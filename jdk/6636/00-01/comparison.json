{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import javax.lang.model.element.ModuleElement;\n@@ -36,0 +35,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -78,1 +78,1 @@\n-        return EnumSet.of(MODULE, PACKAGE);\n+        return EnumSet.of(MODULE, PACKAGE, TYPE);\n@@ -154,0 +154,6 @@\n+            case CLASS:\n+                TypeElement te = (TypeElement)elem;\n+                return te.getQualifiedName()\n+                        .toString()\n+                        .replace('.', '\/')\n+                        .replaceAll(\"[^\/]+\", \"..\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/ToolGuide.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-      NAME := jpackageapplauncher, \\\n+      NAME := jpackageapplauncheraux, \\\n@@ -97,1 +97,1 @@\n-      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncher, \\\n+      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncheraux, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := $(LIBCXX)\n@@ -69,0 +70,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := \/EHsc\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1202,0 +1202,3 @@\n+reg_class p0_reg(P0);\n+reg_class p1_reg(P1);\n+\n@@ -4007,1 +4010,0 @@\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n@@ -4011,3 +4013,0 @@\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont);\n-\n@@ -4019,1 +4018,1 @@\n-    \/\/ flag == EQ was set in the ownership check above\n+    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n@@ -5685,0 +5684,18 @@\n+operand pRegGov_P0()\n+%{\n+  constraint(ALLOC_IN_RC(p0_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand pRegGov_P1()\n+%{\n+  constraint(ALLOC_IN_RC(p1_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -16663,1 +16680,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n@@ -16673,1 +16690,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n@@ -16681,1 +16698,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n@@ -16690,1 +16707,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n@@ -16699,1 +16716,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n@@ -16710,1 +16727,1 @@\n-                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n@@ -16719,1 +16736,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n@@ -16730,1 +16747,1 @@\n-                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -5554,0 +5554,99 @@\n+\/\/ Intrisics for String.compareTo()\n+\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+\n+instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -3047,0 +3047,36 @@\n+\/\/ Intrisics for String.compareTo()\n+\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+dnl\n+define(`STRING_COMPARETO', `\n+instruct string_compare$1_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::$1));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::$1);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}')dnl\n+dnl              $1\n+STRING_COMPARETO(LL)\n+STRING_COMPARETO(LU)\n+STRING_COMPARETO(UL)\n+STRING_COMPARETO(UU)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -481,0 +481,2 @@\n+        assert(offset_ok_for_immed(_offset, size),\n+               \"must be, was: \" INT64_FORMAT \", %d\", _offset, size);\n@@ -482,9 +484,8 @@\n-        if (_offset < 0 || _offset & mask)\n-          {\n-            i->f(0b00, 25, 24);\n-            i->f(0, 21), i->f(0b00, 11, 10);\n-            i->sf(_offset, 20, 12);\n-          } else {\n-            i->f(0b01, 25, 24);\n-            i->f(_offset >> size, 21, 10);\n-          }\n+        if (_offset < 0 || _offset & mask) {\n+          i->f(0b00, 25, 24);\n+          i->f(0, 21), i->f(0b00, 11, 10);\n+          i->sf(_offset, 20, 12);\n+        } else {\n+          i->f(0b01, 25, 24);\n+          i->f(_offset >> size, 21, 10);\n+        }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,1 +33,6 @@\n-\n+\/\/ Check if an offset is within the encoding range for LDR\/STR instructions\n+\/\/ with an immediate offset, either using unscaled signed 9-bits or, scaled\n+\/\/ unsigned 12-bits. We favour the scaled unsigned encoding for all aligned\n+\/\/ offsets (only using the signed 9-bit encoding for negative and unaligned\n+\/\/ offsets). As a precondition, 0 <= shift <= 4 is the log2(size), for the\n+\/\/ supported data widths, {1, 2, 4, 8, 16} bytes.\n@@ -35,0 +40,1 @@\n+  precond(shift < 5);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.inline.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,8 +190,7 @@\n-  } else  {\n-    intptr_t addr_offset = intptr_t(addr->disp());\n-    if (Address::offset_ok_for_immed(addr_offset, addr->scale()))\n-      return Address(base, addr_offset, Address::lsl(addr->scale()));\n-    else {\n-      __ mov(tmp, addr_offset);\n-      return Address(base, tmp, Address::lsl(addr->scale()));\n-    }\n+  } else {\n+    assert(addr->scale() == 0,\n+           \"expected for immediate operand, was: %d\", addr->scale());\n+    ptrdiff_t offset = ptrdiff_t(addr->disp());\n+    \/\/ NOTE: Does not handle any 16 byte vector access.\n+    const uint type_size = type2aelembytes(addr->type(), true);\n+    return __ legitimize_address(Address(base, offset), type_size, tmp);\n@@ -989,8 +988,1 @@\n-      \/\/ FIXME: OMG this is a horrible kludge.  Any offset from an\n-      \/\/ address that matches klass_offset_in_bytes() will be loaded\n-      \/\/ as a word, not a long.\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ ldrw(dest->as_register(), as_Address(from_addr));\n-      } else {\n-        __ ldr(dest->as_register(), as_Address(from_addr));\n-      }\n+      __ ldr(dest->as_register(), as_Address(from_addr));\n@@ -1035,4 +1027,0 @@\n-  } else if (type == T_ADDRESS && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-    if (UseCompressedClassPointers) {\n-      __ decode_klass_not_null(dest->as_register());\n-    }\n@@ -2596,0 +2584,16 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -679,1 +679,2 @@\n-    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {\n+    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+    PRegister pgtmp1, PRegister pgtmp2, int ae) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-                      FloatRegister vtmp2, FloatRegister vtmp3, int ae);\n+                      FloatRegister vtmp2, FloatRegister vtmp3,\n+                      PRegister pgtmp1, PRegister pgtmp2, int ae);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -271,0 +271,2 @@\n+CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,2 @@\n+REGISTER_DEFINITION(PRegister, pnoreg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5034,0 +5034,91 @@\n+  enum string_compare_mode {\n+    LL,\n+    LU,\n+    UL,\n+    UU,\n+  };\n+\n+  \/\/ The following registers are declared in aarch64.ad\n+  \/\/ r0  = result\n+  \/\/ r1  = str1\n+  \/\/ r2  = cnt1\n+  \/\/ r3  = str2\n+  \/\/ r4  = cnt2\n+  \/\/ r10 = tmp1\n+  \/\/ r11 = tmp2\n+  \/\/ z0  = ztmp1\n+  \/\/ z1  = ztmp2\n+  \/\/ p0  = pgtmp1\n+  \/\/ p1  = pgtmp2\n+  address generate_compare_long_string_sve(string_compare_mode mode) {\n+    __ align(CodeEntryAlignment);\n+    address entry = __ pc();\n+    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n+             tmp1 = r10, tmp2 = r11;\n+\n+    Label LOOP, MATCH, DONE, NOMATCH;\n+    Register vec_len = tmp1;\n+    Register idx = tmp2;\n+    \/\/ The minimum of the string lengths has been stored in cnt2.\n+    Register cnt = cnt2;\n+    FloatRegister ztmp1 = z0, ztmp2 = z1;\n+    PRegister pgtmp1 = p0, pgtmp2 = p1;\n+\n+    if (mode == LL) {\n+      __ sve_cntb(vec_len);\n+    } else {\n+      __ sve_cnth(vec_len);\n+    }\n+\n+    __ mov(idx, 0);\n+    __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+\n+    __ bind(LOOP);\n+      switch (mode) {\n+        case LL:\n+          __ sve_ld1b(ztmp1, __ B, pgtmp1, Address(str1, idx));\n+          __ sve_ld1b(ztmp2, __ B, pgtmp1, Address(str2, idx));\n+          break;\n+        case LU:\n+          __ sve_ld1b(ztmp1, __ H, pgtmp1, Address(str1, idx));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        case UL:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1b(ztmp2, __ H, pgtmp1, Address(str2, idx));\n+          break;\n+        case UU:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        default: ShouldNotReachHere();\n+      }\n+      __ add(idx, idx, vec_len);\n+\n+      \/\/ Compare strings.\n+      __ sve_cmp(Assembler::NE, pgtmp2, mode == LL ? __ B : __ H, pgtmp1, ztmp1, ztmp2);\n+      __ br(__ NE, MATCH);\n+      __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+      __ br(__ LT, LOOP);\n+\n+      \/\/ The result has been computed in the caller prior to entering this stub.\n+      __ b(DONE);\n+\n+    __ bind(MATCH);\n+\n+      \/\/ Crop the vector to find its location.\n+      __ sve_brkb(pgtmp2, pgtmp1, pgtmp2, false \/* isMerge *\/);\n+\n+      \/\/ Extract the first different characters of each string.\n+      __ sve_lasta(rscratch1, mode == LL ? __ B : __ H, pgtmp2, ztmp1);\n+      __ sve_lasta(rscratch2, mode == LL ? __ B : __ H, pgtmp2, ztmp2);\n+\n+      \/\/ Compute the difference of the first different characters.\n+      __ sub(result, rscratch1, rscratch2);\n+\n+    __ bind(DONE);\n+      __ ret(lr);\n+\n+    return entry;\n+  }\n+\n@@ -5156,0 +5247,1 @@\n+    if (UseSVE == 0) {\n@@ -5164,0 +5256,10 @@\n+    } else {\n+      StubRoutines::aarch64::_compare_long_string_LL\n+          = generate_compare_long_string_sve(LL);\n+      StubRoutines::aarch64::_compare_long_string_UU\n+          = generate_compare_long_string_sve(UU);\n+      StubRoutines::aarch64::_compare_long_string_LU\n+          = generate_compare_long_string_sve(LU);\n+      StubRoutines::aarch64::_compare_long_string_UL\n+          = generate_compare_long_string_sve(UL);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -723,5 +723,1 @@\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ ldr_u32(dest->as_pointer_register(), as_Address(addr));\n-      } else {\n-        __ ldr(dest->as_pointer_register(), as_Address(addr));\n-      }\n+      __ ldr(dest->as_pointer_register(), as_Address(addr));\n@@ -2448,0 +2444,15 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+  if (UseCompressedClassPointers) { \/\/ On 32 bit arm??\n+    __ ldr_u32(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    __ ldr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -815,6 +815,1 @@\n-        if (offset == oopDesc::klass_offset_in_bytes() && UseCompressedClassPointers) {\n-          __ lwz(to_reg->as_register(), offset, base);\n-          __ decode_klass_not_null(to_reg->as_register());\n-        } else {\n-          __ ld(to_reg->as_register(), offset, base);\n-        }\n+        __ ld(to_reg->as_register(), offset, base);\n@@ -2735,0 +2730,20 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n+      explicit_null_check(obj, info);\n+    } else {\n+      add_debug_info_for_null_check_here(info);\n+    }\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    __ lwz(result, oopDesc::klass_offset_in_bytes(), obj);\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ ld(result, oopDesc::klass_offset_in_bytes(), obj);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -953,6 +953,1 @@\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ z_llgf(dest->as_register(), disp_value, disp_reg, src);\n-        __ decode_klass_not_null(dest->as_register());\n-      } else {\n-        __ z_lg(dest->as_register(), disp_value, disp_reg, src);\n-      }\n+      __ z_lg(dest->as_register(), disp_value, disp_reg, src);\n@@ -2757,0 +2752,16 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    __ z_llgf(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ z_lg(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1187,1 +1187,0 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -1260,5 +1259,1 @@\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ movl(dest->as_register(), from_addr);\n-      } else {\n-        __ movptr(dest->as_register(), from_addr);\n-      }\n+      __ movptr(dest->as_register(), from_addr);\n@@ -1370,6 +1365,0 @@\n-  } else if (type == T_ADDRESS && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-#ifdef _LP64\n-    if (UseCompressedClassPointers) {\n-      __ decode_klass_not_null(dest->as_register(), tmp_load_klass);\n-    }\n-#endif\n@@ -3531,0 +3520,17 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+#ifdef _LP64\n+  if (UseCompressedClassPointers) {\n+    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result, rscratch1);\n+  } else\n+#endif\n+    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -6199,1 +6199,1 @@\n-  predicate(Matcher::vector_length(n) <= 8 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) <= 8 && !n->as_ShiftV()->is_var_shift());\n@@ -6219,1 +6219,1 @@\n-  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && !n->as_ShiftV()->is_var_shift() &&\n@@ -6244,1 +6244,1 @@\n-  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && !n->as_ShiftV()->is_var_shift() &&\n@@ -6265,1 +6265,1 @@\n-  predicate(Matcher::vector_length(n) == 32 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 32 && !n->as_ShiftV()->is_var_shift());\n@@ -6290,1 +6290,1 @@\n-  predicate(Matcher::vector_length(n) == 64 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 64 && !n->as_ShiftV()->is_var_shift());\n@@ -6323,1 +6323,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6354,1 +6354,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6408,1 +6408,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6449,1 +6449,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)) && UseAVX <= 2);\n+  predicate(!n->as_ShiftV()->is_var_shift() && UseAVX <= 2);\n@@ -6478,1 +6478,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)) && UseAVX > 2);\n+  predicate(!n->as_ShiftV()->is_var_shift() && UseAVX > 2);\n@@ -6492,1 +6492,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6512,1 +6512,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6540,1 +6540,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6576,1 +6576,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6595,1 +6595,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6619,1 +6619,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6644,1 +6644,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6679,1 +6679,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(n->as_ShiftV()->is_var_shift() &&\n@@ -6700,1 +6700,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(n->as_ShiftV()->is_var_shift());\n@@ -6717,1 +6717,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(n->as_ShiftV()->is_var_shift());\n@@ -6734,1 +6734,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6749,1 +6749,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(n->as_ShiftV()->is_var_shift() &&\n@@ -9036,0 +9036,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9044,1 +9045,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9046,1 +9046,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vlshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (LShiftVS (Binary dst src2) mask));\n+  match(Set dst (LShiftVI (Binary dst src2) mask));\n+  match(Set dst (LShiftVL (Binary dst src2) mask));\n+  format %{ \"vplshiftv_masked $dst, $dst, $src2, $mask\\t! lshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n@@ -9082,0 +9098,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9090,1 +9107,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9092,1 +9108,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vrshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVS (Binary dst src2) mask));\n+  match(Set dst (RShiftVI (Binary dst src2) mask));\n+  match(Set dst (RShiftVL (Binary dst src2) mask));\n+  format %{ \"vprshiftv_masked $dst, $dst, $src2, $mask\\t! rshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n@@ -9128,0 +9160,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9136,1 +9169,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9138,1 +9170,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vurshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVS (Binary dst src2) mask));\n+  match(Set dst (URShiftVI (Binary dst src2) mask));\n+  match(Set dst (URShiftVL (Binary dst src2) mask));\n+  format %{ \"vpurshiftv_masked $dst, $dst, $src2, $mask\\t! urshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":76,"deletions":28,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-\/\/ No performance work done here yet.\n-define_pd_global(bool, CompactStrings, false);\n+define_pd_global(bool, CompactStrings, true);\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1269,1 +1269,1 @@\n-  BlockListList* _predecessors;\n+  BlockListList* _predecessors; \/\/ Each index i will hold predecessors of block with id i\n@@ -1280,1 +1280,1 @@\n-    _blocks = new BlockList();\n+    _blocks = new BlockList(BlockBegin::number_of_blocks());\n@@ -1282,1 +1282,0 @@\n-    int i;\n@@ -1286,1 +1285,1 @@\n-      for (i = 0; i < _blocks->length(); i++) {\n+      for (int i = 0; i < _blocks->length(); i++) {\n@@ -1291,1 +1290,1 @@\n-    for (i = 0; i < _blocks->length(); i++) {\n+    for (int i = 0; i < _blocks->length(); i++) {\n@@ -1293,21 +1292,1 @@\n-      BlockList* preds = _predecessors->at(block->block_id());\n-      if (preds == NULL) {\n-        assert(block->number_of_preds() == 0, \"should be the same\");\n-        continue;\n-      }\n-\n-      \/\/ clone the pred list so we can mutate it\n-      BlockList* pred_copy = new BlockList();\n-      int j;\n-      for (j = 0; j < block->number_of_preds(); j++) {\n-        pred_copy->append(block->pred_at(j));\n-      }\n-      \/\/ sort them in the same order\n-      preds->sort(cmp);\n-      pred_copy->sort(cmp);\n-      int length = MIN2(preds->length(), block->number_of_preds());\n-      for (j = 0; j < block->number_of_preds(); j++) {\n-        assert(preds->at(j) == pred_copy->at(j), \"must match\");\n-      }\n-\n-      assert(preds->length() == block->number_of_preds(), \"should be the same\");\n+      verify_block_preds_against_collected_preds(block);\n@@ -1319,13 +1298,11 @@\n-    BlockEnd* be = block->end();\n-    int n = be->number_of_sux();\n-    int i;\n-    for (i = 0; i < n; i++) {\n-      BlockBegin* sux = be->sux_at(i);\n-      assert(!sux->is_set(BlockBegin::exception_entry_flag), \"must not be xhandler\");\n-\n-      BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n-      if (preds == NULL) {\n-        preds = new BlockList();\n-        _predecessors->at_put(sux->block_id(), preds);\n-      }\n-      preds->append(block);\n+    verify_successor_xentry_flag(block);\n+    collect_predecessors(block);\n+  }\n+\n+ private:\n+  void verify_successor_xentry_flag(const BlockBegin* block) const {\n+    for (int i = 0; i < block->end()->number_of_sux(); i++) {\n+      assert(!block->end()->sux_at(i)->is_set(BlockBegin::exception_entry_flag), \"must not be xhandler\");\n+    }\n+    for (int i = 0; i < block->number_of_exception_handlers(); i++) {\n+      assert(block->exception_handler_at(i)->is_set(BlockBegin::exception_entry_flag), \"must be xhandler\");\n@@ -1333,0 +1310,1 @@\n+  }\n@@ -1334,4 +1312,8 @@\n-    n = block->number_of_exception_handlers();\n-    for (i = 0; i < n; i++) {\n-      BlockBegin* sux = block->exception_handler_at(i);\n-      assert(sux->is_set(BlockBegin::exception_entry_flag), \"must be xhandler\");\n+  void collect_predecessors(BlockBegin* block) {\n+    for (int i = 0; i < block->end()->number_of_sux(); i++) {\n+      collect_predecessor(block, block->end()->sux_at(i));\n+    }\n+    for (int i = 0; i < block->number_of_exception_handlers(); i++) {\n+      collect_predecessor(block, block->exception_handler_at(i));\n+    }\n+  }\n@@ -1339,6 +1321,27 @@\n-      BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n-      if (preds == NULL) {\n-        preds = new BlockList();\n-        _predecessors->at_put(sux->block_id(), preds);\n-      }\n-      preds->append(block);\n+  void collect_predecessor(BlockBegin* const pred, const BlockBegin* sux) {\n+    BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n+    if (preds == NULL) {\n+      preds = new BlockList();\n+      _predecessors->at_put(sux->block_id(), preds);\n+    }\n+    preds->append(pred);\n+  }\n+\n+  void verify_block_preds_against_collected_preds(const BlockBegin* block) const {\n+    BlockList* preds = _predecessors->at(block->block_id());\n+    if (preds == NULL) {\n+      assert(block->number_of_preds() == 0, \"should be the same\");\n+      return;\n+    }\n+    assert(preds->length() == block->number_of_preds(), \"should be the same\");\n+\n+    \/\/ clone the pred list so we can mutate it\n+    BlockList* pred_copy = new BlockList();\n+    for (int j = 0; j < block->number_of_preds(); j++) {\n+      pred_copy->append(block->pred_at(j));\n+    }\n+    \/\/ sort them in the same order\n+    preds->sort(cmp);\n+    pred_copy->sort(cmp);\n+    for (int j = 0; j < block->number_of_preds(); j++) {\n+      assert(preds->at(j) == pred_copy->at(j), \"must match\");\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":52,"deletions":49,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2001,8 +2001,0 @@\n-  void swap_sux() {\n-    assert(number_of_sux() == 2, \"wrong number of successors\");\n-    BlockList* s = sux();\n-    BlockBegin* t = s->at(0); s->at_put(0, s->at(1)); s->at_put(1, t);\n-    _cond = negate(_cond);\n-    set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -883,0 +883,13 @@\n+\/\/ LIR_OpLoadKlass\n+    case lir_load_klass:\n+    {\n+      LIR_OpLoadKlass* opLoadKlass = op->as_OpLoadKlass();\n+      assert(opLoadKlass != NULL, \"must be\");\n+\n+      do_input(opLoadKlass->_obj);\n+      do_output(opLoadKlass->_result);\n+      if (opLoadKlass->_info) do_info(opLoadKlass->_info);\n+      break;\n+    }\n+\n+\n@@ -1052,0 +1065,4 @@\n+void LIR_OpLoadKlass::emit_code(LIR_Assembler* masm) {\n+  masm->emit_load_klass(this);\n+}\n+\n@@ -1973,0 +1990,5 @@\n+void LIR_OpLoadKlass::print_instr(outputStream* out) const {\n+  obj()->print(out);        out->print(\" \");\n+  result_opr()->print(out); out->print(\" \");\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -898,0 +898,1 @@\n+class    LIR_OpLoadKlass;\n@@ -942,0 +943,1 @@\n+      , lir_load_klass\n@@ -1151,0 +1153,1 @@\n+  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return NULL; }\n@@ -1823,0 +1826,19 @@\n+class LIR_OpLoadKlass: public LIR_Op {\n+  friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr _obj;\n+  CodeEmitInfo* _info;\n+ public:\n+  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info)\n+    : LIR_Op(lir_load_klass, result, NULL)\n+    , _obj(obj)\n+    , _info(info) {}\n+\n+  LIR_Opr obj()        const { return _obj;  }\n+  CodeEmitInfo* info() const { return _info; }\n+\n+  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return this; }\n+  virtual void emit_code(LIR_Assembler* masm);\n+  void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n@@ -2265,0 +2287,3 @@\n+\n+  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info) { append(new LIR_OpLoadKlass(obj, result, info)); }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+  void emit_load_klass(LIR_OpLoadKlass* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1234,0 +1234,4 @@\n+void LIRGenerator::load_klass(LIR_Opr obj, LIR_Opr klass, CodeEmitInfo* null_check_info) {\n+  __ load_klass(obj, klass, null_check_info);\n+}\n+\n@@ -1240,1 +1244,1 @@\n-  LIR_Opr temp = new_register(T_METADATA);\n+  LIR_Opr temp = new_register(T_ADDRESS);\n@@ -1249,4 +1253,3 @@\n-  \/\/ FIXME T_ADDRESS should actually be T_METADATA but it can't because the\n-  \/\/ meaning of these two is mixed up (see JDK-8026837).\n-  __ move(new LIR_Address(rcvr.result(), oopDesc::klass_offset_in_bytes(), T_ADDRESS), temp, info);\n-  __ move_wide(new LIR_Address(temp, in_bytes(Klass::java_mirror_offset()), T_ADDRESS), temp);\n+  LIR_Opr klass = new_register(T_METADATA);\n+  load_klass(rcvr.result(), klass, info);\n+  __ move_wide(new LIR_Address(klass, in_bytes(Klass::java_mirror_offset()), T_ADDRESS), temp);\n@@ -1325,1 +1328,1 @@\n-  __ move(new LIR_Address(value.result(), oopDesc::klass_offset_in_bytes(), T_ADDRESS), klass, NULL);\n+  load_klass(value.result(), klass, NULL);\n@@ -3575,1 +3578,1 @@\n-  __ move(new LIR_Address(array, oopDesc::klass_offset_in_bytes(), T_ADDRESS), klass, null_check_info);\n+  load_klass(array, klass, null_check_info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -242,0 +242,2 @@\n+  void load_klass(LIR_Opr obj, LIR_Opr klass, CodeEmitInfo* null_check_info);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,13 +339,14 @@\n-    if (end->as_Goto() != NULL) {\n-      assert(end->number_of_sux() == 1, \"end must have exactly one successor\");\n-      \/\/ Note: It would be sufficient to check for the number of successors (= 1)\n-      \/\/       in order to decide if this block can be merged potentially. That\n-      \/\/       would then also include switch statements w\/ only a default case.\n-      \/\/       However, in that case we would need to make sure the switch tag\n-      \/\/       expression is executed if it can produce observable side effects.\n-      \/\/       We should probably have the canonicalizer simplifying such switch\n-      \/\/       statements and then we are sure we don't miss these merge opportunities\n-      \/\/       here (was bug - gri 7\/7\/99).\n-      BlockBegin* sux = end->default_sux();\n-      if (sux->number_of_preds() == 1 && !sux->is_entry_block() && !end->is_safepoint()) {\n-        \/\/ merge the two blocks\n+    if (end->as_Goto() == NULL) return false;\n+\n+    assert(end->number_of_sux() == 1, \"end must have exactly one successor\");\n+    \/\/ Note: It would be sufficient to check for the number of successors (= 1)\n+    \/\/       in order to decide if this block can be merged potentially. That\n+    \/\/       would then also include switch statements w\/ only a default case.\n+    \/\/       However, in that case we would need to make sure the switch tag\n+    \/\/       expression is executed if it can produce observable side effects.\n+    \/\/       We should probably have the canonicalizer simplifying such switch\n+    \/\/       statements and then we are sure we don't miss these merge opportunities\n+    \/\/       here (was bug - gri 7\/7\/99).\n+    BlockBegin* sux = end->default_sux();\n+    if (sux->number_of_preds() != 1 || sux->is_entry_block() || end->is_safepoint()) return false;\n+    \/\/ merge the two blocks\n@@ -354,20 +355,20 @@\n-        \/\/ verify that state at the end of block and at the beginning of sux are equal\n-        \/\/ no phi functions must be present at beginning of sux\n-        ValueStack* sux_state = sux->state();\n-        ValueStack* end_state = end->state();\n-\n-        assert(end_state->scope() == sux_state->scope(), \"scopes must match\");\n-        assert(end_state->stack_size() == sux_state->stack_size(), \"stack not equal\");\n-        assert(end_state->locals_size() == sux_state->locals_size(), \"locals not equal\");\n-\n-        int index;\n-        Value sux_value;\n-        for_each_stack_value(sux_state, index, sux_value) {\n-          assert(sux_value == end_state->stack_at(index), \"stack not equal\");\n-        }\n-        for_each_local_value(sux_state, index, sux_value) {\n-          Phi* sux_phi = sux_value->as_Phi();\n-          if (sux_phi != NULL && sux_phi->is_illegal()) continue;\n-          assert(sux_value == end_state->local_at(index), \"locals not equal\");\n-        }\n-        assert(sux_state->caller_state() == end_state->caller_state(), \"caller not equal\");\n+    \/\/ verify that state at the end of block and at the beginning of sux are equal\n+    \/\/ no phi functions must be present at beginning of sux\n+    ValueStack* sux_state = sux->state();\n+    ValueStack* end_state = end->state();\n+\n+    assert(end_state->scope() == sux_state->scope(), \"scopes must match\");\n+    assert(end_state->stack_size() == sux_state->stack_size(), \"stack not equal\");\n+    assert(end_state->locals_size() == sux_state->locals_size(), \"locals not equal\");\n+\n+    int index;\n+    Value sux_value;\n+    for_each_stack_value(sux_state, index, sux_value) {\n+      assert(sux_value == end_state->stack_at(index), \"stack not equal\");\n+    }\n+    for_each_local_value(sux_state, index, sux_value) {\n+      Phi* sux_phi = sux_value->as_Phi();\n+      if (sux_phi != NULL && sux_phi->is_illegal()) continue;\n+      assert(sux_value == end_state->local_at(index), \"locals not equal\");\n+    }\n+    assert(sux_state->caller_state() == end_state->caller_state(), \"caller not equal\");\n@@ -376,20 +377,12 @@\n-        \/\/ find instruction before end & append first instruction of sux block\n-        Instruction* prev = end->prev();\n-        Instruction* next = sux->next();\n-        assert(prev->as_BlockEnd() == NULL, \"must not be a BlockEnd\");\n-        prev->set_next(next);\n-        prev->fixup_block_pointers();\n-        sux->disconnect_from_graph();\n-        block->set_end(sux->end());\n-        \/\/ add exception handlers of deleted block, if any\n-        for (int k = 0; k < sux->number_of_exception_handlers(); k++) {\n-          BlockBegin* xhandler = sux->exception_handler_at(k);\n-          block->add_exception_handler(xhandler);\n-\n-          \/\/ also substitute predecessor of exception handler\n-          assert(xhandler->is_predecessor(sux), \"missing predecessor\");\n-          xhandler->remove_predecessor(sux);\n-          if (!xhandler->is_predecessor(block)) {\n-            xhandler->add_predecessor(block);\n-          }\n-        }\n+    \/\/ find instruction before end & append first instruction of sux block\n+    Instruction* prev = end->prev();\n+    Instruction* next = sux->next();\n+    assert(prev->as_BlockEnd() == NULL, \"must not be a BlockEnd\");\n+    prev->set_next(next);\n+    prev->fixup_block_pointers();\n+    sux->disconnect_from_graph();\n+    block->set_end(sux->end());\n+    \/\/ add exception handlers of deleted block, if any\n+    for (int k = 0; k < sux->number_of_exception_handlers(); k++) {\n+      BlockBegin* xhandler = sux->exception_handler_at(k);\n+      block->add_exception_handler(xhandler);\n@@ -397,6 +390,7 @@\n-        \/\/ debugging output\n-        _merge_count++;\n-        if (PrintBlockElimination) {\n-          tty->print_cr(\"%d. merged B%d & B%d (stack size = %d)\",\n-                        _merge_count, block->block_id(), sux->block_id(), sux->state()->stack_size());\n-        }\n+      \/\/ also substitute predecessor of exception handler\n+      assert(xhandler->is_predecessor(sux), \"missing predecessor\");\n+      xhandler->remove_predecessor(sux);\n+      if (!xhandler->is_predecessor(block)) {\n+        xhandler->add_predecessor(block);\n+      }\n+    }\n@@ -404,11 +398,30 @@\n-        _hir->verify();\n-\n-        If* if_ = block->end()->as_If();\n-        if (if_) {\n-          IfOp* ifop    = if_->x()->as_IfOp();\n-          Constant* con = if_->y()->as_Constant();\n-          bool swapped = false;\n-          if (!con || !ifop) {\n-            ifop = if_->y()->as_IfOp();\n-            con  = if_->x()->as_Constant();\n-            swapped = true;\n+    \/\/ debugging output\n+    _merge_count++;\n+    if (PrintBlockElimination) {\n+      tty->print_cr(\"%d. merged B%d & B%d (stack size = %d)\",\n+                    _merge_count, block->block_id(), sux->block_id(), sux->state()->stack_size());\n+    }\n+\n+    _hir->verify();\n+\n+    If* if_ = block->end()->as_If();\n+    if (if_) {\n+      IfOp* ifop    = if_->x()->as_IfOp();\n+      Constant* con = if_->y()->as_Constant();\n+      bool swapped = false;\n+      if (!con || !ifop) {\n+        ifop = if_->y()->as_IfOp();\n+        con  = if_->x()->as_Constant();\n+        swapped = true;\n+      }\n+      if (con && ifop) {\n+        Constant* tval = ifop->tval()->as_Constant();\n+        Constant* fval = ifop->fval()->as_Constant();\n+        if (tval && fval) {\n+          \/\/ Find the instruction before if_, starting with ifop.\n+          \/\/ When if_ and ifop are not in the same block, prev\n+          \/\/ becomes NULL In such (rare) cases it is not\n+          \/\/ profitable to perform the optimization.\n+          Value prev = ifop;\n+          while (prev != NULL && prev->next() != if_) {\n+            prev = prev->next();\n@@ -416,12 +429,0 @@\n-          if (con && ifop) {\n-            Constant* tval = ifop->tval()->as_Constant();\n-            Constant* fval = ifop->fval()->as_Constant();\n-            if (tval && fval) {\n-              \/\/ Find the instruction before if_, starting with ifop.\n-              \/\/ When if_ and ifop are not in the same block, prev\n-              \/\/ becomes NULL In such (rare) cases it is not\n-              \/\/ profitable to perform the optimization.\n-              Value prev = ifop;\n-              while (prev != NULL && prev->next() != if_) {\n-                prev = prev->next();\n-              }\n@@ -429,27 +430,23 @@\n-              if (prev != NULL) {\n-                Instruction::Condition cond = if_->cond();\n-                BlockBegin* tsux = if_->tsux();\n-                BlockBegin* fsux = if_->fsux();\n-                if (swapped) {\n-                  cond = Instruction::mirror(cond);\n-                }\n-\n-                BlockBegin* tblock = tval->compare(cond, con, tsux, fsux);\n-                BlockBegin* fblock = fval->compare(cond, con, tsux, fsux);\n-                if (tblock != fblock && !if_->is_safepoint()) {\n-                  If* newif = new If(ifop->x(), ifop->cond(), false, ifop->y(),\n-                                     tblock, fblock, if_->state_before(), if_->is_safepoint());\n-                  newif->set_state(if_->state()->copy());\n-\n-                  assert(prev->next() == if_, \"must be guaranteed by above search\");\n-                  NOT_PRODUCT(newif->set_printable_bci(if_->printable_bci()));\n-                  prev->set_next(newif);\n-                  block->set_end(newif);\n-\n-                  _merge_count++;\n-                  if (PrintBlockElimination) {\n-                    tty->print_cr(\"%d. replaced If and IfOp at end of B%d with single If\", _merge_count, block->block_id());\n-                  }\n-\n-                  _hir->verify();\n-                }\n+          if (prev != NULL) {\n+            Instruction::Condition cond = if_->cond();\n+            BlockBegin* tsux = if_->tsux();\n+            BlockBegin* fsux = if_->fsux();\n+            if (swapped) {\n+              cond = Instruction::mirror(cond);\n+            }\n+\n+            BlockBegin* tblock = tval->compare(cond, con, tsux, fsux);\n+            BlockBegin* fblock = fval->compare(cond, con, tsux, fsux);\n+            if (tblock != fblock && !if_->is_safepoint()) {\n+              If* newif = new If(ifop->x(), ifop->cond(), false, ifop->y(),\n+                                 tblock, fblock, if_->state_before(), if_->is_safepoint());\n+              newif->set_state(if_->state()->copy());\n+\n+              assert(prev->next() == if_, \"must be guaranteed by above search\");\n+              NOT_PRODUCT(newif->set_printable_bci(if_->printable_bci()));\n+              prev->set_next(newif);\n+              block->set_end(newif);\n+\n+              _merge_count++;\n+              if (PrintBlockElimination) {\n+                tty->print_cr(\"%d. replaced If and IfOp at end of B%d with single If\", _merge_count, block->block_id());\n@@ -457,0 +454,2 @@\n+\n+              _hir->verify();\n@@ -460,2 +459,0 @@\n-\n-        return true;\n@@ -464,1 +461,2 @@\n-    return false;\n+\n+    return true;\n@@ -468,1 +466,0 @@\n-    _hir->verify();\n@@ -470,3 +467,1 @@\n-    while (try_merge(block)) {\n-      _hir->verify();\n-    }\n+    while (try_merge(block)) ;\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":111,"deletions":116,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -1657,0 +1657,1 @@\n+\n@@ -1659,1 +1660,2 @@\n-  out->print_cr(\"instanceKlass %s\", CURRENT_ENV->replay_name(task()->method()->method_holder()));\n+  ciInstanceKlass::dump_replay_instanceKlass(out, task()->method()->method_holder());\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -735,0 +735,13 @@\n+void ciInstanceKlass::dump_replay_instanceKlass(outputStream* out, InstanceKlass* ik) {\n+  if (ik->is_hidden()) {\n+    const char *name = CURRENT_ENV->dyno_name(ik);\n+    if (name != NULL) {\n+      out->print_cr(\"instanceKlass %s # %s\", name, ik->name()->as_quoted_ascii());\n+    } else {\n+      out->print_cr(\"# instanceKlass %s\", ik->name()->as_quoted_ascii());\n+    }\n+  } else {\n+    out->print_cr(\"instanceKlass %s\", ik->name()->as_quoted_ascii());\n+  }\n+}\n+\n@@ -746,10 +759,1 @@\n-      if (isub->is_hidden()) {\n-        const char *name = CURRENT_ENV->dyno_name(isub);\n-        if (name != NULL) {\n-          out->print_cr(\"instanceKlass %s # %s\", name, sub->name()->as_quoted_ascii());\n-        } else {\n-          out->print_cr(\"# instanceKlass %s\", sub->name()->as_quoted_ascii());\n-        }\n-      } else {\n-        out->print_cr(\"instanceKlass %s\", sub->name()->as_quoted_ascii());\n-      }\n+      dump_replay_instanceKlass(out, isub);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -296,0 +296,3 @@\n+  static void dump_replay_instanceKlass(outputStream* out, InstanceKlass* ik);\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  bool _inline_late;\n@@ -723,1 +724,1 @@\n-  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <klass> <name> <signature>)*\n+  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <inline_late> <klass> <name> <signature>)*\n@@ -765,0 +766,8 @@\n+        int inline_late = 0;\n+        if (_version >= 2) {\n+          inline_late = parse_int(\"inline_late\");\n+          if (had_error()) {\n+              break;\n+          }\n+        }\n+\n@@ -769,1 +778,1 @@\n-        new_ciInlineRecord(inl_method, bci, depth);\n+        new_ciInlineRecord(inl_method, bci, depth, inline_late);\n@@ -1230,1 +1239,1 @@\n-  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {\n+  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth, int inline_late) {\n@@ -1237,0 +1246,1 @@\n+    rec->_inline_late = inline_late;\n@@ -1473,1 +1483,1 @@\n-bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {\n+bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay) {\n@@ -1475,1 +1485,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n@@ -1478,1 +1488,6 @@\n-    return CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1482,1 +1497,6 @@\n-    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1489,1 +1509,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth);\n+  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay);\n@@ -138,1 +138,2 @@\n-#define REPLAY_VERSION 1 \/\/ current version, bump up for incompatible changes\n+\/\/ 2: incremental inlining support (8254108)\n+#define REPLAY_VERSION 2 \/\/ current version, bump up for incompatible changes\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,12 +29,17 @@\n- *\n- * SipHash reference C implementation\n- *\n- * Copyright (c) 2016 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>\n- *\n- * To the extent possible under law, the author(s) have dedicated all copyright\n- * and related and neighboring rights to this software to the public domain\n- * worldwide. This software is distributed without any warranty.\n- *\n- * You should have received a copy of the CC0 Public Domain Dedication along\n- * with this software. If not, see\n- * <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>.\n+ *\/\n+\n+\/*\n+   SipHash reference C implementation\n+\n+   Copyright (c) 2012-2021 Jean-Philippe Aumasson\n+   <jeanphilippe.aumasson@gmail.com>\n+   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>\n+\n+   To the extent possible under law, the author(s) have dedicated all copyright\n+   and related and neighboring rights to this software to the public domain\n+   worldwide. This software is distributed without any warranty.\n+\n+   You should have received a copy of the CC0 Public Domain Dedication along\n+   with\n+   this software. If not, see\n+   <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>.\n@@ -138,1 +143,3 @@\n-uint32_t AltHashing::halfsiphash_32(uint64_t seed, const uint8_t* data, int len) {\n+uint32_t AltHashing::halfsiphash_32(uint64_t seed, const void* in, int len) {\n+\n+  const unsigned char* data = (const unsigned char*)in;\n","filename":"src\/hotspot\/share\/classfile\/altHashing.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  static uint32_t halfsiphash_32(uint64_t seed, const uint8_t* data, int len);\n+  static uint32_t halfsiphash_32(uint64_t seed, const void* in, int len);\n","filename":"src\/hotspot\/share\/classfile\/altHashing.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -354,1 +354,0 @@\n-  template(jdk_incubator_foreign_MemoryAccess,       \"jdk\/incubator\/foreign\/MemoryAccess\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+  _last = NULL;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,2 +138,2 @@\n-    uint num_cards_in_inline_ptr = G1CardSetConfiguration::num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n-    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr * 2,\n+    uint max_cards_in_inline_ptr = G1CardSetConfiguration::max_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n+    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(max_cards_in_inline_ptr * 2,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  uint log2_card_region_per_heap_region = 0;\n+  uint log2_card_regions_per_heap_region = 0;\n@@ -52,1 +52,1 @@\n-    log2_card_region_per_heap_region = (uint)HeapRegion::LogCardsPerRegion - card_container_limit;\n+    log2_card_regions_per_heap_region = (uint)HeapRegion::LogCardsPerRegion - card_container_limit;\n@@ -55,1 +55,1 @@\n-  return log2_card_region_per_heap_region;\n+  return log2_card_regions_per_heap_region;\n@@ -60,1 +60,1 @@\n-                         G1RemSetArrayOfCardsEntries,                               \/* num_cards_in_array *\/\n+                         G1RemSetArrayOfCardsEntries,                               \/* max_cards_in_array *\/\n@@ -67,1 +67,1 @@\n-  assert((_log2_card_region_per_heap_region + _log2_cards_per_card_region) == (uint)HeapRegion::LogCardsPerRegion,\n+  assert((_log2_card_regions_per_heap_region + _log2_cards_per_card_region) == (uint)HeapRegion::LogCardsPerRegion,\n@@ -71,1 +71,1 @@\n-G1CardSetConfiguration::G1CardSetConfiguration(uint num_cards_in_array,\n+G1CardSetConfiguration::G1CardSetConfiguration(uint max_cards_in_array,\n@@ -78,1 +78,1 @@\n-                         num_cards_in_array,                                   \/* num_cards_in_array *\/\n+                         max_cards_in_array,                                   \/* max_cards_in_array *\/\n@@ -81,1 +81,1 @@\n-                                                    num_cards_in_array,\n+                                                    max_cards_in_array,\n@@ -89,1 +89,1 @@\n-                                               uint num_cards_in_array,\n+                                               uint max_cards_in_array,\n@@ -94,1 +94,1 @@\n-                                               uint log2_card_region_per_heap_region) :\n+                                               uint log2_card_regions_per_heap_region) :\n@@ -96,1 +96,1 @@\n-  _num_cards_in_array(num_cards_in_array),\n+  _max_cards_in_array(max_cards_in_array),\n@@ -100,6 +100,6 @@\n-  _num_cards_in_howl_bitmap(G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl)),\n-  _cards_in_howl_bitmap_threshold(_num_cards_in_howl_bitmap * cards_in_bitmap_threshold_percent),\n-  _log2_num_cards_in_howl_bitmap(log2i_exact(_num_cards_in_howl_bitmap)),\n-  _bitmap_hash_mask(~(~(0) << _log2_num_cards_in_howl_bitmap)),\n-  _log2_card_region_per_heap_region(log2_card_region_per_heap_region),\n-  _log2_cards_per_card_region(log2i_exact(_max_cards_in_card_set) - _log2_card_region_per_heap_region) {\n+  _max_cards_in_howl_bitmap(G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl)),\n+  _cards_in_howl_bitmap_threshold(_max_cards_in_howl_bitmap * cards_in_bitmap_threshold_percent),\n+  _log2_max_cards_in_howl_bitmap(log2i_exact(_max_cards_in_howl_bitmap)),\n+  _bitmap_hash_mask(~(~(0) << _log2_max_cards_in_howl_bitmap)),\n+  _log2_card_regions_per_heap_region(log2_card_regions_per_heap_region),\n+  _log2_cards_per_card_region(log2i_exact(_max_cards_in_card_set) - _log2_card_regions_per_heap_region) {\n@@ -121,2 +121,2 @@\n-  new (&_card_set_alloc_options[1]) G1CardSetAllocOptions((uint)G1CardSetArray::size_in_bytes(_num_cards_in_array), 2, 256);\n-  new (&_card_set_alloc_options[2]) G1CardSetAllocOptions((uint)G1CardSetBitMap::size_in_bytes(_num_cards_in_howl_bitmap), 2, 256);\n+  new (&_card_set_alloc_options[1]) G1CardSetAllocOptions((uint)G1CardSetArray::size_in_bytes(_max_cards_in_array), 2, 256);\n+  new (&_card_set_alloc_options[2]) G1CardSetAllocOptions((uint)G1CardSetBitMap::size_in_bytes(_max_cards_in_howl_bitmap), 2, 256);\n@@ -133,2 +133,2 @@\n-                          num_cards_in_inline_ptr(), sizeof(void*),\n-                          num_cards_in_array(), G1CardSetArray::size_in_bytes(num_cards_in_array()),\n+                          max_cards_in_inline_ptr(), sizeof(void*),\n+                          max_cards_in_array(), G1CardSetArray::size_in_bytes(max_cards_in_array()),\n@@ -136,2 +136,2 @@\n-                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold(),\n-                          (uint)1 << log2_card_region_per_heap_region(),\n+                          max_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(max_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold(),\n+                          (uint)1 << log2_card_regions_per_heap_region(),\n@@ -141,2 +141,2 @@\n-uint G1CardSetConfiguration::num_cards_in_inline_ptr() const {\n-  return num_cards_in_inline_ptr(_inline_ptr_bits_per_card);\n+uint G1CardSetConfiguration::max_cards_in_inline_ptr() const {\n+  return max_cards_in_inline_ptr(_inline_ptr_bits_per_card);\n@@ -145,1 +145,1 @@\n-uint G1CardSetConfiguration::num_cards_in_inline_ptr(uint bits_per_card) {\n+uint G1CardSetConfiguration::max_cards_in_inline_ptr(uint bits_per_card) {\n@@ -511,1 +511,1 @@\n-  return bitmap->add(card_offset, _config->cards_in_howl_bitmap_threshold(), _config->num_cards_in_howl_bitmap());\n+  return bitmap->add(card_offset, _config->cards_in_howl_bitmap_threshold(), _config->max_cards_in_howl_bitmap());\n@@ -516,1 +516,1 @@\n-  return value.add(card_in_region, _config->inline_ptr_bits_per_card(), _config->num_cards_in_inline_ptr());\n+  return value.add(card_in_region, _config->inline_ptr_bits_per_card(), _config->max_cards_in_inline_ptr());\n@@ -523,1 +523,1 @@\n-    uint const size_in_bits = _config->num_cards_in_howl_bitmap();\n+    uint const size_in_bits = _config->max_cards_in_howl_bitmap();\n@@ -552,1 +552,1 @@\n-      uint const size = _config->num_cards_in_array();\n+      uint const size = _config->max_cards_in_array();\n@@ -629,1 +629,1 @@\n-    uint diff = _config->num_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n+    uint diff = _config->max_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n@@ -758,1 +758,1 @@\n-    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->num_cards_in_howl_bitmap());\n+    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->max_cards_in_howl_bitmap());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  uint _num_cards_in_array;\n+  uint _max_cards_in_array;\n@@ -57,1 +57,1 @@\n-  uint _num_cards_in_howl_bitmap;\n+  uint _max_cards_in_howl_bitmap;\n@@ -59,1 +59,1 @@\n-  uint _log2_num_cards_in_howl_bitmap;\n+  uint _log2_max_cards_in_howl_bitmap;\n@@ -61,1 +61,1 @@\n-  uint _log2_card_region_per_heap_region;\n+  uint _log2_card_regions_per_heap_region;\n@@ -67,1 +67,1 @@\n-                         uint num_cards_in_array,\n+                         uint max_cards_in_array,\n@@ -72,1 +72,1 @@\n-                         uint log2_card_region_per_heap_region);\n+                         uint log2_card_regions_per_heap_region);\n@@ -82,1 +82,1 @@\n-  G1CardSetConfiguration(uint num_cards_in_array,\n+  G1CardSetConfiguration(uint max_cards_in_array,\n@@ -93,2 +93,2 @@\n-  uint num_cards_in_inline_ptr() const;\n-  static uint num_cards_in_inline_ptr(uint bits_per_card);\n+  uint max_cards_in_inline_ptr() const;\n+  static uint max_cards_in_inline_ptr(uint bits_per_card);\n@@ -97,2 +97,1 @@\n-  bool use_cards_in_array() const { return _num_cards_in_array != 0; } \/\/ Unused for now\n-  \/\/ Number of cards in \"Array of Cards\" set; 0 to disable.\n+  \/\/ Maximum number of cards in \"Array of Cards\" set; 0 to disable.\n@@ -100,1 +99,1 @@\n-  uint num_cards_in_array() const { return _num_cards_in_array; }\n+  uint max_cards_in_array() const { return _max_cards_in_array; }\n@@ -103,2 +102,1 @@\n-  bool use_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap != 0; } \/\/ Unused for now\n-  uint num_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap; }\n+  uint max_cards_in_howl_bitmap() const { return _max_cards_in_howl_bitmap; }\n@@ -107,1 +105,1 @@\n-  uint log2_num_cards_in_howl_bitmap() const {return _log2_num_cards_in_howl_bitmap;}\n+  uint log2_max_cards_in_howl_bitmap() const {return _log2_max_cards_in_howl_bitmap;}\n@@ -115,1 +113,1 @@\n-  uint howl_bucket_index(uint card_idx) { return card_idx >> _log2_num_cards_in_howl_bitmap; }\n+  uint howl_bucket_index(uint card_idx) { return card_idx >> _log2_max_cards_in_howl_bitmap; }\n@@ -130,2 +128,2 @@\n-  \/\/ The log2 of the amount of card regions per heap region configured.\n-  uint log2_card_region_per_heap_region() const { return _log2_card_region_per_heap_region; }\n+  \/\/ The log2 of the number of card regions per heap region configured.\n+  uint log2_card_regions_per_heap_region() const { return _log2_card_regions_per_heap_region; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  size_t max_entries() const { return _size; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-  _num_entries((config->num_cards_in_array() + 1)) \/* Card Transfer will not increment _num_entries *\/ {\n+  _num_entries((config->max_cards_in_array() + 1)) \/* Card Transfer will not increment _num_entries *\/ {\n@@ -262,1 +262,1 @@\n-      value.add(card_in_region, config->inline_ptr_bits_per_card(), config->num_cards_in_inline_ptr());\n+      value.add(card_in_region, config->inline_ptr_bits_per_card(), config->max_cards_in_inline_ptr());\n@@ -278,1 +278,1 @@\n-      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->num_cards_in_howl_bitmap());\n+      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->max_cards_in_howl_bitmap());\n@@ -324,2 +324,2 @@\n-        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n-        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->num_cards_in_howl_bitmap(), offset);\n+        uint offset = index << config->log2_max_cards_in_howl_bitmap();\n+        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->max_cards_in_howl_bitmap(), offset);\n@@ -332,2 +332,2 @@\n-        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n-        found(offset, config->num_cards_in_howl_bitmap());\n+        uint offset = index << config->log2_max_cards_in_howl_bitmap();\n+        found(offset, config->max_cards_in_howl_bitmap());\n@@ -340,1 +340,1 @@\n-inline G1CardSetHowl::EntryCountType G1CardSetHowl::num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_num_buckets) {\n+inline G1CardSetHowl::EntryCountType G1CardSetHowl::num_buckets(size_t size_in_bits, size_t max_cards_in_array, size_t max_num_buckets) {\n@@ -345,1 +345,1 @@\n-  size_t size_array_bytes = num_cards_in_array * sizeof(G1CardSetArray::EntryDataType);\n+  size_t size_array_bytes = max_cards_in_array * sizeof(G1CardSetArray::EntryDataType);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n-#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n-#include \"heapRegionRemSet.hpp\"\n-#include \"ci\/ciUtilities.hpp\"\n-\n-constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n-\n-const char* G1CardSetFreeMemoryTask::get_state_name(State value) const {\n-  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n-}\n-\n-bool G1CardSetFreeMemoryTask::deadline_exceeded(jlong deadline) {\n-  return os::elapsed_counter() >= deadline;\n-}\n-\n-static size_t keep_size(size_t free, size_t used, double percent) {\n-  size_t to_keep = used * percent;\n-  return MIN2(free, to_keep);\n-}\n-\n-bool G1CardSetFreeMemoryTask::calculate_return_infos(jlong deadline) {\n-  \/\/ Ignore the deadline in this step as it is very short.\n-\n-  G1CardSetMemoryStats used = _total_used;\n-  G1CardSetMemoryStats free = G1CardSetFreePool::free_list_sizes();\n-\n-  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n-  for (uint i = 0; i < used.num_pools(); i++) {\n-    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n-                                         used._num_mem_sizes[i],\n-                                         G1RemSetFreeMemoryKeepExcessRatio);\n-    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n-                        \"Used: %zu Keep: %zu\",\n-                        G1CardSetConfiguration::mem_object_type_name_str(i),\n-                        free._num_mem_sizes[i], free._num_buffers[i],\n-                        used._num_mem_sizes[i], return_to_vm_size);\n-\n-    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n-  }\n-\n-  G1CardSetFreePool::update_unlink_processors(_return_info);\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-    G1ReturnMemoryProcessor* info = _return_info->at(i);\n-    if (!info->finished_return_to_vm()) {\n-      if (info->return_to_vm(deadline)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::return_memory_to_os(jlong deadline) {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-    G1ReturnMemoryProcessor* info = _return_info->at(i);\n-    if (!info->finished_return_to_os()) {\n-      if (info->return_to_os(deadline)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::cleanup_return_infos() {\n-  for (int i = 0; i < _return_info->length(); i++) {\n-     G1ReturnMemoryProcessor* info = _return_info->at(i);\n-     delete info;\n-  }\n-  delete _return_info;\n-\n-  _return_info = nullptr;\n-  return false;\n-}\n-\n-bool G1CardSetFreeMemoryTask::free_excess_card_set_memory() {\n-  jlong start = os::elapsed_counter();\n-  jlong end = start +\n-              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n-                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n-\n-  State next_state;\n-\n-  do {\n-    switch (_state) {\n-      case State::CalculateUsed: {\n-        if (calculate_return_infos(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::ReturnToVM;\n-        break;\n-      }\n-      case State::ReturnToVM: {\n-        if (return_memory_to_vm(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::ReturnToOS;\n-        break;\n-      }\n-      case State::ReturnToOS: {\n-        if (return_memory_to_os(end)) {\n-          next_state = _state;\n-          return true;\n-        }\n-        next_state = State::Cleanup;\n-        break;\n-      }\n-      case State::Cleanup: {\n-        cleanup_return_infos();\n-        next_state = State::Inactive;\n-        break;\n-      }\n-      default:\n-        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n-        ShouldNotReachHere();\n-        break;\n-    }\n-\n-    set_state(next_state);\n-  } while (_state != State::Inactive && !deadline_exceeded(end));\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n-                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n-                      bool_to_str(_state == State::CalculateUsed));\n-\n-  return is_active();\n-}\n-\n-void G1CardSetFreeMemoryTask::set_state(State new_state) {\n-  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n-                      get_state_name(_state),\n-                      get_state_name(new_state));\n-  _state = new_state;\n-}\n-\n-bool G1CardSetFreeMemoryTask::is_active() const {\n-  return _state != State::Inactive;\n-}\n-\n-jlong G1CardSetFreeMemoryTask::reschedule_delay_ms() const {\n-  return G1RemSetFreeMemoryRescheduleDelayMillis;\n-}\n-\n-G1CardSetFreeMemoryTask::G1CardSetFreeMemoryTask(const char* name) :\n-  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n-\n-void G1CardSetFreeMemoryTask::execute() {\n-  SuspendibleThreadSetJoiner sts;\n-\n-  if (free_excess_card_set_memory()) {\n-    schedule(reschedule_delay_ms());\n-  }\n-}\n-\n-void G1CardSetFreeMemoryTask::notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n-                                               G1CardSetMemoryStats* collection_set_candidate_stats) {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  _total_used = *young_gen_stats;\n-  _total_used.add(*collection_set_candidate_stats);\n-\n-  if (!is_active()) {\n-    set_state(State::CalculateUsed);\n-    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n-#define SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n-\n-#include \"gc\/g1\/g1ServiceThread.hpp\"\n-#include \"gc\/g1\/g1CardSetMemory.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-\/\/ Task handling deallocation of free card set memory.\n-class G1CardSetFreeMemoryTask : public G1ServiceTask {\n-\n-  enum class State : uint {\n-    Inactive,\n-    CalculateUsed,\n-    ReturnToVM,\n-    ReturnToOS,\n-    Cleanup\n-  };\n-\n-  static constexpr const char* _state_names[] = { \"Invalid\",\n-                                                  \"CalculateUsed\",\n-                                                  \"ReturnToVM\",\n-                                                  \"ReturnToOS\",\n-                                                  \"Cleanup\" };\n-\n-  const char* get_state_name(State value) const;\n-\n-  State _state;\n-\n-  \/\/ Current total card set memory usage.\n-  G1CardSetMemoryStats _total_used;\n-\n-  typedef G1CardSetFreePool::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n-  typedef G1CardSetFreePool::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n-\n-  G1ReturnMemoryProcessorSet* _return_info;\n-\n-  \/\/ Returns whether the given deadline has passed.\n-  bool deadline_exceeded(jlong deadline);\n-\n-  \/\/ Methods for the tasks to be done. They all return true if that step has\n-  \/\/ completed.\n-  bool calculate_return_infos(jlong deadline);\n-  bool return_memory_to_vm(jlong deadline);\n-  bool return_memory_to_os(jlong deadline);\n-  bool cleanup_return_infos();\n-\n-  \/\/ Free excess card set memory, main method. Returns true if there is more work\n-  \/\/ to do.\n-  bool free_excess_card_set_memory();\n-\n-  void set_state(State new_state);\n-  \/\/ Returns whether we are currently processing a recent request.\n-  bool is_active() const;\n-\n-  \/\/ The delay used to reschedule this task if not all work has been completed.\n-  jlong reschedule_delay_ms() const;\n-\n-public:\n-  explicit G1CardSetFreeMemoryTask(const char* name);\n-\n-  void execute() override;\n-\n-  \/\/ Notify the task of new used remembered set memory statistics for the young\n-  \/\/ generation and the collection set candidate sets.\n-  void notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n-                        G1CardSetMemoryStats* collection_set_candidate_stats);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"logging\/log.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -34,1 +33,0 @@\n-\n@@ -145,160 +143,0 @@\n-G1CardSetMemoryStats::G1CardSetMemoryStats() {\n-  clear();\n-}\n-\n-void G1CardSetMemoryStats::clear() {\n-  for (uint i = 0; i < num_pools(); i++) {\n-    _num_mem_sizes[i] = 0;\n-    _num_buffers[i] = 0;\n-  }\n-}\n-\n-void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n-  uint num_free_lists = _freelist_pool.num_free_lists();\n-\n-  for (uint i = 0; i < num_free_lists; i++) {\n-    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n-  }\n-}\n-\n-void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n-  assert(_source == nullptr, \"already visited\");\n-  if (_return_to_vm_size > 0) {\n-    _source = source;\n-  } else {\n-    assert(_source == nullptr, \"must be\");\n-  }\n-  if (source->mem_size() > _return_to_vm_size) {\n-    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n-  } else {\n-    assert(_first == nullptr, \"must be\");\n-  }\n-  \/\/ Above we were racing with other threads getting the contents of the free list,\n-  \/\/ so while we might have been asked to return something to the OS initially,\n-  \/\/ the free list might be empty anyway. In this case just reset internal values\n-  \/\/ used for checking whether there is work available.\n-  if (_first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n-  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n-  assert(_first != nullptr, \"must have element to return\");\n-\n-  size_t keep_size = 0;\n-  size_t keep_num = 0;\n-\n-  G1CardSetBuffer* cur = _first;\n-  G1CardSetBuffer* last = nullptr;\n-\n-  while (cur != nullptr && _return_to_vm_size > 0) {\n-    size_t cur_size = cur->mem_size();\n-    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n-\n-    keep_size += cur_size;\n-    keep_num++;\n-\n-    last = cur;\n-    cur = cur->next();\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  assert(_first != nullptr, \"must be\");\n-  assert(last != nullptr, \"must be\");\n-\n-  last->set_next(nullptr);\n-\n-  \/\/ Wait for any in-progress pops to avoid ABA for them.\n-  GlobalCounter::write_synchronize();\n-  _source->bulk_add(*_first, *last, keep_num, keep_size);\n-  _first = cur;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n-\n-  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n-  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n-  \/\/ inconsistent.\n-  \/\/ So also check if we actually already at the end of the list for the exit\n-  \/\/ condition.\n-  if (_return_to_vm_size == 0 || _first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-  return _source != nullptr;\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n-  assert(finished_return_to_vm(), \"not finished returning to VM\");\n-  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n-\n-  \/\/ Now delete the rest.\n-  size_t num_delete = 0;\n-  size_t mem_size_deleted = 0;\n-\n-  while (_first != nullptr) {\n-    G1CardSetBuffer* next = _first->next();\n-    num_delete++;\n-    mem_size_deleted += _first->mem_size();\n-    delete _first;\n-    _first = next;\n-\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n-\n-  return _first != nullptr;\n-}\n-\n-G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n-\n-G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n-  _num_free_lists(num_free_lists) {\n-\n-  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    new (&_free_lists[i]) G1CardSetBufferList();\n-  }\n-}\n-\n-G1CardSetFreePool::~G1CardSetFreePool() {\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    _free_lists[i].~G1CardSetBufferList();\n-  }\n-  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n-}\n-\n-G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n-  G1CardSetMemoryStats free_list_stats;\n-  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n-  for (uint i = 0; i < num_free_lists(); i++) {\n-    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n-    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n-  }\n-  return free_list_stats;\n-}\n-\n-size_t G1CardSetFreePool::mem_size() const {\n-  size_t result = 0;\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    result += _free_lists[i].mem_size();\n-  }\n-  return result;\n-}\n-\n-void G1CardSetFreePool::print_on(outputStream* out) {\n-  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n-    _free_lists[i].print_on(out, fmt);\n-  }\n-}\n-\n@@ -366,2 +204,2 @@\n-G1CardSetMemoryStats G1CardSetMemoryManager::memory_stats() const {\n-  G1CardSetMemoryStats result;\n+G1SegmentedArrayMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1SegmentedArrayMemoryStats result;\n@@ -370,1 +208,1 @@\n-    result._num_buffers[i] += _allocators[i].num_buffers();\n+    result._num_segments[i] += _allocators[i].num_buffers();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":4,"deletions":166,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -139,92 +139,1 @@\n-\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n-\/\/ used for each. Note that statistics are typically not taken atomically so there\n-\/\/ can be inconsistencies. The user must be prepared for them.\n-class G1CardSetMemoryStats {\n-public:\n-\n-  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n-  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n-\n-  \/\/ Returns all-zero statistics.\n-  G1CardSetMemoryStats();\n-\n-  void add(G1CardSetMemoryStats const other) {\n-    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n-    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n-      _num_mem_sizes[i] += other._num_mem_sizes[i];\n-      _num_buffers[i] += other._num_buffers[i];\n-    }\n-  }\n-\n-  void clear();\n-\n-  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n-};\n-\n-\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n-class G1CardSetFreePool {\n-  \/\/ The global free pool.\n-  static G1CardSetFreePool _freelist_pool;\n-\n-  const uint _num_free_lists;\n-  G1CardSetBufferList* _free_lists;\n-\n-public:\n-  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n-  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n-\n-  class G1ReturnMemoryProcessor;\n-  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n-\n-  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n-\n-  explicit G1CardSetFreePool(uint num_free_lists);\n-  ~G1CardSetFreePool();\n-\n-  G1CardSetBufferList* free_list(uint i) {\n-    assert(i < _num_free_lists, \"must be\");\n-    return &_free_lists[i];\n-  }\n-\n-  uint num_free_lists() const { return _num_free_lists; }\n-\n-  G1CardSetMemoryStats memory_sizes() const;\n-  size_t mem_size() const;\n-\n-  void print_on(outputStream* out);\n-};\n-\n-\/\/ Data structure containing current in-progress state for returning memory to the\n-\/\/ operating system for a single G1CardSetBufferList.\n-class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n-  G1CardSetBufferList* _source;\n-  size_t _return_to_vm_size;\n-\n-  G1CardSetBuffer* _first;\n-  size_t _unlinked_bytes;\n-  size_t _num_unlinked;\n-\n-public:\n-  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n-    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n-  }\n-\n-  \/\/ Updates the instance members about the given card set buffer list for the purpose\n-  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n-  \/\/ nothing to return to the VM, do not set the source list.\n-  void visit_free_list(G1CardSetBufferList* source);\n-\n-  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n-  bool finished_return_to_os() const { return _first == nullptr; }\n-\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_vm() re-adds buffers to the respective free list.\n-  bool return_to_vm(jlong deadline);\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_os() gives back buffers to the OS.\n-  bool return_to_os(jlong deadline);\n-};\n+typedef G1SegmentedArrayFreePool<mtGCCardSet> G1CardSetFreePool;\n@@ -259,1 +168,1 @@\n-  G1CardSetMemoryStats memory_stats() const;\n+  G1SegmentedArrayMemoryStats memory_stats() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":3,"deletions":94,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -68,0 +67,2 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -70,1 +71,0 @@\n-#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -73,1 +73,0 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -75,0 +74,1 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -90,1 +90,0 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -92,1 +91,1 @@\n-#include \"gc\/shared\/taskTerminator.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -94,0 +93,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -95,1 +95,0 @@\n-#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -97,0 +96,1 @@\n+#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -99,1 +99,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -101,0 +100,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -1434,1 +1434,1 @@\n-  _free_card_set_memory_task(NULL),\n+  _free_segmented_array_memory_task(NULL),\n@@ -1726,2 +1726,2 @@\n-  _free_card_set_memory_task = new G1CardSetFreeMemoryTask(\"Card Set Free Memory Task\");\n-  _service_thread->register_task(_free_card_set_memory_task);\n+  _free_segmented_array_memory_task = new G1SegmentedArrayFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_segmented_array_memory_task);\n@@ -2263,1 +2263,1 @@\n-class G1ParallelObjectIterator : public ParallelObjectIterator {\n+class G1ParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -2278,1 +2278,1 @@\n-ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n@@ -2619,2 +2619,2 @@\n-  _free_card_set_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n-                                               &_collection_set_candidates_card_set_stats);\n+  _free_segmented_array_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                                      &_collection_set_candidates_card_set_stats);\n@@ -2944,1 +2944,1 @@\n-void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats) {\n@@ -2948,1 +2948,1 @@\n-void G1CollectedHeap::set_young_gen_card_set_stats(const G1CardSetMemoryStats& stats) {\n+void G1CollectedHeap::set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"gc\/g1\/g1HeapRegionAttr.hpp\"\n@@ -41,1 +41,0 @@\n-#include \"gc\/g1\/g1HeapRegionAttr.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n@@ -146,1 +146,1 @@\n-  G1CardSetFreeMemoryTask* _free_card_set_memory_task;\n+  G1SegmentedArrayFreeMemoryTask* _free_segmented_array_memory_task;\n@@ -163,1 +163,1 @@\n-  G1CardSetMemoryStats _young_gen_card_set_stats;\n+  G1SegmentedArrayMemoryStats _young_gen_card_set_stats;\n@@ -165,1 +165,1 @@\n-  G1CardSetMemoryStats _collection_set_candidates_card_set_stats;\n+  G1SegmentedArrayMemoryStats _collection_set_candidates_card_set_stats;\n@@ -262,2 +262,2 @@\n-  void set_collection_set_candidates_stats(G1CardSetMemoryStats& stats);\n-  void set_young_gen_card_set_stats(const G1CardSetMemoryStats& stats);\n+  void set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats);\n+  void set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats);\n@@ -1080,1 +1080,1 @@\n-  ParallelObjectIterator* parallel_object_iterator(uint thread_num) override;\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,6 @@\n+inline bool G1STWIsAliveClosure::do_object_b(oop p) {\n+  \/\/ An object is reachable if it is outside the collection set,\n+  \/\/ or is inside and copied.\n+  return !_g1h->is_in_cset(p) || p->is_forwarded();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -773,1 +773,1 @@\n-    const uint regions_per_thread = 1000;\n+    const double regions_per_thread = 1000;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  _gc_par_phases[ScanHR]->create_thread_work_items(\"Found Roots:\", ScanHRFoundRoots);\n@@ -123,0 +124,1 @@\n+  _gc_par_phases[OptScanHR]->create_thread_work_items(\"Found Roots:\", ScanHRFoundRoots);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+    ScanHRFoundRoots,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  size_t& _heap_roots_found;\n@@ -66,2 +67,3 @@\n-                    G1ParScanThreadState* pss) :\n-    G1ScanClosureBase(g1h, pss) { }\n+                    G1ParScanThreadState* pss,\n+                    size_t& heap_roots_found) :\n+    G1ScanClosureBase(g1h, pss), _heap_roots_found(heap_roots_found) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+    _heap_roots_found++;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -777,0 +777,1 @@\n+  size_t _heap_roots_found;\n@@ -788,1 +789,1 @@\n-    G1ScanCardClosure card_cl(_g1h, _pss);\n+    G1ScanCardClosure card_cl(_g1h, _pss, _heap_roots_found);\n@@ -883,0 +884,1 @@\n+    _heap_roots_found(0),\n@@ -909,0 +911,1 @@\n+  size_t heap_roots_found() const { return _heap_roots_found; }\n@@ -927,0 +930,1 @@\n+  p->record_or_add_thread_work_item(scan_phase, worker_id, cl.heap_roots_found(), G1GCPhaseTimes::ScanHRFoundRoots);\n@@ -940,0 +944,1 @@\n+  size_t _opt_roots_scanned;\n@@ -954,1 +959,1 @@\n-    G1ScanCardClosure scan_cl(G1CollectedHeap::heap(), _pss);\n+    G1ScanCardClosure scan_cl(G1CollectedHeap::heap(), _pss, _opt_roots_scanned);\n@@ -973,0 +978,1 @@\n+    _opt_roots_scanned(0),\n@@ -1009,0 +1015,1 @@\n+  size_t opt_roots_scanned() const { return _opt_roots_scanned; }\n@@ -1031,0 +1038,1 @@\n+    p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_roots_scanned(), G1GCPhaseTimes::ScanHRFoundRoots);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+constexpr const char* G1SegmentedArrayFreeMemoryTask::_state_names[];\n+\n+const char* G1SegmentedArrayFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1SegmentedArrayMemoryStats used = _total_used;\n+  G1SegmentedArrayMemoryStats free = G1SegmentedArrayFreePool<mtGCCardSet>::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Segmented Array Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_segments[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1SegmentedArrayFreePool<mtGCCardSet>::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::free_excess_segmented_array_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess segmented array memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1SegmentedArrayFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Segmented Array Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1SegmentedArrayFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1SegmentedArrayFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1SegmentedArrayFreeMemoryTask::G1SegmentedArrayFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1SegmentedArrayFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_segmented_array_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1SegmentedArrayFreeMemoryTask::notify_new_stats(G1SegmentedArrayMemoryStats* young_gen_stats,\n+                                                      G1SegmentedArrayMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.cpp","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ Task handling deallocation of free segmented array memory.\n+class G1SegmentedArrayFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total segmented array memory usage.\n+  G1SegmentedArrayMemoryStats _total_used;\n+\n+  typedef G1SegmentedArrayFreePool<mtGCCardSet>::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1SegmentedArrayFreePool<mtGCCardSet>::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess segmented array memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_segmented_array_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1SegmentedArrayFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1SegmentedArrayMemoryStats* young_gen_stats,\n+                        G1SegmentedArrayMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1SEGMENTEDARRAYFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+G1SegmentedArrayMemoryStats::G1SegmentedArrayMemoryStats() {\n+  clear();\n+}\n+\n+void G1SegmentedArrayMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_segments[i] = 0;\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::visit_free_list(G1SegmentedArrayBufferList<flag>* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+bool G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1SegmentedArrayBuffer<flag>* cur = _first;\n+  G1SegmentedArrayBuffer<flag>* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+template<MEMFLAGS flag>\n+bool G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1SegmentedArrayBuffer<flag>* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag> G1SegmentedArrayFreePool<flag>::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag>::G1SegmentedArrayFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1SegmentedArrayBufferList<flag>, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1SegmentedArrayBufferList<flag>();\n+  }\n+}\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayFreePool<flag>::~G1SegmentedArrayFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1SegmentedArrayBufferList<flag>();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+template<MEMFLAGS flag>\n+G1SegmentedArrayMemoryStats G1SegmentedArrayFreePool<flag>::memory_sizes() const {\n+  G1SegmentedArrayMemoryStats free_list_stats;\n+  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n+  for (uint i = 0; i < num_free_lists(); i++) {\n+    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n+    free_list_stats._num_segments[i] = _free_lists[i].num_buffers();\n+  }\n+  return free_list_stats;\n+}\n+\n+template<MEMFLAGS flag>\n+size_t G1SegmentedArrayFreePool<flag>::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+template<MEMFLAGS flag>\n+void G1SegmentedArrayFreePool<flag>::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n+\n+template class G1SegmentedArrayFreePool<mtGCCardSet>;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Statistics for a segmented array. Contains the number of segments and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1SegmentedArrayMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_segments[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1SegmentedArrayMemoryStats();\n+\n+  void add(G1SegmentedArrayMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_segments) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_segments[i] += other._num_segments[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+\/\/ A set of free lists holding memory buffers for use by G1SegmentedArray,\n+\/\/ e.g. G1CardSetAllocators::SegmentedArray\n+template<MEMFLAGS flag>\n+class G1SegmentedArrayFreePool {\n+  \/\/ The global free pool.\n+  static G1SegmentedArrayFreePool _freelist_pool;\n+\n+  const uint _num_free_lists;\n+  G1SegmentedArrayBufferList<flag>* _free_lists;\n+\n+public:\n+  static G1SegmentedArrayFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1SegmentedArrayMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1SegmentedArrayFreePool(uint num_free_lists);\n+  ~G1SegmentedArrayFreePool();\n+\n+  G1SegmentedArrayBufferList<flag>* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  G1SegmentedArrayMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1SegmentedArrayBufferList.\n+template<MEMFLAGS flag>\n+class G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1SegmentedArrayBufferList<flag>* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1SegmentedArrayBuffer<flag>* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given segmented array buffer list for\n+  \/\/ the purpose of giving back memory. Only necessary members are updated,\n+  \/\/ e.g. if there is nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1SegmentedArrayBufferList<flag>* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -333,1 +333,1 @@\n-    G1CardSetMemoryStats _card_set_stats;\n+    G1SegmentedArrayMemoryStats _card_set_stats;\n@@ -449,1 +449,1 @@\n-    G1CardSetMemoryStats card_set_stats() const {\n+    G1SegmentedArrayMemoryStats card_set_stats() const {\n@@ -459,1 +459,1 @@\n-  G1CardSetMemoryStats _all_card_set_stats;\n+  G1SegmentedArrayMemoryStats _all_card_set_stats;\n@@ -493,1 +493,1 @@\n-  const G1CardSetMemoryStats all_card_set_stats() const {\n+  const G1SegmentedArrayMemoryStats all_card_set_stats() const {\n@@ -990,6 +990,0 @@\n-bool G1STWIsAliveClosure::do_object_b(oop p) {\n-  \/\/ An object is reachable if it is outside the collection set,\n-  \/\/ or is inside and copied.\n-  return !_g1h->is_in_cset(p) || p->is_forwarded();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class G1CardSetMemoryStats;\n@@ -52,0 +51,1 @@\n+class G1SegmentedArrayMemoryStats;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-      G1CardSetMemoryStats _total;\n+      G1SegmentedArrayMemoryStats _total;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-class G1CardSetMemoryManager;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  _card_set_mm(config, G1CardSetFreePool::free_list_pool()),\n+  _card_set_mm(config, G1SegmentedArrayFreePool<mtGCCardSet>::free_list_pool()),\n@@ -108,0 +108,4 @@\n+G1SegmentedArrayMemoryStats HeapRegionRemSet::card_set_memory_stats() const {\n+  return _card_set_mm.memory_stats();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class G1CardSetMemoryManager;\n@@ -128,1 +129,1 @@\n-  G1CardSetMemoryStats card_set_memory_stats() const { return _card_set_mm.memory_stats(); }\n+  G1SegmentedArrayMemoryStats card_set_memory_stats() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-                                                                                       _card_set.config()->log2_card_region_per_heap_region(),\n+                                                                                       _card_set.config()->log2_card_regions_per_heap_region(),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-class PSScavengeParallelObjectIterator : public ParallelObjectIterator {\n+class PSScavengeParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -618,1 +618,1 @@\n-ParallelObjectIterator* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  static size_t power_to_words_back(uint i) {\n-    return power_to_cards_back(i) * N_words;\n-  }\n@@ -77,4 +74,0 @@\n-  static size_t entry_to_words_back(u_char entry) {\n-    assert(entry >= N_words, \"Precondition\");\n-    return power_to_words_back(entry - N_words);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-      __ move(new LIR_Address(base_reg, oopDesc::klass_offset_in_bytes(), T_ADDRESS), src_klass);\n+      gen->load_klass(base_reg, src_klass, NULL);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,0 +113,12 @@\n+ParallelObjectIterator::ParallelObjectIterator(uint thread_num) :\n+  _impl(Universe::heap()->parallel_object_iterator(thread_num))\n+{}\n+\n+ParallelObjectIterator::~ParallelObjectIterator() {\n+  delete _impl;\n+}\n+\n+void ParallelObjectIterator::object_iterate(ObjectClosure* cl, uint worker_id) {\n+  _impl->object_iterate(cl, worker_id);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-class ParallelObjectIterator : public CHeapObj<mtGC> {\n+class ParallelObjectIteratorImpl : public CHeapObj<mtGC> {\n@@ -67,0 +67,1 @@\n+  virtual ~ParallelObjectIteratorImpl() {}\n@@ -68,1 +69,13 @@\n-  virtual ~ParallelObjectIterator() {}\n+};\n+\n+\/\/ User facing parallel object iterator. This is a StackObj, which ensures that\n+\/\/ the _impl is allocated and deleted in the scope of this object. This ensures\n+\/\/ the life cycle of the implementation is as required by ThreadsListHandle,\n+\/\/ which is sometimes used by the root iterators.\n+class ParallelObjectIterator : public StackObj {\n+  ParallelObjectIteratorImpl* _impl;\n+\n+public:\n+  ParallelObjectIterator(uint thread_num);\n+  ~ParallelObjectIterator();\n+  void object_iterate(ObjectClosure* cl, uint worker_id);\n@@ -85,0 +98,1 @@\n+  friend class ParallelObjectIterator;\n@@ -387,1 +401,2 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+ protected:\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) {\n@@ -391,0 +406,1 @@\n+ public:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -201,0 +201,2 @@\n+  phase_times.set_processing_is_mt(processing_is_mt());\n+\n@@ -733,2 +735,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n-\n@@ -767,1 +767,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -794,1 +793,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -1057,9 +1055,0 @@\n-bool ReferenceProcessor::has_discovered_references() {\n-  for (uint i = 0; i < _max_num_queues * number_of_subclasses_of_ref(); i++) {\n-    if (!_discovered_refs[i].is_empty()) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -424,3 +424,0 @@\n-  \/\/ Has discovered references that need handling\n-  bool has_discovered_references();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,1 +203,0 @@\n-    _sub_phases_total_time_ms[i] = uninitialized();\n@@ -230,11 +229,0 @@\n-double ReferenceProcessorPhaseTimes::sub_phase_total_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase) const {\n-  ASSERT_SUB_PHASE(sub_phase);\n-  return _sub_phases_total_time_ms[sub_phase];\n-}\n-\n-void ReferenceProcessorPhaseTimes::set_sub_phase_total_phase_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase,\n-                                                                     double time_ms) {\n-  ASSERT_SUB_PHASE(sub_phase);\n-  _sub_phases_total_time_ms[sub_phase] = time_ms;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  \/\/ Total time of each sub phase.\n-  double                   _sub_phases_total_time_ms[ReferenceProcessor::RefSubPhaseMax];\n@@ -65,1 +63,0 @@\n-  double sub_phase_total_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase) const;\n@@ -86,2 +83,0 @@\n-\n-  void set_sub_phase_total_phase_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase, double ref_proc_time_ms);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,10 +39,0 @@\n-template <>\n-void WorkerDataArray<double>::WDAPrinter::summary(outputStream* out, double time) {\n-  out->print_cr(\" %.1lfms\", time * MILLIUNITS);\n-}\n-\n-template <>\n-void WorkerDataArray<size_t>::WDAPrinter::summary(outputStream* out, size_t value) {\n-  out->print_cr(\" \" SIZE_FORMAT, value);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  WorkerDataArray(const char* short_name, const char* title, uint length, bool is_serial = false);\n+  WorkerDataArray(const char* short_name, const char* title, uint length);\n@@ -94,1 +94,0 @@\n-    static void summary(outputStream* out, double time);\n@@ -96,1 +95,0 @@\n-    static void summary(outputStream* out, size_t value);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-WorkerDataArray<T>::WorkerDataArray(const char* short_name, const char* title, uint length, bool is_serial) :\n+WorkerDataArray<T>::WorkerDataArray(const char* short_name, const char* title, uint length) :\n@@ -38,2 +38,1 @@\n- _title(title),\n- _is_serial(is_serial) {\n+ _title(title) {\n@@ -41,1 +40,0 @@\n-  assert(!is_serial || length == 1, \"Serial phase must only have a single entry.\");\n@@ -161,5 +159,1 @@\n-  if (_is_serial) {\n-    out->print(\"%s:\", title());\n-  } else {\n-    out->print(\"%-30s\", title());\n-  }\n+  out->print(\"%-30s\", title());\n@@ -172,15 +166,11 @@\n-    if (_is_serial) {\n-      WDAPrinter::summary(out, get(0));\n-    } else {\n-      T min = get(start);\n-      T max = min;\n-      T sum = 0;\n-      uint contributing_threads = 0;\n-      for (uint i = start; i < _length; ++i) {\n-        T value = get(i);\n-        if (value != uninitialized()) {\n-          max = MAX2(max, value);\n-          min = MIN2(min, value);\n-          sum += value;\n-          contributing_threads++;\n-        }\n+    T min = get(start);\n+    T max = min;\n+    T sum = 0;\n+    uint contributing_threads = 0;\n+    for (uint i = start; i < _length; ++i) {\n+      T value = get(i);\n+      if (value != uninitialized()) {\n+        max = MAX2(max, value);\n+        min = MIN2(min, value);\n+        sum += value;\n+        contributing_threads++;\n@@ -188,5 +178,0 @@\n-      T diff = max - min;\n-      assert(contributing_threads != 0, \"Must be since we found a used value for the start index\");\n-      double avg = sum \/ (double) contributing_threads;\n-      WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);\n-      out->print_cr(\", Workers: %d\", contributing_threads);\n@@ -194,0 +179,5 @@\n+    T diff = max - min;\n+    assert(contributing_threads != 0, \"Must be since we found a used value for the start index\");\n+    double avg = sum \/ (double) contributing_threads;\n+    WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);\n+    out->print_cr(\", Workers: %d\", contributing_threads);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.inline.hpp","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-class ShenandoahParallelObjectIterator : public ParallelObjectIterator {\n+class ShenandoahParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -1468,1 +1468,1 @@\n-ParallelObjectIterator* ShenandoahHeap::parallel_object_iterator(uint workers) {\n+ParallelObjectIteratorImpl* ShenandoahHeap::parallel_object_iterator(uint workers) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint workers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-ParallelObjectIterator* ZCollectedHeap::parallel_object_iterator(uint nworkers) {\n+ParallelObjectIteratorImpl* ZCollectedHeap::parallel_object_iterator(uint nworkers) {\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint nworkers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-ParallelObjectIterator* ZHeap::parallel_object_iterator(uint nworkers, bool visit_weaks) {\n+ParallelObjectIteratorImpl* ZHeap::parallel_object_iterator(uint nworkers, bool visit_weaks) {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  ParallelObjectIterator* parallel_object_iterator(uint nworkers, bool visit_weaks);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers, bool visit_weaks);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class ZHeapIterator : public ParallelObjectIterator {\n+class ZHeapIterator : public ParallelObjectIteratorImpl {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/z\/zThread.inline.hpp\"\n@@ -739,2 +740,7 @@\n-  LogTarget(Debug, gc, phases, start) log;\n-  log_start(log, true \/* thread *\/);\n+  if (ZThread::is_worker()) {\n+    LogTarget(Trace, gc, phases, start) log;\n+    log_start(log, true \/* thread *\/);\n+  } else {\n+    LogTarget(Debug, gc, phases, start) log;\n+    log_start(log, false \/* thread *\/);\n+  }\n@@ -753,2 +759,7 @@\n-  LogTarget(Debug, gc, phases) log;\n-  log_end(log, duration, true \/* thread *\/);\n+  if (ZThread::is_worker()) {\n+    LogTarget(Trace, gc, phases) log;\n+    log_end(log, duration, true \/* thread *\/);\n+  } else {\n+    LogTarget(Debug, gc, phases) log;\n+    log_end(log, duration, false \/* thread *\/);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -134,0 +134,13 @@\n+\n+void ZTracer::send_thread_debug(const char* name, const Ticks& start, const Ticks& end) {\n+  NoSafepointVerifier nsv;\n+\n+  EventZThreadDebug e(UNTIMED);\n+  if (e.should_commit()) {\n+    e.set_gcId(GCId::current_or_undefined());\n+    e.set_name(name);\n+    e.set_starttime(start);\n+    e.set_endtime(end);\n+    e.commit();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  void send_thread_debug(const char* name, const Ticks& start, const Ticks& end);\n@@ -50,0 +51,1 @@\n+  void report_thread_debug(const char* name, const Ticks& start, const Ticks& end);\n@@ -52,1 +54,2 @@\n-class ZTraceThreadPhase : public StackObj {\n+\/\/ For temporary latency measurements during development and debugging\n+class ZTraceThreadDebug : public StackObj {\n@@ -58,2 +61,2 @@\n-  ZTraceThreadPhase(const char* name);\n-  ~ZTraceThreadPhase();\n+  ZTraceThreadDebug(const char* name);\n+  ~ZTraceThreadDebug();\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,7 @@\n-inline ZTraceThreadPhase::ZTraceThreadPhase(const char* name) :\n+inline void ZTracer::report_thread_debug(const char* name, const Ticks& start, const Ticks& end) {\n+  if (EventZThreadDebug::is_enabled()) {\n+    send_thread_debug(name, start, end);\n+  }\n+}\n+\n+inline ZTraceThreadDebug::ZTraceThreadDebug(const char* name) :\n@@ -57,2 +63,2 @@\n-inline ZTraceThreadPhase::~ZTraceThreadPhase() {\n-  ZTracer::tracer()->report_thread_phase(_name, _start, Ticks::now());\n+inline ZTraceThreadDebug::~ZTraceThreadDebug() {\n+  ZTracer::tracer()->report_thread_debug(_name, _start, Ticks::now());\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.inline.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -410,1 +410,5 @@\n-    note_trap(current, Deoptimization::Reason_class_check);\n+    if (s == vmSymbols::java_lang_ArrayStoreException()) {\n+      note_trap(current, Deoptimization::Reason_array_check);\n+    } else {\n+      note_trap(current, Deoptimization::Reason_class_check);\n+    }\n@@ -828,1 +832,12 @@\n-                                 CHECK);\n+                                 THREAD);\n+\n+    if (HAS_PENDING_EXCEPTION) {\n+      if (ProfileTraps && PENDING_EXCEPTION->klass()->name() == vmSymbols::java_lang_NullPointerException()) {\n+        \/\/ Preserve the original exception across the call to note_trap()\n+        PreserveExceptionMark pm(current);\n+        \/\/ Recording the trap will help the compiler to potentially recognize this exception as \"hot\"\n+        note_trap(current, Deoptimization::Reason_null_check);\n+      }\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1037,0 +1037,5 @@\n+  <Event name=\"ZThreadDebug\" category=\"Java Virtual Machine, GC, Detailed\" label=\"ZGC Thread Event\" description=\"Temporary latency measurements used during development and debugging of ZGC\" thread=\"true\" experimental=\"true\">\n+    <Field type=\"uint\" name=\"gcId\" label=\"GC Identifier\" relation=\"GcId\"\/>\n+    <Field type=\"string\" name=\"name\" label=\"Name\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -581,12 +581,6 @@\n-      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(workers->active_workers());\n-      if (poi != NULL) {\n-        \/\/ The GC supports parallel object iteration.\n-\n-        ParHeapInspectTask task(poi, cit, filter);\n-        \/\/ Run task with the active workers.\n-        workers->run_task(&task);\n-\n-        delete poi;\n-        if (task.success()) {\n-          return task.missed_count();\n-        }\n+      ParallelObjectIterator poi(workers->active_workers());\n+      ParHeapInspectTask task(&poi, cit, filter);\n+      \/\/ Run task with the active workers.\n+      workers->run_task(&task);\n+      if (task.success()) {\n+        return task.missed_count();\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -116,4 +116,6 @@\n-  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n-  if (_requests_head == request) {\n-    \/\/ The first request can't opportunistically ride on a previous GC\n-    return false;\n+  {\n+    MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+    if (_requests_head == request) {\n+      \/\/ The first request can't opportunistically ride on a previous GC\n+      return false;\n+    }\n@@ -127,2 +129,6 @@\n-  while (!request->has_result()) {\n-    ThreadBlockInVM tbivm(JavaThread::current());\n+  ThreadBlockInVM tbivm(JavaThread::current());\n+  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+  for (;;) {\n+    if (request->has_result()) {\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1589,12 +1589,0 @@\n-bool MethodData::profile_memory_access(const methodHandle& m, int bci) {\n-  Bytecode_invoke inv(m , bci);\n-  if (inv.is_invokestatic()) {\n-    if (inv.klass() == vmSymbols::jdk_incubator_foreign_MemoryAccess()) {\n-      if (inv.name()->starts_with(\"get\") || inv.name()->starts_with(\"set\")) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -1630,4 +1618,0 @@\n-  if (profile_memory_access(m, bci)) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  _late_inline(false),\n@@ -116,1 +117,1 @@\n-                               int caller_bci, ciCallProfile& profile) {\n+                               int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -131,3 +132,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -197,1 +202,1 @@\n-                                   int caller_bci, ciCallProfile& profile) {\n+                                   int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -235,3 +240,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -372,1 +381,3 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, profile)) {\n+\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (!should_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -375,1 +386,2 @@\n-  if (should_not_inline(callee_method, caller_method, caller_bci, profile)) {\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (should_not_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -560,2 +572,0 @@\n-  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n-  assert(!should_delay, \"should be initialized to false\");\n@@ -563,0 +573,1 @@\n+  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n@@ -598,1 +609,5 @@\n-    build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    InlineTree* callee_tree = build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    if (should_delay) {\n+      \/\/ Record late inlining decision in order to dump it for compiler replay\n+      callee_tree->set_late_inline();\n+    }\n@@ -703,1 +718,1 @@\n-  out->print(\" %d %d \", inline_level(), caller_bci());\n+  out->print(\" %d %d %d \", inline_level(), caller_bci(), _late_inline);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-      bool should_delay = false;\n+      bool should_delay = AlwaysIncrementalInline;\n@@ -192,1 +192,1 @@\n-          } else if ((should_delay || AlwaysIncrementalInline)) {\n+          } else if (should_delay) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -583,5 +583,4 @@\n-      if (java_bc() == Bytecodes::_aastore) {\n-        ex_obj = env()->ArrayStoreException_instance();\n-      } else {\n-        ex_obj = env()->ClassCastException_instance();\n-      }\n+      ex_obj = env()->ClassCastException_instance();\n+      break;\n+    case Deoptimization::Reason_array_check:\n+      ex_obj = env()->ArrayStoreException_instance();\n@@ -3343,1 +3342,4 @@\n-          builtin_throw(Deoptimization::Reason_class_check, makecon(TypeKlassPtr::make(objtp->klass())));\n+          bool is_aastore = (java_bc() == Bytecodes::_aastore);\n+          Deoptimization::DeoptReason reason = is_aastore ?\n+            Deoptimization::Reason_array_check : Deoptimization::Reason_class_check;\n+          builtin_throw(reason, makecon(TypeKlassPtr::make(objtp->klass())));\n@@ -3425,1 +3427,4 @@\n-        builtin_throw(Deoptimization::Reason_class_check, load_object_klass(not_null_obj));\n+        bool is_aastore = (java_bc() == Bytecodes::_aastore);\n+        Deoptimization::DeoptReason reason = is_aastore ?\n+          Deoptimization::Reason_array_check : Deoptimization::Reason_class_check;\n+        builtin_throw(reason, load_object_klass(not_null_obj));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -421,0 +421,8 @@\n+    Node_Notes* nn = C->node_notes_at(node->_idx);\n+    if (nn != NULL && !nn->is_clear() && nn->jvms() != NULL) {\n+      buffer[0] = 0;\n+      stringStream ss(buffer, sizeof(buffer) - 1);\n+      nn->jvms()->dump_spec(&ss);\n+      print_prop(\"jvms\", buffer);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, iffast_pred, loop);\n+    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n@@ -346,1 +346,1 @@\n-    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, ifslow_pred, loop);\n+    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n@@ -400,4 +400,4 @@\n-ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj,\n-                                                                    Deoptimization::DeoptReason reason, ProjNode* output_proj,\n-                                                                    IdealLoopTree* loop) {\n-  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, predicate, uncommon_proj, output_proj, loop);\n+ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                                        Deoptimization::DeoptReason reason,\n+                                                                        ProjNode* output_proj) {\n+  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1290,1 +1290,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, NULL, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1293,1 +1294,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1370,2 +1372,1 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                    Node* control, IdealLoopTree* outer_loop) {\n+Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control) {\n@@ -1447,3 +1448,3 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                             Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n-  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, predicate, uncommon_proj, control, outer_loop);\n+Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                                     Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, control);\n@@ -1463,2 +1464,2 @@\n-  register_control(new_iff, outer_loop->_parent, input_proj);\n-  register_control(proj, outer_loop->_parent, new_iff);\n+  register_control(new_iff, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, input_proj);\n+  register_control(proj, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, new_iff);\n@@ -1547,1 +1548,2 @@\n-  Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n+  Node* post_incr = incr;\n+  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr, limit, post_head);\n@@ -1646,0 +1648,1 @@\n+  copy_skeleton_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n@@ -1768,0 +1771,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1814,0 +1818,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1830,3 +1835,3 @@\n-Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                                       CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                                       Node *incr, Node *limit, CountedLoopNode *&post_head) {\n+Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                       CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1916,2 +1921,2 @@\n-  Node* castii = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(castii != NULL, \"no castII inserted\");\n+  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n+  assert(incr != NULL, \"no castII inserted\");\n@@ -1959,1 +1964,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, max_value, entry, proj, ctrl, outer_loop,\n+                                                                   prev_proj);\n@@ -1971,0 +1977,28 @@\n+void PhaseIdealLoop::copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride) {\n+  \/\/ Go over the skeleton predicates of the main loop and make a copy for the post loop with its initial iv value and\n+  \/\/ stride as inputs.\n+  Node* post_loop_entry = post_loop_head->in(LoopNode::EntryControl);\n+  Node* main_loop_entry = main_loop_head->in(LoopNode::EntryControl);\n+  IdealLoopTree* post_loop = get_loop(post_loop_head);\n+\n+  Node* ctrl = main_loop_entry;\n+  Node* prev_proj = post_loop_entry;\n+  while (ctrl != NULL && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n+    IfNode* iff = ctrl->in(0)->as_If();\n+    ProjNode* proj = iff->proj_out(1 - ctrl->as_Proj()->_con);\n+    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+      break;\n+    }\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n+      prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, ctrl, proj, post_loop_entry,\n+                                                                 post_loop, prev_proj);\n+      assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"unexpected\");\n+    }\n+    ctrl = ctrl->in(0)->in(0);\n+  }\n+  if (prev_proj != post_loop_entry) {\n+    _igvn.replace_input_of(post_loop_head, LoopNode::EntryControl, prev_proj);\n+    set_idom(post_loop_head, prev_proj, dom_depth(post_loop_head));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2392,0 +2392,1 @@\n+  Node* ctrl = in(LoopNode::EntryControl);\n@@ -2393,2 +2394,3 @@\n-    Node* ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n-\n+    ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n+  }\n+  if (is_main_loop() || is_post_loop()) {\n@@ -2397,1 +2399,1 @@\n-  return in(LoopNode::EntryControl);\n+  return ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -920,4 +920,3 @@\n-  Node* clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                               IdealLoopTree* outer_loop, Node* input_proj);\n-  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                      IdealLoopTree* outer_loop);\n+  Node* clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                                       IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control);\n@@ -927,0 +926,1 @@\n+  void copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride);\n@@ -1249,3 +1249,3 @@\n-  Node *insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                         CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                         Node *incr, Node *limit, CountedLoopNode *&post_head);\n+  Node *insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                         CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1596,2 +1596,3 @@\n-  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj, Deoptimization::DeoptReason reason,\n-                                                          ProjNode* output_proj, IdealLoopTree* loop);\n+  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                          Deoptimization::DeoptReason reason,\n+                                                          ProjNode* output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2369,0 +2369,1 @@\n+               n->Opcode() == Op_Opaque4   ||\n@@ -2430,0 +2431,13 @@\n+      } else if (n->Opcode() == Op_Opaque4) {\n+        \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n+        \/\/ is always equal to the constant value of input 2. So we can\n+        \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n+        \/\/ leave the non constant test in instead to sanity check that it\n+        \/\/ never fails (if it does, that subgraph was constructed so, at\n+        \/\/ runtime, a Halt node is executed).\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, n->in(2));\n+#endif\n+        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -637,6 +637,7 @@\n-    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n-    \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n-    for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n-      scalable_stack_mask.Remove(in);\n-      in = OptoReg::add(in, -1);\n-    }\n+    if (Matcher::has_predicated_vectors()) {\n+      \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+      \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n+      for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n+        scalable_stack_mask.Remove(in);\n+        in = OptoReg::add(in, -1);\n+      }\n@@ -644,5 +645,6 @@\n-    \/\/ For RegVectMask\n-    scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n-    assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-    idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+      \/\/ For RegVectMask\n+      scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n+      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+class ShiftVNode;\n@@ -714,0 +715,1 @@\n+        DEFINE_CLASS_ID(ShiftV, Vector, 3)\n@@ -948,0 +950,1 @@\n+  DEFINE_CLASS_QUERY(ShiftV)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,19 +63,0 @@\n-Node* Opaque4Node::Identity(PhaseGVN* phase) {\n-  if (phase->C->post_loop_opts_phase()) {\n-    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-    \/\/ is always equal to the constant value of input 2. So we can\n-    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-    \/\/ leave the non constant test in instead to sanity check that it\n-    \/\/ never fails (if it does, that subgraph was constructed so, at\n-    \/\/ runtime, a Halt node is executed).\n-#ifdef ASSERT\n-    return this->in(1);\n-#else\n-    return this->in(2);\n-#endif\n-  } else {\n-    phase->C->record_for_post_loop_opts_igvn(this);\n-  }\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -117,1 +117,4 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {}\n+  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n@@ -121,1 +124,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool        _late_inline;       \/\/ method is inlined incrementally\n@@ -78,0 +79,1 @@\n+                            NOT_PRODUCT_ARG(bool& should_delay)\n@@ -82,0 +84,1 @@\n+                                NOT_PRODUCT_ARG(bool& should_delay)\n@@ -115,0 +118,4 @@\n+  void set_late_inline() {\n+    _late_inline = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -529,1 +529,1 @@\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass));\n+        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask) {\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift) {\n@@ -537,4 +537,4 @@\n-  case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt);\n-  case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt);\n-  case Op_LShiftVI: return new LShiftVINode(n1, n2, vt);\n-  case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt);\n+  case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVI: return new LShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -542,4 +542,4 @@\n-  case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt);\n-  case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt);\n-  case Op_RShiftVI: return new RShiftVINode(n1, n2, vt);\n-  case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt);\n+  case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVI: return new RShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -547,4 +547,4 @@\n-  case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt);\n-  case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt);\n-  case Op_URShiftVI: return new URShiftVINode(n1, n2, vt);\n-  case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt);\n+  case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVI: return new URShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -566,1 +566,1 @@\n-VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt) {\n+VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt, bool is_var_shift) {\n@@ -571,1 +571,1 @@\n-  return make(vopc, n1, n2, vt);\n+  return make(vopc, n1, n2, vt, false, is_var_shift);\n@@ -1300,2 +1300,2 @@\n-  return new OrVNode(phase->transform(VectorNode::make(shiftLOpc, src, shiftLCnt, vlen, bt)),\n-                     phase->transform(VectorNode::make(shiftROpc, src, shiftRCnt, vlen, bt)),\n+  return new OrVNode(phase->transform(VectorNode::make(shiftLOpc, src, shiftLCnt, vlen, bt, is_binary_vector_op)),\n+                     phase->transform(VectorNode::make(shiftROpc, src, shiftRCnt, vlen, bt, is_binary_vector_op)),\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-  static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);\n-  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false);\n+  static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt, bool is_var_shift = false);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false);\n@@ -534,0 +534,1 @@\n+ bool _is_var_shift;\n@@ -535,1 +536,4 @@\n-  ShiftVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  ShiftVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift) :\n+    VectorNode(in1,in2,vt), _is_var_shift(is_var_shift) {\n+    init_class_id(Class_ShiftV);\n+  }\n@@ -538,0 +542,2 @@\n+  bool is_var_shift() { return _is_var_shift;}\n+  virtual  uint  size_of() const { return sizeof(ShiftVNode); }\n@@ -544,1 +550,2 @@\n-  LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -552,1 +559,2 @@\n-  LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -560,1 +568,2 @@\n-  LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -568,1 +577,2 @@\n-  LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -576,1 +586,2 @@\n-  RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -584,1 +595,2 @@\n-  RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -592,1 +604,2 @@\n-  RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -600,1 +613,2 @@\n-  RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -608,1 +622,2 @@\n-  URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -616,1 +631,2 @@\n-  URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -624,1 +640,2 @@\n-  URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -632,1 +649,2 @@\n-  URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+     ShiftVNode(in1,in2,vt,is_var_shift) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1396,0 +1396,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1526,0 +1529,4 @@\n+\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1602,8 +1609,6 @@\n-  if (!java_thread->is_exiting() && java_thread->threadObj() != NULL) {\n-    _state->update_for_pop_top_frame();\n-    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n-    \/\/ Set pending step flag for this popframe and it is cleared when next\n-    \/\/ step event is posted.\n-    _state->set_pending_step_for_popframe();\n-    _result = JVMTI_ERROR_NONE;\n-  }\n+  _state->update_for_pop_top_frame();\n+  java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n+  \/\/ Set pending step flag for this popframe and it is cleared when next\n+  \/\/ step event is posted.\n+  _state->set_pending_step_for_popframe();\n+  _result = JVMTI_ERROR_NONE;\n@@ -1617,0 +1622,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1636,3 +1644,0 @@\n-  if (java_thread->is_exiting() || java_thread->threadObj() == NULL) {\n-    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -332,0 +333,1 @@\n+  JvmtiVMObjectAllocEventCollector oam;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -958,0 +958,66 @@\n+WB_ENTRY(jint, WB_GetMethodDecompileCount(JNIEnv* env, jobject o, jobject method))\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  uint cnt = 0;\n+  MethodData* mdo = mh->method_data();\n+  if (mdo != NULL) {\n+    cnt = mdo->decompile_count();\n+  }\n+  return cnt;\n+WB_END\n+\n+\/\/ Get the trap count of a method for a specific reason. If the trap count for\n+\/\/ that reason did overflow, this includes the overflow trap count of the method.\n+\/\/ If 'reason' is NULL, the sum of the traps for all reasons will be returned.\n+\/\/ This number includes the overflow trap count if the trap count for any reason\n+\/\/ did overflow.\n+WB_ENTRY(jint, WB_GetMethodTrapCount(JNIEnv* env, jobject o, jobject method, jstring reason_obj))\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  uint cnt = 0;\n+  MethodData* mdo = mh->method_data();\n+  if (mdo != NULL) {\n+    ResourceMark rm(THREAD);\n+    char* reason_str = (reason_obj == NULL) ?\n+      NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+    bool overflow = false;\n+    for (uint reason = 0; reason < mdo->trap_reason_limit(); reason++) {\n+      if (reason_str != NULL && !strcmp(reason_str, Deoptimization::trap_reason_name(reason))) {\n+        cnt = mdo->trap_count(reason);\n+        \/\/ Count in the overflow trap count on overflow\n+        if (cnt == (uint)-1) {\n+          cnt = mdo->trap_count_limit() + mdo->overflow_trap_count();\n+        }\n+        break;\n+      } else if (reason_str == NULL) {\n+        uint c = mdo->trap_count(reason);\n+        if (c == (uint)-1) {\n+          c = mdo->trap_count_limit();\n+          if (!overflow) {\n+            \/\/ Count overflow trap count just once\n+            overflow = true;\n+            c += mdo->overflow_trap_count();\n+          }\n+        }\n+        cnt += c;\n+      }\n+    }\n+  }\n+  return cnt;\n+WB_END\n+\n+WB_ENTRY(jint, WB_GetDeoptCount(JNIEnv* env, jobject o, jstring reason_obj, jstring action_obj))\n+  if (reason_obj == NULL && action_obj == NULL) {\n+    return Deoptimization::total_deoptimization_count();\n+  }\n+  ResourceMark rm(THREAD);\n+  const char *reason_str = (reason_obj == NULL) ?\n+    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+  const char *action_str = (action_obj == NULL) ?\n+    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(action_obj));\n+\n+  return Deoptimization::deoptimization_count(reason_str, action_str);\n+WB_END\n+\n@@ -2530,0 +2596,7 @@\n+  {CC\"getMethodDecompileCount0\",\n+      CC\"(Ljava\/lang\/reflect\/Executable;)I\",          (void*)&WB_GetMethodDecompileCount},\n+  {CC\"getMethodTrapCount0\",\n+      CC\"(Ljava\/lang\/reflect\/Executable;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_GetMethodTrapCount},\n+  {CC\"getDeoptCount0\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;)I\",    (void*)&WB_GetDeoptCount},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2611,0 +2611,24 @@\n+\/\/ Get the deopt count for a specific reason and a specific action. If either\n+\/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+\/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+\/\/ If both arguments are null, the method returns the total deopt count.\n+jint Deoptimization::deoptimization_count(const char *reason_str, const char *action_str) {\n+  if (reason_str == NULL && action_str == NULL) {\n+    return total_deoptimization_count();\n+  }\n+  juint counter = 0;\n+  for (int reason = 0; reason < Reason_LIMIT; reason++) {\n+    if (reason_str == NULL || !strcmp(reason_str, trap_reason_name(reason))) {\n+      for (int action = 0; action < Action_LIMIT; action++) {\n+        if (action_str == NULL || !strcmp(action_str, trap_action_name(action))) {\n+          juint* cases = _deoptimization_hist[reason][1+action];\n+          for (int bc_case = 0; bc_case < BC_CASE_LIMIT; bc_case++) {\n+            counter += cases[bc_case] >> LSB_BITS;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return counter;\n+}\n+\n@@ -2664,0 +2688,8 @@\n+jint Deoptimization::total_deoptimization_count() {\n+  return 0;\n+}\n+\n+jint Deoptimization::deoptimization_count(const char *reason_str, const char *action_str) {\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -436,0 +436,1 @@\n+  static jint deoptimization_count(const char* reason_str, const char* action_str);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -672,1 +672,2 @@\n-  size_t            nmt_header_size = MemTracker::malloc_header_size(level);\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n@@ -675,1 +676,1 @@\n-  const size_t alloc_size = size + nmt_header_size;\n+  const size_t alloc_size = size + nmt_overhead;\n@@ -677,2 +678,2 @@\n-  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_header_size);\n-  if (size + nmt_header_size > alloc_size) { \/\/ Check for rollover.\n+  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_overhead);\n+  if (size + nmt_overhead > alloc_size) { \/\/ Check for rollover.\n@@ -696,1 +697,1 @@\n-  GuardedMemory guarded(ptr, size + nmt_header_size);\n+  GuardedMemory guarded(ptr, size + nmt_overhead);\n@@ -744,2 +745,3 @@\n-  size_t  nmt_header_size = MemTracker::malloc_header_size(level);\n-  void* ptr = ::realloc(membase, size + nmt_header_size);\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+  void* ptr = ::realloc(membase, size + nmt_overhead);\n@@ -764,1 +766,4 @@\n-    size_t memblock_size = guarded.get_user_size() - MemTracker::malloc_header_size(memblock);\n+    NMT_TrackingLevel level = MemTracker::tracking_level();\n+    const size_t nmt_overhead =\n+        MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+    size_t memblock_size = guarded.get_user_size() - nmt_overhead;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -387,2 +387,0 @@\n-  static size_t trampoline_size();\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1913,1 +1913,0 @@\n-      _poi = Universe::heap()->parallel_object_iterator(_num_dumper_threads);\n@@ -2002,4 +2001,0 @@\n-    if (_poi != NULL) {\n-      delete _poi;\n-      _poi = NULL;\n-    }\n@@ -2255,1 +2250,8 @@\n-    workers->run_task(this);\n+    if (_num_dumper_threads > 1) {\n+      ParallelObjectIterator poi(_num_dumper_threads);\n+      _poi = &poi;\n+      workers->run_task(this);\n+      _poi = NULL;\n+    } else {\n+      workers->run_task(this);\n+    }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n@@ -52,1 +51,0 @@\n-  assert((size_t)table_size <= MAX_MALLOCSITE_TABLE_SIZE, \"Hashtable overflow\");\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+  \/\/ The table must not be wider than the maximum value the bucket_idx field\n+  \/\/ in the malloc header can hold.\n+  STATIC_ASSERT(table_size <= MAX_MALLOCSITE_TABLE_SIZE);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -30,0 +31,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -106,1 +109,7 @@\n-void MallocHeader::release() const {\n+void MallocHeader::mark_block_as_dead() {\n+  _canary = _header_canary_dead_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  set_footer(_footer_canary_dead_mark);\n+}\n+\n+void MallocHeader::release() {\n@@ -110,0 +119,2 @@\n+  check_block_integrity();\n+\n@@ -115,0 +126,95 @@\n+\n+  mark_block_as_dead();\n+}\n+\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+  assert(bad_address >= (address)this, \"sanity\");\n+\n+  \/\/ This function prints block information, including hex dump, in case of a detected\n+  \/\/ corruption. The hex dump should show both block header and corruption site\n+  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n+  \/\/\n+  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n+  \/\/ memory (it uses SafeFetch).\n+\n+  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n+               p2i(this), p2i(bad_address));\n+  static const size_t min_dump_length = 256;\n+  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to1 = from1 + min_dump_length;\n+  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to2 = from2 + min_dump_length;\n+  if (from2 > to1) {\n+    \/\/ Dump gets too large, split up in two sections.\n+    os::print_hex_dump(st, from1, to1, 1);\n+    st->print_cr(\"...\");\n+    os::print_hex_dump(st, from2, to2, 1);\n+  } else {\n+    \/\/ print one hex dump\n+    os::print_hex_dump(st, from1, to2, 1);\n+  }\n+}\n+\n+\/\/ Check block integrity. If block is broken, print out a report\n+\/\/ to tty (optionally with hex dump surrounding the broken block),\n+\/\/ then trigger a fatal error.\n+void MallocHeader::check_block_integrity() const {\n+\n+#define PREFIX \"NMT corruption: \"\n+  \/\/ Note: if you modify the error messages here, make sure you\n+  \/\/ adapt the associated gtests too.\n+\n+  \/\/ Weed out obviously wrong block addresses of NULL or very low\n+  \/\/ values. Note that we should not call this for ::free(NULL),\n+  \/\/ which should be handled by os::free() above us.\n+  if (((size_t)p2i(this)) < K) {\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n+  }\n+\n+  \/\/ From here on we assume the block pointer to be valid. We could\n+  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n+  \/\/ wrong, we will crash when accessing the canary, which hopefully\n+  \/\/ generates distinct crash report.\n+\n+  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n+  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n+  \/\/ specified by the standard by this requirement:\n+  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n+  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n+  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n+  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n+  \/\/ we test the smallest alignment we know.\n+  \/\/ Should we ever start using std::max_align_t, this would be one place to\n+  \/\/ fix up.\n+  if (!is_aligned(this, sizeof(uint64_t))) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n+  }\n+\n+  \/\/ Check header canary\n+  if (_canary != _header_canary_life_mark) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n+  }\n+\n+#ifndef _LP64\n+  \/\/ On 32-bit we have a second canary, check that one too.\n+  if (_alt_canary != _header_alt_canary_life_mark) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n+  }\n+#endif\n+\n+  \/\/ Does block size seems reasonable?\n+  if (_size >= max_reasonable_malloc_size) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n+  }\n+\n+  \/\/ Check footer canary\n+  if (get_footer() != _footer_canary_life_mark) {\n+    print_block_on_error(tty, footer_address());\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+          p2i(this), p2i(footer_address()));\n+  }\n+#undef PREFIX\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":107,"deletions":1,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -242,2 +242,50 @@\n- * To satisfy malloc alignment requirement, NMT uses 2 machine words for tracking purpose,\n- * which ensures 8-bytes alignment on 32-bit systems and 16-bytes on 64-bit systems (Product build).\n+ *\n+ * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n+ * do this is by using malloc headers.\n+ *\n+ * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n+ *  footer canary:\n+ *\n+ * +--------------+-------------  ....  ------------------+-----+\n+ * |    header    |               user                    | can |\n+ * |              |             allocation                | ary |\n+ * +--------------+-------------  ....  ------------------+-----+\n+ *     16 bytes              user size                      2 byte\n+ *\n+ * Alignment:\n+ *\n+ * The start of the user allocation needs to adhere to malloc alignment. We assume 128 bits\n+ * on both 64-bit\/32-bit to be enough for that. So the malloc header is 16 bytes long on both\n+ * 32-bit and 64-bit.\n+ *\n+ * Layout on 64-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |                            64-bit size                                |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Layout on 32-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |            alt. canary            |           32-bit size             |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Notes:\n+ * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n+ *   catch negative buffer overflows.\n+ * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n+ *   canary at the very start of the malloc header (generously sized 32 bits).\n+ * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n+ *   the bytes are stored individually.\n@@ -247,15 +295,34 @@\n-#ifdef _LP64\n-  size_t           _size      : 64;\n-  size_t           _flags     : 8;\n-  size_t           _pos_idx   : 16;\n-  size_t           _bucket_idx: 40;\n-#define MAX_MALLOCSITE_TABLE_SIZE right_n_bits(40)\n-#define MAX_BUCKET_LENGTH         right_n_bits(16)\n-#else\n-  size_t           _size      : 32;\n-  size_t           _flags     : 8;\n-  size_t           _pos_idx   : 8;\n-  size_t           _bucket_idx: 16;\n-#define MAX_MALLOCSITE_TABLE_SIZE  right_n_bits(16)\n-#define MAX_BUCKET_LENGTH          right_n_bits(8)\n-#endif  \/\/ _LP64\n+\n+  NOT_LP64(uint32_t _alt_canary);\n+  size_t _size;\n+  uint16_t _bucket_idx;\n+  uint16_t _pos_idx;\n+  uint8_t _flags;\n+  uint8_t _unused;\n+  uint16_t _canary;\n+\n+#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n+#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n+\n+  static const uint16_t _header_canary_life_mark = 0xE99E;\n+  static const uint16_t _header_canary_dead_mark = 0xD99D;\n+  static const uint16_t _footer_canary_life_mark = 0xE88E;\n+  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n+  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n+  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n+\n+  \/\/ We discount sizes larger than these\n+  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n+\n+  \/\/ Check block integrity. If block is broken, print out a report\n+  \/\/ to tty (optionally with hex dump surrounding the broken block),\n+  \/\/ then trigger a fatal error.\n+  void check_block_integrity() const;\n+  void print_block_on_error(outputStream* st, address bad_address) const;\n+  void mark_block_as_dead();\n+\n+  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return ((uint16_t)b1 << 8) | (uint16_t)b2; }\n+\n+  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n+  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n+  void set_footer(uint16_t v)       { footer_address()[0] = v >> 8; footer_address()[1] = (uint8_t)v; }\n@@ -264,0 +331,1 @@\n+\n@@ -265,2 +333,2 @@\n-    assert(sizeof(MallocHeader) == sizeof(void*) * 2,\n-      \"Wrong header size\");\n+\n+    assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n@@ -280,2 +348,2 @@\n-        _bucket_idx = bucket_idx;\n-        _pos_idx = pos_idx;\n+        _bucket_idx = (uint16_t)bucket_idx;\n+        _pos_idx = (uint16_t)pos_idx;\n@@ -285,0 +353,7 @@\n+    _unused = 0;\n+    _canary = _header_canary_life_mark;\n+    \/\/ On 32-bit we have some bits more, use them for a second canary\n+    \/\/ guarding the start of the header.\n+    NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n+    set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n+\n@@ -293,2 +368,2 @@\n-  \/\/ Cleanup tracking information before the memory is released.\n-  void release() const;\n+  \/\/ Cleanup tracking information and mark block as dead before the memory is released.\n+  void release();\n@@ -304,0 +379,3 @@\n+\/\/ This needs to be true on both 64-bit and 32-bit platforms\n+STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n+\n@@ -318,0 +396,5 @@\n+  \/\/ malloc tracking footer size for specific tracking level\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n+    return (level == NMT_off) ? 0 : sizeof(uint16_t);\n+  }\n+\n@@ -352,5 +435,0 @@\n-  \/\/ Get header size\n-  static inline size_t get_header_size(void* memblock) {\n-    return (memblock == NULL) ? 0 : sizeof(MallocHeader);\n-  }\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":106,"deletions":28,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) { return 0; }\n@@ -160,5 +161,3 @@\n-  static size_t malloc_header_size(void* memblock) {\n-    if (tracking_level() != NMT_off) {\n-      return MallocTracker::get_header_size(memblock);\n-    }\n-    return 0;\n+  \/\/ malloc tracking footer size for specific tracking level\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n+    return MallocTracker::malloc_footer_size(level);\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-#ifdef ASSERT\n@@ -265,1 +264,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,0 +300,9 @@\n+        \/**\n+         * Property to control {@link GetField#get(String, Object)} conversion of\n+         * {@link ClassNotFoundException} to {@code null}. If set to {@code true}\n+         * {@link GetField#get(String, Object)} returns null otherwise\n+         * throwing {@link ClassNotFoundException}.\n+         *\/\n+        private static final boolean GETFIELD_CNFE_RETURNS_NULL = GetBooleanAction\n+                .privilegedGetProperty(\"jdk.serialGetFieldCnfeReturnsNull\");\n+\n@@ -1599,0 +1608,1 @@\n+         * @throws ClassNotFoundException Class of a serialized object cannot be found.\n@@ -1604,1 +1614,1 @@\n-        public abstract Object get(String name, Object val) throws IOException;\n+        public abstract Object get(String name, Object val) throws IOException, ClassNotFoundException;\n@@ -2648,1 +2658,1 @@\n-        public Object get(String name, Object val) {\n+        public Object get(String name, Object val) throws ClassNotFoundException {\n@@ -2653,2 +2663,8 @@\n-                return (handles.lookupException(objHandle) == null) ?\n-                    objValues[off] : null;\n+                ClassNotFoundException ex = handles.lookupException(objHandle);\n+                if (ex == null)\n+                    return objValues[off];\n+                if (Caches.GETFIELD_CNFE_RETURNS_NULL) {\n+                    \/\/ Revert to the prior behavior; return null instead of CNFE\n+                    return null;\n+                }\n+                throw ex;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -113,1 +114,2 @@\n-    private volatile boolean enableNativeAccess;\n+    @Stable\n+    private boolean enableNativeAccess;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1670,0 +1670,4 @@\n+            @Override\n+            public Class<?>[] exceptionTypes(MethodHandle handle) {\n+                return VarHandles.exceptionTypes(handle);\n+            }\n@@ -2276,9 +2280,10 @@\n-            MH_cast                  = 0,\n-            MH_selectAlternative     = 1,\n-            MH_countedLoopPred       = 2,\n-            MH_countedLoopStep       = 3,\n-            MH_initIterator          = 4,\n-            MH_iteratePred           = 5,\n-            MH_iterateNext           = 6,\n-            MH_Array_newInstance     = 7,\n-            MH_LIMIT                 = 8;\n+            MH_cast                  =              0,\n+            MH_selectAlternative     =              1,\n+            MH_countedLoopPred       =              2,\n+            MH_countedLoopStep       =              3,\n+            MH_initIterator          =              4,\n+            MH_iteratePred           =              5,\n+            MH_iterateNext           =              6,\n+            MH_Array_newInstance     =              7,\n+            MH_VarHandles_handleCheckedExceptions = 8,\n+            MH_LIMIT                 =              9;\n@@ -2334,0 +2339,3 @@\n+                case MH_VarHandles_handleCheckedExceptions:\n+                    return IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n+                            MethodType.methodType(void.class, Throwable.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Parameter;\n@@ -37,1 +36,0 @@\n-import java.util.LinkedHashMap;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -48,2 +45,0 @@\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toList;\n@@ -362,1 +357,1 @@\n-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n+    public static VarHandle filterValue(VarHandle target, MethodHandle pFilterToTarget, MethodHandle pFilterFromTarget) {\n@@ -364,2 +359,2 @@\n-        Objects.requireNonNull(filterToTarget);\n-        Objects.requireNonNull(filterFromTarget);\n+        Objects.requireNonNull(pFilterToTarget);\n+        Objects.requireNonNull(pFilterFromTarget);\n@@ -367,2 +362,2 @@\n-        noCheckedExceptions(filterToTarget);\n-        noCheckedExceptions(filterFromTarget);\n+        MethodHandle filterToTarget = adaptForCheckedExceptions(pFilterToTarget);\n+        MethodHandle filterFromTarget = adaptForCheckedExceptions(pFilterFromTarget);\n@@ -476,2 +471,3 @@\n-            noCheckedExceptions(filters[i]);\n-            MethodType filterType = filters[i].type();\n+            MethodHandle filter = Objects.requireNonNull(filters[i]);\n+            filter = adaptForCheckedExceptions(filter);\n+            MethodType filterType = filter.type();\n@@ -567,1 +563,1 @@\n-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle pFilter) {\n@@ -569,2 +565,2 @@\n-        Objects.requireNonNull(filter);\n-        noCheckedExceptions(filter);\n+        Objects.requireNonNull(pFilter);\n+        MethodHandle filter = adaptForCheckedExceptions(pFilter);\n@@ -607,1 +603,23 @@\n-    private static void noCheckedExceptions(MethodHandle handle) {\n+    private static MethodHandle adaptForCheckedExceptions(MethodHandle target) {\n+        Class<?>[] exceptionTypes = exceptionTypes(target);\n+        if (exceptionTypes != null) { \/\/ exceptions known\n+            if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n+                throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n+            }\n+            return target; \/\/ no adaptation needed\n+        } else {\n+            MethodHandle handler = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_VarHandles_handleCheckedExceptions);\n+            MethodHandle zero = MethodHandles.zero(target.type().returnType()); \/\/ dead branch\n+            handler = MethodHandles.collectArguments(zero, 0, handler);\n+            return MethodHandles.catchException(target, Throwable.class, handler);\n+        }\n+    }\n+\n+    static void handleCheckedExceptions(Throwable throwable) throws Throwable {\n+        if (isCheckedException(throwable.getClass())) {\n+            throw new IllegalStateException(\"Adapter handle threw checked exception\", throwable);\n+        }\n+        throw throwable;\n+    }\n+\n+    static Class<?>[] exceptionTypes(MethodHandle handle) {\n@@ -614,1 +632,0 @@\n-            final Class<?>[] exceptionTypes;\n@@ -616,1 +633,1 @@\n-                exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -619,1 +636,1 @@\n-                exceptionTypes = null;\n+                return new Class<?>[0];\n@@ -621,1 +638,1 @@\n-                exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -626,5 +643,0 @@\n-            if (exceptionTypes != null) {\n-                if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n-                    throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n-                }\n-            }\n@@ -632,10 +644,3 @@\n-            noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());\n-        } else {\n-            \/\/bound\n-            BoundMethodHandle boundHandle = (BoundMethodHandle)handle;\n-            for (int i = 0 ; i < boundHandle.fieldCount() ; i++) {\n-                Object arg = boundHandle.arg(i);\n-                if (arg instanceof MethodHandle){\n-                    noCheckedExceptions((MethodHandle) arg);\n-                }\n-            }\n+            return exceptionTypes(((DelegatingMethodHandle)handle).getTarget());\n+        } else if (handle instanceof NativeMethodHandle) {\n+            return new Class<?>[0];\n@@ -643,0 +648,4 @@\n+\n+        assert handle instanceof BoundMethodHandle : \"Unexpected handle type: \" + handle;\n+        \/\/ unknown\n+        return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -35,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -55,0 +57,2 @@\n+    private static final int MAX_STRING_CONCAT_SLOTS = 20;\n+\n@@ -254,2 +258,3 @@\n-    private static MethodHandle makeToString(Class<?> receiverClass,\n-                                            List<MethodHandle> getters,\n+    private static MethodHandle makeToString(MethodHandles.Lookup lookup,\n+                                            Class<?> receiverClass,\n+                                            MethodHandle[] getters,\n@@ -257,20 +262,6 @@\n-        \/\/ This is a pretty lousy algorithm; we spread the receiver over N places,\n-        \/\/ apply the N getters, apply N toString operations, and concat the result with String.format\n-        \/\/ Better to use String.format directly, or delegate to StringConcatFactory\n-        \/\/ Also probably want some quoting around String components\n-\n-        assert getters.size() == names.size();\n-\n-        int[] invArgs = new int[getters.size()];\n-        Arrays.fill(invArgs, 0);\n-        MethodHandle[] filters = new MethodHandle[getters.size()];\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(receiverClass.getSimpleName()).append(\"[\");\n-        for (int i=0; i<getters.size(); i++) {\n-            MethodHandle getter = getters.get(i); \/\/ (R)T\n-            MethodHandle stringify = stringifier(getter.type().returnType()); \/\/ (T)String\n-            MethodHandle stringifyThisField = MethodHandles.filterArguments(stringify, 0, getter);    \/\/ (R)String\n-            filters[i] = stringifyThisField;\n-            sb.append(names.get(i)).append(\"=%s\");\n-            if (i != getters.size() - 1)\n-                sb.append(\", \");\n+        assert getters.length == names.size();\n+        if (getters.length == 0) {\n+            \/\/ special case\n+            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, receiverClass.getSimpleName() + \"[]\");\n+            emptyRecordCase = MethodHandles.dropArguments(emptyRecordCase, 0, receiverClass); \/\/ (R)S\n+            return emptyRecordCase;\n@@ -278,7 +269,85 @@\n-        sb.append(']');\n-        String formatString = sb.toString();\n-        MethodHandle formatter = MethodHandles.insertArguments(STRING_FORMAT, 0, formatString)\n-                                              .asCollector(String[].class, getters.size()); \/\/ (R*)String\n-        if (getters.size() == 0) {\n-            \/\/ Add back extra R\n-            formatter = MethodHandles.dropArguments(formatter, 0, receiverClass);\n+\n+        boolean firstTime = true;\n+        MethodHandle[] mhs;\n+        List<List<MethodHandle>> splits;\n+        MethodHandle[] toSplit = getters;\n+        int namesIndex = 0;\n+        do {\n+            \/* StringConcatFactory::makeConcatWithConstants can only deal with 200 slots, longs and double occupy two\n+             * the rest 1 slot, we need to chop the current `getters` into chunks, it could be that for records with\n+             * a lot of components that we need to do a couple of iterations. The main difference between the first\n+             * iteration and the rest would be on the recipe\n+             *\/\n+            splits = split(toSplit);\n+            mhs = new MethodHandle[splits.size()];\n+            for (int splitIndex = 0; splitIndex < splits.size(); splitIndex++) {\n+                String recipe = \"\";\n+                if (firstTime && splitIndex == 0) {\n+                    recipe = receiverClass.getSimpleName() + \"[\";\n+                }\n+                for (int i = 0; i < splits.get(splitIndex).size(); i++) {\n+                    recipe += firstTime ? names.get(namesIndex) + \"=\" + \"\\1\" : \"\\1\";\n+                    if (firstTime && namesIndex != names.size() - 1) {\n+                        recipe += \", \";\n+                    }\n+                    namesIndex++;\n+                }\n+                if (firstTime && splitIndex == splits.size() - 1) {\n+                    recipe += \"]\";\n+                }\n+                Class<?>[] concatTypeArgs = new Class<?>[splits.get(splitIndex).size()];\n+                \/\/ special case: no need to create another getters if there is only one split\n+                MethodHandle[] currentSplitGetters = new MethodHandle[splits.get(splitIndex).size()];\n+                for (int j = 0; j < splits.get(splitIndex).size(); j++) {\n+                    concatTypeArgs[j] = splits.get(splitIndex).get(j).type().returnType();\n+                    currentSplitGetters[j] = splits.get(splitIndex).get(j);\n+                }\n+                MethodType concatMT = MethodType.methodType(String.class, concatTypeArgs);\n+                try {\n+                    mhs[splitIndex] = StringConcatFactory.makeConcatWithConstants(\n+                            lookup, \"\",\n+                            concatMT,\n+                            recipe,\n+                            new Object[0]\n+                    ).getTarget();\n+                    mhs[splitIndex] = MethodHandles.filterArguments(mhs[splitIndex], 0, currentSplitGetters);\n+                    \/\/ this will spread the receiver class across all the getters\n+                    mhs[splitIndex] = MethodHandles.permuteArguments(\n+                            mhs[splitIndex],\n+                            MethodType.methodType(String.class, receiverClass),\n+                            new int[splits.get(splitIndex).size()]\n+                    );\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+            toSplit = mhs;\n+            firstTime = false;\n+        } while (splits.size() > 1);\n+        return mhs[0];\n+    }\n+\n+    \/**\n+     * Chops the getters into smaller chunks according to the maximum number of slots\n+     * StringConcatFactory::makeConcatWithConstants can chew\n+     * @param getters the current getters\n+     * @return chunks that wont surpass the maximum number of slots StringConcatFactory::makeConcatWithConstants can chew\n+     *\/\n+    private static List<List<MethodHandle>> split(MethodHandle[] getters) {\n+        List<List<MethodHandle>> splits = new ArrayList<>();\n+\n+        int slots = 0;\n+\n+        \/\/ Need to peel, so that neither call has more than acceptable number\n+        \/\/ of slots for the arguments.\n+        List<MethodHandle> cArgs = new ArrayList<>();\n+        for (MethodHandle methodHandle : getters) {\n+            Class<?> returnType = methodHandle.type().returnType();\n+            int needSlots = (returnType == long.class || returnType == double.class) ? 2 : 1;\n+            if (slots + needSlots > MAX_STRING_CONCAT_SLOTS) {\n+                splits.add(cArgs);\n+                cArgs = new ArrayList<>();\n+                slots = 0;\n+            }\n+            cArgs.add(methodHandle);\n+            slots += needSlots;\n@@ -286,3 +355,4 @@\n-        else {\n-            MethodHandle filtered = MethodHandles.filterArguments(formatter, 0, filters);\n-            formatter = MethodHandles.permuteArguments(filtered, MethodType.methodType(String.class, receiverClass), invArgs);\n+\n+        \/\/ Flush the tail slice\n+        if (!cArgs.isEmpty()) {\n+            splits.add(cArgs);\n@@ -291,1 +361,1 @@\n-        return formatter;\n+        return splits;\n@@ -370,1 +440,1 @@\n-                yield makeToString(recordClass, getterList, nameList);\n+                yield makeToString(lookup, recordClass, getters, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":104,"deletions":34,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-                public Scope.Handle acquireScope(Buffer buffer, boolean async) {\n+                public Runnable acquireScope(Buffer buffer, boolean async) {\n@@ -831,1 +831,2 @@\n-                    return scope.acquire();\n+                    scope.acquire0();\n+                    return scope::release0;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1065,1 +1065,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n@@ -1096,1 +1096,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n@@ -1163,1 +1163,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1199,1 +1199,1 @@\n-         * @implSpec The default implementation calls {@link JumpableGenerator#jump jump}().\n+         * @implSpec The default implementation calls {@link JumpableGenerator#jumps jumps}().\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -350,1 +350,3 @@\n- * interface {@link RandomGenerator.LeapableGenerator}. There is also an interface\n+ * interface {@link RandomGenerator.LeapableGenerator}. In this package,\n+ * implementations of this interface include \"Xoroshiro128PlusPlus\" and\n+ * \"Xoshiro256PlusPlus\". There is also an interface\n@@ -352,4 +354,2 @@\n- * jumping along the state cycle by any user-specified distance. In this package,\n- * implementations of these interfaces include\n- * \"Xoroshiro128PlusPlus\", and\n- * \"Xoshiro256PlusPlus\".\n+ * jumping along the state cycle by any user-specified distance; there are currently\n+ * no implementations of this interface in this package.\n@@ -385,2 +385,2 @@\n- * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", ACM Transactions\n- * on Mathematical Software, 2021) with an LCG that uses one of the best\n+ * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", <i>ACM Transactions\n+ * on Mathematical Software<\/i>, 2021) with an LCG that uses one of the best\n@@ -388,4 +388,9 @@\n- * in 2019 by Steele and Vigna), and then applies either a mixing function\n- * identified by Doug Lea or a simple scrambler proposed by Blackman and Vigna.\n- * Testing has confirmed that the LXM algorithm is far superior in quality to\n- * the SplitMix algorithm (2014) used by {@code SplittableRandom}.\n+ * in 2019 by Steele and Vigna, described in \"Computationally Easy, Spectrally\n+ * Good Multipliers for Congruential Pseudorandom Number Generators\",\n+ * <i>Software: Practice and Experience<\/i> (2021), doi:10.1002\/spe.3030),\n+ * and then applies either a mixing function identified by Doug Lea or\n+ * or a simple scrambler proposed by Blackman and Vigna. Testing has\n+ * confirmed that the LXM algorithm is far superior in quality to the\n+ * SplitMix algorithm (2014) used by {@code SplittableRandom}\n+ * (see Steele and Vigna, \"LXM: Better Splittable Pseudorandom Number\n+ * Generators (and Almost as Fast)\", <i>Proc. 2021 ACM OOPSLA Conference<\/i>).\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5608,0 +5608,31 @@\n+    private static CharPredicate and(CharPredicate p1, CharPredicate p2,\n+                                     boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) && p2.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) && p2.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate union(CharPredicate p1, CharPredicate p2,\n+                                       boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) || p2.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) || p2.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate union(CharPredicate p1, CharPredicate p2,\n+                                       CharPredicate p3, boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) || p2.is(ch) || p3.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) || p2.is(ch) || p3.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate negate(CharPredicate p1) {\n+        return (CharPredicate)(ch -> !p1.is(ch));\n+    }\n+\n@@ -5613,1 +5644,1 @@\n-            return ch -> is(ch) && p.is(ch);\n+            return Pattern.and(this, p, false);\n@@ -5616,1 +5647,1 @@\n-            return ch -> is(ch) || p.is(ch);\n+            return Pattern.union(this, p, false);\n@@ -5620,1 +5651,1 @@\n-            return ch -> is(ch) || p1.is(ch) || p2.is(ch);\n+            return Pattern.union(this, p1, p2, false);\n@@ -5623,1 +5654,1 @@\n-            return ch -> !is(ch);\n+            return Pattern.negate(this);\n@@ -5630,3 +5661,1 @@\n-            if (p instanceof BmpCharPredicate)\n-                return (BmpCharPredicate)(ch -> is(ch) && p.is(ch));\n-            return ch -> is(ch) && p.is(ch);\n+            return Pattern.and(this, p, p instanceof BmpCharPredicate);\n@@ -5635,17 +5664,7 @@\n-            if (p instanceof BmpCharPredicate)\n-                return (BmpCharPredicate)(ch -> is(ch) || p.is(ch));\n-            return ch -> is(ch) || p.is(ch);\n-        }\n-        static CharPredicate union(CharPredicate... predicates) {\n-            CharPredicate cp = ch -> {\n-                for (CharPredicate p : predicates) {\n-                    if (!p.is(ch))\n-                        return false;\n-                }\n-                return true;\n-            };\n-            for (CharPredicate p : predicates) {\n-                if (! (p instanceof BmpCharPredicate))\n-                    return cp;\n-            }\n-            return (BmpCharPredicate)cp;\n+            return Pattern.union(this, p, p instanceof BmpCharPredicate);\n+        }\n+        default CharPredicate union(CharPredicate p1,\n+                                    CharPredicate p2) {\n+            return Pattern.union(this, p1, p2,\n+                                 p1 instanceof BmpCharPredicate &&\n+                                 p2 instanceof BmpCharPredicate);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+        byte[] bytes = null;\n@@ -148,3 +149,4 @@\n-            this.comment = zc.getBytes(comment);\n-            if (this.comment.length > 0xffff)\n-                throw new IllegalArgumentException(\"ZIP file comment too long.\");\n+            bytes = zc.getBytes(comment);\n+            if (bytes.length > 0xffff) {\n+                throw new IllegalArgumentException(\"ZIP file comment too long\");\n+            }\n@@ -152,0 +154,1 @@\n+        this.comment = bytes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -184,0 +184,7 @@\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    Scope.Handle acquireScope(Buffer buffer, boolean async);\n+    Runnable acquireScope(Buffer buffer, boolean async);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,4 +106,0 @@\n-       interface Handle {\n-            Scope scope();\n-        }\n-\n@@ -114,3 +110,1 @@\n-        boolean isImplicit();\n-\n-        Handle acquire();\n+        void acquire0();\n@@ -118,1 +112,1 @@\n-        void release(Handle handle);\n+        void release0();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    private String getQualifiedFieldName() {\n+    protected String getQualifiedFieldName() {\n@@ -226,10 +226,0 @@\n-    protected String getMessage(boolean getter, String attemptedType) {\n-        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n-        if (Modifier.isStatic(field.getModifiers()))\n-            err += \" static\";\n-        if (Modifier.isFinal(field.getModifiers()))\n-            err += \" final\";\n-        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" on \" + attemptedType;\n-        return err;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-        ensureObj(obj);\n@@ -69,1 +68,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -125,1 +124,0 @@\n-        ensureObj(obj);\n@@ -127,0 +125,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -138,1 +137,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleBooleanFieldAccessorImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -130,1 +130,0 @@\n-        ensureObj(obj);\n@@ -132,0 +131,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -143,1 +143,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleByteFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -149,1 +149,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleCharacterFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -198,1 +198,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleDoubleFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Modifier;\n@@ -67,0 +68,13 @@\n+    private String getMessage(boolean getter, Class<?> type) {\n+        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName();\n+        if (type != null) {\n+            err += \" on \" + type.getName();\n+        }\n+        return err;\n+    }\n+\n@@ -71,2 +85,2 @@\n-    protected IllegalArgumentException newGetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(true, type.getName()));\n+    protected IllegalArgumentException newGetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(true, o != null ? o.getClass() : null));\n@@ -79,2 +93,2 @@\n-    protected IllegalArgumentException newSetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(false, type.getName()));\n+    protected IllegalArgumentException newSetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(false, o != null ? o.getClass() : null));\n@@ -82,2 +96,0 @@\n-\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFieldAccessorImpl.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -189,1 +189,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFloatFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -171,1 +171,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleIntegerFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -180,1 +180,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleLongFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -101,0 +101,1 @@\n+        ensureObj(obj);\n@@ -102,1 +103,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -114,1 +114,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ already ensure the receiver type.  So this CCE is due to the value.\n+            throwSetIllegalArgumentException(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleObjectFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -159,1 +159,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleShortFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -109,0 +110,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-    static Scope.Handle acquireScope(ByteBuffer bb, boolean async) {\n+    static Runnable acquireScope(ByteBuffer bb, boolean async) {\n@@ -482,1 +482,1 @@\n-    private static void releaseScope(Scope.Handle handle) {\n+    private static void releaseScope(Runnable handle) {\n@@ -486,1 +486,1 @@\n-            handle.scope().release(handle);\n+            handle.run();\n@@ -538,1 +538,1 @@\n-    static record Releaser(Scope.Handle handle) implements Runnable {\n+    static record Releaser(Runnable handle) implements Runnable {\n@@ -541,2 +541,2 @@\n-        static Runnable of(Scope.Handle handle) { return new Releaser(handle); }\n-        static Runnable ofNullable(Scope.Handle handle) {\n+        static Runnable of(Runnable handle) { return new Releaser(handle); }\n+        static Runnable ofNullable(Runnable handle) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-     * If this process leads to a list with a single element,\n-     * the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element, the\n+     * single element is returned, otherwise {@code null} is returned.\n@@ -158,2 +158,2 @@\n-     * If this process leads to a list with a single element,\n-     * the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element, the\n+     * single element is returned, otherwise {@code null} is returned.\n@@ -738,2 +738,3 @@\n-     * Returns the record component for the given accessor. Returns null if the\n-     * given method is not a record component accessor.\n+     * Returns the record component for the given accessor. Returns\n+     * {@code null} if the given method is not a record component\n+     * accessor.\n@@ -750,2 +751,2 @@\n-     * @return the record component, or null if the given method is not a record\n-     * component accessor\n+     * @return the record component, or {@code null} if the given\n+     * method is not a record component accessor\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    rolesMap = [[NSMutableDictionary alloc] initWithCapacity:50];\n+    rolesMap = [[NSMutableDictionary alloc] initWithCapacity:51];\n@@ -159,0 +159,1 @@\n+    [rolesMap setObject:@\"ProgressIndicatorAccessibility\" forKey:@\"progressbar\"];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CommonComponentAccessibility.m","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"JavaComponentAccessibility.h\"\n+#import \"GroupAccessibility.h\"\n+\n+#import <AppKit\/AppKit.h>\n+\n+@interface ProgressIndicatorAccessibility : GroupAccessibility {\n+\n+};\n+- (NSAccessibilityRole _Nonnull)accessibilityRole;\n+- (NSString * _Nullable)accessibilityValue;\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ProgressIndicatorAccessibility.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"ProgressIndicatorAccessibility.h\"\n+\n+\/*\n+ * Implementation of the accessibility peer for the NSProgressIndicator role.\n+ * Main usage is JProgressBar\n+ *\/\n+@implementation ProgressIndicatorAccessibility\n+\n+- (NSAccessibilityRole _Nonnull)accessibilityRole\n+{\n+    return NSAccessibilityProgressIndicatorRole;\n+}\n+\n+- (NSString * _Nullable)accessibilityValue\n+{\n+    return [super accessibilityValue];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ProgressIndicatorAccessibility.m","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -523,1 +523,1 @@\n-                String trimmedText = trimTrailingSpaces(text);\n+                String trimmedText = text.stripTrailing();\n@@ -869,1 +869,1 @@\n-                    String trimmedText = trimTrailingSpaces(text);\n+                    String trimmedText = text.stripTrailing();\n@@ -1324,8 +1324,0 @@\n-    private static String trimTrailingSpaces(String s) {\n-        int i = s.length() - 1;\n-        while(i >= 0 && Character.isWhitespace(s.charAt(i))) {\n-            i--;\n-        }\n-        return s.substring(0, i + 1);\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/SwingUtilities2.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1683,1 +1683,2 @@\n-            List<Type> coveredTypes = List.nil();\n+            List<Type> coveredTypesForPatterns = List.nil();\n+            List<Type> coveredTypesForConstants = List.nil();\n@@ -1721,1 +1722,1 @@\n-                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n+                                checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, sym.type);\n@@ -1754,1 +1755,1 @@\n-                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n@@ -1787,3 +1788,6 @@\n-                        checkCaseLabelDominated(pat.pos(), coveredTypes, patternType);\n-                        if (primary.unconditional() && !patternType.isErroneous()) {\n-                            coveredTypes = coveredTypes.prepend(patternType);\n+                        checkCaseLabelDominated(pat.pos(), coveredTypesForPatterns, patternType);\n+                        if (!patternType.isErroneous()) {\n+                            coveredTypesForConstants = coveredTypesForConstants.prepend(patternType);\n+                            if (primary.unconditional()) {\n+                                coveredTypesForPatterns = coveredTypesForPatterns.prepend(patternType);\n+                            }\n@@ -3953,1 +3957,1 @@\n-        Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);\n+        OperatorSymbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);\n@@ -3960,1 +3964,1 @@\n-            int opc = ((OperatorSymbol)operator).opcode;\n+            int opc = operator.opcode;\n@@ -4007,1 +4011,1 @@\n-        Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);\n+        OperatorSymbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);\n@@ -4013,1 +4017,1 @@\n-            int opc = ((OperatorSymbol)operator).opcode;\n+            int opc = operator.opcode;\n@@ -5497,1 +5501,1 @@\n-                Symbol sym = null;\n+                VarSymbol sym = null;\n@@ -5501,1 +5505,1 @@\n-                        ((VarSymbol) sym).getConstValue() == null)\n+                        sym.getConstValue() == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -754,1 +754,1 @@\n-        private void transitiveCovers(Set<Symbol> covered) {\n+        private void transitiveCovers(Type seltype, Set<Symbol> covered) {\n@@ -776,1 +776,1 @@\n-                                if (isTransitivelyCovered(sup.tsym, covered) &&\n+                                if (isTransitivelyCovered(seltype, sup.tsym, covered) &&\n@@ -787,1 +787,1 @@\n-        private boolean isTransitivelyCovered(Symbol sealed, Set<Symbol> covered) {\n+        private boolean isTransitivelyCovered(Type seltype, Symbol sealed, Set<Symbol> covered) {\n@@ -796,1 +796,4 @@\n-                                                 .allMatch(s -> isTransitivelyCovered(s, covered));\n+                                                 .filter(s -> {\n+                                                     return types.isCastable(seltype, s.type\/*, types.noWarnings*\/);\n+                                                 })\n+                                                 .allMatch(s -> isTransitivelyCovered(seltype, s, covered));\n@@ -808,1 +811,1 @@\n-            transitiveCovers(covered);\n+            transitiveCovers(seltype, covered);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -427,2 +427,2 @@\n-                JCTree captured_local = make.Ident(fv).setType(fv.type);\n-                syntheticInits.append((JCExpression) captured_local);\n+                JCExpression captured_local = make.Ident(fv).setType(fv.type);\n+                syntheticInits.append(captured_local);\n@@ -433,2 +433,2 @@\n-            JCTree captured_local = make.QualThis(fv.type);\n-            syntheticInits.append((JCExpression) captured_local);\n+            JCExpression captured_local = make.QualThis(fv.type);\n+            syntheticInits.append(captured_local);\n@@ -1187,1 +1187,1 @@\n-            Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,\n+            MethodSymbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,\n@@ -1193,1 +1193,1 @@\n-                                            ((MethodSymbol)bsm).asHandle(),\n+                                            bsm.asHandle(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    private final boolean optimizeOuterThis;\n@@ -122,0 +123,3 @@\n+        optimizeOuterThis =\n+            target.optimizeOuterThis() ||\n+            options.getBoolean(\"optimizeOuterThis\", false);\n@@ -1483,0 +1487,4 @@\n+        \/\/ Set NOOUTERTHIS for all synthetic outer instance variables, and unset\n+        \/\/ it when the variable is accessed. If the variable is never accessed,\n+        \/\/ we skip creating an outer instance field and saving the constructor\n+        \/\/ parameter to it.\n@@ -1484,1 +1492,1 @@\n-            new VarSymbol(flags, outerThisName(target, owner), target, owner);\n+            new VarSymbol(flags | NOOUTERTHIS, outerThisName(target, owner), target, owner);\n@@ -1731,0 +1739,1 @@\n+        ot.flags_field &= ~NOOUTERTHIS;\n@@ -1748,0 +1757,1 @@\n+            ot.flags_field &= ~NOOUTERTHIS;\n@@ -1787,0 +1797,1 @@\n+        ot.flags_field &= ~NOOUTERTHIS;\n@@ -1799,0 +1810,1 @@\n+            ot.flags_field &= ~NOOUTERTHIS;\n@@ -1820,2 +1832,1 @@\n-    JCStatement initOuterThis(int pos) {\n-        VarSymbol rhs = outerThisStack.head;\n+    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n@@ -1823,1 +1834,1 @@\n-        VarSymbol lhs = outerThisStack.tail.head;\n+        VarSymbol lhs = outerThisStack.head;\n@@ -2227,1 +2238,1 @@\n-        \/\/ Add this$n and free variables proxy definitions to class.\n+        \/\/ Add free variables proxy definitions to class.\n@@ -2233,1 +2244,3 @@\n-        if (currentClass.hasOuterInstance()) {\n+        \/\/ If this$n was accessed, add the field definition and\n+        \/\/ update initial constructors to initialize it\n+        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n@@ -2236,0 +2249,8 @@\n+\n+           for (JCTree def : tree.defs) {\n+                if (TreeInfo.isInitialConstructor(def)) {\n+                  JCMethodDecl mdef = (JCMethodDecl) def;\n+                  mdef.body.stats = mdef.body.stats.prepend(\n+                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                }\n+            }\n@@ -2252,0 +2273,33 @@\n+    private boolean shouldEmitOuterThis(ClassSymbol sym) {\n+      if (!optimizeOuterThis) {\n+        \/\/ Optimization is disabled\n+        return true;\n+      }\n+      if ((outerThisStack.head.flags_field & NOOUTERTHIS) == 0)  {\n+        \/\/ Enclosing instance field is used\n+        return true;\n+      }\n+      if (rs.isSerializable(sym.type) && !hasSerialVersionUID(sym)) {\n+        \/\/ Class is serializable and does not have a stable serialVersionUID\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private boolean hasSerialVersionUID(ClassSymbol sym) {\n+      VarSymbol svuid = (VarSymbol) sym.members().findFirst(names.serialVersionUID, f -> f.kind == VAR);\n+      if (svuid == null) {\n+        return false;\n+      }\n+      if ((svuid.flags() & (STATIC | FINAL)) != (STATIC | FINAL)) {\n+        return false;\n+      }\n+      if (!svuid.type.hasTag(LONG)) {\n+        return false;\n+      }\n+      if (svuid.getConstValue() == null) {\n+        return false;\n+      }\n+      return true;\n+    }\n+\n@@ -2318,1 +2372,1 @@\n-        Symbol valuesSym = lookupMethod(tree.pos(), names.values,\n+        MethodSymbol valuesSym = lookupMethod(tree.pos(), names.values,\n@@ -2369,1 +2423,1 @@\n-             make.MethodDef((MethodSymbol)valuesSym, make.Block(0, valuesBody));\n+             make.MethodDef(valuesSym, make.Block(0, valuesBody));\n@@ -2584,1 +2638,1 @@\n-        Symbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,\n+        MethodSymbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,\n@@ -2596,1 +2650,1 @@\n-                ((MethodSymbol)bsm).asHandle(),\n+                bsm.asHandle(),\n@@ -2706,5 +2760,0 @@\n-            if (currentClass.hasOuterInstance() &&\n-                TreeInfo.isInitialConstructor(tree))\n-            {\n-                added = added.prepend(initOuterThis(tree.body.pos));\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":64,"deletions":15,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-            Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n+            MethodSymbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n@@ -385,1 +385,1 @@\n-                    ((MethodSymbol)bsm).asHandle(),\n+                    bsm.asHandle(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-                Symbol bsm = rs.resolveInternalMethod(pos,\n+                MethodSymbol bsm = rs.resolveInternalMethod(pos,\n@@ -383,1 +383,1 @@\n-                        ((MethodSymbol)bsm).asHandle(),\n+                        bsm.asHandle(),\n@@ -490,1 +490,1 @@\n-                Symbol bsm = rs.resolveInternalMethod(pos,\n+                MethodSymbol bsm = rs.resolveInternalMethod(pos,\n@@ -499,1 +499,1 @@\n-                        ((MethodSymbol)bsm).asHandle(),\n+                        bsm.asHandle(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/StringConcat.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -206,0 +206,7 @@\n+\n+    \/** Omit unused enclosing instance fields from inner classes that don't access enclosing\n+     * instance state.\n+     *\/\n+    public boolean optimizeOuterThis() {\n+        return compareTo(JDK1_18) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -357,0 +357,1 @@\n+        javacOpts.add(\"-Xlint:-options\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -513,0 +513,5 @@\n+\n+        @Override\n+        public void process(OptionHelper helper, String option, String arg) throws InvalidValueException {\n+            throw helper.newInvalidValueException(Errors.InvalidFlag(option + arg));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import sun.jvm.hotspot.memory.SystemDictionary;\n@@ -97,1 +96,0 @@\n-import sun.jvm.hotspot.utilities.CompactHashTable;\n@@ -101,1 +99,0 @@\n-import sun.jvm.hotspot.utilities.ObjectReader;\n@@ -135,1 +132,1 @@\n-                \/\/ together duplicate classes are a possibilty.  For\n+                \/\/ together duplicate classes are a possibility.  For\n@@ -439,1 +436,0 @@\n-                    String format = \"\";\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import sun.jvm.hotspot.memory.*;\n@@ -1740,1 +1739,0 @@\n-    sun.jvm.hotspot.oops.ObjectHistogram histo = new sun.jvm.hotspot.oops.ObjectHistogram();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,1 +429,0 @@\n-    long size = 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotTypeDataBase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,0 @@\n-    int RADIX = (1 << LOG2_RADIX);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.*;\n@@ -91,1 +90,0 @@\n-      int i = 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubQueue.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,1 +420,0 @@\n-    int moduleNumber = 0; \/\/ Debugging\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgCDebugInfoBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,1 +313,1 @@\n-  boolean  _got_error;      \/\/ True, if an error occured during interpretation.\n+  boolean  _got_error;      \/\/ True, if an error occurred during interpretation.\n@@ -316,1 +316,1 @@\n-  \/\/  bool     _did_relocation; \/\/ was relocation neccessary\n+  \/\/  bool     _did_relocation; \/\/ was relocation necessary\n@@ -532,1 +532,0 @@\n-    boolean change = false;\n@@ -1897,1 +1896,1 @@\n-  boolean  _report_result_for_send;         \/\/ Unfortunatly, stackmaps for sends are special, so we need some extra\n+  boolean  _report_result_for_send;         \/\/ Unfortunately, stackmaps for sends are special, so we need some extra\n@@ -1950,1 +1949,1 @@\n-  boolean   _conflict;                      \/\/ True, if a conflict occured during interpretation\n+  boolean   _conflict;                      \/\/ True, if a conflict occurred during interpretation\n@@ -2134,1 +2133,1 @@\n-    \/\/ We have to initialize all variables here, that can be queried direcly\n+    \/\/ We have to initialize all variables here, that can be queried directly\n@@ -2207,1 +2206,1 @@\n-      \/\/ an exception thrown in this part of the code is likly to mean that we are executing some\n+      \/\/ an exception thrown in this part of the code is likely to mean that we are executing some\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/GenerateOopMap.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1284,2 +1284,0 @@\n-            boolean isFloat = (type == Location.Type.FLOAT_IN_DBL ||\n-                               type == Location.Type.DBL);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/classbrowser\/HTMLGenerator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -29,1 +32,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +33,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -37,3 +38,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -43,2 +41,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -48,0 +44,1 @@\n+import static java.lang.constant.ConstantDescs.CD_Class;\n@@ -55,1 +52,3 @@\n-    final Map<String, Constable> attributes;\n+    private final Optional<String> name;\n+    @Stable\n+    long cachedSize;\n@@ -57,1 +56,1 @@\n-    public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> attributes) {\n+    public AbstractLayout(OptionalLong size, long alignment, Optional<String> name) {\n@@ -60,1 +59,1 @@\n-        this.attributes = Collections.unmodifiableMap(attributes);\n+        this.name = name;\n@@ -66,1 +65,1 @@\n-        return withAttribute(LAYOUT_NAME, name);\n+        return dup(alignment, Optional.of(name));\n@@ -71,20 +70,1 @@\n-        return attribute(LAYOUT_NAME).map(String.class::cast);\n-    }\n-\n-    @Override\n-    public Optional<Constable> attribute(String name) {\n-        Objects.requireNonNull(name);\n-        return Optional.ofNullable(attributes.get(name));\n-    }\n-\n-    @Override\n-    public Stream<String> attributes() {\n-        return attributes.keySet().stream();\n-    }\n-\n-    @Override\n-    public AbstractLayout withAttribute(String name, Constable value) {\n-        Objects.requireNonNull(name);\n-        Map<String, Constable> newAttributes = new HashMap<>(attributes);\n-        newAttributes.put(name, value);\n-        return dup(alignment, newAttributes);\n+        return name;\n@@ -93,1 +73,1 @@\n-    abstract AbstractLayout dup(long alignment, Map<String, Constable> annos);\n+    abstract AbstractLayout dup(long alignment, Optional<String> name);\n@@ -98,1 +78,1 @@\n-        return dup(alignmentBits, attributes);\n+        return dup(alignmentBits, name);\n@@ -123,0 +103,9 @@\n+    @Override\n+    public long byteSize() {\n+        if (cachedSize == 0) {\n+            cachedSize = Utils.bitsToBytesOrThrow(bitSize(),\n+                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n+        }\n+        return cachedSize;\n+    }\n+\n@@ -148,5 +137,0 @@\n-        if (!attributes.isEmpty()) {\n-            s += attributes.entrySet().stream()\n-                                      .map(e -> e.getKey() + \"=\" + e.getValue())\n-                                      .collect(Collectors.joining(\",\", \"[\", \"]\"));\n-        }\n@@ -161,3 +145,3 @@\n-        for (var e : attributes.entrySet()) {\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withAttribute\", desc.constantType(), MH_WITH_ATTRIBUTE,\n-                    desc, e.getKey(), e.getValue().describeConstable().orElseThrow());\n+        if (name().isPresent()) {\n+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withName\", desc.constantType(), MH_WITH_NAME,\n+                    desc, name().get().describeConstable().orElseThrow());\n@@ -180,1 +164,1 @@\n-        return attributes.hashCode() << Long.hashCode(alignment);\n+        return name.hashCode() << Long.hashCode(alignment);\n@@ -193,1 +177,1 @@\n-        return Objects.equals(attributes, ((AbstractLayout) other).attributes) &&\n+        return Objects.equals(name, ((AbstractLayout) other).name) &&\n@@ -211,2 +195,0 @@\n-    static final ClassDesc CD_Constable = Constable.class.describeConstable().get();\n-\n@@ -220,3 +202,0 @@\n-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n-                MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_long, CD_BYTEORDER));\n-\n@@ -235,0 +214,3 @@\n+    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n+            MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_Class, CD_BYTEORDER));\n+\n@@ -244,2 +226,2 @@\n-    static final MethodHandleDesc MH_WITH_ATTRIBUTE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withAttribute\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String, CD_Constable));\n+    static final MethodHandleDesc MH_WITH_NAME = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withName\",\n+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":32,"deletions":50,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -30,2 +30,6 @@\n- * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},\n- * {@link MemoryAddress} and {@link CLinker.VaList}.\n+ * a {@linkplain #address() memory address}. Examples of addressable types are {@link MemorySegment},\n+ * {@link MemoryAddress}, {@link VaList} and {@link NativeSymbol}.\n+ * <p>\n+ * The {@link Addressable} type is used by the {@link CLinker C linker} to model the types of\n+ * {@link CLinker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n+ * (e.g. memory addresses, va lists and upcall stubs).\n@@ -36,1 +40,2 @@\n-public interface Addressable {\n+public sealed interface Addressable permits MemorySegment, MemoryAddress, NativeSymbol, VaList {\n+\n@@ -38,2 +43,2 @@\n-     * Map this object into a {@link MemoryAddress} instance.\n-     * @return the {@link MemoryAddress} instance associated with this object.\n+     * Returns the memory address associated with this addressable.\n+     * @return The memory address associated with this addressable.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -33,4 +30,4 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n-import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n-import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n@@ -40,1 +37,0 @@\n-import java.lang.constant.Constable;\n@@ -43,6 +39,1 @@\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import static jdk.internal.foreign.PlatformLayouts.*;\n+import java.util.Optional;\n@@ -53,1 +44,3 @@\n- * follow the JVM's target platform C ABI.\n+ * follow the JVM's target platform C ABI. A C linker provides two main capabilities: first, it allows Java code\n+ * to <em>link<\/em> foreign functions into a so called <em>downcall method handle<\/em>; secondly, it allows\n+ * native code to call Java method handles via the generation of <em>upcall stubs<\/em>.\n@@ -55,5 +48,1 @@\n- * Linking a foreign function is a process which requires two components: a method type, and\n- * a function descriptor. The method type, consists of a set of <em>carrier<\/em> types, which, together,\n- * specify the Java signature which clients must adhere to when calling the underlying foreign function.\n- * The function descriptor contains a set of memory layouts which, together, specify the foreign function\n- * signature and classification information (via a custom layout attributes, see {@link TypeKind}), so that linking can take place.\n+ * On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n@@ -61,6 +50,21 @@\n- * Clients of this API can build function descriptors using the predefined memory layout constants\n- * (based on a subset of the built-in types provided by the C language), found in this interface; alternatively,\n- * they can also decorate existing value layouts using the required {@link TypeKind} classification attribute\n- * (this can be done using the {@link MemoryLayout#withAttribute(String, Constable)} method). A failure to do so might\n- * result in linkage errors, given that linking requires additional classification information to determine, for instance,\n- * how arguments should be loaded into registers during a foreign function call.\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n+ * <h2><a id = \"downcall-method-handles\">Downcall method handles<\/a><\/h2>\n+ * <p>\n+ * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n+ * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target native function.\n+ * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is\n+ * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n+ * as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n@@ -68,5 +72,21 @@\n- * Implementations of this interface support the following primitive carrier types:\n- * {@code byte}, {@code short}, {@code char}, {@code int}, {@code long}, {@code float},\n- * and {@code double}, as well as {@link MemoryAddress} for passing pointers, and\n- * {@link MemorySegment} for passing structs and unions. Finally, the {@link VaList}\n- * carrier type can be used to match the native {@code va_list} type.\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters:\n+ * <ul>\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a native symbol},\n+ * the downcall method handle type features a leading parameter of type {@link NativeSymbol}, from which the\n+ * address of the target native function can be derived.<\/li>\n+ * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by the downcall method handle.<\/li>\n+ * <\/ul>\n+ * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n+ * list or with an empty formal parameter list, are not supported directly. However, it is possible to link a native\n+ * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>} function descriptor,\n+ * in which the specialized signature of a given variable arity callsite is described in full. Alternatively,\n+ * if the foreign library allows it, clients might also be able to interact with variable arity methods\n+ * by passing a trailing parameter of type {@link VaList}.\n+ *\n+ * <h2><a id = \"upcall-stubs\">Upcall stubs<\/a><\/h2>\n+ *\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) Creating an upcall stub} requires a method\n+ * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n+ * specify the signature of the function pointer associated with the upcall stub.\n@@ -74,3 +94,3 @@\n- * For the linking process to be successful, some requirements must be satisfied; if {@code M} and {@code F} are\n- * the method type (obtained after dropping any prefix arguments) and the function descriptor, respectively,\n- * used during the linking process, then it must be that:\n+ * The type of the provided method handle has to match the Java {@link java.lang.invoke.MethodType method type}\n+ * associated with the upcall stub, which is derived from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n@@ -78,5 +98,1 @@\n- *     <li>The arity of {@code M} is the same as that of {@code F};<\/li>\n- *     <li>If the return type of {@code M} is {@code void}, then {@code F} should have no return layout\n- *     (see {@link FunctionDescriptor#ofVoid(MemoryLayout...)});<\/li>\n- *     <li>for each pair of carrier type {@code C} and layout {@code L} in {@code M} and {@code F}, respectively,\n- *     where {@code C} and {@code L} refer to the same argument, or to the return value, the following conditions must hold:\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n@@ -84,9 +100,5 @@\n- *       <li>If {@code C} is a primitve type, then {@code L} must be a {@code ValueLayout}, and the size of the layout must match\n- *       that of the carrier type (see {@link Integer#SIZE} and similar fields in other primitive wrapper classes);<\/li>\n- *       <li>If {@code C} is {@code MemoryAddress.class}, then {@code L} must be a {@code ValueLayout}, and its size must match\n- *       the platform's address size (see {@link MemoryLayouts#ADDRESS}). For this purpose, the {@link CLinker#C_POINTER} layout\n- *       constant can  be used;<\/li>\n- *       <li>If {@code C} is {@code MemorySegment.class}, then {@code L} must be a {@code GroupLayout}<\/li>\n- *       <li>If {@code C} is {@code VaList.class}, then {@code L} must be {@link CLinker#C_VA_LIST}<\/li>\n- *     <\/ul>\n- *     <\/li>\n+ *         <li>if {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -94,0 +106,3 @@\n+ * Upcall stubs are modelled by instances of type {@link NativeSymbol}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link NativeSymbol} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain NativeSymbol#scope() scope}.\n@@ -95,10 +110,1 @@\n- * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n- * list or with an empty formal parameter list, are not supported directly. It is not possible to create a method handle\n- * that takes a variable number of arguments, and neither is it possible to create an upcall stub wrapping a method\n- * handle that accepts a variable number of arguments. However, for downcalls only, it is possible to link a native\n- * variadic function by using a <em>specialized<\/em> method type and function descriptor: for each argument that is to be\n- * passed as a variadic argument, an explicit, additional, carrier type and memory layout must be present in the method type and\n- * function descriptor objects passed to the linker. Furthermore, as memory layouts corresponding to variadic arguments in\n- * a function descriptor must contain additional classification information, it is required that\n- * {@link #asVarArg(MemoryLayout)} is used to create the memory layouts for each parameter corresponding to a variadic\n- * argument in a specialized function descriptor.\n+ * <h2>System lookup<\/h2>\n@@ -106,1 +112,3 @@\n- * <p>On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n+ * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) lookup} symbols\n+ * in the standard libraries associated with this linker. The set of symbols available for lookup is unspecified,\n+ * as it depends on the platform and on the operating system.\n@@ -108,2 +116,24 @@\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ * <h2>Safety considerations<\/h2>\n+ *\n+ * Obtaining downcall method handle is intrinsically unsafe. A symbol in a native library does not, in general,\n+ * contain enough signature information (e.g. arity and types of native function parameters). As a consequence,\n+ * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n+ * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n+ * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n+ * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment},\n+ * {@link NativeSymbol} or {@link VaList}):\n+ * <ul>\n+ *     <li>The resource scope of {@code R} is {@linkplain ResourceScope#isAlive() alive}. Otherwise, the invocation throws\n+ *     {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in same thread as the one {@link ResourceScope#ownerThread() owning} the resource scope of {@code R},\n+ *     if said scope is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n+ *     <li>The scope of {@code R} is {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} (and cannot be closed) during the invocation.\n+ *<\/ul>\n+ * <p>\n+ * When creating upcall stubs the linker runtime validates the type of the target method handle against the provided\n+ * function descriptor and report an error if any mismatch is detected. As for downcalls, JVM crashes might occur,\n+ * if the native code casts the function pointer associated with an upcall stub to a type\n+ * that is incompatible with the provided function descriptor. Moreover, if the target method\n+ * handle associated with an upcall stub returns a {@linkplain MemoryAddress native address}, clients must ensure\n+ * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n+ * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n@@ -114,1 +144,1 @@\n-public sealed interface CLinker permits AbstractCLinker {\n+public sealed interface CLinker extends SymbolLookup permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n@@ -130,1 +160,1 @@\n-    static CLinker getInstance() {\n+    static CLinker systemCLinker() {\n@@ -136,11 +166,3 @@\n-     * Obtains a system lookup which is suitable to find symbols in the standard C libraries. The set of symbols\n-     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Lookup a symbol in the standard libraries associated with this linker.\n+     * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * @return a symbol in the standard libraries associated with this linker.\n@@ -148,4 +170,3 @@\n-    @CallerSensitive\n-    static SymbolLookup systemLookup() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return SystemLookup.getInstance();\n+    @Override\n+    default Optional<NativeSymbol> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n@@ -156,1 +177,1 @@\n-     * which can be used to call a target foreign function at the given address.\n+     * which can be used to call a target foreign function at the address in the given native symbol.\n@@ -161,0 +182,5 @@\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+<blockquote><pre>{@code\n+    linker.downcallHandle(function).bindTo(symbol);\n+}<\/pre><\/blockquote>\n@@ -163,1 +189,0 @@\n-     * @param type     the method type.\n@@ -165,22 +190,3 @@\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n-     *                                  is {@link MemoryAddress#NULL}\n-     *\n-     * @see SymbolLookup\n-     *\/\n-    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n-\n-    \/**\n-     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n-     * which can be used to call a target foreign function at the given address.\n-     * <p>\n-     * If the provided method type's return type is {@code MemorySegment}, then the provided allocator will be used by\n-     * the linker runtime to allocate structs returned by-value.\n-     *\n-     * @param symbol    downcall symbol.\n-     * @param allocator the segment allocator.\n-     * @param type      the method type.\n-     * @param function  the function descriptor.\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n-     *                                  is {@link MemoryAddress#NULL}\n+     * @return the downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n+     * or if the symbol is {@link MemoryAddress#NULL}\n@@ -190,1 +196,4 @@\n-    MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function);\n+    default MethodHandle downcallHandle(NativeSymbol symbol, FunctionDescriptor function) {\n+        SharedUtils.checkSymbol(symbol);\n+        return downcallHandle(function).bindTo(symbol);\n+    }\n@@ -194,3 +203,3 @@\n-     * used to call a target foreign function at an address.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the address, of\n-     * type {@link Addressable}.\n+     * used to call a target foreign function at the address in a dynamically provided native symbol.\n+     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n+     * entry point, of type {@link NativeSymbol}.\n@@ -198,1 +207,1 @@\n-     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features an\n+     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n@@ -202,2 +211,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the target address passed to it is\n-     * {@link MemoryAddress#NULL}, or a {@link NullPointerException} if the target address is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the native symbol passed to it is\n+     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if the native symbol is {@code null}.\n@@ -205,1 +214,0 @@\n-     * @param type     the method type.\n@@ -207,2 +215,3 @@\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     * @return the downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * from the provided function descriptor.\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout.\n@@ -212,1 +221,1 @@\n-    MethodHandle downcallHandle(MethodType type, FunctionDescriptor function);\n+    MethodHandle downcallHandle(FunctionDescriptor function);\n@@ -219,1 +228,1 @@\n-     * The returned memory address is associated with the provided scope. When such scope is closed,\n+     * The returned function pointer is associated with the provided scope. When such scope is closed,\n@@ -231,2 +240,4 @@\n-     * @return the native stub segment.\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @return the native stub symbol.\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n+     * or if it is determined that the target method handle can throw an exception, or if the target method handle\n+     * has a type that does not match the upcall stub <a href=\"CLinker.html#upcall-stubs\"><em>inferred type<\/em><\/a>.\n@@ -236,147 +247,1 @@\n-    MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n-\n-    \/**\n-     * The layout for the {@code char} C type\n-     *\/\n-    ValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n-    \/**\n-     * The layout for the {@code short} C type\n-     *\/\n-    ValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n-    \/**\n-     * The layout for the {@code int} C type\n-     *\/\n-    ValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n-    \/**\n-     * The layout for the {@code long} C type\n-     *\/\n-    ValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n-    \/**\n-     * The layout for the {@code long long} C type.\n-     *\/\n-    ValueLayout C_LONG_LONG = pick(SysV.C_LONG_LONG, Win64.C_LONG_LONG, AArch64.C_LONG_LONG);\n-    \/**\n-     * The layout for the {@code float} C type\n-     *\/\n-    ValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n-    \/**\n-     * The layout for the {@code double} C type\n-     *\/\n-    ValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n-    \/**\n-     * The {@code T*} native type.\n-     *\/\n-    ValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n-    \/**\n-     * The layout for the {@code va_list} C type\n-     *\/\n-    MemoryLayout C_VA_LIST = pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);\n-\n-    \/**\n-     * Returns a memory layout that is suitable to use as the layout for variadic arguments in a specialized\n-     * function descriptor.\n-     * @param <T> the memory layout type\n-     * @param layout the layout the adapt\n-     * @return a potentially newly created layout with the right attributes\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    static <T extends MemoryLayout> T asVarArg(T layout) {\n-        Objects.requireNonNull(layout);\n-        return (T) PlatformLayouts.asVarArg(layout);\n-    }\n-\n-    \/**\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n-     * storing the result into a native memory segment allocated using the provided allocator.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param allocator the allocator to be used for the native segment allocation.\n-     * @return a new native memory segment containing the converted C string.\n-     *\/\n-    static MemorySegment toCString(String str, SegmentAllocator allocator) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(allocator);\n-        return toCString(str.getBytes(StandardCharsets.UTF_8), allocator);\n-    }\n-\n-    \/**\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n-     * storing the result into a native memory segment associated with the provided resource scope.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param scope the resource scope to be associated with the returned segment.\n-     * @return a new native memory segment containing the converted C string.\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n-     *\/\n-    static MemorySegment toCString(String str, ResourceScope scope) {\n-        return toCString(str, SegmentAllocator.ofScope(scope));\n-    }\n-\n-    \/**\n-     * Converts a UTF-8 encoded, null-terminated C string stored at given address into a Java string.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform,\n-     * or if {@code addr == MemoryAddress.NULL}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static String toJavaString(MemoryAddress addr) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SharedUtils.checkAddress(addr);\n-        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue());\n-    }\n-\n-    \/**\n-     * Converts a UTF-8 encoded, null-terminated C string stored at given address into a Java string.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n-     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n-     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n-     *\/\n-    static String toJavaString(MemorySegment addr) {\n-        Objects.requireNonNull(addr);\n-        return SharedUtils.toJavaStringInternal(addr, 0L);\n-    }\n-\n-    private static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n-    }\n-\n-    private static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n+    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n@@ -385,13 +250,5 @@\n-     * Allocates memory of given size using malloc.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param size memory size to be allocated\n-     * @return addr memory address of the allocated memory\n-     * @throws OutOfMemoryError if malloc could not allocate the required amount of native memory.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Obtains the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n@@ -399,9 +256,2 @@\n-    @CallerSensitive\n-    static MemoryAddress allocateMemory(long size) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        MemoryAddress addr = SharedUtils.allocateMemoryInternal(size);\n-        if (addr.equals(MemoryAddress.NULL)) {\n-            throw new OutOfMemoryError();\n-        } else {\n-            return addr;\n-        }\n+    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, false);\n@@ -411,12 +261,5 @@\n-     * Frees the memory pointed by the given memory address.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr memory address of the native memory to be freed\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * @throws IllegalArgumentException if {@code addr == MemoryAddress.NULL}.\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Obtains the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n@@ -424,365 +267,2 @@\n-    @CallerSensitive\n-    static void freeMemory(MemoryAddress addr) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SharedUtils.checkAddress(addr);\n-        SharedUtils.freeMemoryInternal(addr);\n-    }\n-\n-    \/**\n-     * An interface that models a C {@code va_list}.\n-     * <p>\n-     * A va list is a stateful cursor used to iterate over a set of variadic arguments.\n-     * <p>\n-     * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n-     * arguments to variadic calls are erased by way of 'default argument promotions',\n-     * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n-     * and which erases all {@code float} arguments to {@code double}.\n-     * <p>\n-     * As such, this interface only supports reading {@code int}, {@code double},\n-     * and any other type that fits into a {@code long}.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n-     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n-     *\/\n-    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n-\n-        \/**\n-         * Reads the next value as an {@code int} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code int}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-         *\/\n-        int vargAsInt(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code long} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code long}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-         *\/\n-        long vargAsLong(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code double} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code double}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-         *\/\n-        double vargAsDouble(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code MemoryAddress}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-         *\/\n-        MemoryAddress vargAsAddress(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n-         *\n-         * @param layout the layout of the value\n-         * @param allocator the allocator to be used for the native segment allocation\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be associated with the given {@link ResourceScope}.\n-         *\n-         * @param layout the layout of the value\n-         * @param scope the resource scope to be associated with the returned segment\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope);\n-\n-        \/**\n-         * Skips a number of elements with the given memory layouts, and advances this va list's position.\n-         *\n-         * @param layouts the layout of the value\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         *\/\n-        void skip(MemoryLayout... layouts);\n-\n-        \/**\n-         * Returns the resource scope associated with this instance.\n-         * @return the resource scope associated with this instance.\n-         *\/\n-        ResourceScope scope();\n-\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * Any native resource required by the execution of this method will be allocated in the resource scope\n-         * associated with this instance (see {@link #scope()}).\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         *\/\n-        VaList copy();\n-\n-        \/**\n-         * Returns the memory address of the C {@code va_list} associated with this instance.\n-         * The returned memory address is associated with same resource scope as that associated with this instance.\n-         *\n-         * @return the memory address of the C {@code va_list} associated with this instance.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * backed by the {@linkplain ResourceScope#globalScope() global} resource scope.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-         *\/\n-        @CallerSensitive\n-        static VaList ofAddress(MemoryAddress address) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * with given resource scope.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-         *\/\n-        @CallerSensitive\n-        static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            Objects.requireNonNull(address);\n-            Objects.requireNonNull(scope);\n-            return SharedUtils.newVaListOfAddress(address, scope);\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n-         * {@linkplain ResourceScope resource scope}.\n-         * <p>\n-         * If this method needs to allocate native memory, such memory will be managed by the given\n-         * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@link #empty()}.\n-         *\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @param scope the scope to be used for the valist allocation.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         *\/\n-        static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n-            Objects.requireNonNull(actions);\n-            Objects.requireNonNull(scope);\n-            return SharedUtils.newVaList(actions, scope);\n-        }\n-\n-        \/**\n-         * Returns an empty C {@code va_list} constant.\n-         * <p>\n-         * The returned {@code VaList} can not be closed.\n-         *\n-         * @return a {@code VaList} modelling an empty C {@code va_list}.\n-         *\/\n-        static VaList empty() {\n-            return SharedUtils.emptyVaList();\n-        }\n-\n-        \/**\n-         * A builder interface used to construct a C {@code va_list}.\n-         *\n-         * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n-         * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n-         *\/\n-        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n-\n-            \/**\n-             * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as an {@code int}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-             *\/\n-            Builder vargFromInt(ValueLayout layout, int value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code long}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-             *\/\n-            Builder vargFromLong(ValueLayout layout, long value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code double}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-             *\/\n-            Builder vargFromDouble(ValueLayout layout, double value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code Addressable}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-             *\/\n-            Builder vargFromAddress(ValueLayout layout, Addressable value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code MemorySegment}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-             *\/\n-            Builder vargFromSegment(GroupLayout layout, MemorySegment value);\n-        }\n-    }\n-\n-    \/**\n-     * A C type kind. Each kind corresponds to a particular C language builtin type, and can be attached to\n-     * {@link ValueLayout} instances using the {@link MemoryLayout#withAttribute(String, Constable)} in order\n-     * to obtain a layout which can be classified accordingly by {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}\n-     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}.\n-     *\/\n-    enum TypeKind {\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code char} type\n-         *\/\n-        CHAR(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code short} type\n-         *\/\n-        SHORT(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code int} type\n-         *\/\n-        INT(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code long} type\n-         *\/\n-        LONG(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code long long} type\n-         *\/\n-        LONG_LONG(true),\n-        \/**\n-         * A kind corresponding to the <em>floating-point<\/em> C {@code float} type\n-         *\/\n-        FLOAT(false),\n-        \/**\n-         * A kind corresponding to the <em>floating-point<\/em> C {@code double} type\n-         *\/\n-        DOUBLE(false),\n-        \/**\n-         * A kind corresponding to the an <em>integral<\/em> C pointer type\n-         *\/\n-        POINTER(false);\n-\n-        private final boolean isIntegral;\n-\n-        TypeKind(boolean isIntegral) {\n-            this.isIntegral = isIntegral;\n-        }\n-\n-        \/**\n-         * Is this kind integral?\n-         *\n-         * @return true if this kind is integral\n-         *\/\n-        public boolean isIntegral() {\n-            return isIntegral;\n-        }\n-\n-        \/**\n-         * Is this kind a floating point type?\n-         *\n-         * @return true if this kind is a floating point type\n-         *\/\n-        public boolean isFloat() {\n-            return !isIntegral() && !isPointer();\n-        }\n-\n-        \/**\n-         * Is this kind a pointer kind?\n-         *\n-         * @return true if this kind is a pointer kind\n-         *\/\n-        public boolean isPointer() {\n-            return this == POINTER;\n-        }\n-\n-        \/**\n-         * The layout attribute name associated with this classification kind. Clients can retrieve the type kind\n-         * of a layout using the following code:\n-         * <blockquote><pre>{@code\n-        ValueLayout layout = ...\n-        TypeKind = layout.attribute(TypeKind.ATTR_NAME).orElse(null);\n-         * }<\/pre><\/blockquote>\n-         *\/\n-        public static final String ATTR_NAME = \"abi\/kind\";\n+    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, true);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":142,"deletions":662,"binary":false,"changes":804,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n@@ -36,1 +34,0 @@\n-import java.util.Map;\n@@ -49,7 +46,1 @@\n-public final class FunctionDescriptor implements Constable {\n-\n-    \/**\n-     * The name of the function descriptor attribute (see {@link #attributes()} used to mark trivial functions. The\n-     * attribute value must be a boolean.\n-     *\/\n-    public static final String TRIVIAL_ATTRIBUTE_NAME = \"abi\/trivial\";\n+public sealed class FunctionDescriptor implements Constable permits FunctionDescriptor.VariadicFunction {\n@@ -58,2 +49,1 @@\n-    private final MemoryLayout[] argLayouts;\n-    private final Map<String, Constable> attributes;\n+    private final List<MemoryLayout> argLayouts;\n@@ -61,1 +51,1 @@\n-    private FunctionDescriptor(MemoryLayout resLayout, Map<String, Constable> attributes, MemoryLayout... argLayouts) {\n+    private FunctionDescriptor(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n@@ -63,1 +53,0 @@\n-        this.attributes = attributes;\n@@ -67,36 +56,0 @@\n-    \/**\n-     * Returns the attribute with the given name (if it exists).\n-     *\n-     * @param name the attribute name.\n-     * @return the attribute with the given name (if it exists).\n-     *\/\n-    public Optional<Constable> attribute(String name) {\n-        Objects.requireNonNull(name);\n-        return Optional.ofNullable(attributes.get(name));\n-    }\n-\n-    \/**\n-     * Returns a stream of the attribute names associated with this function descriptor.\n-     *\n-     * @return a stream of the attribute names associated with this function descriptor.\n-     *\/\n-    public Stream<String> attributes() {\n-        return attributes.keySet().stream();\n-    }\n-\n-    \/**\n-     * Returns a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.\n-     * If this descriptor already contains an attribute with the same name, the existing attribute value is overwritten in the returned\n-     * descriptor.\n-     *\n-     * @param name the attribute name.\n-     * @param value the attribute value.\n-     * @return a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.\n-     *\/\n-    public FunctionDescriptor withAttribute(String name, Constable value) {\n-        Objects.requireNonNull(name);\n-        Map<String, Constable> newAttributes = new HashMap<>(attributes);\n-        newAttributes.put(name, value);\n-        return new FunctionDescriptor(resLayout, newAttributes, argLayouts);\n-    }\n-\n@@ -116,1 +69,1 @@\n-        return Arrays.asList(argLayouts);\n+        return argLayouts;\n@@ -129,1 +82,1 @@\n-        return new FunctionDescriptor(resLayout, Map.of(), argLayouts);\n+        return new FunctionDescriptor(resLayout, List.of(argLayouts));\n@@ -140,1 +93,25 @@\n-        return new FunctionDescriptor(null, Map.of(), argLayouts);\n+        return new FunctionDescriptor(null, List.of(argLayouts));\n+    }\n+\n+    \/**\n+     * Obtain a specialized variadic function descriptor, by appending given variadic layouts to this\n+     * function descriptor argument layouts. The resulting function descriptor can report the position\n+     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n+     * in any way: for instance, calling {@link #withReturnLayout(MemoryLayout)} on the resulting descriptor\n+     * will throw an {@link UnsupportedOperationException}.\n+     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n+     * @return a new variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n+     *\/\n+    public FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts) {\n+        Objects.requireNonNull(variadicLayouts);\n+        Arrays.stream(variadicLayouts).forEach(Objects::requireNonNull);\n+        return variadicLayouts.length == 0 ? this : new VariadicFunction(this, variadicLayouts);\n+    }\n+\n+    \/**\n+     * The index of the first variadic argument layout (where defined).\n+     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n+     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n+     *\/\n+    public int firstVariadicArgumentIndex() {\n+        return -1;\n@@ -152,3 +129,2 @@\n-        MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);\n-        System.arraycopy(addedLayouts, 0, newLayouts, argLayouts.length, addedLayouts.length);\n-        return new FunctionDescriptor(resLayout, attributes, newLayouts);\n+        List<MemoryLayout> newLayouts = Stream.concat(argLayouts.stream(), Stream.of(addedLayouts)).toList();\n+        return new FunctionDescriptor(resLayout, newLayouts);\n@@ -164,1 +140,1 @@\n-        return new FunctionDescriptor(newReturn, attributes, argLayouts);\n+        return new FunctionDescriptor(newReturn, argLayouts);\n@@ -172,1 +148,1 @@\n-        return new FunctionDescriptor(null, attributes, argLayouts);\n+        return new FunctionDescriptor(null, argLayouts);\n@@ -190,1 +166,1 @@\n-     * object is also a function descriptor, and all of the following conditions are met:\n+     * object is also a function descriptor, and all the following conditions are met:\n@@ -204,1 +180,1 @@\n-        if (!(other instanceof FunctionDescriptor)) {\n+        if (!(other instanceof FunctionDescriptor f)) {\n@@ -207,2 +183,1 @@\n-        FunctionDescriptor f = (FunctionDescriptor) other;\n-        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts);\n+        return Objects.equals(resLayout, f.resLayout) && Objects.equals(argLayouts, f.argLayouts);\n@@ -217,1 +192,1 @@\n-        int hashCode = Arrays.hashCode(argLayouts);\n+        int hashCode = Objects.hashCode(argLayouts);\n@@ -221,0 +196,8 @@\n+    \/**\n+     * Returns an {@link Optional} containing the nominal descriptor for this\n+     * function descriptor, if one can be constructed, or an empty {@link Optional}\n+     * if one cannot be constructed.\n+     *\n+     * @return An {@link Optional} containing the resulting nominal descriptor,\n+     * or an empty {@link Optional} if one cannot be constructed.\n+     *\/\n@@ -234,0 +217,36 @@\n+\n+    static final class VariadicFunction extends FunctionDescriptor {\n+\n+        private final int firstVariadicIndex;\n+\n+        public VariadicFunction(FunctionDescriptor descriptor, MemoryLayout... argLayouts) {\n+            super(descriptor.returnLayout().orElse(null),\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toList());\n+            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n+        }\n+\n+        @Override\n+        public int firstVariadicArgumentIndex() {\n+            return firstVariadicIndex;\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withAppendedArgumentLayouts(MemoryLayout... addedLayouts) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withReturnLayout(MemoryLayout newReturn) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withVoidReturnLayout() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Optional<DynamicConstantDesc<FunctionDescriptor>> describeConstable() {\n+            return Optional.empty();\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":83,"deletions":64,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -35,1 +34,0 @@\n-import java.util.Map;\n@@ -43,1 +41,1 @@\n- * A group layout is used to combine together multiple <em>member layouts<\/em>. There are two ways in which member layouts\n+ * A group layout is used to combine multiple <em>member layouts<\/em>. There are two ways in which member layouts\n@@ -108,1 +106,1 @@\n-        this(kind, elements, kind.alignof(elements), Map.of());\n+        this(kind, elements, kind.alignof(elements), Optional.empty());\n@@ -111,2 +109,2 @@\n-    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Map<String, Constable> attributes) {\n-        super(kind.sizeof(elements), alignment, attributes);\n+    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {\n+        super(kind.sizeof(elements), alignment, name);\n@@ -163,1 +161,1 @@\n-        if (!(other instanceof GroupLayout)) {\n+        if (!(other instanceof GroupLayout g)) {\n@@ -166,1 +164,0 @@\n-        GroupLayout g = (GroupLayout)other;\n@@ -176,2 +173,2 @@\n-    GroupLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new GroupLayout(kind, elements, alignment, attributes);\n+    GroupLayout dup(long alignment, Optional<String> name) {\n+        return new GroupLayout(kind, elements, alignment, name);\n@@ -215,8 +212,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public GroupLayout withAttribute(String name, Constable value) {\n-        return (GroupLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,1455 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-\/**\n- * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n- * <p>\n- * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n- * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n- * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n- * <p>\n- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n- * clients can omit the offset coordinate.\n- * <p>\n- * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n- * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n- * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n- * be dereferenced.\n- * <p>\n- * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\/\n-public final class MemoryAccess {\n-\n-    private MemoryAccess() {\n-        \/\/ just the one\n-    }\n-\n-    private static final VarHandle byte_handle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n-    private static final VarHandle char_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, char.class);\n-    private static final VarHandle short_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, short.class);\n-    private static final VarHandle int_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, int.class);\n-    private static final VarHandle float_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, float.class);\n-    private static final VarHandle long_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, long.class);\n-    private static final VarHandle double_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, double.class);\n-    private static final VarHandle char_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, char.class);\n-    private static final VarHandle short_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, short.class);\n-    private static final VarHandle int_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, int.class);\n-    private static final VarHandle float_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, float.class);\n-    private static final VarHandle long_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, long.class);\n-    private static final VarHandle double_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, double.class);\n-    private static final VarHandle address_handle;\n-\n-    static {\n-        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n-            case 4 -> int.class;\n-            case 8 -> long.class;\n-            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n-        };\n-        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n-    }\n-\n-    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n-        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());\n-    }\n-\n-    \/\/ Note: all the accessor methods defined below take advantage of argument type profiling\n-    \/\/ (see src\/hotspot\/share\/oops\/methodData.cpp) which greatly enhances performance when the same accessor\n-    \/\/ method is used repeatedly with different segment kinds (e.g. on-heap vs. off-heap).\n-\n-    \/**\n-     * Reads a byte from given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (byte)byte_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n-        Objects.requireNonNull(segment);\n-        byte_handle.set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (MemoryAddress)address_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    handle.set(segment, offset, value.address());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(value);\n-        address_handle.set(segment, offset, value.address());\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n-    char value = (char)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (char)((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n-    short value = (short)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (short)((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n-    int value = (int)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (int)((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n-    float value = (float)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (float)((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n-    long value = (long)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (long)((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n-    double value = (double)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (double)((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a byte from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment) {\n-        return getLongAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, long value) {\n-        setLongAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment) {\n-        return getDoubleAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, double value) {\n-        setDoubleAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemoryAddress value = getAddressAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddress(MemorySegment segment) {\n-        return getAddressAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddress(MemorySegment segment, Addressable value) {\n-        setAddressAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment, ByteOrder order) {\n-        return getCharAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n-        setCharAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment, ByteOrder order) {\n-        return getShortAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n-        setShortAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment, ByteOrder order) {\n-        return getIntAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n-        setIntAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment, ByteOrder order) {\n-        return getFloatAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment, ByteOrder order) {\n-        return getLongAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n-        setLongAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment, ByteOrder order) {\n-        return getDoubleAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index) {\n-        return getCharAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index) {\n-        return getShortAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index) {\n-        return getIntAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index) {\n-        return getLongAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getCharAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getShortAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getIntAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getLongAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    @ForceInline\n-    private static long scale(MemorySegment address, long index, int size) {\n-        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":0,"deletions":1455,"binary":false,"changes":1455,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -33,1 +32,1 @@\n-import java.lang.ref.Cleaner;\n+import java.nio.ByteOrder;\n@@ -36,14 +35,29 @@\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained using the\n- * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory. Off-heap memory\n- * addresses are referred to as <em>native<\/em> memory addresses (see {@link #isNative()}). Native memory addresses\n- * allow clients to obtain a raw memory address (expressed as a long value) which can then be used e.g. when interacting\n- * with native code.\n- * <p>\n- * Given an address, it is possible to compute its offset relative to a given segment, which can be useful\n- * when performing memory dereference operations using a memory access var handle (see {@link MemoryHandles}).\n- * <p>\n- * A memory address is associated with a {@linkplain ResourceScope resource scope}; the resource scope determines the\n- * lifecycle of the memory address, and whether the address can be used from multiple threads. Memory addresses\n- * obtained from {@linkplain #ofLong(long) numeric values}, or from native code, are associated with the\n- * {@linkplain ResourceScope#globalScope() global resource scope}. Memory addresses obtained from segments\n- * are associated with the same scope as the segment from which they have been obtained.\n+ * A memory address models a reference into a memory location. Memory addresses are typically obtained in three ways:\n+ * <ul>\n+ *     <li>By calling {@link Addressable#address()} on an instance of type {@link Addressable} (e.g. a memory segment);<\/li>\n+ *     <li>By invoking a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n+ *     <li>By reading an address from memory, e.g. via {@link MemorySegment#get(ValueLayout.OfAddress, long)}.<\/li>\n+ * <\/ul>\n+ * A memory address is backed by a raw machine pointer, expressed as a {@linkplain #toRawLongValue() long value}.\n+ *\n+ * <h2>Dereference<\/h2>\n+ *\n+ * A memory address can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * <blockquote><pre>{@code\n+MemoryAddress address = ...\n+int value = address.get(ValueLayout.JAVA_INT, 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * can be expressed as follows:\n+ * <blockquote><pre>{@code\n+MemoryAddress address = ...\n+int value = address.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * All the dereference methods in this class are <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>: since\n+ * a memory address does not feature temporal nor spatial bounds, the runtime has no way to check the correctness\n+ * of the memory dereference operation.\n@@ -55,2 +69,0 @@\n- * <p>\n- * Non-platform classes should not implement {@linkplain MemoryAddress} directly.\n@@ -66,4 +78,5 @@\n-    @Override\n-    default MemoryAddress address() {\n-        return this;\n-    }\n+    \/**\n+     * Returns the raw long value associated with this memory address.\n+     * @return The raw long value associated with this memory address.\n+     *\/\n+    long toRawLongValue();\n@@ -79,2 +92,86 @@\n-     * Returns the resource scope associated with this memory address.\n-     * @return the resource scope associated with this memory address.\n+     * Reads a UTF-8 encoded, null-terminated string from this address and offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a Java string constructed from the bytes read from the given starting address ({@code toRowLongValue() + offset})\n+     * up to (but not including) the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    String getUtf8String(long offset);\n+\n+    \/**\n+     * Writes the given string to this address at given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param str the Java string to be written at this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setUtf8String(long offset, String str);\n+\n+    \/**\n+     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n+     * object is also an address, and it refers to the same memory location as this address.\n+     *\n+     * @param that the object to be compared for equality with this address.\n+     * @return {@code true} if the specified object is equal to this address.\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * Returns the hash code value for this address.\n+     * @return the hash code value for this address.\n+     *\/\n+    @Override\n+    int hashCode();\n+\n+    \/**\n+     * The native memory address instance modelling the {@code NULL} address.\n+     *\/\n+    MemoryAddress NULL = new MemoryAddressImpl(0L);\n+\n+    \/**\n+     * Obtain a native memory address instance from given long address.\n+     * @param value the long address.\n+     * @return the new memory address instance.\n+     *\/\n+    static MemoryAddress ofLong(long value) {\n+        return value == 0 ?\n+                NULL :\n+                new MemoryAddressImpl(value);\n+    }\n+\n+    \/**\n+     * Reads a byte from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a byte value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -82,1 +179,2 @@\n-    ResourceScope scope();\n+    @CallerSensitive\n+    byte get(ValueLayout.OfByte layout, long offset);\n@@ -85,6 +183,1 @@\n-     * Returns the offset of this memory address into the given segment. More specifically, if both the segment's\n-     * base address and this address are native addresses, the result is computed as\n-     * {@code this.toRawLongValue() - segment.address().toRawLongValue()}. Otherwise, if both addresses in the form\n-     * {@code (B, O1)}, {@code (B, O2)}, where {@code B} is the same base heap object and {@code O1}, {@code O2}\n-     * are byte offsets (relative to the base object) associated with this address and the segment's base address,\n-     * the result is computed as {@code O1 - O2}.\n+     * Writes a byte to this address instance and offset with given layout.\n@@ -92,9 +185,11 @@\n-     * If the segment's base address and this address are both heap addresses, but with different base objects, the result is undefined\n-     * and an exception is thrown. Similarly, if the segment's base address is an heap address (resp. off-heap) and\n-     * this address is an off-heap (resp. heap) address, the result is undefined and an exception is thrown.\n-     * Otherwise, the result is a byte offset {@code SO}. If this address falls within the\n-     * spatial bounds of the given segment, then {@code 0 <= SO < segment.byteSize()}; otherwise, {@code SO < 0 || SO > segment.byteSize()}.\n-     * @return the offset of this memory address into the given segment.\n-     * @param segment the segment relative to which this address offset should be computed\n-     * @throws IllegalArgumentException if {@code segment} is not compatible with this address; this can happen, for instance,\n-     * when {@code segment} models an heap memory region, while this address is a {@linkplain #isNative() native} address.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -102,1 +197,2 @@\n-    long segmentOffset(MemorySegment segment);\n+    @CallerSensitive\n+    void set(ValueLayout.OfByte layout, long offset, byte value);\n@@ -105,6 +201,1 @@\n-     Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n-     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided resource scope.\n+     * Reads a boolean from this address and offset with given layout.\n@@ -112,3 +203,17 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a boolean value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    boolean get(ValueLayout.OfBoolean layout, long offset);\n+\n+    \/**\n+     * Writes a boolean to this address instance and offset with given layout.\n@@ -116,4 +221,17 @@\n-     * This method is equivalent to the following code:\n-     * <pre>{@code\n-    asSegment(byteSize, null, scope);\n-     * }<\/pre>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n+\n+    \/**\n+     * Reads a char from this address and offset with given layout.\n@@ -126,8 +244,3 @@\n-     * @param bytesSize the desired size.\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n-     * have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a char value read from this address.\n@@ -139,1 +252,1 @@\n-    MemorySegment asSegment(long bytesSize, ResourceScope scope);\n+    char get(ValueLayout.OfChar layout, long offset);\n@@ -142,5 +255,1 @@\n-     * Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n-     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is associated with the provided resource scope.\n+     * Writes a char to this address instance and offset with given layout.\n@@ -148,3 +257,17 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the char value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfChar layout, long offset, char value);\n+\n+    \/**\n+     * Reads a short from this address and offset with given layout.\n@@ -152,2 +275,17 @@\n-     * Calling {@link ResourceScope#close()} on the scope associated with the returned segment will result in calling\n-     * the provided cleanup action (if any).\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a short value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    short get(ValueLayout.OfShort layout, long offset);\n+\n+    \/**\n+     * Writes a short to this address instance and offset with given layout.\n@@ -160,9 +298,3 @@\n-     * @param bytesSize the desired size.\n-     * @param cleanupAction the cleanup action; can be {@code null}.\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n-     * have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the short value to be written.\n@@ -174,1 +306,1 @@\n-    MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n+    void set(ValueLayout.OfShort layout, long offset, short value);\n@@ -177,2 +309,13 @@\n-     * Is this an off-heap memory address?\n-     * @return true, if this is an off-heap memory address.\n+     * Reads an int from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return an int value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -180,1 +323,2 @@\n-    boolean isNative();\n+    @CallerSensitive\n+    int get(ValueLayout.OfInt layout, long offset);\n@@ -183,5 +327,13 @@\n-     * Returns the raw long value associated with this native memory address.\n-     * @return The raw long value associated with this native memory address.\n-     * @throws UnsupportedOperationException if this memory address is not a {@linkplain #isNative() native} address.\n-     * @throws IllegalStateException if the scope associated with this segment has been already closed,\n-     * or if access occurs from a thread other than the thread owning either segment.\n+     * Writes an int to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the int value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -189,1 +341,2 @@\n-    long toRawLongValue();\n+    @CallerSensitive\n+    void set(ValueLayout.OfInt layout, long offset, int value);\n@@ -192,2 +345,6 @@\n-     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n-     * object is also an address, and it refers to the same memory location as this address.\n+     * Reads a float from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -195,4 +352,17 @@\n-     * @apiNote two addresses might be considered equal despite their associated resource scopes differ. This\n-     * can happen, for instance, if the same memory address is used to create memory segments with different\n-     * scopes (using {@link #asSegment(long, ResourceScope)}), and the base address of the resulting segments is\n-     * then compared.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a float value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    float get(ValueLayout.OfFloat layout, long offset);\n+\n+    \/**\n+     * Writes a float to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -200,2 +370,6 @@\n-     * @param that the object to be compared for equality with this address.\n-     * @return {@code true} if the specified object is equal to this address.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the float value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -203,2 +377,2 @@\n-    @Override\n-    boolean equals(Object that);\n+    @CallerSensitive\n+    void set(ValueLayout.OfFloat layout, long offset, float value);\n@@ -207,2 +381,13 @@\n-     * Returns the hash code value for this address.\n-     * @return the hash code value for this address.\n+     * Reads a long from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a long value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -210,2 +395,2 @@\n-    @Override\n-    int hashCode();\n+    @CallerSensitive\n+    long get(ValueLayout.OfLong layout, long offset);\n@@ -214,2 +399,13 @@\n-     * The native memory address instance modelling the {@code NULL} address, associated\n-     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * Writes a long to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the long value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -217,1 +413,2 @@\n-    MemoryAddress NULL = new MemoryAddressImpl(null, 0L);\n+    @CallerSensitive\n+    void set(ValueLayout.OfLong layout, long offset, long value);\n@@ -220,4 +417,13 @@\n-     * Obtain a native memory address instance from given long address. The returned address is associated\n-     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     * @param value the long address.\n-     * @return the new memory address instance.\n+     * Reads a double from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a double value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -225,5 +431,308 @@\n-    static MemoryAddress ofLong(long value) {\n-        return value == 0 ?\n-                NULL :\n-                new MemoryAddressImpl(null, value);\n-    }\n+    @CallerSensitive\n+    double get(ValueLayout.OfDouble layout, long offset);\n+\n+    \/**\n+     * Writes a double to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the double value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfDouble layout, long offset, double value);\n+\n+    \/**\n+     * Reads an address from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return an address value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemoryAddress get(ValueLayout.OfAddress layout, long offset);\n+\n+    \/**\n+     * Writes an address to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the address value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfAddress layout, long offset, Addressable value);\n+\n+    \/**\n+     * Reads a char from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a char value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    char getAtIndex(ValueLayout.OfChar layout, long index);\n+\n+    \/**\n+     * Writes a char to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the char value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfChar layout, long index, char value);\n+\n+    \/**\n+     * Reads a short from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a short value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    short getAtIndex(ValueLayout.OfShort layout, long index);\n+\n+    \/**\n+     * Writes a short to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfShort layout, long index, short value);\n+\n+    \/**\n+     * Reads an int from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an int value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    int getAtIndex(ValueLayout.OfInt layout, long index);\n+\n+    \/**\n+     * Writes an int to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the int value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfInt layout, long index, int value);\n+\n+    \/**\n+     * Reads a float from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a float value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    float getAtIndex(ValueLayout.OfFloat layout, long index);\n+\n+    \/**\n+     * Writes a float to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the float value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfFloat layout, long index, float value);\n+\n+    \/**\n+     * Reads a long from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a long value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    long getAtIndex(ValueLayout.OfLong layout, long index);\n+\n+    \/**\n+     * Writes a long to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the long value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfLong layout, long index, long value);\n+\n+    \/**\n+     * Reads a double from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a double value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    double getAtIndex(ValueLayout.OfDouble layout, long index);\n+\n+    \/**\n+     * Writes a double to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the double value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfDouble layout, long index, double value);\n+\n+    \/**\n+     * Reads an address from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an address value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index);\n+\n+    \/**\n+     * Writes an address to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the address value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":627,"deletions":118,"binary":false,"changes":745,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -37,1 +36,0 @@\n-import java.nio.ByteOrder;\n@@ -43,5 +41,4 @@\n- * To obtain a memory access var handle, clients must start from one of the <em>leaf<\/em> methods\n- * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},\n- * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type\n- * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the\n- * byte order associated with a memory access var handle. The resulting memory access var handle can then be combined in various ways\n+ * Memory access var handles can be obtained using {@link MemoryHandles#varHandle(ValueLayout)}. The provided value layout\n+ * determines the type, as well as the alignment constraint and the byte order associated with the memory access var handle.\n+ * <p>\n+ * The resulting memory access var handle can then be combined in various ways\n@@ -56,1 +53,1 @@\n-        MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN).withName(\"value\")\n+        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -61,1 +58,1 @@\n-VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); \/\/(MemorySegment, long) -> int\n+VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n@@ -80,1 +77,1 @@\n- *     {@code float} or {@code double}.\n+ *     {@code float}, {@code double} or {@link MemoryAddress}.\n@@ -83,1 +80,1 @@\n- * <li>numeric atomic update access modes for {@code int} and {@code long}.\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n@@ -86,1 +83,1 @@\n- * <li>bitwise atomic update access modes for {@code int} and {@code long}.\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n@@ -91,1 +88,1 @@\n- * If {@code T} is {@code float} or {@code double} then atomic\n+ * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n@@ -93,2 +90,2 @@\n- * (see {@link Float#floatToRawIntBits} and\n- * {@link Double#doubleToRawLongBits}, respectively).\n+ * (see {@link Float#floatToRawIntBits},\n+ * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n@@ -112,2 +109,0 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n-    private static final MethodHandle ADDRESS_TO_LONG;\n@@ -127,4 +122,0 @@\n-            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, \"longToAddress\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n-            ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, \"addressToLong\",\n-                    MethodType.methodType(long.class, MemoryAddress.class));\n@@ -157,28 +148,4 @@\n-     * Creates a memory access var handle with the given carrier type and byte order.\n-     *\n-     * The returned var handle's type is {@code carrier} and the list of coordinate types is\n-     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n-     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n-     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n-     * the alignment constraint (in bytes) for the resulting memory access var handle is the same as the size (in bytes) of the\n-     * carrier type {@code carrier}.\n-     *\n-     * @apiNote the resulting var handle features certain <a href=\"#memaccess-mode\">access mode restrictions<\/a>,\n-     * which are common to all memory access var handles.\n-     *\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, and {@code double}.\n-     * @param byteOrder the required byte order.\n-     * @return the new memory access var handle.\n-     * @throws IllegalArgumentException when an illegal carrier type is used\n-     *\/\n-    public static VarHandle varHandle(Class<?> carrier, ByteOrder byteOrder) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(byteOrder);\n-        return varHandle(carrier,\n-                carrierSize(carrier),\n-                byteOrder);\n-    }\n-\n-    \/**\n-     * Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.\n+     * Creates a memory access var handle from given value layout. The provided layout will specify the\n+     * {@linkplain ValueLayout#carrier() carrier type}, the {@linkplain ValueLayout#byteSize() the byte size},\n+     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n+     * associated to the returned var handle.\n@@ -195,4 +162,1 @@\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, and {@code double}.\n-     * @param alignmentBytes the alignment constraint (in bytes). Must be a power of two.\n-     * @param byteOrder the required byte order.\n+     * @param layout the value layout for which a memory access handle is to be obtained.\n@@ -202,43 +166,3 @@\n-    public static VarHandle varHandle(Class<?> carrier, long alignmentBytes, ByteOrder byteOrder) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(byteOrder);\n-        checkCarrier(carrier);\n-\n-        if (alignmentBytes <= 0\n-                || (alignmentBytes & (alignmentBytes - 1)) != 0) { \/\/ is power of 2?\n-            throw new IllegalArgumentException(\"Bad alignment: \" + alignmentBytes);\n-        }\n-\n-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder));\n-    }\n-\n-    \/**\n-     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemorySegment}.\n-     * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,\n-     * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});\n-     * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted\n-     * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)\n-     * memory depends on the carrier of the original memory access var handle.\n-     *\n-     * @param target the memory access var handle to be adapted\n-     * @return the adapted var handle.\n-     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},\n-     * {@code float}, or {@code double}, or is not a primitive type.\n-     *\/\n-    public static VarHandle asAddressVarHandle(VarHandle target) {\n-        Objects.requireNonNull(target);\n-        Class<?> carrier = target.varType();\n-        if (!carrier.isPrimitive() || carrier == boolean.class ||\n-                carrier == float.class || carrier == double.class) {\n-            throw new IllegalArgumentException(\"Unsupported carrier type: \" + carrier.getName());\n-        }\n-\n-        if (carrier != long.class) {\n-            \/\/ slow-path, we need to adapt\n-            return filterValue(target,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));\n-        } else {\n-            \/\/ fast-path\n-            return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);\n-        }\n+    public static VarHandle varHandle(ValueLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return layout.accessHandle();\n@@ -258,1 +182,1 @@\n-    VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);\n+    VarHandle SHORT_VH = ValueLayout.JAVA_SHORT.varHandle();\n@@ -279,1 +203,1 @@\n-     * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access\n+     * java.lang.invoke.VarHandle.AccessMode}), and the same atomic access\n@@ -287,1 +211,1 @@\n-     * adaptedType} is not one of {@code int}, or {@code long}; if the bitwidth\n+     * adaptedType} is not one of {@code int}, or {@code long}; if the bit width\n@@ -327,1 +251,1 @@\n-     * For the boxing and unboxing filters to be well formed, their types must be of the form {@code (A... , S) -> T} and\n+     * For the boxing and unboxing filters to be well-formed, their types must be of the form {@code (A... , S) -> T} and\n@@ -332,1 +256,4 @@\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and\n+     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n@@ -341,1 +268,1 @@\n-     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n+     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n@@ -356,1 +283,1 @@\n-     * For the coordinate filters to be well formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n+     * For the coordinate filters to be well-formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n@@ -359,0 +286,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -371,1 +301,1 @@\n-     * or if any of the filters throws any checked exceptions.\n+     * or if it's determined that any of the filters throws any checked exceptions.\n@@ -385,1 +315,1 @@\n-     * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },\n+     * For the bound coordinates to be well-formed, their types must be {@code T1, T2 ... Tn },\n@@ -412,1 +342,1 @@\n-     * {@code newCoordinates.size()}, and call {@code #O} the number\n+     * {@code newCoordinates.size()}), and call {@code #O} the number\n@@ -447,1 +377,1 @@\n-     * Adapts a target var handle handle by pre-processing\n+     * Adapts a target var handle by pre-processing\n@@ -467,0 +397,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -479,1 +412,1 @@\n-     * or if {@code filter} throws any checked exceptions.\n+     * or if it's determined that {@code filter} throws any checked exceptions.\n@@ -508,18 +441,0 @@\n-    private static void checkAddressFirstCoordinate(VarHandle handle) {\n-        if (handle.coordinateTypes().size() < 1 ||\n-                handle.coordinateTypes().get(0) != MemorySegment.class) {\n-            throw new IllegalArgumentException(\"Expected var handle with leading coordinate of type MemorySegment\");\n-        }\n-    }\n-\n-    private static void checkCarrier(Class<?> carrier) {\n-        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {\n-            throw new IllegalArgumentException(\"Illegal carrier: \" + carrier.getSimpleName());\n-        }\n-    }\n-\n-    private static long carrierSize(Class<?> carrier) {\n-        long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());\n-        return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);\n-    }\n-\n@@ -544,8 +459,0 @@\n-\n-    private static MemoryAddress longToAddress(long value) {\n-        return MemoryAddress.ofLong(value);\n-    }\n-\n-    private static long addressToLong(MemoryAddress value) {\n-        return value.toRawLongValue();\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":41,"deletions":134,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * A memory layout can be used to describe the contents of a memory segment in a <em>language neutral<\/em> fashion.\n+ * A memory layout can be used to describe the contents of a memory segment.\n@@ -53,1 +53,1 @@\n- * Some common value layout constants are defined in the {@link MemoryLayouts} class.\n+ * Some common value layout constants are defined in the {@link ValueLayout} class.\n@@ -73,1 +73,1 @@\n-        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        ValueLayout.JAVA_BYTE.withName(\"kind\"),\n@@ -75,1 +75,1 @@\n-        MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"value\")\n+        ValueLayout.JAVA_INT.withName(\"value\")\n@@ -84,2 +84,0 @@\n- * <p>\n- * Non-platform classes should not implement {@linkplain MemoryLayout} directly.\n@@ -125,5 +123,5 @@\n- * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout\n- * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected\n- * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside\n- * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside\n- * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).\n+ * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#bitOffset(PathElement...) offsets} of\n+ * arbitrarily nested layouts inside another layout, to quickly obtain a {@linkplain #varHandle(PathElement...) memory access handle}\n+ * corresponding to the selected layout, to {@linkplain #select(PathElement...) select} an arbitrarily nested layout inside\n+ * another layout, or to {@link #map(UnaryOperator, PathElement...) transform} a nested layout element inside\n+ * another layout.\n@@ -155,1 +153,1 @@\n-        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        ValueLayout.JAVA_BYTE.withName(\"kind\"),\n@@ -167,2 +165,1 @@\n-VarHandle valueHandle = taggedValues.varHandle(int.class,\n-                                               PathElement.sequenceElement(),\n+VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n@@ -192,3 +189,1 @@\n- * Layouts can be optionally associated with one or more <em>attributes<\/em>. A layout attribute forms a <em>name\/value<\/em>\n- * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute\n- * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated with memory layouts and that can be referred to when\n+ * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be referred to when\n@@ -239,4 +234,1 @@\n-    default long byteSize() {\n-        return Utils.bitsToBytesOrThrow(bitSize(),\n-                () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n-    }\n+    long byteSize();\n@@ -246,5 +238,0 @@\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    attribute(LAYOUT_NAME).map(String.class::cast);\n-     * }<\/pre><\/blockquote>\n@@ -259,5 +246,0 @@\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    withAttribute(LAYOUT_NAME, name);\n-     * }<\/pre><\/blockquote>\n@@ -316,1 +298,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.\n+     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than 8.\n@@ -320,26 +302,0 @@\n-    \/**\n-     * Returns the attribute with the given name (if it exists).\n-     *\n-     * @param name the attribute name\n-     * @return the attribute with the given name (if it exists).\n-     *\/\n-    Optional<Constable> attribute(String name);\n-\n-    \/**\n-     * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.\n-     * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned\n-     * layout.\n-     *\n-     * @param name the attribute name.\n-     * @param value the attribute value.\n-     * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.\n-     *\/\n-    MemoryLayout withAttribute(String name, Constable value);\n-\n-    \/**\n-     * Returns a stream of the attribute names associated with this layout.\n-     *\n-     * @return a stream of the attribute names associated with this layout.\n-     *\/\n-    Stream<String> attributes();\n-\n@@ -369,1 +325,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -420,1 +376,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -480,1 +436,0 @@\n-     * @param carrier the var handle carrier type.\n@@ -485,3 +440,1 @@\n-     * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},\n-     * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),\n-     * or if the selected value layout has a size that that does not match that of the specified carrier type.\n+     * @throws IllegalArgumentException if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}).\n@@ -489,3 +442,2 @@\n-    default VarHandle varHandle(Class<?> carrier, PathElement... elements) {\n-        Objects.requireNonNull(carrier);\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -> path.dereferenceHandle(carrier),\n+    default VarHandle varHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::dereferenceHandle,\n@@ -501,1 +453,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -518,1 +470,1 @@\n-     * <p>After the offset is computed, the returned segment is create as if by calling:\n+     * <p>After the offset is computed, the returned segment is created as if by calling:\n@@ -585,1 +537,1 @@\n-     * Is this a padding layout (e.g. a layout created from {@link #paddingLayout(long)}) ?\n+     * Is this a {@linkplain #paddingLayout(long) padding layout} ?\n@@ -598,2 +550,0 @@\n-     * <p>\n-     * Non-platform classes should not implement {@linkplain PathElement} directly.\n@@ -615,1 +565,1 @@\n-         * method will select the first one; that is, the group element with lowest offset from current path is selected.\n+         * method will select the first one; that is, the group element with the lowest offset from current path is selected.\n@@ -731,3 +681,14 @@\n-     * Create a value layout of given byte order and size.\n-     *\n-     * @param size the value layout size.\n+     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n+     * by the carrier provided:\n+     * <ul>\n+     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n+     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n+     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n+     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n+     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n+     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n+     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n+     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemoryAddress.class}<\/li>\n+     * <\/ul>\n+     * @param carrier the value layout carrier.\n@@ -736,1 +697,1 @@\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @throws IllegalArgumentException if the carrier type is not supported.\n@@ -738,1 +699,2 @@\n-    static ValueLayout valueLayout(long size, ByteOrder order) {\n+    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n@@ -740,2 +702,21 @@\n-        AbstractLayout.checkSize(size);\n-        return new ValueLayout(order, size);\n+        if (carrier == boolean.class) {\n+            return new ValueLayout.OfBoolean(order);\n+        } else if (carrier == char.class) {\n+            return new ValueLayout.OfChar(order);\n+        } else if (carrier == byte.class) {\n+            return new ValueLayout.OfByte(order);\n+        } else if (carrier == short.class) {\n+            return new ValueLayout.OfShort(order);\n+        } else if (carrier == int.class) {\n+            return new ValueLayout.OfInt(order);\n+        } else if (carrier == float.class) {\n+            return new ValueLayout.OfFloat(order);\n+        } else if (carrier == long.class) {\n+            return new ValueLayout.OfLong(order);\n+        } else if (carrier == double.class) {\n+            return new ValueLayout.OfDouble(order);\n+        } else if (carrier == MemoryAddress.class) {\n+            return new ValueLayout.OfAddress(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n@@ -795,5 +776,0 @@\n-\n-    \/**\n-     * Attribute name used to specify the <em>name<\/em> property of a memory layout (see {@link #name()} and {@link #withName(String)}).\n-     *\/\n-    String LAYOUT_NAME = \"layout\/name\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":61,"deletions":85,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.misc.Unsafe;\n-\n-import java.nio.ByteOrder;\n-\n-\/**\n- * This class defines useful layout constants. Some of the constants defined in this class are explicit in both\n- * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the\n- * contents of a memory segment. Other constants make implicit byte order assumptions (see\n- * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,\n- * such as {@link java.nio.ByteBuffer}.\n- *\/\n-public final class MemoryLayouts {\n-\n-    private MemoryLayouts() {\n-        \/\/just the one, please\n-    }\n-\n-    \/**\n-     * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_8_LE = MemoryLayout.valueLayout(8, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_16_LE = MemoryLayout.valueLayout(16, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_32_LE = MemoryLayout.valueLayout(32, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_64_LE = MemoryLayout.valueLayout(64, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_8_BE = MemoryLayout.valueLayout(8, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_16_BE = MemoryLayout.valueLayout(16, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_32_BE = MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_64_BE = MemoryLayout.valueLayout(64, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A padding layout constant with size of one byte.\n-     *\/\n-    public static final MemoryLayout PAD_8 = MemoryLayout.paddingLayout(8);\n-\n-    \/**\n-     * A padding layout constant with size of two bytes.\n-     *\/\n-    public static final MemoryLayout PAD_16 = MemoryLayout.paddingLayout(16);\n-\n-    \/**\n-     * A padding layout constant with size of four bytes.\n-     *\/\n-    public static final MemoryLayout PAD_32 = MemoryLayout.paddingLayout(32);\n-\n-    \/**\n-     * A padding layout constant with size of eight bytes.\n-     *\/\n-    public static final MemoryLayout PAD_64 = MemoryLayout.paddingLayout(64);\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}), and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout ADDRESS = MemoryLayout.valueLayout(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code byte}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_BYTE = MemoryLayout.valueLayout(8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code char}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_CHAR = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code short}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_SHORT = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_INT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n-     * invariant holds:\n-     * <blockquote><pre>{@code\n-    MemoryLayouts.JAVA_LONG.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n-     * }<\/pre><\/blockquote>\n-     *\/\n-    public static final ValueLayout JAVA_LONG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n-            .withBitAlignment(ADDRESS.bitSize());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_FLOAT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n-     * invariant holds:\n-     * <blockquote><pre>{@code\n-    MemoryLayouts.JAVA_DOUBLE.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n-     * }<\/pre><\/blockquote>\n-     *\/\n-    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n-            .withBitAlignment(ADDRESS.bitSize());\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -37,0 +38,4 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -39,0 +44,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -41,0 +47,1 @@\n+import java.nio.ByteOrder;\n@@ -42,0 +49,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -89,1 +97,1 @@\n- * these capabilities are suitable replacements for some of the functionality in the {@link java.nio.MappedByteBuffer} class.\n+ * these capabilities are suitable replacements for some capabilities in the {@link java.nio.MappedByteBuffer} class.\n@@ -97,1 +105,36 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}.\n+ *\n+ * <h2>Restricted native segments<\/h2>\n+ *\n+ * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddress(MemoryAddress, long, ResourceScope) obtain}\n+ * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain ResourceScope scope}.\n+ * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n+ * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n+ * the memory segment.\n+ *\n+ * <h2>Dereference<\/h2>\n+ *\n+ * A memory segment can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+int value = segment.get(ValueLayout.JAVA_INT, 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * can be expressed as follows:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+int value = segment.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * For more complex dereference operations (e.g. structured memory access), clients can obtain a <em>memory access var handle<\/em>,\n+ * that is, a var handle that accepts a segment and, optionally, one or more additional {@code long} coordinates. Memory\n+ * access var handles can be obtained from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n+ * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>.\n+ * Alternatively, clients can obtain raw memory access var handles from a given\n+ * {@linkplain MemoryHandles#varHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n+ * functions defined in the {@link MemoryHandles} class.\n@@ -108,1 +151,1 @@\n-    segment = MemorySegment.allocateNative(8, 1, scope);\n+    segment = MemorySegment.allocateNative(8, scope);\n@@ -110,1 +153,1 @@\n-MemoryAccess.getLong(segment); \/\/ already closed!\n+segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n@@ -146,1 +189,1 @@\n-    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -148,3 +191,2 @@\n-    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-    int sum = segment.elements(MemoryLayouts.JAVA_INT).parallel()\n-                           .mapToInt(s -> (int)VH_int.get(s.address()))\n+    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                           .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n@@ -161,2 +203,4 @@\n-     * The base memory address associated with this memory segment.\n-     * The returned memory address is associated with same resource scope as that associated with this segment.\n+     * The base memory address associated with this native memory segment.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -220,2 +264,0 @@\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(MemoryAddress, long)\n@@ -230,22 +272,0 @@\n-    \/**\n-     * Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.\n-     * <p>\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSlice(newBase.segmentOffset(this), newSize);\n-     * }<\/pre>\n-     *\n-     * @see #asSlice(long)\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(long, long)\n-     *\n-     * @param newBase The new segment base address.\n-     * @param newSize The new segment size, specified in bytes.\n-     * @return a new memory segment view with updated base\/limit addresses.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n-     *\/\n-    default MemorySegment asSlice(MemoryAddress newBase, long newSize) {\n-        Objects.requireNonNull(newBase);\n-        return asSlice(newBase.segmentOffset(this), newSize);\n-    }\n-\n@@ -261,2 +281,0 @@\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(MemoryAddress, long)\n@@ -273,22 +291,0 @@\n-    \/**\n-     * Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting\n-     * the address offset relative to this segment (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.\n-     * <p>\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSlice(newBase.segmentOffset(this));\n-     * }<\/pre>\n-     *\n-     * @see #asSlice(long)\n-     * @see #asSlice(MemoryAddress, long)\n-     * @see #asSlice(long, long)\n-     *\n-     * @param newBase The new segment base offset (relative to the current segment base address), specified in bytes.\n-     * @return a new memory segment view with updated base\/limit addresses.\n-     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.\n-     *\/\n-    default MemorySegment asSlice(MemoryAddress newBase) {\n-        Objects.requireNonNull(newBase);\n-        return asSlice(newBase.segmentOffset(this));\n-    }\n-\n@@ -327,0 +323,36 @@\n+    \/**\n+     * Returns a slice of this segment that is the overlap between this and\n+     * the provided segment.\n+     *\n+     * <p>Two segments {@code S1} and {@code S2} are said to overlap if it is possible to find\n+     * at least two slices {@code L1} (from {@code S1}) and {@code L2} (from {@code S2}) that are backed by the\n+     * same memory region. As such, it is not possible for a\n+     * {@link #isNative() native} segment to overlap with a heap segment; in\n+     * this case, or when no overlap occurs, {@code null} is returned.\n+     *\n+     * @param other the segment to test for an overlap with this segment.\n+     * @return a slice of this segment, or {@code null} if no overlap occurs.\n+     *\/\n+    MemorySegment asOverlappingSlice(MemorySegment other);\n+\n+    \/**\n+     * Returns the offset, in bytes, of the provided segment, relative to this\n+     * segment.\n+     *\n+     * <p>The offset is relative to the base address of this segment and can be\n+     * a negative or positive value. For instance, if both segments are native\n+     * segments, the resulting offset can be computed as follows:\n+     *\n+     * <pre>{@code\n+     * other.baseAddress().toRawLongValue() - segment.baseAddress().toRawLongValue()\n+     * }<\/pre>\n+     *\n+     * If the segments share the same base address, {@code 0} is returned. If\n+     * {@code other} is a slice of this segment, the offset is always\n+     * {@code 0 <= x < this.byteSize()}.\n+     *\n+     * @param other the segment to retrieve an offset to.\n+     * @return the relative offset, in bytes, of the provided segment.\n+     *\/\n+    long segmentOffset(MemorySegment other);\n+\n@@ -334,1 +366,1 @@\n-byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+byteHandle = MemoryLayout.ofSequence(ValueLayout.JAVA_BYTE)\n@@ -349,1 +381,1 @@\n-     * a thread other than the thread owning that scope,\n+     * a thread other than the thread owning that scope.\n@@ -358,4 +390,0 @@\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n@@ -363,4 +391,4 @@\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     *\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize);\n+     * }<\/pre><\/blockquote>\n@@ -373,0 +401,1 @@\n+     * @return this segment.\n@@ -374,1 +403,4 @@\n-    void copyFrom(MemorySegment src);\n+    default MemorySegment copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+        return this;\n+    }\n@@ -384,1 +416,1 @@\n-     * the length of the common prefix and it follows that there is a mismatch\n+     * the length of the common prefix, and it follows that there is a mismatch\n@@ -386,2 +418,2 @@\n-     * If one segment is a proper prefix of the other then the returned offset is\n-     * the smaller of the segment sizes, and it follows that the offset is only\n+     * If one segment is a proper prefix of the other, then the returned offset is\n+     * the smallest of the segment sizes, and it follows that the offset is only\n@@ -401,1 +433,1 @@\n-     * Tells whether or not the contents of this mapped segment is resident in physical\n+     * Tells whether the contents of this mapped segment is resident in physical\n@@ -405,1 +437,1 @@\n-     * that all of the data in this segment is resident in physical memory and\n+     * that all the data in this segment is resident in physical memory and\n@@ -484,1 +516,1 @@\n-     * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to\n+     * Wraps this segment in a {@link ByteBuffer}. Some properties of the returned buffer are linked to\n@@ -487,1 +519,1 @@\n-     * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is\n+     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native memory segment, the resulting buffer is\n@@ -490,1 +522,1 @@\n-     * The returned buffer's position (see {@link ByteBuffer#position()} is initially set to zero, while\n+     * The returned buffer's position (see {@link ByteBuffer#position()}) is initially set to zero, while\n@@ -496,1 +528,1 @@\n-     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}, will throw an {@link IllegalStateException}.\n+     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}), will throw an {@link IllegalStateException}.\n@@ -508,1 +540,1 @@\n-     * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n+     * e.g. because it models a heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n@@ -515,0 +547,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -520,1 +554,1 @@\n-    byte[] toByteArray();\n+    byte[] toArray(ValueLayout.OfByte elementLayout);\n@@ -524,0 +558,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -529,1 +565,1 @@\n-    short[] toShortArray();\n+    short[] toArray(ValueLayout.OfShort elementLayout);\n@@ -533,0 +569,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -538,1 +576,1 @@\n-    char[] toCharArray();\n+    char[] toArray(ValueLayout.OfChar elementLayout);\n@@ -542,0 +580,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -547,1 +587,1 @@\n-    int[] toIntArray();\n+    int[] toArray(ValueLayout.OfInt elementLayout);\n@@ -551,0 +591,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -556,1 +598,1 @@\n-    float[] toFloatArray();\n+    float[] toArray(ValueLayout.OfFloat elementLayout);\n@@ -560,0 +602,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -565,1 +609,1 @@\n-    long[] toLongArray();\n+    long[] toArray(ValueLayout.OfLong elementLayout);\n@@ -569,0 +613,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -574,1 +620,1 @@\n-    double[] toDoubleArray();\n+    double[] toArray(ValueLayout.OfDouble elementLayout);\n@@ -577,1 +623,39 @@\n-     * Creates a new confined buffer memory segment that models the memory associated with the given byte\n+     * Reads a UTF-8 encoded, null-terminated string from this segment at given offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n+     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    default String getUtf8String(long offset) {\n+        return SharedUtils.toJavaStringInternal(this, offset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param str the Java string to be written into this segment.\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n+     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    default void setUtf8String(long offset, String str) {\n+        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    }\n+\n+\n+    \/**\n+     * Creates a new buffer memory segment that models the memory associated with the given byte\n@@ -584,1 +668,1 @@\n-     * or to some other (possibly closeable) resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * or some other resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n@@ -596,1 +680,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.\n@@ -607,1 +691,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.\n@@ -618,1 +702,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.\n@@ -629,1 +713,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.\n@@ -640,1 +724,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.\n@@ -651,1 +735,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.\n@@ -662,1 +746,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.\n@@ -672,0 +756,41 @@\n+\n+    \/**\n+     * Creates a new native memory segment with given size and resource scope, and whose base address is the given address.\n+     * This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided resource scope.\n+     * <p>\n+     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     *\n+     * @param address the returned segment's base address.\n+     * @param bytesSize the desired size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws IllegalStateException if the provided scope has been already closed,\n+     * or if access occurs from a thread other than the thread owning the scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddress(MemoryAddress address, long bytesSize, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, (ResourceScopeImpl)scope);\n+    }\n+\n@@ -673,1 +798,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout\n@@ -698,1 +823,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n@@ -721,1 +846,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size\n@@ -759,1 +884,1 @@\n-     * this (or another) program.  Whether or not such changes occur, and when they\n+     * this (or another) program.  Whether such changes occur, and when they\n@@ -777,1 +902,1 @@\n-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode\n+     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the mapping mode\n@@ -780,1 +905,1 @@\n-     * @return a new confined mapped memory segment.\n+     * @return a new mapped memory segment.\n@@ -787,1 +912,1 @@\n-     * @throws  SecurityException If a security manager is installed and it denies an unspecified permission required by the implementation.\n+     * @throws  SecurityException If a security manager is installed, and it denies an unspecified permission required by the implementation.\n@@ -798,7 +923,3 @@\n-     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n-     * This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries.\n-     * The returned segment is associated with the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n-     * Equivalent to (but likely more efficient than) the following code:\n-     * <pre>{@code\n-    MemoryAddress.NULL.asSegment(Long.MAX_VALUE)\n-     * }<\/pre>\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n@@ -806,4 +927,102 @@\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n+    \/**\n+     * Reads a byte from this segment and offset with given layout.\n@@ -811,4 +1030,8 @@\n-     * @return a memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a byte value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -816,4 +1039,617 @@\n-    @CallerSensitive\n-    static MemorySegment globalNativeSegment() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return NativeMemorySegmentImpl.EVERYTHING;\n+    @ForceInline\n+    default byte get(ValueLayout.OfByte layout, long offset) {\n+        return (byte)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a byte to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a boolean from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a boolean value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        return (boolean)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a boolean to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a char from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a char value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default char get(ValueLayout.OfChar layout, long offset) {\n+        return (char)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a char to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the char value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfChar layout, long offset, char value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a short from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a short value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default short get(ValueLayout.OfShort layout, long offset) {\n+        return (short)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a short to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfShort layout, long offset, short value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an int from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return an int value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default int get(ValueLayout.OfInt layout, long offset) {\n+        return (int)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes an int to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the int value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfInt layout, long offset, int value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a float from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a float value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default float get(ValueLayout.OfFloat layout, long offset) {\n+        return (float)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a float to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the float value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a long from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a long value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default long get(ValueLayout.OfLong layout, long offset) {\n+        return (long)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a long to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the long value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfLong layout, long offset, long value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a double from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a double value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default double get(ValueLayout.OfDouble layout, long offset) {\n+        return (double)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a double to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the double value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an address from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return an address value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n+        return (MemoryAddress)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes an address to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the address value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n+        layout.accessHandle().set(this, offset, value.address());\n+    }\n+\n+    \/**\n+     * Reads a char from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a char value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        return (char)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a char to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the char value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a short from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a short value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        return (short)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a short to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads an int from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an int value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        return (int)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes an int to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the int value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a float from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a float value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        return (float)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a float to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the float value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a long from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a long value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        return (long)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a long to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the long value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a double from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a double value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        return (double)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a double to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the double value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads an address from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an address value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+        return (MemoryAddress)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes an address to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the address value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value.address());\n+    }\n+\n+\n+    \/**\n+     * Copies a number of elements from a source segment to a destination array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given source element layout.\n+     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n+     * @param srcSegment the source segment.\n+     * @param srcLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported,\n+     * or if the destination array component type does not match the carrier of the source element layout.\n+     *\/\n+    @ForceInline\n+    static void copy(\n+            MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(srcLayout);\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        int dstWidth = (int)(baseAndScale >> 32);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of elements from a source array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given destination element layout.\n+     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n+     * @param dstSegment the destination segment.\n+     * @param dstLayout the destination element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported,\n+     * or if the source array component type does not match the carrier of the destination element layout.\n+     *\/\n+    @ForceInline\n+    static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset, int elementCount) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstLayout);\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        int srcWidth = (int)(baseAndScale >> 32);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n+\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":958,"deletions":122,"binary":false,"changes":1080,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.NativeSymbolImpl;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n+\n+\/**\n+ * A native symbol models a reference to a location (typically the entry point of a function) in a native library.\n+ * A native symbol has a name, and is associated with a scope, which governs the native symbol's lifecycle.\n+ * This is useful, since the library a native symbol refers to can be <em>unloaded<\/em>, thus invalidating the native symbol.\n+ * While native symbols are typically obtained using a {@link SymbolLookup#lookup(String) symbol lookup}, it is also possible to obtain an\n+ * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub},\n+ * that is, a reference to a dynamically-generated native symbol which can be used to call back into Java code.\n+ *\/\n+sealed public interface NativeSymbol extends Addressable permits NativeSymbolImpl {\n+\n+    \/**\n+     * Returns the name of this symbol.\n+     * @return the name of this symbol.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the resource scope associated with this symbol.\n+     * @return the resource scope associated with this symbol.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Returns the memory address associated with this symbol.\n+     * @throws IllegalStateException if the scope associated with this symbol has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this symbol.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n+    \/**\n+     * Creates a new symbol from given name, address and scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param name the symbol name.\n+     * @param address the symbol address.\n+     * @param scope the symbol scope.\n+     * @return A new symbol from given name, address and scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static NativeSymbol ofAddress(String name, MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        return new NativeSymbolImpl(name, address, scope);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeSymbol.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Map;\n@@ -56,1 +54,1 @@\n-        this(size, 1, Map.of());\n+        this(size, 1, Optional.empty());\n@@ -59,2 +57,2 @@\n-    PaddingLayout(long size, long alignment, Map<String, Constable> attributes) {\n-        super(OptionalLong.of(size), alignment, attributes);\n+    PaddingLayout(long size, long alignment, Optional<String> name) {\n+        super(OptionalLong.of(size), alignment, name);\n@@ -76,1 +74,1 @@\n-        if (!(other instanceof PaddingLayout)) {\n+        if (!(other instanceof PaddingLayout p)) {\n@@ -79,1 +77,0 @@\n-        PaddingLayout p = (PaddingLayout)other;\n@@ -89,2 +86,2 @@\n-    PaddingLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new PaddingLayout(bitSize(), alignment, attributes);\n+    PaddingLayout dup(long alignment, Optional<String> name) {\n+        return new PaddingLayout(bitSize(), alignment, name);\n@@ -122,8 +119,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public PaddingLayout withAttribute(String name, Constable value) {\n-        return (PaddingLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/PaddingLayout.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -32,0 +33,1 @@\n+import java.nio.ByteBuffer;\n@@ -39,2 +41,2 @@\n- * with a resource scope can only be accessed while the resource scope is <em>alive<\/em> (see {@link #isAlive()}),\n- * and by the thread associated with the resource scope (if any).\n+ * with a resource scope can only be accessed while the resource scope is {@linkplain #isAlive() alive},\n+ * and by the {@linkplain #ownerThread() thread} associated with the resource scope (if any).\n@@ -42,1 +44,1 @@\n- * <h2>Explicit resource scopes<\/h2>\n+ * <h2>Deterministic deallocation<\/h2>\n@@ -44,4 +46,4 @@\n- * Resource scopes obtained from {@link #newConfinedScope()}, {@link #newSharedScope()} support <em>deterministic deallocation<\/em>;\n- * We call these resource scopes <em>explicit scopes<\/em>. Explicit resource scopes can be closed explicitly (see {@link ResourceScope#close()}).\n- * When a resource scope is closed, it is no longer <em>alive<\/em> (see {@link #isAlive()}, and subsequent operations on\n- * resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * Resource scopes support <em>deterministic deallocation<\/em>; that is, they can be {@linkplain ResourceScope#close() closed}\n+ * explicitly. When a resource scope is closed, it is no longer {@link #isAlive() alive}, and subsequent\n+ * operations on resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance)\n+ * will fail with {@link IllegalStateException}.\n@@ -49,1 +51,1 @@\n- * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addCloseAction(Runnable)}) to be called.\n+ * Closing a resource scope will cause all the {@linkplain #addCloseAction(Runnable) close actions} associated with that scope to be called.\n@@ -52,6 +54,8 @@\n- *     <li>closing the scope associated with a native memory segment results in <em>freeing<\/em> the native memory associated with it\n- *     (see {@link MemorySegment#allocateNative(long, ResourceScope)}, or {@link SegmentAllocator#arenaAllocator(ResourceScope)})<\/li>\n- *     <li>closing the scope associated with a mapped memory segment results in the backing memory-mapped file to be unmapped\n- *     (see {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)})<\/li>\n- *     <li>closing the scope associated with an upcall stub results in releasing the stub\n- *     (see {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}<\/li>\n+ *     <li>closing the scope associated with a {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) native memory segment}\n+ *     results in <em>freeing<\/em> the native memory associated with it;<\/li>\n+ *     <li>closing the scope associated with a {@linkplain MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope) mapped memory segment}\n+ *     results in the backing memory-mapped file to be unmapped;<\/li>\n+ *     <li>closing the scope associated with an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub}\n+ *     results in releasing the stub;<\/li>\n+ *     <li>closing the scope associated with a {@linkplain VaList variable arity list} results in releasing the memory\n+ *     associated with that variable arity list instance.<\/li>\n@@ -59,9 +63,0 @@\n- * <p>\n- * Sometimes, explicit scopes can be associated with a {@link Cleaner} instance (see {@link #newConfinedScope(Cleaner)} and\n- * {@link #newSharedScope(Cleaner)}). We call these resource scopes <em>managed<\/em> resource scopes. A managed resource scope\n- * is closed automatically once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * <p>\n- * Managed scopes can be useful to allow for predictable, deterministic resource deallocation, while still prevent accidental native memory leaks.\n- * In case a managed resource scope is closed explicitly, no further action will be taken when the scope becomes unreachable;\n- * that is, cleanup actions (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not,\n- * are called <em>exactly once<\/em>.\n@@ -69,1 +64,10 @@\n- * <h2>Implicit resource scopes<\/h2>\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Resource scopes can be associated with a {@link Cleaner} instance, so that they are also closed automatically,\n+ * once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * This can be useful to allow for predictable, deterministic resource deallocation, while still preventing accidental\n+ * native memory leaks. In case a managed resource scope is closed explicitly, no further action will be taken when\n+ * the scope becomes unreachable; that is, {@linkplain #addCloseAction(Runnable) close actions} associated with a\n+ * resource scope, whether managed or not, are called <em>exactly once<\/em>.\n+ *\n+ * <h2><a id = \"global-scope\">Global scope<\/a><\/h2>\n@@ -71,5 +75,0 @@\n- * Resource scopes obtained from {@link #newImplicitScope()} cannot be closed explicitly. We call these resource scopes\n- * <em>implicit scopes<\/em>. Calling {@link #close()} on an implicit resource scope always results in an exception.\n- * Resources associated with implicit scopes are released once the scope instance becomes\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * <p>\n@@ -77,2 +76,10 @@\n- * an implicit scope that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * As a results, the global scope will never attempt to release resources associated with it. Such resources must, where\n+ * a resource scope that cannot be closed, either explicitly or implicitly. As a result, the global scope will never\n+ * attempt to release resources associated with it. Examples of resources associated with the global scope are:\n+ * <ul>\n+ *     <li>heap segments created from {@linkplain MemorySegment#ofArray(int[]) arrays} or\n+ *     {@linkplain MemorySegment#ofByteBuffer(ByteBuffer) buffers};<\/li>\n+ *     <li>variable arity lists {@linkplain VaList#ofAddress(MemoryAddress, ResourceScope) obtained} from raw memory addresses;\n+ *     <li>native symbols {@linkplain SymbolLookup#lookup(String) obtained} from a {@linkplain SymbolLookup#loaderLookup() loader lookup},\n+ *     or from the {@link CLinker}.<\/li>\n+ * <\/ul>\n+ * In other words, the global scope is used to indicate that the lifecycle of one or more resources must, where\n@@ -83,1 +90,1 @@\n- * Resource scopes can be further divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n+ * Resource scopes can be divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n@@ -86,2 +93,2 @@\n- * Confined resource scopes (see {@link #newConfinedScope()}), support strong thread-confinement guarantees. Upon creation,\n- * they are assigned an <em>owner thread<\/em>, typically the thread which initiated the creation operation (see {@link #ownerThread()}).\n+ * {@linkplain #newConfinedScope() Confined resource scopes}, support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an {@linkplain #ownerThread() owner thread}, typically the thread which initiated the creation operation.\n@@ -92,2 +99,2 @@\n- * Shared resource scopes (see {@link #newSharedScope()} and {@link #newImplicitScope()}), on the other hand, have no owner thread;\n- * as such resources associated with this shared resource scopes can be accessed by multiple threads.\n+ * {@linkplain #newSharedScope() Shared resource scopes}, on the other hand, have no owner thread;\n+ * as such, resources associated with shared resource scopes can be accessed by multiple threads.\n@@ -95,1 +102,1 @@\n- * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n+ * For instance, a client might obtain a {@link Spliterator} from a segment backed by a shared scope, which can then be used to slice the\n@@ -100,1 +107,0 @@\n-SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n@@ -102,0 +108,1 @@\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -103,4 +110,3 @@\n-    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n-        .mapToInt(s -> (int)VH_int.get(s.address()))\n-        .sum();\n+    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                        .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n+                        .sum();\n@@ -111,1 +117,1 @@\n- * Explicit shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n+ * Shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n@@ -115,1 +121,1 @@\n- * should always ensure that proper synchronization mechanisms (e.g. using resource scope handles, see below) are put in place\n+ * should always ensure that proper synchronization mechanisms (e.g. using temporal dependencies, see below) are put in place\n@@ -118,1 +124,1 @@\n- * <h2>Resource scope handles<\/h2>\n+ * <h2>Temporal dependencies<\/h2>\n@@ -120,5 +126,5 @@\n- * Resource scopes can be made <em>non-closeable<\/em> by acquiring one or more resource scope <em>handles<\/em> (see\n- * {@link #acquire()}. A resource scope handle can be used to make sure that resources associated with a given resource scope\n- * (either explicit or implicit) cannot be released for a certain period of time - e.g. during a critical region of code\n- * involving one or more resources associated with the scope. For instance, an explicit resource scope can only be closed\n- * <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n+ * Resource scopes can depend on each other. More specifically, a scope can feature\n+ * {@linkplain #keepAlive(ResourceScope) temporal dependencies} on one or more other resource scopes.\n+ * Such a resource scope cannot be closed (either implicitly or explicitly) until <em>all<\/em> the scopes it depends on\n+ * have also been closed.\n+ * <p>\n@@ -126,1 +132,1 @@\n- * to ensure that the segment will not be released; this can be done as follows:\n+ * to ensure that the scope associated with that segment will not be closed; this can be done as follows:\n@@ -130,5 +136,3 @@\n-ResourceScope.Handle segmentHandle = segment.scope().acquire()\n-try {\n-   <critical operation on segment>\n-} finally {\n-   segment.scope().release(segmentHandle);\n+try (ResourceScope criticalScope = ResourceScope.newConfinedScope()) {\n+    criticalScope.keepAlive(segment.scope());\n+    <critical operation on segment>\n@@ -138,4 +142,2 @@\n- * Acquiring implicit resource scopes is also possible, but it is often unnecessary: since resources associated with\n- * an implicit scope will only be released when the scope becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n- * clients can use e.g. {@link java.lang.ref.Reference#reachabilityFence(Object)} to make sure that resources associated\n- * with implicit scopes are not released prematurely. That said, the above code snippet works (trivially) for implicit scopes too.\n+ * Note that a resource scope does not become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>\n+ * until all the scopes it depends on have been closed.\n@@ -161,9 +163,1 @@\n-     * Is this resource scope an <em>implicit scope<\/em>?\n-     * @return true if this scope is an <em>implicit scope<\/em>.\n-     * @see #newImplicitScope()\n-     * @see #globalScope()\n-     *\/\n-    boolean isImplicit();\n-\n-    \/**\n-     * Closes this resource scope. As a side-effect, if this operation completes without exceptions, this scope will be marked\n+     * Closes this resource scope. As a side effect, if this operation completes without exceptions, this scope will be marked\n@@ -183,1 +177,1 @@\n-     *     <li>one or more handles (see {@link #acquire()}) associated with this resource scope have not been {@linkplain #release(Handle) released}<\/li>\n+     *     <li>one or more scopes which {@linkplain #keepAlive(ResourceScope) depend} on this resource scope have not been closed.\n@@ -185,1 +179,1 @@\n-     * @throws UnsupportedOperationException if this resource scope is {@linkplain #isImplicit() implicit}.\n+     * @throws UnsupportedOperationException if this resource scope is the {@linkplain #globalScope() global scope}.\n@@ -193,1 +187,2 @@\n-     * @throws IllegalStateException if this scope has already been closed.\n+     * @throws IllegalStateException if this scope has been closed, or if access occurs from\n+     * a thread other than the thread owning this scope.\n@@ -198,19 +193,7 @@\n-     * Acquires a resource scope handle associated with this resource scope. An explicit resource scope cannot be\n-     * {@linkplain #close() closed} until all the resource scope handles acquired from it have been {@linkplain #release(Handle)} released}.\n-     * @return a resource scope handle.\n-     *\/\n-    Handle acquire();\n-\n-    \/**\n-     * Release the provided resource scope handle. This method is idempotent, that is, releasing the same handle\n-     * multiple times has no effect.\n-     * @param handle the resource scope handle to be released.\n-     * @throws IllegalArgumentException if the provided handle is not associated with this scope.\n-     *\/\n-    void release(Handle handle);\n-\n-    \/**\n-     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@linkplain #acquire() acquired} by clients\n-     * in order to prevent an explicit resource scope from being closed while executing a certain operation.\n-     * Once obtained, resource scope handles can be {@linkplain #release(Handle)} released}; an explicit resource scope can\n-     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n+     * Creates a temporal dependency between this scope and the target scope. As a result, the target scope cannot\n+     * be {@linkplain #close() closed} <em>before<\/em> this scope.\n+     * @implNote A given scope can support up to {@link Integer#MAX_VALUE} pending keep alive requests.\n+     * @param target the scope that needs to be kept alive.\n+     * @throws IllegalArgumentException if {@code target == this}.\n+     * @throws IllegalStateException if this scope or {@code target} have been closed, or if access occurs from\n+     * a thread other than the thread owning this scope or {@code target}.\n@@ -218,8 +201,1 @@\n-    sealed interface Handle permits ResourceScopeImpl.HandleImpl {\n-\n-        \/**\n-         * Returns the resource scope associated with this handle.\n-         * @return the resource scope associated with this handle.\n-         *\/\n-        ResourceScope scope();\n-    }\n+    void keepAlive(ResourceScope target);\n@@ -228,1 +204,1 @@\n-     * Create a new confined scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * Creates a new confined scope.\n@@ -232,1 +208,1 @@\n-        return ResourceScopeImpl.createConfined( null);\n+        return ResourceScopeImpl.createConfined(Thread.currentThread(), null);\n@@ -236,1 +212,1 @@\n-     * Create a new confined scope managed by a {@link Cleaner}.\n+     * Creates a new confined scope, managed by the provided cleaner instance.\n@@ -239,1 +215,0 @@\n-     * @throws NullPointerException if {@code cleaner == null}.\n@@ -243,1 +218,1 @@\n-        return ResourceScopeImpl.createConfined( cleaner);\n+        return ResourceScopeImpl.createConfined(Thread.currentThread(), cleaner);\n@@ -247,1 +222,1 @@\n-     * Create a new shared scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * Creates a new shared scope.\n@@ -255,1 +230,1 @@\n-     * Create a new shared scope managed by a {@link Cleaner}.\n+     * Creates a new shared scope, managed by the provided cleaner instance.\n@@ -258,1 +233,0 @@\n-     * @throws NullPointerException if {@code cleaner == null}.\n@@ -266,7 +240,6 @@\n-     * Create a new <em>implicit scope<\/em>. The implicit scope is a managed, shared, and non-closeable scope which only features\n-     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n-     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n-     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n-     * memory pressure.\n-     *\n-     * @return a new implicit scope.\n+     * Creates a new shared scope, managed by a private {@link Cleaner} instance. Equivalent to (but likely more efficient than)\n+     * the following code:\n+     * <pre>{@code\n+    newSharedScope(Cleaner.create());\n+     * }<\/pre>\n+     * @return a shared scope, managed by a private {@link Cleaner} instance.\n@@ -275,1 +248,1 @@\n-        return ResourceScopeImpl.createImplicitScope();\n+        return newSharedScope(CleanerFactory.cleaner());\n@@ -279,2 +252,2 @@\n-     * Returns an implicit scope which is assumed to be always alive.\n-     * @return the global scope.\n+     * Returns the <a href=\"ResourceScope.html#global-scope\"><em>global scope<\/em><\/a>.\n+     * @return the <a href=\"ResourceScope.html#global-scope\"><em>global scope<\/em><\/a>.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":90,"deletions":117,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.foreign.ArenaAllocator;\n@@ -30,0 +29,1 @@\n+import jdk.internal.foreign.ArenaAllocator;\n@@ -36,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -38,1 +39,0 @@\n-import java.util.stream.Stream;\n@@ -44,2 +44,3 @@\n- * This interface can be seen as a thin wrapper around the basic capabilities for creating native segments\n- * (e.g. {@link MemorySegment#allocateNative(long, long, ResourceScope)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n+ * This interface can be seen as a thin wrapper around the basic capabilities for\n+ * {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) creating} native segments;\n+ * since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n@@ -48,14 +49,15 @@\n- * This interface provides a factory, namely {@link SegmentAllocator#ofScope(ResourceScope)} which can be used to obtain\n- * a <em>scoped<\/em> allocator, that is, an allocator which creates segment bound by a given scope. This can be useful\n- * when working inside a <em>try-with-resources<\/em> construct:\n- *\n- * <blockquote><pre>{@code\n-try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-   SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-   ...\n-}\n- * }<\/pre><\/blockquote>\n- *\n- * In addition, this interface also defines factories for commonly used allocators; for instance {@link #arenaAllocator(ResourceScope)}\n- * and {@link #arenaAllocator(long, ResourceScope)} are arena-style native allocators. Finally {@link #ofSegment(MemorySegment)}\n- * returns an allocator which wraps a segment (either on-heap or off-heap) and recycles its content upon each new allocation request.\n+ * This interface also defines factories for commonly used allocators:\n+ * <ul>\n+ *     <li>{@link #nativeAllocator(ResourceScope)} creates an allocator which\n+ *     {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) allocates} native segments, backed by a given scope;<\/li>\n+ *     <li>{@link #newNativeArena(ResourceScope)} creates a more efficient arena-style native allocator, where memory\n+ *     is allocated in bigger blocks, which are then sliced accordingly to fit allocation requests;<\/li>\n+ *     <li>{@link #prefixAllocator(MemorySegment)} creates an allocator which wraps a segment (either on-heap or off-heap)\n+ *     and recycles its content upon each new allocation request.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Passing a segment allocator to an API can be especially useful in circumstances where a client wants to communicate <em>where<\/em>\n+ * the results of a certain operation (performed by the API) should be stored, as a memory segment. For instance,\n+ * {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n+ * {@link SegmentAllocator} parameter if the underlying native function is known to return a struct by-value. Effectively,\n+ * the allocator parameter tells the linker runtime where to store the return value of the native function.\n@@ -67,1 +69,20 @@\n-     * Allocate a block of memory with given layout and initialize it with given byte value.\n+     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n+     * storing the result into a memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @implSpec the default implementation for this method copies the contents of the provided Java string\n+     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native memory segment containing the converted C string.\n+     *\/\n+    default MemorySegment allocateUtf8String(String str) {\n+        Objects.requireNonNull(str);\n+        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+    }\n+\n+    \/**\n+     * Allocate a memory segment with given layout and initialize it with given byte value.\n@@ -72,1 +93,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n@@ -74,1 +94,1 @@\n-    default MemorySegment allocate(ValueLayout layout, byte value) {\n+    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n@@ -76,1 +96,1 @@\n-        VarHandle handle = layout.varHandle(byte.class);\n+        VarHandle handle = layout.varHandle();\n@@ -83,1 +103,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given char value.\n+     * Allocate a memory segment with given layout and initialize it with given char value.\n@@ -88,1 +108,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n@@ -90,1 +109,1 @@\n-    default MemorySegment allocate(ValueLayout layout, char value) {\n+    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n@@ -92,1 +111,1 @@\n-        VarHandle handle = layout.varHandle(char.class);\n+        VarHandle handle = layout.varHandle();\n@@ -99,1 +118,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given short value.\n+     * Allocate a memory segment with given layout and initialize it with given short value.\n@@ -104,1 +123,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n@@ -106,1 +124,1 @@\n-    default MemorySegment allocate(ValueLayout layout, short value) {\n+    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n@@ -108,1 +126,1 @@\n-        VarHandle handle = layout.varHandle(short.class);\n+        VarHandle handle = layout.varHandle();\n@@ -115,1 +133,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given int value.\n+     * Allocate a memory segment with given layout and initialize it with given int value.\n@@ -120,1 +138,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n@@ -122,1 +139,1 @@\n-    default MemorySegment allocate(ValueLayout layout, int value) {\n+    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n@@ -124,1 +141,1 @@\n-        VarHandle handle = layout.varHandle(int.class);\n+        VarHandle handle = layout.varHandle();\n@@ -131,1 +148,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given float value.\n+     * Allocate a memory segment with given layout and initialize it with given float value.\n@@ -136,1 +153,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n@@ -138,1 +154,1 @@\n-    default MemorySegment allocate(ValueLayout layout, float value) {\n+    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n@@ -140,1 +156,1 @@\n-        VarHandle handle = layout.varHandle(float.class);\n+        VarHandle handle = layout.varHandle();\n@@ -147,1 +163,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given long value.\n+     * Allocate a memory segment with given layout and initialize it with given long value.\n@@ -152,1 +168,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n@@ -154,1 +169,1 @@\n-    default MemorySegment allocate(ValueLayout layout, long value) {\n+    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n@@ -156,1 +171,1 @@\n-        VarHandle handle = layout.varHandle(long.class);\n+        VarHandle handle = layout.varHandle();\n@@ -163,1 +178,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given double value.\n+     * Allocate a memory segment with given layout and initialize it with given double value.\n@@ -168,1 +183,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n@@ -170,1 +184,1 @@\n-    default MemorySegment allocate(ValueLayout layout, double value) {\n+    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n@@ -172,1 +186,1 @@\n-        VarHandle handle = layout.varHandle(double.class);\n+        VarHandle handle = layout.varHandle();\n@@ -179,1 +193,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given address value\n+     * Allocate a memory segment with given layout and initialize it with given address value\n@@ -181,1 +195,1 @@\n-     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The address value might be narrowed according to the platform address size (see {@link ValueLayout#ADDRESS}).\n@@ -186,1 +200,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n@@ -188,1 +201,1 @@\n-    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n+    default MemorySegment allocate(ValueLayout.OfAddress layout, Addressable value) {\n@@ -191,8 +204,3 @@\n-        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        return switch ((int)layout.byteSize()) {\n-            case 4 -> allocate(layout, (int)value.address().toRawLongValue());\n-            case 8 -> allocate(layout, value.address().toRawLongValue());\n-            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        };\n+        MemorySegment segment = allocate(layout);\n+        layout.varHandle().set(segment, value.address());\n+        return segment;\n@@ -202,1 +210,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given byte array.\n+     * Allocate a memory segment with given layout and initialize it with given byte array.\n@@ -207,1 +215,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n@@ -209,1 +216,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte[] array) {\n@@ -214,1 +221,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given short array.\n+     * Allocate a memory segment with given layout and initialize it with given short array.\n@@ -219,1 +226,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n@@ -221,1 +227,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short[] array) {\n@@ -226,1 +232,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given char array.\n+     * Allocate a memory segment with given layout and initialize it with given char array.\n@@ -231,1 +237,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n@@ -233,1 +238,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char[] array) {\n@@ -238,1 +243,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given int array.\n+     * Allocate a memory segment with given layout and initialize it with given int array.\n@@ -243,1 +248,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n@@ -245,1 +249,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int[] array) {\n@@ -250,1 +254,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given float array.\n+     * Allocate a memory segment with given layout and initialize it with given float array.\n@@ -255,1 +259,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n@@ -257,1 +260,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float[] array) {\n@@ -262,1 +265,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given long array.\n+     * Allocate a memory segment with given layout and initialize it with given long array.\n@@ -267,1 +270,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n@@ -269,1 +271,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long[] array) {\n@@ -274,1 +276,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given double array.\n+     * Allocate a memory segment with given layout and initialize it with given double array.\n@@ -279,1 +281,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n@@ -281,1 +282,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double[] array) {\n@@ -285,27 +286,0 @@\n-    \/**\n-     * Allocate a block of memory with given layout and initialize it with given address array.\n-     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n-        Objects.requireNonNull(elementLayout);\n-        Objects.requireNonNull(array);\n-        Stream.of(array).forEach(Objects::requireNonNull);\n-        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        return switch ((int)elementLayout.byteSize()) {\n-            case 4 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n-                    elementLayout, MemorySegment::ofArray);\n-            case 8 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n-                    elementLayout, MemorySegment::ofArray);\n-            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        };\n-    }\n-\n@@ -316,7 +290,4 @@\n-        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n-        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n-            addr.copyFrom(heapSegmentFactory.apply(array));\n-        } else {\n-            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n-        }\n+        int size = Array.getLength(array);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n+                addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n@@ -327,1 +298,1 @@\n-     * Allocate a block of memory  with given layout.\n+     * Allocate a memory segment with given layout.\n@@ -338,1 +309,1 @@\n-     * Allocate a block of memory corresponding to an array with given element layout and size.\n+     * Allocate a memory segment with given element layout and size.\n@@ -350,1 +321,2 @@\n-     * Allocate a block of memory with given size, with default alignment (1-byte aligned).\n+     * Allocate a memory segment with given size\n+     * and default alignment constraints (1-byte aligned).\n@@ -360,1 +332,1 @@\n-     * Allocate a block of memory  with given size and alignment constraint.\n+     * Allocate a memory segment with given size and alignment constraints.\n@@ -368,12 +340,5 @@\n-     * Returns a native arena-based allocator which allocates a single memory segment, of given size (using malloc),\n-     * and then responds to allocation request by returning different slices of that same segment\n-     * (until no further allocation is possible).\n-     * This can be useful when clients want to perform multiple allocation requests while avoiding the cost associated\n-     * with allocating a new off-heap memory region upon each allocation request.\n-     * <p>\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the allocator capacity.\n+     * Returns a native unbounded arena-based allocator, with predefined block size and maximum arena size,\n+     * associated with the provided scope. Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator.newNativeArena(Long.MAX_VALUE, predefinedBlockSize, scope);\n+     * }<\/pre><\/blockquote>\n@@ -381,4 +346,2 @@\n-     * @param size the size (in bytes) of the allocation arena.\n-     * @param scope the scope associated with the segments returned by this allocator.\n-     * @return a new bounded arena-based allocator\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @return a new unbounded arena-based allocator\n@@ -388,5 +351,20 @@\n-    static SegmentAllocator arenaAllocator(long size, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        return scope.ownerThread() == null ?\n-                new ArenaAllocator.BoundedSharedArenaAllocator(scope, size) :\n-                new ArenaAllocator.BoundedArenaAllocator(scope, size);\n+    static SegmentAllocator newNativeArena(ResourceScope scope) {\n+        return newNativeArena(Long.MAX_VALUE, ArenaAllocator.DEFAULT_BLOCK_SIZE, scope);\n+    }\n+\n+    \/**\n+     * Returns a native unbounded arena-based allocator, with block size set to the specified arena size, associated with\n+     * the provided scope, with given arena size. Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator.newNativeArena(arenaSize, arenaSize, scope);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n+     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @return a new unbounded arena-based allocator\n+     * @throws IllegalArgumentException if {@code arenaSize <= 0}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     *\/\n+    static SegmentAllocator newNativeArena(long arenaSize, ResourceScope scope) {\n+        return newNativeArena(arenaSize, arenaSize, scope);\n@@ -396,1 +374,1 @@\n-     * Returns a native unbounded arena-based allocator.\n+     * Returns a native arena-based allocator, associated with the provided scope, with given arena size and block size.\n@@ -398,2 +376,2 @@\n-     * The returned allocator allocates a memory segment {@code S} of a certain fixed size (using malloc) and then\n-     * responds to allocation requests in one of the following ways:\n+     * The returned allocator {@linkplain MemorySegment#allocateNative(long, ResourceScope) allocates} a memory segment\n+     * {@code S} of the specified block size and then responds to allocation requests in one of the following ways:\n@@ -404,1 +382,1 @@\n-     *     slices which fits that allocation request, allocate a new segment {@code S'} (using malloc), which has same size as {@code S}\n+     *     slices which fits that allocation request, allocate a new segment {@code S'}, which has same size as {@code S}\n@@ -406,2 +384,2 @@\n-     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'}\n-     *     (using malloc), which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n+     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'},\n+     *     which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n@@ -413,6 +391,3 @@\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the system capacity.\n+     * The returned allocator might throw an {@link OutOfMemoryError} if the total memory allocated with this allocator\n+     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe.\n+     * Concurrent allocation needs to be guarded with synchronization primitives.\n@@ -420,1 +395,3 @@\n-     * @param scope the scope associated with the segments returned by this allocator.\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n+     * @param blockSize the block size associated with the arena-based allocator.\n+     * @param scope the scope associated with the segments returned by the arena-based allocator.\n@@ -422,0 +399,1 @@\n+     * @throws IllegalArgumentException if {@code blockSize <= 0}, if {@code arenaSize <= 0} or if {@code arenaSize < blockSize}.\n@@ -425,1 +403,1 @@\n-    static SegmentAllocator arenaAllocator(ResourceScope scope) {\n+    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, ResourceScope scope) {\n@@ -427,3 +405,7 @@\n-        return scope.ownerThread() == null ?\n-                new ArenaAllocator.UnboundedSharedArenaAllocator(scope) :\n-                new ArenaAllocator.UnboundedArenaAllocator(scope);\n+        if (blockSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid block size: \" + blockSize);\n+        }\n+        if (arenaSize <= 0 || arenaSize < blockSize) {\n+            throw new IllegalArgumentException(\"Invalid arena size: \" + arenaSize);\n+        }\n+        return new ArenaAllocator(blockSize, arenaSize, scope);\n@@ -435,1 +417,8 @@\n-     * constraints are ignored by this allocator). This can be useful to limit allocation requests in case a client\n+     * constraints are ignored by this allocator), hence the name <em>prefix allocator<\/em>.\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment segment = ...\n+    SegmentAllocator prefixAllocator = (size, align) -> segment.asSlice(0, size);\n+     * }<\/pre><\/blockquote>\n+     * <p>\n+     * This allocator can be useful to limit allocation requests in case a client\n@@ -445,1 +434,1 @@\n-    static SegmentAllocator ofSegment(MemorySegment segment) {\n+    static SegmentAllocator prefixAllocator(MemorySegment segment) {\n@@ -447,1 +436,1 @@\n-        return (size, align) -> segment.asSlice(0, size);\n+        return (AbstractMemorySegmentImpl)segment;\n@@ -451,3 +440,2 @@\n-     * Returns a native allocator which responds to allocation requests by allocating new segments\n-     * bound by the given resource scope, using the {@link MemorySegment#allocateNative(long, long, ResourceScope)}\n-     * factory. This code is equivalent (but likely more efficient) to the following:\n+     * Returns a native allocator, associated with the provided scope. Equivalent to (but likely more efficient than)\n+     * the following code:\n@@ -455,2 +443,2 @@\n-    Resource scope = ...\n-    SegmentAllocator scoped = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n+    ResourceScope scope = ...\n+    SegmentAllocator nativeAllocator = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n@@ -459,2 +447,2 @@\n-     * @param scope the resource scope associated with the segments created by the returned allocator.\n-     * @return an allocator which allocates new memory segment bound by the provided resource scope.\n+     * @param scope the scope associated with the returned allocator.\n+     * @return a native allocator, associated with the provided scope.\n@@ -462,1 +450,1 @@\n-    static SegmentAllocator ofScope(ResourceScope scope) {\n+    static SegmentAllocator nativeAllocator(ResourceScope scope) {\n@@ -466,0 +454,18 @@\n+\n+    \/**\n+     * Returns a native allocator which allocates segments in independent {@linkplain ResourceScope#newImplicitScope() implicit scopes}.\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * <blockquote><pre>{@code\n+    ResourceScope scope = ...\n+    SegmentAllocator implicitAllocator = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @return a native allocator which allocates segments in independent {@linkplain ResourceScope#newImplicitScope() implicit scopes}.\n+     *\/\n+    static SegmentAllocator implicitAllocator() {\n+        class Holder {\n+            static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) ->\n+                    MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+        }\n+        return Holder.IMPLICIT_ALLOCATOR;\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":172,"deletions":166,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Map;\n@@ -38,1 +36,1 @@\n- * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the the sequence layout's <em>element count<\/em>.\n+ * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the sequence layout's <em>element count<\/em>.\n@@ -43,1 +41,1 @@\n-MemoryLayout.sequenceLayout(3, MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n+MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -50,3 +48,3 @@\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -75,1 +73,1 @@\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Map.of());\n+        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n@@ -78,1 +76,1 @@\n-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Map<String, Constable> attributes) {\n+    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {\n@@ -81,1 +79,1 @@\n-                OptionalLong.empty(), alignment, attributes);\n+                OptionalLong.empty(), alignment, name);\n@@ -113,1 +111,1 @@\n-        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);\n+        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, name());\n@@ -125,1 +123,1 @@\n-    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n@@ -129,1 +127,1 @@\n-    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, MemoryLayouts.JAVA_INT));\n+    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n@@ -154,1 +152,1 @@\n-        if (!elementCount().isPresent()) {\n+        if (elementCount().isEmpty()) {\n@@ -201,1 +199,1 @@\n-    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n@@ -205,1 +203,1 @@\n-    var flattenedSeq = MemoryLayout.sequenceLayout(12, MemoryLayouts.JAVA_INT);\n+    var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n@@ -213,1 +211,1 @@\n-        if (!elementCount().isPresent()) {\n+        if (elementCount().isEmpty()) {\n@@ -218,2 +216,1 @@\n-        while (elemLayout instanceof SequenceLayout) {\n-            SequenceLayout elemSeq = (SequenceLayout)elemLayout;\n+        while (elemLayout instanceof SequenceLayout elemSeq) {\n@@ -244,1 +241,1 @@\n-        if (!(other instanceof SequenceLayout)) {\n+        if (!(other instanceof SequenceLayout s)) {\n@@ -247,1 +244,0 @@\n-        SequenceLayout s = (SequenceLayout)other;\n@@ -257,2 +253,2 @@\n-    SequenceLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new SequenceLayout(elementCount(), elementLayout, alignment, attributes);\n+    SequenceLayout dup(long alignment, Optional<String> name) {\n+        return new SequenceLayout(elementCount(), elementLayout, alignment, name);\n@@ -293,8 +289,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withAttribute(String name, Constable value) {\n-        return (SequenceLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":19,"deletions":31,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +38,1 @@\n- * A symbol lookup can be used to lookup a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n+ * A symbol lookup can be used to look up a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n@@ -40,2 +41,2 @@\n- * Alternatively, clients can obtain a {@linkplain CLinker#systemLookup() platform-dependent lookup}, to search symbols\n- * in the standard C library.\n+ * Alternatively, clients can search symbols in the standard C library using a {@link CLinker}, which conveniently\n+ * implements this interface.\n@@ -52,1 +53,1 @@\n-     * @return the memory address associated with the symbol (if any).\n+     * @return the lookup symbol (if any).\n@@ -54,1 +55,1 @@\n-    Optional<MemoryAddress> lookup(String name);\n+    Optional<NativeSymbol> lookup(String name);\n@@ -58,1 +59,3 @@\n-     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n+     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}). The returned lookup\n+     * returns native symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n@@ -75,0 +78,1 @@\n+        ResourceScope loaderScope = ResourceScopeImpl.heapScope(loader);\n@@ -79,1 +83,1 @@\n-            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, loaderScope));\n@@ -82,0 +86,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n+import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n+import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * An interface that models a variable argument list, similar in functionality to a C {@code va_list}.\n+ * <p>\n+ * A variable argument list is a stateful cursor used to iterate over a set of arguments. A variable argument list\n+ * can be passed by reference e.g. to a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle}.\n+ * <p>\n+ * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n+ * arguments to variadic calls are erased by way of 'default argument promotions',\n+ * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n+ * and which erases all {@code float} arguments to {@code double}.\n+ * <p>\n+ * As such, this interface only supports reading {@code int}, {@code double},\n+ * and any other type that fits into a {@code long}.\n+ *\n+ * This class is not thread safe, and all accesses should occur within a single thread\n+ * (regardless of the scope associated with the variable arity list).\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\/\n+sealed public interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n+\n+    \/**\n+     * Reads the next value as an {@code int} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code int} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    int nextVarg(ValueLayout.OfInt layout);\n+\n+    \/**\n+     * Reads the next value as a {@code long} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code long} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    long nextVarg(ValueLayout.OfLong layout);\n+\n+    \/**\n+     * Reads the next value as a {@code double} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value\n+     * @return the {@code double} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    double nextVarg(ValueLayout.OfDouble layout);\n+\n+    \/**\n+     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code MemoryAddress} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    MemoryAddress nextVarg(ValueLayout.OfAddress layout);\n+\n+    \/**\n+     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position.\n+     * <p>\n+     * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @param allocator the allocator to be used to create a segment where the contents of the variable argument list\n+     *                  will be copied.\n+     * @return the {@code MemorySegment} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator);\n+\n+    \/**\n+     * Skips a number of elements with the given memory layouts, and advances this variable argument list's position.\n+     *\n+     * @param layouts the layouts of the values to be skipped.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    void skip(MemoryLayout... layouts);\n+\n+    \/**\n+     * Returns the resource scope associated with this variable argument list.\n+     * @return the resource scope associated with this variable argument list.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Copies this variable argument list at its current position into a new variable argument list associated\n+     * with the same scope as this variable argument list. Copying is useful to\n+     * traverse the variable argument list elements, starting from the current position, without affecting the state\n+     * of the original variable argument list, essentially allowing the elements to be traversed multiple times.\n+     *\n+     * @return a copy of this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    VaList copy();\n+\n+    \/**\n+     * Returns the memory address associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this variable argument list.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n+    \/**\n+     * Constructs a new variable argument list from a memory address pointing to an existing variable argument list,\n+     * with given resource scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param address a memory address pointing to an existing variable argument list.\n+     * @param scope the resource scope to be associated with the returned variable argument list.\n+     * @return a new variable argument list backed by the memory region at {@code address}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaListOfAddress(address, scope);\n+    }\n+\n+    \/**\n+     * Constructs a new variable argument list using a builder (see {@link Builder}), with a given resource scope.\n+     * <p>\n+     * If this method needs to allocate native memory, such memory will be managed by the given\n+     * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n+     * <p>\n+     * Note that when there are no elements added to the created va list,\n+     * this method will return the same as {@link #empty()}.\n+     *\n+     * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n+     *                of the underlying variable argument list.\n+     * @param scope scope the scope to be associated with the new variable arity list.\n+     * @return a new variable argument list.\n+     * @throws IllegalStateException if the scope associated with {@code allocator} has been already closed,\n+     * or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n+        Objects.requireNonNull(actions);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaList(actions, scope);\n+    }\n+\n+    \/**\n+     * Returns an empty variable argument list, associated with the {@linkplain ResourceScope#globalScope() global}\n+     * scope. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+     * on all operations, except for {@link #scope()}, {@link #copy()} and {@link #address()}.\n+     * @return an empty variable argument list.\n+     *\/\n+    static VaList empty() {\n+        return SharedUtils.emptyVaList();\n+    }\n+\n+    \/**\n+     * A builder interface used to construct a variable argument list.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+     *\/\n+    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n+\n+        \/**\n+         * Writes an {@code int} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code int} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfInt layout, int value);\n+\n+        \/**\n+         * Writes a {@code long} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code long} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfLong layout, long value);\n+\n+        \/**\n+         * Writes a {@code double} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code double} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfDouble layout, double value);\n+\n+        \/**\n+         * Writes an {@code Addressable} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code Addressable} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfAddress layout, Addressable value);\n+\n+        \/**\n+         * Writes a {@code MemorySegment} value, with given layout, to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code MemorySegment} whose contents will be copied.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(GroupLayout layout, MemorySegment value);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -28,1 +28,6 @@\n-import java.lang.constant.Constable;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n@@ -31,0 +36,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -32,1 +38,0 @@\n-import java.util.Map;\n@@ -39,2 +44,8 @@\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size and a byte order (see {@link ByteOrder}).\n- *\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, a {@linkplain ByteOrder byte order})\n+ * and a <em>carrier<\/em>, that is, the Java type that should be used when {@linkplain MemorySegment#get(OfInt, long) accessing}\n+ * a memory region using the value layout.\n+ * <p>\n+ * This class defines useful value layout constants for Java primitive types and addresses.\n+ * The layout constants in this class make implicit alignment and byte-ordering assumption: all layout\n+ * constants in this class are byte-aligned, and their byte order is set to the {@linkplain ByteOrder#nativeOrder() platform default},\n+ * thus making it easy to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n@@ -55,1 +66,1 @@\n-public final class ValueLayout extends AbstractLayout implements MemoryLayout {\n+public sealed class ValueLayout extends AbstractLayout implements MemoryLayout {\n@@ -57,0 +68,1 @@\n+    private final Class<?> carrier;\n@@ -59,2 +71,4 @@\n-    ValueLayout(ByteOrder order, long size) {\n-        this(order, size, size, Map.of());\n+    private static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+\n+    ValueLayout(Class<?> carrier, ByteOrder order, long size) {\n+        this(carrier, order, size, size, Optional.empty());\n@@ -63,2 +77,3 @@\n-    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n-        super(OptionalLong.of(size), alignment, attributes);\n+    ValueLayout(Class<?> carrier, ByteOrder order, long size, long alignment, Optional<String> name) {\n+        super(OptionalLong.of(size), alignment, name);\n+        this.carrier = carrier;\n@@ -66,0 +81,1 @@\n+        checkCarrierSize(carrier, size);\n@@ -84,1 +100,1 @@\n-        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n+        return new ValueLayout(carrier, Objects.requireNonNull(order), bitSize(), alignment, name());\n@@ -102,1 +118,1 @@\n-        if (!(other instanceof ValueLayout)) {\n+        if (!(other instanceof ValueLayout v)) {\n@@ -105,2 +121,2 @@\n-        ValueLayout v = (ValueLayout)other;\n-        return order.equals(v.order) &&\n+        return carrier.equals(v.carrier) &&\n+            order.equals(v.order) &&\n@@ -111,0 +127,8 @@\n+    \/**\n+     * Returns the carrier associated with this value layout.\n+     * @return the carrier associated with this value layout.\n+     *\/\n+    public Class<?> carrier() {\n+        return carrier;\n+    }\n+\n@@ -117,2 +141,2 @@\n-    ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+    ValueLayout dup(long alignment, Optional<String> name) {\n+        return new ValueLayout(carrier, order, bitSize(), alignment, name());\n@@ -124,1 +148,1 @@\n-                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n+                CD_VALUE_LAYOUT, MH_VALUE, carrier().describeConstable().get(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n@@ -146,0 +170,39 @@\n+    static void checkCarrierSize(Class<?> carrier, long size) {\n+        if (!isValidCarrier(carrier)) {\n+            throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n+        }\n+        if (carrier == MemoryAddress.class && size != ADDRESS_SIZE_BITS) {\n+            throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n+        }\n+        if (carrier.isPrimitive()) {\n+            int expectedSize =  carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n+            if (size != expectedSize) {\n+                throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+            }\n+        }\n+    }\n+\n+    static boolean isValidCarrier(Class<?> carrier) {\n+        return carrier == boolean.class\n+                || carrier == byte.class\n+                || carrier == short.class\n+                || carrier == char.class\n+                || carrier == int.class\n+                || carrier == long.class\n+                || carrier == float.class\n+                || carrier == double.class\n+                || carrier == MemoryAddress.class;\n+    }\n+\n+    @Stable\n+    private VarHandle handle;\n+\n+    @ForceInline\n+    VarHandle accessHandle() {\n+        if (handle == null) {\n+            \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n+            handle = Utils.makeMemoryAccessVarHandle(this, false);\n+        }\n+        return handle;\n+    }\n+\n@@ -147,1 +210,1 @@\n-     * {@inheritDoc}\n+     * A value layout whose carrier is {@code boolean.class}.\n@@ -149,3 +212,63 @@\n-    @Override\n-    public ValueLayout withAttribute(String name, Constable value) {\n-        return (ValueLayout)super.withAttribute(name, value);\n+    public static final class OfBoolean extends ValueLayout {\n+        OfBoolean(ByteOrder order) {\n+            super(boolean.class, order, 8);\n+        }\n+\n+        OfBoolean(ByteOrder order, long alignment, Optional<String> name) {\n+            super(boolean.class, order, 8, alignment, name);\n+        }\n+\n+        @Override\n+        OfBoolean dup(long alignment, Optional<String> name) {\n+            return new OfBoolean(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfBoolean withName(String name) {\n+            return (OfBoolean)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfBoolean withBitAlignment(long alignmentBits) {\n+            return (OfBoolean)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfBoolean withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfBoolean(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code byte.class}.\n+     *\/\n+    public static final class OfByte extends ValueLayout {\n+        OfByte(ByteOrder order) {\n+            super(byte.class, order, 8);\n+        }\n+\n+        OfByte(ByteOrder order, long alignment, Optional<String> name) {\n+            super(byte.class, order, 8, alignment, name);\n+        }\n+\n+        @Override\n+        OfByte dup(long alignment, Optional<String> name) {\n+            return new OfByte(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfByte withName(String name) {\n+            return (OfByte)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfByte withBitAlignment(long alignmentBits) {\n+            return (OfByte)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfByte withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfByte(order, alignment, name());\n+        }\n@@ -153,0 +276,329 @@\n+\n+    \/**\n+     * A value layout whose carrier is {@code char.class}.\n+     *\/\n+    public static final class OfChar extends ValueLayout {\n+        OfChar(ByteOrder order) {\n+            super(char.class, order, 16);\n+        }\n+\n+        OfChar(ByteOrder order, long alignment, Optional<String> name) {\n+            super(char.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfChar dup(long alignment, Optional<String> name) {\n+            return new OfChar(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfChar withName(String name) {\n+            return (OfChar)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfChar withBitAlignment(long alignmentBits) {\n+            return (OfChar)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfChar withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfChar(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code short.class}.\n+     *\/\n+    public static final class OfShort extends ValueLayout {\n+        OfShort(ByteOrder order) {\n+            super(short.class, order, 16);\n+        }\n+\n+        OfShort(ByteOrder order, long alignment, Optional<String> name) {\n+            super(short.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfShort dup(long alignment, Optional<String> name) {\n+            return new OfShort(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfShort withName(String name) {\n+            return (OfShort)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfShort withBitAlignment(long alignmentBits) {\n+            return (OfShort)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfShort withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfShort(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code int.class}.\n+     *\/\n+    public static final class OfInt extends ValueLayout {\n+        OfInt(ByteOrder order) {\n+            super(int.class, order, 32);\n+        }\n+\n+        OfInt(ByteOrder order, long alignment, Optional<String> name) {\n+            super(int.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfInt dup(long alignment, Optional<String> name) {\n+            return new OfInt(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfInt withName(String name) {\n+            return (OfInt)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfInt withBitAlignment(long alignmentBits) {\n+            return (OfInt)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfInt withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfInt(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code float.class}.\n+     *\/\n+    public static final class OfFloat extends ValueLayout {\n+        OfFloat(ByteOrder order) {\n+            super(float.class, order, 32);\n+        }\n+\n+        OfFloat(ByteOrder order, long alignment, Optional<String> name) {\n+            super(float.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfFloat dup(long alignment, Optional<String> name) {\n+            return new OfFloat(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfFloat withName(String name) {\n+            return (OfFloat)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfFloat withBitAlignment(long alignmentBits) {\n+            return (OfFloat)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfFloat withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfFloat(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code long.class}.\n+     *\/\n+    public static final class OfLong extends ValueLayout {\n+        OfLong(ByteOrder order) {\n+            super(long.class, order, 64);\n+        }\n+\n+        OfLong(ByteOrder order, long alignment, Optional<String> name) {\n+            super(long.class, order, 64, alignment, name);\n+        }\n+\n+        @Override\n+        OfLong dup(long alignment, Optional<String> name) {\n+            return new OfLong(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfLong withName(String name) {\n+            return (OfLong)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfLong withBitAlignment(long alignmentBits) {\n+            return (OfLong)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfLong withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfLong(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code double.class}.\n+     *\/\n+    public static final class OfDouble extends ValueLayout {\n+        OfDouble(ByteOrder order) {\n+            super(double.class, order, 64);\n+        }\n+\n+        OfDouble(ByteOrder order, long alignment, Optional<String> name) {\n+            super(double.class, order, 64, alignment, name);\n+        }\n+\n+        @Override\n+        OfDouble dup(long alignment, Optional<String> name) {\n+            return new OfDouble(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfDouble withName(String name) {\n+            return (OfDouble)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfDouble withBitAlignment(long alignmentBits) {\n+            return (OfDouble)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfDouble withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfDouble(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code MemoryAddress.class}.\n+     *\/\n+    public static final class OfAddress extends ValueLayout {\n+        OfAddress(ByteOrder order) {\n+            super(MemoryAddress.class, order, ADDRESS_SIZE_BITS);\n+        }\n+\n+        OfAddress(ByteOrder order, long size, long alignment, Optional<String> name) {\n+            super(MemoryAddress.class, order, size, alignment, name);\n+        }\n+\n+        @Override\n+        OfAddress dup(long alignment, Optional<String> name) {\n+            return new OfAddress(order(), bitSize(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfAddress withName(String name) {\n+            return (OfAddress)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfAddress withBitAlignment(long alignmentBits) {\n+            return (OfAddress)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfAddress withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfAddress(order, bitSize(), alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}),\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(MemoryAddress.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code byte},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code boolean},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code char},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code short},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code int},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code long},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder())\n+            .withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code float},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code double},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder()).withBitAlignment(8);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":472,"deletions":20,"binary":false,"changes":492,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n- * The key abstractions introduced to support foreign memory access are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.\n- * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which also can\n- * reside either inside or outside the Java heap (and can sometimes be expressed as an offset into a given segment).\n+ * The main abstractions introduced to support foreign memory access is {@link jdk.incubator.foreign.MemorySegment}, which\n+ * models a contiguous memory region, which can reside either inside or outside the Java heap.\n@@ -38,1 +37,1 @@\n- * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemorySegment} class, which can\n@@ -50,1 +49,1 @@\n-   MemoryAccess.setIntAtIndex(segment, i, 42);\n+   segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -54,1 +53,1 @@\n- * Here create a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n@@ -56,4 +55,6 @@\n- * Inside a loop, we then initialize the contents of the memory segment using the\n- * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n- * more specifically, if we view the memory segment as a set of 10 adjacent slots,\n- * {@code s[i]}, where {@code 0 <= i < 10}, where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n+ * Inside a loop, we then initialize the contents of the memory segment; note how the\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n+ * accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n+ * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n+ * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n@@ -75,1 +76,1 @@\n-        MemoryAccess.setIntAtIndex(segment, i, 42);\n+        segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -99,3 +100,4 @@\n- * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup} and {@link jdk.incubator.foreign.CLinker}.\n- * The former is used to lookup symbols inside native libraries; the latter\n- * provides linking capabilities which allow to model foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup},\n+ * {@link jdk.incubator.foreign.MemoryAddress} and {@link jdk.incubator.foreign.CLinker}.\n+ * The first is used to lookup symbols inside native libraries; the second is used to model native addresses (more on that later),\n+ * while the third provides linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -109,4 +111,4 @@\n-      MethodHandle strlen = CLinker.getInstance().downcallHandle(\n-        CLinker.systemLookup().lookup(\"strlen\").get(),\n-        MethodType.methodType(long.class, MemoryAddress.class),\n-        FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER)\n+      var linker = CLinker.systemCLinker();\n+      MethodHandle strlen = linker.downcallHandle(\n+        linker.lookup(\"strlen\").get(),\n+        FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n@@ -116,2 +118,3 @@\n-         var cString = CLinker.toCString(\"Hello\", scope);\n-         long len = (long)strlen.invokeExact(cString.address()); \/\/ 5\n+         var cString = MemorySegment.allocateNative(5 + 1, scope);\n+         cString.setUtf8String(\"Hello\");\n+         long len = (long)strlen.invoke(cString); \/\/ 5\n@@ -121,12 +124,13 @@\n- * Here, we lookup the {@code strlen} symbol in the {@linkplain jdk.incubator.foreign.CLinker#systemLookup() system lookup}.\n- * Then, we obtain a linker instance (see {@link jdk.incubator.foreign.CLinker#getInstance()}) and we use it to\n- * obtain a method handle which targets the {@code strlen} library symbol. To complete the linking successfully,\n- * we must provide (i) a {@link java.lang.invoke.MethodType} instance, describing the type of the resulting method handle\n- * and (ii) a {@link jdk.incubator.foreign.FunctionDescriptor} instance, describing the signature of the {@code strlen}\n- * function. From this information, the linker will uniquely determine the sequence of steps which will turn\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n- * into a foreign function call, according to the rules specified by the platform C ABI. The {@link jdk.incubator.foreign.CLinker}\n- * class also provides many useful methods for interacting with native code, such as converting Java strings into\n- * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String, ResourceScope)} and\n- * {@link jdk.incubator.foreign.CLinker#toJavaString(jdk.incubator.foreign.MemorySegment)}, respectively), as\n- * demonstrated in the above example.\n+ * Here, we obtain a {@linkplain jdk.incubator.foreign.CLinker#systemCLinker() linker instance} and we use it\n+ * to {@linkplain jdk.incubator.foreign.CLinker#lookup(java.lang.String) lookup} the {@code strlen} symbol in the\n+ * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n+ * {@linkplain jdk.incubator.foreign.CLinker#downcallHandle(jdk.incubator.foreign.FunctionDescriptor) obtained}.\n+ * To complete the linking successfully, we must provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance,\n+ * describing the signature of the {@code strlen} function.\n+ * From this information, the linker will uniquely determine the sequence of steps which will turn\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n+ * into a foreign function call, according to the rules specified by the platform C ABI.\n+ * The {@link jdk.incubator.foreign.MemorySegment} class also provides many useful methods for\n+ * interacting with native code, such as converting Java strings\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} native strings and\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#getUtf8String(long) back}, as demonstrated in the above example.\n@@ -141,7 +145,5 @@\n- * When clients receive a {@link jdk.incubator.foreign.MemoryAddress} instance from a foreign function call, it might be\n- * necessary to obtain a {@link jdk.incubator.foreign.MemorySegment} instance to dereference the memory pointed to by that address.\n- * To do that, clients can proceed in three different ways, described below.\n- * <p>\n- * First, if the memory address is known to belong to a segment the client already owns, a <em>rebase<\/em> operation can be performed;\n- * in other words, the client can ask the address what its offset relative to a given segment is, and, then, proceed to dereference\n- * the original segment accordingly, as follows:\n+ * Raw pointers are modelled using the {@link jdk.incubator.foreign.MemoryAddress} class. When clients receive a\n+ * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n+ * using one of the many <em>unsafe<\/em>\n+ * {@linkplain jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long) dereference methods}\n+ * provided:\n@@ -150,1 +152,0 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, scope);\n@@ -153,1 +154,1 @@\n-int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));\n+int x = addr.get(ValueLayout.JAVA_INT, 0);\n@@ -156,4 +157,5 @@\n- * Secondly, if the client does <em>not<\/em> have a segment which contains a given memory address, it can create one <em>unsafely<\/em>,\n- * using the {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} factory. This allows the client to\n- * inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n- * which produced the native address. Here is how an unsafe segment can be created from a native address:\n+ * Alternatively, the client can\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#ofAddress(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope) create}\n+ * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n+ * for instance, be available in the documentation of the foreign function which produced the native address.\n+ * Here is how an unsafe segment can be created from a native address:\n@@ -164,11 +166,2 @@\n-MemorySegment segment = addr.asSegment(4, scope); \/\/ segment is 4 bytes long\n-int x = MemoryAccess.getInt(segment);\n- * }<\/pre>\n- *\n- * Alternatively, the client can fall back to use the so called <em>everything<\/em> segment - that is, a primordial segment\n- * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#globalNativeSegment()}\n- * method, so that dereference can happen without the need of creating any additional segment instances:\n- *\n- * <pre>{@code\n-MemoryAddress addr = ... \/\/obtain address from native code\n-int x = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+MemorySegment segment = MemorySegment.ofAddress(addr, 4, scope); \/\/ segment is 4 bytes long\n+int x = segment.get(ValueLayout.JAVA_INT, 0);\n@@ -179,3 +172,2 @@\n- * to a Java method) into a native memory address (see {@link jdk.incubator.foreign.MemoryAddress}), so that Java code\n- * can effectively be passed to other foreign functions. For instance, we can write a method that compares two\n- * integer values, as follows:\n+ * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n+ * For instance, we can write a method that compares two integer values, as follows:\n@@ -186,2 +178,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) -\n-               MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n+        return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n@@ -197,0 +188,1 @@\n+FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n@@ -199,1 +191,1 @@\n-                                                   MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                                                   CLinker.upcallType(comparFunction));\n@@ -202,1 +194,7 @@\n- * Now that we have a method handle instance, we can link it into a fresh native memory address, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n+ * As before, we need to create a {@link jdk.incubator.foreign.FunctionDescriptor} instance, this time describing the signature\n+ * of the function pointer we want to create. The descriptor can be used to\n+ * {@linkplain jdk.incubator.foreign.CLinker#upcallType(jdk.incubator.foreign.FunctionDescriptor) derive} a method type\n+ * that can be used to lookup the method handle for {@code IntComparator.intCompare}.\n+ * <p>\n+ * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n+ * using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n@@ -206,4 +204,2 @@\n-MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n-     intCompareHandle,\n-     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n-     scope\n+Addressable comparFunc = CLinker.systemCLinker().upcallStub(\n+     intCompareHandle, intCompareDescriptor, scope);\n@@ -213,6 +209,7 @@\n- * As before, we need to provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance describing the signature\n- * of the function pointer we want to create; as before, this, coupled with the method handle type, uniquely determines the\n- * sequence of steps which will allow foreign code to call {@code intCompareHandle} according to the rules specified\n- * by the platform C ABI. The lifecycle of the memory address returned by\n- * {@link jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope)}\n- * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method.\n+ * The {@link jdk.incubator.foreign.FunctionDescriptor} instance created in the previous step is then used to\n+ * {@linkplain jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope) create}\n+ * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n+ * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the platform C ABI.\n+ * The lifecycle of the upcall stub returned by is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope}\n+ * provided when the upcall stub is created. This same scope is made available by the {@link jdk.incubator.foreign.NativeSymbol}\n+ * instance returned by that method.\n@@ -224,2 +221,2 @@\n- * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} can be used to create\n- * a fresh segment with given spatial bounds out of a native address.\n+ * the restricted method {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n+ * can be used to create a fresh segment with given spatial bounds out of a native address.\n@@ -228,2 +225,2 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)}, if the provided\n- * spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+ * For instance, in the case of {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n+ * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":75,"deletions":78,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-\n-public abstract non-sealed class AbstractCLinker implements CLinker {\n-\n-    public final MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-    }\n-\n-    public final MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        Objects.requireNonNull(allocator);\n-        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-        if (type.returnType().equals(MemorySegment.class)) {\n-            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n-        }\n-        return downcall;\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.nio.ByteOrder;\n@@ -46,0 +47,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -55,1 +58,1 @@\n-public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment {\n+public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment, SegmentAllocator, Scoped {\n@@ -143,18 +146,3 @@\n-    public void copyFrom(MemorySegment src) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n-                that.base(), that.min(),\n-                base(), min(), size);\n-    }\n-\n-    public void copyFromSwap(MemorySegment src, long elemSize) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                        that.base(), that.min(),\n-                        base(), min(), size, elemSize);\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return asSlice(0, bytesSize);\n@@ -178,1 +166,1 @@\n-            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n+            if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {\n@@ -193,1 +181,1 @@\n-            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n+            if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {\n@@ -233,3 +221,2 @@\n-    @ForceInline\n-    public final MemoryAddress address() {\n-        return new MemoryAddressImpl(this, 0L);\n+    public MemoryAddress address() {\n+        throw new UnsupportedOperationException(\"Cannot obtain address of on-heap segment\");\n@@ -272,0 +259,27 @@\n+    @Override\n+    public final MemorySegment asOverlappingSlice(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n+        if (base() == that.base()) {  \/\/ both either native or heap\n+            final long thisStart = this.min();\n+            final long thatStart = that.min();\n+            final long thisEnd = thisStart + this.byteSize();\n+            final long thatEnd = thatStart + that.byteSize();\n+\n+            if (thisStart < thatEnd && thisEnd > thatStart) {  \/\/overlap occurs\n+                long offsetToThat = this.segmentOffset(that);\n+                long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+                return asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public final long segmentOffset(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n+        if (base() == that.base()) {\n+            return that.min() - this.min();\n+        }\n+        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n+    }\n+\n@@ -293,2 +307,2 @@\n-    public final byte[] toByteArray() {\n-        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);\n+    public final byte[] toArray(ValueLayout.OfByte elementLayout) {\n+        return toArray(byte[].class, elementLayout, byte[]::new, MemorySegment::ofArray);\n@@ -298,2 +312,2 @@\n-    public final short[] toShortArray() {\n-        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);\n+    public final short[] toArray(ValueLayout.OfShort elementLayout) {\n+        return toArray(short[].class, elementLayout, short[]::new, MemorySegment::ofArray);\n@@ -303,2 +317,2 @@\n-    public final char[] toCharArray() {\n-        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);\n+    public final char[] toArray(ValueLayout.OfChar elementLayout) {\n+        return toArray(char[].class, elementLayout, char[]::new, MemorySegment::ofArray);\n@@ -308,2 +322,2 @@\n-    public final int[] toIntArray() {\n-        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);\n+    public final int[] toArray(ValueLayout.OfInt elementLayout) {\n+        return toArray(int[].class, elementLayout, int[]::new, MemorySegment::ofArray);\n@@ -313,2 +327,2 @@\n-    public final float[] toFloatArray() {\n-        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);\n+    public final float[] toArray(ValueLayout.OfFloat elementLayout) {\n+        return toArray(float[].class, elementLayout, float[]::new, MemorySegment::ofArray);\n@@ -318,2 +332,2 @@\n-    public final long[] toLongArray() {\n-        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);\n+    public final long[] toArray(ValueLayout.OfLong elementLayout) {\n+        return toArray(long[].class, elementLayout, long[]::new, MemorySegment::ofArray);\n@@ -323,2 +337,2 @@\n-    public final double[] toDoubleArray() {\n-        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);\n+    public final double[] toArray(ValueLayout.OfDouble elementLayout) {\n+        return toArray(double[].class, elementLayout, double[]::new, MemorySegment::ofArray);\n@@ -327,2 +341,2 @@\n-    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n-        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);\n+    private <Z> Z toArray(Class<Z> arrayClass, ValueLayout elemLayout, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n+        int size = checkArraySize(arrayClass.getSimpleName(), (int)elemLayout.byteSize());\n@@ -331,1 +345,1 @@\n-        arrSegment.copyFrom(this);\n+        MemorySegment.copy(this, elemLayout, 0, arrSegment, elemLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n@@ -385,2 +399,2 @@\n-                offset < Integer.MAX_VALUE && length < Integer.MAX_VALUE &&\n-                offset > Integer.MIN_VALUE && length > Integer.MIN_VALUE) {\n+                offset <= Integer.MAX_VALUE && length <= Integer.MAX_VALUE &&\n+                offset >= Integer.MIN_VALUE && length >= Integer.MIN_VALUE) {\n@@ -388,2 +402,3 @@\n-        } else {\n-            if (length < 0 ||\n+        } else if (this != NativeMemorySegmentImpl.EVERYTHING) { \/\/ oob not possible for everything segment\n+            if (\n+                    length < 0 ||\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":61,"deletions":46,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public abstract class ArenaAllocator implements SegmentAllocator {\n+public final class ArenaAllocator implements SegmentAllocator {\n@@ -34,1 +34,1 @@\n-    protected MemorySegment segment;\n+    public static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n@@ -36,1 +36,1 @@\n-    protected long sp = 0L;\n+    private MemorySegment segment;\n@@ -38,2 +38,11 @@\n-    ArenaAllocator(MemorySegment segment) {\n-        this.segment = segment;\n+    private long sp = 0L;\n+    private long size = 0;\n+    private final long blockSize;\n+    private final long arenaSize;\n+    private final ResourceScope scope;\n+\n+    public ArenaAllocator(long blockSize, long arenaSize, ResourceScope scope) {\n+        this.blockSize = blockSize;\n+        this.arenaSize = arenaSize;\n+        this.scope = scope;\n+        this.segment = newSegment(blockSize, 1);\n@@ -54,5 +63,2 @@\n-    void checkConfinementIfNeeded() {\n-        Thread ownerThread = scope().ownerThread();\n-        if (ownerThread != null && ownerThread != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempt to allocate outside confinement thread\");\n-        }\n+    public ResourceScope scope() {\n+        return scope;\n@@ -61,35 +67,4 @@\n-    ResourceScope scope() {\n-        return segment.scope();\n-    }\n-\n-    public static class UnboundedArenaAllocator extends ArenaAllocator {\n-\n-        private static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n-\n-        public UnboundedArenaAllocator(ResourceScope scope) {\n-            super(MemorySegment.allocateNative(DEFAULT_BLOCK_SIZE, 1, scope));\n-        }\n-\n-        private MemorySegment newSegment(long size, long align) {\n-            return MemorySegment.allocateNative(size, align, segment.scope());\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkConfinementIfNeeded();\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice != null) {\n-                return slice;\n-            } else {\n-                long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n-                if (maxPossibleAllocationSize > DEFAULT_BLOCK_SIZE) {\n-                    \/\/ too big\n-                    return newSegment(bytesSize, bytesAlignment);\n-                } else {\n-                    \/\/ allocate a new segment and slice from there\n-                    sp = 0L;\n-                    segment = newSegment(DEFAULT_BLOCK_SIZE, 1L);\n-                    return trySlice(bytesSize, bytesAlignment);\n-                }\n-            }\n+    private MemorySegment newSegment(long bytesSize, long bytesAlignment) {\n+        long allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+        if (size + allocatedSize > arenaSize) {\n+            throw new OutOfMemoryError();\n@@ -97,0 +72,2 @@\n+        size += allocatedSize;\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, scope);\n@@ -99,13 +76,11 @@\n-    public static class BoundedArenaAllocator extends ArenaAllocator {\n-\n-        public BoundedArenaAllocator(ResourceScope scope, long size) {\n-            super(MemorySegment.allocateNative(size, 1, scope));\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkConfinementIfNeeded();\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice != null) {\n-                return slice;\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        \/\/ try to slice from current segment first...\n+        MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+        if (slice != null) {\n+            return slice;\n+        } else {\n+            long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+            if (maxPossibleAllocationSize > blockSize) {\n+                \/\/ too big\n+                return newSegment(bytesSize, bytesAlignment);\n@@ -113,24 +88,5 @@\n-                throw new OutOfMemoryError(\"Not enough space left to allocate\");\n-            }\n-        }\n-    }\n-\n-    public static class BoundedSharedArenaAllocator extends BoundedArenaAllocator {\n-        public BoundedSharedArenaAllocator(ResourceScope scope, long size) {\n-            super(scope, size);\n-        }\n-\n-        @Override\n-        public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            return super.allocate(bytesSize, bytesAlignment);\n-        }\n-    }\n-\n-    public static class UnboundedSharedArenaAllocator implements SegmentAllocator {\n-\n-        final ResourceScope scope;\n-\n-        final ThreadLocal<ArenaAllocator> allocators = new ThreadLocal<>() {\n-            @Override\n-            protected ArenaAllocator initialValue() {\n-                return new UnboundedArenaAllocator(scope);\n+                \/\/ allocate a new segment and slice from there\n+                sp = 0L;\n+                segment = newSegment(blockSize, 1L);\n+                slice = trySlice(bytesSize, bytesAlignment);\n+                return slice;\n@@ -138,9 +94,0 @@\n-        };\n-\n-        public UnboundedSharedArenaAllocator(ResourceScope scope) {\n-            this.scope = scope;\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            return allocators.get().allocate(bytesSize, bytesAlignment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":38,"deletions":91,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import sun.security.action.GetPropertyAction;\n-\n-import static jdk.incubator.foreign.MemoryLayouts.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -31,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -32,1 +33,0 @@\n-import java.lang.ref.Reference;\n@@ -44,0 +44,1 @@\n+    private int asyncReleaseCount = 0;\n@@ -46,0 +47,10 @@\n+    static final VarHandle ASYNC_RELEASE_COUNT;\n+\n+    static {\n+        try {\n+            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedScope.class, \"asyncReleaseCount\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -47,1 +58,1 @@\n-        super(cleaner, new ConfinedResourceList());\n+        super(new ConfinedResourceList(), cleaner);\n@@ -67,1 +78,2 @@\n-    public HandleImpl acquire() {\n+    @ForceInline\n+    public void acquire0() {\n@@ -69,0 +81,3 @@\n+        if (lockCount == MAX_FORKS) {\n+            throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n+        }\n@@ -70,1 +85,14 @@\n-        return new ConfinedHandle();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        if (Thread.currentThread() == owner) {\n+            lockCount--;\n+        } else {\n+            \/\/ It is possible to end up here in two cases: this scope was kept alive by some other confined scope\n+            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n+            \/\/ this scope might be kept alive by a shared scope, which means the release call can come from any\n+            \/\/ thread.\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n+        }\n@@ -75,1 +103,1 @@\n-        if (lockCount == 0) {\n+        if (lockCount == 0 || lockCount - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n@@ -78,1 +106,1 @@\n-            throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + lockCount + \" scopes\");\n@@ -112,21 +140,0 @@\n-\n-    \/**\n-     * A confined resource scope handle; no races are possible here.\n-     *\/\n-    final class ConfinedHandle implements HandleImpl {\n-        boolean released = false;\n-\n-        @Override\n-        public ResourceScopeImpl scope() {\n-            return ConfinedScope.this;\n-        }\n-\n-        @Override\n-        public void release() {\n-            checkValidState(); \/\/ thread check\n-            if (!released) {\n-                released = true;\n-                lockCount--;\n-            }\n-        }\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -56,1 +54,1 @@\n- * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle(Class)}).\n+ * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle()}).\n@@ -60,2 +58,0 @@\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -159,2 +155,4 @@\n-    public VarHandle dereferenceHandle(Class<?> carrier) {\n-        Utils.checkPrimitiveCarrierCompat(carrier, layout);\n+    public VarHandle dereferenceHandle() {\n+        if (!(layout instanceof ValueLayout valueLayout)) {\n+            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+        }\n@@ -168,2 +166,1 @@\n-        VarHandle handle = Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n-                ((ValueLayout)layout).order()));\n+        VarHandle handle = Utils.makeMemoryAccessVarHandle(valueLayout, true);\n@@ -229,2 +226,1 @@\n-        } else if (enclosing.layout instanceof SequenceLayout) {\n-            SequenceLayout seq = (SequenceLayout)enclosing.layout;\n+        } else if (enclosing.layout instanceof SequenceLayout seq) {\n@@ -236,2 +232,1 @@\n-        } else if (enclosing.layout instanceof GroupLayout) {\n-            GroupLayout g = (GroupLayout)enclosing.layout;\n+        } else if (enclosing.layout instanceof GroupLayout g) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -30,0 +31,3 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,2 +37,1 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import java.util.Objects;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -40,1 +43,1 @@\n-public final class MemoryAddressImpl implements MemoryAddress {\n+public final class MemoryAddressImpl implements MemoryAddress, Scoped {\n@@ -42,1 +45,0 @@\n-    private final AbstractMemorySegmentImpl segment;\n@@ -45,2 +47,1 @@\n-    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {\n-        this.segment = segment;\n+    public MemoryAddressImpl(long offset) {\n@@ -50,2 +51,5 @@\n-    Object base() {\n-        return segment != null ? segment.base() : null;\n+    \/\/ MemoryAddress methods\n+\n+    @Override\n+    public MemoryAddress addOffset(long offset) {\n+        return new MemoryAddressImpl(this.offset + offset);\n@@ -54,3 +58,3 @@\n-    long offset() {\n-        return segment != null ?\n-                segment.min() + offset : offset;\n+    @Override\n+    public long toRawLongValue() {\n+        return offset;\n@@ -59,1 +63,34 @@\n-    \/\/ MemoryAddress methods\n+    @Override\n+    public final MemoryAddress address() {\n+        return this;\n+    }\n+\n+    \/\/ Object methods\n+\n+    @Override\n+    public int hashCode() {\n+        return (int) toRawLongValue();\n+    }\n+\n+    @Override\n+    public boolean equals(Object that) {\n+        return (that instanceof MemoryAddressImpl addressImpl &&\n+            offset == addressImpl.offset);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MemoryAddress{ offset=0x\" + Long.toHexString(offset) + \" }\";\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value) {\n+        return ofLongUnchecked(value, Long.MAX_VALUE);\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, resourceScope);\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, ResourceScopeImpl.GLOBAL);\n+    }\n@@ -63,2 +100,1 @@\n-        return segment != null ?\n-                segment.scope() : ResourceScope.globalScope();\n+        return ResourceScopeImpl.GLOBAL;\n@@ -68,2 +104,6 @@\n-    public MemoryAddress addOffset(long offset) {\n-        return new MemoryAddressImpl(segment, this.offset + offset);\n+    @CallerSensitive\n+    @ForceInline\n+    public String getUtf8String(long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkAddress(this);\n+        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n@@ -73,7 +113,6 @@\n-    public long segmentOffset(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;\n-        if (segmentImpl.base() != base()) {\n-            throw new IllegalArgumentException(\"Incompatible segment: \" + segment);\n-        }\n-        return offset() - segmentImpl.min();\n+    @CallerSensitive\n+    @ForceInline\n+    public void setUtf8String(long offset, String str) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkAddress(this);\n+        NativeMemorySegmentImpl.EVERYTHING.setUtf8String(toRawLongValue() + offset, str);\n@@ -83,2 +122,5 @@\n-    public boolean isNative() {\n-        return base() == null;\n+    @ForceInline\n+    @CallerSensitive\n+    public byte get(ValueLayout.OfByte layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -88,8 +130,5 @@\n-    public long toRawLongValue() {\n-        if (segment != null) {\n-            if (segment.base() != null) {\n-                throw new UnsupportedOperationException(\"Not a native address\");\n-            }\n-            segment.checkValidState();\n-        }\n-        return offset();\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -98,1 +137,7 @@\n-    \/\/ Object methods\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n@@ -101,2 +146,5 @@\n-    public int hashCode() {\n-        return Objects.hash(base(), offset());\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -106,8 +154,5 @@\n-    public boolean equals(Object that) {\n-        if (that instanceof MemoryAddressImpl) {\n-            MemoryAddressImpl addr = (MemoryAddressImpl)that;\n-            return Objects.equals(base(), addr.base()) &&\n-                    offset() == addr.offset();\n-        } else {\n-            return false;\n-        }\n+    @ForceInline\n+    @CallerSensitive\n+    public char get(ValueLayout.OfChar layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -117,2 +162,5 @@\n-    public String toString() {\n-        return \"MemoryAddress{ base: \" + base() + \" offset=0x\" + Long.toHexString(offset()) + \" }\";\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfChar layout, long offset, char value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -122,0 +170,1 @@\n+    @ForceInline\n@@ -123,1 +172,1 @@\n-    public final MemorySegment asSegment(long bytesSize, ResourceScope scope) {\n+    public short get(ValueLayout.OfShort layout, long offset) {\n@@ -125,1 +174,1 @@\n-        return asSegment(bytesSize, null, scope);\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -129,0 +178,1 @@\n+    @ForceInline\n@@ -130,1 +180,1 @@\n-    public final MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n+    public void set(ValueLayout.OfShort layout, long offset, short value) {\n@@ -132,7 +182,1 @@\n-        Objects.requireNonNull(scope);\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize,\n-                cleanupAction,\n-                (ResourceScopeImpl) scope);\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -141,2 +185,6 @@\n-    public static MemorySegment ofLongUnchecked(long value) {\n-        return ofLongUnchecked(value, Long.MAX_VALUE);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public int get(ValueLayout.OfInt layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -145,2 +193,6 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, resourceScope);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfInt layout, long offset, int value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -149,2 +201,174 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, ResourceScopeImpl.GLOBAL);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public float get(ValueLayout.OfFloat layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public long get(ValueLayout.OfLong layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfLong layout, long offset, long value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public double get(ValueLayout.OfDouble layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value.address());\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value.address());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":286,"deletions":62,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -46,1 +44,1 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null, ResourceScopeImpl.GLOBAL);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, ResourceScopeImpl.GLOBAL);\n@@ -50,2 +48,0 @@\n-    public static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n-\n@@ -66,0 +62,7 @@\n+    @ForceInline\n+    @Override\n+    public MemoryAddress address() {\n+        checkValidState();\n+        return MemoryAddress.ofLong(unsafeGetOffset());\n+    }\n+\n@@ -126,1 +129,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, ResourceScopeImpl scope) {\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, ResourceScopeImpl scope) {\n@@ -129,3 +132,0 @@\n-        if (cleanupAction != null) {\n-            scope.addCloseAction(cleanupAction);\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n+    @Override\n+    public MemoryAddress address() {\n+        ((ResourceScopeImpl)scope).checkValidState();\n+        return address;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,4 +31,0 @@\n-import java.nio.ByteOrder;\n-\n-import static java.nio.ByteOrder.LITTLE_ENDIAN;\n-\n@@ -45,53 +40,0 @@\n-    public static MemoryLayout asVarArg(MemoryLayout ml) {\n-        return switch (CABI.current()) {\n-            case Win64 -> Win64.asVarArg(ml);\n-            case MacOsAArch64 -> AArch64.asVarArg(ml);\n-            default -> ml;\n-        };\n-    }\n-\n-    private static ValueLayout ofChar(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.CHAR);\n-    }\n-\n-    private static ValueLayout ofShort(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.SHORT);\n-    }\n-\n-    private static ValueLayout ofInt(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.INT);\n-    }\n-\n-    private static ValueLayout ofLong(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG);\n-    }\n-\n-    private static ValueLayout ofLongLong(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG_LONG);\n-    }\n-\n-    private static ValueLayout ofFloat(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.FLOAT);\n-    }\n-\n-    private static ValueLayout ofDouble(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.DOUBLE);\n-    }\n-\n-    private static ValueLayout ofPointer(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.POINTER);\n-    }\n-\n-    public static CLinker.TypeKind getKind(MemoryLayout layout) {\n-        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-            () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-    }\n-\n@@ -106,0 +48,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n@@ -109,1 +56,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -114,1 +61,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -119,1 +66,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -124,1 +71,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -129,1 +76,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -134,1 +81,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -139,1 +86,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -144,1 +91,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -149,1 +96,1 @@\n-        public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;\n+        public static final ValueLayout.OfAddress C_VA_LIST = SysV.C_POINTER;\n@@ -162,2 +109,1 @@\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()}) used to mark variadic parameters. The\n-         * attribute value must be a boolean.\n+         * The {@code bool} native type.\n@@ -165,1 +111,1 @@\n-        public static final String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n@@ -170,1 +116,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -175,1 +121,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -180,1 +126,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -184,1 +130,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -189,1 +135,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -194,1 +140,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -199,1 +145,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -204,1 +150,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -209,11 +155,1 @@\n-        public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be passed to a function.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},\n-         * which is set to {@code true}.\n-         *\/\n-        public static MemoryLayout asVarArg(MemoryLayout layout) {\n-            return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);\n-        }\n+        public static final ValueLayout.OfAddress C_VA_LIST = Win64.C_POINTER;\n@@ -231,0 +167,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n@@ -234,1 +175,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -239,1 +180,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -244,1 +185,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -249,1 +190,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -254,1 +195,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -259,1 +200,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -264,1 +205,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -269,1 +210,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -274,21 +215,1 @@\n-        public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()})\n-         * used to mark variadic parameters on systems such as macOS which pass these\n-         * entirely on the stack. The attribute value must be a boolean.\n-         *\/\n-        public final static String STACK_VARARGS_ATTRIBUTE_NAME = \"abi\/aarch64\/stack_varargs\";\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be\n-         * passed to a function. This is only required on platforms such as macOS\n-         * which pass variadic parameters entirely on the stack.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for\n-         * the extra attribute {@link #STACK_VARARGS_ATTRIBUTE_NAME}, which is set\n-         * to {@code true}.\n-         *\/\n-        public static MemoryLayout asVarArg(MemoryLayout layout) {\n-            return layout.withAttribute(STACK_VARARGS_ATTRIBUTE_NAME, true);\n-        }\n+        public static final ValueLayout.OfAddress C_VA_LIST = AArch64.C_POINTER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":39,"deletions":118,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -52,1 +52,1 @@\n-public abstract non-sealed class ResourceScopeImpl implements ResourceScope, ScopedMemoryAccess.Scope, SegmentAllocator {\n+public abstract non-sealed class ResourceScopeImpl implements ResourceScope, SegmentAllocator, ScopedMemoryAccess.Scope {\n@@ -55,0 +55,3 @@\n+    final Cleaner.Cleanable cleanable;\n+\n+    static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -62,5 +65,0 @@\n-    @Override\n-    public boolean isImplicit() {\n-        return false;\n-    }\n-\n@@ -94,1 +92,1 @@\n-    protected ResourceScopeImpl(Cleaner cleaner, ResourceList resourceList) {\n+    protected ResourceScopeImpl(ResourceList resourceList, Cleaner cleaner) {\n@@ -96,7 +94,2 @@\n-        if (cleaner != null) {\n-            cleaner.register(this, resourceList);\n-        }\n-    }\n-\n-    public static ResourceScopeImpl createImplicitScope() {\n-        return new ImplicitScopeImpl(CleanerFactory.cleaner());\n+        cleanable = (cleaner != null) ?\n+            cleaner.register(this, resourceList) : null;\n@@ -109,13 +102,0 @@\n-    \/**\n-     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n-     * is assumed to be confined on the current thread.\n-     * @return a confined memory scope\n-     *\/\n-    public static ResourceScopeImpl createConfined(Cleaner cleaner) {\n-        return new ConfinedScope(Thread.currentThread(), cleaner);\n-    }\n-\n-    \/**\n-     * Creates a shared memory scope with given attachment and cleanup action.\n-     * @return a shared memory scope\n-     *\/\n@@ -126,12 +106,0 @@\n-    private final void release0(HandleImpl handle) {\n-        try {\n-            Objects.requireNonNull(handle);\n-            if (handle.scope() != this) {\n-                throw new IllegalArgumentException(\"Cannot release an handle acquired from another scope\");\n-            }\n-            handle.release();\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n@@ -139,2 +107,2 @@\n-    public final void release(ResourceScope.Handle handle) {\n-        release0((HandleImpl)handle);\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n@@ -143,4 +111,1 @@\n-    @Override\n-    public final void release(ScopedMemoryAccess.Scope.Handle handle) {\n-        release0((HandleImpl)handle);\n-    }\n+    public abstract void release0();\n@@ -148,2 +113,1 @@\n-    @Override\n-    public abstract HandleImpl acquire();\n+    public abstract void acquire0();\n@@ -151,9 +115,9 @@\n-    \/**\n-     * Internal interface used to implement resource scope handles.\n-     *\/\n-    public non-sealed interface HandleImpl extends ResourceScope.Handle, ScopedMemoryAccess.Scope.Handle {\n-\n-        @Override\n-        ResourceScopeImpl scope();\n-\n-        void release();\n+    @Override\n+    public void keepAlive(ResourceScope target) {\n+        Objects.requireNonNull(target);\n+        if (target == this) {\n+            throw new IllegalArgumentException(\"Invalid target scope.\");\n+        }\n+        ResourceScopeImpl targetImpl = (ResourceScopeImpl)target;\n+        targetImpl.acquire0();\n+        addCloseAction(targetImpl::release0);\n@@ -170,1 +134,5 @@\n-            resourceList.cleanup();\n+            if (cleanable != null) {\n+                cleanable.clean();\n+            } else {\n+                resourceList.cleanup();\n+            }\n@@ -218,11 +186,3 @@\n-     * Allocates a segment using this scope. Used by {@link SegmentAllocator#ofScope(ResourceScope)}.\n-     *\/\n-    @Override\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n-    }\n-\n-    \/**\n-     * A non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n-     * In addition, non-closeable scopes feature a much simpler scheme for generating resource scope handles, where\n-     * the scope itself also acts as a resource scope handle and is returned by {@link #acquire()}.\n+     * The global, always alive, non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n+     * Adding new resources to the global scope, does nothing: as the scope can never become not-alive, there is nothing to track.\n+     * Acquiring and or releasing a resource scope similarly does nothing.\n@@ -230,1 +190,1 @@\n-    static class ImplicitScopeImpl extends SharedScope implements HandleImpl {\n+    static class GlobalScopeImpl extends SharedScope {\n@@ -232,3 +192,1 @@\n-        public ImplicitScopeImpl(Cleaner cleaner) {\n-            super(cleaner);\n-        }\n+        final Object ref;\n@@ -236,8 +194,3 @@\n-        @Override\n-        public HandleImpl acquire() {\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean isImplicit() {\n-            return true;\n+        public GlobalScopeImpl(Object ref) {\n+            super(null);\n+            this.ref = ref;\n@@ -252,1 +205,2 @@\n-        public void release() {\n+        @ForceInline\n+        public void release0() {\n@@ -257,2 +211,3 @@\n-        public ResourceScopeImpl scope() {\n-            return this;\n+        @ForceInline\n+        public void acquire0() {\n+            \/\/ do nothing\n@@ -260,1 +215,0 @@\n-    }\n@@ -262,6 +216,0 @@\n-    \/**\n-     * The global, always alive, non-closeable, shared scope. This is like a {@link ImplicitScopeImpl non-closeable scope},\n-     * except that the operation which adds new resources to the global scope does nothing: as the scope can never\n-     * become not-alive, there is nothing to track.\n-     *\/\n-    public static final ResourceScopeImpl GLOBAL = new ImplicitScopeImpl( null) {\n@@ -272,1 +220,7 @@\n-    };\n+    }\n+\n+    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl(null);\n+\n+    public static ResourceScopeImpl heapScope(Object ref) {\n+        return new GlobalScopeImpl(ref);\n+    }\n@@ -299,1 +253,1 @@\n-        public static abstract class ResourceCleanup {\n+        public abstract static class ResourceCleanup {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":47,"deletions":93,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public interface Scoped {\n+    ResourceScope scope();\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -30,0 +29,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -34,2 +34,0 @@\n-import java.lang.ref.Reference;\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -53,1 +51,0 @@\n-    private static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -68,1 +65,1 @@\n-        super(cleaner, new SharedResourceList());\n+        super(new SharedResourceList(), cleaner);\n@@ -84,1 +81,2 @@\n-    public HandleImpl acquire() {\n+    @ForceInline\n+    public void acquire0() {\n@@ -93,1 +91,1 @@\n-                throw new IllegalStateException(\"Segment acquire limit exceeded\");\n+                throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n@@ -96,1 +94,13 @@\n-        return new SharedHandle();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value <= ALIVE) {\n+                \/\/cannot get here - we can't close segment twice\n+                throw new IllegalStateException(\"Already closed\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value - 1));\n@@ -104,1 +114,1 @@\n-            throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + prevState + \" scopes\");\n@@ -136,4 +146,2 @@\n-                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n-                cleanup.next = prev;\n-                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n-                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n+                if (prev == ResourceCleanup.CLOSED_LIST) {\n@@ -142,1 +150,3 @@\n-                } else if (newSegment == prev) {\n+                }\n+                cleanup.next = prev;\n+                if (FST.compareAndSet(this, prev, cleanup)) {\n@@ -158,1 +168,1 @@\n-                    prev = (ResourceCleanup) FST.getAcquire(this);\n+                    prev = (ResourceCleanup) FST.getVolatile(this);\n@@ -160,1 +170,1 @@\n-                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n@@ -170,26 +180,0 @@\n-\n-    \/**\n-     * A shared resource scope handle; this implementation has to handle close vs. close races.\n-     *\/\n-    class SharedHandle implements HandleImpl {\n-        final AtomicBoolean released = new AtomicBoolean(false);\n-\n-        @Override\n-        public ResourceScopeImpl scope() {\n-            return SharedScope.this;\n-        }\n-\n-        @Override\n-        public void release() {\n-            if (released.compareAndSet(false, true)) {\n-                int value;\n-                do {\n-                    value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n-                    if (value <= ALIVE) {\n-                        \/\/cannot get here - we can't close segment twice\n-                        throw new IllegalStateException(\"Already closed\");\n-                    }\n-                } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n-            }\n-        }\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":26,"deletions":42,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -42,1 +42,1 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -48,1 +48,1 @@\n-    final static SystemLookup INSTANCE = new SystemLookup();\n+    static final SystemLookup INSTANCE = new SystemLookup();\n@@ -74,2 +74,2 @@\n-            MemorySegment funcs = fallbackLibLookup.lookup(\"funcs\").orElseThrow()\n-                .asSegment(C_POINTER.byteSize() * numSymbols, ResourceScope.newImplicitScope());\n+            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n+                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n@@ -78,1 +78,1 @@\n-                .map(symbol -> MemoryAccess.getAddressAtIndex(funcs, symbol.ordinal()));\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n@@ -94,1 +94,2 @@\n-                        Optional.empty() : Optional.of(MemoryAddress.ofLong(addr));\n+                        Optional.empty() :\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n@@ -102,1 +103,1 @@\n-    public Optional<MemoryAddress> lookup(String name) {\n+    public Optional<NativeSymbol> lookup(String name) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -31,2 +32,1 @@\n-import jdk.internal.misc.VM;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -38,1 +38,2 @@\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -41,0 +42,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -52,0 +54,4 @@\n+    private static final MethodHandle BYTE_TO_BOOL;\n+    private static final MethodHandle BOOL_TO_BYTE;\n+    private static final MethodHandle ADDRESS_TO_LONG;\n+    private static final MethodHandle LONG_TO_ADDRESS;\n@@ -62,0 +68,8 @@\n+            BYTE_TO_BOOL = lookup.findStatic(Utils.class, \"byteToBoolean\",\n+                    MethodType.methodType(boolean.class, byte.class));\n+            BOOL_TO_BYTE = lookup.findStatic(Utils.class, \"booleanToByte\",\n+                    MethodType.methodType(byte.class, boolean.class));\n+            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    MethodType.methodType(long.class));\n+            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n+                    MethodType.methodType(MemoryAddress.class, long.class));\n@@ -94,1 +108,24 @@\n-    public static VarHandle fixUpVarHandle(VarHandle handle) {\n+    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout, boolean skipAlignmentCheck) {\n+        class VarHandleCache {\n+            private static final Map<ValueLayout, VarHandle> handleMap = new ConcurrentHashMap<>();\n+            private static final Map<ValueLayout, VarHandle> handleMapNoAlignCheck = new ConcurrentHashMap<>();\n+\n+            static VarHandle put(ValueLayout layout, VarHandle handle, boolean skipAlignmentCheck) {\n+                VarHandle prev = (skipAlignmentCheck ? handleMapNoAlignCheck : handleMap).putIfAbsent(layout, handle);\n+                return prev != null ? prev : handle;\n+            }\n+        }\n+        Class<?> baseCarrier = layout.carrier();\n+        if (layout.carrier() == MemoryAddress.class) {\n+            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+                case 8 -> long.class;\n+                case 4 -> int.class;\n+                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n+            };\n+        } else if (layout.carrier() == boolean.class) {\n+            baseCarrier = byte.class;\n+        }\n+\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck,\n+                layout.byteAlignment() - 1, layout.order());\n+\n@@ -97,1 +134,1 @@\n-        return SHOULD_ADAPT_HANDLES\n+        handle = SHOULD_ADAPT_HANDLES\n@@ -100,0 +137,8 @@\n+        if (layout.carrier() == boolean.class) {\n+            handle = MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n+        } else if (layout.carrier() == MemoryAddress.class) {\n+            handle = MemoryHandles.filterValue(handle,\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n+        }\n+        return VarHandleCache.put(layout, handle, skipAlignmentCheck);\n@@ -106,6 +151,12 @@\n-    public static void checkPrimitiveCarrierCompat(Class<?> carrier, MemoryLayout layout) {\n-        checkLayoutType(layout, ValueLayout.class);\n-        if (!isValidPrimitiveCarrier(carrier))\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier);\n-        if (Wrapper.forPrimitiveType(carrier).bitWidth() != layout.bitSize())\n-            throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier + \" != \" + layout);\n+    private static boolean byteToBoolean(byte b) {\n+        return b != 0;\n+    }\n+\n+    private static byte booleanToByte(boolean b) {\n+        return b ? (byte)1 : (byte)0;\n+    }\n+\n+    public static void copy(MemorySegment addr, byte[] bytes) {\n+        var heapSegment = MemorySegment.ofArray(bytes);\n+        addr.copyFrom(heapSegment);\n+        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n@@ -114,8 +165,4 @@\n-    public static boolean isValidPrimitiveCarrier(Class<?> carrier) {\n-        return carrier == byte.class\n-            || carrier == short.class\n-            || carrier == char.class\n-            || carrier == int.class\n-            || carrier == long.class\n-            || carrier == float.class\n-            || carrier == double.class;\n+    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n+        copy(addr, bytes);\n+        return addr;\n@@ -124,3 +171,4 @@\n-    public static void checkLayoutType(MemoryLayout layout, Class<? extends MemoryLayout> layoutType) {\n-        if (!layoutType.isInstance(layout))\n-            throw new IllegalArgumentException(\"Expected a \" + layoutType.getSimpleName() + \": \" + layout);\n+    @ForceInline\n+    public static long scaleOffset(MemorySegment segment, long index, long size) {\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return MemorySegmentProxy.multiplyOffsets(index, (int)size, (AbstractMemorySegmentImpl)segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":70,"deletions":22,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -33,0 +34,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +40,1 @@\n+import java.lang.invoke.MethodType;\n@@ -207,1 +210,0 @@\n-    private static final MethodHandle MH_BASE_ADDRESS;\n@@ -219,2 +221,0 @@\n-            MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, \"address\",\n-                    methodType(MemoryAddress.class));\n@@ -265,1 +265,1 @@\n-            return new Context(SegmentAllocator.arenaAllocator(size, scope), scope);\n+            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n@@ -324,1 +324,0 @@\n-        BASE_ADDRESS,\n@@ -347,1 +346,1 @@\n-        if (!type.isPrimitive() || type == void.class || type == boolean.class)\n+        if (!type.isPrimitive() || type == void.class)\n@@ -391,1 +390,1 @@\n-        return UnboxAddress.INSTANCE;\n+        return UnboxAddress.INSTANCE.get(MemoryAddress.class);\n@@ -394,2 +393,2 @@\n-    public static BaseAddress baseAddress() {\n-        return BaseAddress.INSTANCE;\n+    public static UnboxAddress unboxAddress(Class<?> carrier) {\n+        return UnboxAddress.INSTANCE.get(carrier);\n@@ -470,2 +469,2 @@\n-        public Binding.Builder baseAddress() {\n-            bindings.add(Binding.baseAddress());\n+        public Binding.Builder unboxAddress(Class<?> carrier) {\n+            bindings.add(Binding.unboxAddress(carrier));\n@@ -490,1 +489,1 @@\n-    static abstract class Move extends Binding {\n+    abstract static class Move extends Binding {\n@@ -596,1 +595,1 @@\n-    private static abstract class Dereference extends Binding {\n+    private abstract static class Dereference extends Binding {\n@@ -633,1 +632,2 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, 1, ByteOrder.nativeOrder()), 1, offset);\n+            ValueLayout layout = MemoryLayout.valueLayout(type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, offset);\n@@ -743,3 +743,2 @@\n-            MemorySegment copy = context.allocator().allocate(size, alignment);\n-            copy.copyFrom(operand.asSlice(0, size));\n-            return copy;\n+            return context.allocator().allocate(size, alignment)\n+                            .copyFrom(operand.asSlice(0, size));\n@@ -878,2 +877,12 @@\n-        private static final UnboxAddress INSTANCE = new UnboxAddress();\n-        private UnboxAddress() {\n+\n+        static final ClassValue<UnboxAddress> INSTANCE = new ClassValue<>() {\n+            @Override\n+            protected UnboxAddress computeValue(Class<?> type) {\n+                return new UnboxAddress(type);\n+            }\n+        };\n+\n+        final Class<?> carrier;\n+        final MethodHandle toAddress;\n+\n+        private UnboxAddress(Class<?> carrier) {\n@@ -881,0 +890,6 @@\n+            this.carrier = carrier;\n+            try {\n+                this.toAddress = MethodHandles.lookup().findVirtual(carrier, \"address\", MethodType.methodType(MemoryAddress.class));\n+            } catch (Throwable ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n@@ -886,1 +901,1 @@\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n+            SharedUtils.checkType(actualType, carrier);\n@@ -893,1 +908,1 @@\n-            stack.push(((MemoryAddress)stack.pop()).toRawLongValue());\n+            stack.push(((Addressable)stack.pop()).address().toRawLongValue());\n@@ -898,1 +913,2 @@\n-            return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);\n+            return filterArguments(specializedHandle, insertPos,\n+                    MethodHandles.filterReturnValue(toAddress, MH_UNBOX_ADDRESS));\n@@ -942,35 +958,0 @@\n-    \/**\n-     * BASE_ADDRESS()\n-     *   Pops a MemorySegment from the operand stack, and takes the base address of the segment\n-     *   (the MemoryAddress that points to the start), and pushes that onto the operand stack\n-     *\/\n-    public static class BaseAddress extends Binding {\n-        private static final BaseAddress INSTANCE = new BaseAddress();\n-        private BaseAddress() {\n-            super(Tag.BASE_ADDRESS);\n-        }\n-\n-        @Override\n-        public void verify(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemorySegment.class);\n-            stack.push(MemoryAddress.class);\n-        }\n-\n-        @Override\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment) stack.pop()).address());\n-        }\n-\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"BaseAddress{}\";\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":38,"deletions":57,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -37,1 +37,1 @@\n-    static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.stream.IntStream;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-        BASE_ADDRESS,\n@@ -132,1 +131,0 @@\n-        \/\/BASE_ADDRESS,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -43,1 +43,0 @@\n-import java.lang.ref.Reference;\n@@ -73,1 +72,1 @@\n-    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -90,1 +89,1 @@\n-                    methodType(Object.class, Addressable.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+                    methodType(Object.class, NativeSymbol.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n@@ -93,1 +92,1 @@\n-            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, NativeSymbol.class));\n@@ -175,3 +174,3 @@\n-    private static long unboxTargetAddress(Addressable addr) {\n-        MemoryAddress ma = SharedUtils.checkSymbol(addr);\n-        return ma.toRawLongValue();\n+    private static long unboxTargetAddress(NativeSymbol addr) {\n+        SharedUtils.checkSymbol(addr);\n+        return addr.address().toRawLongValue();\n@@ -315,1 +314,1 @@\n-    Object invokeInterpBindings(Addressable address, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(NativeSymbol symbol, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n@@ -324,1 +323,1 @@\n-            leafArgs[0] = address; \/\/ addr\n+            leafArgs[0] = symbol; \/\/ symbol\n@@ -329,1 +328,1 @@\n-                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip symbol\n@@ -335,4 +334,0 @@\n-            \/\/ make sure arguments are reachable during the call\n-            \/\/ technically we only need to do all Addressable parameters here\n-            Reference.reachabilityFence(address);\n-            Reference.reachabilityFence(args);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -49,0 +49,1 @@\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n@@ -72,1 +73,1 @@\n-    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -91,1 +92,1 @@\n-    public static UpcallHandler make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n+    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n@@ -137,1 +138,1 @@\n-        return () -> entryPoint;\n+        return UpcallStubs.makeUpcall(entryPoint, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -38,1 +38,1 @@\n-import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -41,0 +41,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n@@ -42,0 +43,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -44,0 +46,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -49,0 +52,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -55,1 +59,0 @@\n-import java.nio.charset.Charset;\n@@ -57,0 +60,1 @@\n+import java.util.ArrayList;\n@@ -62,0 +66,1 @@\n+import java.util.function.UnaryOperator;\n@@ -70,1 +75,1 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n@@ -76,1 +81,9 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -81,0 +94,1 @@\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n@@ -90,0 +104,2 @@\n+    private static final MethodHandle ACQUIRE_MH;\n+    private static final MethodHandle RELEASE_MH;\n@@ -110,0 +126,4 @@\n+            ACQUIRE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"acquire\",\n+                    MethodType.methodType(void.class, Scoped[].class));\n+            RELEASE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"release\",\n+                    MethodType.methodType(void.class, Scoped[].class));\n@@ -116,1 +136,3 @@\n-    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> { throw new IllegalStateException(\"Cannot get here\"); };\n+    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new IllegalStateException(\"Cannot get here\");\n+    };\n@@ -228,28 +250,0 @@\n-    public static void checkCompatibleType(Class<?> carrier, MemoryLayout layout, long addressSize) {\n-        if (carrier.isPrimitive()) {\n-            Utils.checkPrimitiveCarrierCompat(carrier, layout);\n-        } else if (carrier == MemoryAddress.class) {\n-            Utils.checkLayoutType(layout, ValueLayout.class);\n-            if (layout.bitSize() != addressSize)\n-                throw new IllegalArgumentException(\"Address size mismatch: \" + addressSize + \" != \" + layout.bitSize());\n-        } else if (carrier == MemorySegment.class) {\n-            Utils.checkLayoutType(layout, GroupLayout.class);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier);\n-        }\n-    }\n-\n-    public static void checkFunctionTypes(MethodType mt, FunctionDescriptor cDesc, long addressSize) {\n-        if (mt.returnType() == void.class != cDesc.returnLayout().isEmpty())\n-            throw new IllegalArgumentException(\"Return type mismatch: \" + mt + \" != \" + cDesc);\n-        List<MemoryLayout> argLayouts = cDesc.argumentLayouts();\n-        if (mt.parameterCount() != argLayouts.size())\n-            throw new IllegalArgumentException(\"Arity mismatch: \" + mt + \" != \" + cDesc);\n-\n-        int paramCount = mt.parameterCount();\n-        for (int i = 0; i < paramCount; i++) {\n-            checkCompatibleType(mt.parameterType(i), argLayouts.get(i), addressSize);\n-        }\n-        cDesc.returnLayout().ifPresent(rl -> checkCompatibleType(mt.returnType(), rl, addressSize));\n-    }\n-\n@@ -290,2 +284,1 @@\n-        MemorySegment.ofArray(bytes)\n-                .copyFrom(segment.asSlice(start, len));\n+        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n@@ -298,1 +291,1 @@\n-            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n@@ -395,1 +388,5 @@\n-            closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            if (!upcall) {\n+                closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            } else {\n+                closer = collectArguments(closer, 0, MH_HANDLE_UNCAUGHT_EXCEPTION); \/\/ (Throwable, V) -> V\n+            }\n@@ -399,1 +396,1 @@\n-        \/\/ downcalls get the leading Addressable\/SegmentAllocator param as well\n+        \/\/ downcalls get the leading NativeSymbol\/SegmentAllocator param as well\n@@ -401,2 +398,2 @@\n-            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(Addressable.class));\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n+            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(NativeSymbol.class));\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, NativeSymbol, SegmentAllocator) -> V\/void\n@@ -405,15 +402,1 @@\n-        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n-\n-        if (!upcall) {\n-            \/\/ now for each Addressable parameter, add a reachability fence\n-            MethodType specType = specializedHandle.type();\n-            \/\/ skip 3 for address, segment allocator, and binding context\n-            for (int i = 3; i < specType.parameterCount(); i++) {\n-                Class<?> param = specType.parameterType(i);\n-                if (Addressable.class.isAssignableFrom(param)) {\n-                    closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(param));\n-                } else {\n-                    closer = dropArguments(closer, insertPos++, param);\n-                }\n-            }\n-        }\n+        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, NativeSymbol?, BindingContext) -> V\/void\n@@ -437,0 +420,141 @@\n+    @ForceInline\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void acquire(Scoped[] args) {\n+        ResourceScope scope4 = null;\n+        ResourceScope scope3 = null;\n+        ResourceScope scope2 = null;\n+        ResourceScope scope1 = null;\n+        ResourceScope scope0 = null;\n+        switch (args.length) {\n+            default:\n+                \/\/ slow path, acquire all remaining addressable parameters in isolation\n+                for (int i = 5 ; i < args.length ; i++) {\n+                    acquire(args[i].scope());\n+                }\n+            \/\/ fast path, acquire only scopes not seen in other parameters\n+            case 5:\n+                scope4 = args[4].scope();\n+                acquire(scope4);\n+            case 4:\n+                scope3 = args[3].scope();\n+                if (scope3 != scope4)\n+                    acquire(scope3);\n+            case 3:\n+                scope2 = args[2].scope();\n+                if (scope2 != scope3 && scope2 != scope4)\n+                    acquire(scope2);\n+            case 2:\n+                scope1 = args[1].scope();\n+                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n+                    acquire(scope1);\n+            case 1:\n+                scope0 = args[0].scope();\n+                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n+                    acquire(scope0);\n+            case 0: break;\n+        }\n+    }\n+\n+    @ForceInline\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void release(Scoped[] args) {\n+        ResourceScope scope4 = null;\n+        ResourceScope scope3 = null;\n+        ResourceScope scope2 = null;\n+        ResourceScope scope1 = null;\n+        ResourceScope scope0 = null;\n+        switch (args.length) {\n+            default:\n+                \/\/ slow path, release all remaining addressable parameters in isolation\n+                for (int i = 5 ; i < args.length ; i++) {\n+                    release(args[i].scope());\n+                }\n+            \/\/ fast path, release only scopes not seen in other parameters\n+            case 5:\n+                scope4 = args[4].scope();\n+                release(scope4);\n+            case 4:\n+                scope3 = args[3].scope();\n+                if (scope3 != scope4)\n+                    release(scope3);\n+            case 3:\n+                scope2 = args[2].scope();\n+                if (scope2 != scope3 && scope2 != scope4)\n+                    release(scope2);\n+            case 2:\n+                scope1 = args[1].scope();\n+                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n+                    release(scope1);\n+            case 1:\n+                scope0 = args[0].scope();\n+                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n+                    release(scope0);\n+            case 0: break;\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void acquire(ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).acquire0();\n+    }\n+\n+    @ForceInline\n+    private static void release(ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).release0();\n+    }\n+\n+    \/*\n+     * This method adds a try\/finally block to a downcall method handle, to make sure that all by-reference\n+     * parameters (including the target address of the native function) are kept alive for the duration of\n+     * the downcall.\n+     *\/\n+    public static MethodHandle wrapDowncall(MethodHandle downcallHandle, FunctionDescriptor descriptor) {\n+        boolean hasReturn = descriptor.returnLayout().isPresent();\n+        MethodHandle tryBlock = downcallHandle;\n+        MethodHandle cleanup = hasReturn ?\n+                MethodHandles.identity(downcallHandle.type().returnType()) :\n+                MethodHandles.empty(MethodType.methodType(void.class));\n+        int addressableCount = 0;\n+        List<UnaryOperator<MethodHandle>> adapters = new ArrayList<>();\n+        for (int i = 0 ; i < downcallHandle.type().parameterCount() ; i++) {\n+            Class<?> ptype = downcallHandle.type().parameterType(i);\n+            if (ptype == Addressable.class || ptype == NativeSymbol.class) {\n+                addressableCount++;\n+            } else {\n+                int pos = i;\n+                adapters.add(mh -> dropArguments(mh, pos, ptype));\n+            }\n+        }\n+\n+        if (addressableCount > 0) {\n+            cleanup = dropArguments(cleanup, 0, Throwable.class);\n+\n+            MethodType adapterType = MethodType.methodType(void.class);\n+            for (int i = 0 ; i < addressableCount ; i++) {\n+                adapterType = adapterType.appendParameterTypes(i == 0 ? NativeSymbol.class : Addressable.class);\n+            }\n+\n+            MethodHandle acquireHandle = ACQUIRE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n+            MethodHandle releaseHandle = RELEASE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n+\n+            for (UnaryOperator<MethodHandle> adapter : adapters) {\n+                acquireHandle = adapter.apply(acquireHandle);\n+                releaseHandle = adapter.apply(releaseHandle);\n+            }\n+\n+            tryBlock = foldArguments(tryBlock, acquireHandle);\n+            cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, releaseHandle);\n+\n+            return tryFinally(tryBlock, cleanup);\n+        } else {\n+            return downcallHandle;\n+        }\n+    }\n+\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n@@ -442,3 +566,2 @@\n-        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n-                        MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"malloc\").get(),\n+                FunctionDescriptor.of(ADDRESS, JAVA_LONG));\n@@ -446,3 +569,2 @@\n-        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n-                        MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER));\n+        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"free\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS));\n@@ -451,2 +573,2 @@\n-    public static MemoryAddress checkSymbol(Addressable symbol) {\n-        return checkAddressable(symbol, \"Symbol is NULL\");\n+    public static void checkSymbol(NativeSymbol symbol) {\n+        checkAddressable(symbol, \"Symbol is NULL\");\n@@ -455,2 +577,2 @@\n-    public static MemoryAddress checkAddress(MemoryAddress address) {\n-        return checkAddressable(address, \"Address is NULL\");\n+    public static void checkAddress(MemoryAddress address) {\n+        checkAddressable(address, \"Address is NULL\");\n@@ -459,1 +581,1 @@\n-    private static MemoryAddress checkAddressable(Addressable symbol, String msg) {\n+    private static void checkAddressable(Addressable symbol, String msg) {\n@@ -461,4 +583,2 @@\n-        MemoryAddress symbolAddr = symbol.address();\n-        if (symbolAddr.equals(MemoryAddress.NULL))\n-            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbolAddr);\n-        return symbolAddr;\n+        if (symbol.address().toRawLongValue() == 0)\n+            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbol);\n@@ -477,1 +597,1 @@\n-            AllocHolder.MH_FREE.invokeExact(addr);\n+            AllocHolder.MH_FREE.invokeExact((Addressable)addr);\n@@ -492,6 +612,0 @@\n-    public static VarHandle vhPrimitiveOrAddress(Class<?> carrier, MemoryLayout layout) {\n-        return carrier == MemoryAddress.class\n-            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n-            : layout.varHandle(carrier);\n-    }\n-\n@@ -516,28 +630,0 @@\n-    public static MethodType convertVaListCarriers(MethodType mt, Class<?> carrier) {\n-        Class<?>[] params = new Class<?>[mt.parameterCount()];\n-        for (int i = 0; i < params.length; i++) {\n-            Class<?> pType = mt.parameterType(i);\n-            params[i] = ((pType == VaList.class) ? carrier : pType);\n-        }\n-        return methodType(mt.returnType(), params);\n-    }\n-\n-    public static MethodHandle unboxVaLists(MethodType type, MethodHandle handle, MethodHandle unboxer) {\n-        for (int i = 0; i < type.parameterCount(); i++) {\n-            if (type.parameterType(i) == VaList.class) {\n-               handle = filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n-            }\n-        }\n-        return handle;\n-    }\n-\n-    public static MethodHandle boxVaLists(MethodHandle handle, MethodHandle boxer) {\n-        MethodType type = handle.type();\n-        for (int i = 0; i < type.parameterCount(); i++) {\n-            if (type.parameterType(i) == VaList.class) {\n-               handle = filterArguments(handle, i, boxer);\n-            }\n-        }\n-        return handle;\n-    }\n-\n@@ -552,3 +638,6 @@\n-        return cDesc.attribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME)\n-                .map(Boolean.class::cast)\n-                .orElse(false);\n+        return false; \/\/ FIXME: use system property?\n+    }\n+\n+    public static boolean isVarargsIndex(FunctionDescriptor descriptor, int argIndex) {\n+        int firstPos = descriptor.firstVariadicArgumentIndex();\n+        return firstPos != -1 && argIndex >= firstPos;\n@@ -569,3 +658,1 @@\n-            return carrier == MemoryAddress.class\n-                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n-                : layout.varHandle(carrier);\n+            return layout.varHandle();\n@@ -575,1 +662,1 @@\n-    public static non-sealed class EmptyVaList implements VaList {\n+    public static non-sealed class EmptyVaList implements VaList, Scoped {\n@@ -588,6 +675,1 @@\n-        public int vargAsInt(MemoryLayout layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public long vargAsLong(MemoryLayout layout) {\n+        public int nextVarg(ValueLayout.OfInt layout) {\n@@ -598,1 +680,1 @@\n-        public double vargAsDouble(MemoryLayout layout) {\n+        public long nextVarg(ValueLayout.OfLong layout) {\n@@ -603,1 +685,1 @@\n-        public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+        public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -608,1 +690,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -613,1 +695,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -641,1 +723,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            ptr.set(JAVA_LONG, 0, (long) o);\n@@ -643,1 +725,1 @@\n-            MemoryAccess.setLong(ptr, (int) o);\n+            ptr.set(JAVA_LONG, 0, (int) o);\n@@ -645,1 +727,1 @@\n-            MemoryAccess.setLong(ptr, (short) o);\n+            ptr.set(JAVA_LONG, 0, (short) o);\n@@ -647,1 +729,1 @@\n-            MemoryAccess.setLong(ptr, (char) o);\n+            ptr.set(JAVA_LONG, 0, (char) o);\n@@ -649,1 +731,1 @@\n-            MemoryAccess.setLong(ptr, (byte) o);\n+            ptr.set(JAVA_LONG, 0, (byte) o);\n@@ -651,1 +733,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            ptr.set(JAVA_FLOAT, 0, (float) o);\n@@ -653,1 +735,3 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            ptr.set(JAVA_DOUBLE, 0, (double) o);\n+        } else if (type == boolean.class) {\n+            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n@@ -661,1 +745,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            ptr.set(JAVA_LONG, 0, (long) o);\n@@ -663,1 +747,1 @@\n-            MemoryAccess.setInt(ptr, (int) o);\n+            ptr.set(JAVA_INT, 0, (int) o);\n@@ -665,1 +749,1 @@\n-            MemoryAccess.setShort(ptr, (short) o);\n+            ptr.set(JAVA_SHORT, 0, (short) o);\n@@ -667,1 +751,1 @@\n-            MemoryAccess.setChar(ptr, (char) o);\n+            ptr.set(JAVA_CHAR, 0, (char) o);\n@@ -669,1 +753,1 @@\n-            MemoryAccess.setByte(ptr, (byte) o);\n+            ptr.set(JAVA_BYTE, 0, (byte) o);\n@@ -671,1 +755,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            ptr.set(JAVA_FLOAT, 0, (float) o);\n@@ -673,1 +757,3 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            ptr.set(JAVA_DOUBLE, 0, (double) o);\n+        } else if (type == boolean.class) {\n+            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n@@ -681,1 +767,1 @@\n-            return MemoryAccess.getLong(ptr);\n+            return ptr.get(JAVA_LONG, 0);\n@@ -683,1 +769,1 @@\n-            return MemoryAccess.getInt(ptr);\n+            return ptr.get(JAVA_INT, 0);\n@@ -685,1 +771,1 @@\n-            return MemoryAccess.getShort(ptr);\n+            return ptr.get(JAVA_SHORT, 0);\n@@ -687,1 +773,1 @@\n-            return MemoryAccess.getChar(ptr);\n+            return ptr.get(JAVA_CHAR, 0);\n@@ -689,1 +775,1 @@\n-            return MemoryAccess.getByte(ptr);\n+            return ptr.get(JAVA_BYTE, 0);\n@@ -691,1 +777,1 @@\n-            return MemoryAccess.getFloat(ptr);\n+            return ptr.get(JAVA_FLOAT, 0);\n@@ -693,1 +779,3 @@\n-            return MemoryAccess.getDouble(ptr);\n+            return ptr.get(JAVA_DOUBLE, 0);\n+        } else if (type == boolean.class) {\n+            return ptr.get(JAVA_BOOLEAN, 0);\n@@ -698,0 +786,20 @@\n+\n+    public static MethodType inferMethodType(FunctionDescriptor descriptor, boolean upcall) {\n+        MethodType type = MethodType.methodType(descriptor.returnLayout().isPresent() ?\n+                carrierFor(descriptor.returnLayout().get(), upcall) : void.class);\n+        for (MemoryLayout argLayout : descriptor.argumentLayouts()) {\n+            type = type.appendParameterTypes(carrierFor(argLayout, !upcall));\n+        }\n+        return type;\n+    }\n+\n+    static Class<?> carrierFor(MemoryLayout layout, boolean forArg) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return (forArg && valueLayout.carrier().equals(MemoryAddress.class)) ?\n+                    Addressable.class : valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":253,"deletions":145,"binary":false,"changes":398,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.internal.foreign.abi;\n-\n-public interface UpcallHandler {\n-    long entryPoint();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallHandler.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -28,1 +28,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.NativeSymbolImpl;\n@@ -30,1 +32,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -34,6 +35,0 @@\n-    public static MemoryAddress upcallAddress(UpcallHandler handler, ResourceScopeImpl scope) {\n-        long stubAddress = handler.entryPoint();\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0,\n-                () -> freeUpcallStub(stubAddress), scope).address();\n-    }\n-\n@@ -55,0 +50,10 @@\n+\n+    static NativeSymbol makeUpcall(long entry, ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                freeUpcallStub(entry);\n+            }\n+        });\n+        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), scope);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -35,1 +37,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -43,0 +44,2 @@\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64CallArranger;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64CallArranger;\n@@ -57,0 +60,4 @@\n+ *\n+ * There are minor differences between the ABIs implemented on Linux, macOS, and Windows\n+ * which are handled in sub-classes. Clients should access these through the provided\n+ * public constants CallArranger.LINUX and CallArranger.MACOS.\n@@ -58,1 +65,1 @@\n-public class CallArranger {\n+public abstract class CallArranger {\n@@ -98,2 +105,12 @@\n-    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64.C_POINTER.bitSize());\n+    public static final CallArranger LINUX = new LinuxAArch64CallArranger();\n+    public static final CallArranger MACOS = new MacOsAArch64CallArranger();\n+\n+    \/**\n+     * Are variadic arguments assigned to registers as in the standard calling\n+     * convention, or always passed on the stack?\n+     *\n+     * @returns true if variadic arguments should be spilled to the stack.\n+     *\/\n+    protected abstract boolean varArgsOnStack();\n+\n+    protected CallArranger() {}\n@@ -101,0 +118,1 @@\n+    public Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n@@ -119,0 +137,3 @@\n+            if (varArgsOnStack() && SharedUtils.isVarargsIndex(cDesc, i)) {\n+                argCalc.storageCalculator.adjustForVarArgs();\n+            }\n@@ -127,1 +148,1 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n+    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -139,1 +160,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -146,1 +167,1 @@\n-        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence,scope);\n@@ -211,8 +232,5 @@\n-        void adjustForVarArgs(MemoryLayout layout) {\n-            if (layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME)\n-                    .map(Boolean.class::cast).orElse(false)) {\n-                \/\/ This system passes all variadic parameters on the stack. Ensure\n-                \/\/ no further arguments are allocated to registers.\n-                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n-                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n-            }\n+        void adjustForVarArgs() {\n+            \/\/ This system passes all variadic parameters on the stack. Ensure\n+            \/\/ no further arguments are allocated to registers.\n+            nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n@@ -222,1 +240,1 @@\n-    static abstract class BindingCalculator {\n+    abstract static class BindingCalculator {\n@@ -291,1 +309,0 @@\n-            storageCalculator.adjustForVarArgs(layout);\n@@ -320,2 +337,1 @@\n-                            .baseAddress()\n-                            .unboxAddress();\n+                            .unboxAddress(MemorySegment.class);\n@@ -352,1 +368,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n@@ -394,1 +410,0 @@\n-            assert !layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME).isPresent() : \"no variadic upcalls\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":36,"deletions":21,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -32,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -45,5 +45,11 @@\n-        return switch (PlatformLayouts.getKind(type)) {\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n-            case POINTER -> POINTER;\n-            case FLOAT, DOUBLE -> FLOAT;\n-        };\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return FLOAT;\n+        } else if (carrier == MemoryAddress.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.linux;\n+\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for Linux ABI.\n+ *\/\n+public class LinuxAArch64CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        \/\/ Variadic arguments are passed as normal arguments\n+        return false;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -31,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -32,2 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -35,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -48,1 +48,1 @@\n-public final class LinuxAArch64Linker extends AbstractCLinker {\n+public final class LinuxAArch64Linker implements CLinker {\n@@ -53,15 +53,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(LinuxAArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -76,2 +61,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -79,2 +63,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, LinuxAArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n@@ -85,2 +69,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -90,1 +73,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -94,2 +77,6 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n@@ -35,2 +37,0 @@\n-import java.lang.ref.Cleaner;\n-import java.nio.ByteOrder;\n@@ -42,1 +42,1 @@\n-import static jdk.incubator.foreign.CLinker.VaList;\n+\n@@ -46,2 +46,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n-import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n@@ -54,1 +52,1 @@\n-public non-sealed class LinuxAArch64VaList implements VaList {\n+public non-sealed class LinuxAArch64VaList implements VaList, Scoped {\n@@ -79,1 +77,1 @@\n-        = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n+        = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n@@ -81,1 +79,1 @@\n-        = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n+        = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n@@ -94,6 +92,3 @@\n-    private static final VarHandle VH_stack\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__stack\")));\n-    private static final VarHandle VH_gr_top\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__gr_top\")));\n-    private static final VarHandle VH_vr_top\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__vr_top\")));\n+    private static final VarHandle VH_stack = LAYOUT.varHandle(groupElement(\"__stack\"));\n+    private static final VarHandle VH_gr_top = LAYOUT.varHandle(groupElement(\"__gr_top\"));\n+    private static final VarHandle VH_vr_top = LAYOUT.varHandle(groupElement(\"__vr_top\"));\n@@ -101,1 +96,1 @@\n-        = LAYOUT.varHandle(int.class, groupElement(\"__gr_offs\"));\n+        = LAYOUT.varHandle(groupElement(\"__gr_offs\"));\n@@ -103,1 +98,1 @@\n-        = LAYOUT.varHandle(int.class, groupElement(\"__vr_offs\"));\n+        = LAYOUT.varHandle(groupElement(\"__vr_offs\"));\n@@ -105,1 +100,0 @@\n-    private static final Cleaner cleaner = Cleaner.create();\n@@ -120,1 +114,1 @@\n-        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegment(\n+        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).addOffset(-MAX_GP_OFFSET),\n@@ -123,1 +117,1 @@\n-        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegment(\n+        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n@@ -130,3 +124,4 @@\n-        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegment(\n-                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n-        cleaner.register(LinuxAArch64VaList.class, () -> ms.scope().close());\n+        ResourceScope scope = ResourceScope.newImplicitScope();\n+        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment ms = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n+                LAYOUT.byteSize(), scope);\n@@ -218,1 +213,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -223,1 +218,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -228,1 +223,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -233,1 +228,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -238,1 +233,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -243,5 +238,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -254,2 +244,0 @@\n-        checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n-\n@@ -261,1 +249,1 @@\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n@@ -268,2 +256,2 @@\n-                    VarHandle reader = vhPrimitiveOrAddress(carrier, layout);\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    VarHandle reader = layout.varHandle();\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n@@ -283,2 +271,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n@@ -299,2 +286,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));\n+                        MemorySegment.copy(fpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -308,2 +294,1 @@\n-                    VarHandle ptrReader\n-                        = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);\n+                    VarHandle ptrReader = AArch64.C_POINTER.varHandle();\n@@ -314,1 +299,1 @@\n-                    MemorySegment slice = ptr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr, layout.byteSize(), scope());\n@@ -320,1 +305,1 @@\n-                    VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle();\n@@ -326,1 +311,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -338,0 +323,1 @@\n+        ((ResourceScopeImpl)segment.scope()).checkValidStateSlow();\n@@ -359,1 +345,1 @@\n-        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), scope));\n@@ -421,1 +407,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -426,1 +412,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -431,1 +417,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -436,1 +422,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -441,1 +427,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -448,2 +434,0 @@\n-            checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n-\n@@ -461,2 +445,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            gpRegs.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n@@ -476,2 +459,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            fpRegs.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, fpRegs, currentFPOffset, copy);\n@@ -485,3 +467,1 @@\n-                        VarHandle writer\n-                            = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class,\n-                                                               AArch64.C_POINTER);\n+                        VarHandle writer = AArch64.C_POINTER.varHandle();\n@@ -493,1 +473,1 @@\n-                        VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                        VarHandle writer = layout.varHandle();\n@@ -498,1 +478,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n@@ -516,1 +496,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":44,"deletions":64,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for macOS ABI.\n+ *\/\n+public class MacOsAArch64CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        \/\/ Variadic arguments are always passed on the stack\n+        return true;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -34,2 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -46,2 +44,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -52,1 +48,1 @@\n-public final class MacOsAArch64Linker extends AbstractCLinker {\n+public final class MacOsAArch64Linker implements CLinker {\n@@ -57,15 +53,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(MacOsAArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -80,2 +61,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -83,2 +63,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, MacOsAArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n@@ -89,2 +69,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -94,1 +73,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -98,2 +77,5 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.internal.foreign.Scoped;\n@@ -48,1 +48,1 @@\n-public non-sealed class MacOsAArch64VaList implements VaList {\n+public non-sealed class MacOsAArch64VaList implements VaList, Scoped {\n@@ -51,1 +51,1 @@\n-    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n@@ -68,1 +68,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -73,1 +73,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -78,1 +78,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -83,1 +83,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -88,1 +88,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -93,5 +93,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -104,1 +99,0 @@\n-        SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n@@ -111,1 +105,1 @@\n-                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), scope());\n@@ -118,2 +112,2 @@\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -126,1 +120,1 @@\n-            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            VarHandle reader = layout.varHandle();\n@@ -136,0 +130,1 @@\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n@@ -147,1 +142,1 @@\n-        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, scope);\n@@ -184,1 +179,0 @@\n-            SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n@@ -190,1 +184,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -195,1 +189,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -200,1 +194,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -205,1 +199,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -210,1 +204,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -219,1 +213,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -240,4 +234,3 @@\n-                        case STRUCT_REGISTER, STRUCT_HFA -> {\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n-                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -89,2 +90,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, SysVx64Linker.ADDRESS_SIZE);\n-\n@@ -137,1 +136,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -144,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence, scope);\n@@ -242,1 +241,1 @@\n-    static abstract class BindingCalculator {\n+    abstract static class BindingCalculator {\n@@ -283,1 +282,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n@@ -34,2 +36,0 @@\n-import java.lang.ref.Cleaner;\n-import java.nio.ByteOrder;\n@@ -41,1 +41,1 @@\n-import static jdk.incubator.foreign.CLinker.VaList;\n+\n@@ -45,2 +45,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n-import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n@@ -49,1 +47,1 @@\n-public non-sealed class SysVVaList implements VaList {\n+public non-sealed class SysVVaList implements VaList, Scoped {\n@@ -70,2 +68,2 @@\n-    private static final MemoryLayout GP_REG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n-    private static final MemoryLayout FP_REG = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n+    private static final MemoryLayout GP_REG = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n+    private static final MemoryLayout FP_REG = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n@@ -108,6 +106,4 @@\n-    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(int.class, groupElement(\"fp_offset\"));\n-    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(int.class, groupElement(\"gp_offset\"));\n-    private static final VarHandle VH_overflow_arg_area\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"overflow_arg_area\")));\n-    private static final VarHandle VH_reg_save_area\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"reg_save_area\")));\n+    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(groupElement(\"fp_offset\"));\n+    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(groupElement(\"gp_offset\"));\n+    private static final VarHandle VH_overflow_arg_area = LAYOUT.varHandle(groupElement(\"overflow_arg_area\"));\n+    private static final VarHandle VH_reg_save_area = LAYOUT.varHandle(groupElement(\"reg_save_area\"));\n@@ -115,1 +111,0 @@\n-    private static final Cleaner cleaner = Cleaner.create();\n@@ -133,3 +128,4 @@\n-        MemorySegment base = MemoryAddress.ofLong(ptr).asSegment(\n-                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n-        cleaner.register(SysVVaList.class, () -> base.scope().close());\n+        ResourceScope scope = ResourceScope.newImplicitScope();\n+        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment base = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n+                LAYOUT.byteSize(), scope);\n@@ -176,1 +172,1 @@\n-        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegment(\n+        return MemorySegment.ofAddress(((MemoryAddress)VH_reg_save_area.get(segment)),\n@@ -191,1 +187,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -196,1 +192,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -201,1 +197,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -206,1 +202,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -211,1 +207,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -216,5 +212,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -227,1 +218,0 @@\n-        checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);\n@@ -234,1 +224,1 @@\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n@@ -241,1 +231,1 @@\n-                    VarHandle reader = vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle();\n@@ -243,1 +233,1 @@\n-                        MemorySegment slice = stackPtr().asSegment(layout.byteSize(), localScope);\n+                        MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), localScope);\n@@ -259,1 +249,0 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n@@ -261,1 +250,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n@@ -264,1 +253,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n@@ -272,1 +261,1 @@\n-                    VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle();\n@@ -278,1 +267,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -290,0 +279,1 @@\n+        ((ResourceScopeImpl)segment.scope()).checkValidStateSlow();\n@@ -308,1 +298,1 @@\n-        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), scope));\n@@ -356,1 +346,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -361,1 +351,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -366,1 +356,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -371,1 +361,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -376,1 +366,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -383,1 +373,0 @@\n-            checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);\n@@ -398,1 +387,0 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n@@ -400,1 +388,1 @@\n-                                reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n@@ -403,1 +391,1 @@\n-                                reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n@@ -410,1 +398,1 @@\n-                        VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                        VarHandle writer = layout.varHandle();\n@@ -415,1 +403,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n@@ -433,1 +421,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":39,"deletions":51,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -31,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -32,2 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -35,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -46,1 +46,1 @@\n-public final class SysVx64Linker extends AbstractCLinker {\n+public final class SysVx64Linker implements CLinker {\n@@ -57,15 +57,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -86,2 +71,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -89,2 +73,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, SysVVaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -95,2 +79,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -100,1 +83,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -104,2 +87,6 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -31,1 +32,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -110,5 +110,11 @@\n-        return switch (PlatformLayouts.getKind(layout)) {\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> ArgumentClassImpl.INTEGER;\n-            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;\n-            case POINTER -> ArgumentClassImpl.POINTER;\n-        };\n+        Class<?> carrier = ((ValueLayout)layout).carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return ArgumentClassImpl.INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return ArgumentClassImpl.SSE;\n+        } else if (carrier == MemoryAddress.class) {\n+            return ArgumentClassImpl.POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -85,2 +86,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, Windowsx64Linker.ADDRESS_SIZE);\n-\n@@ -94,2 +93,2 @@\n-            void addArgumentBindings(Class<?> carrier, MemoryLayout layout) {\n-                csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));\n+            void addArgumentBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+                csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout, isVararg));\n@@ -99,1 +98,1 @@\n-                csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));\n+                csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout, false));\n@@ -108,1 +107,1 @@\n-            csb.addArgumentBindings(carrier, layout);\n+            csb.addArgumentBindings(carrier, layout, false);\n@@ -117,1 +116,1 @@\n-            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i));\n+            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), SharedUtils.isVarargsIndex(cDesc, i));\n@@ -137,1 +136,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -144,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence, scope);\n@@ -188,1 +187,1 @@\n-        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout);\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg);\n@@ -199,2 +198,2 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {\n-            TypeClass argumentClass = TypeClass.typeClassFor(layout);\n+        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+            TypeClass argumentClass = TypeClass.typeClassFor(layout, isVararg);\n@@ -214,2 +213,1 @@\n-                            .baseAddress()\n-                            .unboxAddress();\n+                            .unboxAddress(MemorySegment.class);\n@@ -221,1 +219,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n@@ -262,2 +260,2 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {\n-            TypeClass argumentClass = TypeClass.typeClassFor(layout);\n+        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+            TypeClass argumentClass = TypeClass.typeClassFor(layout, isVararg);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,3 +31,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n-\n-import static jdk.internal.foreign.PlatformLayouts.Win64.VARARGS_ATTRIBUTE_NAME;\n@@ -42,1 +40,1 @@\n-    private static TypeClass classifyValueType(ValueLayout type) {\n+    private static TypeClass classifyValueType(ValueLayout type, boolean isVararg) {\n@@ -52,9 +50,9 @@\n-        return switch (PlatformLayouts.getKind(type)) {\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n-            case POINTER -> POINTER;\n-            case FLOAT, DOUBLE -> {\n-                 if (type.attribute(VARARGS_ATTRIBUTE_NAME)\n-                        .map(Boolean.class::cast).orElse(false)) {\n-                    yield VARARG_FLOAT;\n-                }\n-                yield FLOAT;\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            if (isVararg) {\n+                return VARARG_FLOAT;\n+            } else {\n+                return FLOAT;\n@@ -62,1 +60,5 @@\n-        };\n+        } else if (carrier == MemoryAddress.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n@@ -80,1 +82,1 @@\n-    static TypeClass typeClassFor(MemoryLayout type) {\n+    static TypeClass typeClassFor(MemoryLayout type, boolean isVararg) {\n@@ -82,1 +84,1 @@\n-            return classifyValueType((ValueLayout) type);\n+            return classifyValueType((ValueLayout) type, isVararg);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.internal.foreign.Scoped;\n@@ -58,1 +58,1 @@\n-public non-sealed class WinVaList implements VaList {\n+public non-sealed class WinVaList implements VaList, Scoped {\n@@ -61,1 +61,1 @@\n-    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n@@ -78,1 +78,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -83,1 +83,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -88,1 +88,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -93,1 +93,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -98,1 +98,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -103,5 +103,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -114,1 +109,0 @@\n-        SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);\n@@ -117,1 +111,1 @@\n-            TypeClass typeClass = TypeClass.typeClassFor(layout);\n+            TypeClass typeClass = TypeClass.typeClassFor(layout, false);\n@@ -121,1 +115,1 @@\n-                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), scope());\n@@ -126,5 +120,2 @@\n-                case STRUCT_REGISTER -> {\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n-                    yield struct;\n-                }\n+                case STRUCT_REGISTER ->\n+                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -134,1 +125,1 @@\n-            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            VarHandle reader = layout.varHandle();\n@@ -144,0 +135,1 @@\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n@@ -149,1 +141,1 @@\n-        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, scope);\n@@ -186,1 +178,0 @@\n-            SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);\n@@ -192,1 +183,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -197,1 +188,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -202,1 +193,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -207,1 +198,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -212,1 +203,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -220,1 +211,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -229,1 +220,1 @@\n-                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout);\n+                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout, false);\n@@ -237,4 +228,2 @@\n-                        case STRUCT_REGISTER -> {\n-                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);\n-                            slice.copyFrom(msArg);\n-                        }\n+                        case STRUCT_REGISTER ->\n+                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":24,"deletions":35,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -31,2 +33,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -34,1 +35,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -45,1 +45,1 @@\n-public final class Windowsx64Linker extends AbstractCLinker {\n+public final class Windowsx64Linker implements CLinker {\n@@ -58,15 +58,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -87,2 +72,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -90,2 +74,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, WinVaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -96,2 +80,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -101,1 +84,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -105,2 +88,6 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        this.encoding = encoding != null ? encoding : Charset.defaultCharset();\n+        this.encoding = encoding != null ? encoding : System.out.charset();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractTerminal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -123,1 +124,1 @@\n-    Map<String,byte[]> moduleInfos = new HashMap<>();\n+    Map<String, ModuleInfoEntry> moduleInfos = new HashMap<>();\n@@ -130,1 +131,4 @@\n-    Map<Integer,String[]> filesMap = new HashMap<>();\n+    \/\/ base version is the first entry and then follow with the version given\n+    \/\/ from the --release option in the command-line order.\n+    \/\/ The value of each entry is the files given in the command-line order.\n+    Map<Integer,String[]> filesMap = new LinkedHashMap<>();\n@@ -775,1 +779,1 @@\n-        if (files == null)\n+        if (files == null) {\n@@ -777,0 +781,1 @@\n+        }\n@@ -780,1 +785,1 @@\n-            if (dir == null)\n+            if (dir == null) {\n@@ -782,1 +787,1 @@\n-            else\n+            } else {\n@@ -784,0 +789,1 @@\n+            }\n@@ -804,2 +810,5 @@\n-                    moduleInfos.putIfAbsent(name, Files.readAllBytes(f.toPath()));\n-                    if (uflag)\n+                    Path path = f.toPath();\n+                    byte[] fileContent = Files.readAllBytes(path);\n+                    ModuleInfoEntry mie = new StreamedModuleInfoEntry(name, fileContent, Files.getLastModifiedTime(path));\n+                    moduleInfos.putIfAbsent(name, mie);\n+                    if (uflag) {\n@@ -807,0 +816,1 @@\n+                    }\n@@ -808,1 +818,1 @@\n-                    if (uflag)\n+                    if (uflag) {\n@@ -810,0 +820,1 @@\n+                    }\n@@ -816,1 +827,1 @@\n-                    \/\/ dir name confilict\/duplicate could happen with -C option.\n+                    \/\/ dir name conflict\/duplicate could happen with -C option.\n@@ -825,1 +836,6 @@\n-                    expand(f, f.list(), cpaths, version);\n+                    String[] dirFiles = f.list();\n+                    \/\/ Ensure files list is sorted for reproducible jar content\n+                    if (dirFiles != null) {\n+                        Arrays.sort(dirFiles);\n+                    }\n+                    expand(f, dirFiles, cpaths, version);\n@@ -898,1 +914,1 @@\n-                   Map<String,byte[]> moduleInfos,\n+                   Map<String, ModuleInfoEntry> moduleInfos,\n@@ -947,1 +963,1 @@\n-                moduleInfos.putIfAbsent(name, zis.readAllBytes());\n+                moduleInfos.putIfAbsent(name, new StreamedModuleInfoEntry(name, zis.readAllBytes(), e.getLastModifiedTime()));\n@@ -1031,1 +1047,1 @@\n-    private void updateModuleInfo(Map<String,byte[]> moduleInfos, ZipOutputStream zos)\n+    private void updateModuleInfo(Map<String, ModuleInfoEntry> moduleInfos, ZipOutputStream zos)\n@@ -1035,1 +1051,1 @@\n-        for (Map.Entry<String,byte[]> mi : moduleInfos.entrySet()) {\n+        for (Map.Entry<String, ModuleInfoEntry> mi : moduleInfos.entrySet()) {\n@@ -1037,1 +1053,2 @@\n-            byte[] bytes = mi.getValue();\n+            ModuleInfoEntry mie = mi.getValue();\n+            byte[] bytes = mie.readAllBytes();\n@@ -1039,1 +1056,6 @@\n-            e.setTime(System.currentTimeMillis());\n+            FileTime lastModified = mie.getLastModifiedTime();\n+            if (lastModified != null) {\n+                e.setLastModifiedTime(lastModified);\n+            } else {\n+                e.setLastModifiedTime(FileTime.fromMillis(System.currentTimeMillis()));\n+            }\n@@ -1734,1 +1756,1 @@\n-     * bytes and an optional URI. Used when describing modules.\n+     * bytes and an optional URI.\n@@ -1737,3 +1759,14 @@\n-       String name();\n-       Optional<String> uriString();\n-       InputStream bytes() throws IOException;\n+        String name();\n+        Optional<String> uriString();\n+        InputStream bytes() throws IOException;\n+        \/**\n+         * @return Returns the last modified time of the module-info.class.\n+         * Returns null if the last modified time is unknown or cannot be\n+         * determined.\n+         *\/\n+        FileTime getLastModifiedTime();\n+        default byte[] readAllBytes() throws IOException {\n+            try (InputStream is = bytes()) {\n+                return is.readAllBytes();\n+            }\n+        }\n@@ -1753,0 +1786,6 @@\n+\n+        @Override\n+        public FileTime getLastModifiedTime() {\n+            return entry.getLastModifiedTime();\n+        }\n+\n@@ -1764,1 +1803,3 @@\n-        StreamedModuleInfoEntry(String name, byte[] bytes) {\n+        private final FileTime lastModifiedTime;\n+\n+        StreamedModuleInfoEntry(String name, byte[] bytes, FileTime lastModifiedTime) {\n@@ -1767,0 +1808,1 @@\n+            this.lastModifiedTime = lastModifiedTime;\n@@ -1772,0 +1814,11 @@\n+\n+        @Override\n+        public byte[] readAllBytes() throws IOException {\n+            return bytes;\n+        }\n+\n+        @Override\n+        public FileTime getLastModifiedTime() {\n+            return lastModifiedTime;\n+        }\n+\n@@ -1823,1 +1876,1 @@\n-                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes()));\n+                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes(), e.getLastModifiedTime()));\n@@ -2036,1 +2089,1 @@\n-    private boolean checkModuleInfo(byte[] moduleInfoBytes, Set<String> entries)\n+    private boolean checkModuleInfo(ModuleInfoEntry moduleInfoEntry, Set<String> entries)\n@@ -2040,1 +2093,1 @@\n-        if (moduleInfoBytes != null) {  \/\/ no root module-info.class if null\n+        if (moduleInfoEntry != null) {  \/\/ no root module-info.class if null\n@@ -2043,1 +2096,1 @@\n-                ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes));\n+                ModuleDescriptor md = ModuleDescriptor.read(moduleInfoEntry.bytes());\n@@ -2061,1 +2114,1 @@\n-     * Map values are updated in-place. Returns false if an error occurs.\n+     * Map values are updated in-place.\n@@ -2063,1 +2116,1 @@\n-    private void addExtendedModuleAttributes(Map<String,byte[]> moduleInfos,\n+    private void addExtendedModuleAttributes(Map<String, ModuleInfoEntry> moduleInfos,\n@@ -2067,3 +2120,7 @@\n-        for (Map.Entry<String,byte[]> e: moduleInfos.entrySet()) {\n-            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(e.getValue()));\n-            e.setValue(extendedInfoBytes(md, e.getValue(), packages));\n+        for (Map.Entry<String, ModuleInfoEntry> e: moduleInfos.entrySet()) {\n+            ModuleInfoEntry mie = e.getValue();\n+            byte[] bytes = mie.readAllBytes();\n+            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(bytes));\n+            byte[] extended = extendedInfoBytes(md, bytes, packages);\n+            \/\/ replace the entry value with the extended bytes\n+            e.setValue(new StreamedModuleInfoEntry(mie.name(), extended, mie.getLastModifiedTime()));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":88,"deletions":31,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -66,0 +67,32 @@\n+    public enum Language {\n+\n+        JAVA(\"java\"),\n+        PROPERTIES(\"properties\");\n+\n+        private static final Map<String, Language> languages;\n+\n+        static {\n+            Map<String, Language> tmp = new HashMap<>();\n+            for (var language : values()) {\n+                String id = Objects.requireNonNull(language.identifier);\n+                if (tmp.put(id, language) != null)\n+                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n+            }\n+            languages = Map.copyOf(tmp);\n+        }\n+\n+        Language(String id) {\n+            identifier = id;\n+        }\n+\n+        private final String identifier;\n+\n+        public static Optional<Language> of(String identifier) {\n+            if (identifier == null)\n+                return Optional.empty();\n+            return Optional.ofNullable(languages.get(identifier));\n+        }\n+\n+        public String getIdentifier() {return identifier;}\n+    }\n+\n@@ -220,0 +253,13 @@\n+        String lang = null;\n+        AttributeTree langAttr = attributes.get(\"lang\");\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n+        } else if (containsClass) {\n+            lang = \"java\";\n+        } else if (containsFile) {\n+            lang = languageFromFileName(fileObject.getName());\n+        }\n+\n+        Optional<Language> language = Language.of(lang);\n+\n+\n@@ -227,1 +273,1 @@\n-                inlineSnippet = parse(writer.configuration().getDocResources(), inlineContent);\n+                inlineSnippet = parse(writer.configuration().getDocResources(), language, inlineContent);\n@@ -242,1 +288,1 @@\n-                externalSnippet = parse(writer.configuration().getDocResources(), externalContent);\n+                externalSnippet = parse(writer.configuration().getDocResources(), language, externalContent);\n@@ -292,9 +338,0 @@\n-        String lang = null;\n-        AttributeTree langAttr = attributes.get(\"lang\");\n-        if (langAttr != null) {\n-            lang = stringValueOf(langAttr);\n-        } else if (containsClass) {\n-            lang = \"java\";\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n-        }\n@@ -329,2 +366,2 @@\n-    private StyledText parse(Resources resources, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(content);\n+    private StyledText parse(Resources resources, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(language, content);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":50,"deletions":13,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n@@ -79,4 +80,4 @@\n-    \/\/ next-line tag behaves as if it were specified on the next line\n-\n-    private String eolMarker;\n-    private Matcher markedUpLine;\n+    private static final Pattern JAVA_COMMENT = Pattern.compile(\n+            \"^(?<payload>.*)\/\/(?<markup>\\\\s*@\\\\s*\\\\w+.+?)$\");\n+    private static final Pattern PROPERTIES_COMMENT = Pattern.compile(\n+            \"^(?<payload>[ \\t]*([#!].*)?)[#!](?<markup>\\\\s*@\\\\s*\\\\w+.+?)$\");\n@@ -96,2 +97,7 @@\n-    public Result parse(String source) throws ParseException {\n-        return parse(\"\/\/\", source);\n+    public Result parse(Optional<SnippetTaglet.Language> language, String source) throws ParseException {\n+        SnippetTaglet.Language lang = language.orElse(SnippetTaglet.Language.JAVA);\n+        var p = switch (lang) {\n+            case JAVA -> JAVA_COMMENT;\n+            case PROPERTIES -> PROPERTIES_COMMENT;\n+        };\n+        return parse(p, source);\n@@ -103,2 +109,2 @@\n-    public Result parse(String eolMarker, String source) throws ParseException {\n-        Objects.requireNonNull(eolMarker);\n+    private Result parse(Pattern commentPattern, String source) throws ParseException {\n+        Objects.requireNonNull(commentPattern);\n@@ -106,16 +112,2 @@\n-        if (!Objects.equals(eolMarker, this.eolMarker)) {\n-            if (eolMarker.length() < 1) {\n-                throw new IllegalArgumentException();\n-            }\n-            for (int i = 0; i < eolMarker.length(); i++) {\n-                switch (eolMarker.charAt(i)) {\n-                    case '\\f', '\\n', '\\r' -> throw new IllegalArgumentException();\n-                }\n-            }\n-            this.eolMarker = eolMarker;\n-            \/\/ capture the rightmost eolMarker (e.g. \"\/\/\")\n-            \/\/ The below Pattern.compile should never throw PatternSyntaxException\n-            Pattern pattern = Pattern.compile(\"^(.*)(\" + Pattern.quote(eolMarker)\n-                    + \"(\\\\s*@\\\\s*\\\\w+.+?))$\");\n-            this.markedUpLine = pattern.matcher(\"\"); \/\/ reusable matcher\n-        }\n+\n+        Matcher markedUpLine = commentPattern.matcher(\"\"); \/\/ reusable matcher\n@@ -154,1 +146,1 @@\n-                String maybeMarkup = markedUpLine.group(3);\n+                String maybeMarkup = rawLine.substring(markedUpLine.start(\"markup\"));\n@@ -160,1 +152,1 @@\n-                    throw new ParseException(e::getMessage, markedUpLine.start(3) + e.getPosition());\n+                    throw new ParseException(e::getMessage, markedUpLine.start(\"markup\") + e.getPosition());\n@@ -164,1 +156,1 @@\n-                    t.markupLineOffset = markedUpLine.start(3);\n+                    t.markupLineOffset = markedUpLine.start(\"markup\");\n@@ -179,1 +171,1 @@\n-                    String payload = markedUpLine.group(1);\n+                    String payload = rawLine.substring(0, markedUpLine.end(\"payload\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":20,"deletions":28,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -359,1 +359,2 @@\n-                if (jarfile.isMultiRelease()) {\n+                \/\/ exclude module-info.class since this jarFile is on classpath\n+                if (jarfile.isMultiRelease() && !cf.getName().equals(\"module-info\")) {\n@@ -440,1 +441,0 @@\n-    private static final String MODULE_INFO = \"module-info.class\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ClassFileReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,8 @@\n-            throw new Error(e);\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException x) {\n+                throw x;\n+            } else if (cause instanceof Error x) {\n+                throw x;\n+            } else {\n+                throw new Error(e);\n+            }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DependencyFinder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        super();\n+        super(JdepsTask.getMessage(key, params));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/MultiReleaseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,9 +58,4 @@\n-                if (nameToVersion.containsKey(name)) {\n-                    if (!version.equals(nameToVersion.get(name))) {\n-                        throw new MultiReleaseException(\n-                                \"err.multirelease.version.associated\",\n-                                name, nameToVersion.get(name), version\n-                        );\n-                    }\n-                } else {\n-                    nameToVersion.put(name, version);\n+                String v = nameToVersion.computeIfAbsent(name, _n -> version);\n+                if (!version.equals(v)) {\n+                    throw new MultiReleaseException(\"err.multirelease.version.associated\",\n+                                name, nameToVersion.get(name), version);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/VersionHelper.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.ArrayList;\n@@ -165,1 +164,0 @@\n-        List<RequestHook> addEntries = new ArrayList<>();\n@@ -168,1 +166,0 @@\n-            addEntries.add(rh);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -778,0 +778,5 @@\n+    <event name=\"jdk.ZThreadDebug\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -778,0 +778,5 @@\n+    <event name=\"jdk.ZThreadDebug\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -770,0 +770,4 @@\n+            \/\/ Keep a sorted set of files to be processed, so that the jmod\n+            \/\/ content is reproducible as Files.walkFileTree order is not defined\n+            SortedMap<String, Path> filesToProcess = new TreeMap<String, Path>();\n+\n@@ -785,3 +789,1 @@\n-                                try (InputStream in = Files.newInputStream(file)) {\n-                                    out.writeEntry(in, section, name);\n-                                }\n+                                filesToProcess.put(name, file);\n@@ -793,0 +795,9 @@\n+\n+            \/\/ Process files in sorted order for deterministic jmod content\n+            for (Map.Entry<String, Path> entry : filesToProcess.entrySet()) {\n+                String name = entry.getKey();\n+                Path   file = entry.getValue();\n+                try (InputStream in = Files.newInputStream(file)) {\n+                    out.writeEntry(in, section, name);\n+                }\n+            }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncher.so\")) {\n+        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncheraux.so\")) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+        ENABLE_NATIVE_ACCESS(\"--enable-native-access\", true, true, false, true, true),\n@@ -366,0 +367,1 @@\n+        private final OptionSpecBuilder  argEnableNativeAccess = parser.accepts(\"enable-native-access\");\n@@ -474,0 +476,4 @@\n+            if (options.has(argEnableNativeAccess)) {\n+                opts.addAll(OptionKind.ENABLE_NATIVE_ACCESS, List.of(\n+                        OptionKind.ENABLE_NATIVE_ACCESS.optionFlag, \"ALL-UNNAMED\"));\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,0 +210,2 @@\n+\\    --enable-native-access\\n\\\n+\\                          Allow code to run restricted native methods\\n\\\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,2 +66,2 @@\n-        outputs.put(\"out\", st -> System.setOut(new PrintStream(st, true)));\n-        outputs.put(\"err\", st -> System.setErr(new PrintStream(st, true)));\n+        outputs.put(\"out\", st -> System.setOut(new PrintStream(st, true, System.out.charset())));\n+        outputs.put(\"err\", st -> System.setErr(new PrintStream(st, true, System.err.charset())));\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-     * associated with this {@link RecordingInfo}, or {code 0} if no duration\n+     * associated with this {@link RecordingInfo}, or {@code 0} if no duration\n@@ -306,1 +306,1 @@\n-     * @return the desired duration, or {code 0} if no duration has been set\n+     * @return the desired duration, or {@code 0} if no duration has been set\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RecordingInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+15\n","filename":"src\/utils\/IdealGraphVisualizer\/.java-version","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n- Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n-\n- Redistribution and use in source and binary forms, with or without\n- modification, are permitted provided that the following conditions\n- are met:\n-\n-   - Redistributions of source code must retain the above copyright\n-     notice, this list of conditions and the following disclaimer.\n-\n-   - Redistributions in binary form must reproduce the above copyright\n-     notice, this list of conditions and the following disclaimer in the\n-     documentation and\/or other materials provided with the distribution.\n-\n-   - Neither the name of Oracle nor the names of its\n-     contributors may be used to endorse or promote products derived\n-     from this software without specific prior written permission.\n-\n- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n--->\n-\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <parent>\n-        <artifactId>IdealGraphVisualizer-parent<\/artifactId>\n-        <groupId>com.sun.hotspot.igv<\/groupId>\n-        <version>1.0-SNAPSHOT<\/version>\n-    <\/parent>\n-    <groupId>com.sun.hotspot.igv<\/groupId>\n-    <artifactId>BatikSVGProxy<\/artifactId>\n-    <version>1.0-SNAPSHOT<\/version>\n-    <packaging>nbm<\/packaging>\n-    <name>BatikSVGProxy<\/name>\n-    <properties>\n-        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n-    <\/properties>\n-    <dependencies>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.netbeans.utilities<\/groupId>\n-                <artifactId>nbm-maven-plugin<\/artifactId>\n-                <version>${nbmmvnplugin.version}<\/version>\n-                <extensions>true<\/extensions>\n-                <configuration>\n-                    <publicPackages>\n-                        <publicPackage>com.sun.hotspot.igv.svg<\/publicPackage>\n-                    <\/publicPackages>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-compiler-plugin<\/artifactId>\n-                <version>${mvncompilerplugin.version}<\/version>\n-                <configuration>\n-                    <source>1.8<\/source>\n-                    <target>1.8<\/target>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-jar-plugin<\/artifactId>\n-                <version>${mvnjarplugin.version}<\/version>\n-                <configuration>\n-                    <!-- to have the jar plugin pickup the nbm generated manifest -->\n-                    <archive>\n-                        <manifestFile>${project.build.outputDirectory}\/META-INF\/MANIFEST.MF<\/manifestFile>\n-                    <\/archive>\n-                <\/configuration>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"src\/utils\/IdealGraphVisualizer\/BatikSVGProxy\/pom.xml","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.svg;\n-\n-import java.awt.Graphics2D;\n-import java.io.Writer;\n-import java.io.File;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import org.w3c.dom.DOMImplementation;\n-\n-\/**\n- * Utility class\n- * @author Thomas Wuerthinger\n- *\/\n-public class BatikSVG {\n-\n-    private BatikSVG() {\n-    }\n-\n-    private static Constructor SVGGraphics2DConstructor;\n-    private static Method streamMethod;\n-    private static Method createDefaultMethod;\n-    private static Method getDOMImplementationMethod;\n-    private static Method setEmbeddedFontsOnMethod;\n-    private static Class<?> classSVGGraphics2D;\n-\n-    \/**\n-     * Creates a graphics object that allows to be exported to SVG data using the {@link #printToStream(Graphics2D, Writer, boolean) printToStream} method.\n-     * @return the newly created Graphics2D object or null if the library does not exist\n-     *\/\n-    public static Graphics2D createGraphicsObject() {\n-        try {\n-            if (SVGGraphics2DConstructor == null) {\n-                String batikJar = System.getenv().get(\"IGV_BATIK_JAR\");\n-                if (batikJar == null) {\n-                    return null;\n-                }\n-                \/\/ Load batik in it's own class loader since some it's support jars interfere with the JDK\n-                URL url = new File(batikJar).toURI().toURL();\n-                ClassLoader cl = new URLClassLoader(new URL[] { url });\n-                Class<?> classGenericDOMImplementation = cl.loadClass(\"org.apache.batik.dom.GenericDOMImplementation\");\n-                Class<?> classSVGGeneratorContext = cl.loadClass(\"org.apache.batik.svggen.SVGGeneratorContext\");\n-                classSVGGraphics2D = cl.loadClass(\"org.apache.batik.svggen.SVGGraphics2D\");\n-                getDOMImplementationMethod = classGenericDOMImplementation.getDeclaredMethod(\"getDOMImplementation\", new Class[0]);\n-                createDefaultMethod = classSVGGeneratorContext.getDeclaredMethod(\"createDefault\", new Class[]{org.w3c.dom.Document.class});\n-                setEmbeddedFontsOnMethod = classSVGGeneratorContext.getDeclaredMethod(\"setEmbeddedFontsOn\", new Class[]{boolean.class});\n-                streamMethod = classSVGGraphics2D.getDeclaredMethod(\"stream\", Writer.class, boolean.class);\n-                SVGGraphics2DConstructor = classSVGGraphics2D.getConstructor(classSVGGeneratorContext, boolean.class);\n-            }\n-            DOMImplementation dom = (DOMImplementation) getDOMImplementationMethod.invoke(null);\n-            org.w3c.dom.Document document = dom.createDocument(\"http:\/\/www.w3.org\/2000\/svg\", \"svg\", null);\n-            Object ctx = createDefaultMethod.invoke(null, document);\n-            setEmbeddedFontsOnMethod.invoke(ctx, true);\n-            Graphics2D svgGenerator = (Graphics2D) SVGGraphics2DConstructor.newInstance(ctx, true);\n-            return svgGenerator;\n-        } catch (ClassNotFoundException e) {\n-            return null;\n-        } catch (NoSuchMethodException e) {\n-            return null;\n-        } catch (IllegalAccessException e) {\n-            return null;\n-        } catch (InvocationTargetException e) {\n-            return null;\n-        } catch (InstantiationException e) {\n-            return null;\n-        } catch (MalformedURLException e) {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Serializes a graphics object to a stream in SVG format.\n-     * @param svgGenerator the graphics object. Only graphics objects created by the {@link #createGraphicsObject() createGraphicsObject} method are valid.\n-     * @param stream the stream to which the data is written\n-     * @param useCSS whether to use CSS styles in the SVG output\n-     *\/\n-    public static void printToStream(Graphics2D svgGenerator, Writer stream, boolean useCSS) {\n-        assert classSVGGraphics2D != null;\n-        assert classSVGGraphics2D.isInstance(svgGenerator);\n-        try {\n-            streamMethod.invoke(svgGenerator, stream, useCSS);\n-        } catch (IllegalAccessException e) {\n-            assert false;\n-        } catch (InvocationTargetException e) {\n-            assert false;\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/BatikSVGProxy\/src\/main\/java\/com\/sun\/hotspot\/igv\/svg\/BatikSVG.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\/**\n- * This package is used to proxy the SVG export functionality of the BatikSVG library. Reflection is used such that the\n- * library is optional and need not be present at build time.\n- *\/\n-package com.sun.hotspot.igv.svg;\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/BatikSVGProxy\/src\/main\/java\/com\/sun\/hotspot\/igv\/svg\/package-info.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-Manifest-Version: 1.0\n-OpenIDE-Module: com.sun.hotspot.igv.svg\n-OpenIDE-Module-Localizing-Bundle: com\/sun\/hotspot\/igv\/svg\/Bundle.properties\n-OpenIDE-Module-Specification-Version: 1.0\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/BatikSVGProxy\/src\/main\/nbm\/manifest.mf","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n-OpenIDE-Module-Name=BatikSVGProxy\n","filename":"src\/utils\/IdealGraphVisualizer\/BatikSVGProxy\/src\/main\/resources\/com\/sun\/hotspot\/igv\/svg\/Bundle.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -84,5 +84,0 @@\n-        <dependency>\n-            <groupId>com.sun.hotspot.igv<\/groupId>\n-            <artifactId>BatikSVGProxy<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n@@ -154,0 +149,15 @@\n+        <dependency>\n+            <groupId>org.apache.xmlgraphics<\/groupId>\n+            <artifactId>batik-dom<\/artifactId>\n+            <version>${batik.version}<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.apache.xmlgraphics<\/groupId>\n+            <artifactId>batik-svggen<\/artifactId>\n+            <version>${batik.version}<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>com.github.librepdf<\/groupId>\n+            <artifactId>openpdf<\/artifactId>\n+            <version>${openpdf.version}<\/version>\n+        <\/dependency>\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/pom.xml","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.awt.Rectangle;\n@@ -47,1 +48,1 @@\n-    public void paint(Graphics2D svgGenerator);\n+    public void paint(Graphics2D generator);\n@@ -73,0 +74,2 @@\n+    public Rectangle getBounds();\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.hotspot.igv.svg.BatikSVG;\n@@ -51,0 +50,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -55,0 +55,10 @@\n+import org.apache.batik.dom.GenericDOMImplementation;\n+import org.apache.batik.svggen.SVGGeneratorContext;\n+import org.apache.batik.svggen.SVGGraphics2D;\n+import com.lowagie.text.Document;\n+import com.lowagie.text.Rectangle;\n+import com.lowagie.text.pdf.PdfWriter;\n+import com.lowagie.text.pdf.PdfContentByte;\n+import com.lowagie.text.pdf.PdfTemplate;\n+import com.lowagie.text.pdf.PdfGraphics2D;\n+import org.w3c.dom.DOMImplementation;\n@@ -106,5 +116,5 @@\n-            Graphics2D svgGenerator = BatikSVG.createGraphicsObject();\n-\n-            if (svgGenerator == null) {\n-                NotifyDescriptor message = new NotifyDescriptor.Message(\"For export to SVG files the Batik SVG Toolkit must be intalled.\", NotifyDescriptor.ERROR_MESSAGE);\n-                DialogDisplayer.getDefault().notifyLater(message);\n+            String lcFileName = f.getName().toLowerCase();\n+            if (lcFileName.endsWith(\".pdf\")) {\n+                exportToPDF(scene, f);\n+            } else if (lcFileName.endsWith(\".svg\")) {\n+                exportToSVG(scene, f);\n@@ -112,18 +122,2 @@\n-                scene.paint(svgGenerator);\n-                FileOutputStream os = null;\n-                try {\n-                    os = new FileOutputStream(f);\n-                    Writer out = new OutputStreamWriter(os, UTF_8);\n-                    BatikSVG.printToStream(svgGenerator, out, true);\n-                } catch (FileNotFoundException e) {\n-                    NotifyDescriptor message = new NotifyDescriptor.Message(\"For export to SVG files the Batik SVG Toolkit must be intalled.\", NotifyDescriptor.ERROR_MESSAGE);\n-                    DialogDisplayer.getDefault().notifyLater(message);\n-                } finally {\n-                    if (os != null) {\n-                        try {\n-                            os.close();\n-                        } catch (IOException e) {\n-                        }\n-                    }\n-                }\n-\n+                NotifyDescriptor message = new NotifyDescriptor.Message(\"Unknown image file extension: expected either '.pdf' or '.svg'\", NotifyDescriptor.ERROR_MESSAGE);\n+                DialogDisplayer.getDefault().notifyLater(message);\n@@ -642,1 +636,43 @@\n-}\n+    }\n+\n+    private static void exportToPDF(DiagramViewer scene, File f) {\n+        int width = scene.getBounds().width;\n+        int height = scene.getBounds().height;\n+        com.lowagie.text.Document document = new Document(new Rectangle(width, height));\n+        PdfWriter writer = null;\n+        try {\n+            writer = PdfWriter.getInstance(document, new FileOutputStream(f));\n+            writer.setCloseStream(true);\n+            document.open();\n+            PdfContentByte contentByte = writer.getDirectContent();\n+            PdfTemplate template = contentByte.createTemplate(width, height);\n+            PdfGraphics2D pdfGenerator = new PdfGraphics2D(contentByte, width, height);\n+            scene.paint(pdfGenerator);\n+            pdfGenerator.dispose();\n+            contentByte.addTemplate(template, 0, 0);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            if (document.isOpen()) {\n+                document.close();\n+            }\n+            if (writer != null) {\n+                writer.close();\n+            }\n+        }\n+    }\n+\n+    private static void exportToSVG(DiagramViewer scene, File f) {\n+        DOMImplementation dom = GenericDOMImplementation.getDOMImplementation();\n+        org.w3c.dom.Document document = dom.createDocument(\"http:\/\/www.w3.org\/2000\/svg\", \"svg\", null);\n+        SVGGeneratorContext ctx = SVGGeneratorContext.createDefault(document);\n+        ctx.setEmbeddedFontsOn(true);\n+        SVGGraphics2D svgGenerator = new SVGGraphics2D(ctx, true);\n+        scene.paint(svgGenerator);\n+        try (FileOutputStream os = new FileOutputStream(f)) {\n+            Writer out = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n+            svgGenerator.stream(out, true);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":61,"deletions":25,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Export current graph as SVG file\");\n+        putValue(Action.SHORT_DESCRIPTION, \"Export current graph as image file\");\n@@ -69,1 +69,4 @@\n-                return true;\n+                String lcFileName = f.getName().toLowerCase();\n+                return lcFileName.endsWith(\".pdf\") ||\n+                       lcFileName.endsWith(\".svg\") ||\n+                       f.isDirectory();\n@@ -74,1 +77,1 @@\n-                return \"SVG files (*.svg)\";\n+                return \"Image files (*.pdf, *.svg)\";\n@@ -83,1 +86,1 @@\n-                file = new File(file.getAbsolutePath() + \".svg\");\n+                file = new File(file.getAbsolutePath() + \".pdf\");\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExportAction.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -145,5 +145,0 @@\n-        <dependency>\n-            <groupId>${project.groupId}<\/groupId>\n-            <artifactId>BatikSVGProxy<\/artifactId>\n-            <version>${project.version}<\/version>\n-        <\/dependency>\n","filename":"src\/utils\/IdealGraphVisualizer\/application\/pom.xml","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-        <module>BatikSVGProxy<\/module>\n@@ -95,1 +94,1 @@\n-        <nbmmvnplugin.version>4.3<\/nbmmvnplugin.version>\n+        <nbmmvnplugin.version>4.6<\/nbmmvnplugin.version>\n@@ -97,1 +96,1 @@\n-        <mvnjarplugin.version>3.1.2<\/mvnjarplugin.version>\n+        <mvnjarplugin.version>3.2.0<\/mvnjarplugin.version>\n@@ -99,0 +98,2 @@\n+        <batik.version>1.14<\/batik.version>\n+        <openpdf.version>1.3.26<\/openpdf.version>\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -346,1 +348,1 @@\n-    G1AddCardResult res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 1);\n+    G1AddCardResult res = card_set.add_card(99, config.max_cards_in_howl_bitmap() - 1);\n@@ -349,1 +351,1 @@\n-    ASSERT_TRUE(config.num_cards_in_howl_bitmap() == card_set.occupied());\n+    ASSERT_TRUE(config.max_cards_in_howl_bitmap() == card_set.occupied());\n@@ -351,1 +353,1 @@\n-    res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 2);\n+    res = card_set.add_card(99, config.max_cards_in_howl_bitmap() - 2);\n@@ -356,1 +358,1 @@\n-    i = config.num_cards_in_howl_bitmap();\n+    i = config.max_cards_in_howl_bitmap();\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+#include \"testutils.hpp\"\n+\n+#if INCLUDE_NMT\n+\n+\/\/ This prefix shows up on any c heap corruption NMT detects. If unsure which assert will\n+\/\/ come, just use this one.\n+#define COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX \"NMT corruption\"\n+\n+\n+\n+#define DEFINE_TEST(test_function, expected_assertion_message)                            \\\n+  TEST_VM_FATAL_ERROR_MSG(NMT, test_function, \".*\" expected_assertion_message \".*\") {     \\\n+    if (MemTracker::tracking_level() > NMT_off) {                                         \\\n+      tty->print_cr(\"NMT overwrite death test, please ignore subsequent error dump.\");    \\\n+      test_function ();                                                                   \\\n+    } else {                                                                              \\\n+      \/* overflow detection requires NMT to be on. If off, fake assert. *\/                \\\n+      guarantee(false,                                                                    \\\n+                \"fake message ignore this - \" expected_assertion_message);                \\\n+    }                                                                                     \\\n+  }\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_overwrite_front() {\n+  address p = (address) os::malloc(1, mtTest);\n+  *(p - 1) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_front, \"header canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_overwrite_back() {\n+  address p = (address) os::malloc(1, mtTest);\n+  *(p + 1) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_back, \"footer canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ A overwrite farther away from the NMT header; the report should show the hex dump split up\n+\/\/ in two parts, containing both header and corruption site.\n+static void test_overwrite_back_long(size_t distance) {\n+  address p = (address) os::malloc(distance, mtTest);\n+  *(p + distance) = 'a';\n+  os::free(p);\n+}\n+static void test_overwrite_back_long_aligned_distance()   { test_overwrite_back_long(0x2000); }\n+DEFINE_TEST(test_overwrite_back_long_aligned_distance, \"footer canary broken\")\n+static void test_overwrite_back_long_unaligned_distance() { test_overwrite_back_long(0x2001); }\n+DEFINE_TEST(test_overwrite_back_long_unaligned_distance, \"footer canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_double_free() {\n+  address p = (address) os::malloc(1, mtTest);\n+  os::free(p);\n+  \/\/ Now a double free. Note that this is susceptible to concurrency issues should\n+  \/\/ a concurrent thread have done a malloc and gotten the same address after the\n+  \/\/ first free. To decrease chance of this happening, we repeat the double free\n+  \/\/ several times.\n+  for (int i = 0; i < 100; i ++) {\n+    os::free(p);\n+  }\n+}\n+\n+\/\/ What assertion message we will see depends on whether the VM wipes the memory-to-be-freed\n+\/\/ on the first free(), and whether the libc uses the freed memory to store bookkeeping information.\n+\/\/ If the death marker in the header is still intact after the first free, we will recognize this as\n+\/\/ double free; if it got wiped, we should at least see a broken header canary.\n+\/\/ The message would be either\n+\/\/ - \"header canary broken\" or\n+\/\/ - \"header canary dead (double free?)\".\n+\/\/ However, since gtest regex expressions do not support unions (a|b), I search for a reasonable\n+\/\/ subset here.\n+DEFINE_TEST(test_double_free, \"header canary\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_invalid_block_address() {\n+  \/\/ very low, like the result of an overflow or of accessing a NULL this pointer\n+  os::free((void*)0x100);\n+}\n+DEFINE_TEST(test_invalid_block_address, \"invalid block address\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_unaliged_block_address() {\n+  address p = (address) os::malloc(1, mtTest);\n+  os::free(p + 6);\n+}\n+DEFINE_TEST(test_unaliged_block_address, \"block address is unaligned\");\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ Test that we notice block corruption on realloc too\n+static void test_corruption_on_realloc(size_t s1, size_t s2) {\n+  address p1 = (address) os::malloc(s1, mtTest);\n+  *(p1 + s1) = 'a';\n+  address p2 = (address) os::realloc(p1, s2, mtTest);\n+\n+  \/\/ Still here?\n+  tty->print_cr(\"NMT did not detect corruption on os::realloc?\");\n+  \/\/ Note: don't use ASSERT here, that does not work as expected in death tests. Just\n+  \/\/ let the test run its course, it should notice something is amiss.\n+}\n+static void test_corruption_on_realloc_growing()    { test_corruption_on_realloc(0x10, 0x11); }\n+DEFINE_TEST(test_corruption_on_realloc_growing, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n+static void test_corruption_on_realloc_shrinking()  { test_corruption_on_realloc(0x11, 0x10); }\n+DEFINE_TEST(test_corruption_on_realloc_shrinking, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ realloc is the trickiest of the bunch. Test that realloc works and correctly takes over\n+\/\/ NMT header and footer to the resized block. We just test that nothing crashes - if the\n+\/\/ header\/footer get corrupted, NMT heap corruption checker will trigger alert on os::free()).\n+TEST_VM(NMT, test_realloc) {\n+  \/\/ We test both directions (growing and shrinking) and a small range for each to cover all\n+  \/\/ size alignment variants. Should not matter, but this should be cheap.\n+  for (size_t s1 = 0xF0; s1 < 0x110; s1 ++) {\n+    for (size_t s2 = 0x100; s2 > 0xF0; s2 --) {\n+      address p1 = (address) os::malloc(s1, mtTest);\n+      ASSERT_NOT_NULL(p1);\n+      GtestUtils::mark_range(p1, s1);       \/\/ mark payload range...\n+      address p2 = (address) os::realloc(p1, s2, mtTest);\n+      ASSERT_NOT_NULL(p2);\n+      ASSERT_RANGE_IS_MARKED(p2, MIN2(s1, s2))        \/\/ ... and check that it survived the resize\n+         << s1 << \"->\" << s2 << std::endl;\n+      os::free(p2);                         \/\/ <- if NMT headers\/footers got corrupted this asserts\n+    }\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -60,1 +60,2 @@\n-    tty->print_cr(\"wrong pattern around \" PTR_FORMAT, p2i(first_wrong));\n+    tty->print_cr(\"check_range [\" PTR_FORMAT \"..\" PTR_FORMAT \"), 0x%X, : wrong pattern around \" PTR_FORMAT,\n+                  p2i(p), p2i(p) + s, expected, p2i(first_wrong));\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-#define ASSERT_NOT_NULL(p)  ASSERT_NE(p, (char*)NULL)\n-#define ASSERT_NULL(p)      ASSERT_EQ(p, (char*)NULL)\n+#define ASSERT_NOT_NULL(p)  ASSERT_NE(p2i(p), 0)\n+#define ASSERT_NULL(p)      ASSERT_EQ(p2i(p), 0)\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,0 +152,17 @@\n+#define TEST_VM_FATAL_ERROR_MSG(category, name, msg)                \\\n+  static void test_  ## category ## _ ## name ## _();               \\\n+                                                                    \\\n+  static void child_ ## category ## _ ## name ## _() {              \\\n+    ::testing::GTEST_FLAG(throw_on_failure) = true;                 \\\n+    test_ ## category ## _ ## name ## _();                          \\\n+    exit(0);                                                        \\\n+  }                                                                 \\\n+                                                                    \\\n+  TEST(category, CONCAT(name, _vm_assert)) {                        \\\n+    ASSERT_EXIT(child_ ## category ## _ ## name ## _(),             \\\n+                ::testing::ExitedWithCode(1),                       \\\n+                msg);                            \\\n+  }                                                                 \\\n+                                                                    \\\n+  void test_ ## category ## _ ## name ## _()\n+\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java 8273095 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8265795 generic-all\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java 8265795 generic-all\n-vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002.java 8265796  generic-all\n@@ -95,0 +92,2 @@\n+applications\/jcstress\/acqrel.java 8277434 linux-aarch64\n+\n@@ -108,1 +107,1 @@\n-runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java 8277350 macosx-x64\n+runtime\/ErrorHandling\/CreateCoredumpOnCrash.java 8267433 macosx-x64\n@@ -153,0 +152,1 @@\n+vmTestbase\/nsk\/jdi\/TypeComponent\/isSynthetic\/issynthetic001\/TestDescription.java 8277803 generic-all\n@@ -163,2 +163,1 @@\n-vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java 8264605 generic-all\n-vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java 8266593 generic-all\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8277812 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,2 +27,7 @@\n-import java.io.IOException;\n-import java.io.File;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.CoreUtils;\n+\n@@ -30,0 +35,1 @@\n+import java.io.File;\n@@ -31,0 +37,1 @@\n+import java.io.IOException;\n@@ -39,8 +46,0 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.util.CoreUtils;\n@@ -299,0 +298,37 @@\n+\n+    protected void removeVersionFromReplayFile() {\n+        setNewVersionLineInReplayFile(null);\n+    }\n+\n+    protected void setNewVersionInReplayFile(int newVersionNumber) {\n+        setNewVersionLineInReplayFile(\"version \" + newVersionNumber);\n+    }\n+\n+    private void setNewVersionLineInReplayFile(String firstLineString) {\n+        List<String> newLines = new ArrayList<>();\n+        Path replayFilePath = Paths.get(getReplayFileName());\n+        try (var br = Files.newBufferedReader(replayFilePath)) {\n+            String line;\n+            boolean firstLine = true;\n+            while ((line = br.readLine()) != null) {\n+                if (firstLine) {\n+                    firstLine = false;\n+                    Asserts.assertTrue(line.startsWith(\"version\"), \"version number must exist in a proper replay file\");\n+                    if (firstLineString != null) {\n+                        newLines.add(firstLineString);\n+                    }\n+                    \/\/ Else: Remove first line by skipping it.\n+                } else {\n+                    newLines.add(line);\n+                }\n+            }\n+            Asserts.assertFalse(firstLine, replayFilePath + \" should not be empty\");\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read replay data: \" + e, e);\n+        }\n+        try {\n+            Files.write(replayFilePath, newLines, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to write replay data: \" + e, e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public abstract class InliningBase extends DumpReplayBase {\n+    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n+    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n+    protected final String[] commandLineReplay;\n+    protected final List<String> commandLineNormal;\n+    protected final Class<?> testClass;\n+\n+    protected InliningBase(Class<?> testClass) {\n+        this.testClass = testClass;\n+        commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n+                                                                 \"-XX:CompileCommand=exclude,\" + testClass.getName() + \"::main\",\n+                                                                 \"-XX:CompileCommand=option,\" + testClass.getName() + \"::test,bool,PrintInlining,true\"));\n+        commandLineReplay = new String[]\n+                {\"-XX:LogFile=\" + LOG_FILE_REPLAY, \"-XX:+LogCompilation\",\n+                 \"-XX:CompileCommand=option,\" + testClass.getName()  + \"::test,bool,PrintInlining,true\"};\n+    }\n+\n+    protected void runTest() {\n+        runTest(commandLineNormal.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    public String getTestClass() {\n+        return testClass.getName();\n+    }\n+\n+    @Override\n+    public void cleanup() {\n+        super.cleanup();\n+        remove(LOG_FILE_NORMAL);\n+        remove(LOG_FILE_REPLAY);\n+    }\n+\n+    static class InlineEntry {\n+        String klass;\n+        String method;\n+        String reason;\n+\n+        public InlineEntry(String klass, String method, String reason) {\n+            this.klass = klass;\n+            this.method = method;\n+            this.reason = reason;\n+        }\n+\n+        public boolean isNormalInline() {\n+            return reason.equals(\"inline (hot)\");\n+        }\n+\n+        public boolean isForcedByReplay() {\n+            return reason.equals(\"force inline by ciReplay\");\n+        }\n+\n+        public boolean isDisallowedByReplay() {\n+            return reason.equals(\"disallowed by ciReplay\");\n+        }\n+\n+        public boolean isUnloadedSignatureClasses() {\n+            return reason.equals(\"unloaded signature classes\");\n+        }\n+\n+        public boolean isForcedIncrementalInlineByReplay() {\n+            return reason.equals(\"force (incremental) inline by ciReplay\");\n+        }\n+\n+        public boolean isForcedInline() {\n+            return reason.equals(\"force inline by annotation\");\n+        }\n+\n+        public boolean isTooDeep() {\n+            return reason.equals(\"inlining too deep\");\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+\n+            if (!(other instanceof InlineEntry)) {\n+                return false;\n+            }\n+\n+            InlineEntry e = (InlineEntry)other;\n+            return klass.equals(e.klass) && method.equals(e.method);\n+        }\n+\n+        public boolean compare(String klass, String method, boolean kind) {\n+            return this.klass.equals(klass) && this.method.equals(method) && kind;\n+        }\n+    }\n+\n+    protected static List<InlineEntry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n+        String nmethodStart = \"<nmethod\";\n+        List<InlineEntry> inlinees = new ArrayList<>();\n+        int foundLines = 0;\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            boolean nmethodLine = false;\n+            boolean inlinineLine = false;\n+            while ((line = br.readLine()) != null) {\n+                if (nmethodLine) {\n+                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n+                    if (line.startsWith(\"             \")) {\n+                        inlinineLine = true;\n+                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n+                        Matcher matcher = p.matcher(line);\n+                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n+                        inlinees.add(new InlineEntry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n+                        foundLines++;\n+                    } else if (inlinineLine) {\n+                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n+                        return inlinees;\n+                    }\n+                } else {\n+                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n+                    if (nmethodLine) {\n+                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        Asserts.fail(\"Should have found inlinees\");\n+        return inlinees;\n+    }\n+\n+    protected void verifyLists(List<InlineEntry> inlineesNormal, List<InlineEntry> inlineesReplay, int expectedSize) {\n+        if (!inlineesNormal.equals(inlineesReplay)) {\n+            System.err.println(\"Normal entries:\");\n+            inlineesNormal.forEach(System.err::println);\n+            System.err.println(\"Replay entries:\");\n+            inlineesReplay.forEach(System.err::println);\n+            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n+        }\n+        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/InliningBase.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8254108\n+ * @library \/ \/test\/lib\n+ * @summary Testing of ciReplay with incremental inlining.\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" & vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.ciReplay.TestIncrementalInlining\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestIncrementalInlining extends InliningBase {\n+\n+    private List<InlineEntry> inlineesNormal;\n+    private List<InlineEntry> inlineesReplay;\n+    public static void main(String[] args) {\n+        new TestIncrementalInlining();\n+    }\n+\n+    TestIncrementalInlining() {\n+        super(IncrementalInliningTest.class);\n+        \/\/ Enable Whitebox access for test VM.\n+        commandLineNormal.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        commandLineNormal.add(\"-cp\");\n+        commandLineNormal.add(Utils.TEST_CLASS_PATH);\n+        commandLineNormal.add(\"-Xbootclasspath\/a:.\");\n+        commandLineNormal.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commandLineNormal.add(\"-XX:+WhiteBoxAPI\");\n+        commandLineNormal.add(\"-XX:MaxInlineLevel=2\");\n+        commandLineNormal.add(\"-XX:-AlwaysIncrementalInline\");\n+        runTest();\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        positiveTest(commandLineReplay);\n+        inlineesNormal = parseLogFile(LOG_FILE_NORMAL, getTestClass() + \" \" + \"test\", \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), 5);\n+        verify(true);\n+\n+        \/\/ Incremental inlining is supported in version 2+\n+        \/\/ Test replay file version 1.\n+        removeIncrementalInlineInfo();\n+        setNewVersionInReplayFile(1);\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+\n+        \/\/ Test replay file without version.\n+        removeVersionFromReplayFile();\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+    }\n+\n+    private void verify(boolean isNewFormat) {\n+        inlineesReplay = parseLogFile(LOG_FILE_REPLAY, getTestClass() + \" \" + \"test\", \"test ()V\", 5);\n+        verifyLists(inlineesNormal, inlineesReplay, 5);\n+        checkInlining(isNewFormat);\n+    }\n+\n+    \/\/ Check if inlining is done correctly in ciReplay.\n+    private void checkInlining(boolean isNewFormat) {\n+        String klass = getTestClass();\n+        Asserts.assertTrue(inlineesNormal.get(0).compare(klass, \"level0\", inlineesNormal.get(0).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(0).compare(klass, \"level0\", inlineesReplay.get(0).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(1).compare(klass, \"level1\", inlineesNormal.get(1).isNormalInline()));\n+        Asserts.assertTrue(inlineesReplay.get(1).compare(klass, \"level1\", inlineesReplay.get(1).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(2).compare(klass, \"level2\", inlineesNormal.get(2).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(2).compare(klass, \"level2\", inlineesReplay.get(2).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(3).compare(klass, \"late\", inlineesNormal.get(3).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(3).compare(klass, \"late\", isNewFormat ?\n+                inlineesReplay.get(3).isForcedIncrementalInlineByReplay()\n+                : inlineesReplay.get(3).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(4).compare(klass, \"level4\", inlineesNormal.get(4).isTooDeep()));\n+        Asserts.assertTrue(inlineesReplay.get(4).compare(klass, \"level4\", inlineesReplay.get(4).isDisallowedByReplay()));\n+    }\n+\n+    private void removeIncrementalInlineInfo() {\n+        try {\n+            Path replayFilePath = Paths.get(getReplayFileName());\n+            List<String> replayContent = Files.readAllLines(replayFilePath);\n+            for (int i = 0; i < replayContent.size(); i++) {\n+                String line = replayContent.get(i);\n+                if (line.startsWith(\"compile \")) {\n+                    int lastIndex = 0;\n+                    StringBuilder newLine = new StringBuilder();\n+                    Pattern p = Pattern.compile(\"(\\\\d (-?\\\\d)) \\\\d compiler\");\n+                    Matcher m = p.matcher(line);\n+                    boolean firstMatch = true;\n+                    while (m.find()) {\n+                        newLine.append(line, lastIndex, m.start())\n+                              .append(m.group(1))\n+                              .append(\" compiler\");\n+                        lastIndex = m.end();\n+                        String bci = m.group(2);\n+                        Asserts.assertTrue(firstMatch ? bci.equals(\"-1\") : bci.equals(\"0\"), \"only root has -1\");\n+                        firstMatch = false;\n+                    }\n+                    Asserts.assertLessThan(lastIndex, line.length(), \"not reached end of line, yet\");\n+                    newLine.append(line, lastIndex, line.length());\n+                    replayContent.set(i, newLine.toString());\n+                }\n+            }\n+            Files.write(replayFilePath, replayContent, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException ioe) {\n+            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n+        }\n+    }\n+}\n+\n+class IncrementalInliningTest {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static String s;\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level0\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level2\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"late\"), true);\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    private static void test() {\n+        level0();\n+    }\n+\n+    public static void level0() {\n+        level1();\n+    }\n+\n+    public static void level1() {\n+        level2();\n+    }\n+\n+    public static void level2() {\n+        late();\n+    }\n+\n+    \/\/ Reached max inline level but forced to be inlined -> inline late.\n+    public static void late() {\n+        level4();\n+    }\n+\n+    \/\/ Reached max inline level and not forced to be inlined -> no inline.\n+    public static void level4() {\n+        s = \"HelloWorld\";\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestIncrementalInlining.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -31,4 +31,1 @@\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      compiler.ciReplay.TestInliningProtectionDomain\n+ * @run driver compiler.ciReplay.TestInliningProtectionDomain\n@@ -41,4 +38,0 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n@@ -46,2 +39,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -49,6 +40,1 @@\n-public class TestInliningProtectionDomain extends DumpReplayBase {\n-    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n-    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n-    private final String[] commandLineReplay;\n-\n-    private final String className;\n+public class TestInliningProtectionDomain extends InliningBase {\n@@ -57,4 +43,4 @@\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestCompiledBefore\", true);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPublic\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivate\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivateString\", false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestCompiledBefore.class, true);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPublic.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivate.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivateString.class, false);\n@@ -63,5 +49,2 @@\n-    public TestInliningProtectionDomain(String className, boolean compileBar) {\n-        this.className = className;\n-        List<String> commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n-                                                           \"-XX:CompileCommand=exclude,\" + getTestClass() + \"::main\",\n-                                                           \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"));\n+    public TestInliningProtectionDomain(Class<?> testClass, boolean compileBar) {\n+        super(testClass);\n@@ -69,1 +52,1 @@\n-            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::bar\");\n+            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + testClass.getName() + \"::bar\");\n@@ -71,4 +54,1 @@\n-        commandLineReplay = new String[]\n-                {\"-XX:LogFile=\" + LOG_FILE_REPLAY + \"\", \"-XX:+LogCompilation\",\n-                 \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"};\n-        runTest(commandLineNormal.toArray(new String[0]));\n+        runTest();\n@@ -80,3 +60,2 @@\n-        String klass = \"compiler.ciReplay.\" + className;\n-        String entryString = klass + \" \" + \"test\";\n-        boolean inlineFails = className.equals(\"ProtectionDomainTestNoOtherCompilationPrivate\");\n+        String entryString = getTestClass() + \" \" + \"test\";\n+        boolean inlineFails = testClass == ProtectionDomainTestNoOtherCompilationPrivate.class;\n@@ -85,2 +64,2 @@\n-        List<Entry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n-        List<Entry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n@@ -90,4 +69,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n+            Asserts.assertTrue(inlineesNormal.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n+            Asserts.assertTrue(inlineesReplay.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n@@ -95,103 +72,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n-        }\n-        remove(LOG_FILE_NORMAL);\n-        remove(LOG_FILE_REPLAY);\n-    }\n-\n-    private void verifyLists(List<Entry> inlineesNormal, List<Entry> inlineesReplay, int expectedSize) {\n-        if (!inlineesNormal.equals(inlineesReplay)) {\n-            System.err.println(\"Normal entries:\");\n-            inlineesNormal.forEach(System.err::println);\n-            System.err.println(\"Replay entries:\");\n-            inlineesReplay.forEach(System.err::println);\n-            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n-        }\n-        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n-    }\n-\n-    public static boolean compare(Entry e, String klass, String method, boolean kind) {\n-        return e.klass.equals(klass) && e.method.equals(method) && kind;\n-    }\n-\n-    public static List<Entry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n-        String nmethodStart = \"<nmethod\";\n-        List<Entry> inlinees = new ArrayList<>();\n-        int foundLines = 0;\n-        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n-            String line;\n-            boolean nmethodLine = false;\n-            boolean inlinineLine = false;\n-            while ((line = br.readLine()) != null) {\n-                if (nmethodLine) {\n-                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n-                    if (line.startsWith(\"             \")) {\n-                        inlinineLine = true;\n-                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n-                        Matcher matcher = p.matcher(line);\n-                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n-                        inlinees.add(new Entry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n-                        foundLines++;\n-                    } else if (inlinineLine) {\n-                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n-                        return inlinees;\n-                    }\n-                } else {\n-                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n-                    if (nmethodLine) {\n-                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n-                    }\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n-        }\n-        Asserts.fail(\"Should have found inlinees\");\n-        return inlinees;\n-    }\n-\n-\n-    @Override\n-    public String getTestClass() {\n-        return \"compiler.ciReplay.\" + className;\n-    }\n-\n-    static class Entry {\n-        String klass;\n-        String method;\n-        String reason;\n-\n-        public Entry(String klass, String method, String reason) {\n-            this.klass = klass;\n-            this.method = method;\n-            this.reason = reason;\n-        }\n-\n-        public boolean isNormalInline() {\n-            return reason.equals(\"inline (hot)\");\n-        }\n-\n-        public boolean isForcedByReplay() {\n-            return reason.equals(\"force inline by ciReplay\");\n-        }\n-\n-        public boolean isDisallowedByReplay() {\n-            return reason.equals(\"disallowed by ciReplay\");\n-        }\n-\n-        public boolean isUnloadedSignatureClasses() {\n-            return reason.equals(\"unloaded signature classes\");\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (other == this) {\n-                return true;\n-            }\n-\n-            if (!(other instanceof Entry)) {\n-                return false;\n-            }\n-\n-            Entry e = (Entry)other;\n-            return klass.equals(e.klass) && method.equals(e.method);\n+            Asserts.assertTrue(inlineesNormal.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n+            Asserts.assertTrue(inlineesReplay.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":18,"deletions":142,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.lang.reflect.Field;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @bug 8276036 8277213 8277441\n+ * @summary test for the value of full_count in the message of insufficient codecache\n+ * @library \/test\/lib\n+ *\/\n+public class CodeCacheFullCountTest {\n+    public static void main(String args[]) throws Throwable {\n+        if (args.length == 1) {\n+            wasteCodeCache();\n+        } else {\n+            runTest();\n+        }\n+    }\n+\n+    public static void wasteCodeCache()  throws Exception {\n+        URL url = CodeCacheFullCountTest.class.getProtectionDomain().getCodeSource().getLocation();\n+\n+        for (int i = 0; i < 500; i++) {\n+            ClassLoader cl = new MyClassLoader(url);\n+            refClass(cl.loadClass(\"SomeClass\"));\n+        }\n+    }\n+\n+    public static void runTest() throws Throwable {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+          \"-XX:ReservedCodeCacheSize=2496k\", \"-XX:-UseCodeCacheFlushing\", \"CodeCacheFullCountTest\", \"WasteCodeCache\");\n+        OutputAnalyzer oa = ProcessTools.executeProcess(pb);\n+        oa.shouldHaveExitValue(0);\n+        String stdout = oa.getStdout();\n+\n+        Pattern pattern = Pattern.compile(\"full_count=(\\\\d)\");\n+        Matcher stdoutMatcher = pattern.matcher(stdout);\n+        if (stdoutMatcher.find()) {\n+            int fullCount = Integer.parseInt(stdoutMatcher.group(1));\n+            if (fullCount != 1) {\n+                throw new RuntimeException(\"the value of full_count is wrong.\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"codecache shortage did not occur.\");\n+        }\n+    }\n+\n+    private static void refClass(Class clazz) throws Exception {\n+        Field name = clazz.getDeclaredField(\"NAME\");\n+        name.setAccessible(true);\n+        name.get(null);\n+    }\n+\n+    private static class MyClassLoader extends URLClassLoader {\n+        public MyClassLoader(URL url) {\n+            super(new URL[]{url}, null);\n+        }\n+        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            try {\n+                return super.loadClass(name, resolve);\n+            } catch (ClassNotFoundException e) {\n+                return Class.forName(name, resolve, CodeCacheFullCountTest.class.getClassLoader());\n+            }\n+        }\n+    }\n+}\n+\n+abstract class Foo {\n+    public abstract int foo();\n+}\n+\n+class Foo1 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo2 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo3 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo4 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class SomeClass {\n+    static final String NAME = \"name\";\n+\n+    static {\n+        int res =0;\n+        Foo[] foos = new Foo[] { new Foo1(), new Foo2(), new Foo3(), new Foo4() };\n+        for (int i = 0; i < 100000; i++) {\n+            res = foos[i % foos.length].foo();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CodeCacheFullCountTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8275908\n+ * @summary Record null_check traps for calls and array_check traps in the interpreter\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.exceptions.OptimizeImplicitExceptions::throwImplicitException\n+ *                   compiler.exceptions.OptimizeImplicitExceptions\n+ *\/\n+\n+package compiler.exceptions;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class OptimizeImplicitExceptions {\n+    \/\/ ImplicitException represents the various implicit (aka. 'built-in') exceptions\n+    \/\/ which can be thrown implicitely by the JVM when executing bytecodes.\n+    public enum ImplicitException {\n+        \/\/ NullPointerException during field access\n+        NULL_POINTER_EXCEPTION(\"null_check\"),\n+        \/\/ NullPointerException during invoke\n+        INVOKE_NULL_POINTER_EXCEPTION(\"null_check\"),\n+        ARITHMETIC_EXCEPTION(\"div0_check\"),\n+        ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION(\"range_check\"),\n+        ARRAY_STORE_EXCEPTION(\"array_check\"),\n+        CLASS_CAST_EXCEPTION(\"class_check\");\n+        private final String reason;\n+        ImplicitException(String reason) {\n+            this.reason = reason;\n+        }\n+        public String getReason() {\n+            return reason;\n+        }\n+    }\n+    \/\/ TestMode represents a specific combination of the OmitStackTraceInFastThrow command line options.\n+    \/\/ They will be set up in 'setFlags(TestMode testMode)' before a new test run starts.\n+    public enum TestMode {\n+        OMIT_STACKTRACES_IN_FASTTHROW,\n+        STACKTRACES_IN_FASTTHROW\n+    }\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+    \/\/ The following variables are used to track the value of the global deopt counters between the various test phases.\n+    private static int oldDeoptCount = 0;\n+    private static HashMap<String, Integer> oldDeoptCountReason = new HashMap<String, Integer>(ImplicitException.values().length);\n+    \/\/ The following two objects are declared statically to simplify the test method.\n+    private static String[] string_a = new String[1];\n+    private static final Object o = new Object();\n+\n+    \/\/ This is the main test method. It will repeatedly called with the same ImplicitException 'type' to\n+    \/\/ JIT-compile it, deoptimized it, re-compile it again and do various checks on the way.\n+    \/\/ This process will be repeated then for each kind of ImplicitException 'type'.\n+    public static Object throwImplicitException(ImplicitException type, Object[] object_a) {\n+        switch (type) {\n+            case NULL_POINTER_EXCEPTION: {\n+                return object_a.length;\n+            }\n+            case INVOKE_NULL_POINTER_EXCEPTION: {\n+                return object_a.hashCode();\n+            }\n+            case ARITHMETIC_EXCEPTION: {\n+                return ((42 \/ (object_a.length - 1)) > 2) ? null : object_a[0];\n+            }\n+            case ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION: {\n+                return object_a[5];\n+            }\n+            case ARRAY_STORE_EXCEPTION: {\n+                return (object_a[0] = o);\n+            }\n+            case CLASS_CAST_EXCEPTION: {\n+                return (ImplicitException[])object_a;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Completely unload (i.e. make \"not-entrant\"->\"zombie\"->\"unload\/free\") a JIT-compiled\n+    \/\/ version of a method and clear the method's profiling counters.\n+    private static void unloadAndClean(Method m) {\n+        WB.deoptimizeMethod(m);  \/\/ Makes the nmethod \"not entrant\".\n+        WB.forceNMethodSweep();  \/\/ Makes all \"not entrant\" nmethods \"zombie\". This requires\n+        WB.forceNMethodSweep();  \/\/ two sweeps, see 'nmethod::can_convert_to_zombie()' for why.\n+        WB.forceNMethodSweep();  \/\/ Need third sweep to actually unload\/free all \"zombie\" nmethods.\n+        System.gc();\n+        WB.clearMethodState(m);\n+    }\n+\n+    \/\/ Set '-XX' flags according to 'TestMode'\n+    private static void setFlags(TestMode testMode) {\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", true);\n+        } else {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", false);\n+        }\n+\n+        System.out.println(\"==========================================================\");\n+        System.out.println(\"testMode=\" + testMode +\n+                           \" OmitStackTraceInFastThrow=\" + WB.getBooleanVMFlag(\"OmitStackTraceInFastThrow\"));\n+        System.out.println(\"==========================================================\");\n+    }\n+\n+    private static void printCounters(TestMode testMode, ImplicitException impExcp, Method throwImplicitException_m, int invocations) {\n+        System.out.println(\"testMode=\" + testMode + \" exception=\" + impExcp + \" invocations=\" + invocations + \"\\n\" +\n+                           \"decompilecount=\" + WB.getMethodDecompileCount(throwImplicitException_m) + \" \" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(throwImplicitException_m) + \" \" +\n+                           \"trapCount(\" + impExcp.getReason() + \")=\" +\n+                           WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason()) + \" \" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(\" + impExcp.getReason() + \")=\" + WB.getDeoptCount(impExcp.getReason(), null));\n+        System.out.println(\"method compiled=\" + WB.isMethodCompiled(throwImplicitException_m));\n+    }\n+\n+    \/\/ Checks after the test method has been JIT-compiled but before the compiled version has been invoked.\n+    private static void checkSimple(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n+        \/\/ At this point, throwImplicitException() has been compiled but the compiled version has not been invoked yet.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+\n+        int trapCount = WB.getMethodTrapCount(throwImplicitException_m);\n+        int trapCountSpecific = WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason());\n+        Asserts.assertEQ(trapCount, invocations, \"Trap count must much invocation count.\");\n+        Asserts.assertEQ(trapCountSpecific, invocations, \"Trap count must much invocation count.\");\n+        Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+    }\n+\n+    \/\/ Checks after the JIT-compiled test method has been invoked 'invocations' times.\n+    private static void check(TestMode testMode, ImplicitException impExcp, Exception ex,\n+                              Method throwImplicitException_m, int invocations, int totalInvocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, totalInvocations);\n+        \/\/ At this point, the compiled version of 'throwImplicitException()' has been invoked 'invocations' times.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+        int deoptCount = WB.getDeoptCount();\n+        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n+            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow'\n+            Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n+            \/\/ '-XX:+OmitStackTraceInFastThrow' never has message because it is using a global singleton exception.\n+            Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n+        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n+            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow\n+            Asserts.assertEQ(oldDeoptCount + invocations, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + invocations, deoptCountReason, \"Wrong number of deoptimizations.\");\n+            Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+        } else {\n+            Asserts.fail(\"Unknown test mode.\");\n+        }\n+        oldDeoptCount = deoptCount;\n+        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!WB.getBooleanVMFlag(\"ProfileTraps\")) {\n+            \/\/ The fast-throw optimzation only works if we're running with -XX:+ProfileTraps\n+            return;\n+        }\n+\n+        \/\/ Initialize global deopt counts to zero.\n+        for (ImplicitException impExcp : ImplicitException.values()) {\n+            oldDeoptCountReason.put(impExcp.getReason(), 0);\n+        }\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method throwImplicitException_m = OptimizeImplicitExceptions.class\n+            .getDeclaredMethod(\"throwImplicitException\", new Class[] { ImplicitException.class, Object[].class});\n+\n+        for (TestMode testMode : TestMode.values()) {\n+            setFlags(testMode);\n+            for (ImplicitException impExcp : ImplicitException.values()) {\n+                int invocations = 0;\n+                Exception lastException = null;\n+\n+                \/\/ Warmup and compile, but don't invoke compiled code.\n+                while(!WB.isMethodCompiled(throwImplicitException_m)) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                checkSimple(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+\n+                \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times.\n+                for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                check(testMode, impExcp, lastException, throwImplicitException_m, PerBytecodeTrapLimit, invocations);\n+\n+                \/\/ Invoke compiled code 'Tier0InvokeNotifyFreq' times.\n+                \/\/ If the method was de-compiled before, this will re-compile it again.\n+                for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                check(testMode, impExcp, lastException, throwImplicitException_m, Tier0InvokeNotifyFreq, invocations);\n+\n+                \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times.\n+                for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                check(testMode, impExcp, lastException, throwImplicitException_m, PerBytecodeTrapLimit, invocations);\n+\n+                System.out.println(\"------------------------------------------------------------------\");\n+\n+                unloadAndClean(throwImplicitException_m);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275330\n+ * @summary C2: assert(n->is_Root() || n->is_Region() || n->is_Phi() || n->is_MachMerge() || def_block->dominates(block)) failed: uses must be dominated by definitions\n+ *\n+ * @run main\/othervm -Xmx512m -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:CompileOnly=TestDeadPostLoopBecausePredicate TestDeadPostLoopBecausePredicate\n+ *\n+ *\/\n+\n+\n+public class TestDeadPostLoopBecausePredicate {\n+\n+    public static final int N = 400;\n+\n+    public static int iFld=54270;\n+    public static int iFld1=-4;\n+    public int iFld2=201;\n+\n+    public int mainTest(String[] strArr1) {\n+\n+        int i=0, i17=8052, i19=22380, i20=60894, iArr[]=new int[N];\n+        init(iArr, 4);\n+\n+        i = 1;\n+        do {\n+            for (i17 = 5; i17 < 114; i17++) {\n+                switch ((i17 % 7) + 126) {\n+                case 126:\n+                    for (i19 = 2; i19 > i; i19 -= 3) {\n+                        try {\n+                            i20 = (iFld2 % TestDeadPostLoopBecausePredicate.iFld1);\n+                            i20 = (iArr[i19 - 1] % TestDeadPostLoopBecausePredicate.iFld);\n+                            TestDeadPostLoopBecausePredicate.iFld = (TestDeadPostLoopBecausePredicate.iFld1 % iArr[i19]);\n+                        } catch (ArithmeticException a_e) {}\n+                    }\n+                    break;\n+                }\n+            }\n+        } while (++i < 220);\n+\n+        return i20;\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDeadPostLoopBecausePredicate _instance = new TestDeadPostLoopBecausePredicate();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadPostLoopBecausePredicate.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -90,1 +90,2 @@\n-            checkFinalFlagsEqualTo(ProcessTools.createJavaProcessBuilder(\"-XX:+PrintFlagsFinal\", \"-version\"), \"isb\", \"1\");\n+            checkFinalFlagsEqualTo(ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintFlagsFinal\", \"-version\"),\n+                \"isb\", \"1\");\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64DefaultFlags.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8275908\n+ * @summary Quick test for the new WhiteBox methods of JDK-8275908\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.uncommontrap.Decompile::uncommonTrap\n+ *                   -XX:CompileCommand=inline,compiler.uncommontrap.Decompile*::foo\n+ *                   compiler.uncommontrap.Decompile\n+ *\/\n+\n+package compiler.uncommontrap;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Decompile {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+    \/\/ VM builds without JVMCI like x86_32 call the bimorphic inlining trap just 'bimorphic'\n+    \/\/ while all the other builds with JVMCI call it 'bimorphic_or_optimized_type_check'.\n+    \/\/ Only builds with JVMCI have the \"EnableJVMCI\" flag.\n+    private static final boolean isJVMCISupported = (WB.getBooleanVMFlag(\"EnableJVMCI\") != null);\n+    private static final String bimorphicTrapName = isJVMCISupported ? \"bimorphic_or_optimized_type_check\" : \"bimorphic\";\n+\n+    static class Base {\n+        void foo() {}\n+    }\n+    static class X extends Base {\n+        void foo() {}\n+    }\n+    static class Y extends Base {\n+        void foo() {}\n+    }\n+\n+    static void uncommonTrap(Base t) {\n+        t.foo();\n+    }\n+\n+    private static void printCounters(Method uncommonTrap_m, int invocations) {\n+        System.out.println(\"-----------------------------------------------------------------\");\n+        System.out.println(\"invocations=\" + invocations + \" \" +\n+                           \"method compiled=\" + WB.isMethodCompiled(uncommonTrap_m) + \" \" +\n+                           \"decompileCount=\" + WB.getMethodDecompileCount(uncommonTrap_m) + \"\\n\" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(uncommonTrap_m) + \" \" +\n+                           \"trapCount(class_check)=\" + WB.getMethodTrapCount(uncommonTrap_m, \"class_check\") + \" \" +\n+                           \"trapCount(\" + bimorphicTrapName + \")=\" +\n+                           WB.getMethodTrapCount(uncommonTrap_m, bimorphicTrapName) + \"\\n\" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(class_check)=\" + WB.getDeoptCount(\"class_check\", null) + \" \" +\n+                           \"globalDeoptCount(\" + bimorphicTrapName + \")=\" +\n+                           WB.getDeoptCount(bimorphicTrapName, null));\n+        System.out.println(\"-----------------------------------------------------------------\");\n+    }\n+\n+    private static void check(Method uncommonTrap_m, int invocations, boolean isCompiled, int decompileCount,\n+                              int trapCount, int trapCountClassCheck, int trapCountBimorphic,\n+                              int deoptCount, int deoptCountClassCheck, int deoptCountBimorphic) {\n+\n+        printCounters(uncommonTrap_m, invocations);\n+\n+        Asserts.assertEQ(isCompiled, WB.isMethodCompiled(uncommonTrap_m),\n+                         \"Wrong compilation status.\");\n+        Asserts.assertEQ(decompileCount, WB.getMethodDecompileCount(uncommonTrap_m),\n+                         \"Wrong number of decompilations.\");\n+        Asserts.assertEQ(trapCount, WB.getMethodTrapCount(uncommonTrap_m),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountClassCheck, WB.getMethodTrapCount(uncommonTrap_m, \"class_check\"),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountBimorphic, WB.getMethodTrapCount(uncommonTrap_m, bimorphicTrapName),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(deoptCount, WB.getDeoptCount(),\n+                         \"Wrong number of deoptimizations.\");\n+        Asserts.assertEQ(deoptCountClassCheck, WB.getDeoptCount(\"class_check\", null),\n+                         \"Wrong number of class_check deoptimizations.\");\n+        Asserts.assertEQ(deoptCountBimorphic, WB.getDeoptCount(bimorphicTrapName, null),\n+                         \"Wrong number of \" + bimorphicTrapName + \"deoptimizations.\");\n+    }\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method uncommonTrap_m = Decompile.class\n+            .getDeclaredMethod(\"uncommonTrap\", new Class[] { Base.class });\n+\n+        int invocations = 0;\n+        Base b = new Base();\n+        \/\/ This is a little tricky :) We have to define 'x' already here otherwise\n+        \/\/ the class 'X' won't be loaded and 'uncommonTrap()' will be compiled without\n+        \/\/ a class check but a CHA dependency that class 'B' has no subtypes.\n+        X x = new X();\n+        Y y = new Y();\n+\n+        \/\/ Warmup and compile with an object of type 'Base' as receiver, but don't invoke compiled code.\n+        while(!WB.isMethodCompiled(uncommonTrap_m)) {\n+            invocations++;\n+            uncommonTrap(b);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 0 \/* decompileCount *\/,\n+              0 \/* trapCount  *\/, 0 \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              0 \/* deoptCount *\/, 0 \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'X'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke the method 'Tier0InvokeNotifyFreq' more times with an receiver object of type 'X'.\n+        \/\/ This should re-compile the method again with bimorphic inlining for receiver types 'Base' and 'X'.\n+        for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'Y'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(y);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 2 \/* decompileCount *\/,\n+              2*PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, PerBytecodeTrapLimit \/* trapCountBimorphic  *\/,\n+              2*PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, PerBytecodeTrapLimit \/* deoptCountBimorphic *\/);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/Decompile.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -145,0 +145,1 @@\n+        new LogMessageWithLevel(\"Found Roots\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -45,3 +46,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -54,1 +52,1 @@\n-    final static CLinker abi = CLinker.getInstance();\n+    final static CLinker abi = CLinker.systemCLinker();\n@@ -57,2 +55,1 @@\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+            FunctionDescriptor.of(ValueLayout.JAVA_INT));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,6 +44,2 @@\n-      try {\n-        output.shouldContain(\"PrintTouchedMethodsJcmd.main:([Ljava\/lang\/String;)V\");\n-      } catch (RuntimeException e) {\n-        output.shouldContain(\"Unknown diagnostic command\");\n-      }\n-  }\n+      output.shouldContain(\"PrintTouchedMethodsJcmd.main:([Ljava\/lang\/String;)V\");\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/PrintTouchedMethodsJcmd.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+                \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n+                \/\/ deflations when 10% of monitors are used rather than the\n+                \/\/ default 90%. This should allow the test to tolerate a burst\n+                \/\/ of used monitors by threads not under this test's control.\n+                \"-XX:MonitorUsedDeflationThreshold=10\",\n@@ -92,2 +97,3 @@\n-                \/\/ reproduced the bug with JDK13. Anything above the\n-                \/\/ in_use_list_ceiling will do the trick.\n+                \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n+                \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n+                \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n@@ -114,0 +120,2 @@\n+            \/\/ Uncomment the following line for dumping test output in passing runs:\n+            \/\/ output_detail.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUsedDeflationThresholdTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        pbArgs.add(\"-XX:-CreateCoredumpOnCrash\");\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies that a VMObjectAlloc event is generated for object created using MethodHandle\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:VMObjectAlloc VMObjectAllocTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class VMObjectAllocTest {\n+\n+    private static native int getNumberOfAllocation();\n+\n+    public VMObjectAllocTest(String str) {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        MethodType mt = MethodType.methodType(void.class, String.class);\n+        MethodHandle mh = publicLookup.findConstructor(VMObjectAllocTest.class, mt);\n+        mh.invoke(\"str\");\n+\n+        if (getNumberOfAllocation() != 1) {\n+            throw new Exception(\"Number of allocation != 1\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/VMObjectAllocTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+extern \"C\" {\n+\n+static int number_of_allocation = 0;\n+\n+extern JNIEXPORT void JNICALL\n+VMObjectAlloc(jvmtiEnv *jvmti,\n+              JNIEnv* jni,\n+              jthread thread,\n+              jobject object,\n+              jclass cls,\n+              jlong size) {\n+  char *signature = NULL;\n+  jvmtiError err = jvmti->GetClassSignature(cls, &signature, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni->FatalError(\"Failed during the GetClassSignature call\");\n+  }\n+\n+  printf(\"VMObjectAlloc called for %s\\n\", signature);\n+\n+  if (!strcmp(signature, \"LVMObjectAllocTest;\")) {\n+    number_of_allocation++;\n+  }\n+}\n+\n+\n+JNIEXPORT jint JNICALL\n+Java_VMObjectAllocTest_getNumberOfAllocation(JNIEnv *env, jclass cls) {\n+  return number_of_allocation;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jvmtiCapabilities caps;\n+\n+  if (jvm->GetEnv((void **) &jvmti, JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VMObjectAlloc = &VMObjectAlloc;\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_vm_object_alloc_events = 1;\n+\n+  err = jvmti->AddCapabilities( &caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC , NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+} \/\/extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * In this test a 1000 classes are loaded and unloaded in a loop.\n+ * In this test 1000 classes are loaded and unloaded in a loop.\n@@ -33,1 +33,1 @@\n- * the way uptill class1000.  The classes should be unloaded whenever a\n+ * the way up to class1000.  The classes should be unloaded whenever a\n@@ -35,1 +35,1 @@\n- * at the end of the each loop iteration. The loop is repeated 1000 times.\n+ * at the end of each loop iteration. The loop is repeated 1000 times.\n@@ -48,0 +48,24 @@\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM Testbase gc\/gctests\/LoadUnloadGC.\n+ * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, monitoring]\n+ * VM Testbase readme:\n+ * In this test 1000 classes are loaded and unloaded in a loop.\n+ * Class0 gets loaded which results in Class1 getting loaded and so on all\n+ * the way up to class1000.  The classes should be unloaded whenever a\n+ * garbage collection takes place because their classloader is made unreachable\n+ * at the end of each loop iteration. The loop is repeated 1000 times.\n+ *\n+ * @requires vm.opt.final.ClassUnloading\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.share.gc.ClassChain\n+ * @run main\/othervm\n+ *      -XX:MaxMetaspaceSize=64M\n+ *      -XX:MetaspaceSize=64M\n+ *      -XX:CompressedClassSpaceSize=32M\n+ *      gc.gctests.LoadUnloadGC.LoadUnloadGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LoadUnloadGC\/LoadUnloadGC.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,2 @@\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -66,1 +68,2 @@\n- *      -debugee.vmkeys=\"-Xmx256M ${test.vm.opts} ${test.java.opts}\"\n+ *      -debugee.vmkeys=\"-Xmx256M -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                       -XX:+WhiteBoxAPI  ${test.vm.opts} ${test.java.opts}\"\n@@ -100,0 +103,4 @@\n+        log.display(\"References:\");\n+        for (ObjectReference ref: classObjectReference.referringObjects(0)) {\n+            log.display(ref);\n+        }\n@@ -140,1 +147,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -59,0 +60,2 @@\n+    private final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n@@ -79,0 +82,3 @@\n+        \/\/ force full GC with WB to ensure that weak refernces are collected\n+        \/\/ j.l.i.MethodType has ConcurrentWeakInternSet which might contain references to TestClass1\n+        WB.fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002a.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,8 +141,0 @@\n-\/* ============================================================================= *\/\n-static void set_agent_thread_state(thread_state_t value) {\n-    rawMonitorEnter(jvmti_env, agent_data.monitor);\n-    agent_data.thread_state = value;\n-    rawMonitorNotify(jvmti_env, agent_data.monitor);\n-    rawMonitorExit(jvmti_env, agent_data.monitor);\n-}\n-\n@@ -154,3 +146,4 @@\n-    \/* run user agent proc *\/\n-    {\n-        set_agent_thread_state(RUNNABLE);\n+    rawMonitorEnter(jvmti_env, agent_data.monitor);\n+    agent_data.thread_state = RUNNABLE;\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+    rawMonitorExit(jvmti_env, agent_data.monitor);\n@@ -158,1 +151,1 @@\n-        NSK_TRACE((*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg));\n+    NSK_TRACE((*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg));\n@@ -160,2 +153,6 @@\n-        set_agent_thread_state(TERMINATED);\n-    }\n+    rawMonitorEnter(jvmti_env, agent_data.monitor);\n+    agent_data.thread_state = TERMINATED;\n+    agentJNI->DeleteGlobalRef(agentThread);\n+    agentThread = NULL;\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+    rawMonitorExit(jvmti_env, agent_data.monitor);\n@@ -163,6 +160,0 @@\n-    \/* finalize agent thread *\/\n-    {\n-        \/* gelete global ref for agent thread *\/\n-        agentJNI->DeleteGlobalRef(agentThread);\n-        agentThread = NULL;\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/agent_tools.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        if (!\"Java heap space\".equals(message)) {\n+        if (!message.startsWith(\"Java heap space\")) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -29,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,0 +37,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -43,1 +48,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -48,1 +52,3 @@\n-    static SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+    static SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new UnsupportedOperationException();\n+    };\n@@ -61,1 +67,1 @@\n-                VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n+                VarHandle vh = g.varHandle(MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n@@ -413,1 +419,1 @@\n-            VarHandle accessor = g.varHandle(structFieldCarrier(l), MemoryLayout.PathElement.groupElement(l.name().get()));\n+            VarHandle accessor = g.varHandle(MemoryLayout.PathElement.groupElement(l.name().get()));\n@@ -416,3 +422,0 @@\n-            if (isPointer(l)) {\n-                value = ((MemoryAddress)value).toRawLongValue();\n-            }\n@@ -427,5 +430,1 @@\n-                        if (isPointer(l)) {\n-                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual)));\n-                        } else {\n-                            fieldsCheck.get(0).accept(accessor.get(actual));\n-                        }\n+                        fieldsCheck.get(0).accept(accessor.get(actual));\n@@ -440,17 +439,1 @@\n-    static Class<?> structFieldCarrier(MemoryLayout layout) {\n-        if (isPointer(layout)) {\n-            return long.class;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            } else {\n-                return double.class;\n-            }\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n-    static Class<?> paramCarrier(MemoryLayout layout) {\n+    static Class<?> carrier(MemoryLayout layout, boolean param) {\n@@ -460,9 +443,3 @@\n-            return MemoryAddress.class;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            } else {\n-                return double.class;\n-            }\n+            return param ? Addressable.class : MemoryAddress.class;\n+        } else if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n@@ -473,0 +450,8 @@\n+\n+    MethodHandle downcallHandle(CLinker abi, NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+        MethodHandle mh = abi.downcallHandle(symbol, descriptor);\n+        if (descriptor.returnLayout().isPresent() && descriptor.returnLayout().get() instanceof GroupLayout) {\n+            mh = mh.bindTo(allocator);\n+        }\n+        return mh;\n+    }\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":23,"deletions":38,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -26,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,0 +33,3 @@\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n@@ -33,3 +39,2 @@\n-    static CLinker.TypeKind kind(MemoryLayout layout) {\n-        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+    public static boolean isIntegral(MemoryLayout layout) {\n+        return layout instanceof ValueLayout valueLayout && isIntegral(valueLayout.carrier());\n@@ -38,2 +43,3 @@\n-    public static boolean isIntegral(MemoryLayout layout) {\n-        return kind(layout).isIntegral();\n+    static boolean isIntegral(Class<?> clazz) {\n+        return clazz == byte.class || clazz == char.class || clazz == short.class\n+                || clazz == int.class || clazz == long.class;\n@@ -43,1 +49,1 @@\n-        return kind(layout).isPointer();\n+        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class;\n@@ -46,4 +52,1 @@\n-    public static class NativeScope implements SegmentAllocator, AutoCloseable {\n-        final ResourceScope resourceScope;\n-        final ResourceScope.Handle scopeHandle;\n-        final SegmentAllocator allocator;\n+    \/\/ the constants below are useful aliases for C types. The type\/carrier association is only valid for 64-bit platforms.\n@@ -51,1 +54,16 @@\n-        long allocatedBytes = 0;\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -53,5 +71,16 @@\n-        public NativeScope() {\n-            this.resourceScope = ResourceScope.newConfinedScope();\n-            this.scopeHandle = resourceScope.acquire();\n-            this.allocator = SegmentAllocator.arenaAllocator(resourceScope);\n-        }\n+    \/**\n+     * The layout for the {@code long long} C type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -59,5 +88,1 @@\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            allocatedBytes += bytesSize;\n-            return allocator.allocate(bytesSize, bytesAlignment);\n-        }\n+    private static CLinker LINKER = CLinker.systemCLinker();\n@@ -65,3 +90,2 @@\n-        public ResourceScope scope() {\n-            return resourceScope;\n-        }\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -69,2 +93,8 @@\n-        public long allocatedBytes() {\n-            return allocatedBytes;\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n@@ -72,0 +102,1 @@\n+    }\n@@ -73,4 +104,5 @@\n-        @Override\n-        public void close() {\n-            resourceScope.release(scopeHandle);\n-            resourceScope.close();\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":62,"deletions":30,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -32,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -39,0 +40,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -41,0 +43,1 @@\n+import jdk.incubator.foreign.VaList;\n@@ -42,0 +45,1 @@\n+\n@@ -44,1 +48,1 @@\n-public class SafeFunctionAccessTest {\n+public class SafeFunctionAccessTest extends NativeTestHelper {\n@@ -50,1 +54,1 @@\n-            CLinker.C_INT, CLinker.C_INT\n+            C_INT, C_INT\n@@ -62,1 +66,1 @@\n-        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n@@ -64,1 +68,0 @@\n-                MethodType.methodType(void.class, MemorySegment.class),\n@@ -70,0 +73,37 @@\n+    @Test\n+    public void testClosedStructAddr_6() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_6\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        for (int i = 0 ; i < 6 ; i++) {\n+            MemorySegment[] segments = new MemorySegment[]{\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope())\n+            };\n+            \/\/ check liveness\n+            segments[i].scope().close();\n+            for (int j = 0 ; j < 6 ; j++) {\n+                if (i == j) {\n+                    assertFalse(segments[j].scope().isAlive());\n+                } else {\n+                    assertTrue(segments[j].scope().isAlive());\n+                }\n+            }\n+            try {\n+                handle.invokeWithArguments(segments);\n+                fail();\n+            } catch (IllegalStateException ex) {\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n+            }\n+            for (int j = 0 ; j < 6 ; j++) {\n+                if (i != j) {\n+                    segments[j].scope().close(); \/\/ should succeed!\n+                }\n+            }\n+        }\n+    }\n+\n@@ -71,2 +111,2 @@\n-    public void testClosedPointer() throws Throwable {\n-        MemoryAddress address;\n+    public void testClosedVaList() throws Throwable {\n+        VaList list;\n@@ -74,1 +114,1 @@\n-            address = MemorySegment.allocateNative(POINT, scope).address();\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n@@ -76,2 +116,2 @@\n-        assertFalse(address.scope().isAlive());\n-        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+        assertFalse(list.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n@@ -79,2 +119,1 @@\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(CLinker.C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER));\n@@ -82,1 +121,75 @@\n-        handle.invokeExact(address);\n+        handle.invokeExact((Addressable)list);\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedUpcall() throws Throwable {\n+        NativeSymbol upcall;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+        }\n+        assertFalse(upcall.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER));\n+\n+        handle.invokeExact((Addressable)upcall);\n+    }\n+\n+    static void dummy() { }\n+\n+    @Test\n+    public void testClosedVaListCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n+            handle.invoke(list, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedStructCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(POINT, scope);\n+            handle.invoke(segment, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedUpcallCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+            handle.invoke(upcall, scopeChecker(scope));\n+        }\n+    }\n+\n+    NativeSymbol scopeChecker(ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkScope\",\n+                    MethodType.methodType(void.class, ResourceScope.class));\n+            handle = handle.bindTo(scope);\n+            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static void checkScope(ResourceScope scope) {\n+        try {\n+            scope.close();\n+            fail(\"Scope closed unexpectedly!\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"kept alive\")); \/\/if acquired, fine\n+        }\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":126,"deletions":13,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Optional;\n@@ -51,2 +50,0 @@\n-import static jdk.incubator.foreign.MemoryAccess.*;\n-\n@@ -55,1 +52,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -59,1 +55,1 @@\n-public class StdLibTest {\n+public class StdLibTest extends NativeTestHelper {\n@@ -61,1 +57,1 @@\n-    final static CLinker abi = CLinker.getInstance();\n+    final static CLinker abi = CLinker.systemCLinker();\n@@ -158,5 +154,3 @@\n-        static final SymbolLookup LOOKUP = CLinker.systemLookup();\n-\n-        final static MethodHandle strcat = abi.downcallHandle(LOOKUP.lookup(\"strcat\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n+        final static MethodHandle strcat = abi.downcallHandle(abi.lookup(\"strcat\").get(),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER))\n+                .asType(MethodType.methodType(MemoryAddress.class, MemorySegment.class, MemorySegment.class)); \/\/ exact signature match\n@@ -164,2 +158,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(LOOKUP.lookup(\"strcmp\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle strcmp = abi.downcallHandle(abi.lookup(\"strcmp\").get(),\n@@ -168,2 +161,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(LOOKUP.lookup(\"puts\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        final static MethodHandle puts = abi.downcallHandle(abi.lookup(\"puts\").get(),\n@@ -172,2 +164,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(LOOKUP.lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        final static MethodHandle strlen = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -176,2 +167,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(LOOKUP.lookup(\"gmtime\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle gmtime = abi.downcallHandle(abi.lookup(\"gmtime\").get(),\n@@ -180,2 +170,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(LOOKUP.lookup(\"qsort\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+        final static MethodHandle qsort = abi.downcallHandle(abi.lookup(\"qsort\").get(),\n@@ -188,2 +177,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(LOOKUP.lookup(\"rand\").get(),\n-                MethodType.methodType(int.class),\n+        final static MethodHandle rand = abi.downcallHandle(abi.lookup(\"rand\").get(),\n@@ -192,3 +180,2 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(LOOKUP.lookup(\"vprintf\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+        final static MethodHandle vprintf = abi.downcallHandle(abi.lookup(\"vprintf\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));\n@@ -196,1 +183,1 @@\n-        final static MemoryAddress printfAddr = LOOKUP.lookup(\"printf\").get();\n+        final static NativeSymbol printfAddr = abi.lookup(\"printf\").get();\n@@ -204,1 +191,1 @@\n-                        MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));\n+                        CLinker.upcallType(qsortComparFunction));\n@@ -212,8 +199,5 @@\n-                MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1, scope);\n-                MemorySegment other = toCString(s2, scope);\n-                char[] chars = s1.toCharArray();\n-                for (long i = 0 ; i < chars.length ; i++) {\n-                    setByteAtOffset(buf, i, (byte)chars[(int)i]);\n-                }\n-                setByteAtOffset(buf, chars.length, (byte)'\\0');\n-                return toJavaString(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment buf = malloc.allocate(s1.length() + s2.length() + 1);\n+                buf.setUtf8String(0, s1);\n+                MemorySegment other = malloc.allocateUtf8String(s2);\n+                return ((MemoryAddress)strcat.invokeExact(buf, other)).getUtf8String(0);\n@@ -225,3 +209,4 @@\n-                MemorySegment ns1 = toCString(s1, scope);\n-                MemorySegment ns2 = toCString(s2, scope);\n-                return (int)strcmp.invokeExact(ns1.address(), ns2.address());\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment ns1 = malloc.allocateUtf8String(s1);\n+                MemorySegment ns2 = malloc.allocateUtf8String(s2);\n+                return (int)strcmp.invoke(ns1, ns2);\n@@ -233,2 +218,3 @@\n-                MemorySegment s = toCString(msg, scope);\n-                return (int)puts.invokeExact(s.address());\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment s = malloc.allocateUtf8String(msg);\n+                return (int)puts.invoke(s);\n@@ -240,2 +226,3 @@\n-                MemorySegment s = toCString(msg, scope);\n-                return (int)strlen.invokeExact(s.address());\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment s = malloc.allocateUtf8String(msg);\n+                return (int)strlen.invoke(s);\n@@ -248,2 +235,2 @@\n-                setLong(time, arg);\n-                return new Tm((MemoryAddress)gmtime.invokeExact(time.address()));\n+                time.set(C_LONG_LONG, 0, arg);\n+                return new Tm((MemoryAddress)gmtime.invoke(time));\n@@ -261,1 +248,1 @@\n-                this.base = addr.asSegment(SIZE, ResourceScope.globalScope());\n+                this.base = MemorySegment.ofAddress(addr, SIZE, ResourceScope.globalScope());\n@@ -265,1 +252,1 @@\n-                return getIntAtOffset(base, 0);\n+                return base.get(C_INT, 0);\n@@ -268,1 +255,1 @@\n-                return getIntAtOffset(base, 4);\n+                return base.get(C_INT, 4);\n@@ -271,1 +258,1 @@\n-                return getIntAtOffset(base, 8);\n+                return base.get(C_INT, 8);\n@@ -274,1 +261,1 @@\n-                return getIntAtOffset(base, 12);\n+                return base.get(C_INT, 12);\n@@ -277,1 +264,1 @@\n-                return getIntAtOffset(base, 16);\n+                return base.get(C_INT, 16);\n@@ -280,1 +267,1 @@\n-                return getIntAtOffset(base, 20);\n+                return base.get(C_INT, 20);\n@@ -283,1 +270,1 @@\n-                return getIntAtOffset(base, 24);\n+                return base.get(C_INT, 24);\n@@ -286,1 +273,1 @@\n-                return getIntAtOffset(base, 28);\n+                return base.get(C_INT, 28);\n@@ -289,2 +276,1 @@\n-                byte b = getByteAtOffset(base, 32);\n-                return b != 0;\n+                return base.get(C_BOOL, 32);\n@@ -297,2 +283,2 @@\n-                SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment nativeArr = malloc.allocateArray(C_INT, arr);\n@@ -301,1 +287,1 @@\n-                MemoryAddress qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n+                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n@@ -303,1 +289,1 @@\n-                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                qsort.invoke(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n@@ -306,1 +292,1 @@\n-                return nativeArr.toIntArray();\n+                return nativeArr.toArray(C_INT);\n@@ -310,3 +296,3 @@\n-        static int qsortCompare(MemorySegment base, MemoryAddress addr1, MemoryAddress addr2) {\n-            return getIntAtOffset(base, addr1.segmentOffset(base)) -\n-                   getIntAtOffset(base, addr2.segmentOffset(base));\n+        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+            return addr1.get(C_INT, 0) -\n+                   addr2.get(C_INT, 0);\n@@ -321,2 +307,3 @@\n-                MemorySegment formatStr = toCString(format, scope);\n-                return (int)specializedPrintf(args).invokeExact(formatStr.address(),\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment formatStr = malloc.allocateUtf8String(format);\n+                return (int)specializedPrintf(args).invoke(formatStr,\n@@ -329,1 +316,2 @@\n-                MemorySegment formatStr = toCString(format, scope);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment formatStr = malloc.allocateUtf8String(format);\n@@ -331,1 +319,1 @@\n-                return (int)vprintf.invokeExact(formatStr.address(), vaList);\n+                return (int)vprintf.invoke(formatStr, vaList);\n@@ -339,0 +327,1 @@\n+            List<MemoryLayout> variadicLayouts = new ArrayList<>(args.size());\n@@ -341,1 +330,1 @@\n-                fd = fd.withAppendedArgumentLayouts(arg.layout);\n+                variadicLayouts.add(arg.layout);\n@@ -343,1 +332,2 @@\n-            MethodHandle mh = abi.downcallHandle(printfAddr, mt, fd);\n+            MethodHandle mh = abi.downcallHandle(printfAddr,\n+                    fd.asVariadic(variadicLayouts.toArray(new MemoryLayout[args.size()])));\n@@ -404,4 +394,8 @@\n-        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", scope -> 42, 42, VaList.Builder::vargFromInt),\n-        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", scope -> toCString(\"str\", scope).address(), \"str\", VaList.Builder::vargFromAddress),\n-        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n-        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n+        INTEGRAL(int.class, C_INT, \"%d\", scope -> 42, 42, VaList.Builder::addVarg),\n+        STRING(MemoryAddress.class, C_POINTER, \"%s\", scope -> {\n+            var segment = MemorySegment.allocateNative(4, scope);\n+            segment.setUtf8String(0, \"str\");\n+            return segment.address();\n+        }, \"str\", VaList.Builder::addVarg),\n+        CHAR(byte.class, C_CHAR, \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n@@ -417,1 +411,1 @@\n-        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n@@ -432,2 +426,2 @@\n-        interface VaListBuilderCall<V> {\n-            void build(VaList.Builder builder, ValueLayout layout, V value);\n+        interface VaListBuilderCall<V, L> {\n+            void build(VaList.Builder builder, L layout, V value);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":71,"deletions":77,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -89,2 +88,2 @@\n-    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -92,1 +91,1 @@\n-    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -94,1 +93,1 @@\n-    static final VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n+    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n@@ -98,1 +97,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -100,1 +99,1 @@\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        VarHandle intHandle = layout.varHandle();\n@@ -117,1 +116,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -119,1 +118,1 @@\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        VarHandle intHandle = layout.varHandle();\n@@ -138,1 +137,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -140,1 +139,1 @@\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        VarHandle intHandle = layout.varHandle();\n@@ -162,1 +161,1 @@\n-        VarHandle floatHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle floatHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -168,1 +167,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -174,1 +173,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -182,1 +181,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -188,1 +187,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -192,1 +191,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -194,2 +193,7 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n+            vh.set(seg, \"42\");\n+            String x = (String) vh.get(seg); \/\/ should throw\n+        }\n@@ -198,1 +202,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -200,2 +204,6 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n+            vh.set(seg, \"42\"); \/\/ should throw\n+        }\n@@ -206,1 +214,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -249,1 +257,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -287,1 +295,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -326,1 +334,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -369,1 +377,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle\n- *\/\n-\n-import java.lang.invoke.*;\n-import java.nio.ByteOrder;\n-import jdk.incubator.foreign.*;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestAddressHandle {\n-\n-    static final MethodHandle INT_TO_BOOL;\n-    static final MethodHandle BOOL_TO_INT;\n-    static final MethodHandle INT_TO_STRING;\n-    static final MethodHandle STRING_TO_INT;\n-\n-    static {\n-        try {\n-            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"intToBool\",\n-                    MethodType.methodType(boolean.class, int.class));\n-            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"boolToInt\",\n-                    MethodType.methodType(int.class, boolean.class));\n-            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"intToString\",\n-                    MethodType.methodType(String.class, int.class));\n-            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"stringToInt\",\n-                    MethodType.methodType(int.class, String.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"addressHandles\")\n-    public void testAddressHandle(VarHandle addrHandle, int byteSize) {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n-            MemorySegment target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n-                    segment.asSlice(8 - byteSize) :\n-                    segment;\n-            longHandle.set(segment, 42L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(target);\n-            assertEquals(address.toRawLongValue(), 42L);\n-            addrHandle.set(target, address.addOffset(1));\n-            long result = (long)longHandle.get(segment);\n-            assertEquals(43L, result);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"addressHandles\")\n-    public void testNull(VarHandle addrHandle, int byteSize) {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n-            longHandle.set(segment, 0L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment);\n-            assertTrue(address == MemoryAddress.NULL);\n-        }\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptFloat() {\n-        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n-        MemoryHandles.asAddressVarHandle(floatHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptDouble() {\n-        VarHandle doubleHandle = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);\n-        MemoryHandles.asAddressVarHandle(doubleHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptBoolean() {\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        VarHandle boolHandle = MemoryHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);\n-        MemoryHandles.asAddressVarHandle(boolHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptString() {\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        VarHandle stringHandle = MemoryHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);\n-        MemoryHandles.asAddressVarHandle(stringHandle);\n-    }\n-\n-    @DataProvider(name = \"addressHandles\")\n-    static Object[][] addressHandles() {\n-        return new Object[][] {\n-                \/\/ long\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)), 8 },\n-\n-                \/\/ int\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)), 4 },\n-\n-                \/\/ short\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)), 2 },\n-\n-                \/\/ char\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)), 2 },\n-\n-                \/\/ byte\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)), 1 }\n-        };\n-    }\n-\n-    static VarHandle at(VarHandle handle, long offset) {\n-        return MemoryHandles.insertCoordinates(handle, 1, offset);\n-    }\n-\n-    static int boolToInt(boolean value) {\n-        return value ? 1 : 0;\n-    }\n-\n-    static boolean intToBool(int value) {\n-        return value != 0;\n-    }\n-\n-    static int stringToInt(String value) {\n-        return value.length();\n-    }\n-\n-    static String intToString(int value) {\n-        return String.valueOf(value);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -0,0 +1,542 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCopy\n+ *\/\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * To make these tests more challenging the segment is a view of the given array,\n+ * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\/\n+public class TestArrayCopy {\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+\n+    private static final int SEG_LENGTH_BYTES = 32;\n+    private static final int SEG_OFFSET_BYTES = 8;\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testSelfCopy(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        assertEquals(truth.mismatch(dstSeg), -1);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = helper.fromArray(dstArr);\n+        assertEquals(truth.mismatch(result), -1);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobLength(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNotAnArraySrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_BYTE, 0, new String[] { \"hello\" }, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNotAnArrayDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(new String[] { \"hello\" }, 0, segment, JAVA_BYTE, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testCarrierMismatchSrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_INT, 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testCarrierMismatchDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_INT, 0, 4);\n+    }\n+\n+    \/***** Utilities *****\/\n+\n+    public static MemorySegment srcSegment(int bytesLength) {\n+        byte[] arr = new byte[bytesLength];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte)i;\n+        }\n+        return MemorySegment.ofArray(arr);\n+    }\n+\n+    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?, ?> helper, int indexShifts, CopyMode mode) {\n+        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n+                                                .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n+                                                 .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toArray(JAVA_BYTE));\n+        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n+        if (mode.direction) {\n+            if (mode.swap) {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            } else {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            }\n+        } else { \/\/down\n+            if (mode.swap) {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            } else {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            }\n+        }\n+        return dstSeg;\n+    }\n+\n+    enum CopyMode {\n+        UP_NO_SWAP(true, false),\n+        UP_SWAP(true, true),\n+        DOWN_NO_SWAP(false, false),\n+        DOWN_SWAP(false, true);\n+\n+        final boolean direction;\n+        final boolean swap;\n+\n+        CopyMode(boolean direction, boolean swap) {\n+            this.direction = direction;\n+            this.swap = swap;\n+        }\n+    }\n+\n+    abstract static class CopyHelper<X, L extends ValueLayout> {\n+\n+        final L elementLayout;\n+        final Class<?> carrier;\n+\n+        public CopyHelper(L elementLayout, Class<X> carrier) {\n+            this.elementLayout = elementLayout;\n+            this.carrier = carrier;\n+        }\n+\n+        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n+        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract X toArray(MemorySegment segment);\n+        abstract MemorySegment fromArray(X array);\n+        abstract int length(X arr);\n+\n+        @Override\n+        public String toString() {\n+            return \"CopyHelper{\" +\n+                    \"elementLayout=\" + elementLayout +\n+                    \", carrier=\" + carrier.getName() +\n+                    '}';\n+        }\n+\n+        static final CopyHelper<byte[], ValueLayout.OfByte> BYTE = new CopyHelper<>(JAVA_BYTE, byte[].class) {\n+            @Override\n+            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            byte[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(byte[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(byte[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<char[], ValueLayout.OfChar> CHAR = new CopyHelper<>(ValueLayout.JAVA_CHAR, char[].class) {\n+            @Override\n+            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            char[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(char[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(char[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<short[], ValueLayout.OfShort> SHORT = new CopyHelper<>(ValueLayout.JAVA_SHORT, short[].class) {\n+            @Override\n+            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            short[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(short[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(short[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<int[], ValueLayout.OfInt> INT = new CopyHelper<>(ValueLayout.JAVA_INT, int[].class) {\n+            @Override\n+            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            int[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(int[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(int[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<float[], ValueLayout.OfFloat> FLOAT = new CopyHelper<>(ValueLayout.JAVA_FLOAT, float[].class) {\n+            @Override\n+            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            float[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(float[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(float[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<long[], ValueLayout.OfLong> LONG = new CopyHelper<>(ValueLayout.JAVA_LONG, long[].class) {\n+            @Override\n+            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            long[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(long[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(long[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<double[], ValueLayout.OfDouble> DOUBLE = new CopyHelper<>(ValueLayout.JAVA_DOUBLE, double[].class) {\n+            @Override\n+            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            double[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(double[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(double[] arr) {\n+                return arr.length;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModesAndHelpers() {\n+        CopyHelper<?, ?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n+                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n+        List<Object[]> results = new ArrayList<>();\n+        for (CopyHelper<?, ?> helper : helpers) {\n+            for (CopyMode mode : CopyMode.values()) {\n+                results.add(new Object[] { mode, helper, helper.toString() });\n+            }\n+        }\n+        return results.stream().toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":542,"deletions":0,"binary":false,"changes":542,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -46,0 +45,7 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -51,1 +57,1 @@\n-            MemoryLayouts.JAVA_BYTE\n+            JAVA_BYTE\n@@ -55,1 +61,1 @@\n-            MemoryLayouts.JAVA_CHAR\n+            JAVA_CHAR\n@@ -59,1 +65,1 @@\n-            MemoryLayouts.JAVA_SHORT\n+            JAVA_SHORT\n@@ -63,1 +69,1 @@\n-            MemoryLayouts.JAVA_INT\n+            JAVA_INT\n@@ -67,1 +73,1 @@\n-            MemoryLayouts.JAVA_FLOAT\n+            JAVA_FLOAT\n@@ -71,1 +77,1 @@\n-            MemoryLayouts.JAVA_LONG\n+            JAVA_LONG\n@@ -75,1 +81,1 @@\n-            MemoryLayouts.JAVA_DOUBLE\n+            JAVA_DOUBLE\n@@ -78,7 +84,7 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());\n+    static VarHandle byteHandle = bytes.varHandle(PathElement.sequenceElement());\n+    static VarHandle charHandle = chars.varHandle(PathElement.sequenceElement());\n+    static VarHandle shortHandle = shorts.varHandle(PathElement.sequenceElement());\n+    static VarHandle intHandle = ints.varHandle(PathElement.sequenceElement());\n+    static VarHandle floatHandle = floats.varHandle(PathElement.sequenceElement());\n+    static VarHandle longHandle = longs.varHandle(PathElement.sequenceElement());\n+    static VarHandle doubleHandle = doubles.varHandle(PathElement.sequenceElement());\n@@ -115,1 +121,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n@@ -155,1 +161,1 @@\n-                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n@@ -157,1 +163,1 @@\n-                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n@@ -159,1 +165,1 @@\n-                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n@@ -161,1 +167,1 @@\n-                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n@@ -163,1 +169,1 @@\n-                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n@@ -165,1 +171,1 @@\n-                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n@@ -167,1 +173,1 @@\n-                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n@@ -183,7 +189,7 @@\n-                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n-                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n-                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n-                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n-                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n-                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n-                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n+                { JAVA_BYTE, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_BYTE)},\n+                { JAVA_SHORT, (Function<MemorySegment, Object>) s -> s.toArray(JAVA_SHORT)},\n+                { JAVA_CHAR, (Function<MemorySegment, Object>) s -> s.toArray(JAVA_CHAR)},\n+                { JAVA_INT, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_INT)},\n+                { JAVA_FLOAT, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_FLOAT)},\n+                { JAVA_LONG, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_LONG)},\n+                { JAVA_DOUBLE, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_DOUBLE)}\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -85,0 +83,7 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -105,2 +110,2 @@\n-                    MemoryLayouts.BITS_32_BE.withName(\"index\"),\n-                    MemoryLayouts.BITS_32_BE.withName(\"value\")\n+                    JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"index\"),\n+                    JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -110,1 +115,1 @@\n-            MemoryLayouts.BITS_8_BE\n+            JAVA_BYTE\n@@ -114,1 +119,1 @@\n-            MemoryLayouts.BITS_16_BE\n+            JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -118,1 +123,1 @@\n-            MemoryLayouts.BITS_16_BE\n+            JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -122,1 +127,1 @@\n-            MemoryLayouts.BITS_32_BE\n+            JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -126,1 +131,1 @@\n-            MemoryLayouts.BITS_32_BE\n+            JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -130,1 +135,1 @@\n-            MemoryLayouts.BITS_64_BE\n+            JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -134,1 +139,1 @@\n-            MemoryLayouts.BITS_64_BE\n+            JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -137,2 +142,2 @@\n-    static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement(\"index\"));\n-    static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n+    static VarHandle indexHandle = tuples.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"index\"));\n+    static VarHandle valueHandle = tuples.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n@@ -266,1 +271,1 @@\n-    @Test(dataProvider = \"mappedOps\", expectedExceptions = UnsupportedOperationException.class)\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n@@ -327,0 +332,3 @@\n+        } catch(IOException e) {\n+            if (e.getMessage().equals(\"Function not implemented\"))\n+                throw new SkipException(e.getMessage(), e);\n@@ -483,1 +491,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n@@ -514,1 +522,1 @@\n-                MemoryAccess.setByteAtOffset(segment, offset, offset);\n+                segment.set(JAVA_BYTE, offset, offset);\n@@ -522,1 +530,1 @@\n-                assertEquals(MemoryAccess.getByte(segment), offset);\n+                assertEquals(segment.get(JAVA_BYTE, 0), offset);\n@@ -639,1 +647,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, ResourceScope.newConfinedScope());\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n@@ -645,1 +653,1 @@\n-        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n+        s2.set(JAVA_INT, 0, 10); \/\/ Dead access!\n@@ -657,1 +665,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                segment.set(JAVA_BYTE, i, (byte) i);\n@@ -677,1 +685,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                segment.set(JAVA_BYTE, i, (byte) i);\n@@ -697,1 +705,1 @@\n-            var bytes = slice.toByteArray();\n+            var bytes = slice.toArray(JAVA_BYTE);\n@@ -722,0 +730,1 @@\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()) },\n@@ -732,9 +741,2 @@\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) }\n-        };\n-    }\n-\n-    @DataProvider(name = \"implicitScopes\")\n-    public static Object[][] implicitScopes() {\n-        return new Object[][] {\n-                { (Supplier<ResourceScope>) ResourceScope::newImplicitScope },\n-                { (Supplier<ResourceScope>) ResourceScope::globalScope      },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newImplicitScope() }\n@@ -746,1 +748,1 @@\n-        return Stream.of(implicitScopes(), closeableScopes())\n+        return Stream.of(new Object[][] { { (Supplier<ResourceScope>)ResourceScope::globalScope } }, closeableScopes())\n@@ -752,1 +754,1 @@\n-        if (scope.isImplicit())\n+        if (scope == ResourceScope.globalScope())\n@@ -815,1 +817,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> addr.set(JAVA_BYTE, pos, (byte)(long)pos));\n@@ -817,1 +819,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> addr.setAtIndex(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), pos, (char)(long)pos));\n@@ -819,1 +821,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> addr.setAtIndex(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), pos, (short)(long)pos));\n@@ -821,1 +823,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> addr.setAtIndex(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), pos, (int)(long)pos));\n@@ -823,1 +825,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> addr.setAtIndex(JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), pos, (float)(long)pos));\n@@ -825,1 +827,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> addr.setAtIndex(JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), pos, (long)pos));\n@@ -827,1 +829,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> addr.setAtIndex(JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), pos, (double)(long)pos));\n@@ -830,1 +832,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> addr.get(JAVA_BYTE, pos), ByteBuffer::get);\n@@ -832,1 +834,1 @@\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> addr.getAtIndex(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), pos), CharBuffer::get);\n@@ -834,1 +836,1 @@\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> addr.getAtIndex(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), pos), ShortBuffer::get);\n@@ -836,1 +838,1 @@\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> addr.getAtIndex(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), pos), IntBuffer::get);\n@@ -838,1 +840,1 @@\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> addr.getAtIndex(JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), pos), FloatBuffer::get);\n@@ -840,1 +842,1 @@\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> addr.getAtIndex(JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), pos), LongBuffer::get);\n@@ -842,1 +844,1 @@\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> addr.getAtIndex(JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), pos), DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":49,"deletions":47,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm TestCircularInit1\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-public class TestCircularInit1 {\n-\n-    @Test\n-    public void testCircularInit() {\n-        System.out.println(PlatformLayouts.Win64.C_CHAR); \/\/ trigger clinit\n-        assertNotNull(CLinker.C_CHAR); \/\/ should not be null\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit1.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm TestCircularInit2\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-public class TestCircularInit2 {\n-\n-    @Test\n-    public void testCircularInit() {\n-        System.out.println(CLinker.C_CHAR); \/\/ trigger clinit\n-        assertNotNull(PlatformLayouts.Win64.C_CHAR);\n-        assertNotNull(PlatformLayouts.SysV.C_CHAR);\n-        assertNotNull(PlatformLayouts.AArch64.C_CHAR);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit2.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -42,1 +42,9 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -56,8 +64,9 @@\n-        C_CHAR,\n-        C_SHORT,\n-        C_INT,\n-        C_LONG,\n-        C_LONG_LONG,\n-        C_FLOAT,\n-        C_DOUBLE,\n-        C_POINTER\n+        JAVA_BOOLEAN,\n+        JAVA_CHAR,\n+        JAVA_BYTE,\n+        JAVA_SHORT,\n+        JAVA_INT,\n+        JAVA_FLOAT,\n+        JAVA_LONG,\n+        JAVA_DOUBLE,\n+        ADDRESS\n@@ -81,1 +90,1 @@\n-        testValues.add(FunctionDescriptor.of(C_CHAR, constants));\n+        testValues.add(FunctionDescriptor.of(JAVA_BYTE, constants));\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +39,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -55,1 +58,1 @@\n-    static CLinker abi = CLinker.getInstance();\n+    static CLinker abi = CLinker.systemCLinker();\n@@ -65,1 +68,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -69,1 +72,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n@@ -71,1 +74,4 @@\n-            Object res = doCall(addr, scope, mt, descriptor, args);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(scope) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n@@ -76,5 +82,1 @@\n-                    assertEquals(((MemorySegment) res).scope(), scope.scope());\n-                    assertEquals(scope.allocatedBytes(), descriptor.returnLayout().get().byteSize());\n-                } else {\n-                    \/\/ if here, there should be no allocation through the scope!\n-                    assertEquals(scope.allocatedBytes(), 0L);\n+                    assertEquals(((MemorySegment) res).scope(), scope);\n@@ -82,3 +84,0 @@\n-            } else {\n-                \/\/ if here, there should be no allocation through the scope!\n-                assertEquals(scope.allocatedBytes(), 0L);\n@@ -89,25 +88,2 @@\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testDowncallNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> checks = new ArrayList<>();\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n-        MethodType mt = methodType(ret, paramTypes, fields);\n-        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-        Object[] args = makeArgs(paramTypes, fields, checks);\n-        boolean needsScope = mt.returnType().equals(MemorySegment.class);\n-        Object res = doCall(addr, IMPLICIT_ALLOCATOR, mt, descriptor, args);\n-        if (ret == Ret.NON_VOID) {\n-            checks.forEach(c -> c.accept(res));\n-            if (needsScope) {\n-                \/\/ check that return struct has indeed been allocated in the default scope\n-                try {\n-                    ((MemorySegment)res).scope().close(); \/\/ should throw\n-                    fail(\"Expected exception!\");\n-                } catch (UnsupportedOperationException ex) {\n-                    \/\/ ok\n-                }\n-            }\n-        }\n-    }\n-\n-    Object doCall(MemoryAddress addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = abi.downcallHandle(addr, allocator, type, descriptor);\n+    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = downcallHandle(abi, symbol, allocator, descriptor);\n@@ -120,1 +96,1 @@\n-                MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));\n+                MethodType.methodType(void.class) : MethodType.methodType(carrier(params.get(0).layout(fields), false));\n@@ -122,1 +98,1 @@\n-            mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));\n+            mt = mt.appendParameterTypes(carrier(p.layout(fields), true));\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":15,"deletions":39,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -38,1 +37,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -41,1 +39,1 @@\n-public class TestFree {\n+public class TestFree extends NativeTestHelper {\n@@ -43,1 +41,1 @@\n-        return addr.asSegment(numElements * layout.byteSize(), ResourceScope.globalScope());\n+        return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n@@ -51,2 +49,2 @@\n-        MemoryAccess.setByteAtOffset(seg, str.length(), (byte)0);\n-        assertEquals(str, toJavaString(seg));\n+        seg.set(C_CHAR, str.length(), (byte)0);\n+        assertEquals(str, seg.getUtf8String(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng TestFunctionDescriptor\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFunctionDescriptor\n@@ -40,4 +40,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -48,1 +44,1 @@\n-public class TestFunctionDescriptor {\n+public class TestFunctionDescriptor extends NativeTestHelper {\n@@ -71,15 +67,0 @@\n-    @Test\n-    public void testAttribute() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n-        fd = fd.withAttribute(DUMMY_ATTR, true);\n-\n-        assertEquals(fd.argumentLayouts(), List.of(C_DOUBLE, C_LONG_LONG));\n-        Optional<MemoryLayout> returnLayoutOp = fd.returnLayout();\n-        assertTrue(returnLayoutOp.isPresent());\n-        assertEquals(returnLayoutOp.get(), C_INT);\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n-        Optional<Constable> attr = fd.attribute(DUMMY_ATTR);\n-        assertTrue(attr.isPresent());\n-        assertEquals(attr.get(), true);\n-    }\n-\n@@ -88,2 +69,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -96,1 +76,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n@@ -101,2 +80,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -109,1 +87,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n@@ -114,2 +91,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -121,1 +97,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -51,0 +50,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -153,1 +154,1 @@\n-                sum += MemoryAccess.getByteAtOffset(segment, i);\n+                sum += segment.get(JAVA_BYTE, i);\n@@ -196,1 +197,1 @@\n-            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+            copy.set(JAVA_BYTE, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,3 +40,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -46,1 +43,1 @@\n-public class TestIllegalLink {\n+public class TestIllegalLink extends NativeTestHelper {\n@@ -48,2 +45,2 @@\n-    private static final MemoryAddress DUMMY_TARGET = MemoryAddress.ofLong(1);\n-    private static final CLinker ABI = CLinker.getInstance();\n+    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope());\n+    private static final CLinker ABI = CLinker.systemCLinker();\n@@ -52,1 +49,1 @@\n-    public void testTypeMismatch(MethodType mt, FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testTypeMismatch(FunctionDescriptor desc, String expectedExceptionMessage) {\n@@ -54,1 +51,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, mt, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc);\n@@ -65,8 +62,2 @@\n-                MethodType.methodType(void.class),\n-                FunctionDescriptor.of(C_INT),\n-                \"Return type mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class),\n-                FunctionDescriptor.ofVoid(C_INT),\n-                \"Arity mismatch\"\n+                FunctionDescriptor.of(MemoryLayout.paddingLayout(64)),\n+                \"Unsupported layout: x64\"\n@@ -75,16 +66,0 @@\n-                MethodType.methodType(void.class, int.class),\n-                FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(32)),\n-                \"Expected a ValueLayout\"\n-            },\n-            {\n-                MethodType.methodType(void.class, boolean.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_8_LE),\n-                \"Unsupported carrier\"\n-            },\n-            {\n-                MethodType.methodType(void.class, int.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Carrier size mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class, MemoryAddress.class),\n@@ -92,6 +67,1 @@\n-                \"Expected a ValueLayout\"\n-            },\n-            {\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_16_LE),\n-                \"Address size mismatch\"\n+                \"Unsupported layout: x64\"\n@@ -100,3 +70,2 @@\n-                MethodType.methodType(void.class, MemorySegment.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Expected a GroupLayout\"\n+                    FunctionDescriptor.of(MemoryLayout.sequenceLayout(C_INT)),\n+                    \"Unsupported layout: [:b32]\"\n@@ -105,3 +74,2 @@\n-                MethodType.methodType(void.class, String.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Unsupported carrier\"\n+                    FunctionDescriptor.ofVoid(MemoryLayout.sequenceLayout(C_INT)),\n+                    \"Unsupported layout: [:b32]\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":14,"deletions":46,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -49,2 +50,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n-import static jdk.incubator.foreign.FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n@@ -53,1 +53,1 @@\n-public class TestIntrinsics {\n+public class TestIntrinsics extends NativeTestHelper {\n@@ -55,1 +55,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -91,1 +91,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(name).get();\n+            NativeSymbol ma = LOOKUP.lookup(name).get();\n@@ -95,3 +95,2 @@\n-            tests.add(abi.downcallHandle(ma, mt, fd), arg, arg);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), arg, arg);\n-            tests.add(abi.downcallHandle(mt, fd), arg, ma, arg);\n+            tests.add(abi.downcallHandle(ma, fd), arg, arg);\n+            tests.add(abi.downcallHandle(fd), arg, ma, arg);\n@@ -101,1 +100,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"empty\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"empty\").get();\n@@ -104,2 +103,1 @@\n-            tests.add(abi.downcallHandle(ma, mt, fd), null);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), null);\n+            tests.add(abi.downcallHandle(ma, fd), null);\n@@ -108,6 +106,7 @@\n-        addIdentity.add(\"identity_char\",   byte.class,   C_CHAR,   (byte) 10);\n-        addIdentity.add(\"identity_short\",  short.class,  C_SHORT, (short) 10);\n-        addIdentity.add(\"identity_int\",    int.class,    C_INT,           10);\n-        addIdentity.add(\"identity_long\",   long.class,   C_LONG_LONG,     10L);\n-        addIdentity.add(\"identity_float\",  float.class,  C_FLOAT,         10F);\n-        addIdentity.add(\"identity_double\", double.class, C_DOUBLE,        10D);\n+        addIdentity.add(\"identity_bool\",   boolean.class, C_BOOL,   true);\n+        addIdentity.add(\"identity_char\",   byte.class,    C_CHAR,   (byte) 10);\n+        addIdentity.add(\"identity_short\",  short.class,   C_SHORT, (short) 10);\n+        addIdentity.add(\"identity_int\",    int.class,     C_INT,           10);\n+        addIdentity.add(\"identity_long\",   long.class,    C_LONG_LONG,     10L);\n+        addIdentity.add(\"identity_float\",  float.class,   C_FLOAT,         10F);\n+        addIdentity.add(\"identity_double\", double.class,  C_DOUBLE,        10D);\n@@ -116,1 +115,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"identity_va\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"identity_va\").get();\n@@ -118,4 +117,2 @@\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, asVarArg(C_DOUBLE),\n-                    asVarArg(C_INT), asVarArg(C_FLOAT), asVarArg(C_LONG_LONG));\n-            tests.add(abi.downcallHandle(ma, mt, fd), 1, 1, 10D, 2, 3F, 4L);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), 1, 1, 10D, 2, 3F, 4L);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd), 1, 1, 10D, 2, 3F, 4L);\n@@ -128,1 +125,1 @@\n-                    C_SHORT, C_SHORT);\n+                    C_SHORT, JAVA_CHAR);\n@@ -131,1 +128,1 @@\n-                MemoryAddress ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n+                NativeSymbol ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n@@ -135,2 +132,1 @@\n-                tests.add(abi.downcallHandle(ma, mt, fd), expected, args);\n-                tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), expected, args);\n+                tests.add(abi.downcallHandle(ma, fd), expected, args);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestLayoutAttributes\n- *\/\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import org.testng.annotations.Test;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class TestLayoutAttributes {\n-\n-    @Test\n-    public void testAttribute() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 10L);\n-    }\n-\n-    @Test\n-    public void testAttributeOverwrite() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 10L);\n-        ml = ml.withAttribute(\"MyAttribute\", 11L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 11L);\n-    }\n-\n-    @Test\n-    public void testAttributeNonExistent() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertTrue(ml.attribute(\"Foo\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testNameAttribute() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withName(\"foo\");\n-        assertEquals(ml.name().orElseThrow(), \"foo\");\n-        assertEquals(ml.attribute(MemoryLayout.LAYOUT_NAME).orElseThrow(), \"foo\");\n-    }\n-\n-    @Test\n-    public void testAttributesStream() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withName(\"foo\")\n-                .withAttribute(\"MyAttribute\", 10L);\n-        List<String> attribs = ml.attributes().collect(Collectors.toList());\n-        assertEquals(attribs.size(), 2);\n-        assertTrue(attribs.contains(\"MyAttribute\"));\n-        assertTrue(attribs.contains(MemoryLayout.LAYOUT_NAME));\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -69,5 +70,5 @@\n-                { MemoryLayouts.PAD_32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayouts.PAD_32) },\n-                { MemoryLayout.sequenceLayout(5, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.structLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.unionLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n+                {MemoryLayout.paddingLayout(32)},\n+                { MemoryLayout.sequenceLayout(MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.sequenceLayout(5, MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.unionLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n@@ -75,1 +76,1 @@\n-                { MemoryLayouts.BITS_32_BE },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN) },\n@@ -77,2 +78,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        MemoryLayouts.BITS_32_BE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n@@ -80,2 +81,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        MemoryLayouts.BITS_32_BE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n@@ -83,1 +84,1 @@\n-                { MemoryLayouts.BITS_32_LE },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN) },\n@@ -85,2 +86,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        MemoryLayouts.BITS_32_LE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n@@ -88,2 +89,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        MemoryLayouts.BITS_32_LE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n@@ -92,1 +93,1 @@\n-                        MemoryLayouts.PAD_16,\n+                        MemoryLayout.paddingLayout(16),\n@@ -94,2 +95,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -97,1 +98,1 @@\n-                        MemoryLayouts.PAD_16,\n+                        MemoryLayout.paddingLayout(16),\n@@ -99,2 +100,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -103,2 +104,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -107,5 +108,4 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n-                { MemoryLayouts.BITS_32_LE.withName(\"myInt\") },\n-                { MemoryLayouts.BITS_32_LE.withBitAlignment(8) },\n-                { MemoryLayouts.BITS_32_LE.withAttribute(\"xyz\", \"abc\") },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"myInt\") },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withBitAlignment(8) },\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -42,0 +42,9 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -48,1 +57,3 @@\n-        ValueLayout newLayout = MemoryLayout.valueLayout(layout.bitSize(), layout.order());\n+        ValueLayout newLayout = valueLayoutForCarrier(layout.carrier());\n+        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n+        newLayout = newLayout.withOrder(layout.order());\n@@ -54,2 +65,0 @@\n-        assertEquals(newLayout.attributes().toArray().length, 0);\n-        assertEquals(layout.attributes().toArray().length, 1);\n@@ -57,2 +66,2 @@\n-        \/\/ but equals should return false, because one is a ValueLayout with a CLinker kind\n-        assertNotEquals(newLayout, layout);\n+        \/\/ layouts should be equals\n+        assertEquals(newLayout, layout);\n@@ -79,0 +88,23 @@\n+    static ValueLayout valueLayoutForCarrier(Class<?> carrier) {\n+        if (carrier == boolean.class) {\n+            return JAVA_BOOLEAN;\n+        } else if (carrier == char.class) {\n+            return JAVA_CHAR;\n+        } else if (carrier == byte.class) {\n+            return JAVA_BYTE;\n+        } else if (carrier == short.class) {\n+            return JAVA_SHORT;\n+        } else if (carrier == int.class) {\n+            return JAVA_INT;\n+        } else if (carrier == long.class) {\n+            return JAVA_LONG;\n+        } else if (carrier == float.class) {\n+            return JAVA_FLOAT;\n+        } else if (carrier == double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (carrier == MemoryAddress.class) {\n+            return ADDRESS;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -48,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -156,1 +155,1 @@\n-        seq.varHandle(int.class, sequenceElement());\n+        seq.varHandle(sequenceElement());\n@@ -224,1 +223,1 @@\n-            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n+            g.varHandle(groupElement(\"foo\")); \/\/ok\n@@ -235,1 +234,1 @@\n-        GroupLayout g = MemoryLayout.structLayout(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n@@ -243,1 +242,1 @@\n-            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n+            g.varHandle(groupElement(\"foo\")); \/\/ok\n@@ -302,4 +301,4 @@\n-                MemoryLayouts.JAVA_BYTE.withName(\"1\"),\n-                MemoryLayouts.JAVA_CHAR.withName(\"2\"),\n-                MemoryLayouts.JAVA_FLOAT.withName(\"3\"),\n-                MemoryLayouts.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"1\"),\n+                ValueLayout.JAVA_CHAR.withName(\"2\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n+                ValueLayout.JAVA_LONG.withName(\"4\")\n@@ -327,1 +326,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -331,1 +330,1 @@\n-                    assertEquals(g2.memberLayouts().get(j), MemoryLayouts.JAVA_DOUBLE);\n+                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n@@ -343,4 +342,4 @@\n-                MemoryLayouts.JAVA_BYTE.withName(\"1\"),\n-                MemoryLayouts.JAVA_CHAR.withName(\"2\"),\n-                MemoryLayouts.JAVA_FLOAT.withName(\"3\"),\n-                MemoryLayouts.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"1\"),\n+                ValueLayout.JAVA_CHAR.withName(\"2\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n+                ValueLayout.JAVA_LONG.withName(\"4\")\n@@ -368,1 +367,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -372,1 +371,1 @@\n-                    assertEquals(g2.memberLayouts().get(j), MemoryLayouts.JAVA_DOUBLE);\n+                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n@@ -383,1 +382,1 @@\n-        SequenceLayout g = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_BYTE);\n+        SequenceLayout g = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_BYTE);\n@@ -388,1 +387,1 @@\n-        assertTrue(selected == MemoryLayouts.JAVA_BYTE);\n+        assertTrue(selected == ValueLayout.JAVA_BYTE);\n@@ -401,2 +400,2 @@\n-        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, sequenceElement());\n-        assertTrue(seq2.elementLayout() == MemoryLayouts.JAVA_DOUBLE);\n+        SequenceLayout seq2 = (SequenceLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, sequenceElement());\n+        assertTrue(seq2.elementLayout() == ValueLayout.JAVA_DOUBLE);\n@@ -509,1 +508,1 @@\n-            assertEquals(slice.address().segmentOffset(segment), expectedBitOffset \/ 8);\n+            assertEquals(slice.address().toRawLongValue() - segment.address().toRawLongValue(), expectedBitOffset \/ 8);\n@@ -514,10 +513,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testSliceHandleUOEInvalidSize() {\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"x\"),\n-            MemoryLayout.valueLayout(31, ByteOrder.nativeOrder()).withName(\"y\") \/\/ size not a multiple of 8\n-        );\n-\n-        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n-    }\n-\n@@ -528,1 +517,1 @@\n-            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+            JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n@@ -539,1 +528,1 @@\n-                MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+                    JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -41,5 +46,0 @@\n-    @Test(dataProvider = \"badLayoutSizes\", expectedExceptions = IllegalArgumentException.class)\n-    public void testBadLayoutSize(SizedLayoutFactory factory, long size) {\n-        factory.make(size);\n-    }\n-\n@@ -54,1 +54,1 @@\n-                MemoryLayouts.JAVA_INT.withName(\"size\"),\n+                ValueLayout.JAVA_INT.withName(\"size\"),\n@@ -56,1 +56,1 @@\n-                MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE).withName(\"arr\"));\n+                MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE).withName(\"arr\"));\n@@ -58,2 +58,2 @@\n-        VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(double.class,\n+        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n+        VarHandle array_elem_handle = layout.varHandle(\n@@ -80,1 +80,1 @@\n-                MemoryLayouts.JAVA_INT.withName(\"size\"),\n+                ValueLayout.JAVA_INT.withName(\"size\"),\n@@ -82,1 +82,1 @@\n-                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE)).withName(\"arr\"));\n+                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE)).withName(\"arr\"));\n@@ -84,2 +84,2 @@\n-        VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(double.class,\n+        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n+        VarHandle array_elem_handle = layout.varHandle(\n@@ -106,1 +106,1 @@\n-        MemoryLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_INT);\n@@ -109,1 +109,1 @@\n-            VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+            VarHandle indexHandle = seq.varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -116,1 +116,1 @@\n-                VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));\n+                VarHandle preindexHandle = seq.varHandle(MemoryLayout.PathElement.sequenceElement(i));\n@@ -146,1 +146,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -152,1 +152,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_INT);\n@@ -171,4 +171,4 @@\n-                MemoryLayouts.JAVA_BYTE,\n-                MemoryLayouts.JAVA_CHAR,\n-                MemoryLayouts.JAVA_INT,\n-                MemoryLayouts.JAVA_LONG\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_LONG\n@@ -177,1 +177,1 @@\n-        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n+        assertEquals(struct.byteAlignment(), ValueLayout.ADDRESS.byteAlignment());\n@@ -202,4 +202,4 @@\n-                MemoryLayouts.JAVA_BYTE,\n-                MemoryLayouts.JAVA_CHAR,\n-                MemoryLayouts.JAVA_INT,\n-                MemoryLayouts.JAVA_LONG\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_LONG\n@@ -208,1 +208,1 @@\n-        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n+        assertEquals(struct.byteAlignment(), ValueLayout.ADDRESS.byteAlignment());\n@@ -227,13 +227,0 @@\n-    @DataProvider(name = \"badLayoutSizes\")\n-    public Object[][] factoriesAndSizes() {\n-        return new Object[][] {\n-                { SizedLayoutFactory.VALUE_BE, 0 },\n-                { SizedLayoutFactory.VALUE_BE, -1 },\n-                { SizedLayoutFactory.VALUE_LE, 0 },\n-                { SizedLayoutFactory.VALUE_LE, -1 },\n-                { SizedLayoutFactory.PADDING, 0 },\n-                { SizedLayoutFactory.PADDING, -1 },\n-                { SizedLayoutFactory.SEQUENCE, -1 }\n-        };\n-    }\n-\n@@ -242,0 +229,1 @@\n+        ValueLayout alignedInt = JAVA_INT.withBitAlignment(32);\n@@ -243,9 +231,9 @@\n-                { MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT), 32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.sequenceLayout(alignedInt), 32 },\n+                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n@@ -274,2 +262,2 @@\n-        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n-        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n+        VALUE_LE(size -> valueLayoutForSize((int)size).withOrder(ByteOrder.LITTLE_ENDIAN)),\n+        VALUE_BE(size -> valueLayoutForSize((int)size).withOrder(ByteOrder.BIG_ENDIAN)),\n@@ -277,1 +265,1 @@\n-        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayouts.PAD_8));\n+        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(8)));\n@@ -290,0 +278,10 @@\n+    static ValueLayout valueLayoutForSize(int size) {\n+        return switch (size) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new UnsupportedOperationException();\n+        };\n+    }\n+\n@@ -291,6 +289,5 @@\n-        VALUE_LE(MemoryLayouts.BITS_8_LE),\n-        VALUE_BE(MemoryLayouts.BITS_8_BE),\n-        PADDING(MemoryLayouts.PAD_8),\n-        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayouts.PAD_8)),\n-        STRUCT(MemoryLayout.structLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8)),\n-        UNION(MemoryLayout.unionLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8));\n+        VALUE(ValueLayout.JAVA_BYTE),\n+        PADDING(MemoryLayout.paddingLayout(8)),\n+        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(8))),\n+        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8))),\n+        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8)));\n@@ -336,7 +333,7 @@\n-            MemoryLayouts.JAVA_BYTE,\n-            MemoryLayouts.JAVA_CHAR,\n-            MemoryLayouts.JAVA_SHORT,\n-            MemoryLayouts.JAVA_INT,\n-            MemoryLayouts.JAVA_FLOAT,\n-            MemoryLayouts.JAVA_LONG,\n-            MemoryLayouts.JAVA_DOUBLE,\n+            ValueLayout.JAVA_BYTE,\n+            ValueLayout.JAVA_CHAR,\n+            ValueLayout.JAVA_SHORT,\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_FLOAT,\n+            ValueLayout.JAVA_LONG,\n+            ValueLayout.JAVA_DOUBLE,\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":63,"deletions":66,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -42,0 +42,1 @@\n+import java.nio.ByteOrder;\n@@ -50,1 +51,1 @@\n-    public void testAccess(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testAccess(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, Checker checker) {\n@@ -52,1 +53,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(), checker);\n@@ -56,1 +57,1 @@\n-    public void testPaddedAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testPaddedAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Checker checker) {\n@@ -58,1 +59,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.groupElement(\"elem\")), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(PathElement.groupElement(\"elem\")), checker);\n@@ -62,1 +63,1 @@\n-    public void testPaddedAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testPaddedAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Checker checker) {\n@@ -64,1 +65,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.sequenceElement(1)), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(PathElement.sequenceElement(1)), checker);\n@@ -68,1 +69,1 @@\n-    public void testArrayAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testArrayAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -70,1 +71,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(PathElement.sequenceElement()), checker);\n@@ -74,1 +75,1 @@\n-    public void testPaddedArrayAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testPaddedArrayAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -76,1 +77,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(\"elem\")), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(\"elem\")), checker);\n@@ -80,1 +81,1 @@\n-    public void testPaddedArrayAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testPaddedArrayAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -82,1 +83,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);\n@@ -152,1 +153,1 @@\n-    public void testMatrixAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testMatrixAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -155,1 +156,1 @@\n-        testMatrixAccessInternal(viewFactory, seq, seq.varHandle(carrier,\n+        testMatrixAccessInternal(viewFactory, seq, seq.varHandle(\n@@ -160,1 +161,1 @@\n-    public void testPaddedMatrixAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testPaddedMatrixAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -164,1 +165,1 @@\n-                seq.varHandle(carrier,\n+                seq.varHandle(\n@@ -170,1 +171,1 @@\n-    public void testPaddedMatrixAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testPaddedMatrixAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -174,1 +175,1 @@\n-                seq.varHandle(carrier,\n+                seq.varHandle(\n@@ -179,7 +180,0 @@\n-    @Test(dataProvider = \"badCarriers\",\n-          expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarriers(Class<?> carrier) {\n-        ValueLayout l = MemoryLayouts.BITS_32_LE.withName(\"elem\");\n-        l.varHandle(carrier);\n-    }\n-\n@@ -230,7 +224,7 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), Checker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), Checker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), Checker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), Checker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), Checker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), Checker.DOUBLE },\n@@ -238,7 +232,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), Checker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), Checker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), Checker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), Checker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), Checker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), Checker.DOUBLE },\n@@ -246,7 +240,7 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.DOUBLE },\n@@ -254,7 +248,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.DOUBLE },\n@@ -307,7 +301,7 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.DOUBLE },\n@@ -315,7 +309,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.DOUBLE },\n@@ -323,7 +317,7 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.DOUBLE },\n@@ -331,7 +325,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.DOUBLE },\n@@ -384,7 +378,9 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { ID, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.LONG },\n+                { ID, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.ADDR },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.DOUBLE },\n@@ -392,7 +388,9 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.LONG },\n+                { IMMUTABLE, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.ADDR },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.DOUBLE },\n@@ -400,7 +398,9 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { ID, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.LONG },\n+                { ID, ValueLayout.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.ADDR },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.DOUBLE },\n@@ -408,7 +408,9 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.LONG },\n+                { IMMUTABLE, ValueLayout.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.ADDR },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.DOUBLE },\n@@ -426,0 +428,5 @@\n+        MatrixChecker BOOLEAN = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+        };\n+\n@@ -446,0 +453,5 @@\n+        MatrixChecker ADDR = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, MemoryAddress.ofLong(r + c));\n+            assertEquals(MemoryAddress.ofLong(r + c), (MemoryAddress)handle.get(segment, r, c));\n+        };\n+\n@@ -456,10 +468,0 @@\n-\n-    @DataProvider(name = \"badCarriers\")\n-    public Object[][] createBadCarriers() {\n-        return new Object[][] {\n-                { void.class },\n-                { boolean.class },\n-                { Object.class },\n-                { int[].class }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":122,"deletions":120,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryAccessInstance\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.function.Function;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryAccessInstance {\n+\n+    static class Accessor<T, X, L> {\n+\n+        interface SegmentGetter<T, X, L> {\n+            X get(T buffer, L layout, long offset);\n+        }\n+\n+        interface SegmentSetter<T, X, L> {\n+            void set(T buffer, L layout, long offset, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment, int offset);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, int offset, X o);\n+        }\n+\n+        final X value;\n+        final L layout;\n+        final Function<MemorySegment, T> transform;\n+        final SegmentGetter<T, X, L> segmentGetter;\n+        final SegmentSetter<T, X, L> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(Function<MemorySegment, T> transform, L layout, X value,\n+                 SegmentGetter<T, X, L> segmentGetter, SegmentSetter<T, X, L> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.transform = transform;\n+            this.layout = layout;\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, scope);\n+                ByteBuffer buffer = segment.asByteBuffer();\n+                T t = transform.apply(segment);\n+                segmentSetter.set(t, layout, 4, value);\n+                assertEquals(bufferGetter.get(buffer, 4), value);\n+                bufferSetter.set(buffer, 4, value);\n+                assertEquals(value, segmentGetter.get(t, layout, 4));\n+            }\n+        }\n+\n+        static <L, X> Accessor<MemorySegment, X, L> ofSegment(L layout, X value,\n+                         SegmentGetter<MemorySegment, X, L> segmentGetter, SegmentSetter<MemorySegment, X, L> segmentSetter,\n+                         BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(Function.identity(), layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+\n+        static <L, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n+                                                              SegmentGetter<MemoryAddress, X, L> segmentGetter, SegmentSetter<MemoryAddress, X, L> segmentSetter,\n+                                                              BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(MemorySegment::address, layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"segmentAccessors\")\n+    public void testSegmentAccess(String testName, Accessor<?, ?, ?> accessor) {\n+        accessor.test();\n+    }\n+\n+    @Test(dataProvider = \"addressAccessors\")\n+    public void testAddressAccess(String testName, Accessor<?, ?, ?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"segmentAccessors\")\n+    static Object[][] segmentAccessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        ByteBuffer::get, ByteBuffer::put)\n+                },\n+                {\"bool\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n+                },\n+                {\"char\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n+                },\n+                {\"int\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n+                },\n+                {\"float\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n+                },\n+                {\"long\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n+                },\n+                {\"double\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n+                },\n+                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos) : nb.getInt(pos);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+\n+                {\"char\/index\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n+                },\n+                {\"int\/index\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n+                },\n+                {\"float\/index\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n+                },\n+                {\"long\/index\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n+                },\n+                {\"double\/index\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n+                },\n+                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos * 8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+\n+    @DataProvider(name = \"addressAccessors\")\n+    static Object[][] addressAccessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", Accessor.ofAddress(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        ByteBuffer::get, ByteBuffer::put)\n+                },\n+                {\"bool\", Accessor.ofAddress(ValueLayout.JAVA_BOOLEAN, false,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n+                },\n+                {\"char\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n+                },\n+                {\"int\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n+                },\n+                {\"float\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n+                },\n+                {\"long\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n+                },\n+                {\"double\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n+                },\n+                { \"address\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos) : nb.getInt(pos);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                {\"char\/index\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n+                },\n+                {\"int\/index\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n+                },\n+                {\"float\/index\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n+                },\n+                {\"long\/index\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n+                },\n+                {\"double\/index\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n+                },\n+                { \"address\/index\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos * 8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -1,364 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryAccessStatics\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestMemoryAccessStatics {\n-\n-    static class Accessor<X> {\n-\n-        interface SegmentGetter<X> {\n-            X get(MemorySegment segment);\n-        }\n-\n-        interface SegmentSetter<X> {\n-            void set(MemorySegment segment, X o);\n-        }\n-\n-        interface BufferGetter<X> {\n-            X get(ByteBuffer segment);\n-        }\n-\n-        interface BufferSetter<X> {\n-            void set(ByteBuffer buffer, X o);\n-        }\n-\n-        final X value;\n-        final SegmentGetter<X> segmentGetter;\n-        final SegmentSetter<X> segmentSetter;\n-        final BufferGetter<X> bufferGetter;\n-        final BufferSetter<X> bufferSetter;\n-\n-        Accessor(X value,\n-                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n-                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n-            this.value = value;\n-            this.segmentGetter = segmentGetter;\n-            this.segmentSetter = segmentSetter;\n-            this.bufferGetter = bufferGetter;\n-            this.bufferSetter = bufferSetter;\n-        }\n-\n-        void test() {\n-            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n-            ByteBuffer buffer = segment.asByteBuffer();\n-            segmentSetter.set(segment, value);\n-            assertEquals(bufferGetter.get(buffer), value);\n-            bufferSetter.set(buffer, value);\n-            assertEquals(value, segmentGetter.get(segment));\n-        }\n-\n-        <Z> Accessor<Z> of(Z value,\n-                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n-                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n-            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"accessors\")\n-    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n-        accessor.test();\n-    }\n-\n-    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n-    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n-    static final ByteOrder NE = ByteOrder.nativeOrder();\n-\n-    @DataProvider(name = \"accessors\")\n-    static Object[][] accessors() {\n-        return new Object[][]{\n-\n-                {\"byte\", new Accessor<>((byte) 42,\n-                        MemoryAccess::getByte, MemoryAccess::setByte,\n-                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n-                },\n-                {\"char\", new Accessor<>((char) 42,\n-                        MemoryAccess::getChar, MemoryAccess::setChar,\n-                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n-                },\n-                {\"char\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n-                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n-                },\n-                {\"char\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n-                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n-                },\n-                {\"short\", new Accessor<>((short) 42,\n-                        MemoryAccess::getShort, MemoryAccess::setShort,\n-                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n-                },\n-                {\"short\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n-                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n-                },\n-                {\"short\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n-                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n-                },\n-                {\"int\", new Accessor<>(42,\n-                        MemoryAccess::getInt, MemoryAccess::setInt,\n-                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n-                },\n-                {\"int\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n-                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n-                },\n-                {\"int\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n-                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n-                },\n-                \/\/ float, no offset\n-                {\"float\", new Accessor<>(42f,\n-                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n-                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n-                },\n-                {\"float\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n-                },\n-                {\"float\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n-                },\n-                \/\/ double, no offset\n-                {\"double\", new Accessor<>(42d,\n-                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n-                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n-                },\n-                {\"double\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n-                },\n-                {\"double\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n-                },\n-\n-\n-                \/\/ byte, offset\n-                {\"byte\/offset\", new Accessor<>((byte) 42,\n-                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n-                        (bb) -> bb.get(4), (bb, v) -> bb.put(4, v))\n-                },\n-                \/\/ char, offset\n-                {\"char\/offset\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getChar(4), (bb, v) -> bb.order(NE).putChar(4, v))\n-                },\n-                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getChar(4), (bb, v) -> bb.order(LE).putChar(4, v))\n-                },\n-                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getChar(4), (bb, v) -> bb.order(BE).putChar(4, v))\n-                },\n-                \/\/ short, offset\n-                {\"short\/offset\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getShort(4), (bb, v) -> bb.order(NE).putShort(4, v))\n-                },\n-                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getShort(4), (bb, v) -> bb.order(LE).putShort(4, v))\n-                },\n-                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getShort(4), (bb, v) -> bb.order(BE).putShort(4, v))\n-                },\n-                \/\/ int, offset\n-                {\"int\/offset\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getInt(4), (bb, v) -> bb.order(NE).putInt(4, v))\n-                },\n-                {\"int\/offset\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getInt(4), (bb, v) -> bb.order(LE).putInt(4, v))\n-                },\n-                {\"int\/offset\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getInt(4), (bb, v) -> bb.order(BE).putInt(4, v))\n-                },\n-                \/\/ float, offset\n-                {\"float\/offset\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getFloat(4), (bb, v) -> bb.order(NE).putFloat(4, v))\n-                },\n-                {\"float\/offset\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(4), (bb, v) -> bb.order(LE).putFloat(4, v))\n-                },\n-                {\"float\/offset\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(4), (bb, v) -> bb.order(BE).putFloat(4, v))\n-                },\n-                \/\/ double, offset\n-                {\"double\/offset\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getDouble(4), (bb, v) -> bb.order(NE).putDouble(4, v))\n-                },\n-                {\"double\/offset\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(4), (bb, v) -> bb.order(LE).putDouble(4, v))\n-                },\n-                {\"double\/offset\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(4), (bb, v) -> bb.order(BE).putDouble(4, v))\n-                },\n-\n-\n-                \/\/ char, index\n-                {\"char\/index\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n-                },\n-                \/\/ short, index\n-                {\"short\/index\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n-                },\n-                {\"int\/index\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n-                },\n-                {\"float\/index\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n-                },\n-                {\"double\/index\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n-                },\n-\n-                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(0) : nb.getInt(0);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(0, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(0, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(4) : nb.getInt(4);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(4, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(4, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.asLongBuffer().put(2, v.toRawLongValue());\n-                            } else {\n-                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":0,"deletions":364,"binary":false,"changes":364,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -39,0 +38,1 @@\n+import java.nio.ByteOrder;\n@@ -48,1 +48,3 @@\n-        ValueLayout layout = MemoryLayouts.BITS_32_BE;\n+        ValueLayout layout = ValueLayout.JAVA_INT\n+                .withBitAlignment(32)\n+                .withOrder(ByteOrder.BIG_ENDIAN);\n@@ -52,1 +54,1 @@\n-        VarHandle vh = aligned.varHandle(int.class);\n+        VarHandle vh = aligned.varHandle();\n@@ -63,1 +65,3 @@\n-        ValueLayout layout = MemoryLayouts.BITS_32_BE;\n+        ValueLayout layout = ValueLayout.JAVA_INT\n+                .withBitAlignment(32)\n+                .withOrder(ByteOrder.BIG_ENDIAN);\n@@ -66,1 +70,1 @@\n-        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n+        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -68,1 +72,1 @@\n-        VarHandle vh = aligned.varHandle(int.class);\n+        VarHandle vh = aligned.varHandle();\n@@ -80,1 +84,1 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_32_BE;\n+        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -82,1 +86,1 @@\n-        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n+        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -84,1 +88,1 @@\n-            alignedGroup.varHandle(int.class, PathElement.groupElement(\"value\"));\n+            alignedGroup.varHandle(PathElement.groupElement(\"value\"));\n@@ -93,1 +97,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -95,1 +99,1 @@\n-            VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());\n+            VarHandle vh = layout.varHandle(PathElement.sequenceElement());\n@@ -109,3 +113,3 @@\n-        ValueLayout vChar = MemoryLayouts.BITS_8_BE;\n-        ValueLayout vShort = MemoryLayouts.BITS_16_BE;\n-        ValueLayout vInt = MemoryLayouts.BITS_32_BE;\n+        ValueLayout vChar = ValueLayout.JAVA_BYTE;\n+        ValueLayout vShort = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        ValueLayout vInt = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -117,3 +121,3 @@\n-        VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement(\"a\"));\n-        VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement(\"b\"));\n-        VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement(\"c\"));\n+        VarHandle vh_c = g.varHandle(PathElement.groupElement(\"a\"));\n+        VarHandle vh_s = g.varHandle(PathElement.groupElement(\"b\"));\n+        VarHandle vh_i = g.varHandle(PathElement.groupElement(\"c\"));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryCopy\n- *\/\n-\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestMemoryCopy {\n-\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.size(), s2.size());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);\n-        }\n-        \/\/perform copy\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        int size() {\n-            return last - first + 1;\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestMemoryDereference\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.*;\n+\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryDereference {\n+\n+    static class Accessor<X> {\n+\n+        interface SegmentGetter<X> {\n+            X get(MemorySegment segment);\n+        }\n+\n+        interface SegmentSetter<X> {\n+            void set(MemorySegment segment, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, X o);\n+        }\n+\n+        final X value;\n+        final SegmentGetter<X> segmentGetter;\n+        final SegmentSetter<X> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(X value,\n+                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            segmentSetter.set(segment, value);\n+            assertEquals(bufferGetter.get(buffer), value);\n+            bufferSetter.set(buffer, value);\n+            assertEquals(value, segmentGetter.get(segment));\n+        }\n+\n+        <Z> Accessor<Z> of(Z value,\n+                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n+                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n+            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n+    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"accessors\")\n+    static Object[][] accessors() {\n+        return new Object[][]{\n+\n+                \/\/ byte, offset\n+                {\"byte\/offset\", new Accessor<>((byte) 42,\n+                        s -> s.get(JAVA_BYTE, 8), (s, x) -> s.set(JAVA_BYTE, 8, x),\n+                        (bb) -> bb.get(8), (bb, v) -> bb.put(8, v))\n+                },\n+                \/\/ bool, offset\n+                {\"bool\", new Accessor<>(false,\n+                        s -> s.get(JAVA_BOOLEAN, 8), (s, x) -> s.set(JAVA_BOOLEAN, 8, x),\n+                        (bb) -> bb.get(8) != 0, (bb, v) -> bb.put(8, v ? (byte)1 : (byte)0))\n+                },\n+                \/\/ char, offset\n+                {\"char\/offset\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR, 8), (s, x) -> s.set(JAVA_CHAR, 8, x),\n+                        (bb) -> bb.order(NE).getChar(8), (bb, v) -> bb.order(NE).putChar(8, v))\n+                },\n+                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getChar(8), (bb, v) -> bb.order(LE).putChar(8, v))\n+                },\n+                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getChar(8), (bb, v) -> bb.order(BE).putChar(8, v))\n+                },\n+                \/\/ short, offset\n+                {\"short\/offset\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT, 8), (s, x) -> s.set(JAVA_SHORT, 8, x),\n+                        (bb) -> bb.order(NE).getShort(8), (bb, v) -> bb.order(NE).putShort(8, v))\n+                },\n+                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getShort(8), (bb, v) -> bb.order(LE).putShort(8, v))\n+                },\n+                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getShort(8), (bb, v) -> bb.order(BE).putShort(8, v))\n+                },\n+                \/\/ int, offset\n+                {\"int\/offset\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT, 8), (s, x) -> s.set(JAVA_INT, 8, x),\n+                        (bb) -> bb.order(NE).getInt(8), (bb, v) -> bb.order(NE).putInt(8, v))\n+                },\n+                {\"int\/offset\/LE\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getInt(8), (bb, v) -> bb.order(LE).putInt(8, v))\n+                },\n+                {\"int\/offset\/BE\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getInt(8), (bb, v) -> bb.order(BE).putInt(8, v))\n+                },\n+                \/\/ float, offset\n+                {\"float\/offset\", new Accessor<>(42f,\n+                        s -> s.get(JAVA_FLOAT, 8), (s, x) -> s.set(JAVA_FLOAT, 8, x),\n+                        (bb) -> bb.order(NE).getFloat(8), (bb, v) -> bb.order(NE).putFloat(8, v))\n+                },\n+                {\"float\/offset\/LE\", new Accessor<>(42f,\n+                        s -> s.get(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getFloat(8), (bb, v) -> bb.order(LE).putFloat(8, v))\n+                },\n+                {\"float\/offset\/BE\", new Accessor<>(42f,\n+                        s -> s.get(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getFloat(8), (bb, v) -> bb.order(BE).putFloat(8, v))\n+                },\n+                \/\/ double, offset\n+                {\"double\/offset\", new Accessor<>(42d,\n+                        s -> s.get(JAVA_DOUBLE, 8), (s, x) -> s.set(JAVA_DOUBLE, 8, x),\n+                        (bb) -> bb.order(NE).getDouble(8), (bb, v) -> bb.order(NE).putDouble(8, v))\n+                },\n+                {\"double\/offset\/LE\", new Accessor<>(42d,\n+                        s -> s.get(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getDouble(8), (bb, v) -> bb.order(LE).putDouble(8, v))\n+                },\n+                {\"double\/offset\/BE\", new Accessor<>(42d,\n+                        s -> s.get(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getDouble(8), (bb, v) -> bb.order(BE).putDouble(8, v))\n+                },\n+                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> s.get(ADDRESS, 8), (s, x) -> s.set(ADDRESS, 8, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(8) : nb.getInt(8);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(8, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import java.nio.ByteOrder;\n@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,2 +58,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_8_BE;\n-        VarHandle byteHandle = layout.varHandle(byte.class);\n+        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n+        VarHandle byteHandle = layout.varHandle();\n@@ -80,2 +81,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_8_BE;\n-        VarHandle byteHandle = layout.varHandle(byte.class);\n+        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n+        VarHandle byteHandle = layout.varHandle();\n@@ -103,2 +104,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_16_BE;\n-        VarHandle shortHandle = layout.varHandle(short.class);\n+        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle shortHandle = layout.varHandle();\n@@ -126,2 +127,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_16_BE;\n-        VarHandle shortHandle = layout.varHandle(short.class);\n+        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle shortHandle = layout.varHandle();\n@@ -153,2 +154,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_32_BE;\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle intHandle = layout.varHandle();\n@@ -168,2 +169,2 @@\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(2, MemoryLayouts.BITS_8_BE);\n-        VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_BYTE);\n+        VarHandle byteHandle = layout.varHandle(PathElement.sequenceElement());\n@@ -187,2 +188,2 @@\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(PathElement.sequenceElement());\n@@ -193,2 +194,2 @@\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(PathElement.sequenceElement());\n@@ -204,1 +205,1 @@\n-        VarHandle handle = MemoryHandles.varHandle(byte.class, BIG_ENDIAN);\n+        VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withOrder(BIG_ENDIAN));\n@@ -212,2 +213,2 @@\n-    static void assertIllegalArgumentExceptionIllegalCarrier(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIllegalCarrier(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -219,2 +220,2 @@\n-    static void assertIllegalArgumentExceptionIllegalAdapter(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIllegalAdapter(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -226,2 +227,2 @@\n-    static void assertIllegalArgumentExceptionIsNotWiderThan(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -235,20 +236,20 @@\n-        assertIllegalArgumentExceptionIllegalCarrier(char.class,   long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(double.class, long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(float.class,  long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(long.class,   long.class);\n-\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, void.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, byte.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, short.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, char.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, double.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, float.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Object.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Integer.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Long.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, long[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, int[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Integer[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Long[].class);\n-\n-        assertIllegalArgumentExceptionIsNotWiderThan(int.class, int.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_CHAR,   long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_DOUBLE, long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_FLOAT,  long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_LONG,   long.class);\n+\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, void.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, byte.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, short.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, char.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, double.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, float.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Object.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, long[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, int[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long[].class);\n+\n+        assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout.JAVA_INT, int.class);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -46,1 +46,1 @@\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n+    final static VarHandle BYTE_HANDLE = ValueLayout.JAVA_BYTE.varHandle();\n@@ -115,1 +115,1 @@\n-        if (MemoryLayouts.ADDRESS.byteSize() > 32) {\n+        if (ValueLayout.ADDRESS.byteSize() > 32) {\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,2 +42,0 @@\n-import java.lang.invoke.MethodType;\n-import java.nio.charset.Charset;\n@@ -45,1 +45,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -50,2 +50,1 @@\n-                MemoryAddress.NULL,\n-                MethodType.methodType(void.class),\n+                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, ResourceScope.globalScope()),\n@@ -58,1 +57,0 @@\n-                MethodType.methodType(void.class),\n@@ -60,1 +58,1 @@\n-        mh.invokeExact((Addressable) MemoryAddress.NULL);\n+        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, ResourceScope.globalScope()));\n@@ -64,2 +62,2 @@\n-    public void testNULLtoJavaString() {\n-        CLinker.toJavaString(MemoryAddress.NULL);\n+    public void testNULLgetString() {\n+        MemoryAddress.NULL.getUtf8String(0);\n@@ -69,2 +67,2 @@\n-    public void testNULLfreeMemory() {\n-        CLinker.freeMemory(MemoryAddress.NULL);\n+    public void testNULLsetString() {\n+        MemoryAddress.NULL.setUtf8String(0, \"hello\");\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -37,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -41,0 +38,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -59,0 +57,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -61,1 +60,1 @@\n-public class TestNative {\n+public class TestNative extends NativeTestHelper {\n@@ -64,1 +63,1 @@\n-            MemoryLayouts.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())\n@@ -68,1 +67,1 @@\n-            MemoryLayouts.JAVA_CHAR.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_CHAR.withOrder(ByteOrder.nativeOrder())\n@@ -72,1 +71,1 @@\n-            MemoryLayouts.JAVA_SHORT.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_SHORT.withOrder(ByteOrder.nativeOrder())\n@@ -76,1 +75,1 @@\n-            MemoryLayouts.JAVA_INT.withOrder(ByteOrder.nativeOrder())\n+            JAVA_INT.withOrder(ByteOrder.nativeOrder())\n@@ -80,1 +79,1 @@\n-            MemoryLayouts.JAVA_FLOAT.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.nativeOrder())\n@@ -84,1 +83,1 @@\n-            MemoryLayouts.JAVA_LONG.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_LONG.withOrder(ByteOrder.nativeOrder())\n@@ -88,1 +87,1 @@\n-            MemoryLayouts.JAVA_DOUBLE.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.nativeOrder())\n@@ -91,7 +90,7 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = doubles.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = longs.varHandle(double.class, PathElement.sequenceElement());\n+    static VarHandle byteHandle = bytes.varHandle(PathElement.sequenceElement());\n+    static VarHandle charHandle = chars.varHandle(PathElement.sequenceElement());\n+    static VarHandle shortHandle = shorts.varHandle(PathElement.sequenceElement());\n+    static VarHandle intHandle = ints.varHandle(PathElement.sequenceElement());\n+    static VarHandle floatHandle = floats.varHandle(PathElement.sequenceElement());\n+    static VarHandle longHandle = longs.varHandle(PathElement.sequenceElement());\n+    static VarHandle doubleHandle = doubles.varHandle(PathElement.sequenceElement());\n@@ -147,8 +146,0 @@\n-    public static MemoryAddress allocate(int size) {\n-        return CLinker.allocateMemory(size);\n-    }\n-\n-    public static void free(MemoryAddress addr) {\n-        CLinker.freeMemory(addr);\n-    }\n-\n@@ -179,1 +170,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -181,1 +172,2 @@\n-            MemorySegment mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            scope.addCloseAction(() -> freeMemory(addr));\n+            MemorySegment mallocSegment = MemorySegment.ofAddress(addr, 12, scope);\n@@ -186,6 +178,0 @@\n-    @Test\n-    public void testDefaultAccessModesEverthing() {\n-        MemorySegment everything = MemorySegment.globalNativeSegment();\n-        assertFalse(everything.isReadOnly());\n-    }\n-\n@@ -194,1 +180,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -197,1 +183,2 @@\n-            mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            scope.addCloseAction(() -> freeMemory(addr));\n+            mallocSegment = MemorySegment.ofAddress(addr, 12, scope);\n@@ -205,6 +192,5 @@\n-    public void testEverythingSegment() {\n-        MemoryAddress addr = allocate(4);\n-        MemorySegment everything = MemorySegment.globalNativeSegment();\n-        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n-        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n-        free(addr);\n+    public void testAddressAccess() {\n+        MemoryAddress addr = allocateMemory(4);\n+        addr.set(JAVA_INT, 0, 42);\n+        assertEquals(addr.get(JAVA_INT, 0), 42);\n+        freeMemory(addr);\n@@ -217,1 +203,1 @@\n-            segment.address().asSegment(0, ResourceScope.globalScope());\n+            MemorySegment.ofAddress(segment.address(), 0, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":29,"deletions":43,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -85,0 +87,9 @@\n+            ValueLayout.OfBoolean.class,\n+            ValueLayout.OfByte.class,\n+            ValueLayout.OfChar.class,\n+            ValueLayout.OfShort.class,\n+            ValueLayout.OfInt.class,\n+            ValueLayout.OfFloat.class,\n+            ValueLayout.OfLong.class,\n+            ValueLayout.OfDouble.class,\n+            ValueLayout.OfAddress.class,\n@@ -88,2 +99,0 @@\n-            MemoryAccess.class,\n-            MemoryLayouts.class,\n@@ -92,2 +101,2 @@\n-            CLinker.VaList.class,\n-            CLinker.VaList.Builder.class,\n+            VaList.class,\n+            VaList.Builder.class,\n@@ -96,1 +105,2 @@\n-            ResourceScope.class\n+            ResourceScope.class,\n+            NativeSymbol.class\n@@ -100,0 +110,2 @@\n+            \"jdk.incubator.foreign.ResourceScope\/newConfinedScope(java.lang.ref.Cleaner)\/0\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/newSharedScope(java.lang.ref.Cleaner)\/0\/0\",\n@@ -101,3 +113,0 @@\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n@@ -106,0 +115,9 @@\n+            \"jdk.incubator.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n@@ -142,1 +160,1 @@\n-        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()));\n+        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(JAVA_INT));\n@@ -150,4 +168,13 @@\n-        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n-        addDefaultMapping(ValueLayout.class, MemoryLayouts.JAVA_INT);\n-        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(MemoryLayouts.JAVA_INT));\n-        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(MemoryLayout.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(ValueLayout.OfByte.class, ValueLayout.JAVA_BYTE);\n+        addDefaultMapping(ValueLayout.OfBoolean.class, ValueLayout.JAVA_BOOLEAN);\n+        addDefaultMapping(ValueLayout.OfChar.class, ValueLayout.JAVA_CHAR);\n+        addDefaultMapping(ValueLayout.OfShort.class, ValueLayout.JAVA_SHORT);\n+        addDefaultMapping(ValueLayout.OfInt.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfFloat.class, ValueLayout.JAVA_FLOAT);\n+        addDefaultMapping(ValueLayout.OfLong.class, JAVA_LONG);\n+        addDefaultMapping(ValueLayout.OfDouble.class, ValueLayout.JAVA_DOUBLE);\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(ValueLayout.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n@@ -156,5 +183,5 @@\n-        addDefaultMapping(CLinker.class, CLinker.getInstance());\n-        addDefaultMapping(CLinker.VaList.class, VaListHelper.vaList);\n-        addDefaultMapping(CLinker.VaList.Builder.class, VaListHelper.vaListBuilder);\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n-        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n+        addDefaultMapping(VaList.class, VaListHelper.vaList);\n+        addDefaultMapping(VaList.Builder.class, VaListHelper.vaListBuilder);\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newSharedScope());\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[10])));\n@@ -162,1 +189,0 @@\n-        addDefaultMapping(ResourceScope.Handle.class, ResourceScope.globalScope().acquire());\n@@ -164,1 +190,2 @@\n-        addDefaultMapping(SymbolLookup.class, CLinker.systemLookup());\n+        addDefaultMapping(SymbolLookup.class, CLinker.systemCLinker());\n+        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope()));\n@@ -168,2 +195,2 @@\n-        static final CLinker.VaList vaList;\n-        static final CLinker.VaList.Builder vaListBuilder;\n+        static final VaList vaList;\n+        static final VaList.Builder vaListBuilder;\n@@ -172,2 +199,2 @@\n-            AtomicReference<CLinker.VaList.Builder> builderRef = new AtomicReference<>();\n-            vaList = CLinker.VaList.make(b -> {\n+            AtomicReference<VaList.Builder> builderRef = new AtomicReference<>();\n+            vaList = VaList.make(b -> {\n@@ -175,1 +202,1 @@\n-                b.vargFromLong(CLinker.C_LONG_LONG, 42L);\n+                b.addVarg(JAVA_LONG, 42L);\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":52,"deletions":25,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestRebase\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestRebase {\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testRebase(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.contains(s2)) {\n-            \/\/check that an address and its rebased counterpart point to same element\n-            MemoryAddress base = s2.segment.address();\n-            long offset = base.segmentOffset(s1.segment);\n-            for (int i = 0; i < s2.size(); i++) {\n-                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n-                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n-                assertEquals(found, expected);\n-            }\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that rebase s1 to s2 fails\n-            try {\n-                s1.segment.address().segmentOffset(s2.segment);\n-                fail(\"Rebase unexpectedly passed!\");\n-            } catch (IllegalArgumentException ex) {\n-                assertTrue(true);\n-            }\n-        } else if (!s2.contains(s1)) {\n-            \/\/disjoint segments - check that rebased address is out of bounds\n-            MemoryAddress base = s2.segment.address();\n-            long offset = base.segmentOffset(s1.segment);\n-            for (int i = 0; i < s2.size(); i++) {\n-                MemoryAccess.getByteAtOffset(s2.segment, i);\n-                try {\n-                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n-                    fail(\"Rebased address on a disjoint segment is not out of bounds!\");\n-                } catch (IndexOutOfBoundsException ex) {\n-                    assertTrue(true);\n-                }\n-            }\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        boolean contains(SegmentSlice other) {\n-            return kind == other.kind &&\n-                    first <= other.first &&\n-                    last >= other.last;\n-        }\n-\n-        int size() {\n-            return last - first + 1;\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            \/\/init root segment\n-            MemorySegment segment = kind.makeSegment(16);\n-            for (int i = 0 ; i < 16 ; i++) {\n-                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n-            }\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,1 +57,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -63,1 +63,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -69,1 +69,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -75,1 +75,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -81,1 +81,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -87,1 +87,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -93,1 +93,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n@@ -128,2 +128,2 @@\n-            MemoryLayouts.JAVA_INT,\n-            MemoryLayouts.JAVA_INT\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_INT\n@@ -135,48 +135,48 @@\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_INT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_LONG, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 8, 16, 2 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 256 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_SHORT, new long[] { 256 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_CHAR, new long[] { 256 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_INT, new long[] { 256 } },\n+                { ValueLayout.JAVA_INT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_INT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_INT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_INT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_INT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_LONG, new long[] { 256 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_FLOAT, new long[] { 256 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 256 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 8, 16, 2 } },\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Set;\n@@ -160,7 +161,4 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testLockSingleThread(Supplier<Cleaner> cleanerSupplier) {\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newConfinedScope(cleaner) :\n-                ResourceScope.newConfinedScope();\n-        List<ResourceScope.Handle> handles = new ArrayList<>();\n+    @Test\n+    public void testLockSingleThread() {\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        List<ResourceScope> handles = new ArrayList<>();\n@@ -168,1 +166,3 @@\n-            handles.add(scope.acquire());\n+            ResourceScope handle = ResourceScope.newConfinedScope();\n+            handle.keepAlive(scope);\n+            handles.add(handle);\n@@ -178,4 +178,2 @@\n-                ResourceScope.Handle handle = handles.remove(0);\n-                scope.release(handle);\n-                scope.release(handle); \/\/ make sure it's idempotent\n-                scope.release(handle); \/\/ make sure it's idempotent\n+                ResourceScope handle = handles.remove(0);\n+                handle.close();\n@@ -186,6 +184,3 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testLockSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n+    @Test\n+    public void testLockSharedMultiThread() {\n+        ResourceScope scope = ResourceScope.newSharedScope();\n@@ -195,2 +190,2 @@\n-                try {\n-                    ResourceScope.Handle handle = scope.acquire(); \/\/ this can throw if segment has been closed\n+                try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n+                    handle.keepAlive(scope);\n@@ -200,3 +195,1 @@\n-                    scope.release(handle); \/\/ cannot throw (acquired segments cannot be closed)\n-                    scope.release(handle); \/\/ cannot throw (idempotent)\n-                    scope.release(handle); \/\/ cannot throw (idempotent)\n+                    handle.close();\n@@ -233,1 +226,2 @@\n-        ResourceScope.Handle handle = scope.acquire();\n+        ResourceScope handle = ResourceScope.newConfinedScope();\n+        handle.keepAlive(scope);\n@@ -237,3 +231,1 @@\n-                scope.release(handle);\n-                scope.release(handle); \/\/ make sure it's idempotent\n-                scope.release(handle); \/\/ make sure it's idempotent\n+                handle.close();\n@@ -258,1 +250,1 @@\n-        if (!scope.isImplicit()) {\n+        if (scope != ResourceScope.globalScope()) {\n@@ -263,0 +255,6 @@\n+    @Test(dataProvider = \"scopes\", expectedExceptions = IllegalArgumentException.class)\n+    public void testAcquireSelf(Supplier<ResourceScope> scopeSupplier) {\n+        ResourceScope scope = scopeSupplier.get();\n+        scope.keepAlive(scope);\n+    }\n+\n@@ -264,5 +262,9 @@\n-        ResourceScope.Handle handle = scope.acquire();\n-        assertEquals(handle.scope(), scope);\n-        if (acquireCount > 0) {\n-            \/\/ recursive acquire\n-            acquireRecursive(scope, acquireCount - 1);\n+        try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n+            handle.keepAlive(scope);\n+            if (acquireCount > 0) {\n+                \/\/ recursive acquire\n+                acquireRecursive(scope, acquireCount - 1);\n+            }\n+            if (scope != ResourceScope.globalScope()) {\n+                assertThrows(IllegalStateException.class, scope::close);\n+            }\n@@ -270,2 +272,8 @@\n-        if (!scope.isImplicit()) {\n-            assertThrows(IllegalStateException.class, scope::close);\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithImplicitDependency() {\n+        ResourceScope root = ResourceScope.newConfinedScope();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            ResourceScope.newConfinedScope(Cleaner.create()).keepAlive(root);\n@@ -273,3 +281,48 @@\n-        scope.release(handle);\n-        scope.release(handle); \/\/ make sure it's idempotent\n-        scope.release(handle); \/\/ make sure it's idempotent\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n+        \/\/ might be called from another thread (the Cleaner thread), so that the confined scope lock count is updated racily.\n+        \/\/ If that happens, the loop below never terminates.\n+        while (true) {\n+            try {\n+                root.close();\n+                break; \/\/ success!\n+            } catch (IllegalStateException ex) {\n+                kickGC();\n+                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n+                    try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                        scope.keepAlive(root);\n+                        \/\/ dummy\n+                    }\n+                }\n+                \/\/ try again\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithSharedDependency() {\n+        ResourceScope root = ResourceScope.newConfinedScope();\n+        List<Thread> threads = new ArrayList<>();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            ResourceScope scope = ResourceScope.newSharedScope(); \/\/ create scope inside same thread!\n+            scope.keepAlive(root);\n+            Thread t = new Thread(scope::close); \/\/ close from another thread!\n+            threads.add(t);\n+            t.start();\n+        }\n+        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                scope.keepAlive(root);\n+                \/\/ dummy\n+            }\n+        }\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                \/\/ ok\n+            }\n+        });\n+        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined scope happen in different\n+        \/\/ threads, so that the confined scope lock count is updated racily. If that happens, the following close will blow up.\n+        root.close();\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":91,"deletions":38,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -41,1 +42,1 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"globalNativeSegment\");\n+        Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -47,3 +48,3 @@\n-        var mh = MethodHandles.lookup().findStatic(MemorySegment.class,\n-                \"globalNativeSegment\", MethodType.methodType(MemorySegment.class));\n-        var seg = (MemorySegment)mh.invokeExact();\n+        var mh = MethodHandles.lookup().findStatic(CLinker.class,\n+                \"systemCLinker\", MethodType.methodType(CLinker.class));\n+        var seg = (CLinker)mh.invokeExact();\n@@ -54,1 +55,1 @@\n-        MemorySegment.globalNativeSegment();\n+        CLinker.systemCLinker();\n@@ -59,2 +60,2 @@\n-        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class, ResourceScope.class);\n-        method.invoke(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", MemoryAddress.class, long.class, ResourceScope.class);\n+        method.invoke(null, MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n@@ -65,2 +66,2 @@\n-        var mh = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class));\n+        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n+            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class));\n@@ -72,1 +73,1 @@\n-        MemoryAddress.NULL.asSegment(4000L, ResourceScope.globalScope());\n+        MemorySegment.ofAddress(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -37,0 +36,2 @@\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -50,0 +51,3 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -70,1 +74,1 @@\n-    public void testOpAfterClose(String name, ScopedOperation scopedOperation) {\n+    public <Z> void testOpAfterClose(String name, ScopedOperation<Z> scopedOperation) {\n@@ -72,0 +76,1 @@\n+        Z obj = scopedOperation.apply(scope);\n@@ -74,1 +79,1 @@\n-            scopedOperation.accept(scope);\n+            scopedOperation.accept(obj);\n@@ -82,1 +87,1 @@\n-    public void testOpOutsideConfinement(String name, ScopedOperation scopedOperation) {\n+    public <Z> void testOpOutsideConfinement(String name, ScopedOperation<Z> scopedOperation) {\n@@ -84,0 +89,1 @@\n+            Z obj = scopedOperation.apply(scope);\n@@ -87,1 +93,1 @@\n-                    scopedOperation.accept(scope);\n+                    scopedOperation.accept(obj);\n@@ -109,3 +115,4 @@\n-            ResourceScope.Handle handle = scope.acquire();\n-            scope.release(handle);\n-        }, \"ResourceScope::lock\");\n+            ResourceScope scope2 = ResourceScope.newConfinedScope();\n+            scope2.keepAlive(scope);\n+            scope2.close();\n+        }, \"ResourceScope::keepAlive\");\n@@ -120,4 +127,3 @@\n-        ScopedOperation.ofScope(scope -> CLinker.VaList.make(b -> {}, scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> CLinker.VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> CLinker.toCString(\"Hello\", scope), \"CLinker::toCString\");\n-        ScopedOperation.ofScope(SegmentAllocator::arenaAllocator, \"SegmentAllocator::arenaAllocator\");\n+        ScopedOperation.ofScope(scope -> VaList.make(b -> b.addVarg(JAVA_INT, 42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(SegmentAllocator::newNativeArena, \"SegmentAllocator::arenaAllocator\");\n@@ -125,7 +131,1 @@\n-        ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+        ScopedOperation.ofSegment(s -> s.toArray(JAVA_BYTE), \"MemorySegment::toArray(BYTE)\");\n@@ -133,1 +133,0 @@\n-        ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n@@ -137,3 +136,0 @@\n-        \/\/ address operations\n-        ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n-        ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n@@ -141,8 +137,9 @@\n-        ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n-        ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n-        ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n-        ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n-        ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n-        ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n-        ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n-        ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n+        ScopedOperation.ofVaList(VaList::address, \"VaList::address\");\n+        ScopedOperation.ofVaList(VaList::copy, \"VaList::copy\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.ADDRESS), \"VaList::nextVarg\/address\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_INT), \"VaList::nextVarg\/int\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_LONG), \"VaList::nextVarg\/long\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_DOUBLE), \"VaList::nextVarg\/double\");\n+        ScopedOperation.ofVaList(VaList::skip, \"VaList::skip\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT),\n+                SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[4]))), \"VaList::nextVargs\/segment\");\n@@ -152,16 +149,18 @@\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        \/\/ native symbol\n+        ScopedOperation.of(scope -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, scope), NativeSymbol::address, \"NativeSymbol::address\");\n@@ -175,1 +174,1 @@\n-    static class ScopedOperation implements Consumer<ResourceScope> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<ResourceScope, X> {\n@@ -177,1 +176,2 @@\n-        final Consumer<ResourceScope> scopeConsumer;\n+        final Function<ResourceScope, X> factory;\n+        final Consumer<X> operation;\n@@ -180,2 +180,3 @@\n-        private ScopedOperation(Consumer<ResourceScope> scopeConsumer, String name) {\n-            this.scopeConsumer = scopeConsumer;\n+        private ScopedOperation(Function<ResourceScope, X> factory, Consumer<X> operation, String name) {\n+            this.factory = factory;\n+            this.operation = operation;\n@@ -186,2 +187,2 @@\n-        public void accept(ResourceScope scope) {\n-            scopeConsumer.accept(scope);\n+        public void accept(X obj) {\n+            operation.accept(obj);\n@@ -190,2 +191,3 @@\n-        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n-            scopedOperations.add(new ScopedOperation(scopeConsumer::accept, name));\n+        @Override\n+        public X apply(ResourceScope scope) {\n+            return factory.apply(scope);\n@@ -194,5 +196,2 @@\n-        static void ofVaList(Consumer<CLinker.VaList> vaListConsumer, String name) {\n-            scopedOperations.add(new ScopedOperation(scope -> {\n-                CLinker.VaList vaList = CLinker.VaList.make((builder) -> {}, scope);\n-                vaListConsumer.accept(vaList);\n-            }, name));\n+        static <Z> void of(Function<ResourceScope, Z> factory, Consumer<Z> consumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(factory, consumer, name));\n@@ -201,7 +200,7 @@\n-        static void ofSegment(Consumer<MemorySegment> segmentConsumer, String name) {\n-            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    MemorySegment segment = segmentFactory.segmentFactory.apply(scope);\n-                    segmentConsumer.accept(segment);\n-                }, segmentFactory.name() + \"\/\" + name));\n-            }\n+        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(Function.identity(), scopeConsumer, name));\n+        }\n+\n+        static void ofVaList(Consumer<VaList> vaListConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(scope -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), scope),\n+                    vaListConsumer, name));\n@@ -210,1 +209,1 @@\n-        static void ofAddress(Consumer<MemoryAddress> addressConsumer, String name) {\n+        static void ofSegment(Consumer<MemorySegment> segmentConsumer, String name) {\n@@ -212,4 +211,4 @@\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    MemoryAddress segment = segmentFactory.segmentFactory.apply(scope).address();\n-                    addressConsumer.accept(segment);\n-                }, segmentFactory.name() + \"\/\" + name));\n+                scopedOperations.add(new ScopedOperation<>(\n+                        segmentFactory.segmentFactory,\n+                        segmentConsumer,\n+                        segmentFactory.name() + \"\/\" + name));\n@@ -221,4 +220,4 @@\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    SegmentAllocator allocator = allocatorFactory.allocatorFactory.apply(scope);\n-                    allocatorConsumer.accept(allocator);\n-                }, allocatorFactory.name() + \"\/\" + name));\n+                scopedOperations.add(new ScopedOperation<>(\n+                        allocatorFactory.allocatorFactory,\n+                        allocatorConsumer,\n+                        allocatorFactory.name() + \"\/\" + name));\n@@ -238,1 +237,1 @@\n-            UNSAFE(scope -> MemoryAddress.NULL.asSegment(10, scope));\n+            UNSAFE(scope -> MemorySegment.ofAddress(MemoryAddress.NULL, 10, scope));\n@@ -258,7 +257,2 @@\n-            ARENA_BOUNDED(scope -> SegmentAllocator.arenaAllocator(1000, scope)),\n-            ARENA_UNBOUNDED(SegmentAllocator::arenaAllocator),\n-            FROM_SEGMENT(scope -> {\n-                MemorySegment segment = MemorySegment.allocateNative(10, scope);\n-                return SegmentAllocator.ofSegment(segment);\n-            }),\n-            FROM_SCOPE(SegmentAllocator::ofScope);\n+            ARENA_BOUNDED(scope -> SegmentAllocator.newNativeArena(1000, scope)),\n+            ARENA_UNBOUNDED(SegmentAllocator::newNativeArena);\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":79,"deletions":85,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.CharBuffer;\n@@ -54,1 +55,1 @@\n-    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n+    final static Class<?> ADDRESS_CARRIER = ValueLayout.ADDRESS.bitSize() == 64 ? long.class : int.class;\n@@ -57,2 +58,4 @@\n-    public <Z> void testAllocation(Z value, AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n-        ValueLayout[] layouts = {\n+    @SuppressWarnings(\"unchecked\")\n+    public <Z, L extends ValueLayout> void testAllocation(Z value, AllocationFactory allocationFactory, L layout, AllocationFunction<Z, L> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n+        layout = (L)layout.withBitAlignment(layout.bitSize());\n+        L[] layouts = (L[])new ValueLayout[] {\n@@ -64,1 +67,1 @@\n-        for (ValueLayout alignedLayout : layouts) {\n+        for (L alignedLayout : layouts) {\n@@ -83,1 +86,1 @@\n-                        allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n+                        allocationFunction.allocate(allocator, alignedLayout, value);\n@@ -90,3 +93,5 @@\n-                \/\/ addresses should be invalid now\n-                for (MemorySegment address : addressList) {\n-                    assertFalse(address.scope().isAlive());\n+                if (allocationFactory != AllocationFactory.IMPLICIT_ALLOCATOR) {\n+                    \/\/ addresses should be invalid now\n+                    for (MemorySegment address : addressList) {\n+                        assertFalse(address.scope().isAlive());\n+                    }\n@@ -103,1 +108,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -114,1 +119,1 @@\n-    @Test(expectedExceptions = OutOfMemoryError.class)\n+    @Test\n@@ -117,2 +122,3 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(10, scope);\n-            allocator.allocate(12);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(10, scope);\n+            assertThrows(OutOfMemoryError.class, () -> allocator.allocate(12));\n+            allocator.allocate(5); \/\/ ok\n@@ -125,1 +131,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(4 * 1024 * 2, scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(4 * 1024 * 2, scope);\n@@ -130,0 +136,5 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadUnboundedArenaSize() {\n+        SegmentAllocator.newNativeArena( -1, ResourceScope.globalScope());\n+    }\n+\n@@ -131,1 +142,1 @@\n-    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object, ValueLayout> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n@@ -149,105 +160,52 @@\n-        return new Object[][] {\n-                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-        };\n+        List<Object[]> nativeScopes = new ArrayList<>();\n+        for (AllocationFactory factory : AllocationFactory.values()) {\n+            nativeScopes.add(new Object[] { (byte)42, factory, ValueLayout.JAVA_BYTE,\n+                    (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42, factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+\n+            nativeScopes.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42, factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+        }\n+        return nativeScopes.toArray(Object[][]::new);\n@@ -258,94 +216,44 @@\n-        return new Object[][] {\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n+        List<Object[]> arrayScopes = new ArrayList<>();\n+        for (AllocationFactory factory : AllocationFactory.values()) {\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_BYTE,\n+                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toByteArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toCharArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toShortArray });\n+            arrayScopes.add(new Object[] { factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toIntArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toFloatArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toLongArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toDoubleArray });\n+\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toCharArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toShortArray });\n+            arrayScopes.add(new Object[] { factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toIntArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toFloatArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toLongArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toDoubleArray });\n@@ -353,0 +261,1 @@\n+        return arrayScopes.toArray(Object[][]::new);\n@@ -355,2 +264,20 @@\n-    interface AllocationFunction<X> {\n-        MemorySegment allocate(SegmentAllocator allocator, ValueLayout layout, X value);\n+    interface AllocationFunction<X, L extends ValueLayout> {\n+        MemorySegment allocate(SegmentAllocator allocator, L layout, X value);\n+\n+        interface OfByte extends AllocationFunction<Byte, ValueLayout.OfByte> { }\n+        interface OfBoolean extends AllocationFunction<Boolean, ValueLayout.OfBoolean> { }\n+        interface OfChar extends AllocationFunction<Character, ValueLayout.OfChar> { }\n+        interface OfShort extends AllocationFunction<Short, ValueLayout.OfShort> { }\n+        interface OfInt extends AllocationFunction<Integer, ValueLayout.OfInt> { }\n+        interface OfFloat extends AllocationFunction<Float, ValueLayout.OfFloat> { }\n+        interface OfLong extends AllocationFunction<Long, ValueLayout.OfLong> { }\n+        interface OfDouble extends AllocationFunction<Double, ValueLayout.OfDouble> { }\n+        interface OfAddress extends AllocationFunction<MemoryAddress, ValueLayout.OfAddress> { }\n+\n+        interface OfByteArray extends AllocationFunction<byte[], ValueLayout.OfByte> { }\n+        interface OfCharArray extends AllocationFunction<char[], ValueLayout.OfChar> { }\n+        interface OfShortArray extends AllocationFunction<short[], ValueLayout.OfShort> { }\n+        interface OfIntArray extends AllocationFunction<int[], ValueLayout.OfInt> { }\n+        interface OfFloatArray extends AllocationFunction<float[], ValueLayout.OfFloat> { }\n+        interface OfLongArray extends AllocationFunction<long[], ValueLayout.OfLong> { }\n+        interface OfDoubleArray extends AllocationFunction<double[], ValueLayout.OfDouble> { }\n@@ -359,1 +286,6 @@\n-    static class AllocationFactory {\n+    enum AllocationFactory {\n+        ARENA_BOUNDED(true, SegmentAllocator::newNativeArena),\n+        ARENA_UNBOUNDED(false, (size, scope) -> SegmentAllocator.newNativeArena(scope)),\n+        NATIVE_ALLOCATOR(false, (size, scope) -> SegmentAllocator.nativeAllocator(scope)),\n+        IMPLICIT_ALLOCATOR(false, (size, scope) -> SegmentAllocator.implicitAllocator());\n+\n@@ -363,1 +295,1 @@\n-        private AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n+        AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n@@ -375,3 +307,0 @@\n-\n-        static AllocationFactory BOUNDED = new AllocationFactory(true, SegmentAllocator::arenaAllocator);\n-        static AllocationFactory UNBOUNDED = new AllocationFactory(false, (size, scope) -> SegmentAllocator.arenaAllocator(scope));\n@@ -399,0 +328,15 @@\n+        ToArrayHelper<char[]> toCharArray = new ToArrayHelper<>() {\n+            @Override\n+            public char[] array() {\n+                return new char[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public char[] toArray(MemorySegment segment, ValueLayout layout) {\n+                CharBuffer buffer = segment.asByteBuffer().order(layout.order()).asCharBuffer();\n+                char[] found = new char[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n@@ -477,1 +421,1 @@\n-                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                return switch ((int) ValueLayout.ADDRESS.byteSize()) {\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":165,"deletions":221,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentCopy\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentCopy {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n+        int size = Math.min(s1.byteSize(), s2.byteSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s2, i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s1, i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.check(s2, i, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.type.carrier != s2.type.carrier) return;\n+        int size = Math.min(s1.elementSize(), s2.elementSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            s2.set(i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            s1.set(i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0; i < size; i++) {\n+            s2.check(i, i);\n+        }\n+    }\n+\n+    interface Getter<X> {\n+        X get(MemorySegment segment, ValueLayout layout, long index);\n+    }\n+\n+    interface Setter<X> {\n+        void set(MemorySegment segment, ValueLayout layout, long index, X val);\n+    }\n+\n+    enum Type {\n+        \/\/ Byte\n+        BYTE(byte.class, ValueLayout.JAVA_BYTE, i -> (byte)i),\n+        \/\/LE\n+        SHORT_LE(short.class, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n+        CHAR_LE(char.class, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n+        INT_LE(int.class, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n+        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n+        LONG_LE(long.class, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n+        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n+        \/\/BE\n+        SHORT_BE(short.class, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n+        CHAR_BE(char.class, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n+        INT_BE(int.class, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n+        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n+        LONG_BE(long.class, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n+        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n+\n+        final ValueLayout layout;\n+        final IntFunction<Object> valueConverter;\n+        final Class<?> carrier;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <Z> Type(Class<Z> carrier, ValueLayout layout, IntFunction<Z> valueConverter) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.valueConverter = (IntFunction<Object>)valueConverter;\n+        }\n+\n+        int size() {\n+            return (int)layout.byteSize();\n+        }\n+\n+        VarHandle handle() {\n+            return MemoryHandles.varHandle(layout);\n+        }\n+\n+        void set(SegmentSlice slice, int index, int val) {\n+            handle().set(slice.segment, index * size(), valueConverter.apply(val));\n+        }\n+\n+        void check(SegmentSlice slice, int index, int val) {\n+            assertEquals(handle().get(slice.segment, index * size()), valueConverter.apply(val));\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final Type type;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.type = type;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        void set(int index, int val) {\n+            type.set(this, index, val);\n+        }\n+\n+        void check(int index, int val) {\n+            type.check(this, index, val);\n+        }\n+\n+        int byteSize() {\n+            return last - first + 1;\n+        }\n+\n+        int elementSize() {\n+            return byteSize() \/ type.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] elementSlices() {\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            MemorySegment segment = kind.makeSegment(16);\n+            \/\/compute all slices\n+            for (Type type : Type.values()) {\n+                for (int index = 0; index < 16; index += type.size()) {\n+                    MemorySegment first = segment.asSlice(0, index);\n+                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n+                    MemorySegment second = segment.asSlice(index);\n+                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentOffset\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import static java.lang.System.out;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOffset {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testOffset(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.contains(s2)) {\n+            \/\/ check that a segment and its overlapping segment point to same elements\n+            long offset = s1.segment.segmentOffset(s2.segment);\n+            for (int i = 0; i < s2.size(); i++) {\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d, i:%s\\n\", s1, s2, offset, i);\n+                byte expected = s2.segment.get(JAVA_BYTE, i);\n+                byte found = s1.segment.get(JAVA_BYTE, i + offset);\n+                assertEquals(found, expected);\n+            }\n+        } else if (s1.kind != s2.kind) {\n+            \/\/ check that offset from s1 to s2 fails\n+            try {\n+                long offset = s1.segment.segmentOffset(s2.segment);\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n+                fail(\"offset unexpectedly passed!\");\n+            } catch (UnsupportedOperationException ex) {\n+                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n+            }\n+        } else if (!s2.contains(s1)) {\n+            \/\/ disjoint segments - check that offset is out of bounds\n+            long offset = s1.segment.segmentOffset(s2.segment);\n+            for (int i = 0; i < s2.size(); i++) {\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d, i:%s\\n\", s1, s2, offset, i);\n+                s2.segment.get(JAVA_BYTE, i);\n+                try {\n+                    s1.segment.get(JAVA_BYTE, i + offset);\n+                    fail(\"Offset on a disjoint segment is not out of bounds!\");\n+                } catch (IndexOutOfBoundsException ex) {\n+                    assertTrue(true);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        boolean contains(SegmentSlice other) {\n+            return kind == other.kind &&\n+                    first <= other.first &&\n+                    last >= other.last;\n+        }\n+\n+        int size() {\n+            return last - first + 1;\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] slices() {\n+        int[] sizes = { 16, 8, 4, 2, 1 };\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            \/\/ init root segment\n+            MemorySegment segment = kind.makeSegment(16);\n+            for (int i = 0 ; i < 16 ; i++) {\n+                segment.set(JAVA_BYTE, i, (byte)i);\n+            }\n+            \/\/ compute all slices\n+            for (int size : sizes) {\n+                for (int index = 0 ; index < 16 ; index += size) {\n+                    MemorySegment slice = segment.asSlice(index, size);\n+                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentOverlap\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+import static java.lang.System.out;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOverlap {\n+\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"buffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+            Files.write(file.toPath(), new byte[16], StandardOpenOption.WRITE);\n+\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"segmentFactories\")\n+    public Object[][] segmentFactories() {\n+        List<Supplier<MemorySegment>> l = List.of(\n+                () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()),\n+                () -> {\n+                    try {\n+                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                },\n+                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 } ),\n+                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' } ),\n+                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n+                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f } ),\n+                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n+                () -> MemorySegment.ofArray(new long[] { 1L, 2L, 3L, 4L } ),\n+                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testBasic(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = segmentSupplier.get();\n+        var sOther = s1.isNative() ? OtherSegmentFactory.HEAP.factory.get()\n+                : OtherSegmentFactory.NATIVE.factory.get();\n+        out.format(\"testBasic s1:%s, s2:%s, sOther:%s\\n\", s1, s2, sOther);\n+        assertNull(s1.asOverlappingSlice(s2));\n+        assertNull(s2.asOverlappingSlice(s1));\n+        assertNull(s1.asOverlappingSlice(sOther));\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testIdentical(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = s1.asReadOnly();\n+        out.format(\"testIdentical s1:%s, s2:%s\\n\", s1, s2);\n+        assertEquals(s1.asOverlappingSlice(s2).byteSize(), s1.byteSize());\n+        assertEquals(s1.asOverlappingSlice(s2).scope(), s1.scope());\n+\n+        assertEquals(s2.asOverlappingSlice(s1).byteSize(), s2.byteSize());\n+        assertEquals(s2.asOverlappingSlice(s1).scope(), s2.scope());\n+\n+        if (s1.isNative()) {\n+            assertEquals(s1.asOverlappingSlice(s2).address(), s1.address());\n+            assertEquals(s2.asOverlappingSlice(s1).address(), s2.address());\n+        }\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testSlices(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment s1 = segmentSupplier.get();\n+        MemorySegment s2 = segmentSupplier.get();\n+        for (int offset = 0 ; offset < 4 ; offset++) {\n+            MemorySegment slice = s1.asSlice(offset);\n+            out.format(\"testSlices s1:%s, s2:%s, slice:%s, offset:%d\\n\", s1, s2, slice, offset);\n+            assertEquals(s1.asOverlappingSlice(slice).byteSize(), s1.byteSize() - offset);\n+            assertEquals(s1.asOverlappingSlice(slice).scope(), s1.scope());\n+\n+            assertEquals(slice.asOverlappingSlice(s1).byteSize(), slice.byteSize());\n+            assertEquals(slice.asOverlappingSlice(s1).scope(), slice.scope());\n+\n+            if (s1.isNative()) {\n+                assertEquals(s1.asOverlappingSlice(slice).address(), s1.address().addOffset(offset));\n+                assertEquals(slice.asOverlappingSlice(s1).address(), slice.address());\n+            }\n+            assertNull(s2.asOverlappingSlice(slice));\n+        }\n+    }\n+\n+    enum OtherSegmentFactory {\n+        NATIVE(() -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope())),\n+        HEAP(() -> MemorySegment.ofArray(new byte[]{16}));\n+\n+        final Supplier<MemorySegment> factory;\n+\n+        OtherSegmentFactory(Supplier<MemorySegment> segmentFactory) {\n+            this.factory = segmentFactory;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -40,1 +39,0 @@\n-import java.nio.ByteOrder;\n@@ -44,1 +42,0 @@\n-import java.util.function.LongFunction;\n@@ -47,0 +44,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -56,5 +54,0 @@\n-    @Test(dataProvider = \"badLayouts\", expectedExceptions = UnsupportedOperationException.class)\n-    public void testBadAllocateLayout(MemoryLayout layout) {\n-        MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n-    }\n-\n@@ -74,2 +67,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -86,2 +79,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -110,1 +103,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        memorySegment.get(JAVA_INT, offset);\n@@ -117,1 +110,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        memorySegment.get(JAVA_INT, offset);\n@@ -128,1 +121,1 @@\n-        if (!segment.scope().isImplicit()) {\n+        if (segment.scope() != ResourceScope.globalScope()) {\n@@ -145,4 +138,4 @@\n-                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newConfinedScope())\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope())\n@@ -156,2 +149,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -196,1 +189,1 @@\n-    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {\n+    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) {\n@@ -199,1 +192,1 @@\n-            segment.address().toRawLongValue();\n+            segment.address();\n@@ -201,1 +194,0 @@\n-            assertTrue(segment.address().isNative());\n@@ -204,1 +196,0 @@\n-            assertFalse(segment.address().isNative());\n@@ -265,27 +256,0 @@\n-    @DataProvider(name = \"badLayouts\")\n-    public Object[][] layouts() {\n-        SizedLayoutFactory[] layoutFactories = SizedLayoutFactory.values();\n-        Object[][] values = new Object[layoutFactories.length * 2][2];\n-        for (int i = 0; i < layoutFactories.length ; i++) {\n-            values[i * 2] = new Object[] { MemoryLayout.structLayout(layoutFactories[i].make(7), MemoryLayout.paddingLayout(9)) }; \/\/ good size, bad align\n-            values[(i * 2) + 1] = new Object[] { layoutFactories[i].make(15).withBitAlignment(16) }; \/\/ bad size, good align\n-        }\n-        return values;\n-    }\n-\n-    enum SizedLayoutFactory {\n-        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n-        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n-        PADDING(MemoryLayout::paddingLayout);\n-\n-        private final LongFunction<MemoryLayout> factory;\n-\n-        SizedLayoutFactory(LongFunction<MemoryLayout> factory) {\n-            this.factory = factory;\n-        }\n-\n-        MemoryLayout make(long size) {\n-            return factory.apply(size);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":17,"deletions":53,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -50,1 +50,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -101,1 +101,1 @@\n-            MemorySegment sharedSegment = s.address().asSegment(s.byteSize(), scope);\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), scope);\n@@ -124,1 +124,1 @@\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, MemoryLayouts.JAVA_INT), scope);\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +42,1 @@\n-            MemoryLayout.sequenceLayout(5, MemoryLayouts.JAVA_INT));\n+            MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT));\n@@ -44,1 +44,1 @@\n-    static VarHandle VH_ALL = LAYOUT.varHandle(int.class,\n+    static VarHandle VH_ALL = LAYOUT.varHandle(\n@@ -79,1 +79,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -82,1 +82,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -85,1 +85,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -88,1 +88,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -43,1 +42,0 @@\n-import java.util.stream.StreamSupport;\n@@ -45,0 +43,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -51,2 +50,2 @@\n-    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -58,1 +57,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(size, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(size, ValueLayout.JAVA_INT);\n@@ -85,1 +84,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -103,1 +102,1 @@\n-        MemorySegment.ofArray(new byte[2]).spliterator(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[2]).spliterator(ValueLayout.JAVA_INT);\n@@ -108,1 +107,1 @@\n-        MemorySegment.ofArray(new byte[2]).elements(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[2]).elements(ValueLayout.JAVA_INT);\n@@ -113,1 +112,1 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[7]).spliterator(ValueLayout.JAVA_INT);\n@@ -118,1 +117,1 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[7]).elements(ValueLayout.JAVA_INT);\n@@ -123,1 +122,1 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n@@ -128,1 +127,1 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -43,1 +43,2 @@\n-            MemorySegment text = CLinker.toCString(testString, scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(expectedByteLength, scope);\n+            MemorySegment text = allocator.allocateUtf8String(testString);\n@@ -47,1 +48,1 @@\n-            String roundTrip = CLinker.toJavaString(text);\n+            String roundTrip = text.getUtf8String(0);\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -36,0 +34,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +37,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -64,2 +64,2 @@\n-        MemorySegment segment = LOOKUP.lookup(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n+        MemorySegment segment = MemorySegment.ofAddress(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        assertEquals(segment.get(JAVA_BYTE, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -41,3 +40,2 @@\n-    static final VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-\n-    static final VarHandle ADDR_HANDLE = MemoryHandles.asAddressVarHandle(INT_HANDLE);\n+    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle ADDR_HANDLE = ValueLayout.ADDRESS.varHandle();\n@@ -47,4 +45,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n-            int v = (int)INT_HANDLE.get(\"string\");\n-        }\n+        int v = (int)INT_HANDLE.get(\"string\");\n@@ -55,4 +50,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n-            int v = (int)INT_HANDLE.get(1);\n-        }\n+        int v = (int)INT_HANDLE.get(1);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        CLinker.getInstance(); \/\/ trigger initialization\n+        CLinker.systemCLinker(); \/\/ trigger initialization\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=async\n@@ -33,0 +33,1 @@\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -36,0 +37,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +40,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -44,0 +48,1 @@\n+import org.testng.SkipException;\n@@ -51,0 +56,1 @@\n+import java.util.HashMap;\n@@ -52,0 +58,1 @@\n+import java.util.Map;\n@@ -57,1 +64,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -63,0 +69,8 @@\n+    private enum TestType {\n+        SCOPE,\n+        NO_SCOPE,\n+        ASYNC\n+    }\n+\n+    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n+\n@@ -65,0 +79,1 @@\n+        System.loadLibrary(\"AsyncInvokers\");\n@@ -66,1 +81,1 @@\n-    static CLinker abi = CLinker.getInstance();\n+    static CLinker abi = CLinker.systemCLinker();\n@@ -83,1 +98,1 @@\n-    static MemoryAddress dummyStub;\n+    static NativeSymbol dummyStub;\n@@ -90,0 +105,5 @@\n+    private static void checkSelected(TestType type) {\n+        if (UPCALL_TEST_TYPE != type)\n+            return;\/\/throw new SkipException(\"Skipping tests that were not selected\");\n+    }\n+\n@@ -92,0 +112,2 @@\n+        checkSelected(TestType.SCOPE);\n+\n@@ -94,5 +116,5 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n-        try (NativeScope scope = new NativeScope()) {\n-            MethodHandle mh = abi.downcallHandle(addr, scope, mtype, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(scope.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n@@ -109,1 +131,2 @@\n-    public void testUpcallsNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.ASYNC);\n@@ -112,9 +135,23 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n-        MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n-        Object[] callArgs = args;\n-        Object res = mh.invokeWithArguments(callArgs);\n-        argChecks.forEach(c -> c.accept(args));\n-        if (ret == Ret.NON_VOID) {\n-            returnChecks.forEach(c -> c.accept(res));\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(allocator, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n@@ -124,5 +161,9 @@\n-    static MethodType methodType(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        MethodType mt = ret == Ret.VOID ?\n-                MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));\n-        for (ParamType p : params) {\n-            mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                abi.downcallHandle(\n+                    LOOKUP.lookup(symbol).orElseThrow(),\n+                        FunctionDescriptor.ofVoid(C_POINTER)));\n@@ -130,2 +171,11 @@\n-        mt = mt.appendParameterTypes(MemoryAddress.class); \/\/the callback\n-        return mt;\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, desc);\n+        });\n@@ -153,1 +203,1 @@\n-    static MemoryAddress makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n@@ -155,1 +205,1 @@\n-            return dummyStub.address();\n+            return dummyStub;\n@@ -165,1 +215,1 @@\n-            Class<?> carrier = paramCarrier(layout);\n+            Class<?> carrier = carrier(layout, false);\n@@ -178,1 +228,1 @@\n-        Class<?> firstCarrier = paramCarrier(firstlayout);\n+        Class<?> firstCarrier = carrier(firstlayout, true);\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":80,"deletions":30,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.ResourceScope;\n@@ -57,2 +54,2 @@\n-        boolean useSpec = false;\n-        run(useSpec);\n+        run(\/* useSpec = *\/ false, \/* isVoid = *\/ true);\n+        run(\/* useSpec = *\/ false, \/* isVoid = *\/ false);\n@@ -63,2 +60,2 @@\n-        boolean useSpec = true;\n-        run(useSpec);\n+        run(\/* useSpec = *\/ true, \/* isVoid = *\/ true);\n+        run(\/* useSpec = *\/ true, \/* isVoid = *\/ false);\n@@ -67,1 +64,1 @@\n-    private void run(boolean useSpec) throws IOException, InterruptedException {\n+    private void run(boolean useSpec, boolean isVoid) throws IOException, InterruptedException {\n@@ -80,1 +77,2 @@\n-                \"ThrowingUpcall\")\n+                \"ThrowingUpcall\",\n+                isVoid ? \"void\" : \"non-void\")\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -52,1 +54,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -58,1 +59,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -73,6 +74,1 @@\n-                MethodType.methodType(void.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER,\n+                    FunctionDescriptor.ofVoid(C_POINTER,\n@@ -111,1 +107,1 @@\n-            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n@@ -113,1 +109,1 @@\n-            args[0] = upcallStub.address();\n+            args[0] = upcallStub;\n@@ -126,1 +122,1 @@\n-                    assertEquals(capturedArgsArr[i], args[i + 1]);\n+                    assertEquals(capturedArgsArr[i], args[i + 1], \"For index \" + i);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -42,0 +43,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -55,3 +57,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -60,1 +59,1 @@\n-public class TestUpcallStructScope {\n+public class TestUpcallStructScope extends NativeTestHelper {\n@@ -62,1 +61,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -77,2 +76,1 @@\n-            MethodType.methodType(void.class, MemoryAddress.class, MemorySegment.class),\n-            FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n+                FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n@@ -99,1 +97,1 @@\n-            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n@@ -101,1 +99,1 @@\n-            MH_do_upcall.invokeExact(upcallStub.address(), argSegment);\n+            MH_do_upcall.invoke(upcallStub, argSegment);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -48,1 +49,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -52,1 +52,1 @@\n-public class TestVarArgs {\n+public class TestVarArgs extends NativeTestHelper {\n@@ -58,2 +58,2 @@\n-    static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(long.class, groupElement(\"writeback\"));\n-    static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(long.class, groupElement(\"argIDs\"));\n+    static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(groupElement(\"writeback\"));\n+    static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(groupElement(\"argIDs\"));\n@@ -61,1 +61,1 @@\n-    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(sequenceElement());\n@@ -63,1 +63,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -68,1 +68,1 @@\n-    static final MemoryAddress VARARGS_ADDR =\n+    static final NativeSymbol VARARGS_ADDR =\n@@ -83,2 +83,2 @@\n-            VH_CallInfo_writeback.set(callInfo, writeBack.address().toRawLongValue());\n-            VH_CallInfo_argIDs.set(callInfo, argIDs.address().toRawLongValue());\n+            VH_CallInfo_writeback.set(callInfo, writeBack.address());\n+            VH_CallInfo_argIDs.set(callInfo, argIDs.address());\n@@ -93,1 +93,0 @@\n-            args.forEach(a -> argLayouts.add(asVarArg(a.layout)));\n@@ -95,1 +94,2 @@\n-            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new));\n+            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.stream().toArray(MemoryLayout[]::new))\n+                    .asVariadic(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n@@ -104,1 +104,1 @@\n-            MethodHandle downcallHandle = abi.downcallHandle(VARARGS_ADDR, mt, desc);\n+            MethodHandle downcallHandle = abi.downcallHandle(VARARGS_ADDR, desc);\n@@ -143,1 +143,1 @@\n-            this.vh = layout.varHandle(carrier);\n+            this.vh = layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -46,1 +47,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE);\n@@ -55,1 +56,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n@@ -63,10 +64,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testAlignNotPowerOf2() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testAlignNegative() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, -1, ByteOrder.nativeOrder());\n-    }\n-\n@@ -75,1 +66,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n@@ -84,1 +75,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN));\n@@ -94,1 +85,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -109,1 +100,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n@@ -124,17 +115,0 @@\n-\n-    @Test(dataProvider = \"badCarriers\", expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarrier(Class<?> carrier) {\n-        MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n-    }\n-\n-    @DataProvider(name = \"badCarriers\")\n-    public Object[][] createBadCarriers() {\n-        return new Object[][] {\n-                { void.class },\n-                { boolean.class },\n-                { Object.class },\n-                { int[].class },\n-                { MemorySegment.class }\n-        };\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,1 +33,0 @@\n-import java.security.Permission;\n@@ -35,1 +34,1 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n+public class ThrowingUpcall extends NativeTestHelper {\n@@ -37,3 +36,2 @@\n-public class ThrowingUpcall {\n-\n-    private static final MethodHandle downcall;\n+    private static final MethodHandle downcallVoid;\n+    private static final MethodHandle downcallNonVoid;\n@@ -45,1 +43,1 @@\n-        downcall = CLinker.getInstance().downcallHandle(\n+        downcallVoid = CLinker.systemCLinker().downcallHandle(\n@@ -47,2 +45,5 @@\n-            MethodType.methodType(void.class, MemoryAddress.class),\n-            FunctionDescriptor.ofVoid(C_POINTER)\n+                FunctionDescriptor.ofVoid(C_POINTER)\n+        );\n+        downcallNonVoid = CLinker.systemCLinker().downcallHandle(\n+            lookup.lookup(\"f10_I_I_\").orElseThrow(),\n+                FunctionDescriptor.of(C_INT, C_INT, C_POINTER)\n@@ -64,1 +65,5 @@\n-        test();\n+        if (args[0].equals(\"void\")) {\n+            testVoid();\n+        } else {\n+            testNonVoid();\n+        }\n@@ -67,1 +72,1 @@\n-    public static void test() throws Throwable {\n+    public static void testVoid() throws Throwable {\n@@ -73,1 +78,14 @@\n-            MemoryAddress stub = CLinker.getInstance().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+\n+            downcallVoid.invoke(stub); \/\/ should call Shutdown.exit(1);\n+        }\n+    }\n+\n+    public static void testNonVoid() throws Throwable {\n+        MethodHandle handle = MethodHandles.identity(int.class);\n+        handle = MethodHandles.collectArguments(handle, 0, MH_throwException);\n+        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(int.class, int.class));\n+        handle = MethodHandles.insertArguments(invoker, 0, handle);\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), scope);\n@@ -75,1 +93,1 @@\n-            downcall.invokeExact(stub); \/\/ should call Shutdown.exit(1);\n+            downcallNonVoid.invoke(42, stub); \/\/ should call Shutdown.exit(1);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -81,1 +81,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -106,1 +106,1 @@\n-      MethodType mt = MethodType.methodType(void.class,\n+        MethodType mt = MethodType.methodType(void.class,\n@@ -110,1 +110,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -131,1 +131,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -160,2 +160,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -191,1 +190,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -201,2 +200,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -207,2 +205,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -223,1 +220,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -246,1 +243,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -272,1 +269,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -308,1 +305,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -361,1 +358,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -369,2 +366,2 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(r0, long.class) },\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(r1, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r1, long.class) },\n@@ -377,1 +374,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n@@ -383,0 +380,42 @@\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":60,"deletions":21,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -159,2 +159,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -181,1 +180,1 @@\n-                C_INT, C_DOUBLE, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE));\n+                C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n@@ -254,2 +253,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -353,1 +351,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(rcx, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(rcx, long.class) },\n@@ -357,1 +355,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n@@ -361,1 +359,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(4), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(4), long.class) },\n@@ -365,1 +363,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(8), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(8), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.ref.Cleaner;\n@@ -32,1 +31,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -37,0 +36,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -54,1 +55,1 @@\n-        if (scope.isImplicit())\n+        if (scope == ResourceScope.globalScope())\n@@ -78,1 +79,1 @@\n-            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+            segment.set(JAVA_BYTE, i, ((byte)RANDOM.nextInt()));\n@@ -132,1 +133,0 @@\n-                { ScopeSupplier.NEW_CONFINED_EXPLICIT },\n@@ -140,1 +140,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT },\n@@ -154,1 +153,0 @@\n-                { ScopeSupplier.NEW_IMPLICIT },\n@@ -177,1 +175,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT ,  0 },\n@@ -179,1 +176,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT , 30 },\n@@ -186,3 +182,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newConfinedScope(), \"newConfinedScope()\");\n-        static final Supplier<ResourceScope> NEW_CONFINED_EXPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newConfinedScope(Cleaner.create()), \"newConfinedScope(Cleaner)\");\n+                new ScopeSupplier(ResourceScope::newConfinedScope, \"newConfinedScope()\");\n@@ -190,3 +184,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newSharedScope(), \"newSharedScope()\");\n-        static final Supplier<ResourceScope> NEW_SHARED_EXPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newSharedScope(Cleaner.create()), \"newSharedScope(Cleaner)\");\n+                new ScopeSupplier(ResourceScope::newSharedScope, \"newSharedScope()\");\n@@ -194,1 +186,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newImplicitScope(), \"newImplicitScope()\");\n+                new ScopeSupplier(ResourceScope::newImplicitScope, \"newImplicitScope()\");\n@@ -196,1 +188,1 @@\n-                new ScopeSupplier(() -> ResourceScope.globalScope(), \"globalScope()\");\n+                new ScopeSupplier(ResourceScope::globalScope, \"globalScope()\");\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -57,0 +57,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -165,1 +166,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n@@ -224,1 +225,1 @@\n-                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n@@ -273,1 +274,1 @@\n-            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -47,0 +47,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -104,1 +106,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n@@ -122,1 +124,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -41,1 +41,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -48,1 +48,1 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n@@ -55,1 +55,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -55,1 +56,1 @@\n-            throw new AssertionError(\"Call to restricted method did not fail as expected!\");\n+            throw new AssertionError(\"Call to restricted method did not fail as expected!\", ex);\n@@ -66,2 +67,1 @@\n-        addDefaultMapping(CLinker.class, CLinker.getInstance());\n-        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n@@ -76,1 +76,1 @@\n-        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(MemoryLayout.class, ValueLayout.JAVA_INT);\n@@ -80,1 +80,18 @@\n-        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[10])));\n+        addDefaultMapping(ValueLayout.OfByte.class, ValueLayout.JAVA_BYTE);\n+        addDefaultMapping(ValueLayout.OfBoolean.class, ValueLayout.JAVA_BOOLEAN);\n+        addDefaultMapping(ValueLayout.OfChar.class, ValueLayout.JAVA_CHAR);\n+        addDefaultMapping(ValueLayout.OfShort.class, ValueLayout.JAVA_SHORT);\n+        addDefaultMapping(ValueLayout.OfInt.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfFloat.class, ValueLayout.JAVA_FLOAT);\n+        addDefaultMapping(ValueLayout.OfLong.class, ValueLayout.JAVA_LONG);\n+        addDefaultMapping(ValueLayout.OfDouble.class, ValueLayout.JAVA_DOUBLE);\n+        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(byte.class, (byte)0);\n+        addDefaultMapping(boolean.class, true);\n+        addDefaultMapping(char.class, (char)0);\n+        addDefaultMapping(short.class, (short)0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -32,3 +31,0 @@\n-import java.nio.charset.Charset;\n-import java.nio.file.Path;\n-import java.util.Optional;\n@@ -36,1 +32,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.Addressable;\n@@ -39,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -42,1 +37,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -44,0 +38,2 @@\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,13 +53,4 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n-                            MethodType.methodType(CLinker.class)), \"CLinker::getInstance\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"toJavaString\",\n-                            MethodType.methodType(String.class, MemoryAddress.class)),\n-                            \"CLinker::toJavaString\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"allocateMemory\",\n-                            MethodType.methodType(MemoryAddress.class, long.class)),\n-                            \"CLinker::allocateMemory\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"freeMemory\",\n-                            MethodType.methodType(void.class, MemoryAddress.class)),\n-                            \"CLinker::freeMemory\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n-                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class)),\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n+                            MethodType.methodType(CLinker.class)), \"ForeignLinker::systemCLinker\" },\n+                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n+                            MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)),\n@@ -71,6 +58,0 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n-                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class, ResourceScope.class)),\n-                            \"VaList::ofAddress\/2\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemLookup\",\n-                            MethodType.methodType(SymbolLookup.class)),\n-                            \"CLinker::systemLookup\" },\n@@ -80,9 +61,63 @@\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-                            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class)),\n-                            \"MemoryAddress::asSegment\/1\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-                            MethodType.methodType(MemorySegment.class, long.class, Runnable.class, ResourceScope.class)),\n-                            \"MemoryAddress::asSegment\/2\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"globalNativeSegment\",\n-                            MethodType.methodType(MemorySegment.class)),\n-                            \"MemoryAddress::globalNativeSegment\" }\n+                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n+                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class)),\n+                            \"MemorySegment::ofAddress\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getUtf8String\",\n+                            MethodType.methodType(String.class, long.class)),\n+                            \"MemoryAddress::getUtf8String\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setUtf8String\",\n+                            MethodType.methodType(void.class, long.class, String.class)),\n+                            \"MemoryAddress::setUtf8String\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(byte.class, ValueLayout.OfByte.class, long.class)),\n+                            \"MemoryAddress::get\/byte\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(boolean.class, ValueLayout.OfBoolean.class, long.class)),\n+                            \"MemoryAddress::get\/boolean\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n+                            \"MemoryAddress::get\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n+                            \"MemoryAddress::get\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n+                            \"MemoryAddress::get\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n+                            \"MemoryAddress::get\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n+                            \"MemoryAddress::get\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n+                            \"MemoryAddress::get\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n+                            \"MemoryAddress::get\/address\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfByte.class, long.class, byte.class)),\n+                            \"MemoryAddress::set\/byte\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfBoolean.class, long.class, boolean.class)),\n+                            \"MemoryAddress::set\/boolean\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n+                            \"MemoryAddress::set\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n+                            \"MemoryAddress::set\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n+                            \"MemoryAddress::set\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n+                            \"MemoryAddress::set\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n+                            \"MemoryAddress::set\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n+                            \"MemoryAddress::set\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n+                            \"MemoryAddress::set\/address\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":70,"deletions":35,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <thread>\n+\n+#include \"libTestUpcall.h\"\n+#ifdef __clang__\n+#pragma clang optimize off\n+#elif defined __GNUC__\n+#pragma GCC optimize (\"O0\")\n+#elif defined _MSC_BUILD\n+#pragma optimize( \"\", off )\n+#endif\n+\n+template<typename CB>\n+void launch_v(CB cb) {\n+    std::thread thrd(cb);\n+    thrd.join();\n+}\n+\n+template<typename O, typename CB>\n+void start(O& out, CB cb) {\n+    out = cb();\n+}\n+\n+template<typename O, typename CB>\n+O launch(CB cb) {\n+    O result;\n+    std::thread thrd(&start<O, CB>, std::ref(result), cb);\n+    thrd.join();\n+    return result;\n+}\n+\n+extern \"C\" {\n+EXPORT void call_async_V(void (*cb)(void)) { launch_v(cb); }\n+\n+EXPORT int call_async_I(int (*cb)(void)) { return launch<int>(cb); }\n+EXPORT float call_async_F(float (*cb)(void)) { return launch<float>(cb); }\n+EXPORT double call_async_D(double (*cb)(void)) { return launch<double>(cb); }\n+EXPORT void* call_async_P(void* (*cb)(void)) { return launch<void*>(cb); }\n+\n+EXPORT struct S_I call_async_S_I(struct S_I (*cb)(void)) { return launch<struct S_I>(cb); }\n+EXPORT struct S_F call_async_S_F(struct S_F (*cb)(void)) { return launch<struct S_F>(cb); }\n+EXPORT struct S_D call_async_S_D(struct S_D (*cb)(void)) { return launch<struct S_D>(cb); }\n+EXPORT struct S_P call_async_S_P(struct S_P (*cb)(void)) { return launch<struct S_P>(cb); }\n+EXPORT struct S_II call_async_S_II(struct S_II (*cb)(void)) { return launch<struct S_II>(cb); }\n+EXPORT struct S_IF call_async_S_IF(struct S_IF (*cb)(void)) { return launch<struct S_IF>(cb); }\n+EXPORT struct S_ID call_async_S_ID(struct S_ID (*cb)(void)) { return launch<struct S_ID>(cb); }\n+EXPORT struct S_IP call_async_S_IP(struct S_IP (*cb)(void)) { return launch<struct S_IP>(cb); }\n+EXPORT struct S_FI call_async_S_FI(struct S_FI (*cb)(void)) { return launch<struct S_FI>(cb); }\n+EXPORT struct S_FF call_async_S_FF(struct S_FF (*cb)(void)) { return launch<struct S_FF>(cb); }\n+EXPORT struct S_FD call_async_S_FD(struct S_FD (*cb)(void)) { return launch<struct S_FD>(cb); }\n+EXPORT struct S_FP call_async_S_FP(struct S_FP (*cb)(void)) { return launch<struct S_FP>(cb); }\n+EXPORT struct S_DI call_async_S_DI(struct S_DI (*cb)(void)) { return launch<struct S_DI>(cb); }\n+EXPORT struct S_DF call_async_S_DF(struct S_DF (*cb)(void)) { return launch<struct S_DF>(cb); }\n+EXPORT struct S_DD call_async_S_DD(struct S_DD (*cb)(void)) { return launch<struct S_DD>(cb); }\n+EXPORT struct S_DP call_async_S_DP(struct S_DP (*cb)(void)) { return launch<struct S_DP>(cb); }\n+EXPORT struct S_PI call_async_S_PI(struct S_PI (*cb)(void)) { return launch<struct S_PI>(cb); }\n+EXPORT struct S_PF call_async_S_PF(struct S_PF (*cb)(void)) { return launch<struct S_PF>(cb); }\n+EXPORT struct S_PD call_async_S_PD(struct S_PD (*cb)(void)) { return launch<struct S_PD>(cb); }\n+EXPORT struct S_PP call_async_S_PP(struct S_PP (*cb)(void)) { return launch<struct S_PP>(cb); }\n+EXPORT struct S_III call_async_S_III(struct S_III (*cb)(void)) { return launch<struct S_III>(cb); }\n+EXPORT struct S_IIF call_async_S_IIF(struct S_IIF (*cb)(void)) { return launch<struct S_IIF>(cb); }\n+EXPORT struct S_IID call_async_S_IID(struct S_IID (*cb)(void)) { return launch<struct S_IID>(cb); }\n+EXPORT struct S_IIP call_async_S_IIP(struct S_IIP (*cb)(void)) { return launch<struct S_IIP>(cb); }\n+EXPORT struct S_IFI call_async_S_IFI(struct S_IFI (*cb)(void)) { return launch<struct S_IFI>(cb); }\n+EXPORT struct S_IFF call_async_S_IFF(struct S_IFF (*cb)(void)) { return launch<struct S_IFF>(cb); }\n+EXPORT struct S_IFD call_async_S_IFD(struct S_IFD (*cb)(void)) { return launch<struct S_IFD>(cb); }\n+EXPORT struct S_IFP call_async_S_IFP(struct S_IFP (*cb)(void)) { return launch<struct S_IFP>(cb); }\n+EXPORT struct S_IDI call_async_S_IDI(struct S_IDI (*cb)(void)) { return launch<struct S_IDI>(cb); }\n+EXPORT struct S_IDF call_async_S_IDF(struct S_IDF (*cb)(void)) { return launch<struct S_IDF>(cb); }\n+EXPORT struct S_IDD call_async_S_IDD(struct S_IDD (*cb)(void)) { return launch<struct S_IDD>(cb); }\n+EXPORT struct S_IDP call_async_S_IDP(struct S_IDP (*cb)(void)) { return launch<struct S_IDP>(cb); }\n+EXPORT struct S_IPI call_async_S_IPI(struct S_IPI (*cb)(void)) { return launch<struct S_IPI>(cb); }\n+EXPORT struct S_IPF call_async_S_IPF(struct S_IPF (*cb)(void)) { return launch<struct S_IPF>(cb); }\n+EXPORT struct S_IPD call_async_S_IPD(struct S_IPD (*cb)(void)) { return launch<struct S_IPD>(cb); }\n+EXPORT struct S_IPP call_async_S_IPP(struct S_IPP (*cb)(void)) { return launch<struct S_IPP>(cb); }\n+EXPORT struct S_FII call_async_S_FII(struct S_FII (*cb)(void)) { return launch<struct S_FII>(cb); }\n+EXPORT struct S_FIF call_async_S_FIF(struct S_FIF (*cb)(void)) { return launch<struct S_FIF>(cb); }\n+EXPORT struct S_FID call_async_S_FID(struct S_FID (*cb)(void)) { return launch<struct S_FID>(cb); }\n+EXPORT struct S_FIP call_async_S_FIP(struct S_FIP (*cb)(void)) { return launch<struct S_FIP>(cb); }\n+EXPORT struct S_FFI call_async_S_FFI(struct S_FFI (*cb)(void)) { return launch<struct S_FFI>(cb); }\n+EXPORT struct S_FFF call_async_S_FFF(struct S_FFF (*cb)(void)) { return launch<struct S_FFF>(cb); }\n+EXPORT struct S_FFD call_async_S_FFD(struct S_FFD (*cb)(void)) { return launch<struct S_FFD>(cb); }\n+EXPORT struct S_FFP call_async_S_FFP(struct S_FFP (*cb)(void)) { return launch<struct S_FFP>(cb); }\n+EXPORT struct S_FDI call_async_S_FDI(struct S_FDI (*cb)(void)) { return launch<struct S_FDI>(cb); }\n+EXPORT struct S_FDF call_async_S_FDF(struct S_FDF (*cb)(void)) { return launch<struct S_FDF>(cb); }\n+EXPORT struct S_FDD call_async_S_FDD(struct S_FDD (*cb)(void)) { return launch<struct S_FDD>(cb); }\n+EXPORT struct S_FDP call_async_S_FDP(struct S_FDP (*cb)(void)) { return launch<struct S_FDP>(cb); }\n+EXPORT struct S_FPI call_async_S_FPI(struct S_FPI (*cb)(void)) { return launch<struct S_FPI>(cb); }\n+EXPORT struct S_FPF call_async_S_FPF(struct S_FPF (*cb)(void)) { return launch<struct S_FPF>(cb); }\n+EXPORT struct S_FPD call_async_S_FPD(struct S_FPD (*cb)(void)) { return launch<struct S_FPD>(cb); }\n+EXPORT struct S_FPP call_async_S_FPP(struct S_FPP (*cb)(void)) { return launch<struct S_FPP>(cb); }\n+EXPORT struct S_DII call_async_S_DII(struct S_DII (*cb)(void)) { return launch<struct S_DII>(cb); }\n+EXPORT struct S_DIF call_async_S_DIF(struct S_DIF (*cb)(void)) { return launch<struct S_DIF>(cb); }\n+EXPORT struct S_DID call_async_S_DID(struct S_DID (*cb)(void)) { return launch<struct S_DID>(cb); }\n+EXPORT struct S_DIP call_async_S_DIP(struct S_DIP (*cb)(void)) { return launch<struct S_DIP>(cb); }\n+EXPORT struct S_DFI call_async_S_DFI(struct S_DFI (*cb)(void)) { return launch<struct S_DFI>(cb); }\n+EXPORT struct S_DFF call_async_S_DFF(struct S_DFF (*cb)(void)) { return launch<struct S_DFF>(cb); }\n+EXPORT struct S_DFD call_async_S_DFD(struct S_DFD (*cb)(void)) { return launch<struct S_DFD>(cb); }\n+EXPORT struct S_DFP call_async_S_DFP(struct S_DFP (*cb)(void)) { return launch<struct S_DFP>(cb); }\n+EXPORT struct S_DDI call_async_S_DDI(struct S_DDI (*cb)(void)) { return launch<struct S_DDI>(cb); }\n+EXPORT struct S_DDF call_async_S_DDF(struct S_DDF (*cb)(void)) { return launch<struct S_DDF>(cb); }\n+EXPORT struct S_DDD call_async_S_DDD(struct S_DDD (*cb)(void)) { return launch<struct S_DDD>(cb); }\n+EXPORT struct S_DDP call_async_S_DDP(struct S_DDP (*cb)(void)) { return launch<struct S_DDP>(cb); }\n+EXPORT struct S_DPI call_async_S_DPI(struct S_DPI (*cb)(void)) { return launch<struct S_DPI>(cb); }\n+EXPORT struct S_DPF call_async_S_DPF(struct S_DPF (*cb)(void)) { return launch<struct S_DPF>(cb); }\n+EXPORT struct S_DPD call_async_S_DPD(struct S_DPD (*cb)(void)) { return launch<struct S_DPD>(cb); }\n+EXPORT struct S_DPP call_async_S_DPP(struct S_DPP (*cb)(void)) { return launch<struct S_DPP>(cb); }\n+EXPORT struct S_PII call_async_S_PII(struct S_PII (*cb)(void)) { return launch<struct S_PII>(cb); }\n+EXPORT struct S_PIF call_async_S_PIF(struct S_PIF (*cb)(void)) { return launch<struct S_PIF>(cb); }\n+EXPORT struct S_PID call_async_S_PID(struct S_PID (*cb)(void)) { return launch<struct S_PID>(cb); }\n+EXPORT struct S_PIP call_async_S_PIP(struct S_PIP (*cb)(void)) { return launch<struct S_PIP>(cb); }\n+EXPORT struct S_PFI call_async_S_PFI(struct S_PFI (*cb)(void)) { return launch<struct S_PFI>(cb); }\n+EXPORT struct S_PFF call_async_S_PFF(struct S_PFF (*cb)(void)) { return launch<struct S_PFF>(cb); }\n+EXPORT struct S_PFD call_async_S_PFD(struct S_PFD (*cb)(void)) { return launch<struct S_PFD>(cb); }\n+EXPORT struct S_PFP call_async_S_PFP(struct S_PFP (*cb)(void)) { return launch<struct S_PFP>(cb); }\n+EXPORT struct S_PDI call_async_S_PDI(struct S_PDI (*cb)(void)) { return launch<struct S_PDI>(cb); }\n+EXPORT struct S_PDF call_async_S_PDF(struct S_PDF (*cb)(void)) { return launch<struct S_PDF>(cb); }\n+EXPORT struct S_PDD call_async_S_PDD(struct S_PDD (*cb)(void)) { return launch<struct S_PDD>(cb); }\n+EXPORT struct S_PDP call_async_S_PDP(struct S_PDP (*cb)(void)) { return launch<struct S_PDP>(cb); }\n+EXPORT struct S_PPI call_async_S_PPI(struct S_PPI (*cb)(void)) { return launch<struct S_PPI>(cb); }\n+EXPORT struct S_PPF call_async_S_PPF(struct S_PPF (*cb)(void)) { return launch<struct S_PPF>(cb); }\n+EXPORT struct S_PPD call_async_S_PPD(struct S_PPD (*cb)(void)) { return launch<struct S_PPD>(cb); }\n+EXPORT struct S_PPP call_async_S_PPP(struct S_PPP (*cb)(void)) { return launch<struct S_PPP>(cb); }\n+}\n","filename":"test\/jdk\/java\/foreign\/libAsyncInvokers.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -25,0 +25,2 @@\n+#include <stdbool.h>\n+\n@@ -34,0 +36,4 @@\n+EXPORT bool identity_bool(bool x) {\n+    return x;\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/libIntrinsics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+\n+EXPORT void addr_func_6(struct Point* p1, struct Point* p2, struct Point* p3, struct Point* p4, struct Point* p5, struct Point* p6) { }\n+\n+EXPORT void addr_func_cb(void* p, void (*callback)()) {\n+   callback();\n+}\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @compile --add-modules jdk.incubator.foreign lookup\/Lookup.java\n+ * @compile --add-modules jdk.incubator.foreign invoker\/Invoker.java\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED TestLoaderLookup\n+ *\/\n+\n+import java.lang.reflect.*;\n+import jdk.incubator.foreign.*;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+\n+public class TestLoaderLookup {\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        ClassLoader loader1 = newClassLoader(\"lookup\");\n+        Class<?> lookup = loader1.loadClass(\"lookup.Lookup\");\n+        Method fooSymbol = lookup.getDeclaredMethod(\"fooSymbol\");\n+        NativeSymbol foo = (NativeSymbol)fooSymbol.invoke(null);\n+\n+        ClassLoader loader2 = newClassLoader(\"invoker\");\n+        Class<?> invoker = loader2.loadClass(\"invoker.Invoker\");\n+        Method invoke = invoker.getDeclaredMethod(\"invoke\", NativeSymbol.class);\n+        invoke.invoke(null, foo);\n+\n+        loader1 = null;\n+        lookup = null;\n+        fooSymbol = null;\n+        \/\/ Make sure that the loader is kept reachable\n+        for (int i = 0 ; i < 1000 ; i++) {\n+            invoke.invoke(null, foo); \/\/ might crash if loader1 is GC'ed\n+            System.gc();\n+        }\n+    }\n+\n+    public static ClassLoader newClassLoader(String path) {\n+        try {\n+            return new URLClassLoader(new URL[] {\n+                    Paths.get(System.getProperty(\"test.classes\", path)).toUri().toURL(),\n+            }, null);\n+        } catch (MalformedURLException e){\n+            throw new RuntimeException(\"Unexpected URL conversion failure\", e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package invoker;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class Invoker {\n+    public static void invoke(NativeSymbol symbol) throws Throwable {\n+        var linker = CLinker.systemCLinker();\n+        var handle = linker.downcallHandle(symbol, FunctionDescriptor.ofVoid());\n+        handle.invokeExact();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lookup;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class Lookup {\n+    static {\n+        System.loadLibrary(\"Foo\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    public static NativeSymbol fooSymbol() {\n+        return lookup.lookup(\"foo\").get();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void foo(void) {\n+    \/\/ do nothing\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/libFoo.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library ..\/\n@@ -32,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -40,1 +40,0 @@\n-import java.lang.invoke.MethodType;\n@@ -42,1 +41,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -45,1 +44,1 @@\n-public class TestMixedMallocFree {\n+public class TestMixedMallocFree extends NativeTestHelper {\n@@ -53,1 +52,1 @@\n-        MH_my_malloc = CLinker.getInstance().downcallHandle(\n+        MH_my_malloc = CLinker.systemCLinker().downcallHandle(\n@@ -55,2 +54,1 @@\n-            MethodType.methodType(MemoryAddress.class, long.class),\n-            FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n@@ -62,3 +60,3 @@\n-        MemorySegment seg = ma.asSegment(4L, ResourceScope.newImplicitScope());\n-        MemoryAccess.setInt(seg, 42);\n-        assertEquals(MemoryAccess.getInt(seg), 42);\n+        MemorySegment seg = MemorySegment.ofAddress(ma, 4L, ResourceScope.newImplicitScope());\n+        seg.set(JAVA_INT, 0, 42);\n+        assertEquals(seg.get(JAVA_INT, 0), 42);\n@@ -67,1 +65,1 @@\n-        CLinker.freeMemory(ma);\n+        freeMemory(ma);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -55,0 +56,1 @@\n+ * @library ..\/\n@@ -83,0 +85,1 @@\n+ * @library ..\/\n@@ -109,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -119,1 +123,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -122,1 +125,1 @@\n-public class TestAsyncStackWalk {\n+public class TestAsyncStackWalk extends NativeTestHelper {\n@@ -125,1 +128,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -136,1 +139,0 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n@@ -149,1 +151,1 @@\n-            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -159,1 +161,1 @@\n-        MH_asyncStackWalk.invokeExact(cb);\n+        MH_asyncStackWalk.invoke(cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -55,0 +56,1 @@\n+ * @library ..\/\n@@ -83,0 +85,1 @@\n+ * @library ..\/\n@@ -109,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -120,1 +124,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -122,1 +125,1 @@\n-public class TestStackWalk {\n+public class TestStackWalk extends NativeTestHelper {\n@@ -125,1 +128,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -136,1 +139,0 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n@@ -148,1 +150,1 @@\n-            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -161,1 +163,1 @@\n-        MH_foo.invokeExact(cb);\n+        MH_foo.invoke(cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.incubator.foreign.VaList;\n@@ -58,7 +58,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_FLOAT;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n@@ -66,1 +59,3 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -72,1 +67,1 @@\n-    private static final CLinker abi = CLinker.getInstance();\n+    private static final CLinker abi = CLinker.systemCLinker();\n@@ -79,27 +74,39 @@\n-    private static final MethodHandle MH_sumInts = link(\"sumInts\",\n-            MethodType.methodType(int.class, int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumDoubles = link(\"sumDoubles\",\n-            MethodType.methodType(double.class, int.class, VaList.class),\n-            FunctionDescriptor.of(C_DOUBLE, C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_getInt = link(\"getInt\",\n-            MethodType.methodType(int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumStruct = link(\"sumStruct\",\n-            MethodType.methodType(int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumBigStruct = link(\"sumBigStruct\",\n-            MethodType.methodType(long.class, VaList.class),\n-            FunctionDescriptor.of(C_LONG_LONG, C_VA_LIST));\n-    private static final MethodHandle MH_sumHugeStruct = link(\"sumHugeStruct\",\n-            MethodType.methodType(long.class, VaList.class),\n-            FunctionDescriptor.of(C_LONG_LONG, C_VA_LIST));\n-    private static final MethodHandle MH_sumFloatStruct = link(\"sumFloatStruct\",\n-            MethodType.methodType(float.class, VaList.class),\n-            FunctionDescriptor.of(C_FLOAT, C_VA_LIST));\n-    private static final MethodHandle MH_sumStack = link(\"sumStack\",\n-            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),\n-            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));\n-\n-    private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {\n-        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), mt, fd);\n+    private static final MethodHandle ADDRESS_TO_VALIST;\n+\n+    static {\n+        try {\n+            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class));\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+\n+    private static final MethodHandle MH_sumInts = linkVaList(\"sumInts\",\n+            FunctionDescriptor.of(C_INT, C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumDoubles = linkVaList(\"sumDoubles\",\n+            FunctionDescriptor.of(C_DOUBLE, C_INT, C_POINTER));\n+    private static final MethodHandle MH_getInt = linkVaList(\"getInt\",\n+            FunctionDescriptor.of(C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumStruct = linkVaList(\"sumStruct\",\n+            FunctionDescriptor.of(C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumBigStruct = linkVaList(\"sumBigStruct\",\n+            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+    private static final MethodHandle MH_sumHugeStruct = linkVaList(\"sumHugeStruct\",\n+            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+    private static final MethodHandle MH_sumFloatStruct = linkVaList(\"sumFloatStruct\",\n+            FunctionDescriptor.of(C_FLOAT, C_POINTER));\n+    private static final MethodHandle MH_sumStack = linkVaList(\"sumStack\",\n+            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER));\n+\n+    private static MethodHandle link(String symbol, FunctionDescriptor fd) {\n+        return linkInternal(symbol, fd);\n+    }\n+\n+    private static MethodHandle linkVaList(String symbol, FunctionDescriptor fd) {\n+        return linkInternal(symbol, fd);\n+    }\n+\n+\n+    private static MethodHandle linkInternal(String symbol, FunctionDescriptor fd) {\n+        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), fd);\n@@ -110,1 +117,0 @@\n-                MethodType.methodType(void.class, MemoryAddress.class),\n@@ -126,10 +132,10 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> winVaListScopedFactory\n-            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> sysvVaListScopedFactory\n-            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> linuxAArch64VaListScopedFactory\n-            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> macAArch64VaListScopedFactory\n-            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> platformVaListScopedFactory\n-            = (builder, scope) -> VaList.make(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> winVaListScopedFactory\n+            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> sysvVaListScopedFactory\n+            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> linuxAArch64VaListScopedFactory\n+            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> macAArch64VaListScopedFactory\n+            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> platformVaListScopedFactory\n+            = (builder, scope) -> VaList.make(builder, scope);\n@@ -140,2 +146,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();\n+        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n+                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -156,1 +162,1 @@\n-                           ValueLayout intLayout) {\n+                           ValueLayout.OfInt intLayout) {\n@@ -158,3 +164,3 @@\n-            b.vargFromInt(intLayout, 10)\n-                    .vargFromInt(intLayout, 15)\n-                    .vargFromInt(intLayout, 20));\n+            b.addVarg(intLayout, 10)\n+                    .addVarg(intLayout, 15)\n+                    .addVarg(intLayout, 20));\n@@ -169,2 +175,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n-                (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();\n+        Function<ValueLayout.OfDouble, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n+                (num, list) -> DoubleStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -185,1 +191,1 @@\n-                              ValueLayout doubleLayout) {\n+                              ValueLayout.OfDouble doubleLayout) {\n@@ -187,3 +193,3 @@\n-            b.vargFromDouble(doubleLayout, 3.0D)\n-                    .vargFromDouble(doubleLayout, 4.0D)\n-                    .vargFromDouble(doubleLayout, 5.0D));\n+            b.addVarg(doubleLayout, 3.0D)\n+                    .addVarg(doubleLayout, 4.0D)\n+                    .addVarg(doubleLayout, 5.0D));\n@@ -198,1 +204,1 @@\n-        Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->\n+        Function<ValueLayout.OfAddress, Function<VaList, Integer>> getIntJavaFact = layout ->\n@@ -200,2 +206,2 @@\n-                    MemoryAddress ma = list.vargAsAddress(layout);\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n+                    MemoryAddress ma = list.nextVarg(layout);\n+                    return ma.get(JAVA_INT, 0);\n@@ -216,1 +222,1 @@\n-                                        ValueLayout pointerLayout) {\n+                                        ValueLayout.OfAddress pointerLayout) {\n@@ -219,2 +225,2 @@\n-            MemoryAccess.setInt(msInt, 10);\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()));\n+            msInt.set(JAVA_INT, 0, 10);\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt.address()));\n@@ -234,1 +240,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n@@ -237,1 +243,2 @@\n-                    MemorySegment struct = list.vargAsSegment(pointLayout, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, ResourceScope.newImplicitScope());\n+                    list.nextVarg(pointLayout, SegmentAllocator.prefixAllocator(struct));\n@@ -243,1 +250,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n@@ -248,1 +255,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n@@ -254,2 +261,2 @@\n-            VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(\"x\"));\n-            VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(\"y\"));\n+            VarHandle VH_Point_x = pointLayout.varHandle(groupElement(\"x\"));\n+            VarHandle VH_Point_y = pointLayout.varHandle(groupElement(\"y\"));\n@@ -277,1 +284,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, struct));\n@@ -287,1 +294,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n@@ -290,1 +297,2 @@\n-                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -296,1 +304,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n@@ -301,1 +309,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n@@ -307,2 +315,2 @@\n-            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n+            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -330,1 +338,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(BigPoint_LAYOUT, struct));\n@@ -340,1 +348,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n@@ -343,1 +351,2 @@\n-                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -349,1 +358,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n@@ -354,1 +363,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n@@ -360,2 +369,2 @@\n-            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"x\"));\n-            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"y\"));\n+            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -384,1 +393,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(FloatPoint_LAYOUT, struct));\n@@ -398,1 +407,1 @@\n-        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n+        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n@@ -401,1 +410,2 @@\n-                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -408,1 +418,1 @@\n-        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n+        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n@@ -413,1 +423,1 @@\n-                QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n+                QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n@@ -420,3 +430,3 @@\n-            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n-            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"z\"));\n+            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n+            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n@@ -449,1 +459,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(HugePoint_LAYOUT, struct));\n@@ -462,1 +472,1 @@\n-        BiFunction<MemoryLayout, MemoryLayout, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n+        BiFunction<ValueLayout.OfLong, ValueLayout.OfDouble, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n@@ -466,1 +476,1 @@\n-                        lSum += list.vargAsLong(longLayout);\n+                        lSum += list.nextVarg(longLayout);\n@@ -468,1 +478,1 @@\n-                    MemoryAccess.setLong(longSum, lSum);\n+                    longSum.set(JAVA_LONG, 0, lSum);\n@@ -471,1 +481,1 @@\n-                        dSum += list.vargAsDouble(doubleLayout);\n+                        dSum += list.nextVarg(doubleLayout);\n@@ -473,1 +483,1 @@\n-                    MemoryAccess.setDouble(doubleSum, dSum);\n+                    doubleSum.set(JAVA_DOUBLE, 0, dSum);\n@@ -477,1 +487,1 @@\n-                MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);\n+                MH_sumStack.invoke(longSum, doubleSum, list);\n@@ -494,2 +504,2 @@\n-                          ValueLayout longLayout,\n-                          ValueLayout doubleLayout) {\n+                          ValueLayout.OfLong longLayout,\n+                          ValueLayout.OfDouble doubleLayout) {\n@@ -499,2 +509,2 @@\n-            MemoryAccess.setLong(longSum, 0L);\n-            MemoryAccess.setDouble(doubleSum, 0D);\n+            longSum.set(JAVA_LONG, 0, 0L);\n+            doubleSum.set(JAVA_DOUBLE, 0, 0D);\n@@ -504,1 +514,1 @@\n-                    b.vargFromLong(longLayout, l);\n+                    b.addVarg(longLayout, l);\n@@ -507,1 +517,1 @@\n-                    b.vargFromDouble(doubleLayout, d);\n+                    b.addVarg(doubleLayout, d);\n@@ -517,2 +527,2 @@\n-            long lSum = MemoryAccess.getLong(longSum);\n-            double dSum = MemoryAccess.getDouble(doubleSum);\n+            long lSum = longSum.get(JAVA_LONG, 0);\n+            double dSum = doubleSum.get(JAVA_DOUBLE, 0);\n@@ -527,1 +537,1 @@\n-        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_POINTER);\n@@ -529,2 +539,2 @@\n-            MemoryAddress stub = abi.upcallStub(callback, desc, scope);\n-            target.invokeExact(stub.address());\n+            NativeSymbol stub = abi.upcallStub(callback, desc, scope);\n+            target.invoke(stub);\n@@ -558,2 +568,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();\n+        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n+                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -572,1 +582,1 @@\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> vaListFactory,\n+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> vaListFactory,\n@@ -574,1 +584,1 @@\n-                                 ValueLayout intLayout) {\n+                                 ValueLayout.OfInt intLayout) {\n@@ -576,4 +586,3 @@\n-        try (NativeScope scope = new NativeScope()) {\n-            VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                            .vargFromInt(intLayout, 8),\n-                    scope);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                            .addVarg(intLayout, 8), scope);\n@@ -592,1 +601,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -597,2 +606,3 @@\n-                VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn));\n-                pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n+                VaList list = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, pointIn));\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, scope);\n+                list.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(pointOut));\n@@ -620,3 +630,3 @@\n-    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n+    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                .addVarg(intLayout, 8));\n@@ -624,2 +634,2 @@\n-        assertEquals(copy.vargAsInt(intLayout), 4);\n-        assertEquals(copy.vargAsInt(intLayout), 8);\n+        assertEquals(copy.nextVarg(intLayout), 4);\n+        assertEquals(copy.nextVarg(intLayout), 8);\n@@ -634,2 +644,2 @@\n-        assertEquals(list.vargAsInt(intLayout), 4);\n-        assertEquals(list.vargAsInt(intLayout), 8);\n+        assertEquals(list.nextVarg(intLayout), 4);\n+        assertEquals(list.nextVarg(intLayout), 8);\n@@ -642,3 +652,3 @@\n-                                                    ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n+                                                    ValueLayout.OfInt intLayout) {\n+        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                .addVarg(intLayout, 8));\n@@ -648,1 +658,1 @@\n-        copy.vargAsInt(intLayout); \/\/ should throw\n+        copy.nextVarg(intLayout); \/\/ should throw\n@@ -657,2 +667,2 @@\n-        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n+        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -663,2 +673,2 @@\n-        VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(\"x\"));\n-        VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(\"y\"));\n+        VarHandle VH_Point_x = Point_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_Point_y = Point_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -669,2 +679,2 @@\n-        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"x\"));\n-        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"y\"));\n+        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -676,3 +686,3 @@\n-        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n-        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"z\"));\n+        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n+        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n@@ -682,1 +692,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -688,1 +699,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -696,1 +708,1 @@\n-                    struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    copy.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -701,1 +713,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -705,1 +718,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n@@ -709,1 +722,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n@@ -712,1 +725,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -717,1 +731,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -723,1 +738,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -728,3 +744,3 @@\n-                    MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);\n-                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize(), ResourceScope.globalScope());\n-                    int x = MemoryAccess.getInt(ms);\n+                    MemoryAddress intPtr = vaList.nextVarg(C_POINTER);\n+                    MemorySegment ms = MemorySegment.ofAddress(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n+                    int x = ms.get(JAVA_INT, 0);\n@@ -734,3 +750,3 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 3.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 4.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 5.0);\n@@ -739,3 +755,3 @@\n-                    assertEquals(vaList.vargAsInt(C_INT), 10);\n-                    assertEquals(vaList.vargAsInt(C_INT), 15);\n-                    assertEquals(vaList.vargAsInt(C_INT), 20);\n+                    assertEquals(vaList.nextVarg(C_INT), 10);\n+                    assertEquals(vaList.nextVarg(C_INT), 15);\n+                    assertEquals(vaList.nextVarg(C_INT), 20);\n@@ -746,1 +762,1 @@\n-                        assertEquals(vaList.vargAsLong(C_LONG_LONG), l);\n+                        assertEquals(vaList.nextVarg(C_LONG_LONG), l);\n@@ -749,1 +765,1 @@\n-                        assertEquals(vaList.vargAsDouble(C_DOUBLE), d);\n+                        assertEquals(vaList.nextVarg(C_DOUBLE), d);\n@@ -753,16 +769,19 @@\n-                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);\n-                    assertEquals((char) vaList.vargAsInt(C_INT), 'a');\n-                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);\n-                    assertEquals(vaList.vargAsInt(C_INT), 4);\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 5L);\n-                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);\n-                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);\n-                    assertEquals((char) vaList.vargAsInt(C_INT), 'b');\n-                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);\n-                    assertEquals(vaList.vargAsInt(C_INT), 11);\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 12L);\n-                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);\n-\n-                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 1);\n+                    assertEquals((char) vaList.nextVarg(C_INT), 'a');\n+                    assertEquals((short) vaList.nextVarg(C_INT), (short) 3);\n+                    assertEquals(vaList.nextVarg(C_INT), 4);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n+                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 6.0F);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 7.0D);\n+                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 8);\n+                    assertEquals((char) vaList.nextVarg(C_INT), 'b');\n+                    assertEquals((short) vaList.nextVarg(C_INT), (short) 10);\n+                    assertEquals(vaList.nextVarg(C_INT), 11);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 12L);\n+                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 13.0F);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 14.0D);\n+\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    SegmentAllocator bufferAllocator = SegmentAllocator.prefixAllocator(buffer);\n+\n+                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, bufferAllocator);\n@@ -773,1 +792,1 @@\n-                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n@@ -781,1 +800,1 @@\n-                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n@@ -788,1 +807,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 5L);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n@@ -790,1 +809,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 10L);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 10L);\n@@ -792,1 +811,1 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 1.0D);\n@@ -794,1 +813,1 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 6.0D);\n@@ -804,1 +823,1 @@\n-                return MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n+                MethodHandle handle = MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n@@ -806,0 +825,2 @@\n+                return MethodHandles.filterArguments(handle, 0,\n+                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, ResourceScope.newConfinedScope()));\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":207,"deletions":186,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library ..\/\n@@ -37,1 +38,0 @@\n-import java.lang.invoke.MethodType;\n@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -43,1 +44,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -46,1 +46,1 @@\n-public class TestVirtualCalls {\n+public class TestVirtualCalls extends NativeTestHelper {\n@@ -48,1 +48,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -51,3 +51,3 @@\n-    static final MemoryAddress funcA;\n-    static final MemoryAddress funcB;\n-    static final MemoryAddress funcC;\n+    static final NativeSymbol funcA;\n+    static final NativeSymbol funcB;\n+    static final NativeSymbol funcC;\n@@ -57,2 +57,1 @@\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+                FunctionDescriptor.of(C_INT));\n@@ -69,3 +68,3 @@\n-        assertEquals((int) func.invokeExact((Addressable) funcA), 1);\n-        assertEquals((int) func.invokeExact((Addressable) funcB), 2);\n-        assertEquals((int) func.invokeExact((Addressable) funcC), 3);\n+        assertEquals((int) func.invokeExact(funcA), 1);\n+        assertEquals((int) func.invokeExact(funcB), 2);\n+        assertEquals((int) func.invokeExact(funcC), 3);\n@@ -76,1 +75,1 @@\n-        int x = (int) func.invokeExact((Addressable) null);\n+        int x = (int) func.invokeExact((NativeSymbol) null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8273660\n+ * @summary Verify that ObjectInputStream ReadFields correctly reports ClassNotFoundException\n+ *    while getting the field value. The test uses Vector that calls ReadFields from its readObject.\n+ * @library \/test\/lib\n+ * @run testng ReadFieldsCNF\n+ * @run testng\/othervm -Djdk.serialGetFieldCnfeReturnsNull=true ReadFieldsCNF\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.StreamCorruptedException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Vector;\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+public class ReadFieldsCNF {\n+\n+    private static final boolean GETFIELD_CNFE_RETURNS_NULL =\n+            Boolean.getBoolean(\"jdk.serialGetFieldCnfeReturnsNull\");\n+\n+\n+    \/**\n+     * Test a Vector holding a reference to a class instance that will not be found.\n+     * @throws IOException If any other exception occurs\n+     *\/\n+    @Test\n+    private static void testVectorWithRole() throws IOException {\n+        System.out.println(\"Property GETFIELD_CNFE_RETURNS_NULL: \" + GETFIELD_CNFE_RETURNS_NULL);\n+\n+        Role role = new Role();\n+        Vector<Role> vector = new Vector<>();\n+        vector.add(role);\n+\n+        \/\/ Modify the byte stream to change the classname to be deserialized to\n+        \/\/ XeadFieldsCNF$Role.\n+        byte[] bytes = writeObject(vector);\n+\n+        \/\/ Locate the name of the class to be deserialize\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);  \/\/ Map bytes to chars\n+        int off = s.indexOf(Role.class.getName());\n+        System.out.printf(\"Role offset: %d (0x%x) : %s%n\", off, off, Role.class.getName());\n+        if (off < 0) {\n+            HexPrinter.simple().formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+            Assert.fail(\"classname not found\");\n+        }\n+\n+        bytes[off] = (byte) 'X';  \/\/ replace R with X -> Class not found\n+\n+        \/\/ Deserialize the Vector expecting a ClassNotFoundException\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            Object obj = in.readObject();\n+            System.out.println(\"Read: \" + obj);\n+            Assert.fail(\"Should not reach here, an exception should always occur\");\n+        } catch (ClassNotFoundException cnfe) {\n+            \/\/ Expected ClassNotFoundException\n+            String expected = \"XeadFieldsCNF$Role\";\n+            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            if (GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected IOException got ClassNotFoundException\", cnfe);\n+            }\n+            System.out.println(\"Normal:  OIS.readObject: \" + cnfe);\n+        } catch (StreamCorruptedException ioe) {\n+            if (!GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+            }\n+            System.out.println(\"Normal: \" + ioe);\n+        }\n+        \/\/ Other exceptions cause the test to fail\n+    }\n+\n+    \/**\n+     * For an object holding a reference to a class that will not be found.\n+     * @throws IOException If any other exception occurs\n+     *\/\n+    @Test\n+    private static void testHolderWithRole() throws IOException {\n+        System.out.println(\"Property GETFIELD_CNFE_RETURNS_NULL: \" + GETFIELD_CNFE_RETURNS_NULL);\n+        Role role = new Role();\n+        Holder holder = new Holder(role);\n+\n+        \/\/ Modify the byte stream to change the classname to be deserialized to\n+        \/\/ XeadFieldsCNF$Role.\n+        byte[] bytes = writeObject(holder);\n+\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);  \/\/ Map bytes to chars\n+        int off = s.indexOf(Role.class.getName(), 0);\n+        off = s.indexOf(Role.class.getName(), off + 1); \/\/ 2nd occurrence of classname\n+        System.out.printf(\"Role offset: %d (0x%x)%n\", off, off);\n+        if (off < 0) {\n+            HexPrinter.simple().formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+            Assert.fail(\"classname found at index: \" + off + \" (0x\" + Integer.toHexString(off) + \")\");\n+        }\n+\n+        bytes[off] = (byte) 'X';  \/\/ replace R with X -> Class not found\n+\n+        \/\/ Deserialize the Vector expecting a ClassNotFoundException\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            Holder obj = (Holder)in.readObject();\n+            System.out.println(\"Read: \" + obj);\n+            Assert.fail(\"Should not reach here, an exception should always occur\");\n+        } catch (ClassNotFoundException cnfe) {\n+            \/\/ Expected ClassNotFoundException\n+            String expected = \"XeadFieldsCNF$Role\";\n+            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            System.out.println(\"Normal: OIS.readObject: \" + cnfe);\n+        } catch (StreamCorruptedException ioe) {\n+            if (!GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+            }\n+            System.out.println(\"Normal: \" + ioe);\n+        }\n+        \/\/ Other exceptions cause the test to fail\n+    }\n+\n+    private static byte[] writeObject(Object o) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream os = new ObjectOutputStream(baos)) {\n+            os.writeObject(o);\n+        }\n+        return baos.toByteArray();\n+    }\n+\n+    static class Role implements Serializable {\n+        private static final long serialVersionUID = 0L;\n+\n+        Role() {}\n+    }\n+\n+    static class Holder implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+\n+        Role role;\n+\n+        Holder(Role role) {\n+            this.role = role;\n+        }\n+\n+        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+            ObjectInputStream.GetField fields = ois.readFields();\n+            try {\n+                Object repl = new Object();\n+                role = (Role)fields.get(\"role\", repl);\n+                System.out.println(\"Holder.readObject Role: \" + role);\n+            } catch (Exception ex) {\n+                \/\/ Catch CNFE and ignore it; check elsewhere that CNFE is thrown from OIS.readObject\n+                System.out.println(\"Normal: exception in Holder.readObject, ignoring: \" + ex);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"role: \" + role;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/GetField\/ReadFieldsCNF.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -173,1 +174,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8277451\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=true NegativeTest\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=false NegativeTest\n+ * @summary Test exception thrown due to bad receiver and bad value on\n+ *          Field with and without setAccessible(true)\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class NegativeTest {\n+    static class Fields {\n+        public static int si;\n+        public static char sc;\n+        public static byte sb;\n+        public static short ss;\n+        public static long sl;\n+        public static double sd;\n+        public static float sf;\n+        public static boolean sz;\n+        public static String so;\n+\n+        public static final int sfi = 10;\n+        public static final char sfc = 'a';\n+        public static final byte sfb = 1;\n+        public static final short sfs = 2;\n+        public static final long sfl = 1000L;\n+        public static final double sfd = 1.0;\n+        public static final float sff = 2.0f;\n+        public static final boolean sfz = true;\n+        public static final String sfo = \"abc\";\n+\n+        public int i;\n+        public char c;\n+        public byte b;\n+        public short s;\n+        public long l;\n+        public double d;\n+        public float f;\n+        public boolean z;\n+        public String o;\n+\n+        public final int fi = 10;\n+        public final char fc = 'a';\n+        public final byte fb = 1;\n+        public final short fs = 2;\n+        public final long fl = 1000L;\n+        public final double fd = 1.0;\n+        public final float ff = 2.0f;\n+        public final boolean fz = true;\n+        public final String fo = \"abc\";\n+    }\n+\n+    static final Field i_field = field(\"i\", false);\n+    static final Field c_field = field(\"c\", false);\n+    static final Field b_field = field(\"b\", false);\n+    static final Field s_field = field(\"s\", false);\n+    static final Field l_field = field(\"l\", false);\n+    static final Field d_field = field(\"d\", false);\n+    static final Field f_field = field(\"f\", false);\n+    static final Field z_field = field(\"z\", false);\n+    static final Field o_field = field(\"o\", false);\n+    static final Field fi_field = field(\"fi\", false);\n+    static final Field fc_field = field(\"fc\", false);\n+    static final Field fb_field = field(\"fb\", false);\n+    static final Field fs_field = field(\"fs\", false);\n+    static final Field fl_field = field(\"fl\", false);\n+    static final Field fd_field = field(\"fd\", false);\n+    static final Field ff_field = field(\"ff\", false);\n+    static final Field fz_field = field(\"fz\", false);\n+    static final Field fo_field = field(\"fo\", false);\n+\n+    static final Field override_i_field = field(\"i\", true);\n+    static final Field override_c_field = field(\"c\", true);\n+    static final Field override_b_field = field(\"b\", true);\n+    static final Field override_s_field = field(\"s\", true);\n+    static final Field override_l_field = field(\"l\", true);\n+    static final Field override_d_field = field(\"d\", true);\n+    static final Field override_f_field = field(\"f\", true);\n+    static final Field override_z_field = field(\"z\", true);\n+    static final Field override_o_field = field(\"o\", true);\n+    static final Field override_fi_field = field(\"fi\", true);\n+    static final Field override_fc_field = field(\"fc\", true);\n+    static final Field override_fb_field = field(\"fb\", true);\n+    static final Field override_fs_field = field(\"fs\", true);\n+    static final Field override_fl_field = field(\"fl\", true);\n+    static final Field override_fd_field = field(\"fd\", true);\n+    static final Field override_ff_field = field(\"ff\", true);\n+    static final Field override_fz_field = field(\"fz\", true);\n+    static final Field override_fo_field = field(\"fo\", true);\n+\n+    static final Field si_field = field(\"si\", false);\n+    static final Field sc_field = field(\"sc\", false);\n+    static final Field sb_field = field(\"sb\", false);\n+    static final Field ss_field = field(\"ss\", false);\n+    static final Field sl_field = field(\"sl\", false);\n+    static final Field sd_field = field(\"sd\", false);\n+    static final Field sf_field = field(\"sf\", false);\n+    static final Field sz_field = field(\"sz\", false);\n+    static final Field so_field = field(\"so\", false);\n+    static final Field sfi_field = field(\"sfi\", false);\n+    static final Field sfc_field = field(\"sfc\", false);\n+    static final Field sfb_field = field(\"sfb\", false);\n+    static final Field sfs_field = field(\"sfs\", false);\n+    static final Field sfl_field = field(\"sfl\", false);\n+    static final Field sfd_field = field(\"sfd\", false);\n+    static final Field sff_field = field(\"sff\", false);\n+    static final Field sfz_field = field(\"sfz\", false);\n+    static final Field sfo_field = field(\"sfo\", false);\n+\n+    static final Field override_si_field = field(\"si\", true);\n+    static final Field override_sc_field = field(\"sc\", true);\n+    static final Field override_sb_field = field(\"sb\", true);\n+    static final Field override_ss_field = field(\"ss\", true);\n+    static final Field override_sl_field = field(\"sl\", true);\n+    static final Field override_sd_field = field(\"sd\", true);\n+    static final Field override_sf_field = field(\"sf\", true);\n+    static final Field override_sz_field = field(\"sz\", true);\n+    static final Field override_so_field = field(\"so\", true);\n+    static final Field override_sfi_field = field(\"sfi\", true);\n+    static final Field override_sfc_field = field(\"sfc\", true);\n+    static final Field override_sfb_field = field(\"sfb\", true);\n+    static final Field override_sfs_field = field(\"sfs\", true);\n+    static final Field override_sfl_field = field(\"sfl\", true);\n+    static final Field override_sfd_field = field(\"sfd\", true);\n+    static final Field override_sff_field = field(\"sff\", true);\n+    static final Field override_sfz_field = field(\"sfz\", true);\n+    static final Field override_sfo_field = field(\"sfo\", true);\n+\n+    private static Field field(String name, boolean suppressAccessCheck) {\n+        try {\n+            Field f = Fields.class.getDeclaredField(name);\n+            if (suppressAccessCheck) {\n+                f.setAccessible(true);\n+            }\n+            return f;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @DataProvider(name = \"instanceFields\")\n+    private Object[][] instanceFields() {\n+        return new Object[][]{\n+                new Object[]{i_field},\n+                new Object[]{c_field},\n+                new Object[]{b_field},\n+                new Object[]{s_field},\n+                new Object[]{l_field},\n+                new Object[]{d_field},\n+                new Object[]{f_field},\n+                new Object[]{z_field},\n+                new Object[]{o_field},\n+                new Object[]{override_i_field},\n+                new Object[]{override_c_field},\n+                new Object[]{override_b_field},\n+                new Object[]{override_s_field},\n+                new Object[]{override_l_field},\n+                new Object[]{override_d_field},\n+                new Object[]{override_f_field},\n+                new Object[]{override_z_field},\n+                new Object[]{override_o_field},\n+                \/\/ final instance fields\n+                new Object[]{fi_field},\n+                new Object[]{fc_field},\n+                new Object[]{fb_field},\n+                new Object[]{fs_field},\n+                new Object[]{fl_field},\n+                new Object[]{fd_field},\n+                new Object[]{ff_field},\n+                new Object[]{fz_field},\n+                new Object[]{fo_field},\n+                new Object[]{override_fi_field},\n+                new Object[]{override_fc_field},\n+                new Object[]{override_fb_field},\n+                new Object[]{override_fs_field},\n+                new Object[]{override_fl_field},\n+                new Object[]{override_fd_field},\n+                new Object[]{override_ff_field},\n+                new Object[]{override_fz_field},\n+                new Object[]{override_fo_field},\n+        };\n+    }\n+    private static Fields INSTANCE = new Fields();\n+\n+    \/*\n+     * Test Field::get on a good receiver, a bad receiver and null.\n+     *\n+     * IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     *\/\n+    @Test(dataProvider = \"instanceFields\")\n+    public void testReceiver(Field f) throws ReflectiveOperationException {\n+        f.get(INSTANCE);     \/\/ good receiver\n+\n+        testBadReceiver(f);\n+        testNullReceiver(f);\n+    }\n+\n+    \/*\n+     * IllegalArgumentException should be thrown for bad receiver type\n+     *\/\n+    private void testBadReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        Object badObj = new NegativeTest();\n+        try {\n+            f.get(badObj);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(badObj);\n+                    case \"C\" -> f.getChar(badObj);\n+                    case \"D\" -> f.getDouble(badObj);\n+                    case \"F\" -> f.getFloat(badObj);\n+                    case \"I\" -> f.getInt(badObj);\n+                    case \"J\" -> f.getLong(badObj);\n+                    case \"S\" -> f.getShort(badObj);\n+                    case \"Z\" -> f.getBoolean(badObj);\n+                }\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * NullPointerException should be thrown for null receiver\n+     *\/\n+    private void testNullReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        try {\n+            f.get(null);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(null);\n+                    case \"C\" -> f.getChar(null);\n+                    case \"D\" -> f.getDouble(null);\n+                    case \"F\" -> f.getFloat(null);\n+                    case \"I\" -> f.getInt(null);\n+                    case \"J\" -> f.getLong(null);\n+                    case \"S\" -> f.getShort(null);\n+                    case \"Z\" -> f.getBoolean(null);\n+                }\n+                fail(\"expected NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"writeableFields\")\n+    private Object[][] writeableFields() {\n+        Fields obj = new Fields();\n+        return new Object[][]{\n+                \/\/ instance fields with and without setAccessible(true)\n+                new Object[]{i_field, obj, Integer.valueOf(10)},\n+                new Object[]{c_field, obj, Character.valueOf('c')},\n+                new Object[]{b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{l_field, obj, Long.valueOf(1000)},\n+                new Object[]{d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{o_field, obj, \"good-value\"},\n+                new Object[]{override_i_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_c_field, obj, Character.valueOf('c')},\n+                new Object[]{override_b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_l_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_o_field, obj, \"good-value\"},\n+                \/\/ instance final fields with setAccessible(true)\n+                new Object[]{override_fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_fc_field, obj, Character.valueOf('c')},\n+                new Object[]{override_fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_fo_field, obj, \"good-value\"},\n+                \/\/ static fields with and without setAccessible(true)\n+                new Object[]{si_field, null, Integer.valueOf(10)},\n+                new Object[]{sc_field, null, Character.valueOf('c')},\n+                new Object[]{sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{sl_field, null, Long.valueOf(1000)},\n+                new Object[]{sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{so_field, null, \"good-value\"},\n+                new Object[]{override_si_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_so_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set with a good and bad value.\n+     * Test setting to null if the field type is primitive.\n+     *\n+     * IllegalArgumentException is thrown if the value is of a bad type or null.\n+     * NullPointerException is thrown if the receiver of an instance field is null.\n+     * The receiver is checked\n+     *\/\n+    @Test(dataProvider = \"writeableFields\")\n+    public void testSetValue(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            switch (fType.descriptorString()) {\n+                case \"B\" -> f.setByte(obj, ((Byte) value).byteValue());\n+                case \"C\" -> f.setChar(obj, ((Character) value).charValue());\n+                case \"D\" -> f.setDouble(obj, ((Double) value).doubleValue());\n+                case \"F\" -> f.setFloat(obj, ((Float) value).floatValue());\n+                case \"I\" -> f.setInt(obj, ((Integer) value).intValue());\n+                case \"J\" -> f.setLong(obj, ((Long) value).longValue());\n+                case \"S\" -> f.setShort(obj, ((Short) value).shortValue());\n+                case \"Z\" -> f.setBoolean(obj, ((Boolean) value).booleanValue());\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @DataProvider(name = \"readOnlyFinalFields\")\n+    private Object[][] readOnlyFinalFields() {\n+        Object obj = INSTANCE;\n+        return new Object[][]{\n+                \/\/ instance final fields\n+                new Object[]{fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{fc_field, obj, Character.valueOf('c')},\n+                new Object[]{fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{fo_field, obj, \"good-value\"},\n+                \/\/ static final fields\n+                new Object[]{sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{sfc_field, null, Character.valueOf('c')},\n+                new Object[]{sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{sfo_field, null, \"good-value\"},\n+                new Object[]{override_sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sfc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_sfo_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a read-only final field.\n+     * IllegalAccessException is thrown regardless of whether the value\n+     * is of a bad type or not.\n+     *\/\n+    @Test(dataProvider = \"readOnlyFinalFields\")\n+    public void testSetValueOnFinalField(Field f, Object obj, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        try {\n+            f.set(obj, value);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(obj, ((Byte)value).byteValue());\n+                    case \"C\" -> f.setChar(obj, ((Character)value).charValue());\n+                    case \"D\" -> f.setDouble(obj, ((Double)value).doubleValue());\n+                    case \"F\" -> f.setFloat(obj, ((Float)value).floatValue());\n+                    case \"I\" -> f.setInt(obj, ((Integer)value).intValue());\n+                    case \"J\" -> f.setLong(obj, ((Long)value).longValue());\n+                    case \"S\" -> f.setShort(obj, ((Short)value).shortValue());\n+                    case \"Z\" -> f.setBoolean(obj, ((Boolean)value).booleanValue());\n+                }\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+\n+\n+    @DataProvider(name = \"finalInstanceFields\")\n+    private Object[][] finalInstanceFields() {\n+        return new Object[][]{\n+                new Object[]{fi_field, Integer.valueOf(10)},\n+                new Object[]{fc_field, Character.valueOf('c')},\n+                new Object[]{fb_field, Byte.valueOf((byte) 1)},\n+                new Object[]{fs_field, Short.valueOf((short) 2)},\n+                new Object[]{fl_field, Long.valueOf(1000)},\n+                new Object[]{fd_field, Double.valueOf(1.2)},\n+                new Object[]{ff_field, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, Boolean.valueOf(true)},\n+                new Object[]{fo_field, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a final instance field with either a bad receiver\n+     * or null.  IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     * The receiver is checked before the access check is performed and\n+     * also before the value is checked.\n+     *\/\n+    @Test(dataProvider = \"finalInstanceFields\")\n+    public void testReceiverOnFinalField(Field f, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        Object badReceiver = new NegativeTest();\n+        \/\/ set the field with a bad receiver with a good value\n+        try {\n+            f.set(badReceiver, value);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a bad receiver with a bad value\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(badReceiver, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a null receiver with a good value\n+        try {\n+            f.set(null, value);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+        \/\/ set the field with a null receiver with a bad value\n+        try {\n+            f.set(null, badValue);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            \/\/ test bad receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(badReceiver, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(badReceiver, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(badReceiver, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(badReceiver, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(badReceiver, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(badReceiver, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(badReceiver, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(badReceiver, ((Boolean) value).booleanValue());\n+                }\n+            } catch (IllegalArgumentException e) {\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+            }\n+            \/\/ test null receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(null, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(null, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(null, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(null, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(null, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(null, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(null, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(null, ((Boolean) value).booleanValue());\n+                }\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/NegativeTest.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -118,0 +118,2 @@\n+        private static String name = \"name\";\n+        private byte b = 9;\n@@ -133,0 +135,5 @@\n+        public Public(byte b) {\n+            this.b = b;\n+            this.i = 0;\n+            this.s = null;\n+        }\n@@ -165,0 +172,1 @@\n+                   \", b=\" + b +\n@@ -388,2 +396,5 @@\n-    private static final Throwable[] cannot_get_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not get final\")\n+    private static final Throwable[] cannot_get_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not get\")\n+    };\n+    private static final Throwable[] cannot_set_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -391,2 +402,2 @@\n-    private static final Throwable[] cannot_set_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not set final\")\n+    private static final Throwable[] mismatched_field_type = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -595,0 +606,1 @@\n+        String wrongInst = new String();\n@@ -598,2 +610,0 @@\n-                new Object[]{\"s\", new Object(), \"test\",\n-                             newImpl ? cannot_get_final_field : cannot_set_final_field},\n@@ -601,0 +611,4 @@\n+                new Object[]{\"s\", wrongInst, \"test\",\n+                        newImpl ? cannot_get_field : cannot_set_field},\n+                new Object[]{\"b\", wrongInst, 0,\n+                        newImpl ? cannot_get_field : cannot_set_field},\n@@ -605,0 +619,2 @@\n+        Object o = new Object();\n+        byte b = 1;\n@@ -607,0 +623,1 @@\n+                new Object[]{\"i\", new Public(100), 100, Integer.valueOf(10), noException},\n@@ -608,3 +625,0 @@\n-                \/\/ ## no exception thrown\n-                \/\/ new Object[]{\"i\", new Public(100), 100, new Object(), cannot_set_final_field},\n-                new Object[]{\"s\", new Object(), \"test\", \"dummy\", cannot_set_final_field},\n@@ -612,0 +626,4 @@\n+                new Object[]{\"b\", new Public(b), b, null, mismatched_field_type},\n+                new Object[]{\"b\", new Public(b), b, Long.valueOf(10), mismatched_field_type},\n+                new Object[]{\"name\", null, \"name\", o, mismatched_field_type},\n+                new Object[]{\"i\", new Public(100), 100, o, mismatched_field_type},\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -39,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,1 +43,1 @@\n-        Function<MemorySegment, Byte> mapper = MemoryAccess::getByte;\n+        Function<MemorySegment, Byte> mapper = s -> s.get(ValueLayout.JAVA_BYTE, 0);\n@@ -55,1 +54,1 @@\n-        Function<MemorySegment, Character> mapper = MemoryAccess::getChar;\n+        Function<MemorySegment, Character> mapper = s -> s.get(ValueLayout.JAVA_CHAR, 0);\n@@ -66,1 +65,1 @@\n-        Function<MemorySegment, Short> mapper = MemoryAccess::getShort;\n+        Function<MemorySegment, Short> mapper = s -> s.get(ValueLayout.JAVA_SHORT, 0);\n@@ -77,1 +76,1 @@\n-        Function<MemorySegment, Integer> mapper = MemoryAccess::getInt;\n+        Function<MemorySegment, Integer> mapper = s -> s.get(ValueLayout.JAVA_INT, 0);\n@@ -88,1 +87,1 @@\n-        Function<MemorySegment, Long> mapper = MemoryAccess::getLong;\n+        Function<MemorySegment, Long> mapper = s-> s.get(ValueLayout.JAVA_LONG, 0);\n@@ -99,1 +98,1 @@\n-        Function<MemorySegment, Float> mapper = MemoryAccess::getFloat;\n+        Function<MemorySegment, Float> mapper = s -> s.get(ValueLayout.JAVA_FLOAT, 0);\n@@ -118,1 +117,1 @@\n-        Function<MemorySegment, Double> mapper = MemoryAccess::getDouble;\n+        Function<MemorySegment, Double> mapper = s -> s.get(ValueLayout.JAVA_DOUBLE, 0);\n@@ -130,1 +129,1 @@\n-            MemoryAccess.setByte(segment, (byte)i);\n+            segment.set(ValueLayout.JAVA_BYTE, 0, (byte)i);\n@@ -135,7 +134,7 @@\n-            { \"bytes\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n-            { \"chars\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n-            { \"shorts\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n-            { \"ints\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n-            { \"longs\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n-            { \"floats\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n-            { \"doubles\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n+            { \"bytes\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n+            { \"chars\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n+            { \"shorts\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n+            { \"ints\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n+            { \"longs\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n+            { \"floats\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n+            { \"doubles\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.function.Consumer;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * @test\n+ * @bug 8277087\n+ * @summary Verifies various use cases when the zip comment should be empty\n+ * @run testng EmptyComment\n+ *\/\n+public final class EmptyComment {\n+\n+    @DataProvider()\n+    Object[][] longLengths() {\n+        return new Object[][]{{0xFFFF + 1}, {0xFFFF + 2}, {0xFFFF * 2}};\n+    }\n+\n+    \/**\n+     * Overflow, the text is too long to be stored as a comment.\n+     *\/\n+    @Test(dataProvider = \"longLengths\")\n+    void testOverflow(int length) throws Exception {\n+        test(zos -> assertThrows(IllegalArgumentException.class, () -> {\n+            zos.setComment(\"X\".repeat(length));\n+        }));\n+    }\n+\n+    \/**\n+     * Simple cases where the comment is set to the empty text.\n+     *\/\n+    @Test\n+    void testSimpleCases() throws Exception {\n+        test(zos -> {\/* do nothing *\/});\n+        test(zos -> zos.setComment(null));\n+        test(zos -> zos.setComment(\"\"));\n+        test(zos -> {\n+            zos.setComment(\"\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(null);\n+            zos.setComment(\"\");\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(\"\");\n+        });\n+    }\n+\n+    private static void test(Consumer<ZipOutputStream> test) throws Exception {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            test.accept(zos);\n+\n+            zos.putNextEntry(new ZipEntry(\"x\"));\n+            zos.finish();\n+\n+            byte[] data = baos.toByteArray();\n+\n+            if (data.length > 0xFFFF) { \/\/ just in case\n+                throw new RuntimeException(\"data is too big: \" + data.length);\n+            }\n+            int pk = data.length - ZipFile.ENDHDR;\n+            if (data[pk] != 'P' || data[pk + 1] != 'K') {\n+                throw new RuntimeException(\"PK is not found\");\n+            }\n+            \/\/ Since the comment is empty this will be two last bytes\n+            int pos = data.length - ZipFile.ENDHDR + ZipFile.ENDCOM;\n+\n+            int len = (data[pos] & 0xFF) + ((data[pos + 1] & 0xFF) << 8);\n+            if (len != 0) {\n+                throw new RuntimeException(\"zip comment is not empty: \" + len);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/EmptyComment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276764\n+ * @summary test that the jar content ordering is sorted\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run testng ContentOrder\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipException;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+public class ContentOrder {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream out = new PrintStream(baos);\n+    private Runnable onCompletion;\n+\n+    @BeforeMethod\n+    public void reset() {\n+        onCompletion = null;\n+    }\n+\n+    @AfterMethod\n+    public void run() {\n+        if (onCompletion != null) {\n+            onCompletion.run();\n+        }\n+    }\n+\n+    \/\/ Test that the jar content ordering when processing a single directory is sorted\n+    @Test\n+    public void testSingleDir() throws IOException {\n+        mkdir(\"testjar\/Ctest1\", \"testjar\/Btest2\/subdir1\", \"testjar\/Atest3\");\n+        touch(\"testjar\/Ctest1\/testfile1\", \"testjar\/Ctest1\/testfile2\", \"testjar\/Ctest1\/testfile3\");\n+        touch(\"testjar\/Btest2\/subdir1\/testfileC\", \"testjar\/Btest2\/subdir1\/testfileB\", \"testjar\/Btest2\/subdir1\/testfileA\");\n+        touch(\"testjar\/Atest3\/fileZ\", \"testjar\/Atest3\/fileY\", \"testjar\/Atest3\/fileX\");\n+\n+        onCompletion = () -> rm(\"test.jar\", \"testjar\");\n+\n+        jar(\"cf test.jar testjar\");\n+        jar(\"tf test.jar\");\n+        System.out.println(new String(baos.toByteArray()));\n+        String output = \"META-INF\/\" + nl +\n+                \"META-INF\/MANIFEST.MF\" + nl +\n+                \"testjar\/\" + nl +\n+                \"testjar\/Atest3\/\" + nl +\n+                \"testjar\/Atest3\/fileX\" + nl +\n+                \"testjar\/Atest3\/fileY\" + nl +\n+                \"testjar\/Atest3\/fileZ\" + nl +\n+                \"testjar\/Btest2\/\" + nl +\n+                \"testjar\/Btest2\/subdir1\/\" + nl +\n+                \"testjar\/Btest2\/subdir1\/testfileA\" + nl +\n+                \"testjar\/Btest2\/subdir1\/testfileB\" + nl +\n+                \"testjar\/Btest2\/subdir1\/testfileC\" + nl +\n+                \"testjar\/Ctest1\/\" + nl +\n+                \"testjar\/Ctest1\/testfile1\" + nl +\n+                \"testjar\/Ctest1\/testfile2\" + nl +\n+                \"testjar\/Ctest1\/testfile3\" + nl;\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/\/ Test that when specifying multiple directories or releases that the sort\n+    \/\/ ordering is done on each directory and release, reserving the order of\n+    \/\/ the directories\/releases specified on the command line\n+    @Test\n+    public void testMultiDirWithReleases() throws IOException {\n+        mkdir(\"testjar\/foo\/classes\",\n+              \"testjar\/foo11\/classes\/Zclasses\",\n+              \"testjar\/foo11\/classes\/Yclasses\",\n+              \"testjar\/foo17\/classes\/Bclasses\",\n+              \"testjar\/foo17\/classes\/Aclasses\");\n+        touch(\"testjar\/foo\/classes\/testfile1\", \"testjar\/foo\/classes\/testfile2\");\n+        touch(\"testjar\/foo11\/classes\/Zclasses\/testfile1\", \"testjar\/foo11\/classes\/Zclasses\/testfile2\");\n+        touch(\"testjar\/foo11\/classes\/Yclasses\/testfileA\", \"testjar\/foo11\/classes\/Yclasses\/testfileB\");\n+        touch(\"testjar\/foo17\/classes\/Bclasses\/testfile1\", \"testjar\/foo17\/classes\/Bclasses\/testfile2\");\n+        touch(\"testjar\/foo17\/classes\/Aclasses\/testfileA\", \"testjar\/foo17\/classes\/Aclasses\/testfileB\");\n+\n+        onCompletion = () -> rm(\"test.jar\", \"testjar\");\n+\n+        jar(\"cf test.jar -C testjar\/foo classes \" +\n+            \"--release 17 -C testjar\/foo17 classes\/Bclasses -C testjar\/foo17 classes\/Aclasses \" +\n+            \"--release 11 -C testjar\/foo11 classes\/Zclasses -C testjar\/foo11 classes\/Yclasses\");\n+        jar(\"tf test.jar\");\n+        System.out.println(new String(baos.toByteArray()));\n+        String output = \"META-INF\/\" + nl +\n+                \"META-INF\/MANIFEST.MF\" + nl +\n+                \"classes\/\" + nl +\n+                \"classes\/testfile1\" + nl +\n+                \"classes\/testfile2\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Bclasses\/\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Bclasses\/testfile1\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Bclasses\/testfile2\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Aclasses\/\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Aclasses\/testfileA\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Aclasses\/testfileB\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Zclasses\/\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Zclasses\/testfile1\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Zclasses\/testfile2\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Yclasses\/\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Yclasses\/testfileA\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Yclasses\/testfileB\" + nl;\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void mkdir(String... dirs) {\n+        System.out.println(\"mkdir -p \" + Arrays.toString(dirs));\n+        Arrays.stream(dirs).forEach(p -> {\n+            try {\n+                Files.createDirectories((new File(p)).toPath());\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void touch(String... files) {\n+        System.out.println(\"touch \" + Arrays.toString(files));\n+        Arrays.stream(files).forEach(p -> {\n+            try {\n+                Files.createFile((new File(p)).toPath());\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void rm(String... files) {\n+        System.out.println(\"rm -rf \" + Arrays.toString(files));\n+        Arrays.stream(files).forEach(p -> {\n+            try {\n+                Path path = (new File(p)).toPath();\n+                if (Files.isDirectory(path)) {\n+                    FileUtils.deleteFileTreeWithRetry(path);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(path);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        int rc = JAR_TOOL.run(out, err, cmdline.split(\" +\"));\n+        System.setErr(saveErr);\n+        if (rc != 0) {\n+            String s = baes.toString();\n+            if (s.startsWith(\"java.util.zip.ZipException: duplicate entry: \")) {\n+                throw new ZipException(s);\n+            }\n+            throw new IOException(s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ContentOrder.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1096,3 +1096,0 @@\n-        if (!TOOL_VM_OPTIONS.isEmpty()) {\n-            commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(\"\\\\s+\", -1)));\n-        }\n","filename":"test\/jdk\/tools\/jar\/modularJar\/Basic.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.module.ModuleDescriptor;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+import java.util.spi.ToolProvider;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/**\n+ * @test\n+ * @bug 8258117\n+ * @summary Tests that the content generated for module-info.class, using the jar command, is reproducible\n+ * @run testng JarToolModuleDescriptorReproducibilityTest\n+ *\/\n+public class JarToolModuleDescriptorReproducibilityTest {\n+\n+    private static final String MODULE_NAME = \"foo\";\n+    private static final String MODULE_VERSION = \"1.2.3\";\n+    private static final String UPDATED_MODULE_VERSION = \"1.2.4\";\n+    private static final String MAIN_CLASS = \"jdk.test.foo.Foo\";\n+    private static final Path MODULE_CLASSES_DIR = Path.of(\"8258117-module-classes\", MODULE_NAME).toAbsolutePath();\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"jar tool not found\")\n+            );\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"javac tool not found\")\n+            );\n+\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        compileModuleClasses();\n+    }\n+\n+    \/**\n+     * Launches a \"jar --create\" command multiple times with a module-info.class. The module-info.class\n+     * is internally updated by the jar tool to add additional data. Expects that each such generated\n+     * jar has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarCreate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-create\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ create a modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--main-class=\" + MAIN_CLASS,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/**\n+     * Launches a \"jar --update\" process multiple times to update the module-info.class\n+     * descriptor with the same content and then expects that the modular jar created by\n+     * each of these processes has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarUpdate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-update\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ first create the modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+            \/\/ now update the same modular jar\n+            runJarCommand(\"--update\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + UPDATED_MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \"module-info.class\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, UPDATED_MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/\/ compiles using javac tool the classes used in the test module\n+    private static void compileModuleClasses() throws Exception {\n+        Path sourcePath = Path.of(System.getProperty(\"test.src\", \".\"),\n+                \"src\", MODULE_NAME);\n+        List<String> sourceFiles = new ArrayList<>();\n+        Files.walkFileTree(sourcePath, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.toString().endsWith(\".java\")) {\n+                    sourceFiles.add(file.toString());\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        Path classesDir = Files.createDirectories(MODULE_CLASSES_DIR);\n+        List<String> javacArgs = new ArrayList<>();\n+        javacArgs.add(\"-d\");\n+        javacArgs.add(classesDir.toString());\n+        sourceFiles.forEach((f) -> javacArgs.add(f));\n+        System.out.println(\"Launching javac command with args: \" + javacArgs);\n+        StringWriter sw = new StringWriter();\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAVAC_TOOL.run(pw, pw, javacArgs.toArray(new String[0]));\n+            assertEquals(exitCode, 0, \"Module compilation failed: \" + sw.toString());\n+        }\n+        System.out.println(\"Module classes successfully compiled to directory \" + classesDir);\n+    }\n+\n+    \/\/ runs the \"jar\" command passing it the \"jarArgs\" and verifying that the command\n+    \/\/ execution didn't fail\n+    private static void runJarCommand(String... jarArgs) {\n+        StringWriter sw = new StringWriter();\n+        System.out.println(\"Launching jar command with args: \" + Arrays.toString(jarArgs));\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAR_TOOL.run(pw, pw, jarArgs);\n+            assertEquals(exitCode, 0, \"jar command execution failed: \" + sw.toString());\n+        }\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(List<Path> files) throws Exception {\n+        Path firstFile = files.get(0);\n+        for (int i = 1; i < files.size(); i++) {\n+            assertEquals(Files.mismatch(firstFile, files.get(i)), -1,\n+                    \"Content in file \" + files.get(i) + \" isn't the same as in file \" + firstFile);\n+        }\n+    }\n+\n+    \/\/ verifies that a module-info.class is present in the jar and the module name and version are the expected\n+    \/\/ ones\n+    private static void assertExpectedModuleInfo(Path jar, String expectedModuleVersion) throws Exception {\n+        try (JarInputStream jaris = new JarInputStream(Files.newInputStream(jar))) {\n+            JarEntry moduleInfoEntry = null;\n+            JarEntry entry = null;\n+            while ((entry = jaris.getNextJarEntry()) != null) {\n+                if (entry.getName().equals(\"module-info.class\")) {\n+                    moduleInfoEntry = entry;\n+                    break;\n+                }\n+            }\n+            assertNotNull(moduleInfoEntry, \"module-info.class is missing from jar \" + jar);\n+\n+            ModuleDescriptor md = ModuleDescriptor.read(jaris);\n+            assertEquals(md.name(), MODULE_NAME, \"Unexpected module name\");\n+            assertFalse(md.rawVersion().isEmpty(), \"Module version missing from descriptor\");\n+\n+            String actualVersion = md.rawVersion().get();\n+            assertEquals(actualVersion, expectedModuleVersion, \"Unexpected module version\");\n+\n+            System.out.println(moduleInfoEntry.getName() + \" has a timestamp of \"\n+                    + moduleInfoEntry.getTime() + \" for version \" + actualVersion);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jar\/modularJar\/JarToolModuleDescriptorReproducibilityTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,0 @@\n-        commands.addAll(Utils.getForwardVmOptions());\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/MRTestBase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764\n@@ -200,0 +200,11 @@\n+\n+                \/\/ JDK-8276764: Ensure the order is sorted for reproducible jmod content\n+                \/\/ module-info, followed by <sorted classes>\n+                int mod_info_i = r.output.indexOf(CLASSES_PREFIX + \"module-info.class\");\n+                int foo_cls_i  = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/Foo.class\");\n+                int msg_i      = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/internal\/Message.class\");\n+                int res_i      = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/resources\/foo.properties\");\n+                System.out.println(\"jmod classes sort order check:\\n\"+r.output);\n+                assertTrue(mod_info_i < foo_cls_i);\n+                assertTrue(foo_cls_i < msg_i);\n+                assertTrue(msg_i < res_i);\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+\n+        AdditionalLauncher testAL = new AdditionalLauncher(\"testAL\");\n+        testAL.applyTo(cmd);\n+\n@@ -74,0 +78,3 @@\n+        Path testALPath = launcherPath.getParent().resolve(\"testAL\");\n+        SigningBase.verifyCodesign(testALPath, true);\n+\n@@ -79,17 +86,0 @@\n-    @Test\n-    public static void testAdditionalLauncher() throws Exception {\n-        SigningCheck.checkCertificates();\n-\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n-        cmd.addArguments(\"--mac-sign\", \"--mac-signing-key-user-name\",\n-                SigningBase.DEV_NAME, \"--mac-signing-keychain\",\n-                SigningBase.KEYCHAIN);\n-        AdditionalLauncher testAL = new AdditionalLauncher(\"testAL\");\n-        testAL.applyTo(cmd);\n-\n-        cmd.executeAndAssertHelloAppImageCreated();\n-        Path launcherPath = cmd.appLauncherPath();\n-        Path testALPath = launcherPath.getParent().resolve(\"testAL\");\n-        SigningBase.verifyCodesign(launcherPath, true);\n-        SigningBase.verifyCodesign(testALPath, true);\n-    }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -104,0 +104,6 @@\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content,\n+                                                  Optional<String> lang) {\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, lang, Optional.empty());\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestLangProperties\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class TestLangProperties extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestLangProperties().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    @Test\n+    public void testPositiveOuterMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\")) {\n+                    String markup = whitespace1 + commentIndicator1\n+                            + whitespace2 + \"@highlight :\";\n+                    var t = new TestSnippetMarkup.TestCase(\n+                            \"\"\"\n+                                    %s\n+                                    coffee=espresso\n+                                    tea=black\n+                                    \"\"\".formatted(markup),\n+                            \"\"\"\n+\n+                                    <span class=\"bold\">coffee=espresso\n+                                    <\/span>tea=black\n+                                    \"\"\");\n+                    testCases.add(t);\n+                }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveInnerMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\"))\n+                    for (String unrelatedComment : List.of(\"a comment\"))\n+                        for (String whitespace3 : List.of(\"\", \" \"))\n+                            for (String commentIndicator2 : List.of(\"#\", \"!\")) {\n+                                String payload = whitespace1 + commentIndicator1 + whitespace2 + unrelatedComment;\n+                                String markup = payload + whitespace3 + commentIndicator2 + \"@highlight :\";\n+                                var t = new TestSnippetMarkup.TestCase(\n+                                        \"\"\"\n+                                                %s\n+                                                coffee=espresso\n+                                                tea=black\n+                                                \"\"\".formatted(markup),\n+                                        \"\"\"\n+                                                %s\n+                                                <span class=\"bold\">coffee=espresso\n+                                                <\/span>tea=black\n+                                                \"\"\".formatted(payload));\n+                                testCases.add(t);\n+                            }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveIneffectiveOuterMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\")) {\n+                    String ineffectiveMarkup = whitespace1\n+                            + commentIndicator1 + whitespace2\n+                            + \"@highlight :\";\n+                    var t = new TestSnippetMarkup.TestCase(\n+                            \"\"\"\n+                                    coffee=espresso%s\n+                                    tea=black\n+                                    \"\"\".formatted(ineffectiveMarkup),\n+                            \"\"\"\n+                                    coffee=espresso%s\n+                                    tea=black\n+                                    \"\"\".formatted(ineffectiveMarkup));\n+                    testCases.add(t);\n+                }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveIneffectiveInnerMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\"))\n+                    for (String unrelatedComment : List.of(\"a comment\"))\n+                        for (String whitespace3 : List.of(\"\", \" \"))\n+                            for (String commentIndicator2 : List.of(\"#\", \"!\")) {\n+                                String ineffectiveMarkup = whitespace1\n+                                        + commentIndicator1 + whitespace2\n+                                        + unrelatedComment + whitespace3\n+                                        + commentIndicator2 + \"@highlight :\";\n+                                var t = new TestSnippetMarkup.TestCase(\n+                                        \"\"\"\n+                                                coffee=espresso%s\n+                                                tea=black\n+                                                \"\"\".formatted(ineffectiveMarkup),\n+                                        \"\"\"\n+                                                coffee=espresso%s\n+                                                tea=black\n+                                                \"\"\".formatted(ineffectiveMarkup));\n+                                testCases.add(t);\n+                            }\n+        testPositive(base, testCases);\n+    }\n+\n+    private void testPositive(Path base, List<TestSnippetMarkup.TestCase> testCases)\n+            throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(testCases, (i, n) -> {\n+            String r = i.region().isBlank() ? \"\" : \"region=\" + i.region();\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet lang=\"properties\" %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.input(), n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+        forEachNumbered(testCases, (t, index) -> {\n+            String html = \"\"\"\n+                    <span class=\"element-name\">case%s<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    %s\n+                    <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\",\n+                    t.expectedOutput(), Optional.of(\"properties\")));\n+            checkOutput(\"A.html\", true, html);\n+        });\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestLangProperties.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268725\n+ * @summary Tests for the --enable-native-access option\n+ * @modules jdk.jshell\n+ * @run testng ToolEnableNativeAccessTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class ToolEnableNativeAccessTest extends ReplToolTesting {\n+\n+    @Test\n+    public void testOptionDebug() {\n+        test(\n+                (a) -> assertCommand(a, \"\/debug b\",\n+                        \"RemoteVM Options: []\\n\"\n+                        + \"Compiler options: []\"),\n+                (a) -> assertCommand(a, \"\/env --enable-native-access\",\n+                        \"|  Setting new options and restoring state.\"),\n+                (a) -> assertCommandCheckOutput(a, \"\/debug b\", s -> {\n+                    assertTrue(s.contains(\"RemoteVM Options: [--enable-native-access, ALL-UNNAMED]\"));\n+                    assertTrue(s.contains(\"Compiler options: []\"));\n+                })\n+        );\n+    }\n+\n+    @Test\n+    public void testCommandLineFlag() {\n+        test(new String[] {\"--enable-native-access\"},\n+                (a) -> assertCommandCheckOutput(a, \"\/debug b\", s -> {\n+                    assertTrue(s.contains(\"RemoteVM Options: [--enable-native-access, ALL-UNNAMED]\"));\n+                    assertTrue(s.contains(\"Compiler options: []\"));\n+                })\n+        );\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnableNativeAccessTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -10,0 +10,2 @@\n+import java.util.Objects;\n+\n@@ -25,1 +27,6 @@\n-    class Outer {}\n+    class Outer {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(T6521805.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/6521805\/T6521805d.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T6521805d.java:18:18: compiler.err.cannot.generate.class: T6521805.Inner, (compiler.misc.synthetic.name.conflict: this$0, T6521805.Inner)\n+T6521805d.java:20:18: compiler.err.cannot.generate.class: T6521805.Inner, (compiler.misc.synthetic.name.conflict: this$0, T6521805.Inner)\n","filename":"test\/langtools\/tools\/javac\/6521805\/T6521805d.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+import java.util.Objects;\n+\n@@ -6,1 +8,6 @@\n-    class Super {}\n+    class Super {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(Outer.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/6521805\/p\/Outer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-FIELD  this$0\n---- FINAL\n@@ -23,2 +21,0 @@\n-FIELD  this$1\n---- FINAL\n@@ -32,2 +28,0 @@\n-FIELD  this$0\n---- FINAL\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/MemberModifiers.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (!javapOut.contains(\"0: #22(): CLASS_EXTENDS, type_index=65535\"))\n+        if (!javapOut.contains(\"0: #20(): CLASS_EXTENDS, type_index=65535\"))\n@@ -65,1 +65,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnnotatedExtendsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-        expectedNumberOfSyntheticFields = 1,\n@@ -50,2 +49,1 @@\n-        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"})\n@@ -53,2 +51,1 @@\n-        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"})\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateInnerClassConstructorsTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * 6. field this in Inner1.\n- * 7. constructor for Inner*.\n+ * 6. constructor for Inner*.\n@@ -53,2 +52,1 @@\n-        expectedFields = \"var\",\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedFields = \"var\")\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateInnerClassMembersTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * 6. field this in Inner1.\n- * 7. constructor for Inner*.\n+ * 6. constructor for Inner*.\n@@ -52,2 +51,1 @@\n-        expectedFields = \"var\",\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedFields = \"var\")\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateSiblingsTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-        expectedNumberOfSyntheticMethods = 1,\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedNumberOfSyntheticMethods = 1)\n@@ -65,2 +64,1 @@\n-        expectedMethods = {\"<init>(BridgeMethodsForLambdaTest)\", \"function()\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(BridgeMethodsForLambdaTest)\", \"function()\"})\n@@ -69,2 +67,1 @@\n-        expectedNumberOfSyntheticMethods = 1,\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedNumberOfSyntheticMethods = 1)\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/BridgeMethodsForLambdaTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.Objects;\n+\n@@ -52,0 +54,4 @@\n+            {\n+                \/\/ access enclosing instance so this$0 field is generated\n+                Objects.requireNonNull(ThisFieldTest.this);\n+            }\n@@ -55,0 +61,4 @@\n+            {\n+                \/\/ access enclosing instance so this$0 field is generated\n+                Objects.requireNonNull(ThisFieldTest.this);\n+            }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/ThisFieldTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -33,1 +35,6 @@\n-    public class Inner extends Outer { }\n+    public class Inner extends Outer {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(ErrSyntheticNameConflict.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ErrSyntheticNameConflict.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876\n@@ -633,0 +633,14 @@\n+    @Test\n+    public void testNoOptionsWarnings(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \"public class Main { public static void main(String... args) {}}\");\n+        String log = new JavaTask(tb)\n+                .vmOptions(\"--source\", \"7\")\n+                .className(base.resolve(\"Main.java\").toString())\n+                .run(Task.Expect.SUCCESS)\n+                .getOutput(Task.OutputKind.STDERR);\n+\n+        if (log.contains(\"warning: [options]\")) {\n+            error(\"Unexpected options warning in error output: \" + log);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8271623\n+ *\n+ * @compile --release 17 DontOptimizeOuterThis.java InnerClasses.java\n+ * @run main DontOptimizeOuterThis\n+ *\/\n+public class DontOptimizeOuterThis extends InnerClasses {\n+\n+    public static void main(String[] args) {\n+        new DontOptimizeOuterThis().test();\n+    }\n+\n+    public void test() {\n+        checkInner(localCapturesParameter(0), true);\n+        checkInner(localCapturesLocal(), true);\n+        checkInner(localCapturesEnclosing(), true);\n+\n+        checkInner(anonCapturesParameter(0), true);\n+        checkInner(anonCapturesLocal(), true);\n+        checkInner(anonCapturesEnclosing(), true);\n+\n+        checkInner(StaticMemberClass.class, false); \/\/ static\n+        checkInner(NonStaticMemberClass.class, true);\n+        checkInner(NonStaticMemberClassCapturesEnclosing.class, true);\n+\n+        checkInner(N0.class, false); \/\/ static\n+        checkInner(N0.N1.class, true);\n+        checkInner(N0.N1.N2.class, true);\n+        checkInner(N0.N1.N2.N3.class, true);\n+        checkInner(N0.N1.N2.N3.N4.class, true);\n+        checkInner(N0.N1.N2.N3.N4.N5.class, true);\n+\n+        checkInner(SerializableCapture.class, true);\n+        checkInner(SerializableWithSerialVersionUID.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDType.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonFinal.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonStatic.class, true);\n+    }\n+\n+    private static void checkInner(Class<?> clazz, boolean expectOuterThis) {\n+        Optional<Field> outerThis = Arrays.stream(clazz.getDeclaredFields())\n+                .filter(f -> f.getName().startsWith(\"this$\")).findFirst();\n+        if (expectOuterThis) {\n+            if (outerThis.isEmpty()) {\n+                throw new AssertionError(\n+                        String.format(\n+                                \"expected %s to have an enclosing instance\", clazz.getName()));\n+            }\n+        } else {\n+            if (outerThis.isPresent()) {\n+                throw new AssertionError(\n+                        String.format(\"%s had an unexpected enclosing instance\", clazz.getName()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/DontOptimizeOuterThis.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Serializable;\n+\n+public class InnerClasses {\n+\n+    public Class<?> localCapturesParameter(final int x) {\n+        class Local {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> localCapturesLocal() {\n+        final int x = 0;\n+        class Local {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> localCapturesEnclosing() {\n+        class Local {\n+            public void f() {\n+                System.err.println(InnerClasses.this);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> anonCapturesParameter(final int x) {\n+        return new Object() {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }.getClass();\n+    }\n+\n+    public Class<?> anonCapturesLocal() {\n+        final int x = 0;\n+        return new Object() {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }.getClass();\n+    }\n+\n+    public Class<?> anonCapturesEnclosing() {\n+        return new Object() {\n+            public void f() {\n+                System.err.println(InnerClasses.this);\n+            }\n+        }.getClass();\n+    }\n+\n+    public static class StaticMemberClass {}\n+\n+    public class NonStaticMemberClass {}\n+\n+    public class NonStaticMemberClassCapturesEnclosing {\n+        public void f() {\n+            System.err.println(InnerClasses.this);\n+        }\n+    }\n+\n+    static class N0 {\n+        int x;\n+\n+        class N1 {\n+            class N2 {\n+                class N3 {\n+                    void f() {\n+                        System.err.println(x);\n+                    }\n+\n+                    class N4 {\n+                        class N5 {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    class SerializableCapture implements Serializable {\n+      void f() {\n+        System.err.println(InnerClasses.this);\n+      }\n+    }\n+\n+    class SerializableWithSerialVersionUID implements Serializable {\n+      private static final long serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDType implements Serializable {\n+      private static final int serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDNonFinal implements Serializable {\n+      private static long serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDNonStatic implements Serializable {\n+      private final long serialVersionUID = 0;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/InnerClasses.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8271623\n+ *\n+ * @clean *\n+ * @compile OptimizeOuterThis.java InnerClasses.java\n+ * @run main OptimizeOuterThis\n+ *\n+ * @clean *\n+ * @compile -XDoptimizeOuterThis=true --release 17 OptimizeOuterThis.java InnerClasses.java\n+ * @run main OptimizeOuterThis\n+ *\/\n+public class OptimizeOuterThis extends InnerClasses {\n+\n+    public static void main(String[] args) {\n+        new OptimizeOuterThis().test();\n+    }\n+\n+    public void test() {\n+        checkInner(localCapturesParameter(0), false);\n+        checkInner(localCapturesLocal(), false);\n+        checkInner(localCapturesEnclosing(), true);\n+\n+        checkInner(anonCapturesParameter(0), false);\n+        checkInner(anonCapturesLocal(), false);\n+        checkInner(anonCapturesEnclosing(), true);\n+\n+        checkInner(StaticMemberClass.class, false);\n+        checkInner(NonStaticMemberClass.class, false);\n+        checkInner(NonStaticMemberClassCapturesEnclosing.class, true);\n+\n+        checkInner(N0.class, false);\n+        checkInner(N0.N1.class, true);\n+        checkInner(N0.N1.N2.class, true);\n+        checkInner(N0.N1.N2.N3.class, true);\n+        checkInner(N0.N1.N2.N3.N4.class, false);\n+        checkInner(N0.N1.N2.N3.N4.N5.class, false);\n+\n+        checkInner(SerializableCapture.class, true);\n+        checkInner(SerializableWithSerialVersionUID.class, false);\n+        checkInner(SerializableWithInvalidSerialVersionUIDType.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonFinal.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonStatic.class, true);\n+    }\n+\n+    private static void checkInner(Class<?> clazz, boolean expectOuterThis) {\n+        Optional<Field> outerThis = Arrays.stream(clazz.getDeclaredFields())\n+                .filter(f -> f.getName().startsWith(\"this$\")).findFirst();\n+        if (expectOuterThis) {\n+            if (outerThis.isEmpty()) {\n+                throw new AssertionError(\n+                        String.format(\n+                                \"expected %s to have an enclosing instance\", clazz.getName()));\n+            }\n+        } else {\n+            if (outerThis.isPresent()) {\n+                throw new AssertionError(\n+                        String.format(\"%s had an unexpected enclosing instance %s\", clazz.getName(), outerThis.get()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/OptimizeOuterThis.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8044859\n+ * @bug 8044859 8272728\n@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.main.Main;\n@@ -63,0 +64,12 @@\n+\n+    @Test\n+    void testAtFilesMustNotContainOptionJ() throws IOException {\n+        writeFile(\"args\", \"-J-verbose\");\n+\n+        String[] opts = { \"@args\", \"-version\" };\n+        String[] files = { };\n+\n+        runMain(opts, files)\n+            .checkResult(Main.Result.CMDERR.exitCode)\n+            .checkLog(Log.DIRECT, \"-J-verbose\");\n+    }\n","filename":"test\/langtools\/tools\/javac\/options\/modes\/AtFilesTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,0 +71,14 @@\n+    int testDominatesStringConstant2(String str) {\n+        switch (str) {\n+            case (String s && s.isEmpty()): return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n+    int testDominatesStringConstant3(String str) {\n+        switch (str) {\n+            case (String s && !s.isEmpty()): return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n@@ -78,0 +92,14 @@\n+    int testDominatesIntegerConstant2(Integer i) {\n+        switch (i) {\n+            case (Integer j && j == 0): return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n+    int testDominatesIntegerConstant3(Integer i) {\n+        switch (i) {\n+            case (Integer j && j == 1): return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n@@ -89,0 +117,22 @@\n+    int testDominatesEnumConstant2() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case (E d && d == E.A): return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n+    int testDominatesEnumConstant3() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case (E d && d == E.B): return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -6,1 +6,7 @@\n-Domination.java:85:18: compiler.err.pattern.dominated\n+Domination.java:81:18: compiler.err.pattern.dominated\n+Domination.java:88:18: compiler.err.pattern.dominated\n+Domination.java:95:18: compiler.err.pattern.dominated\n+Domination.java:102:18: compiler.err.pattern.dominated\n+Domination.java:113:18: compiler.err.pattern.dominated\n+Domination.java:124:18: compiler.err.pattern.dominated\n+Domination.java:135:18: compiler.err.pattern.dominated\n@@ -9,1 +15,1 @@\n-6 errors\n+12 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -57,0 +56,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -64,1 +64,0 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -66,0 +65,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -802,0 +802,88 @@\n+    @Test\n+    public void testOnlyApplicable(Path base) throws Exception {\n+        record TestCase(String cases, String... errors) {}\n+        TestCase[] subCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\"), \/\/OK\n+            new TestCase(\"\"\"\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C1 c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C1)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C2<?> c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C2<?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C4<?, ?> c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C4<?,?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+        };\n+        for (TestCase tc : subCases) {\n+            doTest(base,\n+                   new String[0],\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       sealed interface I<T> {}\n+                       final class C1 implements I<String> {}\n+                       final class C2<T> implements I<String> {}\n+                       final class C3<T> implements I<T> {}\n+                       final class C4<T, E> implements I<String> {}\n+                       final class C5<T, E> implements I<T> {}\n+                       final class C6<T, E> implements I<E> {}\n+                       void t(I<Integer> i) {\n+                           switch (i) {\n+                   ${cases}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"${cases}\", tc.cases),\n+                   tc.errors);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -188,1 +188,10 @@\n-    void test8269146a(Integer i) {\n+    void test8269146a1(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case 1, Integer o && o != null:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146a2(Integer i) {\n@@ -213,1 +222,8 @@\n-    void test8269301(Integer i) {\n+    void test8269301a(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case 1, Integer o && o != null, default:\n+                break;\n+        }\n+    }\n+    void test8269301b(Integer i) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,6 +34,9 @@\n-SwitchErrors.java:191:42: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:200:24: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:209:29: compiler.err.total.pattern.and.default\n-SwitchErrors.java:216:42: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:216:45: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:228:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:191:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:200:42: compiler.err.pattern.dominated\n+SwitchErrors.java:209:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:218:29: compiler.err.total.pattern.and.default\n+SwitchErrors.java:225:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:225:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:232:42: compiler.err.pattern.dominated\n+SwitchErrors.java:232:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:244:18: compiler.err.duplicate.total.pattern\n@@ -51,1 +54,1 @@\n-SwitchErrors.java:221:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:237:9: compiler.err.not.exhaustive.statement\n@@ -54,1 +57,1 @@\n-51 errors\n+54 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-            case E x && \"A\".equals(x.name()): return \"broken\";\n@@ -270,0 +269,1 @@\n+            case E x && \"A\".equals(x.name()): return \"broken\";\n@@ -278,1 +278,0 @@\n-            case E x && \"A\".equals(x.name()) -> \"broken\";\n@@ -280,0 +279,1 @@\n+            case E x && \"A\".equals(x.name()) -> \"broken\";\n@@ -289,2 +289,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -299,2 +298,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -309,2 +307,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -319,2 +316,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -329,2 +325,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -339,2 +334,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -349,2 +343,1 @@\n-            case \"C\": return \"broken\";\n-            case null, String x: return String.valueOf(x);\n+            case null, String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n@@ -359,2 +352,1 @@\n-            case \"C\" -> \"broken\";\n-            case null, String x -> String.valueOf(x);\n+            case null, String x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -369,2 +361,1 @@\n-            case 2: return \"broken\";\n-            case null, Integer x: return String.valueOf(x);\n+            case null, Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n@@ -379,2 +370,1 @@\n-            case 2 -> \"broken\";\n-            case null, Integer x -> String.valueOf(x);\n+            case null, Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n@@ -415,1 +405,0 @@\n-            case -1: r = 1;\n@@ -427,1 +416,0 @@\n-            case -1: r = 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8261847\n+ * @summary test the output of the toString method of records with a large number of components\n+ * @run testng BigRecordsToStringTest\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class BigRecordsToStringTest {\n+    record BigInt(\n+            int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+            int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+            int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+            int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+            int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+            int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+            int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+            int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+            int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+            int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100,\n+            int i101,int i102,int i103,int i104,int i105,int i106,int i107,int i108,int i109,int i110,\n+            int i111,int i112,int i113,int i114,int i115,int i116,int i117,int i118,int i119,int i120,\n+            int i121,int i122,int i123,int i124,int i125,int i126,int i127,int i128,int i129,int i130,\n+            int i131,int i132,int i133,int i134,int i135,int i136,int i137,int i138,int i139,int i140,\n+            int i141,int i142,int i143,int i144,int i145,int i146,int i147,int i148,int i149,int i150,\n+            int i151,int i152,int i153,int i154,int i155,int i156,int i157,int i158,int i159,int i160,\n+            int i161,int i162,int i163,int i164,int i165,int i166,int i167,int i168,int i169,int i170,\n+            int i171,int i172,int i173,int i174,int i175,int i176,int i177,int i178,int i179,int i180,\n+            int i181,int i182,int i183,int i184,int i185,int i186,int i187,int i188,int i189,int i190,\n+            int i191,int i192,int i193,int i194,int i195,int i196,int i197,int i198,int i199, int i200,\n+            int i201,int i202,int i203,int i204,int i205,int i206,int i207,int i208,int i209,int i210,\n+            int i211,int i212,int i213,int i214,int i215,int i216,int i217,int i218,int i219,int i220,\n+            int i221,int i222,int i223,int i224,int i225,int i226,int i227,int i228,int i229,int i230,\n+            int i231,int i232,int i233,int i234,int i235,int i236,int i237,int i238,int i239,int i240,\n+            int i241,int i242,int i243,int i244,int i245,int i246,int i247,int i248,int i249,int i250,\n+            int i251,int i252,int i253,int i254\n+    ) {}\n+\n+    BigInt bigInt= new BigInt(\n+            1,2,3,4,5,6,7,8,9,10,\n+            11,12,13,14,15,16,17,18,19,20,\n+            21,22,23,24,25,26,27,28,29,30,\n+            31,32,33,34,35,36,37,38,39,40,\n+            41,42,43,44,45,46,47,48,49,50,\n+            51,52,53,54,55,56,57,58,59,60,\n+            61,62,63,64,65,66,67,68,69,70,\n+            71,72,73,74,75,76,77,78,79,80,\n+            81,82,83,84,85,86,87,88,89,90,\n+            91,92,93,94,95,96,97,98,99,100,\n+            101,102,103,104,105,106,107,108,109,110,\n+            111,112,113,114,115,116,117,118,119,120,\n+            121,122,123,124,125,126,127,128,129,130,\n+            131,132,133,134,135,136,137,138,139,140,\n+            141,142,143,144,145,146,147,148,149,150,\n+            151,152,153,154,155,156,157,158,159,160,\n+            161,162,163,164,165,166,167,168,169,170,\n+            171,172,173,174,175,176,177,178,179,180,\n+            181,182,183,184,185,186,187,188,189,190,\n+            191,192,193,194,195,196,197,198,199, 200,\n+            201,202,203,204,205,206,207,208,209,210,\n+            211,212,213,214,215,216,217,218,219,220,\n+            221,222,223,224,225,226,227,228,229,230,\n+            231,232,233,234,235,236,237,238,239,240,\n+            241,242,243,244,245,246,247,248,249,250,\n+            251,252,253,254\n+    );\n+\n+    record BigLong(\n+            long i1,long i2,long i3,long i4,long i5,long i6,long i7,long i8,long i9,long i10,\n+            long i11,long i12,long i13,long i14,long i15,long i16,long i17,long i18,long i19,long i20,\n+            long i21,long i22,long i23,long i24,long i25,long i26,long i27,long i28,long i29,long i30,\n+            long i31,long i32,long i33,long i34,long i35,long i36,long i37,long i38,long i39,long i40,\n+            long i41,long i42,long i43,long i44,long i45,long i46,long i47,long i48,long i49,long i50,\n+            long i51,long i52,long i53,long i54,long i55,long i56,long i57,long i58,long i59,long i60,\n+            long i61,long i62,long i63,long i64,long i65,long i66,long i67,long i68,long i69,long i70,\n+            long i71,long i72,long i73,long i74,long i75,long i76,long i77,long i78,long i79,long i80,\n+            long i81,long i82,long i83,long i84,long i85,long i86,long i87,long i88,long i89,long i90,\n+            long i91,long i92,long i93,long i94,long i95,long i96,long i97,long i98,long i99,long i100,\n+            long i101,long i102,long i103,long i104,long i105,long i106,long i107,long i108,long i109,long i110,\n+            long i111,long i112,long i113,long i114,long i115,long i116,long i117,long i118,long i119,long i120,\n+            long i121,long i122,long i123,long i124,long i125,long i126,long i127\n+    ) {}\n+\n+    BigLong bigLong = new BigLong(\n+            1,2,3,4,5,6,7,8,9,10,\n+            11,12,13,14,15,16,17,18,19,20,\n+            21,22,23,24,25,26,27,28,29,30,\n+            31,32,33,34,35,36,37,38,39,40,\n+            41,42,43,44,45,46,47,48,49,50,\n+            51,52,53,54,55,56,57,58,59,60,\n+            61,62,63,64,65,66,67,68,69,70,\n+            71,72,73,74,75,76,77,78,79,80,\n+            81,82,83,84,85,86,87,88,89,90,\n+            91,92,93,94,95,96,97,98,99,100,\n+            101,102,103,104,105,106,107,108,109,110,\n+            111,112,113,114,115,116,117,118,119,120,\n+            121,122,123,124,125,126,127\n+    );\n+\n+    private static final String BIG_INT_TO_STRING_OUTPUT =\n+        \"BigInt[i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9, i10=10, i11=11, i12=12, i13=13, i14=14, i15=15, i16=16, \" +\n+            \"i17=17, i18=18, i19=19, i20=20, i21=21, i22=22, i23=23, i24=24, i25=25, i26=26, i27=27, i28=28, i29=29, i30=30, \" +\n+            \"i31=31, i32=32, i33=33, i34=34, i35=35, i36=36, i37=37, i38=38, i39=39, i40=40, i41=41, i42=42, i43=43, i44=44, \" +\n+            \"i45=45, i46=46, i47=47, i48=48, i49=49, i50=50, i51=51, i52=52, i53=53, i54=54, i55=55, i56=56, i57=57, i58=58, \" +\n+            \"i59=59, i60=60, i61=61, i62=62, i63=63, i64=64, i65=65, i66=66, i67=67, i68=68, i69=69, i70=70, i71=71, i72=72, \" +\n+            \"i73=73, i74=74, i75=75, i76=76, i77=77, i78=78, i79=79, i80=80, i81=81, i82=82, i83=83, i84=84, i85=85, i86=86, \" +\n+            \"i87=87, i88=88, i89=89, i90=90, i91=91, i92=92, i93=93, i94=94, i95=95, i96=96, i97=97, i98=98, i99=99, i100=100, \" +\n+            \"i101=101, i102=102, i103=103, i104=104, i105=105, i106=106, i107=107, i108=108, i109=109, i110=110, i111=111, i112=112, \" +\n+            \"i113=113, i114=114, i115=115, i116=116, i117=117, i118=118, i119=119, i120=120, i121=121, i122=122, i123=123, i124=124, \" +\n+            \"i125=125, i126=126, i127=127, i128=128, i129=129, i130=130, i131=131, i132=132, i133=133, i134=134, i135=135, i136=136, \" +\n+            \"i137=137, i138=138, i139=139, i140=140, i141=141, i142=142, i143=143, i144=144, i145=145, i146=146, i147=147, i148=148, \" +\n+            \"i149=149, i150=150, i151=151, i152=152, i153=153, i154=154, i155=155, i156=156, i157=157, i158=158, i159=159, i160=160, \" +\n+            \"i161=161, i162=162, i163=163, i164=164, i165=165, i166=166, i167=167, i168=168, i169=169, i170=170, i171=171, i172=172, \" +\n+            \"i173=173, i174=174, i175=175, i176=176, i177=177, i178=178, i179=179, i180=180, i181=181, i182=182, i183=183, i184=184, \" +\n+            \"i185=185, i186=186, i187=187, i188=188, i189=189, i190=190, i191=191, i192=192, i193=193, i194=194, i195=195, i196=196, \" +\n+            \"i197=197, i198=198, i199=199, i200=200, i201=201, i202=202, i203=203, i204=204, i205=205, i206=206, i207=207, i208=208, \" +\n+            \"i209=209, i210=210, i211=211, i212=212, i213=213, i214=214, i215=215, i216=216, i217=217, i218=218, i219=219, i220=220, \" +\n+            \"i221=221, i222=222, i223=223, i224=224, i225=225, i226=226, i227=227, i228=228, i229=229, i230=230, i231=231, i232=232, \" +\n+            \"i233=233, i234=234, i235=235, i236=236, i237=237, i238=238, i239=239, i240=240, i241=241, i242=242, i243=243, i244=244, \" +\n+            \"i245=245, i246=246, i247=247, i248=248, i249=249, i250=250, i251=251, i252=252, i253=253, i254=254]\";\n+\n+    private static final String BIG_LONG_TO_STRING_OUTPUT =\n+        \"BigLong[i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9, i10=10, i11=11, i12=12, i13=13, i14=14, i15=15, i16=16, i17=17, \" +\n+            \"i18=18, i19=19, i20=20, i21=21, i22=22, i23=23, i24=24, i25=25, i26=26, i27=27, i28=28, i29=29, i30=30, i31=31, i32=32, i33=33, \" +\n+            \"i34=34, i35=35, i36=36, i37=37, i38=38, i39=39, i40=40, i41=41, i42=42, i43=43, i44=44, i45=45, i46=46, i47=47, i48=48, i49=49, \" +\n+            \"i50=50, i51=51, i52=52, i53=53, i54=54, i55=55, i56=56, i57=57, i58=58, i59=59, i60=60, i61=61, i62=62, i63=63, i64=64, i65=65, \" +\n+            \"i66=66, i67=67, i68=68, i69=69, i70=70, i71=71, i72=72, i73=73, i74=74, i75=75, i76=76, i77=77, i78=78, i79=79, i80=80, i81=81, \" +\n+            \"i82=82, i83=83, i84=84, i85=85, i86=86, i87=87, i88=88, i89=89, i90=90, i91=91, i92=92, i93=93, i94=94, i95=95, i96=96, i97=97, \" +\n+            \"i98=98, i99=99, i100=100, i101=101, i102=102, i103=103, i104=104, i105=105, i106=106, i107=107, i108=108, i109=109, i110=110, \" +\n+            \"i111=111, i112=112, i113=113, i114=114, i115=115, i116=116, i117=117, i118=118, i119=119, i120=120, i121=121, i122=122, i123=123, \" +\n+            \"i124=124, i125=125, i126=126, i127=127]\";\n+\n+    public void testToStringOutput() {\n+        assertTrue(bigInt.toString().equals(BIG_INT_TO_STRING_OUTPUT));\n+        assertTrue(bigLong.toString().equals(BIG_LONG_TO_STRING_OUTPUT));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/BigRecordsToStringTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-                \"  0: #21(#22=B#23)\\n\" +\n+                \"  0: #17(#18=B#19)\\n\" +\n@@ -56,1 +56,1 @@\n-                \"  1: #24(#22=S#25)\\n\" +\n+                \"  1: #20(#18=S#21)\\n\" +\n@@ -62,1 +62,1 @@\n-                \"  0: #27(#22=[J#28,J#30,J#32,J#34,J#36])\\n\" +\n+                \"  0: #23(#18=[J#24,J#26,J#28,J#30,J#32])\\n\" +\n@@ -66,1 +66,1 @@\n-                \"  1: #38(#22=Z#39)\\n\" +\n+                \"  1: #34(#18=Z#35)\\n\" +\n@@ -70,1 +70,1 @@\n-                \"  2: #40(#41=c#42)\\n\" +\n+                \"  2: #36(#37=c#38)\\n\" +\n@@ -74,1 +74,1 @@\n-                \"  3: #43(#44=e#45.#46)\\n\" +\n+                \"  3: #39(#40=e#41.#42)\\n\" +\n@@ -78,1 +78,1 @@\n-                \"  4: #47(#22=I#48)\\n\" +\n+                \"  4: #43(#18=I#44)\\n\" +\n@@ -82,1 +82,1 @@\n-                \"  5: #49()\\n\" +\n+                \"  5: #45()\\n\" +\n@@ -84,1 +84,1 @@\n-                \"  6: #50(#51=s#52)\\n\" +\n+                \"  6: #46(#47=s#48)\\n\" +\n@@ -88,1 +88,1 @@\n-                \"  7: #53(#54=D#55,#57=F#58)\\n\" +\n+                \"  7: #49(#50=D#51,#53=F#54)\\n\" +\n@@ -93,1 +93,1 @@\n-                \"  8: #59()\\n\" +\n+                \"  8: #55()\\n\" +\n@@ -95,1 +95,1 @@\n-                \"  9: #60(#22=@#47(#22=I#61))\\n\" +\n+                \"  9: #56(#18=@#43(#18=I#57))\\n\" +\n@@ -103,1 +103,1 @@\n-                \"  0: #63(): CLASS_EXTENDS, type_index=0\\n\" +\n+                \"  0: #59(): CLASS_EXTENDS, type_index=0\\n\" +\n","filename":"test\/langtools\/tools\/javap\/AnnoTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277165\n+ * @library ..\/lib\n+ * @build CompilerUtils\n+ * @run testng MultiVersionError\n+ * @summary Tests multiple versions of the same class file\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Set;\n+import java.util.spi.ToolProvider;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class MultiVersionError {\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"src\");\n+\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\").orElseThrow();\n+    private static final Set<String> modules = Set.of(\"m1\", \"m2\");\n+\n+    \/**\n+     * Compiles classes used by the test\n+     *\/\n+    @BeforeTest\n+    public void compileAll() throws Exception {\n+        CompilerUtils.cleanDir(MODS_DIR);\n+        modules.forEach(mn ->\n+                assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn)));\n+\n+        \/\/ create a modular multi-release m1.jar\n+        Path m1 = MODS_DIR.resolve(\"m1\");\n+        Path m2 = MODS_DIR.resolve(\"m2\");\n+        jar(\"cf\", \"m1.jar\", \"-C\", m1.toString(), \"p\/Test.class\",\n+                \"--release\", \"9\", \"-C\", m1.toString(), \"module-info.class\",\n+                \"--release\", \"11\", \"-C\", m1.toString(), \"p\/internal\/P.class\");\n+        jar(\"cf\", \"m2.jar\", \"-C\", m2.toString(), \"q\/Q.class\",\n+                \"--release\", \"10\", \"-C\", m2.toString(), \"module-info.class\");\n+\n+        \/\/ package private p\/internal\/P.class in m1 instead\n+        jar(\"cf\", \"m3.jar\", \"-C\", m2.toString(), \"q\/Q.class\",\n+                \"--release\", \"12\", \"-C\", m2.toString(), \"module-info.class\",\n+                \"-C\", m1.toString(), \"p\/internal\/P.class\");\n+    }\n+\n+    \/*\n+     * multiple module-info.class from different versions should be excluded\n+     * from multiple version check.\n+     *\/\n+    @Test\n+    public void noMultiVersionClass() {\n+        \/\/ skip parsing p.internal.P to workaround JDK-8277681\n+        JdepsRunner jdepsRunner = new JdepsRunner(\"--print-module-deps\", \"--multi-release\", \"10\",\n+                                                  \"--ignore-missing-deps\",\n+                                                  \"--module-path\", \"m1.jar\", \"m2.jar\");\n+        int rc = jdepsRunner.run(true);\n+        assertTrue(rc == 0);\n+        assertTrue(jdepsRunner.outputContains(\"java.base,m1\"));\n+    }\n+\n+    \/*\n+     * Detect multiple versions of p.internal.P class\n+     *\/\n+    @Test\n+    public void classInMultiVersions() {\n+        JdepsRunner jdepsRunner = new JdepsRunner(\"--print-module-deps\", \"--multi-release\", \"13\",\n+                                                  \"--module-path\", \"m1.jar\", \"m3.jar\");\n+        int rc = jdepsRunner.run(true);\n+        assertTrue(rc != 0);\n+        assertTrue(jdepsRunner.outputContains(\"class p.internal.P already associated with version\"));\n+    }\n+\n+    private static void jar(String... options) {\n+        int rc = JAR_TOOL.run(System.out, System.err, options);\n+        assertTrue(rc == 0);\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/MultiVersionError.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module m1 {\n+    requires java.management;\n+    exports p;\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+public class Test {\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/p\/Test.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.internal;\n+\n+import java.lang.management.*;\n+\n+class P {\n+     private static RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/p\/internal\/P.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module m2 {\n+    requires m1;\n+    requires java.logging;\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.internal;\n+\n+import java.util.logging.Logger;\n+\n+public class P {\n+     private static final Logger LOGGER = Logger.getLogger(\"p\");\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/p\/internal\/P.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package q;\n+\n+public class Q {\n+    static p.Test t = new p.Test();\n+\n+    public Q() {\n+        Object o = new p.internal.P();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/q\/Q.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -320,0 +320,30 @@\n+  public         int     getMethodDecompileCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodDecompileCount0(method);\n+  }\n+  private native int     getMethodDecompileCount0(Executable method);\n+  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n+  \/\/ did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, null);\n+  }\n+  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n+  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method, String reason) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, reason);\n+  }\n+  private native int     getMethodTrapCount0(Executable method, String reason);\n+  \/\/ Get the total deopt count.\n+  public         int     getDeoptCount() {\n+    return getDeoptCount0(null, null);\n+  }\n+  \/\/ Get the deopt count for a specific reason and a specific action. If either\n+  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+  \/\/ If both arguments are null, the method returns the total deopt count.\n+  public         int     getDeoptCount(String reason, String action) {\n+    return getDeoptCount0(reason, action);\n+  }\n+  private native int     getDeoptCount0(String reason, String action);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -321,0 +321,30 @@\n+  public         int     getMethodDecompileCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodDecompileCount0(method);\n+  }\n+  private native int     getMethodDecompileCount0(Executable method);\n+  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n+  \/\/ did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, null);\n+  }\n+  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n+  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method, String reason) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, reason);\n+  }\n+  private native int     getMethodTrapCount0(Executable method, String reason);\n+  \/\/ Get the total deopt count.\n+  public         int     getDeoptCount() {\n+    return getDeoptCount0(null, null);\n+  }\n+  \/\/ Get the deopt count for a specific reason and a specific action. If either\n+  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+  \/\/ If both arguments are null, the method returns the total deopt count.\n+  public         int     getDeoptCount(String reason, String action) {\n+    return getDeoptCount0(reason, action);\n+  }\n+  private native int     getDeoptCount0(String reason, String action);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.arm.benchmarks.intrinsics;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * This benchmark modified from test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringCompareToDifferentLength.java\n+ * This benchmark can be used to measure performance of compareTo() in\n+ * (Latin1, Latin1), (Latin1, UTF16), (UTF16, Latin1), and (UTF16, UTF16)\n+ * comparisons.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Measurement(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+public class StringCompareToDifferentLength {\n+\n+    @State(Scope.Benchmark)\n+    public static class Input {\n+        @Param({\"24\", \"36\", \"72\", \"128\", \"256\", \"512\"})\n+        public int size;\n+\n+        @Param({\"2\"})\n+        public int delta;\n+\n+        int count = 100000;\n+        String longLatin1;\n+        String shortLatin1;\n+        String longUTF16FirstChar;\n+        String shortUTF16FirstChar;\n+        String longUTF16LastChar;\n+        String shortUTF16LastChar;\n+\n+        \/**\n+         * Initialize. New array objects and set initial values.\n+         *\/\n+        @Setup(Level.Trial)\n+        public void setup() throws Exception {\n+            char[] strsrc = new char[size + delta];\n+            \/\/ generate ASCII string\n+            for (int i = 0; i < size + delta; i++) {\n+                strsrc[i] = (char) ('a' + (i % 26));\n+            }\n+\n+            longLatin1 = new String(strsrc);\n+            shortLatin1 = longLatin1.substring(0, size);\n+            longUTF16LastChar = longLatin1.substring(0, longLatin1.length() - 1) + '\\ubeef';\n+            longUTF16FirstChar = '\\ubeef' + longLatin1.substring(1, longLatin1.length());\n+            shortUTF16LastChar = shortLatin1.substring(0, shortLatin1.length() - 1) + '\\ubeef';\n+            shortUTF16FirstChar = longUTF16FirstChar.substring(0, size);\n+        }\n+    }\n+\n+    private int runCompareTo(String str2, String str1) {\n+        return str1.compareTo(str2);\n+    }\n+\n+    \/**\n+     * latin1-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToLL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToUU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16FirstChar, in.shortUTF16FirstChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * latin1-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToLU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16LastChar, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToUL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortUTF16LastChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToDifferentLength.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -196,0 +196,1 @@\n+        threadConsumer.join();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadOnSpinWaitProducerConsumer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark assesses Record.toString which is implemented by ObjectMethods::makeToString\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class ObjectMethods {\n+    record R0() {}\n+    record R1(int i) {}\n+    record R10(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10) {}\n+    record R100(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+                int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+                int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+                int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+                int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+                int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+                int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+                int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+                int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+                int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100) {}\n+    record R254(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+                int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+                int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+                int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+                int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+                int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+                int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+                int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+                int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+                int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100,\n+                int i101,int i102,int i103,int i104,int i105,int i106,int i107,int i108,int i109,int i110,\n+                int i111,int i112,int i113,int i114,int i115,int i116,int i117,int i118,int i119,int i120,\n+                int i121,int i122,int i123,int i124,int i125,int i126,int i127,int i128,int i129,int i130,\n+                int i131,int i132,int i133,int i134,int i135,int i136,int i137,int i138,int i139,int i140,\n+                int i141,int i142,int i143,int i144,int i145,int i146,int i147,int i148,int i149,int i150,\n+                int i151,int i152,int i153,int i154,int i155,int i156,int i157,int i158,int i159,int i160,\n+                int i161,int i162,int i163,int i164,int i165,int i166,int i167,int i168,int i169,int i170,\n+                int i171,int i172,int i173,int i174,int i175,int i176,int i177,int i178,int i179,int i180,\n+                int i181,int i182,int i183,int i184,int i185,int i186,int i187,int i188,int i189,int i190,\n+                int i191,int i192,int i193,int i194,int i195,int i196,int i197,int i198,int i199, int i200,\n+                int i201,int i202,int i203,int i204,int i205,int i206,int i207,int i208,int i209,int i210,\n+                int i211,int i212,int i213,int i214,int i215,int i216,int i217,int i218,int i219,int i220,\n+                int i221,int i222,int i223,int i224,int i225,int i226,int i227,int i228,int i229,int i230,\n+                int i231,int i232,int i233,int i234,int i235,int i236,int i237,int i238,int i239,int i240,\n+                int i241,int i242,int i243,int i244,int i245,int i246,int i247,int i248,int i249,int i250,\n+                int i251,int i252,int i253,int i254) {}\n+\n+    R0 r0;\n+    R1 r1;\n+    R10 r10;\n+    R100 r100;\n+    R254 r254;\n+\n+    @Setup\n+    public void prepare() {\n+        r0 = new R0();\n+        r1 = new R1(1);\n+        r10 = new R10(1,2,3,4,5,6,7,8,9,10);\n+        r100 = new R100(1,2,3,4,5,6,7,8,9,10,\n+                        11,12,13,14,15,16,17,18,19,20,\n+                        21,22,23,24,25,26,27,28,29,30,\n+                        31,32,33,34,35,36,37,38,39,40,\n+                        41,42,43,44,45,46,47,48,49,50,\n+                        51,52,53,54,55,56,57,58,59,60,\n+                        61,62,63,64,65,66,67,68,69,70,\n+                        71,72,73,74,75,76,77,78,79,80,\n+                        81,82,83,84,85,86,87,88,89,90,\n+                        91,92,93,94,95,96,97,98,99,100);\n+        r254 = new R254(1,2,3,4,5,6,7,8,9,10,\n+                        11,12,13,14,15,16,17,18,19,20,\n+                        21,22,23,24,25,26,27,28,29,30,\n+                        31,32,33,34,35,36,37,38,39,40,\n+                        41,42,43,44,45,46,47,48,49,50,\n+                        51,52,53,54,55,56,57,58,59,60,\n+                        61,62,63,64,65,66,67,68,69,70,\n+                        71,72,73,74,75,76,77,78,79,80,\n+                        81,82,83,84,85,86,87,88,89,90,\n+                        91,92,93,94,95,96,97,98,99,100,\n+                        101,102,103,104,105,106,107,108,109,110,\n+                        111,112,113,114,115,116,117,118,119,120,\n+                        121,122,123,124,125,126,127,128,129,130,\n+                        131,132,133,134,135,136,137,138,139,140,\n+                        141,142,143,144,145,146,147,148,149,150,\n+                        151,152,153,154,155,156,157,158,159,160,\n+                        161,162,163,164,165,166,167,168,169,170,\n+                        171,172,173,174,175,176,177,178,179,180,\n+                        181,182,183,184,185,186,187,188,189,190,\n+                        191,192,193,194,195,196,197,198,199, 200,\n+                        201,202,203,204,205,206,207,208,209,210,\n+                        211,212,213,214,215,216,217,218,219,220,\n+                        221,222,223,224,225,226,227,228,229,230,\n+                        231,232,233,234,235,236,237,238,239,240,\n+                        241,242,243,244,245,246,247,248,249,250,\n+                        251,252,253,254);\n+    }\n+\n+    @Benchmark\n+    public String toString0() {\n+        return r0.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString1() {\n+        return r1.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString10() {\n+        return r10.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString100() {\n+        return r100.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString254() {\n+        return r254.toString();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/ObjectMethods.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util.regex;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value=1, jvmArgs= {\"-showversion\", \"-XX:+UseSerialGC\"})\n+@Warmup(iterations = 1, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 10, timeUnit = TimeUnit.SECONDS)\n+public class FindPattern {\n+    @Param({\"[^A-Za-z0-9]\", \"[A-Za-z0-9]\"})\n+    static String patternString;\n+    @Param({\"abcdefghijklmnop1234567890ABCDEFGHIJKLMNOP\",\n+            \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\"})\n+    static String text;\n+    static Pattern pattern;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() {\n+        pattern = Pattern.compile(patternString);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public int testFind() {\n+        int counter = 0;\n+        Matcher m = pattern.matcher(text);\n+        while (m.find()) {\n+            counter++;\n+        }\n+        return counter;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/FindPattern.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -41,1 +40,0 @@\n-import sun.misc.Unsafe;\n@@ -48,2 +46,0 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n-\n@@ -74,1 +70,1 @@\n-    @Param({\"CONFINED\", \"SHARED\", \"IMPLICIT\"})\n+    @Param({\"CONFINED\", \"SHARED\"})\n@@ -124,2 +120,1 @@\n-        if (!scope.isImplicit())\n-            scope.close();\n+        scope.close();\n@@ -137,2 +132,2 @@\n-        var handle = mismatchSegmentLarge1.scope().acquire();\n-        try {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            scope.keepAlive(mismatchSegmentLarge1.scope());\n@@ -140,2 +135,0 @@\n-        } finally {\n-            mismatchSegmentLarge1.scope().release(handle);\n@@ -160,2 +153,2 @@\n-        var handle = mismatchSegmentLarge1.scope().acquire();\n-        try {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            scope.keepAlive(mismatchSegmentLarge1.scope());\n@@ -163,2 +156,0 @@\n-        } finally {\n-            mismatchSegmentLarge1.scope().release(handle);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Setup;\n@@ -35,0 +37,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -40,0 +43,1 @@\n+import java.nio.IntBuffer;\n@@ -42,1 +46,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -58,2 +62,1 @@\n-    static final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final ResourceScope scope = ResourceScope.newConfinedScope();\n@@ -61,3 +64,7 @@\n-    static final int[] bytes = new int[ELEM_SIZE];\n-    static final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n-    static final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n+    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n+\n+    final int[] bytes = new int[ELEM_SIZE];\n+    final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n+    final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n@@ -67,4 +74,4 @@\n-    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n-    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n-    static final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    static final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n@@ -73,5 +80,7 @@\n-    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n-    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n-    static final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    static final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-    static {\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n+    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n+\n+    @Setup\n+    public void setup() {\n@@ -93,1 +102,0 @@\n-    }\n@@ -95,1 +103,0 @@\n-    static {\n@@ -101,0 +108,5 @@\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n@@ -125,0 +137,44 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small_dontinline() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void unsafe_copy_small() {\n+        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy_small() {\n+        buffer.put(0, bytes, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy() {\n+        buffer.put(0, bytes, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_dontinline() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, bytes.length);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":74,"deletions":18,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+public class CLayouts {\n+\n+    \/\/ the constants below are useful aliases for C types. The type\/carrier association is only valid for 64-bit platforms.\n+\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+\n+    \/**\n+     * The layout for the {@code long long} C type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+\n+    private static CLinker LINKER = CLinker.systemCLinker();\n+\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CLayouts.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -58,5 +59,0 @@\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n-    }\n-\n@@ -74,2 +70,57 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n+    public MemorySegment panama_identity_struct_confined() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_confined_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3.invokeExact(recycling_allocator, confinedPoint, confinedPoint, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3.invokeExact(recycling_allocator, sharedPoint, sharedPoint, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n@@ -79,2 +130,2 @@\n-    public MemorySegment panama_identity_struct() throws Throwable {\n-        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, point);\n+    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)MemoryAddress.NULL);\n@@ -84,2 +135,2 @@\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n+    public MemoryAddress panama_identity_memory_address_null_non_exact() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invoke(MemoryAddress.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -39,4 +38,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -44,1 +39,1 @@\n-public class CallOverheadHelper {\n+public class CallOverheadHelper extends CLayouts {\n@@ -46,1 +41,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -50,1 +45,1 @@\n-    static Addressable func_addr;\n+    static NativeSymbol func_addr;\n@@ -53,1 +48,1 @@\n-    static Addressable identity_addr;\n+    static NativeSymbol identity_addr;\n@@ -56,1 +51,4 @@\n-    static Addressable identity_struct_addr;\n+    static NativeSymbol identity_struct_addr;\n+    static final MethodHandle identity_struct_3;\n+    static final MethodHandle identity_struct_3_v;\n+    static NativeSymbol identity_struct_3_addr;\n@@ -59,1 +57,4 @@\n-    static Addressable identity_memory_address_addr;\n+    static NativeSymbol identity_memory_address_addr;\n+    static final MethodHandle identity_memory_address_3;\n+    static final MethodHandle identity_memory_address_3_v;\n+    static NativeSymbol identity_memory_address_3_addr;\n@@ -62,1 +63,1 @@\n-    static Addressable args1_addr;\n+    static NativeSymbol args1_addr;\n@@ -65,1 +66,1 @@\n-    static Addressable args2_addr;\n+    static NativeSymbol args2_addr;\n@@ -68,1 +69,1 @@\n-    static Addressable args3_addr;\n+    static NativeSymbol args3_addr;\n@@ -71,1 +72,1 @@\n-    static Addressable args4_addr;\n+    static NativeSymbol args4_addr;\n@@ -74,1 +75,1 @@\n-    static Addressable args5_addr;\n+    static NativeSymbol args5_addr;\n@@ -77,5 +78,1 @@\n-    static Addressable args10_addr;\n-    static final MethodHandle func_trivial;\n-    static final MethodHandle func_trivial_v;\n-    static final MethodHandle identity_trivial;\n-    static final MethodHandle identity_trivial_v;\n+    static NativeSymbol args10_addr;\n@@ -84,1 +81,1 @@\n-            C_LONG_LONG, C_LONG_LONG\n+            C_INT, C_INT\n@@ -87,0 +84,3 @@\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+\n@@ -89,1 +89,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n@@ -100,1 +100,1 @@\n-            func_v = abi.downcallHandle(mt, fd);\n+            func_v = abi.downcallHandle(fd);\n@@ -102,2 +102,0 @@\n-            func_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n@@ -107,1 +105,0 @@\n-            MethodType mt = MethodType.methodType(int.class, int.class);\n@@ -109,1 +106,1 @@\n-            identity_v = abi.downcallHandle(mt, fd);\n+            identity_v = abi.downcallHandle(fd);\n@@ -111,2 +108,0 @@\n-            identity_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n@@ -116,1 +111,0 @@\n-                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n@@ -120,0 +114,5 @@\n+        identity_struct_3_addr = lookup.lookup(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct_3 = insertArguments(identity_struct_3_v, 0, identity_struct_3_addr);\n+\n@@ -122,1 +121,0 @@\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n@@ -126,0 +124,5 @@\n+        identity_memory_address_3_addr = lookup.lookup(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        identity_memory_address_3 = insertArguments(identity_memory_address_3_v, 0, identity_memory_address_3_addr);\n+\n@@ -128,1 +131,0 @@\n-                MethodType.methodType(void.class, long.class),\n@@ -134,1 +136,0 @@\n-                MethodType.methodType(void.class, long.class, double.class),\n@@ -140,1 +141,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class),\n@@ -146,1 +146,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class),\n@@ -152,1 +151,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n@@ -158,2 +156,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                  double.class, long.class, double.class, long.class, double.class),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":36,"deletions":40,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -59,2 +60,6 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    public MemorySegment panama_identity_struct_confined() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, confinedPoint);\n@@ -64,2 +69,2 @@\n-    public int jni_identity() throws Throwable {\n-        return identity(10);\n+    public MemorySegment panama_identity_struct_shared() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, sharedPoint);\n@@ -69,2 +74,2 @@\n-    public int panama_identity() throws Throwable {\n-        return (int) identity_v.invokeExact(identity_addr, 10);\n+    public MemorySegment panama_identity_struct_confined_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3_v.invokeExact(identity_struct_3_addr, recycling_allocator, confinedPoint, confinedPoint, confinedPoint);\n@@ -74,2 +79,47 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    public MemorySegment panama_identity_struct_shared_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3_v.invokeExact(identity_struct_3_addr, recycling_allocator, sharedPoint, sharedPoint, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity_v.invokeExact(identity_addr, 10);\n@@ -84,2 +134,2 @@\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemoryAddress.NULL);\n+    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)MemoryAddress.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":60,"deletions":10,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef struct {\n+    jclass holder;\n+    jmethodID mid;\n+} *JNICB;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+public class JNICB {\n+\n+    static {\n+        System.loadLibrary(\"JNICB\");\n+    }\n+\n+    public static native long makeCB(String holder, String name, String signature);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -76,1 +76,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -64,1 +64,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -67,1 +67,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.ofSegment(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class LoopOverNewHeap {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (polluteProfile) {\n+            for (int i = 0 ; i < 10000 ; i++) {\n+                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n+                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n+                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unsafe_loop() {\n+        int[] elems = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void segment_loop() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public void segment_loop_dontinline() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void buffer_loop() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            buffer.put(i , i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNewHeap.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n@@ -63,1 +63,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -120,4 +120,4 @@\n-    public int segment_loop_static() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i ++) {\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+    public int segment_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(segment, (long) i);\n@@ -125,1 +125,1 @@\n-        return res;\n+        return sum;\n@@ -129,1 +129,1 @@\n-    public int segment_loop() {\n+    public int segment_loop_instance() {\n@@ -132,1 +132,30 @@\n-            sum += (int) VH_int.get(segment, (long) i);\n+            sum += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_index() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.getAtIndex(JAVA_INT, i);\n+\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address_index() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.address().getAtIndex(JAVA_INT, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,1 +44,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n@@ -78,1 +77,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentIn, i, i);\n+            segmentIn.setAtIndex(JAVA_DOUBLE, i, i);\n@@ -81,1 +80,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i, i);\n+            segmentOut.setAtIndex(JAVA_DOUBLE, i, i);\n@@ -115,3 +114,3 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i,\n-                    MemoryAccess.getDoubleAtIndex(segmentIn, i) +\n-                    MemoryAccess.getDoubleAtIndex(segmentOut, i));\n+            segmentOut.setAtIndex(JAVA_DOUBLE, i,\n+                    segmentIn.getAtIndex(JAVA_DOUBLE, i) +\n+                    segmentOut.getAtIndex(JAVA_DOUBLE, i));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -49,1 +48,4 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -66,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -82,1 +84,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope(Cleaner.create()));\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope());\n@@ -84,5 +86,5 @@\n-                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                MemoryAccess.setIntAtIndex(intI, i, i);\n-                MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                MemoryAccess.setFloatAtIndex(intF, i, i);\n-                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                intB.set(JAVA_BYTE, i, (byte)i);\n+                intI.setAtIndex(JAVA_INT, i, i);\n+                intD.setAtIndex(JAVA_DOUBLE, i, i);\n+                intF.setAtIndex(JAVA_FLOAT, i, i);\n+                s.set(JAVA_BYTE, i, (byte) i);\n@@ -137,1 +139,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -140,1 +142,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -54,1 +53,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -61,1 +60,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n@@ -84,1 +83,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -146,1 +145,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -149,1 +148,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -47,1 +46,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -63,1 +62,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -75,1 +74,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newSharedScope());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newConfinedScope());\n@@ -120,1 +119,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -123,1 +122,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,1 +44,2 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -65,1 +65,1 @@\n-    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -82,2 +82,2 @@\n-                MemoryAccess.setIntAtIndex(nativeSegment, i, i);\n-                MemoryAccess.setFloatAtIndex(nativeSegment, i, i);\n+                nativeSegment.setAtIndex(JAVA_INT, i, i);\n+                nativeSegment.setAtIndex(JAVA_FLOAT, i, i);\n@@ -85,2 +85,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentBytes, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentBytes, i, i);\n+                heapSegmentBytes.setAtIndex(JAVA_INT, i, i);\n+                heapSegmentBytes.setAtIndex(JAVA_FLOAT, i, i);\n@@ -88,2 +88,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentFloats, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentFloats, i, i);\n+                heapSegmentFloats.setAtIndex(JAVA_INT, i, i);\n+                heapSegmentFloats.setAtIndex(JAVA_FLOAT, i, i);\n@@ -116,1 +116,1 @@\n-    public int native_segment_static() {\n+    public int native_segment_instance() {\n@@ -119,2 +119,2 @@\n-            MemoryAccess.setIntAtOffset(nativeSegment, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(nativeSegment, k);\n+            nativeSegment.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = nativeSegment.getAtIndex(JAVA_INT, k);\n@@ -138,1 +138,1 @@\n-    public int heap_segment_ints_static() {\n+    public int heap_segment_ints_instance() {\n@@ -141,2 +141,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentBytes, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentBytes, k);\n+            heapSegmentBytes.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = heapSegmentBytes.getAtIndex(JAVA_INT, k);\n@@ -160,1 +160,1 @@\n-    public int heap_segment_floats_static() {\n+    public int heap_segment_floats_instance() {\n@@ -163,2 +163,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentFloats, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentFloats, k);\n+            heapSegmentFloats.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = heapSegmentFloats.getAtIndex(JAVA_INT, k);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -55,1 +55,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -68,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -70,1 +70,1 @@\n-    final static MemoryLayout ELEM_LAYOUT = MemoryLayouts.JAVA_INT;\n+    final static MemoryLayout ELEM_LAYOUT = ValueLayout.JAVA_INT;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class QSort extends CLayouts {\n+\n+    static final CLinker abi = CLinker.systemCLinker();\n+    static final MethodHandle clib_qsort;\n+    static final NativeSymbol native_compar;\n+    static final NativeSymbol panama_upcall_compar;\n+    static final long jni_upcall_compar;\n+\n+    static final int[] INPUT = { 5, 3, 2, 7, 8, 12, 1, 7 };\n+    static final MemorySegment INPUT_SEGMENT;\n+\n+    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n+\n+    static {\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n+        INPUT_SEGMENT.copyFrom(MemorySegment.ofArray(INPUT));\n+\n+        System.loadLibrary(\"QSortJNI\");\n+        jni_upcall_compar = JNICB.makeCB(\"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\", \"jni_upcall_compar\", \"(II)I\");\n+\n+        try {\n+            clib_qsort = abi.downcallHandle(\n+                    qsort_addr,\n+                    FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER)\n+            );\n+            System.loadLibrary(\"QSort\");\n+            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n+            panama_upcall_compar = abi.upcallStub(\n+                    lookup().findStatic(QSort.class,\n+                            \"panama_upcall_compar\",\n+                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+                    ResourceScope.globalScope()\n+            );\n+        } catch (ReflectiveOperationException e) {\n+            throw new BootstrapMethodError(e);\n+        }\n+    }\n+\n+    static native void jni_qsort_optimized(int[] array, long cb);\n+    static native void jni_qsort_naive(int[] array);\n+\n+    @FunctionalInterface\n+    interface JNIComparator {\n+        int cmp(int e0, int e1);\n+    }\n+\n+    static final JNIComparator COMP = QSort::jni_upcall_compar;\n+\n+    @Benchmark\n+    public void native_qsort() throws Throwable {\n+         clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)native_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_optimized() {\n+        jni_qsort_optimized(INPUT, jni_upcall_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_naive() {\n+        jni_qsort_naive(INPUT);\n+    }\n+\n+    @Benchmark\n+    public void panama_upcall_qsort() throws Throwable {\n+        clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)panama_upcall_compar);\n+    }\n+\n+    private static int getIntAbsolute(MemoryAddress addr) {\n+        return addr.get(JAVA_INT, 0);\n+    }\n+\n+    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n+        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    }\n+\n+    static int jni_upcall_compar(int j0, int j1) {\n+        return Integer.compare(j0, j1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -48,1 +48,0 @@\n-import java.lang.invoke.MethodType;\n@@ -51,1 +50,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -59,1 +58,1 @@\n-public class StrLenTest {\n+public class StrLenTest extends CLayouts {\n@@ -61,1 +60,1 @@\n-    ResourceScope scope = ResourceScope.newConfinedScope();\n+    ResourceScope scope = ResourceScope.newImplicitScope();\n@@ -64,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = SegmentAllocator.arenaAllocator(scope);\n+    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(scope);\n@@ -75,3 +74,0 @@\n-    static final MethodHandle STRLEN_TRIVIAL;\n-    static final MethodHandle MALLOC_TRIVIAL;\n-    static final MethodHandle FREE_TRIVIAL;\n@@ -80,3 +76,2 @@\n-        CLinker abi = CLinker.getInstance();\n-        STRLEN = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        CLinker abi = CLinker.systemCLinker();\n+        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -84,10 +79,0 @@\n-        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n-                MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-\n-        FREE_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n@@ -99,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(size + 1, ResourceScope.newImplicitScope()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, ResourceScope.newConfinedScope()));\n@@ -115,2 +100,3 @@\n-            MemorySegment segment = CLinker.toCString(str, scope);\n-            return (int)STRLEN.invokeExact(segment.address());\n+            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, scope);\n+            segment.setUtf8String(0, str);\n+            return (int)STRLEN.invokeExact((Addressable)segment);\n@@ -122,1 +108,1 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, arenaAllocator).address());\n+        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n@@ -127,1 +113,1 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n+        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n@@ -133,10 +119,2 @@\n-        int res = (int) STRLEN.invokeExact(address);\n-        CLinker.freeMemory(address);\n-        return res;\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen_unsafe_trivial() throws Throwable {\n-        MemoryAddress address = makeStringUnsafeTrivial(str);\n-        int res = (int) STRLEN_TRIVIAL.invokeExact(address);\n-        FREE_TRIVIAL.invokeExact(address);\n+        int res = (int) STRLEN.invokeExact((Addressable)address);\n+        freeMemory(address);\n@@ -149,12 +127,2 @@\n-        MemoryAddress address = CLinker.allocateMemory(len + 1);\n-        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n-        str.copyFrom(MemorySegment.ofArray(bytes));\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n-        return address;\n-    }\n-\n-    static MemoryAddress makeStringUnsafeTrivial(String s) throws Throwable {\n-        byte[] bytes = s.getBytes();\n-        int len = bytes.length;\n-        MemoryAddress address = (MemoryAddress)MALLOC_TRIVIAL.invokeExact((long)len + 1);\n-        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n+        MemoryAddress address = allocateMemory(len + 1);\n+        MemorySegment str = MemorySegment.ofAddress(address, len + 1, ResourceScope.globalScope());\n@@ -162,1 +130,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        str.set(JAVA_BYTE, len, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":18,"deletions":50,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -88,2 +88,2 @@\n-    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestAdaptVarHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,3 +28,0 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorSpecies;\n@@ -47,1 +41,0 @@\n-import java.nio.ByteOrder;\n@@ -50,0 +43,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -122,1 +117,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n@@ -132,1 +127,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import static jdk.incubator.foreign.MemoryAccess.*;\n@@ -37,0 +36,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -42,1 +43,1 @@\n-@Fork(3)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -49,2 +50,2 @@\n-    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, MemoryLayouts.JAVA_LONG)\n-            .varHandle(long.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, JAVA_LONG)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -68,2 +69,2 @@\n-            this.inputSegment = MemoryAddress.ofLong(inputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n-            this.outputSegment = MemoryAddress.ofLong(outputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n+            this.inputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.outputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n@@ -99,1 +100,1 @@\n-    public void static_handle_loop(Data state) {\n+    public void handle_loop_instance(Data state) {\n@@ -104,4 +105,4 @@\n-            setLongAtIndex(os, i,getLongAtIndex(is, i) + MemoryAccess.getLongAtIndex(os, i));\n-            setLongAtIndex(os, i+1,getLongAtIndex(is, i+1) + getLongAtIndex(os, i+1));\n-            setLongAtIndex(os, i+2,getLongAtIndex(is, i+2) + getLongAtIndex(os, i+2));\n-            setLongAtIndex(os, i+3,getLongAtIndex(is, i+3) + getLongAtIndex(os, i+3));\n+            os.setAtIndex(JAVA_LONG, i, is.getAtIndex(JAVA_LONG, i) + os.get(JAVA_LONG, i));\n+            os.setAtIndex(JAVA_LONG, i+1, is.getAtIndex(JAVA_LONG, i+1) + os.get(JAVA_LONG, i+1));\n+            os.setAtIndex(JAVA_LONG, i+2, is.getAtIndex(JAVA_LONG, i+2) + os.get(JAVA_LONG, i+2));\n+            os.setAtIndex(JAVA_LONG, i+3, is.getAtIndex(JAVA_LONG, i+3) + os.get(JAVA_LONG, i+3));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.Addressable;\n@@ -28,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -44,4 +45,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -55,1 +52,1 @@\n-public class Upcalls {\n+public class Upcalls extends CLayouts {\n@@ -57,1 +54,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -63,4 +60,4 @@\n-    static final MemoryAddress cb_blank;\n-    static final MemoryAddress cb_identity;\n-    static final MemoryAddress cb_args5;\n-    static final MemoryAddress cb_args10;\n+    static final NativeSymbol cb_blank;\n+    static final NativeSymbol cb_identity;\n+    static final NativeSymbol cb_args5;\n+    static final NativeSymbol cb_args10;\n@@ -77,4 +74,4 @@\n-        cb_blank_jni = makeCB(className, \"blank\", \"()V\");\n-        cb_identity_jni = makeCB(className, \"identity\", \"(I)I\");\n-        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n-        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n+        cb_blank_jni = JNICB.makeCB(className, \"blank\", \"()V\");\n+        cb_identity_jni = JNICB.makeCB(className, \"identity\", \"(I)I\");\n+        cb_args5_jni = JNICB.makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = JNICB.makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -89,1 +86,1 @@\n-                blank = linkFunc(name, mt, fd);\n+                blank = linkFunc(name, fd);\n@@ -97,1 +94,1 @@\n-                identity = linkFunc(name, mt, fd);\n+                identity = linkFunc(name, fd);\n@@ -107,1 +104,1 @@\n-                args5 = linkFunc(name, mt, fd);\n+                args5 = linkFunc(name, fd);\n@@ -119,1 +116,1 @@\n-                args10 = linkFunc(name, mt, fd);\n+                args10 = linkFunc(name, fd);\n@@ -127,1 +124,1 @@\n-    static MethodHandle linkFunc(String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+    static MethodHandle linkFunc(String name, FunctionDescriptor baseDesc) {\n@@ -130,2 +127,1 @@\n-            baseType.insertParameterTypes(baseType.parameterCount(), MemoryAddress.class),\n-            baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+                baseDesc.withAppendedArgumentLayouts(C_POINTER)\n@@ -135,1 +131,1 @@\n-    static MemoryAddress makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static NativeSymbol makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n@@ -139,1 +135,1 @@\n-        ).address();\n+        );\n@@ -147,1 +143,0 @@\n-    static native long makeCB(String holder, String name, String signature);\n@@ -156,1 +151,1 @@\n-        blank.invokeExact(cb_blank);\n+        blank.invokeExact((Addressable)cb_blank);\n@@ -176,1 +171,1 @@\n-        return (int) identity.invokeExact(10, cb_identity);\n+        return (int) identity.invokeExact(10, (Addressable)cb_identity);\n@@ -181,1 +176,1 @@\n-        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, (Addressable)cb_args5);\n@@ -186,1 +181,1 @@\n-        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, (Addressable)cb_args10);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.Addressable;\n@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -39,1 +41,0 @@\n-import java.lang.invoke.MethodType;\n@@ -42,6 +43,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n-import static jdk.incubator.foreign.CLinker.asVarArg;\n-\n@@ -54,1 +49,1 @@\n-public class VaList {\n+public class VaList extends CLayouts {\n@@ -56,1 +51,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -67,2 +62,1 @@\n-                MethodType.methodType(void.class, int.class, int.class, double.class, long.class),\n-                FunctionDescriptor.ofVoid(C_INT, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_LONG_LONG)));\n+                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n@@ -70,2 +64,1 @@\n-                MethodType.methodType(void.class, int.class, CLinker.VaList.class),\n-                FunctionDescriptor.ofVoid(C_INT, C_VA_LIST));\n+                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n@@ -83,4 +76,4 @@\n-            CLinker.VaList vaList = CLinker.VaList.make(b ->\n-                    b.vargFromInt(C_INT, 1)\n-                            .vargFromDouble(C_DOUBLE, 2D)\n-                            .vargFromLong(C_LONG_LONG, 3L), scope);\n+            jdk.incubator.foreign.VaList vaList = jdk.incubator.foreign.VaList.make(b ->\n+                    b.addVarg(C_INT, 1)\n+                            .addVarg(C_DOUBLE, 2D)\n+                            .addVarg(C_LONG_LONG, 3L), scope);\n@@ -88,1 +81,1 @@\n-                    vaList);\n+                    (Addressable)vaList);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -57,1 +57,1 @@\n-        generic = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        generic = MemoryHandles.varHandle(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    long long x;\n-    long long y;\n+    int x;\n+    int y;\n@@ -45,0 +45,4 @@\n+EXPORT Point identity_struct_3(Point p1, Point p2, Point p3) {\n+    return p1;\n+}\n+\n@@ -49,0 +53,4 @@\n+EXPORT void* identity_memory_address_3(void* p1, void* p2, void* p3) {\n+    return p1;\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+#include \"JNICB.h\"\n+#include \"jlong.h\"\n+\n+#define CHECK_NULL(thing, message) \\\n+    if (thing == NULL) { \\\n+        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n+        (*env)->ThrowNew(env, cls, message); \\\n+        return 0; \\\n+    }\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_JNICB_makeCB\n+  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n+\n+  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n+  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n+  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n+\n+  JNICB cb = malloc(sizeof *cb);\n+  CHECK_NULL(cb, \"Can not allocate cb\");\n+\n+  jclass holder = (*env)->FindClass(env, holderNameC);\n+  CHECK_NULL(holder, \"Can not find class\");\n+  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n+  cb->holder = holder;\n+\n+  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n+  CHECK_NULL(methodID, \"Can not find method\");\n+  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n+  cb->mid = methodID;\n+\n+  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n+  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n+  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n+\n+  return ptr_to_jlong(cb);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libJNICB.c","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\n+EXPORT int compar(const void* e0, const void* e1) {\n+    int i0 = *((int*) e0);\n+    int i1 = *((int*) e1);\n+    return i0 - i1;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSort.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <stdlib.h>\n+\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n+\n+#ifdef _WIN64\n+#define THREAD_LOCAL __declspec(thread)\n+#else\n+#define THREAD_LOCAL __thread\n+#endif\n+\n+THREAD_LOCAL struct {\n+  JNICB cb;\n+  JNIEnv* env;\n+} ctx_opt;\n+\n+static int comparator(const void* e0, const void* e1) {\n+    JNICB jniCb = ctx_opt.cb;\n+    JNIEnv* env = ctx_opt.env;\n+    jint j0 = *((jint*) e0);\n+    jint j1 = *((jint*) e1);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, j0, j1);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1optimized\n+        (JNIEnv *env, jclass cls, jintArray arr, jlong cb) {\n+\n+    ctx_opt.cb = jlong_to_ptr(cb);\n+    ctx_opt.env = env;\n+\n+    jint* ints = (*env)->GetIntArrayElements(env, arr, NULL);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+\n+    qsort(ints, length, sizeof(jint), &comparator);\n+\n+    (*env)->ReleaseIntArrayElements(env, arr, ints, 0);\n+}\n+\n+JavaVM* VM = NULL;\n+\n+int java_cmp(const void *a, const void *b) {\n+   int v1 = *((int*)a);\n+   int v2 = *((int*)b);\n+\n+   JNIEnv* env;\n+   (*VM)->GetEnv(VM, (void**) &env, JNI_VERSION_10);\n+\n+   jclass qsortClass = (*env)->FindClass(env, \"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\");\n+   jmethodID methodId = (*env)->GetStaticMethodID(env, qsortClass, \"jni_upcall_compar\", \"(II)I\");\n+\n+   return (*env)->CallStaticIntMethod(env, qsortClass, methodId, v1, v2);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1naive\n+        (JNIEnv *env, jclass cls, jintArray arr) {\n+    if (VM == NULL) {\n+        (*env)->GetJavaVM(env, &VM);\n+    }\n+\n+    jint* carr = (*env)->GetIntArrayElements(env, arr, 0);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+    qsort(carr, length, sizeof(jint), java_cmp);\n+    (*env)->ReleaseIntArrayElements(env, arr, carr, 0);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSortJNI.c","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -25,20 +25,0 @@\n-#include \"jlong.h\"\n-\n-typedef struct {\n-    jclass holder;\n-    jmethodID mid;\n-} *JNICB;\n-\n-#define CHECK_NULL(thing, message) \\\n-    if (thing == NULL) { \\\n-        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n-        (*env)->ThrowNew(env, cls, message); \\\n-        return 0; \\\n-    }\n-\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_makeCB\n-  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n-\n-  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n-  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n-  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n@@ -46,19 +26,2 @@\n-  JNICB cb = malloc(sizeof *cb);\n-  CHECK_NULL(cb, \"Can not allocate cb\");\n-\n-  jclass holder = (*env)->FindClass(env, holderNameC);\n-  CHECK_NULL(holder, \"Can not find class\");\n-  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n-  cb->holder = holder;\n-\n-  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n-  CHECK_NULL(methodID, \"Can not find method\");\n-  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n-  cb->mid = methodID;\n-\n-  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n-  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n-  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n-\n-  return ptr_to_jlong(cb);\n-}\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -26,1 +28,0 @@\n-import jdk.incubator.foreign.SymbolLookup;\n@@ -28,0 +29,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -30,1 +32,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,0 +33,1 @@\n+import org.openjdk.bench.jdk.incubator.foreign.CLayouts;\n@@ -38,1 +40,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -40,1 +41,1 @@\n-public class PanamaPoint implements AutoCloseable {\n+public class PanamaPoint extends CLayouts implements AutoCloseable {\n@@ -47,2 +48,2 @@\n-    private static final VarHandle VH_x = LAYOUT.varHandle(int.class, groupElement(\"x\"));\n-    private static final VarHandle VH_y = LAYOUT.varHandle(int.class, groupElement(\"y\"));\n+    private static final VarHandle VH_x = LAYOUT.varHandle(groupElement(\"x\"));\n+    private static final VarHandle VH_y = LAYOUT.varHandle(groupElement(\"y\"));\n@@ -53,1 +54,1 @@\n-        CLinker abi = CLinker.getInstance();\n+        CLinker abi = CLinker.systemCLinker();\n@@ -58,2 +59,1 @@\n-            methodType(double.class, MemorySegment.class, MemorySegment.class),\n-            FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n+                FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n@@ -62,3 +62,2 @@\n-            lookup.lookup(\"distance_ptrs\").get(),\n-            methodType(double.class, MemoryAddress.class, MemoryAddress.class),\n-            FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n+                lookup.lookup(\"distance_ptrs\").get(),\n+                FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n@@ -110,1 +109,1 @@\n-            return (double) MH_distance_ptrs.invokeExact(segment.address(), other.segment.address());\n+            return (double) MH_distance_ptrs.invokeExact((Addressable)segment, (Addressable)other.segment);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -49,0 +47,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -119,2 +119,2 @@\n-    srcAddress = CLinker.allocateMemory(size);\n-    dstAddress = CLinker.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -235,2 +235,2 @@\n-      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n-      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+      var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n+      dstSegmentImplicit.set(JAVA_BYTE, i, v);\n@@ -243,2 +243,2 @@\n-      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker;\n+\n@@ -115,1 +115,1 @@\n-    implicitScope = ResourceScope.newImplicitScope();\n+    implicitScope = ResourceScope.newSharedScope();\n@@ -122,2 +122,2 @@\n-    srcAddress = CLinker.allocateMemory(size);\n-    dstAddress = CLinker.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -133,6 +133,0 @@\n-  @TearDown\n-  public void tearDown() {\n-    CLinker.freeMemory(srcAddress);\n-    CLinker.freeMemory(dstAddress);\n-  }\n-\n@@ -219,2 +213,2 @@\n-      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"}]}