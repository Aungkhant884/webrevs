{"files":[{"patch":"@@ -694,1 +694,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfByte.fromArray(arr);\n@@ -708,1 +708,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfChar.fromArray(arr);\n@@ -722,1 +722,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfShort.fromArray(arr);\n@@ -736,1 +736,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfInt.fromArray(arr);\n@@ -750,1 +750,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfFloat.fromArray(arr);\n@@ -764,1 +764,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfLong.fromArray(arr);\n@@ -778,1 +778,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfDouble.fromArray(arr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-            return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, bufferScope);\n+            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes, bufferScope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n- * sharp type information, as well as sharp null-check information. For this reason, the factories for heap segments\n- * use a lambda to implement the base object accessor, so that the type information will remain sharp (e.g.\n- * the static compiler will generate specialized base accessor for us).\n+ * sharp type information, as well as sharp null-check information. For this reason, many concrete subclasses\n+ * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}, so that each subclass can override the\n+ * {@link HeapMemorySegmentImpl#base()} method so that it returns an array ogf the correct (sharp) type.\n@@ -46,1 +46,1 @@\n-public class HeapMemorySegmentImpl<H> extends AbstractMemorySegmentImpl {\n+public abstract class HeapMemorySegmentImpl<H> extends AbstractMemorySegmentImpl {\n@@ -52,1 +52,1 @@\n-    final Supplier<H> baseProvider;\n+    final H base;\n@@ -55,1 +55,1 @@\n-    HeapMemorySegmentImpl(long offset, Supplier<H> baseProvider, long length, int mask, MemoryScope scope) {\n+    HeapMemorySegmentImpl(long offset, H base, long length, int mask, MemoryScope scope) {\n@@ -58,1 +58,1 @@\n-        this.baseProvider = baseProvider;\n+        this.base = base;\n@@ -62,3 +62,1 @@\n-    H base() {\n-        return Objects.requireNonNull(baseProvider.get());\n-    }\n+    abstract H base();\n@@ -72,3 +70,1 @@\n-    HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, MemoryScope scope) {\n-        return new HeapMemorySegmentImpl<>(this.offset + offset, baseProvider, size, mask, scope);\n-    }\n+    abstract HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, MemoryScope scope);\n@@ -87,4 +83,10 @@\n-    public static MemorySegment makeArraySegment(byte[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);\n-    }\n+    public static class OfByte extends HeapMemorySegmentImpl<byte[]> {\n+\n+        OfByte(long offset, byte[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfByte dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfByte(this.offset + offset, base, size, mask, scope);\n+        }\n@@ -92,3 +94,10 @@\n-    public static MemorySegment makeArraySegment(char[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+        @Override\n+        byte[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(byte[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n@@ -97,3 +106,21 @@\n-    public static MemorySegment makeArraySegment(short[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+    public static class OfChar extends HeapMemorySegmentImpl<char[]> {\n+\n+        OfChar(long offset, char[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfChar dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfChar(this.offset + offset, base, size, mask, scope);\n+        }\n+\n+        @Override\n+        char[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(char[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n@@ -102,3 +129,21 @@\n-    public static MemorySegment makeArraySegment(int[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);\n+    public static class OfShort extends HeapMemorySegmentImpl<short[]> {\n+\n+        OfShort(long offset, short[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfShort dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfShort(this.offset + offset, base, size, mask, scope);\n+        }\n+\n+        @Override\n+        short[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(short[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n@@ -107,3 +152,21 @@\n-    public static MemorySegment makeArraySegment(long[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);\n+    public static class OfInt extends HeapMemorySegmentImpl<int[]> {\n+\n+        OfInt(long offset, int[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfInt dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfInt(this.offset + offset, base, size, mask, scope);\n+        }\n+\n+        @Override\n+        int[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(int[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n@@ -112,3 +175,21 @@\n-    public static MemorySegment makeArraySegment(float[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+    public static class OfLong extends HeapMemorySegmentImpl<long[]> {\n+\n+        OfLong(long offset, long[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfLong dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfLong(this.offset + offset, base, size, mask, scope);\n+        }\n+\n+        @Override\n+        long[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(long[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n@@ -117,3 +198,21 @@\n-    public static MemorySegment makeArraySegment(double[] arr) {\n-        return makeHeapSegment(() -> arr, arr.length,\n-                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+    public static class OfFloat extends HeapMemorySegmentImpl<float[]> {\n+\n+        OfFloat(long offset, float[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfFloat dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfFloat(this.offset + offset, base, size, mask, scope);\n+        }\n+\n+        @Override\n+        float[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(float[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n@@ -122,4 +221,21 @@\n-    static <Z> HeapMemorySegmentImpl<Z> makeHeapSegment(Supplier<Z> obj, int length, int base, int scale) {\n-        int byteSize = length * scale;\n-        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-        return new HeapMemorySegmentImpl<>(base, obj, byteSize, defaultAccessModes(byteSize), scope);\n+    public static class OfDouble extends HeapMemorySegmentImpl<double[]> {\n+\n+        OfDouble(long offset, double[] base, long length, int mask, MemoryScope scope) {\n+            super(offset, base, length, mask, scope);\n+        }\n+\n+        @Override\n+        OfDouble dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new OfDouble(this.offset + offset, base, size, mask, scope);\n+        }\n+\n+        @Override\n+        double[] base() {\n+            return Objects.requireNonNull(base);\n+        }\n+\n+        public static MemorySegment fromArray(double[] arr) {\n+            int byteSize = arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n+            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":155,"deletions":39,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -70,0 +71,3 @@\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n@@ -72,0 +76,16 @@\n+        if (polluteProfile) {\n+            MemorySegment intB = MemorySegment.ofArray(new byte[ALLOC_SIZE]);\n+            MemorySegment intI = MemorySegment.ofArray(new int[ALLOC_SIZE]);\n+            MemorySegment intD = MemorySegment.ofArray(new double[ALLOC_SIZE]);\n+            MemorySegment intF = MemorySegment.ofArray(new float[ALLOC_SIZE]);\n+            try (MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE)) {\n+                for (int i = 0; i < ALLOC_SIZE; i++) {\n+                    MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n+                    MemoryAccess.setIntAtIndex(intI, i, i);\n+                    MemoryAccess.setDoubleAtIndex(intD, i, i);\n+                    MemoryAccess.setFloatAtIndex(intF, i, i);\n+                    MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                }\n+            }\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}