{"files":[{"patch":"@@ -1158,1 +1158,0 @@\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n- * Crash protection for the JfrSampler thread. Wrap the callback\n- * with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n+ * Crash protection for the JfrSampler thread (but also used for AsyncGetCallTrace).\n+ * Wrap the callback with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5314,1 +5314,0 @@\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,2 +145,3 @@\n- * Crash protection for the JfrSampler thread. Wrap the callback\n- * with a __try { call() }\n+ * Crash protection for the JfrSampler thread (but also used for AsyncGetCallTrace).\n+ * Wrap the callback with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n+ * back.\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-  bool is_JfrSampler_thread() const { return true; }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -508,57 +508,1 @@\n-\/\/ Forte Analyzer AsyncGetCallTrace() entry point. Currently supported\n-\/\/ on Linux X86, Solaris SPARC and Solaris X86.\n-\/\/\n-\/\/ Async-safe version of GetCallTrace being called from a signal handler\n-\/\/ when a LWP gets interrupted by SIGPROF but the stack traces are filled\n-\/\/ with different content (see below).\n-\/\/\n-\/\/ This function must only be called when JVM\/TI\n-\/\/ CLASS_LOAD events have been enabled since agent startup. The enabled\n-\/\/ event will cause the jmethodIDs to be allocated at class load time.\n-\/\/ The jmethodIDs cannot be allocated in a signal handler because locks\n-\/\/ cannot be grabbed in a signal handler safely.\n-\/\/\n-\/\/ void (*AsyncGetCallTrace)(ASGCT_CallTrace *trace, jint depth, void* ucontext)\n-\/\/\n-\/\/ Called by the profiler to obtain the current method call stack trace for\n-\/\/ a given thread. The thread is identified by the env_id field in the\n-\/\/ ASGCT_CallTrace structure. The profiler agent should allocate a ASGCT_CallTrace\n-\/\/ structure with enough memory for the requested stack depth. The VM fills in\n-\/\/ the frames buffer and the num_frames field.\n-\/\/\n-\/\/ Arguments:\n-\/\/\n-\/\/   trace    - trace data structure to be filled by the VM.\n-\/\/   depth    - depth of the call stack trace.\n-\/\/   ucontext - ucontext_t of the LWP\n-\/\/\n-\/\/ ASGCT_CallTrace:\n-\/\/   typedef struct {\n-\/\/       JNIEnv *env_id;\n-\/\/       jint num_frames;\n-\/\/       ASGCT_CallFrame *frames;\n-\/\/   } ASGCT_CallTrace;\n-\/\/\n-\/\/ Fields:\n-\/\/   env_id     - ID of thread which executed this trace.\n-\/\/   num_frames - number of frames in the trace.\n-\/\/                (< 0 indicates the frame is not walkable).\n-\/\/   frames     - the ASGCT_CallFrames that make up this trace. Callee followed by callers.\n-\/\/\n-\/\/  ASGCT_CallFrame:\n-\/\/    typedef struct {\n-\/\/        jint lineno;\n-\/\/        jmethodID method_id;\n-\/\/    } ASGCT_CallFrame;\n-\/\/\n-\/\/  Fields:\n-\/\/    1) For Java frame (interpreted and compiled),\n-\/\/       lineno    - bci of the method being executed or -1 if bci is not available\n-\/\/       method_id - jmethodID of the method being executed\n-\/\/    2) For native method\n-\/\/       lineno    - (-3)\n-\/\/       method_id - jmethodID of the method being executed\n-\n-extern \"C\" {\n-JNIEXPORT\n-void AsyncGetCallTrace(ASGCT_CallTrace *trace, jint depth, void* ucontext) {\n+static void asyncGetCallTraceImpl(ASGCT_CallTrace *trace, jint depth, void* ucontext) {\n@@ -653,0 +597,87 @@\n+\/\/ Helps to wrap ASGCT in crash protection similar to JFR\n+class AsyncGetCallTraceCallBack : public os::CrashProtectionCallback {\n+public:\n+  AsyncGetCallTraceCallBack(ASGCT_CallTrace *trace, jint depth, void* ucontext) :\n+    _trace(trace), _depth(depth), _ucontext(ucontext) {\n+  }\n+  virtual void call() {\n+    asyncGetCallTraceImpl(_trace, _depth, _ucontext);\n+  }\n+ private:\n+  ASGCT_CallTrace* _trace;\n+  jint _depth;\n+  void* _ucontext;\n+};\n+\n+\/\/ Forte Analyzer AsyncGetCallTrace() entry point. Currently supported\n+\/\/ on Linux X86, Solaris SPARC and Solaris X86.\n+\/\/\n+\/\/ Async-safe version of GetCallTrace being called from a signal handler\n+\/\/ when a LWP gets interrupted by SIGPROF but the stack traces are filled\n+\/\/ with different content (see below).\n+\/\/\n+\/\/ This function must only be called when JVM\/TI\n+\/\/ CLASS_LOAD events have been enabled since agent startup. The enabled\n+\/\/ event will cause the jmethodIDs to be allocated at class load time.\n+\/\/ The jmethodIDs cannot be allocated in a signal handler because locks\n+\/\/ cannot be grabbed in a signal handler safely.\n+\/\/\n+\/\/ void (*AsyncGetCallTrace)(ASGCT_CallTrace *trace, jint depth, void* ucontext)\n+\/\/\n+\/\/ Called by the profiler to obtain the current method call stack trace for\n+\/\/ a given thread. The thread is identified by the env_id field in the\n+\/\/ ASGCT_CallTrace structure. The profiler agent should allocate a ASGCT_CallTrace\n+\/\/ structure with enough memory for the requested stack depth. The VM fills in\n+\/\/ the frames buffer and the num_frames field.\n+\/\/\n+\/\/ Arguments:\n+\/\/\n+\/\/   trace    - trace data structure to be filled by the VM.\n+\/\/   depth    - depth of the call stack trace.\n+\/\/   ucontext - ucontext_t of the LWP\n+\/\/\n+\/\/ ASGCT_CallTrace:\n+\/\/   typedef struct {\n+\/\/       JNIEnv *env_id;\n+\/\/       jint num_frames;\n+\/\/       ASGCT_CallFrame *frames;\n+\/\/   } ASGCT_CallTrace;\n+\/\/\n+\/\/ Fields:\n+\/\/   env_id     - ID of thread which executed this trace.\n+\/\/   num_frames - number of frames in the trace.\n+\/\/                (< 0 indicates the frame is not walkable).\n+\/\/   frames     - the ASGCT_CallFrames that make up this trace. Callee followed by callers.\n+\/\/\n+\/\/  ASGCT_CallFrame:\n+\/\/    typedef struct {\n+\/\/        jint lineno;\n+\/\/        jmethodID method_id;\n+\/\/    } ASGCT_CallFrame;\n+\/\/\n+\/\/  Fields:\n+\/\/    1) For Java frame (interpreted and compiled),\n+\/\/       lineno    - bci of the method being executed or -1 if bci is not available\n+\/\/       method_id - jmethodID of the method being executed\n+\/\/    2) For native method\n+\/\/       lineno    - (-3)\n+\/\/       method_id - jmethodID of the method being executed\n+\n+extern \"C\" {\n+JNIEXPORT\n+void AsyncGetCallTrace(ASGCT_CallTrace *trace, jint depth, void* ucontext) {\n+  if (Thread::current_or_null_safe() == NULL) {\n+    \/\/ we need the current Thread object for crash protection\n+    trace->num_frames = ticks_thread_exit;\n+    return;\n+  }\n+  trace->num_frames = ticks_unknown_state;\n+  AsyncGetCallTraceCallBack cb(trace, depth, ucontext);\n+  os::ThreadCrashProtection crash_protection;\n+  if (!crash_protection.call(cb)) {\n+    if (trace->num_frames >= 0) {\n+      trace->num_frames = ticks_unknown_state;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":88,"deletions":57,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -338,1 +338,0 @@\n-  virtual bool is_JfrSampler_thread() const          { return false; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}