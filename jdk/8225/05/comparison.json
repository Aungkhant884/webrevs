{"files":[{"patch":"@@ -1153,1 +1153,0 @@\n-Thread* os::ThreadCrashProtection::_protected_thread = NULL;\n@@ -1155,0 +1154,2 @@\n+sigset_t os::ThreadCrashProtection::_saved_sig_mask;\n+\n@@ -1158,1 +1159,0 @@\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n@@ -1168,2 +1168,0 @@\n-  sigset_t saved_sig_mask;\n-\n@@ -1173,1 +1171,3 @@\n-  pthread_sigmask(0, NULL, &saved_sig_mask);\n+  if (_outer_protection == NULL) { \/\/ only for the outer most crash protection\n+    pthread_sigmask(0, NULL, &_saved_sig_mask);\n+  }\n@@ -1175,0 +1175,3 @@\n+    \/\/ store the currently active crash protection\n+    \/\/ this happens if crash protections are nested\n+    _outer_protection = _crash_protection;\n@@ -1179,3 +1182,2 @@\n-    \/\/ and clear the crash protection\n-    _crash_protection = NULL;\n-    _protected_thread = NULL;\n+    \/\/ and reset the crash protection\n+    _crash_protection = _outer_protection;\n@@ -1185,3 +1187,2 @@\n-  pthread_sigmask(SIG_SETMASK, &saved_sig_mask, NULL);\n-  _crash_protection = NULL;\n-  _protected_thread = NULL;\n+  pthread_sigmask(SIG_SETMASK, &_saved_sig_mask, NULL);\n+  _crash_protection = _outer_protection;\n@@ -1198,5 +1199,1 @@\n-\n-  if (thread != NULL &&\n-      thread == _protected_thread &&\n-      _crash_protection != NULL) {\n-\n+  if (thread != NULL && is_crash_protected(thread)) {\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n- * Crash protection for the JfrSampler thread. Wrap the callback\n- * with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n+ * Crash protection for the JfrSampler thread (but also used for AsyncGetCallTrace).\n+ * Wrap the callback with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n@@ -121,1 +121,1 @@\n-    return _crash_protection != NULL && _protected_thread == thr;\n+    return _crash_protection != NULL && _crash_protection->_protected_thread == thr;\n@@ -129,1 +129,1 @@\n-  static Thread* _protected_thread;\n+\n@@ -131,0 +131,2 @@\n+  ThreadCrashProtection* _outer_protection;\n+  Thread* _protected_thread;\n@@ -133,0 +135,1 @@\n+  static sigset_t _saved_sig_mask;\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5314,1 +5314,0 @@\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,2 +145,3 @@\n- * Crash protection for the JfrSampler thread. Wrap the callback\n- * with a __try { call() }\n+ * Crash protection for the JfrSampler thread (but also used for AsyncGetCallTrace).\n+ * Wrap the callback with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n+ * back.\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-  bool is_JfrSampler_thread() const { return true; }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -461,1 +461,0 @@\n-  NoHandleMark nhm;\n@@ -508,57 +507,1 @@\n-\/\/ Forte Analyzer AsyncGetCallTrace() entry point. Currently supported\n-\/\/ on Linux X86, Solaris SPARC and Solaris X86.\n-\/\/\n-\/\/ Async-safe version of GetCallTrace being called from a signal handler\n-\/\/ when a LWP gets interrupted by SIGPROF but the stack traces are filled\n-\/\/ with different content (see below).\n-\/\/\n-\/\/ This function must only be called when JVM\/TI\n-\/\/ CLASS_LOAD events have been enabled since agent startup. The enabled\n-\/\/ event will cause the jmethodIDs to be allocated at class load time.\n-\/\/ The jmethodIDs cannot be allocated in a signal handler because locks\n-\/\/ cannot be grabbed in a signal handler safely.\n-\/\/\n-\/\/ void (*AsyncGetCallTrace)(ASGCT_CallTrace *trace, jint depth, void* ucontext)\n-\/\/\n-\/\/ Called by the profiler to obtain the current method call stack trace for\n-\/\/ a given thread. The thread is identified by the env_id field in the\n-\/\/ ASGCT_CallTrace structure. The profiler agent should allocate a ASGCT_CallTrace\n-\/\/ structure with enough memory for the requested stack depth. The VM fills in\n-\/\/ the frames buffer and the num_frames field.\n-\/\/\n-\/\/ Arguments:\n-\/\/\n-\/\/   trace    - trace data structure to be filled by the VM.\n-\/\/   depth    - depth of the call stack trace.\n-\/\/   ucontext - ucontext_t of the LWP\n-\/\/\n-\/\/ ASGCT_CallTrace:\n-\/\/   typedef struct {\n-\/\/       JNIEnv *env_id;\n-\/\/       jint num_frames;\n-\/\/       ASGCT_CallFrame *frames;\n-\/\/   } ASGCT_CallTrace;\n-\/\/\n-\/\/ Fields:\n-\/\/   env_id     - ID of thread which executed this trace.\n-\/\/   num_frames - number of frames in the trace.\n-\/\/                (< 0 indicates the frame is not walkable).\n-\/\/   frames     - the ASGCT_CallFrames that make up this trace. Callee followed by callers.\n-\/\/\n-\/\/  ASGCT_CallFrame:\n-\/\/    typedef struct {\n-\/\/        jint lineno;\n-\/\/        jmethodID method_id;\n-\/\/    } ASGCT_CallFrame;\n-\/\/\n-\/\/  Fields:\n-\/\/    1) For Java frame (interpreted and compiled),\n-\/\/       lineno    - bci of the method being executed or -1 if bci is not available\n-\/\/       method_id - jmethodID of the method being executed\n-\/\/    2) For native method\n-\/\/       lineno    - (-3)\n-\/\/       method_id - jmethodID of the method being executed\n-\n-extern \"C\" {\n-JNIEXPORT\n-void AsyncGetCallTrace(ASGCT_CallTrace *trace, jint depth, void* ucontext) {\n+static void asyncGetCallTraceImpl(ASGCT_CallTrace *trace, jint depth, void* ucontext) {\n@@ -653,0 +596,88 @@\n+\/\/ Helps to wrap ASGCT in crash protection similar to JFR\n+class AsyncGetCallTraceCallBack : public os::CrashProtectionCallback {\n+public:\n+  AsyncGetCallTraceCallBack(ASGCT_CallTrace *trace, jint depth, void* ucontext) :\n+    _trace(trace), _depth(depth), _ucontext(ucontext) {\n+  }\n+  virtual void call() {\n+    asyncGetCallTraceImpl(_trace, _depth, _ucontext);\n+  }\n+ private:\n+  ASGCT_CallTrace* _trace;\n+  jint _depth;\n+  void* _ucontext;\n+};\n+\n+\/\/ Forte Analyzer AsyncGetCallTrace() entry point. Currently supported\n+\/\/ on Linux X86, Solaris SPARC and Solaris X86.\n+\/\/\n+\/\/ Async-safe version of GetCallTrace being called from a signal handler\n+\/\/ when a LWP gets interrupted by SIGPROF but the stack traces are filled\n+\/\/ with different content (see below).\n+\/\/\n+\/\/ This function must only be called when JVM\/TI\n+\/\/ CLASS_LOAD events have been enabled since agent startup. The enabled\n+\/\/ event will cause the jmethodIDs to be allocated at class load time.\n+\/\/ The jmethodIDs cannot be allocated in a signal handler because locks\n+\/\/ cannot be grabbed in a signal handler safely.\n+\/\/\n+\/\/ void (*AsyncGetCallTrace)(ASGCT_CallTrace *trace, jint depth, void* ucontext)\n+\/\/\n+\/\/ Called by the profiler to obtain the current method call stack trace for\n+\/\/ a given thread. The thread is identified by the env_id field in the\n+\/\/ ASGCT_CallTrace structure. The profiler agent should allocate a ASGCT_CallTrace\n+\/\/ structure with enough memory for the requested stack depth. The VM fills in\n+\/\/ the frames buffer and the num_frames field.\n+\/\/\n+\/\/ Arguments:\n+\/\/\n+\/\/   trace    - trace data structure to be filled by the VM.\n+\/\/   depth    - depth of the call stack trace.\n+\/\/   ucontext - ucontext_t of the LWP\n+\/\/\n+\/\/ ASGCT_CallTrace:\n+\/\/   typedef struct {\n+\/\/       JNIEnv *env_id;\n+\/\/       jint num_frames;\n+\/\/       ASGCT_CallFrame *frames;\n+\/\/   } ASGCT_CallTrace;\n+\/\/\n+\/\/ Fields:\n+\/\/   env_id     - ID of thread which executed this trace.\n+\/\/   num_frames - number of frames in the trace.\n+\/\/                (< 0 indicates the frame is not walkable).\n+\/\/   frames     - the ASGCT_CallFrames that make up this trace. Callee followed by callers.\n+\/\/\n+\/\/  ASGCT_CallFrame:\n+\/\/    typedef struct {\n+\/\/        jint lineno;\n+\/\/        jmethodID method_id;\n+\/\/    } ASGCT_CallFrame;\n+\/\/\n+\/\/  Fields:\n+\/\/    1) For Java frame (interpreted and compiled),\n+\/\/       lineno    - bci of the method being executed or -1 if bci is not available\n+\/\/       method_id - jmethodID of the method being executed\n+\/\/    2) For native method\n+\/\/       lineno    - (-3)\n+\/\/       method_id - jmethodID of the method being executed\n+\n+extern \"C\" {\n+JNIEXPORT\n+void AsyncGetCallTrace(ASGCT_CallTrace *trace, jint depth, void* ucontext) {\n+  NoHandleMark nhm;\n+  if (Thread::current_or_null_safe() == NULL) {\n+    \/\/ we need the current Thread object for crash protection\n+    trace->num_frames = ticks_thread_exit;\n+    return;\n+  }\n+  trace->num_frames = ticks_unknown_state;\n+  AsyncGetCallTraceCallBack cb(trace, depth, ucontext);\n+  os::ThreadCrashProtection crash_protection;\n+  if (!crash_protection.call(cb)) {\n+    if (trace->num_frames >= 0) {\n+      trace->num_frames = ticks_unknown_state;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":89,"deletions":58,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -338,1 +338,0 @@\n-  virtual bool is_JfrSampler_thread() const          { return false; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}