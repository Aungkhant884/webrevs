{"files":[{"patch":"@@ -144,1 +144,1 @@\n-\/\/ Return TRUE if the mask contains a single bit\n+\/\/ Return TRUE iff the mask contains a single bit\n@@ -147,1 +147,21 @@\n-  return Size() == 1;\n+\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t v = _RM_UP[i];\n+    if (v != 0) {\n+      \/\/ Only one bit allowed -> v must be a power of two\n+      if (!is_power_of_2(v)) {\n+        return false;\n+      }\n+\n+      \/\/ Check there are no other bits left\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n+      }\n+      \/\/ Done; found a single bit\n+      return true;\n+    }\n+  }\n+  \/\/ No bit found\n+  return false;\n@@ -153,1 +173,1 @@\n-  uintptr_t bit = all;               \/\/ Set to hold the one bit allowed\n+\n@@ -156,5 +176,5 @@\n-    if (_RM_UP[i]) {               \/\/ Found some bits\n-      if (bit != all) return false; \/\/ Already had bits, so fail\n-      bit = uintptr_t(1) << find_lowest_bit(_RM_UP[i]); \/\/ Extract lowest bit from mask\n-      if ((bit << 1U) != 0) {      \/\/ Bit pair stays in same word?\n-        if ((bit | (bit << 1U)) != _RM_UP[i])\n+    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n+      if (bit_index != _WordBitMask) {   \/\/ Bit pair stays in same word?\n+        uintptr_t bit = uintptr_t(1) << bit_index; \/\/ Extract lowest bit from mask\n+        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n@@ -162,0 +182,1 @@\n+        }\n@@ -163,1 +184,1 @@\n-        if (bit != _RM_UP[i]) return false; \/\/ Found many bits, so fail\n+        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n@@ -165,1 +186,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1)\n+        if (i > _hwm || _RM_UP[i] != 1) {\n@@ -167,0 +188,8 @@\n+        }\n+      }\n+\n+      \/\/ Check there are no other bits left\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n@@ -168,0 +197,2 @@\n+      \/\/ Found a bit pair\n+      return true;\n@@ -170,1 +201,1 @@\n-  \/\/ True for both the empty mask and for a bit pair\n+  \/\/ True for the empty mask, too\n@@ -306,1 +337,0 @@\n-  uintptr_t bit = all;         \/\/ Set to hold the one bit allowed\n@@ -308,3 +338,1 @@\n-    if (_RM_UP[i] ) {           \/\/ Found some bits\n-      if (bit != all)\n-        return false;           \/\/ Already had bits, so fail\n+    if (_RM_UP[i] != 0) {           \/\/ Found some bits\n@@ -312,3 +340,4 @@\n-      bit = uintptr_t(1) << bit_index;\n-      uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n-      if (hi_bit != 0) {        \/\/ Bit set stays in same word?\n+      uintptr_t bit = uintptr_t(1) << bit_index;\n+\n+      if (bit_index + size <= BitsPerWord) {   \/\/ Bit set stays in same word?\n+        uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n@@ -319,2 +348,4 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i])\n-          return false;         \/\/ Found many bits, so fail\n+        \/\/ Check that all bits between bit and the highest bit is set\n+        if ((all & ~(bit - 1)) != _RM_UP[i]) {\n+          return false;\n+        }\n@@ -322,3 +353,3 @@\n-        \/\/ The lower (BitsPerWord - size) bits should be 1 since it is split case.\n-        uintptr_t set = (bit >> (BitsPerWord - bit_index)) - 1;\n-        if (i > _hwm || _RM_UP[i] != set)\n+        \/\/ The lower bits should be 1 since it is split case.\n+        uintptr_t set = (bit >> (BitsPerWord - size)) - 1;\n+        if (i > _hwm || _RM_UP[i] != set) {\n@@ -326,0 +357,8 @@\n+        }\n+      }\n+\n+      \/\/ Check there are no other bits left\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n@@ -327,0 +366,2 @@\n+      \/\/ Done - found a bit set\n+      return true;\n@@ -329,1 +370,1 @@\n-  \/\/ True for both the empty mask and for a bit set\n+  \/\/ True for the empty mask, too\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":65,"deletions":24,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/opcodes.hpp\"\n@@ -149,1 +150,2 @@\n-    ASSERT_TRUE(rm.is_bound1());\n+    ASSERT_TRUE(rm.is_bound1())       << \"Index \" << i;\n+    ASSERT_TRUE(rm.is_bound(Op_RegI)) << \"Index \" << i;\n@@ -157,0 +159,41 @@\n+\n+TEST_VM(RegMask, is_bound_pair) {\n+  RegMask rm;\n+  ASSERT_TRUE(rm.is_bound_pair());\n+  for (int i = 0; i < RegMask::CHUNK_SIZE - 2; i++) {\n+    rm.Insert(i);\n+    rm.Insert(i + 1);\n+    ASSERT_TRUE(rm.is_bound_pair())   << \"Index \" << i;\n+    ASSERT_TRUE(rm.is_bound_set(2))   << \"Index \" << i;\n+    ASSERT_TRUE(rm.is_bound(Op_RegI)) << \"Index \" << i;\n+    contains_expected_num_of_registers(rm, 2);\n+    rm.Clear();\n+  }\n+  \/\/ A pair with the AllStack bit does not count as a bound pair\n+  rm.Clear();\n+  rm.Insert(RegMask::CHUNK_SIZE - 2);\n+  rm.Insert(RegMask::CHUNK_SIZE - 1);\n+  ASSERT_FALSE(rm.is_bound_pair());\n+}\n+\n+TEST_VM(RegMask, is_bound_set) {\n+  RegMask rm;\n+  for (int size = 1; size <= 16; size++) {\n+    rm.Clear();\n+    ASSERT_TRUE(rm.is_bound_set(size));\n+    for (int i = 0; i < RegMask::CHUNK_SIZE - size; i++) {\n+      for (int j = i; j < i + size; j++) {\n+        rm.Insert(j);\n+      }\n+      ASSERT_TRUE(rm.is_bound_set(size))   << \"Size \" << size << \" Index \" << i;\n+      contains_expected_num_of_registers(rm, size);\n+      rm.Clear();\n+    }\n+    \/\/ A set with the AllStack bit does not count as a bound set\n+    rm.Clear();\n+    for (int j = RegMask::CHUNK_SIZE - size; j < RegMask::CHUNK_SIZE; j++) {\n+        rm.Insert(j);\n+    }\n+    ASSERT_FALSE(rm.is_bound_set(size));\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"}]}