{"files":[{"patch":"@@ -144,1 +144,1 @@\n-\/\/ Return TRUE iff the mask contains a single bit\n+\/\/ Return TRUE if the mask contains a single bit\n@@ -147,21 +147,1 @@\n-\n-  for (unsigned i = _lwm; i <= _hwm; i++) {\n-    uintptr_t v = _RM_UP[i];\n-    if (v != 0) {\n-      \/\/ Only one bit allowed -> v must be a power of two\n-      if (!is_power_of_2(v)) {\n-        return false;\n-      }\n-\n-      \/\/ Check there are no other bits left\n-      for (i++; i <= _hwm; i++) {\n-        if (_RM_UP[i] != 0) {\n-          return false;\n-        }\n-      }\n-      \/\/ Done; found a single bit\n-      return true;\n-    }\n-  }\n-  \/\/ No bit found\n-  return false;\n+  return Size() == 1;\n@@ -173,1 +153,1 @@\n-\n+  uintptr_t bit = all;               \/\/ Set to hold the one bit allowed\n@@ -176,5 +156,5 @@\n-    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n-      if (bit_index != _WordBitMask) {   \/\/ Bit pair stays in same word?\n-        uintptr_t bit = uintptr_t(1) << bit_index; \/\/ Extract lowest bit from mask\n-        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n+    if (_RM_UP[i]) {               \/\/ Found some bits\n+      if (bit != all) return false; \/\/ Already had bits, so fail\n+      bit = uintptr_t(1) << find_lowest_bit(_RM_UP[i]); \/\/ Extract lowest bit from mask\n+      if ((bit << 1U) != 0) {      \/\/ Bit pair stays in same word?\n+        if ((bit | (bit << 1U)) != _RM_UP[i])\n@@ -182,1 +162,0 @@\n-        }\n@@ -184,1 +163,1 @@\n-        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n+        if (bit != _RM_UP[i]) return false; \/\/ Found many bits, so fail\n@@ -186,1 +165,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1) {\n+        if (i > _hwm || _RM_UP[i] != 1)\n@@ -188,8 +167,0 @@\n-        }\n-      }\n-\n-      \/\/ Check there are no other bits left\n-      for (i++; i <= _hwm; i++) {\n-        if (_RM_UP[i] != 0) {\n-          return false;\n-        }\n@@ -197,2 +168,0 @@\n-      \/\/ Found a bit pair\n-      return true;\n@@ -201,1 +170,1 @@\n-  \/\/ True for the empty mask, too\n+  \/\/ True for both the empty mask and for a bit pair\n@@ -337,0 +306,1 @@\n+  uintptr_t bit = all;         \/\/ Set to hold the one bit allowed\n@@ -338,1 +308,3 @@\n-    if (_RM_UP[i] != 0) {           \/\/ Found some bits\n+    if (_RM_UP[i] ) {           \/\/ Found some bits\n+      if (bit != all)\n+        return false;           \/\/ Already had bits, so fail\n@@ -340,4 +312,3 @@\n-      uintptr_t bit = uintptr_t(1) << bit_index;\n-\n-      if (bit_index + size <= BitsPerWord) {   \/\/ Bit set stays in same word?\n-        uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n+      bit = uintptr_t(1) << bit_index;\n+      uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n+      if (hi_bit != 0) {        \/\/ Bit set stays in same word?\n@@ -348,4 +319,2 @@\n-        \/\/ Check that all bits between bit and the highest bit is set\n-        if ((all & ~(bit - 1)) != _RM_UP[i]) {\n-          return false;\n-        }\n+        if ((all & ~(bit-1)) != _RM_UP[i])\n+          return false;         \/\/ Found many bits, so fail\n@@ -355,1 +324,1 @@\n-        if (i > _hwm || _RM_UP[i] != set) {\n+        if (i > _hwm || _RM_UP[i] != set)\n@@ -357,8 +326,0 @@\n-        }\n-      }\n-\n-      \/\/ Check there are no other bits left\n-      for (i++; i <= _hwm; i++) {\n-        if (_RM_UP[i] != 0) {\n-          return false;\n-        }\n@@ -366,2 +327,0 @@\n-      \/\/ Done - found a bit set\n-      return true;\n@@ -370,1 +329,1 @@\n-  \/\/ True for the empty mask, too\n+  \/\/ True for both the empty mask and for a bit set\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":22,"deletions":63,"binary":false,"changes":85,"status":"modified"}]}