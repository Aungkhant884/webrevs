{"files":[{"patch":"@@ -1298,1 +1298,25 @@\n- bool is_CAS(int opcode, bool maybe_volatile);\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline uint vector_length(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length();\n+  }\n+\n+  static inline uint vector_length(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length();\n+  }\n+\n+  bool is_CAS(int opcode, bool maybe_volatile);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -5299,0 +5299,169 @@\n+\n+\/\/ vector mask reductions\n+\n+instruct vmask_truecount8B(iRegINoSp dst, vecD src, vecD tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount16B(iRegINoSp dst, vecX src, vecX tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_LT8B(iRegINoSp dst, vecD src, rFlagsReg cr) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  ins_cost(7 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (4I\/4S\/2I)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() == 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(6 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label FIRST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, zr);\n+    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8);\n+\n+    \/\/ Reverse the bits and count the leading zero bytes.\n+    __ bind(FIRST_TRUE_INDEX);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ movw(rscratch1, 7);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label LAST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 16 - 1);\n+    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8 - 1);\n+\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n+    __ bind(LAST_TRUE_INDEX);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2246,0 +2246,148 @@\n+dnl\n+dnl VMASK_TRUECOUNT($1,     $2 )\n+dnl VMASK_TRUECOUNT(suffix, reg)\n+define(`VMASK_TRUECOUNT', `\n+instruct vmask_truecount$1(iRegINoSp dst, $2 src, $2 tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector ($1)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T$1, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`ARGLIST',\n+`ifelse($1, `_LT8B', `iRegINoSp dst, vecD src, rFlagsReg cr', `iRegINoSp dst, vecD src')')\n+dnl\n+dnl VMASK_FIRSTTRUE_D($1,     $2,   $3,   $4  )\n+dnl VMASK_FIRSTTRUE_D(suffix, cond, cost, size)\n+define(`VMASK_FIRSTTRUE_D', `\n+instruct vmask_firsttrue$1(ARGLIST($1)) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() $2 8);\n+  match(Set dst (VectorMaskFirstTrue src));dnl\n+ifelse($1, `_LT8B', `\n+  effect(KILL cr);')\n+  ins_cost($3 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector ($4)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);dnl\n+ifelse(`$1', `_LT8B', `\n+    __ movw(rscratch1, vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+undefine(ARGLIST)dnl\n+dnl\n+\/\/ vector mask reductions\n+VMASK_TRUECOUNT(8B,  vecD)\n+VMASK_TRUECOUNT(16B, vecX)\n+VMASK_FIRSTTRUE_D(_LT8B, <,  7, 4I\/4S\/2I)\n+VMASK_FIRSTTRUE_D(8B,    ==, 4, 8B)\n+\n+instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(6 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label FIRST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, zr);\n+    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8);\n+\n+    \/\/ Reverse the bits and count the leading zero bytes.\n+    __ bind(FIRST_TRUE_INDEX);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ movw(rscratch1, 7);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label LAST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 16 - 1);\n+    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8 - 1);\n+\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n+    __ bind(LAST_TRUE_INDEX);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -90,12 +90,0 @@\n-  static inline BasicType vector_element_basic_type(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n@@ -206,0 +194,3 @@\n+      case Op_VectorMaskTrueCount:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskFirstTrue:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -77,12 +77,0 @@\n-  static inline BasicType vector_element_basic_type(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n@@ -193,0 +181,3 @@\n+      case Op_VectorMaskTrueCount:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskFirstTrue:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2037,1 +2037,1 @@\n-  \/\/ INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n+  INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1536,0 +1536,1 @@\n+                        [\"fmov\",   \"__ fmovhid(r0, v1);\",                                \"fmov\\tx0, v1.d[1]\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -726,0 +726,1 @@\n+    __ fmovhid(r0, v1);                                \/\/       fmov    x0, v1.d[1]\n@@ -981,7 +982,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400030c,     0x94000000,\n-    0x97ffffd4,     0x94000309,     0x3400000a,     0x34fffa2a,\n-    0x340060ca,     0x35000008,     0x35fff9c8,     0x35006068,\n-    0xb400000b,     0xb4fff96b,     0xb400600b,     0xb500001d,\n-    0xb5fff91d,     0xb5005fbd,     0x10000013,     0x10fff8b3,\n-    0x10005f53,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36305ed6,     0x3758000c,     0x375ff7cc,     0x37585e6c,\n+    0x14000000,     0x17ffffd7,     0x1400030d,     0x94000000,\n+    0x97ffffd4,     0x9400030a,     0x3400000a,     0x34fffa2a,\n+    0x340060ea,     0x35000008,     0x35fff9c8,     0x35006088,\n+    0xb400000b,     0xb4fff96b,     0xb400602b,     0xb500001d,\n+    0xb5fff91d,     0xb5005fdd,     0x10000013,     0x10fff8b3,\n+    0x10005f73,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305ef6,     0x3758000c,     0x375ff7cc,     0x37585e8c,\n@@ -992,13 +993,13 @@\n-    0x54005c40,     0x54000001,     0x54fff541,     0x54005be1,\n-    0x54000002,     0x54fff4e2,     0x54005b82,     0x54000002,\n-    0x54fff482,     0x54005b22,     0x54000003,     0x54fff423,\n-    0x54005ac3,     0x54000003,     0x54fff3c3,     0x54005a63,\n-    0x54000004,     0x54fff364,     0x54005a04,     0x54000005,\n-    0x54fff305,     0x540059a5,     0x54000006,     0x54fff2a6,\n-    0x54005946,     0x54000007,     0x54fff247,     0x540058e7,\n-    0x54000008,     0x54fff1e8,     0x54005888,     0x54000009,\n-    0x54fff189,     0x54005829,     0x5400000a,     0x54fff12a,\n-    0x540057ca,     0x5400000b,     0x54fff0cb,     0x5400576b,\n-    0x5400000c,     0x54fff06c,     0x5400570c,     0x5400000d,\n-    0x54fff00d,     0x540056ad,     0x5400000e,     0x54ffefae,\n-    0x5400564e,     0x5400000f,     0x54ffef4f,     0x540055ef,\n+    0x54005c60,     0x54000001,     0x54fff541,     0x54005c01,\n+    0x54000002,     0x54fff4e2,     0x54005ba2,     0x54000002,\n+    0x54fff482,     0x54005b42,     0x54000003,     0x54fff423,\n+    0x54005ae3,     0x54000003,     0x54fff3c3,     0x54005a83,\n+    0x54000004,     0x54fff364,     0x54005a24,     0x54000005,\n+    0x54fff305,     0x540059c5,     0x54000006,     0x54fff2a6,\n+    0x54005966,     0x54000007,     0x54fff247,     0x54005907,\n+    0x54000008,     0x54fff1e8,     0x540058a8,     0x54000009,\n+    0x54fff189,     0x54005849,     0x5400000a,     0x54fff12a,\n+    0x540057ea,     0x5400000b,     0x54fff0cb,     0x5400578b,\n+    0x5400000c,     0x54fff06c,     0x5400572c,     0x5400000d,\n+    0x54fff00d,     0x540056cd,     0x5400000e,     0x54ffefae,\n+    0x5400566e,     0x5400000f,     0x54ffef4f,     0x5400560f,\n@@ -1036,1 +1037,1 @@\n-    0xbd1b1869,     0x5800463b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800465b,     0x1800000b,     0xf8945060,\n@@ -1123,54 +1124,54 @@\n-    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x4cc0ac3f,\n-    0x05a08020,     0x04b0e3e0,     0x0470e7e1,     0x042f9c20,\n-    0x043f9c35,     0x047f9c20,     0x04ff9c20,     0x04299420,\n-    0x04319160,     0x0461943e,     0x04a19020,     0x042053ff,\n-    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n-    0x25b8efe2,     0x25f8f007,     0x05203864,     0x05603ace,\n-    0xa400a3e0,     0xa4a8a7ea,     0xa547a814,     0xa4084ffe,\n-    0xa55c53e0,     0xa5e1540b,     0xe400fbf6,     0xe408ffff,\n-    0xe547e400,     0xe4014be0,     0xe4a84fe0,     0xe5f15000,\n-    0x858043e0,     0x85a043ff,     0xe59f5d08,     0x0420e3e9,\n-    0x0460e3ea,     0x04a0e3eb,     0x04e0e3ec,     0x25104042,\n-    0x25104871,     0x252c8840,     0x253c1420,     0x25681572,\n-    0x25a21ce3,     0x25ea1e34,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf8208193,     0xf83101b6,\n-    0xf83c13fe,     0xf821239a,     0xf824309e,     0xf826535e,\n-    0xf8304109,     0xf82c7280,     0xf8216058,     0xf8a08309,\n-    0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,\n-    0xf8aa522f,     0xf8a2418a,     0xf8ac71af,     0xf8a26287,\n-    0xf8fa8090,     0xf8e20184,     0xf8f01215,     0xf8f022ab,\n-    0xf8f7334c,     0xf8f751dc,     0xf8eb4038,     0xf8ec715f,\n-    0xf8f06047,     0xf863826d,     0xf8710070,     0xf86113cb,\n-    0xf86521e8,     0xf87d301e,     0xf8745287,     0xf87742bc,\n-    0xf87b70b9,     0xf8616217,     0xb83f8185,     0xb82901fc,\n-    0xb83d13f6,     0xb83320bf,     0xb82e33f0,     0xb830529b,\n-    0xb830416c,     0xb82973c6,     0xb831639b,     0xb8be8147,\n-    0xb8b4008a,     0xb8b81231,     0xb8b623a3,     0xb8af3276,\n-    0xb8b35056,     0xb8af4186,     0xb8b071ab,     0xb8b763c1,\n-    0xb8f38225,     0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,\n-    0xb8fb3023,     0xb8ff5278,     0xb8f14389,     0xb8fb70ef,\n-    0xb8f563f7,     0xb87983e2,     0xb87b0150,     0xb8771073,\n-    0xb8702320,     0xb87a3057,     0xb870508c,     0xb87c43be,\n-    0xb87070db,     0xb86961fd,     0xce273c87,     0xce080ac9,\n-    0xce7e8e9b,     0xce808b45,     0xce79806e,     0xce758768,\n-    0xcec0835a,     0xce608ad8,     0x043100c4,     0x046105e3,\n-    0x65c900a6,     0x65d60a87,     0x65c80545,     0x0416a63e,\n-    0x04001f8b,     0x0450979a,     0x04dabe0d,     0x045381a5,\n-    0x04918b4f,     0x049006cb,     0x0497a264,     0x045eadd1,\n-    0x04881062,     0x040a04d7,     0x04810f71,     0x04dca450,\n-    0x65c084c3,     0x65cd8d93,     0x65c69a68,     0x65878ae0,\n-    0x65c29db3,     0x049da0e6,     0x6582b911,     0x65c0b6d6,\n-    0x65c1a1e2,     0x65cda494,     0x65c18107,     0x65af1493,\n-    0x65e52b36,     0x65ab4ed0,     0x65f06a8d,     0x0451448f,\n-    0x049c7c86,     0x0429335d,     0x04bc3162,     0x047a3027,\n-    0x04e831d1,     0x2493b8a5,     0x249d9604,     0x24d18095,\n-    0x24d7b491,     0x045a2113,     0x04d83a2e,     0x041927d5,\n-    0x0408358a,     0x048a2709,     0x658738c4,     0x65c639bb,\n-    0x65d836de,     0x04413d3e,\n+    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x9eae0020,\n+    0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,     0x0470e7e1,\n+    0x042f9c20,     0x043f9c35,     0x047f9c20,     0x04ff9c20,\n+    0x04299420,     0x04319160,     0x0461943e,     0x04a19020,\n+    0x042053ff,     0x047f5401,     0x25208028,     0x2538cfe0,\n+    0x2578d001,     0x25b8efe2,     0x25f8f007,     0x05203864,\n+    0x05603ace,     0xa400a3e0,     0xa4a8a7ea,     0xa547a814,\n+    0xa4084ffe,     0xa55c53e0,     0xa5e1540b,     0xe400fbf6,\n+    0xe408ffff,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0xe5f15000,     0x858043e0,     0x85a043ff,     0xe59f5d08,\n+    0x0420e3e9,     0x0460e3ea,     0x04a0e3eb,     0x04e0e3ec,\n+    0x25104042,     0x25104871,     0x252c8840,     0x253c1420,\n+    0x25681572,     0x25a21ce3,     0x25ea1e34,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8208193,\n+    0xf83101b6,     0xf83c13fe,     0xf821239a,     0xf824309e,\n+    0xf826535e,     0xf8304109,     0xf82c7280,     0xf8216058,\n+    0xf8a08309,     0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,\n+    0xf8a2310b,     0xf8aa522f,     0xf8a2418a,     0xf8ac71af,\n+    0xf8a26287,     0xf8fa8090,     0xf8e20184,     0xf8f01215,\n+    0xf8f022ab,     0xf8f7334c,     0xf8f751dc,     0xf8eb4038,\n+    0xf8ec715f,     0xf8f06047,     0xf863826d,     0xf8710070,\n+    0xf86113cb,     0xf86521e8,     0xf87d301e,     0xf8745287,\n+    0xf87742bc,     0xf87b70b9,     0xf8616217,     0xb83f8185,\n+    0xb82901fc,     0xb83d13f6,     0xb83320bf,     0xb82e33f0,\n+    0xb830529b,     0xb830416c,     0xb82973c6,     0xb831639b,\n+    0xb8be8147,     0xb8b4008a,     0xb8b81231,     0xb8b623a3,\n+    0xb8af3276,     0xb8b35056,     0xb8af4186,     0xb8b071ab,\n+    0xb8b763c1,     0xb8f38225,     0xb8e202d0,     0xb8ed12aa,\n+    0xb8fd219b,     0xb8fb3023,     0xb8ff5278,     0xb8f14389,\n+    0xb8fb70ef,     0xb8f563f7,     0xb87983e2,     0xb87b0150,\n+    0xb8771073,     0xb8702320,     0xb87a3057,     0xb870508c,\n+    0xb87c43be,     0xb87070db,     0xb86961fd,     0xce273c87,\n+    0xce080ac9,     0xce7e8e9b,     0xce808b45,     0xce79806e,\n+    0xce758768,     0xcec0835a,     0xce608ad8,     0x043100c4,\n+    0x046105e3,     0x65c900a6,     0x65d60a87,     0x65c80545,\n+    0x0416a63e,     0x04001f8b,     0x0450979a,     0x04dabe0d,\n+    0x045381a5,     0x04918b4f,     0x049006cb,     0x0497a264,\n+    0x045eadd1,     0x04881062,     0x040a04d7,     0x04810f71,\n+    0x04dca450,     0x65c084c3,     0x65cd8d93,     0x65c69a68,\n+    0x65878ae0,     0x65c29db3,     0x049da0e6,     0x6582b911,\n+    0x65c0b6d6,     0x65c1a1e2,     0x65cda494,     0x65c18107,\n+    0x65af1493,     0x65e52b36,     0x65ab4ed0,     0x65f06a8d,\n+    0x0451448f,     0x049c7c86,     0x0429335d,     0x04bc3162,\n+    0x047a3027,     0x04e831d1,     0x2493b8a5,     0x249d9604,\n+    0x24d18095,     0x24d7b491,     0x045a2113,     0x04d83a2e,\n+    0x041927d5,     0x0408358a,     0x048a2709,     0x658738c4,\n+    0x65c639bb,     0x65d836de,     0x04413d3e,\n@@ -1179,0 +1180,1 @@\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":77,"deletions":75,"binary":false,"changes":152,"status":"modified"}]}