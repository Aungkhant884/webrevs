{"files":[{"patch":"@@ -5310,1 +5310,2 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n@@ -5325,1 +5326,2 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n@@ -5340,3 +5342,8 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n-    \/\/ Reverse the bits and count the leading zero bytes. Get the maximum\n-    \/\/ value between the vector length and the leading zero bytes.\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n@@ -5361,2 +5368,8 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n-    \/\/ Reverse the bits and count the leading zero bytes.\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 8 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n@@ -5377,1 +5390,5 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n@@ -5381,2 +5398,1 @@\n-    \/\/ Move the lower 64-bits to a general register and check whether the\n-    \/\/ value is zero.\n+    \/\/ Try to compute the result from lower 64 bits.\n@@ -5387,2 +5403,1 @@\n-    \/\/ If the lower half part is zero, compute the result from the higher\n-    \/\/ 64-bits.\n+    \/\/ Compute the result from the higher 64 bits.\n@@ -5392,1 +5407,1 @@\n-    \/\/ Reverse the bits, count the leading zero bytes and add it with 8\/0.\n+    \/\/ Reverse the bits and count the leading zero bytes.\n@@ -5407,2 +5422,8 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n-    \/\/ Count the leading zero bytes and substract it by 7.\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n@@ -5423,1 +5444,5 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n@@ -5427,2 +5452,1 @@\n-    \/\/ Move the higher 64-bits to a general register and check whether the\n-    \/\/ value is zero.\n+    \/\/ Try to compute the result from higher 64 bits.\n@@ -5433,2 +5457,1 @@\n-    \/\/ If the higher half part value is zero, compute the result from the\n-    \/\/ lower 64-bits.\n+    \/\/ Compute the result from the lower 64 bits.\n@@ -5438,1 +5461,1 @@\n-    \/\/ Count the leading zero bytes and substract it by the 15\/7.\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":44,"deletions":21,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2257,1 +2257,2 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n@@ -2277,3 +2278,8 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n-    \/\/ Reverse the bits and count the leading zero bytes. Get the maximum\n-    \/\/ value between the vector length and the leading zero bytes.\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n@@ -2298,2 +2304,8 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n-    \/\/ Reverse the bits and count the leading zero bytes.\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 8 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n@@ -2314,1 +2326,5 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n@@ -2318,2 +2334,1 @@\n-    \/\/ Move the lower 64-bits to a general register and check whether the\n-    \/\/ value is zero.\n+    \/\/ Try to compute the result from lower 64 bits.\n@@ -2324,2 +2339,1 @@\n-    \/\/ If the lower half part is zero, compute the result from the higher\n-    \/\/ 64-bits.\n+    \/\/ Compute the result from the higher 64 bits.\n@@ -2329,1 +2343,1 @@\n-    \/\/ Reverse the bits, count the leading zero bytes and add it with 8\/0.\n+    \/\/ Reverse the bits and count the leading zero bytes.\n@@ -2344,2 +2358,8 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n-    \/\/ Count the leading zero bytes and substract it by 7.\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n@@ -2360,1 +2380,5 @@\n-    \/\/ Input \"src\" is a vector of boolean with \"0\/1\" as the element values.\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n@@ -2364,2 +2388,1 @@\n-    \/\/ Move the higher 64-bits to a general register and check whether the\n-    \/\/ value is zero.\n+    \/\/ Try to compute the result from higher 64 bits.\n@@ -2370,2 +2393,1 @@\n-    \/\/ If the higher half part value is zero, compute the result from the\n-    \/\/ lower 64-bits.\n+    \/\/ Compute the result from the lower 64 bits.\n@@ -2375,1 +2397,1 @@\n-    \/\/ Count the leading zero bytes and substract it by the 15\/7.\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":42,"deletions":20,"binary":false,"changes":62,"status":"modified"}]}