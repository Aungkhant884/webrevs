{"files":[{"patch":"@@ -5992,8 +5992,1 @@\n-  tty->cr();\n-  tty->print_cr(\"idoms of early %d:\", early->_idx);\n-  dump_idom(early);\n-  tty->cr();\n-  tty->print_cr(\"idoms of (wrong) LCA %d:\", LCA->_idx);\n-  dump_idom(LCA);\n-  tty->cr();\n-  dump_real_LCA(early, LCA);\n+  dump_idoms(early, LCA);\n@@ -6003,31 +5996,13 @@\n-\/\/ Find the real LCA of early and the wrongly assumed LCA.\n-void PhaseIdealLoop::dump_real_LCA(Node* early, Node* wrong_lca) {\n-  assert(!is_dominator(early, wrong_lca) && !is_dominator(early, wrong_lca),\n-         \"sanity check that one node does not dominate the other\");\n-  assert(!has_ctrl(early) && !has_ctrl(wrong_lca), \"sanity check, no data nodes\");\n-\n-  ResourceMark rm;\n-  Node_List nodes_seen;\n-  Node* real_LCA = NULL;\n-  Node* n1 = wrong_lca;\n-  Node* n2 = early;\n-  uint count_1 = 0;\n-  uint count_2 = 0;\n-  \/\/ Add early and wrong_lca to simplify calculation of idom indices\n-  nodes_seen.push(n1);\n-  nodes_seen.push(n2);\n-\n-  \/\/ Walk the idom chain up from early and wrong_lca and stop when they intersect.\n-  while (!n1->is_Start() && !n2->is_Start()) {\n-    n1 = idom(n1);\n-    n2 = idom(n2);\n-    if (n1 == n2) {\n-      \/\/ Both idom chains intersect at the same index\n-      real_LCA = n1;\n-      count_1 = nodes_seen.size() \/ 2;\n-      count_2 = count_1;\n-      break;\n-    }\n-    if (check_idom_chains_intersection(n1, count_1, count_2, &nodes_seen)) {\n-      real_LCA = n1;\n-      break;\n+\/\/ Class to compute the real LCA given an early node and a wrong LCA in a bad graph.\n+class RealLCA {\n+  const PhaseIdealLoop* _phase;\n+  Node* _early;\n+  Node* _wrong_lca;\n+  int _early_index;\n+  int _wrong_lca_index;\n+\n+  static uint find_idom_index(const Node* n, const Unique_Node_List& idoms) {\n+    for (uint i = 0; i < idoms.size(); i++) {\n+      if (idoms[i] == n) {\n+        return i;\n+      }\n@@ -6035,3 +6010,15 @@\n-    if (check_idom_chains_intersection(n2, count_2, count_1, &nodes_seen)) {\n-      real_LCA = n2;\n-      break;\n+    assert(false, \"must find index\");\n+    return 0;\n+  }\n+\n+  Node* find_real_lca(Unique_Node_List& early_idoms) {\n+    Node* next = _wrong_lca;\n+    while (!next->is_Start()) {\n+      if (next == _early) {\n+        return next;\n+      } else if (early_idoms.member(next)) {\n+        _early_index = find_idom_index(next, early_idoms);\n+        return next;\n+      }\n+      next = _phase->idom(next);\n+      _wrong_lca_index++;\n@@ -6039,2 +6026,2 @@\n-    nodes_seen.push(n1);\n-    nodes_seen.push(n2);\n+    assert(false, \"must always find an LCA\");\n+    return nullptr;\n@@ -6043,4 +6030,4 @@\n-  assert(real_LCA != NULL, \"must always find an LCA\");\n-  tty->print_cr(\"Real LCA of early %d (idom[%d]) and (wrong) LCA %d (idom[%d]):\", early->_idx, count_2, wrong_lca->_idx, count_1);\n-  real_LCA->dump();\n-}\n+  void dump(Node* real_lca) {\n+    tty->cr();\n+    tty->print_cr(\"idoms of early \\\"%d %s\\\":\", _early->_idx, _early->Name());\n+    _phase->dump_idom(_early, _early_index + 1);\n@@ -6048,14 +6035,9 @@\n-\/\/ Check if n is already on nodes_seen (i.e. idom chains of early and wrong_lca intersect at n). Determine the idom index of n\n-\/\/ on both idom chains and return them in idom_idx_new and idom_idx_other, respectively.\n-bool PhaseIdealLoop::check_idom_chains_intersection(const Node* n, uint& idom_idx_new, uint& idom_idx_other, const Node_List* nodes_seen) const {\n-  if (nodes_seen->contains(n)) {\n-    \/\/ The idom chain has just discovered n.\n-    \/\/ Divide by 2 because nodes_seen contains the same amount of nodes from both chains.\n-    idom_idx_new = nodes_seen->size() \/ 2;\n-\n-    \/\/ The other chain already contained n. Search the index.\n-    for (uint i = 0; i < nodes_seen->size(); i++) {\n-      if (nodes_seen->at(i) == n) {\n-        \/\/ Divide by 2 because nodes_seen contains the same amount of nodes from both chains.\n-        idom_idx_other = i \/ 2;\n-      }\n+    tty->cr();\n+    tty->print_cr(\"idoms of (wrong) LCA \\\"%d %s\\\":\", _wrong_lca->_idx, _wrong_lca->Name());\n+    _phase->dump_idom(_wrong_lca, _wrong_lca_index + 1);\n+\n+    tty->cr();\n+    tty->print(\"Real LCA of early \\\"%d %s\\\" (idom[%d]) and wrong LCA \\\"%d %s\\\"\",\n+               _early->_idx, _early->Name(), _early_index, _wrong_lca->_idx, _wrong_lca->Name());\n+    if (_wrong_lca_index >= 0) {\n+      tty->print(\" (idom[%d])\", _wrong_lca_index);\n@@ -6063,1 +6045,2 @@\n-    return true;\n+    tty->print_cr(\":\");\n+    real_lca->dump();\n@@ -6065,1 +6048,23 @@\n-  return false;\n+\n+ public:\n+  RealLCA(const PhaseIdealLoop* phase, Node* early, Node* wrong_lca)\n+      : _phase(phase), _early(early), _wrong_lca(wrong_lca), _early_index(-1), _wrong_lca_index(-1) {\n+    assert(!wrong_lca->is_Start(), \"StartNode is always a common dominator\");\n+  }\n+\n+  void compute_and_dump() {\n+    ResourceMark rm;\n+    Unique_Node_List early_idoms;\n+    _phase->get_idoms(_early, 1000, early_idoms);\n+    Node* real_lca = find_real_lca(early_idoms);\n+    dump(real_lca);\n+  }\n+};\n+\n+\/\/ Dump the idom chain of early, of the wrong LCA and dump the real LCA of early and wrong LCA.\n+void PhaseIdealLoop::dump_idoms(Node* early, Node* wrong_lca) {\n+  assert(!is_dominator(early, wrong_lca), \"sanity check that early does not dominate wrong lca\");\n+  assert(!has_ctrl(early) && !has_ctrl(wrong_lca), \"sanity check, no data nodes\");\n+\n+  RealLCA real_lca(this, early, wrong_lca);\n+  real_lca.compute_and_dump();\n@@ -6138,1 +6143,1 @@\n-void PhaseIdealLoop::dump_idom(Node* n) const {\n+void PhaseIdealLoop::dump_idom(Node* n, const uint count) const {\n@@ -6142,4 +6147,23 @@\n-    for (int i = 0; i < 100 && !n->is_Start(); i++) {\n-      tty->print(\"idom[%d] \", i);\n-      n->dump();\n-      n = idom(n);\n+    ResourceMark rm;\n+    Unique_Node_List idoms;\n+    get_idoms(n, count, idoms);\n+    dump_idoms_in_reverse(n, idoms);\n+  }\n+}\n+\n+void PhaseIdealLoop::get_idoms(Node* n, const uint count, Unique_Node_List& idoms) const {\n+  Node* next = n;\n+  for (uint i = 0; !next->is_Start() && i < count; i++) {\n+    next = idom(next);\n+    assert(!idoms.member(n), \"duplicated idom is not possible\");\n+    idoms.push(next);\n+  }\n+}\n+\n+void PhaseIdealLoop::dump_idoms_in_reverse(const Node* n, const Node_List& idom_list) const {\n+  Node* next;\n+  uint padding = 3;\n+  uint node_index_padding_width = static_cast<int>(log10(C->unique())) + 1;\n+  for (int i = idom_list.size() - 1; i >= 0; i--) {\n+    if (i == 9 || i == 99) {\n+      padding++;\n@@ -6147,0 +6171,2 @@\n+    next = idom_list[i];\n+    tty->print_cr(\"idom[%d]:%*c%*d  %s\", i, padding, ' ', node_index_padding_width, next->_idx, next->Name());\n@@ -6148,0 +6174,1 @@\n+  tty->print_cr(\"n:      %*c%*d  %s\", padding, ' ', node_index_padding_width, n->_idx, n->Name());\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":96,"deletions":69,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -1660,2 +1660,2 @@\n-  void dump_real_LCA(Node* early, Node* wrong_lca);\n-  bool check_idom_chains_intersection(const Node* n, uint& idom_idx_new, uint& idom_idx_other, const Node_List* nodes_seen) const;\n+  void dump_idoms(Node* early, Node* wrong_lca);\n+  void dump_idoms_in_reverse(const Node* n, const Node_List& idom_list) const;\n@@ -1671,0 +1671,1 @@\n+  void get_idoms(Node* n, uint count, Unique_Node_List& idoms) const;\n@@ -1675,1 +1676,2 @@\n-  void dump_idom(Node* n) const;\n+  void dump_idom(Node* n) const { dump_idom(n, 1000); } \/\/ For debugging\n+  void dump_idom(Node* n, uint count) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}