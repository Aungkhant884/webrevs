{"files":[{"patch":"@@ -6001,1 +6001,1 @@\n-  int _early_index;\n+  uint _early_index;\n@@ -6004,4 +6004,12 @@\n-  static uint find_idom_index(const Node* n, const Unique_Node_List& idoms) {\n-    for (uint i = 0; i < idoms.size(); i++) {\n-      if (idoms[i] == n) {\n-        return i;\n+  \/\/ Given idom chains of early and wrong LCA: Walk through idoms starting at StartNode and find the first node which\n+  \/\/ is different: Return the previously visited node which must be the real LCA.\n+  \/\/ The node lists also contain _early and _wrong_lca, respectively.\n+  Node* find_real_lca(Unique_Node_List& early_with_idoms, Unique_Node_List& wrong_lca_with_idoms) {\n+    int early_index = early_with_idoms.size() - 1;\n+    int wrong_lca_index = wrong_lca_with_idoms.size() - 1;\n+    bool found_difference = false;\n+    do {\n+      if (early_with_idoms[early_index] != wrong_lca_with_idoms[wrong_lca_index]) {\n+        \/\/ First time early and wrong LCA idoms differ. Real LCA must be at the previous index.\n+        found_difference = true;\n+        break;\n@@ -6009,4 +6017,3 @@\n-    }\n-    assert(false, \"must find index\");\n-    return 0;\n-  }\n+      early_index--;\n+      wrong_lca_index--;\n+    } while (wrong_lca_index >= 0);\n@@ -6014,14 +6021,6 @@\n-  Node* find_real_lca(Unique_Node_List& early_idoms) {\n-    Node* next = _wrong_lca;\n-    while (!next->is_Start()) {\n-      if (next == _early) {\n-        return next;\n-      } else if (early_idoms.member(next)) {\n-        _early_index = find_idom_index(next, early_idoms);\n-        return next;\n-      }\n-      next = _phase->idom(next);\n-      _wrong_lca_index++;\n-    }\n-    assert(false, \"must always find an LCA\");\n-    return nullptr;\n+    assert(early_index >= 0, \"must always find an LCA - cannot be early\");\n+    _early_index = early_index;\n+    _wrong_lca_index = wrong_lca_index;\n+    Node* real_lca = early_with_idoms[_early_index + 1]; \/\/ Plus one to skip _early.\n+    assert(found_difference || real_lca == _wrong_lca, \"wrong LCA dominates early and is therefore the real LCA\");\n+    return real_lca;\n@@ -6051,1 +6050,1 @@\n-      : _phase(phase), _early(early), _wrong_lca(wrong_lca), _early_index(-1), _wrong_lca_index(-1) {\n+      : _phase(phase), _early(early), _wrong_lca(wrong_lca), _early_index(0), _wrong_lca_index(0) {\n@@ -6057,3 +6056,7 @@\n-    Unique_Node_List early_idoms;\n-    _phase->get_idoms(_early, 1000, early_idoms);\n-    Node* real_lca = find_real_lca(early_idoms);\n+    Unique_Node_List early_with_idoms;\n+    Unique_Node_List wrong_lca_with_idoms;\n+    early_with_idoms.push(_early);\n+    wrong_lca_with_idoms.push(_wrong_lca);\n+    _phase->get_idoms(_early, 10000, early_with_idoms);\n+    _phase->get_idoms(_wrong_lca, 10000, wrong_lca_with_idoms);\n+    Node* real_lca = find_real_lca(early_with_idoms, wrong_lca_with_idoms);\n@@ -6158,1 +6161,1 @@\n-    assert(!idoms.member(n), \"duplicated idom is not possible\");\n+    assert(!idoms.member(next), \"duplicated idom is not possible\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":31,"deletions":28,"binary":false,"changes":59,"status":"modified"}]}