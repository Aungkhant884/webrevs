{"files":[{"patch":"@@ -66,0 +66,18 @@\n+ifeq ($(HSDIS_BACKEND), llvm)\n+  # Use C++ instead of C\n+  HSDIS_TOOLCHAIN_CFLAGS := $(CXXFLAGS_JDKLIB)\n+  HSDIS_TOOLCHAIN := TOOLCHAIN_LINK_CXX\n+\n+  ifeq ($(call isTargetOs, linux), true)\n+    LLVM_OS := pc-linux-gnu\n+  else ifeq ($(call isTargetOs, macosx), true)\n+    LLVM_OS := apple-darwin\n+  else ifeq ($(call isTargetOs, windows), true)\n+    LLVM_OS := pc-windows-msvc\n+  else\n+    $(error No support for LLVM on this platform)\n+  endif\n+\n+  HSDIS_CFLAGS += -DLLVM_DEFAULT_TRIPLET='\"$(OPENJDK_TARGET_CPU)-$(LLVM_OS)\"'\n+endif\n+\n","filename":"make\/Hsdis.gmk","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-      [what hsdis backend to use ('none', 'capstone', 'binutils') @<:@none@:>@])])\n+      [what hsdis backend to use ('none', 'capstone', 'llvm', 'binutils') @<:@none@:>@])])\n@@ -819,0 +819,3 @@\n+  AC_ARG_WITH([llvm], [AS_HELP_STRING([--with-llvm],\n+      [where to find the LLVM files needed for hsdis\/llvm])])\n+\n@@ -867,0 +870,53 @@\n+  elif test \"x$with_hsdis\" = xllvm; then\n+    HSDIS_BACKEND=llvm\n+    AC_MSG_RESULT(['llvm'])\n+\n+    if test \"x$with_llvm\" != x; then\n+      LLVM_DIR=\"$with_llvm\"\n+    fi\n+\n+    if test \"x$OPENJDK_TARGET_OS\" != xwindows; then\n+      if test \"x$LLVM_DIR\" = x; then\n+        # Macs with homebrew can have llvm in different places\n+        UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$PATH:\/usr\/local\/opt\/llvm\/bin:\/opt\/homebrew\/opt\/llvm\/bin])\n+        if test \"x$LLVM_CONFIG\" = x; then\n+          AC_MSG_NOTICE([Cannot locate llvm-config which is needed for hsdis\/llvm. Try using --with-llvm=<LLVM home>.])\n+          AC_MSG_ERROR([Cannot continue])\n+        fi\n+      else\n+        UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$LLVM_DIR\/bin])\n+        if test \"x$LLVM_CONFIG\" = x; then\n+          AC_MSG_NOTICE([Cannot locate llvm-config in $LLVM_DIR. Check your --with-llvm argument.])\n+          AC_MSG_ERROR([Cannot continue])\n+        fi\n+      fi\n+\n+      # We need the LLVM flags and libs, and llvm-config provides them for us.\n+      HSDIS_CFLAGS=`$LLVM_CONFIG --cflags`\n+      HSDIS_LDFLAGS=`$LLVM_CONFIG --ldflags`\n+      HSDIS_LIBS=`$LLVM_CONFIG --libs $OPENJDK_TARGET_CPU_ARCH ${OPENJDK_TARGET_CPU_ARCH}disassembler`\n+    else\n+      if test \"x$LLVM_DIR\" = x; then\n+        AC_MSG_NOTICE([--with-llvm is needed on Windows to point out the LLVM home])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+\n+      # Official Windows installation of LLVM do not ship llvm-config, and self-built llvm-config\n+      # produced unusable output, so just ignore it on Windows.\n+      if ! test -e $LLVM_DIR\/include\/llvm-c\/lto.h; then\n+        AC_MSG_NOTICE([$LLVM_DIR does not seem like a valid LLVM home; include dir is missing])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+      if ! test -e $LLVM_DIR\/include\/llvm-c\/Disassembler.h; then\n+        AC_MSG_NOTICE([$LLVM_DIR does not point to a complete LLVM installation. ])\n+        AC_MSG_NOTICE([The official LLVM distribution is missing crucical files; you need to build LLVM yourself or get all include files elsewhere])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+      if ! test -e $LLVM_DIR\/lib\/llvm-c.lib; then\n+        AC_MSG_NOTICE([$LLVM_DIR does not seem like a valid LLVM home; lib dir is missing])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+      HSDIS_CFLAGS=\"-I$LLVM_DIR\/include\"\n+      HSDIS_LDFLAGS=\"-libpath:$LLVM_DIR\/lib\"\n+      HSDIS_LIBS=\"llvm-c.lib\"\n+    fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-JDK is support for building hsdis with Capstone or GNU binutils. The interface\n-is fairly straightforward and easy to implement using other backends.\n+JDK is support for building hsdis with Capstone, LLVM or GNU binutils. The\n+interface is fairly straightforward and easy to implement using other backends.\n@@ -61,2 +61,2 @@\n-where `<backend>` is either `capstone` or `binutils`. For details, see the\n-sections on the respective backends below.\n+where `<backend>` is either `capstone`, `llvm` or `binutils`. For details, see\n+the sections on the respective backends below.\n@@ -79,0 +79,6 @@\n+If using the LLVM backend on Windows, you need to be sure that the LLVM DLL file\n+(or files) can be found by hsdis. In practice, this means that you either need\n+to copy `LLVM-C.DLL` to a place on your `PATH` or the JDK `bin` directory, or\n+you need to augment your `PATH` variable to also point to where you installed\n+LLVM (like `C:\\LLVM\\bin`).\n+\n@@ -103,0 +109,52 @@\n+## Building with LLVM\n+\n+To build this project using LLVM you need to have LLVM installed. Typical ways\n+of installation can be `sudo apt install llvm` (on Debian and derivatives), or\n+`brew install llvm` (on macOS with Homebrew). For Windows, see below.\n+\n+This has been tested with LLVM v13.0.0, but earlier (and later) versions are\n+also likely to work.\n+\n+To build hsdis using LLVM, you must enable it in configure by `bash configure\n+--with-hsdis=llvm`.\n+\n+If `llvm-config` is not in your path, you will need to specify the LLVM home using\n+`--with-llvm=<LLVM home>`. Example: If your `llvm-config` is in `~\/my-llvm\/bin`,\n+then you should use `--with-llvm=~\/my-llvm`.\n+\n+### Building with LLVM on Windows\n+\n+Getting a usable installation on Windows is trickier than on the other\n+platforms. You can download (and patch) the official distribution, or you can\n+build it yourself.\n+\n+Links to the latest version of the official build is available at [LLVMs\n+download page](https:\/\/releases.llvm.org\/download.html). Download the file\n+*LLVM-nn.n.n-win64.exe*, and run it to let it install itself. The default\n+installation location is `C:\\Program Files\\LLVM`. This is not ideal due to the\n+spaces in the path, so it is recommended to put it elsewhere (e.g. `C:\\LLVM`).\n+\n+For very unclear reasons, the official Windows build is missing almost all LLVM\n+include files. (At least this was the case up to and including LLVM 13.) You\n+will need to complement your installation with the proper include files. One way\n+to do this is to install LLVM in Cygwin. This will give you (apart from the Cygwin-based dll\n+files which are unusable with Visual Studio) a complete set of the\n+headers. These are located in `\/usr\/include\/llvm` and `\/usr\/include\/llvm-c`. Copy\n+these directories, with all their content, into `$LLVM_HOME\/include`.\n+\n+Alternatively, you can build LLVM yourself from source. This process is\n+documented at the [LLVM Visual Studio\n+page](https:\/\/llvm.org\/docs\/GettingStartedVS.html).\n+\n+Either which way, you must tell configure the location of your LLVM installation\n+using `--with-llvm=<path to LLVM home>`.\n+\n+The `llvm-config` tool, which configure uses on other platforms to get the\n+proper compile and link flags to use, is unfortunately not usable on Windows. In\n+the official distribution, it is just missing. And the self-built version tend\n+to give broken and unusable output. Therefore configure uses heuristics to setup\n+proper flags to the compiler and linker. This was verified to work for LLVM v13,\n+but might be incorrect for other versions. Manual override of `HSDIS_CFLAGS`,\n+`HSDIS_LDFLAGS` and\/or `HSDIS_LIBS` on the make command line might be needed in\n+that case.\n+\n","filename":"src\/utils\/hsdis\/README.md","additions":62,"deletions":4,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to\n+ * any person obtaining a copy of this software, associated documentation\n+ * and\/or data (collectively the \"Software\"), free of charge and under any\n+ * and all copyright rights in the Software, and any and all patent rights\n+ * owned or freely licensable by each licensor hereunder covering either (i)\n+ * the unmodified Software as contributed to or provided by such licensor,\n+ * or (ii) the Larger Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ *\n+ * (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n+ * if one is included with the Software (each a \"Larger Work\" to which the\n+ * Software is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy,\n+ * create derivative works of, display, perform, and distribute the Software\n+ * and make, use, sell, offer for sale, import, export, have made, and have\n+ * sold the Software and the Larger Work(s), and to sublicense the foregoing\n+ * rights on either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ *\n+ * The above copyright notice and either this complete permission notice or\n+ * at a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+ * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+ * USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* hsdis.cpp -- dump a range of addresses as native instructions\n+   This implements the plugin protocol required by the\n+   HotSpot PrintAssembly option.\n+*\/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+#include <string.h>\n+\n+#include <llvm-c\/Disassembler.h>\n+#include <llvm-c\/DisassemblerTypes.h>\n+#include <llvm-c\/Target.h>\n+#include <llvm-c\/TargetMachine.h>\n+\n+#include \"hsdis.h\"\n+\n+\/* short names for stuff in hsdis.h *\/\n+typedef decode_instructions_event_callback_ftype  event_callback_t;\n+typedef decode_instructions_printf_callback_ftype printf_callback_t;\n+\n+class hsdis_backend_base {\n+ protected:\n+  uintptr_t         _start_va;\n+  uintptr_t         _end_va;\n+  unsigned char*    _buffer;\n+  uintptr_t         _length;\n+  event_callback_t  _event_callback;\n+  void*             _event_stream;\n+  printf_callback_t _printf_callback;\n+  void*             _printf_stream;\n+  int               _do_newline;\n+\n+  bool              _losing;\n+  const char*       _arch_name;\n+\n+  virtual void print_help(const char* msg, const char* arg) = 0;\n+  virtual void print_insns_config() = 0;\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) = 0;\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) = 0;\n+\n+ private:\n+  \/* ignore all events, return a null *\/\n+  static void* null_event_callback(void* ignore_stream, const char* ignore_event, void* arg) {\n+    return NULL;\n+  }\n+\n+  \/* print all events as XML markup *\/\n+  static void* xml_event_callback(void* stream, const char* event, void* arg) {\n+    FILE* fp = (FILE*) stream;\n+#define NS_PFX \"dis:\"\n+    if (event[0] != '\/') {\n+      \/* issue the tag, with or without a formatted argument *\/\n+      fprintf(fp, \"<\" NS_PFX);\n+      fprintf(fp, event, arg);\n+      fprintf(fp, \">\");\n+    } else {\n+      ++event;                    \/* skip slash *\/\n+      const char* argp = strchr(event, ' ');\n+      if (argp == NULL) {\n+        \/* no arguments; just issue the closing tag *\/\n+        fprintf(fp, \"<\/\" NS_PFX \"%s>\", event);\n+      } else {\n+        \/* split out the closing attributes as <dis:foo_done attr='val'\/> *\/\n+        size_t event_prefix =(argp - event);\n+        fprintf(fp, \"<\" NS_PFX \"%.*s_done\", (int) event_prefix, event);\n+        fprintf(fp, argp, arg);\n+        fprintf(fp, \"\/><\/\" NS_PFX \"%.*s>\", (int) event_prefix, event);\n+      }\n+    }\n+#undef NS_PFX\n+    return NULL;\n+  }\n+\n+protected:\n+  hsdis_backend_base(uintptr_t start_va, uintptr_t end_va,\n+                     unsigned char* buffer, uintptr_t length,\n+                     event_callback_t  event_callback,  void* event_stream,\n+                     printf_callback_t printf_callback, void* printf_stream,\n+                     int do_newline) :\n+      _start_va(start_va), _end_va(end_va),\n+      _buffer(buffer), _length(length),\n+      _event_callback(event_callback), _event_stream(event_stream),\n+      _printf_callback(printf_callback), _printf_stream(printf_stream),\n+      _do_newline(do_newline),\n+      _losing(false), _arch_name(NULL)\n+  {\n+    \/* Make reasonable defaults for null callbacks.\n+      A non-null stream for a null callback is assumed to be a FILE* for output.\n+      Events are rendered as XML.\n+    *\/\n+    if (_printf_callback == NULL) {\n+      int (*fprintf_callback)(FILE*, const char*, ...) = &fprintf;\n+      FILE* fprintf_stream = stdout;\n+      _printf_callback = (printf_callback_t) fprintf_callback;\n+      if (_printf_stream == NULL)\n+        _printf_stream   = (void*)           fprintf_stream;\n+    }\n+    if (_event_callback == NULL) {\n+      if (_event_stream == NULL)\n+        _event_callback = (event_callback_t)&null_event_callback;\n+      else\n+        _event_callback = (event_callback_t)&xml_event_callback;\n+    }\n+  }\n+\n+ public:\n+  void* decode() {\n+    uintptr_t start = _start_va;\n+    uintptr_t end   = _end_va;\n+    uintptr_t p     = start;\n+\n+    (*_event_callback)(_event_stream, \"insns\", (void*)start);\n+\n+    print_insns_config();\n+\n+    while (p < end && !_losing) {\n+      (*_event_callback)(_event_stream, \"insn\", (void*) p);\n+\n+      size_t size = decode_instruction(p, start, end);\n+      if (size > 0)  p += size;\n+      else           _losing = true;\n+\n+      if (!_losing) {\n+        char buf[128];\n+        const char* insn_close = format_insn_close(\"\/insn\", buf, sizeof(buf));\n+        (*_event_callback)(_event_stream, insn_close, (void*) p);\n+\n+        if (_do_newline) {\n+          \/* follow each complete insn by a nice newline *\/\n+          (*_printf_callback)(_printf_stream, \"\\n\");\n+        }\n+      }\n+    }\n+\n+    if (_losing) (*_event_callback)(_event_stream, \"\/insns\", (void*) p);\n+    return (void*) p;\n+  }\n+};\n+\n+\n+class hsdis_backend : public hsdis_backend_base {\n+ private:\n+  LLVMDisasmContextRef      _dcontext;\n+  char                      _target_triple[128];\n+\n+  void parse_caller_options(const char* options) {\n+    memset(&_target_triple, 0, sizeof(_target_triple));\n+    const char* p;\n+    for (p = options; p != NULL; ) {\n+      const char* q = strchr(p, ',');\n+      size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n+      if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n+        print_help(NULL, NULL);\n+      } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n+        \/\/ do not pass these to the next level\n+      } else if (plen >= 14 && strncmp(p, \"target_triple=\", 14) == 0) {\n+        char*  target_triple = _target_triple;\n+        size_t target_triple_size   = sizeof(_target_triple);\n+        target_triple_size -= 1;           \/*leave room for the null*\/\n+        if (plen > target_triple_size)  plen = target_triple_size;\n+        strncpy(target_triple, p, plen);\n+        target_triple[plen] = '\\0';\n+      }\n+      p = q;\n+    }\n+  }\n+\n+  const char* native_target_triple() {\n+    return LLVM_DEFAULT_TRIPLET;\n+  }\n+\n+ public:\n+  hsdis_backend(uintptr_t start_va, uintptr_t end_va,\n+                unsigned char* buffer, uintptr_t length,\n+                event_callback_t  event_callback,  void* event_stream,\n+                printf_callback_t printf_callback, void* printf_stream,\n+                const char* options, int newline)\n+    : hsdis_backend_base(start_va, end_va,\n+                         buffer, length,\n+                         event_callback, event_stream,\n+                         printf_callback, printf_stream,\n+                         newline),\n+      _dcontext(NULL) {\n+    \/* Look into _options for anything interesting. *\/\n+    if (options != NULL)\n+      parse_caller_options(options);\n+\n+    \/* Discover which architecture we are going to disassemble. *\/\n+    _arch_name = &_target_triple[0];\n+    if (_arch_name[0] == '\\0')\n+      _arch_name = native_target_triple();\n+\n+    if (LLVMInitializeNativeTarget() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native target\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if (LLVMInitializeNativeAsmPrinter() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native asm printer\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if (LLVMInitializeNativeDisassembler() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native disassembler\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if ((_dcontext = LLVMCreateDisasm(_arch_name, NULL, 0, NULL, NULL)) == NULL) {\n+      static bool complained = false;\n+      const char* bad = _arch_name;\n+      if (bad == &_target_triple[0])\n+        print_help(\"bad target_triple=%s\", bad);\n+      else if (!complained)\n+        print_help(\"bad native target_triple=%s; please port hsdis to this platform\", bad);\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+\n+    LLVMSetDisasmOptions(_dcontext, LLVMDisassembler_Option_PrintImmHex);\n+  }\n+\n+  ~hsdis_backend() {\n+    if (_dcontext != NULL) {\n+      LLVMDisasmDispose(_dcontext);\n+    }\n+  }\n+\n+ protected:\n+  virtual void print_help(const char* msg, const char* arg) {\n+    if (msg != NULL) {\n+      (*_printf_callback)(_printf_stream, \"hsdis: \");\n+      (*_printf_callback)(_printf_stream, msg, arg);\n+      (*_printf_callback)(_printf_stream, \"\\n\");\n+    }\n+    (*_printf_callback)(_printf_stream, \"hsdis output options:\\n\");\n+    (*_printf_callback)(_printf_stream, \"  target_triple=<triple> select disassembly target\\n\");\n+    (*_printf_callback)(_printf_stream, \"  help          print this message\\n\");\n+  }\n+\n+  virtual void print_insns_config() {\n+    (*_event_callback)(_event_stream, \"target_triple name='%s'\",\n+                      (void*) _arch_name);\n+  }\n+\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) {\n+    char buf[128];\n+    size_t size = LLVMDisasmInstruction(_dcontext, (uint8_t*)p, (uint64_t)(end - start), (uint64_t)p, buf, sizeof(buf));\n+    if (size > 0) {\n+      (*_printf_callback)(_printf_stream, \"%s\", buf);\n+    } else {\n+      \/\/ LLVM encountered an unknown instruction\n+      if (end - start >= 4) {\n+        \/\/ Print the following word and skip past it\n+        snprintf(buf, sizeof(buf), \"\\t.inst\\t#0x%08x ; undefined\", *(uint32_t*)p);\n+        size = 4;\n+      } else {\n+        snprintf(buf, sizeof(buf), \"\\t<invalid instruction, aborting hsdis>\");\n+      }\n+    }\n+    return size;\n+  }\n+\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) {\n+    return close;\n+  }\n+};\n+\n+\n+void* decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n+                            unsigned char* buffer, uintptr_t length,\n+                            event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                            printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                            const char* options, int newline) {\n+  return hsdis_backend(start_va, end_va,\n+                       buffer, length,\n+                       event_callback_arg, event_stream_arg,\n+                       printf_callback_arg, printf_stream_arg,\n+                       options, newline == 0 ? false : true)\n+          .decode();\n+}\n+\n+\/* This is the compatability interface for older version of hotspot *\/\n+void* decode_instructions(void* start_pv, void* end_pv,\n+                    event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                    printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                    const char* options) {\n+  return decode_instructions_virtual((uintptr_t)start_pv,\n+                                     (uintptr_t)end_pv,\n+                                     (unsigned char*)start_pv,\n+                                     (uintptr_t)end_pv - (uintptr_t)start_pv,\n+                                     event_callback_arg,\n+                                     event_stream_arg,\n+                                     printf_callback_arg,\n+                                     printf_stream_arg,\n+                                     options, false);\n+}\n","filename":"src\/utils\/hsdis\/llvm\/hsdis-llvm.cpp","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"}]}