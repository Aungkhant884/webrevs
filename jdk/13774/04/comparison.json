{"files":[{"patch":"@@ -1734,1 +1734,1 @@\n-    _gc_tracer_cm->report_object_count_after_gc(&is_alive);\n+    _gc_tracer_cm->report_object_count_after_gc(&is_alive, _g1h->workers());\n@@ -1737,1 +1737,1 @@\n-    _gc_tracer_cm->report_object_count_after_gc(&is_alive);\n+    _gc_tracer_cm->report_object_count_after_gc(&is_alive, _g1h->workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-    scope()->tracer()->report_object_count_after_gc(&_is_alive);\n+    scope()->tracer()->report_object_count_after_gc(&_is_alive, _heap->workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2072,1 +2072,1 @@\n-    _gc_tracer.report_object_count_after_gc(is_alive_closure());\n+    _gc_tracer.report_object_count_after_gc(is_alive_closure(), &ParallelScavengeHeap::heap()->workers());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    gc_tracer()->report_object_count_after_gc(&is_alive);\n+    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -103,1 +104,1 @@\n-void GCTracer::report_object_count_after_gc(BoolObjectClosure* is_alive_cl) {\n+void GCTracer::report_object_count_after_gc(BoolObjectClosure* is_alive_cl, WorkerThreads* workers) {\n@@ -112,1 +113,1 @@\n-      hi.populate_table(&cit, is_alive_cl);\n+      hi.populate_table(&cit, is_alive_cl, workers);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  void report_object_count_after_gc(BoolObjectClosure* object_filter) NOT_SERVICES_RETURN;\n+  void report_object_count_after_gc(BoolObjectClosure* object_filter, WorkerThreads* workers) NOT_SERVICES_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,0 +169,7 @@\n+  WorkerThreads* workers = Universe::heap()->safepoint_workers();\n+  if (workers != nullptr) {\n+      \/\/ The GC provided a WorkerThreads to be used during a safepoint.\n+      \/\/ Can't run with more threads than provided by the WorkerThreads.\n+      const uint capped_parallel_thread_num = MIN2(_parallel_thread_num, workers->max_workers());\n+      WithActiveWorkers with_active_workers(workers, capped_parallel_thread_num);\n+  }\n@@ -170,1 +177,1 @@\n-  inspect.heap_inspection(_out, _parallel_thread_num);\n+  inspect.heap_inspection(_out, workers);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -567,2 +567,1 @@\n-uintx HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter, uint parallel_thread_num) {\n-\n+uintx HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter, WorkerThreads* workers) {\n@@ -570,18 +569,9 @@\n-  if (parallel_thread_num > 1) {\n-    ResourceMark rm;\n-\n-    WorkerThreads* workers = Universe::heap()->safepoint_workers();\n-    if (workers != nullptr) {\n-      \/\/ The GC provided a WorkerThreads to be used during a safepoint.\n-\n-      \/\/ Can't run with more threads than provided by the WorkerThreads.\n-      const uint capped_parallel_thread_num = MIN2(parallel_thread_num, workers->max_workers());\n-      WithActiveWorkers with_active_workers(workers, capped_parallel_thread_num);\n-\n-      ParallelObjectIterator poi(workers->active_workers());\n-      ParHeapInspectTask task(&poi, cit, filter);\n-      \/\/ Run task with the active workers.\n-      workers->run_task(&task);\n-      if (task.success()) {\n-        return task.missed_count();\n-      }\n+  ResourceMark rm;\n+\n+  if (workers != nullptr) {\n+    ParallelObjectIterator poi(workers->active_workers());\n+    ParHeapInspectTask task(&poi, cit, filter);\n+    \/\/ Run task with the active workers.\n+    workers->run_task(&task);\n+    if (task.success()) {\n+      return task.missed_count();\n@@ -591,1 +581,0 @@\n-  ResourceMark rm;\n@@ -598,1 +587,1 @@\n-void HeapInspection::heap_inspection(outputStream* st, uint parallel_thread_num) {\n+void HeapInspection::heap_inspection(outputStream* st, WorkerThreads* workers) {\n@@ -604,1 +593,1 @@\n-    uintx missed_count = populate_table(&cit, nullptr, parallel_thread_num);\n+    uintx missed_count = populate_table(&cit, nullptr, workers);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -203,2 +203,2 @@\n-  void heap_inspection(outputStream* st, uint parallel_thread_num = 1) NOT_SERVICES_RETURN;\n-  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = nullptr, uint parallel_thread_num = 1) NOT_SERVICES_RETURN_(0);\n+  void heap_inspection(outputStream* st, WorkerThreads* workers) NOT_SERVICES_RETURN;\n+  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter, WorkerThreads* workers) NOT_SERVICES_RETURN_(0);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}