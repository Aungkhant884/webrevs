{"files":[{"patch":"@@ -105,1 +105,1 @@\n-      LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+      LogDecorations decorations(LogLevel::Warning, none::tagset(), LogDecorators::All);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,0 +256,24 @@\n+  \/\/ MT-Safety\n+  \/\/ ConfigurationLock can only guarantee that only one thread is executing reconfiguration. This function still must\n+  \/\/ be MT-safe because logsites in other threads may be executing in parallel.\n+  \/\/\n+  \/\/ Reconfiguration: Unified logging allows users to dynamically change tags and decorators of a log output.\n+  \/\/\n+  \/\/ A synchronization 'wait_until_no_readers()' is imposed inside of 'ts->set_output_level(output, level)' above\n+  \/\/ if setting has changed. It guarantees that all logs either synchronous writing or enqueuing to the async buffer\n+  \/\/ see the new tags and decorators. It's worth noting that the synchronization happens even level doesn't change.\n+  \/\/\n+  \/\/ LogDecorator is a set of decorators represented in a uint. sizeof(uinit) is not greater than a machine word,\n+  \/\/ so store of it is atomic on the mainstream processors. I.e. readers see either its older value or new value.\n+  \/\/ ts->update_decorators(decorators) above is a union operation of the existing decorators at different levels.\n+  \/\/ It's safe to do output->set_decorators(decorators) because decorators is a subset of relevant Tagsets' decorators.\n+  \/\/ After updating output's decorators, it's still safe to shrink all decorators of tagsets.\n+  \/\/\n+  \/\/ There are 2 harzards in async logging. A flush operation guarantees to all pending messages in buffer are written\n+  \/\/ before returning. Therefore, the hardards won't appear. It's a nop if async logging is not set.\n+  \/\/ 1. asynclog buffer may be holding some log messages with previous decorators.\n+  \/\/ 2. asynclog buffer may be holding some log messages targeting to the output 'idx'. It has been disabled by new setting,\n+  \/\/ eg. all=off and is about to be purged in delete_output(idx).\n+  \/\/\n+  AsyncLogWriter::flush();\n+\n@@ -259,0 +283,2 @@\n+  OrderAccess::storestore();\n+\n@@ -265,4 +291,0 @@\n-    \/\/ User may disable a logOuput like this:\n-    \/\/ LogConfiguration::parse_log_arguments(filename, \"all=off\", \"\", \"\", &stream);\n-    \/\/ Just be conservative. Flush them all before deleting idx.\n-    AsyncLogWriter::flush();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,11 @@\n+template <LogDecorators::Decorator d>\n+struct AllBitmask {\n+  \/\/ Use recursive template deduction to calculcate the bitmask of all decorations.\n+  static const uint _value = (1 << d) | AllBitmask<static_cast<LogDecorators::Decorator>(d + 1)>::_value;\n+};\n+\n+template<>\n+struct AllBitmask<LogDecorators::Count> {\n+  static const uint _value = 0;\n+};\n+\n@@ -29,0 +40,1 @@\n+const LogDecorators LogDecorators::All  = LogDecorators(AllBitmask<time_decorator>::_value);\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  static const LogDecorators All;\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"concurrentTestRunner.inline.hpp\"\n@@ -231,0 +232,45 @@\n+class ConcurrentLogsite : public TestRunnable {\n+  int _id;\n+\n+ public:\n+  ConcurrentLogsite(int id) : _id(id) {}\n+  void runUnitTest() const override {\n+    log_debug(logging)(\"ConcurrentLogsite %d emits a log\", _id);\n+  }\n+};\n+\n+\/\/ dynamically change decorators while loggings are emitting.\n+TEST_VM_F(LogConfigurationTest, reconfigure_decorators_MT) {\n+  const int nrOfThreads = 2;\n+  ConcurrentLogsite logsites[nrOfThreads] = {0, 1};\n+  Semaphore done(0);\n+  const long testDurationMillis = 3000;\n+  UnitTestThread* t[nrOfThreads];\n+\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\");\n+  set_log_config(\"stdout\", \"all=off\", \"none\");\n+  set_log_config(\"stderr\", \"all=off\", \"none\");\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    t[i] = new UnitTestThread(&logsites[i], &done, testDurationMillis);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; i++) {\n+    t[i]->doit();\n+  }\n+\n+  jlong time_start = os::elapsed_counter();\n+  while (true) {\n+    jlong elapsed = (jlong)TimeHelper::counter_to_millis(os::elapsed_counter() - time_start);\n+    if (elapsed > testDurationMillis) {\n+      break;\n+    }\n+    \/\/ Take turn logging with different decorators, either None or All.\n+    set_log_config(TestLogFileName, \"logging=debug\", \"none\");\n+    set_log_config(TestLogFileName, \"logging=debug\", _all_decorators);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    done.wait();\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logConfiguration.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,0 +213,7 @@\n+TEST(LogDecorators, all) {\n+  LogDecorators dec = LogDecorators::All;\n+  for (size_t i = 0; i < LogDecorators::Count; i++) {\n+    EXPECT_TRUE(dec.is_decorator(decorator_array[i]));\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorators.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}