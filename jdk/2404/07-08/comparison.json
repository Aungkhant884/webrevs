{"files":[{"patch":"@@ -44,1 +44,1 @@\n-    private static final byte[] ICV1 = {\n+    private static final byte[] ICV1 = { \/\/ SEMI_BLKSIZE long\n@@ -99,1 +99,1 @@\n-        if (iv != null && iv.length != ICV1.length) {\n+        if (iv != null && iv.length != SEMI_BLKSIZE) {\n@@ -152,1 +152,1 @@\n-        if (ptLen < (BLKSIZE + SEMI_BLKSIZE) || (ptLen % SEMI_BLKSIZE) != 0) {\n+        if (ptLen < MIN_INPUTLEN || (ptLen % SEMI_BLKSIZE) != 0) {\n@@ -154,1 +154,1 @@\n-                \" be at least 16 bytes and multiples of 8\");\n+                    \" be at least 16 bytes and multiples of 8\");\n@@ -156,3 +156,1 @@\n-\n-        W(iv, pt, ptLen, embeddedCipher);\n-        return ptLen;\n+        return W(iv, pt, ptLen, embeddedCipher);\n@@ -185,1 +183,1 @@\n-        if (ctLen < (BLKSIZE + SEMI_BLKSIZE) || (ctLen % SEMI_BLKSIZE) != 0) {\n+        if (ctLen < MIN_INPUTLEN || (ctLen % SEMI_BLKSIZE) != 0) {\n@@ -187,1 +185,1 @@\n-                (\"data should be at least 24 bytes and multiples of 8\");\n+                    (\"data should be at least 24 bytes and multiples of 8\");\n@@ -189,3 +187,2 @@\n-        byte[] ivOut = new byte[ICV1.length];\n-        W_INV(ct, ctLen, ivOut, embeddedCipher);\n-        ctLen -= SEMI_BLKSIZE;\n+        byte[] ivOut = new byte[SEMI_BLKSIZE];\n+        ctLen = W_INV(ct, ctLen, ivOut, embeddedCipher);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final byte[] ICV2 = {\n+    private static final byte[] ICV2 = { \/\/ SEMI_BLKSIZE\/2 long\n@@ -205,1 +205,1 @@\n-            W(ivAndLen, pt, ptLen, embeddedCipher);\n+            ptLen = W(ivAndLen, pt, ptLen, embeddedCipher);\n@@ -241,0 +241,1 @@\n+            ctLen -= SEMI_BLKSIZE;\n@@ -242,1 +243,1 @@\n-            W_INV(ct, ctLen, ivAndLen, embeddedCipher);\n+            ctLen = W_INV(ct, ctLen, ivAndLen, embeddedCipher);\n@@ -244,1 +245,0 @@\n-        ctLen -= SEMI_BLKSIZE;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    static final int MIN_INPUTLEN = BLKSIZE + SEMI_BLKSIZE;\n@@ -52,0 +53,1 @@\n+     * @return the processed output length, i.e. same as {@code inLen}.\n@@ -53,1 +55,1 @@\n-    static final void W(byte[] firstSemiblk, byte[] in, int inLen,\n+    static final int W(byte[] icvIn, byte[] in, int inLen,\n@@ -55,2 +57,6 @@\n-        \/\/ overwrite the first block of in with the iv semiblock\n-        System.arraycopy(firstSemiblk, 0, in, 0, SEMI_BLKSIZE);\n+        assert((inLen >= MIN_INPUTLEN) && ((inLen % SEMI_BLKSIZE) == 0)) :\n+                (\"Invalid data length for W: \" + inLen);\n+        assert(icvIn.length == SEMI_BLKSIZE) : \"Invalid ICV buffer size\";\n+\n+        \/\/ overwrite the first block of in with the icv semiblock\n+        System.arraycopy(icvIn, 0, in, 0, SEMI_BLKSIZE);\n@@ -58,1 +64,0 @@\n-        \/\/ assert (inLen % SEMI_BLKSIZE == 0) {\n@@ -79,0 +84,2 @@\n+        \/\/ for W, output length is same as input length\n+        return inLen;\n@@ -91,0 +98,1 @@\n+     * @return the recovered data length, i.e. {@code (inLen - icvOut.length)}\n@@ -92,1 +100,1 @@\n-    static final void W_INV(byte[] in, int inLen, byte[] ivOut,\n+    static final int W_INV(byte[] in, int inLen, byte[] icvOut,\n@@ -94,3 +102,4 @@\n-        int outLen = inLen - SEMI_BLKSIZE;\n-        \/\/ assert inLen?\n-        \/\/ assert (ivOut.length == SEMI_BLKSIZE)\n+\n+        assert((inLen >= MIN_INPUTLEN) && ((inLen % SEMI_BLKSIZE) == 0)) :\n+                (\"Invalid data length for W_INV: \" + inLen);\n+        assert(icvOut.length == SEMI_BLKSIZE) : \"Invalid ICV buffer size\";\n@@ -117,1 +126,2 @@\n-        System.arraycopy(buffer, 0, ivOut, 0, SEMI_BLKSIZE);\n+        System.arraycopy(buffer, 0, icvOut, 0, SEMI_BLKSIZE);\n+        return inLen - SEMI_BLKSIZE;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -127,4 +127,4 @@\n-    \/\/ 'dataBuf' starting at startIdx.\n-    \/\/ NOTE: if in is null, this method will ensure that dataBuf has enough\n-    \/\/ capacity for inLen bytes but will NOT copy bytes from in.\n-    private void store(int startIdx, byte[] in, int inOfs, int inLen) {\n+    \/\/ 'dataBuf' starting at 'dataIdx'.\n+    \/\/ NOTE: if 'in' is null, this method will ensure that 'dataBuf' has enough\n+    \/\/ capacity for 'inLen' bytes but will NOT copy bytes from 'in'.\n+    private void store(byte[] in, int inOfs, int inLen) {\n@@ -137,1 +137,1 @@\n-        int remain = Integer.MAX_VALUE - startIdx;\n+        int remain = Integer.MAX_VALUE - dataIdx;\n@@ -143,4 +143,4 @@\n-        \/\/ resize dataBuf to the smallest (n * BLKSIZE) + SEMI_BLKSIZE)\n-        if (dataBuf.length - startIdx < inLen) {\n-            int newSize = Math.addExact(startIdx, inLen);\n-            int lastBlk = (startIdx + inLen - SEMI_BLKSIZE) % BLKSIZE;\n+        \/\/ resize 'dataBuf' to the smallest (n * BLKSIZE) + SEMI_BLKSIZE)\n+        if (dataBuf == null || dataBuf.length - dataIdx < inLen) {\n+            int newSize = Math.addExact(dataIdx, inLen);\n+            int lastBlk = (dataIdx + inLen - SEMI_BLKSIZE) % BLKSIZE;\n@@ -150,1 +150,5 @@\n-            dataBuf = Arrays.copyOf(dataBuf, newSize);\n+            byte[] temp = new byte[newSize];\n+            if (dataBuf != null && dataIdx > 0) {\n+                System.arraycopy(dataBuf, 0, temp, 0, dataIdx);\n+            }\n+            dataBuf = temp;\n@@ -154,2 +158,2 @@\n-            System.arraycopy(in, inOfs, dataBuf, startIdx, inLen);\n-            dataIdx = startIdx + inLen;\n+            System.arraycopy(in, inOfs, dataBuf, dataIdx, inLen);\n+            dataIdx += inLen;\n@@ -174,2 +178,2 @@\n-    \/\/ internal data buffer for encrypt, decrypt and unwrap calls\n-    \/\/ must use store() to store data into dataBuf as it will resize if needed\n+    \/\/ internal data buffer for encrypt, decrypt calls\n+    \/\/ must use store() to store data into 'dataBuf' as it will resize if needed\n@@ -188,1 +192,1 @@\n-        this.dataBuf = new byte[40];\n+        this.dataBuf = null;\n@@ -250,5 +254,3 @@\n-        int result = inLen;\n-        int buffered = dataIdx - SEMI_BLKSIZE;\n-        if (buffered > 0) {\n-            result = Math.addExact(result, buffered);\n-        }\n+\n+        int result;\n+\n@@ -256,1 +258,4 @@\n-            \/\/ calculate padding length first\n+            result = (dataIdx > 0?\n+                    Math.addExact(inLen, dataIdx - SEMI_BLKSIZE) : inLen);\n+            \/\/ calculate padding length based on plaintext length\n+            int padLen = 0;\n@@ -258,1 +263,1 @@\n-                result = Math.addExact(result, padding.padLength(result));\n+                padLen = padding.padLength(result);\n@@ -262,1 +267,1 @@\n-                    result = Math.addExact(result, SEMI_BLKSIZE - n);\n+                    padLen = SEMI_BLKSIZE - n;\n@@ -265,2 +270,2 @@\n-            \/\/ then add the first semiblock\n-            result = Math.addExact(result, SEMI_BLKSIZE);\n+            \/\/ then add the first semiblock and padLen to result\n+            result = Math.addExact(result, SEMI_BLKSIZE + padLen);\n@@ -268,1 +273,4 @@\n-            result -= SEMI_BLKSIZE;\n+            result = inLen - SEMI_BLKSIZE;\n+            if (dataIdx > 0) {\n+                result = Math.addExact(result, dataIdx);\n+            }\n@@ -295,0 +303,1 @@\n+            dataBuf = null;\n@@ -399,1 +408,2 @@\n-            throw new IllegalStateException(\"Cipher not initialized for update\");\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for update\");\n@@ -425,1 +435,2 @@\n-            throw new IllegalStateException(\"Cipher not initialized for update\");\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for update\");\n@@ -432,4 +443,4 @@\n-    private void implUpdate(byte[] in, int inOffset, int inLen) {\n-        boolean encrypting = (opmode == Cipher.ENCRYPT_MODE ||\n-                opmode == Cipher.WRAP_MODE);\n-        if (encrypting && dataIdx == 0) {\n+    private void implUpdate(byte[] in, int inOfs, int inLen) {\n+        if (inLen <= 0) return;\n+\n+        if (opmode == Cipher.ENCRYPT_MODE && dataIdx == 0) {\n@@ -437,1 +448,1 @@\n-            dataIdx += SEMI_BLKSIZE;\n+            dataIdx = SEMI_BLKSIZE;\n@@ -439,1 +450,1 @@\n-        store(dataIdx, in, inOffset, inLen);\n+        store(in, inOfs, inLen);\n@@ -457,4 +468,3 @@\n-        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n-            throw new IllegalStateException\n-                    (\"Cipher not initialized for doFinal\");\n-        }\n+\n+        int estOutLen = engineGetOutputSize(inLen);\n+        byte[] out = new byte[estOutLen];\n@@ -462,3 +472,7 @@\n-            \/\/ implDoFinal() use internal 'dataBuf' as output buffer\n-            int outLen = implDoFinal(in, inOfs, inLen);\n-            return Arrays.copyOf(dataBuf, outLen);\n+            int outLen = engineDoFinal(in, inOfs, inLen, out, 0);\n+\n+            if (outLen < estOutLen) {\n+                return Arrays.copyOf(out, outLen);\n+            } else {\n+                return out;\n+            }\n@@ -489,0 +503,1 @@\n+\n@@ -493,0 +508,1 @@\n+\n@@ -497,5 +513,22 @@\n-        \/\/ implDoFinal() use internal 'dataBuf' as output buffer\n-        int outLen = implDoFinal(in, inOfs, inLen);\n-        \/\/ only write out the result after verification succeeds\n-        System.arraycopy(dataBuf, 0, out, outOfs, outLen);\n-        return outLen;\n+\n+        try {\n+            \/\/ cannot write out the result for decryption due to verification\n+            \/\/ requirement\n+            if (outOfs == 0 && opmode == Cipher.ENCRYPT_MODE) {\n+                return implDoFinal(in, inOfs, inLen, out);\n+            } else {\n+                \/\/ use 'dataBuf' as output buffer and then copy into 'out'\n+                \/\/ make sure 'dataBuf' is large enough\n+                store(null, 0, inLen);\n+                int outLen = implDoFinal(in, inOfs, inLen, dataBuf);\n+                if (outLen > estOutLen) {\n+                    throw new AssertionError\n+                            (\"Actual output length exceeds estimated length\");\n+                }\n+                System.arraycopy(dataBuf, 0, out, outOfs, outLen);\n+                return outLen;\n+            }\n+        } finally {\n+            dataBuf = null;\n+            dataIdx = 0;\n+        }\n@@ -504,4 +537,5 @@\n-    \/\/ actual impl for various engineDoFinal(...) methods, i.e. write the first\n-    \/\/ semiblock containing IV if needed, buffer input data, and then perform\n-    \/\/ single-part encryption\/decrytion\n-    private int implDoFinal(byte[] in, int inOfs, int inLen)\n+    \/\/ actual impl for various engineDoFinal(...) methods.\n+    \/\/ prepare 'out' buffer with the buffered bytes in 'dataBuf',\n+    \/\/ and the to-be-processed bytes in 'in', then perform single-part\n+    \/\/ encryption\/decrytion over 'out' buffer\n+    private int implDoFinal(byte[] in, int inOfs, int inLen, byte[] out)\n@@ -510,5 +544,7 @@\n-        boolean encrypting = (opmode == Cipher.ENCRYPT_MODE ||\n-                opmode == Cipher.WRAP_MODE);\n-        if (encrypting && dataIdx == 0) {\n-            \/\/ the first semiblock is for iv, store data after it\n-            dataIdx += SEMI_BLKSIZE;\n+\n+        int len = (out == dataBuf? dataIdx : 0);\n+\n+        \/\/ copy over the buffered bytes if out != dataBuf\n+        if (out != dataBuf && dataIdx > 0) {\n+            System.arraycopy(dataBuf, 0, out, 0, dataIdx);\n+            len = dataIdx;\n@@ -516,2 +552,3 @@\n-        if (inLen > 0) {\n-            store(dataIdx, in, inOfs, inLen);\n+\n+        if (opmode == Cipher.ENCRYPT_MODE && len == 0) {\n+            len = SEMI_BLKSIZE; \/\/ reserve space for the ICV if encryption\n@@ -520,5 +557,3 @@\n-        try {\n-            return (encrypting? helperEncrypt(dataBuf, dataIdx) :\n-                    helperDecrypt(dataBuf, dataIdx));\n-        } finally {\n-            dataIdx = 0;\n+        if (inLen > 0) {\n+            System.arraycopy(in, inOfs, out, len, inLen);\n+            len += inLen;\n@@ -526,0 +561,3 @@\n+\n+        return (opmode == Cipher.ENCRYPT_MODE?\n+                helperEncrypt(out, len) : helperDecrypt(out, len));\n@@ -528,2 +566,3 @@\n-    \/\/ helper routine for encryption; assuming all data is in 'inBuf'\n-    \/\/ with the first semiblock reserved for iv\n+    \/\/ helper routine for in-place encryption.\n+    \/\/ 'inBuf' = semiblock | plain text | extra bytes if padding is used\n+    \/\/ 'inLen' = semiblock length + plain text length\n@@ -538,6 +577,1 @@\n-                if (inBuf == dataBuf) {\n-                    \/\/ enlarge dataBuf to fit padding bytes\n-                    store(dataIdx, null, 0, paddingLen);\n-                } else {\n-                    throw new ProviderException(\"data buffer too small\");\n-                }\n+                throw new AssertionError(\"encrypt buffer too small\");\n@@ -545,0 +579,1 @@\n+\n@@ -556,0 +591,3 @@\n+    \/\/ helper routine for in-place decryption.\n+    \/\/ 'inBuf' = cipher text\n+    \/\/ 'inLen' = cipher text length\n@@ -651,3 +689,3 @@\n-        int outOfs = SEMI_BLKSIZE;\n-        System.arraycopy(encoded, 0, out, outOfs, encoded.length);\n-        outOfs += encoded.length;\n+        int len = SEMI_BLKSIZE;\n+        System.arraycopy(encoded, 0, out, len, encoded.length);\n+        len += encoded.length;\n@@ -659,1 +697,1 @@\n-            int outLen = helperEncrypt(out, outOfs);\n+            int outLen = helperEncrypt(out, len);\n@@ -661,1 +699,1 @@\n-                throw new ProviderException(\"Need to resize output buffer\");\n+                throw new AssertionError(\"Wrong output buffer size\");\n@@ -701,3 +739,1 @@\n-        store(0, wrappedKey, 0, wrappedKey.length);\n-\n-        int outLen = 0;\n+        byte[] buf = wrappedKey.clone();\n@@ -705,2 +741,2 @@\n-            outLen = helperDecrypt(dataBuf, dataIdx);\n-            return ConstructKeys.constructKey(dataBuf, 0, outLen,\n+            int outLen = helperDecrypt(buf, buf.length);\n+            return ConstructKeys.constructKey(buf, 0, outLen,\n@@ -714,3 +750,1 @@\n-            Arrays.fill(dataBuf, 0, outLen, (byte) 0);\n-            \/\/ reset dataBuf for subsequent operations\n-            dataIdx = 0;\n+            Arrays.fill(buf, (byte) 0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":117,"deletions":83,"binary":false,"changes":200,"status":"modified"}]}