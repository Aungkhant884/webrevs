{"files":[{"patch":"@@ -200,1 +200,1 @@\n-        ps(\"Cipher\", \"AES\/KWP\/NoPadding\",\n+        psA(\"Cipher\", \"AES\/KWP\/NoPadding\",\n@@ -202,1 +202,1 @@\n-                null, attrs);\n+                attrs);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,2 @@\n-    AES_128$KWP$NoPadding(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\"),\n+    AES_128$KWP$NoPadding(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\",\n+            \"AESWrapPad_128\"),\n@@ -131,1 +132,2 @@\n-    AES_192$KWP$NoPadding(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\"),\n+    AES_192$KWP$NoPadding(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\",\n+            \"AESWrapPad_192\"),\n@@ -140,1 +142,2 @@\n-    AES_256$KWP$NoPadding(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\"),\n+    AES_256$KWP$NoPadding(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\",\n+            \"AESWrapPad_256\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -233,0 +233,1 @@\n+        store(\"AES\/KWP\/NoPadding\", null, \"AESWrapPad\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+            { \"AESWrap_128\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AESWrap_192\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AESWrap_256\", KEK, 32, DATA, 16, KW_AES256_128 },\n@@ -119,0 +122,12 @@\n+            { \"AESWrapPad\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AESWrapPad\", KEK, 16, DATA, 14, KWP_AES128_112 },\n+            { \"AESWrapPad\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AESWrapPad\", KEK, 24, DATA, 14, KWP_AES192_112 },\n+            { \"AESWrapPad\", KEK, 24, DATA, 21, KWP_AES192_168 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 7, KWP_AES256_56 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 14, KWP_AES256_112 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 21, KWP_AES256_168 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 28, KWP_AES256_224 },\n+            { \"AESWrapPad_128\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AESWrapPad_192\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AESWrapPad_256\", KEK, 32, DATA, 7, KWP_AES256_56 },\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/NISTWrapKAT.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @bug 8048599\n+ * @bug 8048599 8248268\n@@ -89,0 +89,4 @@\n+        AESWrapPad(\"AES\", \"AESWrapPad\", -1),\n+        AESWrapPad_128(\"AES\", \"AESWrapPad_128\", 128),\n+        AESWrapPad_192(\"AES\", \"AESWrapPad_192\", 192),\n+        AESWrapPad_256(\"AES\", \"AESWrapPad_256\", 256),\n@@ -290,0 +294,2 @@\n+\n+        out.println(\"Testing \" + wrapAlgo + \" cipher wrap\/unwrap\");\n@@ -300,1 +306,0 @@\n-        out.println(\"keysize : \" + wrapKey.getEncoded().length);\n@@ -312,0 +317,1 @@\n+            out.println(\"keysize : \" + wrapKey.getEncoded().length);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestCipherKeyWrapperTest.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8248268\n+ * @summary Verify cipher key size restriction is enforced properly with IKE\n+ * @run main TestKeySizeCheck\n+ *\/\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.security.Key;\n+import java.security.InvalidKeyException;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+public class TestKeySizeCheck {\n+\n+    private static final byte[] BYTES_32 = new byte[32];\n+    static {\n+        for (int i = 0; i < BYTES_32.length; i++) {\n+            BYTES_32[i] = (byte) i;\n+        }\n+    }\n+\n+    private static SecretKey getKey(int sizeInBytes) {\n+        if (sizeInBytes <= BYTES_32.length) {\n+            return new SecretKeySpec(BYTES_32, 0, sizeInBytes, \"AES\");\n+        } else {\n+            return new SecretKeySpec(new byte[sizeInBytes], \"AES\");\n+        }\n+    }\n+\n+    private static String getModeStr(int mode) {\n+        return (mode == Cipher.ENCRYPT_MODE? \"ENC\" : \"WRAP\");\n+    }\n+\n+    public static void test(String algo, int[] invalidKeySizes)\n+            throws Exception {\n+\n+        System.out.println(\"Testing \" + algo);\n+        Cipher c = Cipher.getInstance(algo, \"SunJCE\");\n+\n+        int[] modes = { Cipher.ENCRYPT_MODE, Cipher.WRAP_MODE };\n+        for (int ks : invalidKeySizes) {\n+            System.out.println(\"keysize: \" + ks);\n+            SecretKey key = getKey(ks);\n+\n+            for (int m : modes) {\n+                try {\n+                    c.init(m, key);\n+                    throw new RuntimeException(\"Expected IKE not thrown for \"\n+                            + getModeStr(m));\n+                } catch (InvalidKeyException ike) {\n+                    System.out.println(\" => expected IKE thrown for \"\n+                            + getModeStr(m));\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+\n+        test(\"AESWrap\", new int[] { 120, 264 });\n+        test(\"AESWrap_128\", new int[] { 192, 256 });\n+        test(\"AESWrap_192\", new int[] { 128, 256 });\n+        test(\"AESWrap_256\", new int[] { 128, 192 });\n+        test(\"AESWrapPad\", new int[] { 120, 264 });\n+        test(\"AESWrapPad_128\", new int[] { 192, 256 });\n+        test(\"AESWrapPad_192\", new int[] { 128, 256 });\n+        test(\"AESWrapPad_256\", new int[] { 128, 192 });\n+\n+        test(\"AES\/KW\/NoPadding\", new int[] { 120, 264 });\n+        test(\"AES_128\/KW\/NoPadding\", new int[] { 192, 256 });\n+        test(\"AES_192\/KW\/NoPadding\", new int[] { 128, 256 });\n+        test(\"AES_256\/KW\/NoPadding\", new int[] { 128, 192 });\n+        test(\"AES\/KWP\/NoPadding\", new int[] { 120, 264 });\n+        test(\"AES_128\/KWP\/NoPadding\", new int[] { 192, 256 });\n+        test(\"AES_192\/KWP\/NoPadding\", new int[] { 128, 256 });\n+        test(\"AES_256\/KWP\/NoPadding\", new int[] { 128, 192 });\n+\n+        System.out.println(\"All Tests Passed\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestKeySizeCheck.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}