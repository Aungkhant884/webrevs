{"files":[{"patch":"@@ -133,3 +133,4 @@\n-     * <p>The input <code>pt<\/code>, starting at <code>ptOfs<\/code>\n-     * and ending at <code>(ptOfs+ptLen-1)<\/code>, is encrypted.\n-     * The result is stored in <code>ct<\/code>, starting at <code>ctOfs<\/code>.\n+     * <p>The input <code>pt<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ptLen-1<\/code>, is encrypted.\n+     * The result is stored in place into <code>pt<\/code>, starting at\n+     * <code>0<\/code>.\n@@ -141,1 +142,1 @@\n-     * @param ptOfs the offset in <code>pt<\/code>\n+     * @param dummy1 the offset in <code>pt<\/code> which is always 0\n@@ -143,3 +144,3 @@\n-     * @param ct the buffer for the encryption result\n-     * @param ctOfs the offset in <code>ct<\/code>\n-     * @return the number of bytes placed into <code>ct<\/code>\n+     * @param dummy2 the output buffer for the encryption which is always pt\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>pt<\/code>\n@@ -148,2 +149,2 @@\n-    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy3,\n-            int dummy4) throws IllegalBlockSizeException {\n+    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n@@ -155,2 +156,2 @@\n-        \/\/ assert ptOfs == 0; ct == pt; ctOfs == 0;\n-        W(pt, ptLen, embeddedCipher);\n+\n+        W(iv, pt, ptLen, embeddedCipher);\n@@ -163,4 +164,7 @@\n-     * <p>The input <code>ct<\/code>, starting at <code>ctOfs<\/code>\n-     * and ending at <code>(ctOfs+ctLen-1)<\/code>, is decrypted.\n-     * The result is stored in <code>pt<\/code>, starting at\n-     * <code>ptOfs<\/code>.\n+     * <p>The input <code>ct<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ctLen-1<\/code>, is decrypted.\n+     * The result is stored in place into <code>ct<\/code>, starting at\n+     * <code>0<\/code>.\n+     *\n+     * <p>NOTE: Purpose of this special impl is for minimizing array\n+     * copying, those unused arguments are named as dummyN.\n@@ -172,1 +176,1 @@\n-     * @param ctOfs the offset in <code>ct<\/code>\n+     * @param dummy1 the offset in <code>ct<\/code> which is always 0\n@@ -174,3 +178,3 @@\n-     * @param pt the buffer for the decryption result\n-     * @param ptOfs the offset in <code>pt<\/code>\n-     * @return the number of bytes placed into <code>pt<\/code>\n+     * @param dummy2 the output buffer for the decryption which is always ct\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>ct<\/code>\n@@ -179,3 +183,2 @@\n-    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy3,\n-            int dummy4) throws IllegalBlockSizeException {\n-        \/\/ assert ctOfs == 0; ctLen == ct.length; pt == ct; ptOfs == 0\n+    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n@@ -191,1 +194,1 @@\n-        if (!Arrays.equals(ivOut, 0, ICV1.length, this.iv, 0, ICV1.length)) {\n+        if (!MessageDigest.isEqual(ivOut, this.iv)) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -51,9 +51,9 @@\n-    \/\/ generate internal 8-byte iv based on icv and input length\n-    private static byte[] generateIV(byte[] icv, int inLen) {\n-        if (icv.length != ICV2.length) throw new RuntimeException(\"Invalid iv\");\n-        byte[] newIv = Arrays.copyOf(icv, SEMI_BLKSIZE);\n-        newIv[4] = (byte) ((inLen >>> 24) & 0xFF);\n-        newIv[5] = (byte) ((inLen >>> 16) & 0xFF);\n-        newIv[6] = (byte) ((inLen >>> 8) & 0xFF);\n-        newIv[7] = (byte) (inLen & 0xFF);\n-        return newIv;\n+    \/\/ set the first semiblock of dest with iv and inLen\n+    private static void setIvAndLen(byte[] dest, byte[] iv, int inLen) {\n+        assert(dest.length >= SEMI_BLKSIZE) : \"buffer needs at least 8 bytes\";\n+\n+        System.arraycopy(iv, 0, dest, 0, iv.length);\n+        dest[4] = (byte) ((inLen >>> 24) & 0xFF);\n+        dest[5] = (byte) ((inLen >>> 16) & 0xFF);\n+        dest[6] = (byte) ((inLen >>> 8) & 0xFF);\n+        dest[7] = (byte) (inLen & 0xFF);\n@@ -62,3 +62,3 @@\n-    \/\/ validate the recovered internal iv against icv and return the\n-    \/\/ expected input length\n-    private static int validateIV(byte[] ivAndLen, byte[] icv)\n+    \/\/ validate the recovered internal ivAndLen semiblock against iv and\n+    \/\/ return the recovered input length\n+    private static int validateIV(byte[] ivAndLen, byte[] iv)\n@@ -66,2 +66,6 @@\n-        \/\/ check against icv and fail if not match\n-        if (!Arrays.equals(ivAndLen, 0, ICV2.length, icv, 0, ICV2.length)) {\n+        \/\/ check against iv and fail if not match\n+        boolean match = true;\n+        for (int i = 0; i < ICV2.length; i++) {\n+            match &= (ivAndLen[i] == iv[i]);\n+        }\n+        if (!match) {\n@@ -164,3 +168,4 @@\n-     * <p>The input <code>pt<\/code>, starting at <code>ptOfs<\/code>\n-     * and ending at <code>(ptOfs+ptLen-1)<\/code>, is encrypted.\n-     * The result is stored in <code>ct<\/code>, starting at <code>ctOfs<\/code>.\n+     * <p>The input <code>pt<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ptLen-1<\/code>, is encrypted.\n+     * The result is stored in place into <code>pt<\/code>, starting at\n+     * <code>0<\/code>.\n@@ -172,1 +177,1 @@\n-     * @param ptOfs the offset in <code>pt<\/code>\n+     * @param dummy1 the offset in <code>pt<\/code> which is always 0\n@@ -174,3 +179,3 @@\n-     * @param ct the buffer for the encryption result\n-     * @param ctOfs the offset in <code>ct<\/code>\n-     * @return the number of bytes placed into <code>ct<\/code>\n+     * @param dummy2 the output buffer for the encryption which is always pt\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>pt<\/code>\n@@ -179,3 +184,2 @@\n-    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy3,\n-            int dummy4) throws IllegalBlockSizeException {\n-        \/\/ assert ptOfs == 0; ptLen == pt.length; ct == pt; ctOfs == 0\n+    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n@@ -187,5 +191,0 @@\n-        \/\/ overwrite the ZERO4 place holder with actual input length\n-        pt[4] = (byte) ((actualLen >>> 24) & 0xFF);\n-        pt[5] = (byte) ((actualLen >>> 16) & 0xFF);\n-        pt[6] = (byte) ((actualLen >>> 8) & 0xFF);\n-        pt[7] = (byte) (actualLen & 0xFF);\n@@ -198,0 +197,1 @@\n+\n@@ -199,0 +199,2 @@\n+            \/\/ overwrite the first semiblock with iv and input length\n+            setIvAndLen(pt, iv, actualLen);\n@@ -201,1 +203,3 @@\n-            W(pt, ptLen, embeddedCipher);\n+            byte[] ivAndLen = new byte[SEMI_BLKSIZE];\n+            setIvAndLen(ivAndLen, iv, actualLen);\n+            W(ivAndLen, pt, ptLen, embeddedCipher);\n@@ -209,3 +213,4 @@\n-     * <p>The input <code>ct<\/code>, starting at <code>ctOfs<\/code>\n-     * and ending at <code>(ctOfs+ctLen-1)<\/code>, is decrypted.\n-     * The result is stored in <code>pt<\/code>, starting at <code>ptOfs<\/code>.\n+     * <p>The input <code>ct<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ctLen-1<\/code>, is decrypted.\n+     * The result is stored in place into <code>ct<\/code>, starting at\n+     * <code>0<\/code>.\n@@ -217,1 +222,1 @@\n-     * @param ctOfs the offset in <code>ct<\/code>\n+     * @param dummy1 the offset in <code>ct<\/code> which is always 0\n@@ -219,3 +224,3 @@\n-     * @param pt the buffer for the decryption result\n-     * @param ptOfs the offset in <code>pt<\/code>\n-     * @return the number of bytes placed into <code>pt<\/code>\n+     * @param dummy2 the output buffer for the decryption which is always ct\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>ct<\/code>\n@@ -224,3 +229,2 @@\n-    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy3,\n-            int dummy4) throws IllegalBlockSizeException {\n-        \/\/ assert ctOfs == 0; ctLen == ct.length; pt == ct; ptOfs == 0\n+    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n@@ -232,2 +236,0 @@\n-        \/\/ We cannot directly use 'out' as we don't know whether there\n-        \/\/ are padding bytes\n@@ -247,0 +249,4 @@\n+        if (padLen < 0 || padLen >= SEMI_BLKSIZE) {\n+            throw new IllegalBlockSizeException(\"Invalid KWP pad length \" +\n+                    padLen);\n+        }\n@@ -249,1 +255,1 @@\n-                throw new IllegalBlockSizeException(\"KWP Pad check failed\");\n+                throw new IllegalBlockSizeException(\"Invalid KWP pad value\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+     * @param firstSemiblk the first semi block value to overwrite the input\n+     *         with\n@@ -51,1 +53,5 @@\n-    static final void W(byte[] in, int inLen, SymmetricCipher cipher) {\n+    static final void W(byte[] firstSemiblk, byte[] in, int inLen,\n+            SymmetricCipher cipher) {\n+        \/\/ overwrite the first block of in with the iv semiblock\n+        System.arraycopy(firstSemiblk, 0, in, 0, SEMI_BLKSIZE);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,8 +126,5 @@\n-    \/\/ place holder for AESKeyWrapPadded\n-    private static final byte[] ZERO4 = new byte[4];\n-\n-    \/\/ validate the input length, resize and store the specified bytes into\n-    \/\/ internal 'dataBuf' and updates 'dataIdx' accordingly\n-    \/\/ NOTE: if 'in' == null, this method will ensure that dataBuf has enough\n-    \/\/ capacity for 'inLen' bytes but will attempt to copy bytes from 'in'\n-    private void store(byte[] in, int inOfs, int inLen) {\n+    \/\/ store the specified bytes, e.g. in[inOfs...(inOfs+inLen-1)] into\n+    \/\/ 'dataBuf' starting at startIdx.\n+    \/\/ NOTE: if in is null, this method will ensure that dataBuf has enough\n+    \/\/ capacity for inLen bytes but will NOT copy bytes from in.\n+    private void store(int startIdx, byte[] in, int inOfs, int inLen) {\n@@ -140,1 +137,1 @@\n-        int remain = Integer.MAX_VALUE - dataIdx;\n+        int remain = Integer.MAX_VALUE - startIdx;\n@@ -146,4 +143,4 @@\n-        \/\/ re-size dataBuf to the smallest (n * BLKSIZE) + SEMI_BLKSIZE)\n-        if (dataBuf.length - dataIdx < inLen) {\n-            int newSize = Math.addExact(dataIdx, inLen);\n-            int lastBlk = (dataIdx + inLen - SEMI_BLKSIZE) % BLKSIZE;\n+        \/\/ resize dataBuf to the smallest (n * BLKSIZE) + SEMI_BLKSIZE)\n+        if (dataBuf.length - startIdx < inLen) {\n+            int newSize = Math.addExact(startIdx, inLen);\n+            int lastBlk = (startIdx + inLen - SEMI_BLKSIZE) % BLKSIZE;\n@@ -157,2 +154,2 @@\n-            System.arraycopy(in, inOfs, dataBuf, dataIdx, inLen);\n-            dataIdx += inLen;\n+            System.arraycopy(in, inOfs, dataBuf, startIdx, inLen);\n+            dataIdx = startIdx + inLen;\n@@ -168,2 +165,2 @@\n-    \/\/ encrypting or decrypting?\n-    protected boolean decrypting = false;\n+    \/\/ encrypt\/wrap or decrypt\/unwrap?\n+    private int opmode = -1; \/\/ must be set by init(..)\n@@ -177,1 +174,1 @@\n-    \/\/ data buffering used for encrypt, decrypt and unwrap calls\n+    \/\/ internal data buffer for encrypt, decrypt and unwrap calls\n@@ -212,2 +209,2 @@\n-     * Sets the padding mechanism of this cipher. Currently, only\n-     * \"NoPadding\" scheme is accepted for this cipher.\n+     * Sets the padding mechanism of this cipher. The specified padding\n+     * scheme should match what this cipher is configured with.\n@@ -224,3 +221,3 @@\n-                this.padding instanceof PKCS5Padding &&\n-                \"PKCS5Padding\".equalsIgnoreCase(padding)) {\n-            throw new NoSuchPaddingException();\n+                 this.padding instanceof PKCS5Padding &&\n+                 !\"PKCS5Padding\".equalsIgnoreCase(padding)) {\n+            throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n@@ -258,1 +255,1 @@\n-        if (!decrypting) {\n+        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE) {\n@@ -286,19 +283,0 @@\n-    \/\/ write the IV semi-block into the specified buf\n-    private int writeIvSemiBlock(byte[] buf) {\n-        byte[] iv = cipher.getIV();\n-        if (buf == dataBuf) {\n-            store(iv, 0, iv.length);\n-            if (cipher instanceof AESKeyWrapPadded) {\n-                \/\/ write ZERO4 as place holder for now\n-                store(ZERO4, 0, 4);\n-            }\n-        } else {\n-            System.arraycopy(iv, 0, buf, 0, iv.length);\n-            if (cipher instanceof AESKeyWrapPadded) {\n-                \/\/ write ZERO4 as place holder for now\n-                System.arraycopy(ZERO4, 0, dataBuf, iv.length, 4);\n-            }\n-        }\n-        return SEMI_BLKSIZE;\n-    }\n-\n@@ -308,2 +286,3 @@\n-        decrypting = (opmode == Cipher.DECRYPT_MODE ||\n-                opmode == Cipher.UNWRAP_MODE);\n+        if (opmode < Cipher.ENCRYPT_MODE || opmode > Cipher.UNWRAP_MODE) {\n+            throw new RuntimeException(\"Invalid opmode for Cipher\");\n+        }\n@@ -314,0 +293,3 @@\n+        this.opmode = opmode;\n+        boolean decrypting = (opmode == Cipher.DECRYPT_MODE ||\n+                opmode == Cipher.UNWRAP_MODE);\n@@ -339,1 +321,1 @@\n-            throw new AssertionError();\n+            throw new AssertionError(iae);\n@@ -419,2 +401,2 @@\n-        if (!decrypting && dataIdx == 0) {\n-            writeIvSemiBlock(dataBuf);\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException(\"Cipher not initialized for update\");\n@@ -422,1 +404,1 @@\n-        store(in, inOffset, inLen);\n+        implUpdate(in, inOffset, inLen);\n@@ -445,3 +427,2 @@\n-\n-        if (!decrypting && dataIdx == 0) {\n-            writeIvSemiBlock(dataBuf);\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException(\"Cipher not initialized for update\");\n@@ -449,2 +430,1 @@\n-\n-        store(in, inOffset, inLen);\n+        implUpdate(in, inOffset, inLen);\n@@ -454,0 +434,11 @@\n+    \/\/ actual impl for various engineUpdate(...) methods\n+    private void implUpdate(byte[] in, int inOffset, int inLen) {\n+        boolean encrypting = (opmode == Cipher.ENCRYPT_MODE ||\n+                opmode == Cipher.WRAP_MODE);\n+        if (encrypting && dataIdx == 0) {\n+            \/\/ the first semiblock is for iv, store data after it\n+            dataIdx += SEMI_BLKSIZE;\n+        }\n+        store(dataIdx, in, inOffset, inLen);\n+    }\n+\n@@ -469,23 +460,3 @@\n-        if (!decrypting && dataIdx == 0) {\n-            writeIvSemiBlock(dataBuf);\n-        }\n-\n-        if (inLen > 0) {\n-            store(in, inOfs, inLen);\n-        }\n-\n-        \/\/ if enc, add padding\n-        if (!decrypting) {\n-            int actualLen = dataIdx - SEMI_BLKSIZE;\n-            if (padding != null) {\n-                int paddingLen = padding.padLength(actualLen);\n-                \/\/ check and re-size dataBuf if needed\n-                store(null, 0, paddingLen);\n-                try {\n-                    padding.padWithLen(dataBuf, dataIdx, paddingLen);\n-                    dataIdx += paddingLen;\n-                } catch (ShortBufferException sbe) {\n-                    \/\/ should never happen\n-                    throw new AssertionError();\n-                }\n-            }\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for doFinal\");\n@@ -494,14 +465,2 @@\n-            int outLen;\n-            if (decrypting) {\n-                outLen = cipher.decryptFinal(dataBuf, 0, dataIdx, null, -1);\n-                \/\/ unpad if padding is used\n-                if (padding != null) {\n-                    int padIdx = padding.unpad(dataBuf, 0, outLen);\n-                    if (padIdx <= 0) {\n-                        throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n-                    }\n-                    outLen = padIdx;\n-                }\n-            } else {\n-                outLen = cipher.encryptFinal(dataBuf, 0, dataIdx, null, -1);\n-            }\n+            \/\/ implDoFinal() use internal 'dataBuf' as output buffer\n+            int outLen = implDoFinal(in, inOfs, inLen);\n@@ -511,4 +470,1 @@\n-            throw new AssertionError();\n-        } finally {\n-            \/\/ reset dataBuf for subsequent operations\n-            dataIdx = 0;\n+            throw new AssertionError(sbe);\n@@ -536,1 +492,4 @@\n-\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for doFinal\");\n+        }\n@@ -541,3 +500,18 @@\n-\n-        if (!decrypting && dataIdx == 0) {\n-            writeIvSemiBlock(dataBuf);\n+        \/\/ implDoFinal() use internal 'dataBuf' as output buffer\n+        int outLen = implDoFinal(in, inOfs, inLen);\n+        \/\/ only write out the result after verification succeeds\n+        System.arraycopy(dataBuf, 0, out, outOfs, outLen);\n+        return outLen;\n+    }\n+\n+    \/\/ actual impl for various engineDoFinal(...) methods, i.e. write the first\n+    \/\/ semiblock containing IV if needed, buffer input data, and then perform\n+    \/\/ single-part encryption\/decrytion\n+    private int implDoFinal(byte[] in, int inOfs, int inLen)\n+        throws IllegalBlockSizeException, BadPaddingException,\n+            ShortBufferException {\n+        boolean encrypting = (opmode == Cipher.ENCRYPT_MODE ||\n+                opmode == Cipher.WRAP_MODE);\n+        if (encrypting && dataIdx == 0) {\n+            \/\/ the first semiblock is for iv, store data after it\n+            dataIdx += SEMI_BLKSIZE;\n@@ -545,1 +519,0 @@\n-\n@@ -547,1 +520,1 @@\n-            store(in, inOfs, inLen);\n+            store(dataIdx, in, inOfs, inLen);\n@@ -550,13 +523,23 @@\n-        \/\/ if enc, add padding\n-        if (!decrypting) {\n-            int actualLen = dataIdx - SEMI_BLKSIZE;\n-            if (padding != null) {\n-                int paddingLen = padding.padLength(actualLen);\n-                \/\/ check and re-size dataBuf if needed\n-                store(null, 0, paddingLen);\n-                try {\n-                    padding.padWithLen(dataBuf, dataIdx, paddingLen);\n-                    dataIdx += paddingLen;\n-                } catch (ShortBufferException sbe) {\n-                    \/\/ should never happen\n-                    throw new AssertionError();\n+        try {\n+            return (encrypting? helperEncrypt(dataBuf, dataIdx) :\n+                    helperDecrypt(dataBuf, dataIdx));\n+        } finally {\n+            dataIdx = 0;\n+        }\n+    }\n+\n+    \/\/ helper routine for encryption; assuming all data is in 'inBuf'\n+    \/\/ with the first semiblock reserved for iv\n+    private int helperEncrypt(byte[] inBuf, int inLen)\n+            throws IllegalBlockSizeException, ShortBufferException {\n+\n+        \/\/ pad data if padding is used\n+        if (padding != null) {\n+            int paddingLen = padding.padLength(inLen - SEMI_BLKSIZE);\n+\n+            if (inLen + paddingLen > inBuf.length) {\n+                if (inBuf == dataBuf) {\n+                    \/\/ enlarge dataBuf to fit padding bytes\n+                    store(dataIdx, null, 0, paddingLen);\n+                } else {\n+                    throw new ProviderException(\"data buffer too small\");\n@@ -565,0 +548,7 @@\n+            try {\n+                padding.padWithLen(inBuf, inLen, paddingLen);\n+                inLen += paddingLen;\n+            } catch (ShortBufferException sbe) {\n+                \/\/ should never happen\n+                throw new AssertionError(sbe);\n+            }\n@@ -566,14 +556,13 @@\n-        try {\n-            int outLen;\n-            if (decrypting) {\n-                outLen = cipher.decryptFinal(dataBuf, 0, dataIdx, null, -1);\n-                \/\/ unpad if padding is used\n-                if (padding != null) {\n-                    int padIdx = padding.unpad(dataBuf, 0, outLen);\n-                    if (padIdx <= 0) {\n-                        throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n-                    }\n-                    outLen = padIdx;\n-                }\n-            } else {\n-                outLen = cipher.encryptFinal(dataBuf, 0, dataIdx, null, -1);\n+        return cipher.encryptFinal(inBuf, 0, inLen, null, 0);\n+    }\n+\n+    private int helperDecrypt(byte[] inBuf, int inLen)\n+            throws IllegalBlockSizeException, BadPaddingException,\n+            ShortBufferException {\n+\n+        int outLen = cipher.decryptFinal(inBuf, 0, inLen, null, 0);\n+        \/\/ unpad data if padding is used\n+        if (padding != null) {\n+            int padIdx = padding.unpad(inBuf, 0, outLen);\n+            if (padIdx <= 0) {\n+                throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n@@ -581,9 +570,1 @@\n-            \/\/ only write out the result after verification succeeds\n-            System.arraycopy(dataBuf, 0, out, outOfs, outLen);\n-            return outLen;\n-        } catch (ShortBufferException sbe) {\n-            \/\/ should never happen\n-            throw new AssertionError();\n-        } finally {\n-            \/\/ reset dataBuf for subsequent operations\n-            dataIdx = 0;\n+            outLen = padIdx;\n@@ -591,0 +572,1 @@\n+        return outLen;\n@@ -662,0 +644,3 @@\n+        if (opmode != Cipher.WRAP_MODE) {\n+            throw new IllegalStateException(\"Cipher not initialized for wrap\");\n+        }\n@@ -667,1 +652,0 @@\n-        int keyLen = encoded.length;\n@@ -669,1 +653,1 @@\n-        byte[] out = new byte[engineGetOutputSize(keyLen)];\n+        byte[] out = new byte[engineGetOutputSize(encoded.length)];\n@@ -671,3 +655,4 @@\n-        int outOfs = writeIvSemiBlock(out);\n-        System.arraycopy(encoded, 0, out, outOfs, keyLen);\n-        outOfs += keyLen;\n+        \/\/ reserve the first semiblock and do not write data\n+        int outOfs = SEMI_BLKSIZE;\n+        System.arraycopy(encoded, 0, out, outOfs, encoded.length);\n+        outOfs += encoded.length;\n@@ -678,13 +663,0 @@\n-        \/\/ add padding\n-        if (padding != null) {\n-            int actualLen = outOfs - SEMI_BLKSIZE;\n-            int paddingLen = padding.padLength(actualLen);\n-\n-            try {\n-                padding.padWithLen(out, outOfs, paddingLen);\n-                outOfs += paddingLen;\n-            } catch (ShortBufferException sbe) {\n-                \/\/ should never happen\n-                throw new AssertionError();\n-            }\n-        }\n@@ -692,2 +664,4 @@\n-            int outLen = cipher.encryptFinal(out, 0, outOfs, null, -1);\n-            \/\/ assert outLen == out.length\n+            int outLen = helperEncrypt(out, outOfs);\n+            if (outLen != out.length) {\n+                throw new ProviderException(\"Need to resize output buffer\");\n+            }\n@@ -727,1 +701,6 @@\n-        store(wrappedKey, 0, wrappedKey.length);\n+        if (opmode != Cipher.UNWRAP_MODE) {\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for unwrap\");\n+        }\n+\n+        store(0, wrappedKey, 0, wrappedKey.length);\n@@ -731,9 +710,1 @@\n-            outLen = cipher.decryptFinal(dataBuf, 0, dataIdx, null, -1);\n-            \/\/ unpad if padding is used\n-            if (padding != null) {\n-                int padIdx = padding.unpad(dataBuf, 0, outLen);\n-                if (padIdx <= 0) {\n-                    throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n-                }\n-                outLen = padIdx;\n-            }\n+            outLen = helperDecrypt(dataBuf, dataIdx);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":138,"deletions":167,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -133,0 +133,101 @@\n+            \/\/ some more test vectors for KW and KWP\n+            \/\/ from csrc.nist.gov\/groups\/STM\/cavp\/documents\/mac\/kwtestvectors.zip\n+            { \"AES\/KW\/NoPadding\", \"7575da3a93607cc2bfd8cec7aadfd9a6\", 16,\n+              \"42136d3c384a3eeac95a066fd28fed3f\", 16,\n+              \"031f6bd7e61e643df68594816f64caa3f56fabea2548f5fb\" },\n+            { \"AES\/KW\/NoPadding\", \"e5d058e7f1c22c016c4e1cc9b26b9f8f\", 16,\n+              \"7f604e9b8d39d3c91e193fe6f196c1e3da6211a7c9a33b8873b64b138d1803\" +\n+              \"e4\", 32,\n+              \"60b9f8ac797c56e01e9b5f84d65816a980777869f67991a0e6dc19b8cd75c9\" +\n+              \"b54db4a38456bbd6f3\" },\n+            { \"AES\/KW\/NoPadding\", \"67ae4270bcdd31e8326b7e7f94c80276\", 16,\n+              \"57e748b62fbc37ba25e904ee973d01b136cf7c1d0c8c5c87\", 24,\n+              \"96cec0e3272a21faa550a857957aa38ce3c1cf06f0dd9f5b5c5c422cef6c69\" +\n+              \"a1\" },\n+            { \"AES\/KW\/NoPadding\", \"d7aa53aefad65cd95b57c8eee7b0a906\", 16,\n+              \"4a8daee6774751fc4489e837b8f7fba6896c70bb3d5e53053c92eb58046ee4\" +\n+              \"a7002e542311253b97\", 40,\n+              \"84ebd38cf06c674dcf186977de4a40c6dde3e7f49361a43420a887d2931b29\" +\n+              \"c23e2db72e95e4107001da925181bb7097\" },\n+            { \"AES\/KW\/NoPadding\", \"98311985c4661d7e811ee56070e6fecf\", 16,\n+              \"18840c96813864ef3093b48cdde6ac5d78248b96d4a2cd1f15f0b56f98213d\" +\n+              \"bf87e1ccad04e0d4f1954c233ea3e48fdad8f2b1156e54e19e3b5f4a66d2e9\" +\n+              \"149032b876c51249165fe8c28e112a685b2d228a8ac308017574274af36a4e\" +\n+              \"a3877bcc9850bafe8fc0e0a712faca0dea98396f9143bc5819fe4933a806e9\" +\n+              \"b965133e3c695a45f0fbd6961798c400d7477287df64798b651e0d3009c13f\" +\n+              \"7a2246c28f983509b9e5339919f2cdffcdfc550693cba9491c00334c4a62d8\" +\n+              \"78c4d0ca57b1104bc0174968ea8e3730b9e68db49678b23cd508ebe3e12e94\" +\n+              \"b0ad3791023a8ef95473f0b32f906738f34e94e45a4480ad768072e1853adb\" +\n+              \"63996b9ac27a1dade70804b82290a2274c6dcc3ccd40a8b38a56a5eb03f590\" +\n+              \"75de015e8f9096f53549f6374e02da947fb849287a447f757cc340b6bded71\" +\n+              \"d480988b6d2fcd984fba841470519830304667fef0a577b4cf84f76aef9deb\" +\n+              \"84dde36abfbd76673c17113dbea7a3e24bf9b57a8fd17173a1ef91497b732b\" +\n+              \"3fa8889bed58a503a0d3e20bc27ec4dbf5d13a93cbad05495e3df15e1fe34a\" +\n+              \"3a6d6f648ea4aa60b2f114f30944ae593675dac2db188f90a3c483fb82cec0\" +\n+              \"f0d295544d798b62cdcb51c6c036af1a341d78babf87b92609c1d866e311a4\" +\n+              \"6abccc8ba8c6a41420359bb061d7e752c0ed25990eef57c9f9e190572203f8\" +\n+              \"c473edf8cfc8c26d34e37240f45ded97\", 512,\n+              \"625aea9122b7b57b9f36446f9053acc42c6435a7f69d91b41547026f833291\" +\n+              \"d488e477c7ccba698c143633a304f463d6af4a3e72c189234fcfc360013e65\" +\n+              \"b07b7f7a36c529d3fdbbdbd6224bf100c14bc5354893b44790f54c739a2b1f\" +\n+              \"5bda82d70fb600ed9b0606dbddea52e508b492b72d8779856274aaaaddc0a3\" +\n+              \"edb6cfc788b603101bedfcc3f44baa62336bd950c2e349d5daf04f2e23ec26\" +\n+              \"28893d214e277569c565e5e6aa8b72ffa14118a3b57f814b4deb179980b5ee\" +\n+              \"efa4fd93f1751850466e929be537801babc2120f3ff1ffe5fea813ec7788ea\" +\n+              \"f43f5ef657e5af48395c3ad11aaf741549090b58670695f7c95c68e00576ca\" +\n+              \"18ef0313f2b4b757219fc8db3dc2db28721d6f912547ebfebcd96935c3100a\" +\n+              \"a4e4df9955acae1b4e2c10df1166d46c4285ab631c6d2ce58ad3ae99c07c01\" +\n+              \"9dcd15958694055281ccd6f803af290431f188cc4c429e84a4c30fd9c63968\" +\n+              \"dfd0951c417efb71921c207de172a9546bdd3e2bb35b45e140892c649f88c3\" +\n+              \"1a438f864e801a69f8010aa3d77a26601a7a89067c81b0f7e70d8e82f21f88\" +\n+              \"c7d0bb0c8ca0db875d6c3f8c6f6d709bbb31c7da2e31f3571daa2c5ab13bfc\" +\n+              \"16624cf35abd526e84269fb45bbd2fcd8c383d6fbb700bc4b5205b3ef8c432\" +\n+              \"3dc0d9e0370e56a3d1e5e76aa4de082e4c2a0afd092845bd5dab52a4594318\" +\n+              \"1461b76e3984b95f48bea80a94944241d04b5634c86274e7\" },\n+            { \"AES\/KWP\/NoPadding\", \"6decf10a1caf8e3b80c7a4be8c9c84e8\", 16,\n+              \"49\", 1, \"01a7d657fc4a5b216f261cca4d052c2b\" },\n+            { \"AES\/KWP\/NoPadding\", \"a8e06da625a65b25cf5030826830b661\", 16,\n+              \"43acff293120dd5d\", 8, \"b6f967616dd8d772e9fea295a456dba7\" },\n+            { \"AES\/KWP\/NoPadding\", \"7865e20f3c21659ab4690b629cdf3cc4\", 16,\n+              \"bd6843d420378dc896\", 9,\n+              \"41eca956d4aa047eb5cf4efe659661e74db6f8c564e23500\" },\n+            { \"AES\/KWP\/NoPadding\", \"be96dc195ec034d616486ed70e97fe83\", 16,\n+              \"85b5437b6335ebba7635903a4493d12a77d9357a9e0dbc013456d85f1d3201\",\n+              31,\n+              \"974769b3a7b4d5d32985f87fddf9990631e5610fbfb278387b58b1f48e05c7\" +\n+              \"7d2fb7575c5169eb0e\" },\n+            { \"AES\/KWP\/NoPadding\", \"0e54956a24c7d4a343f90269fb18a17f\", 16,\n+              \"817ddabdc5d215eee233adff97e92193c6beec52a71340477f70243a794ce9\" +\n+              \"54af51e356c9940e4ab198f0e68c543355f65ad179cb2d60dd369eaeb9ed14\" +\n+              \"1fb18c9e4054ac7fdc83506896990a4d20833d2d6e9a34938796ee67c9d7d2\" +\n+              \"3058544a4a35f2954103ce443a95a7e785602075ca0a73da37899e4568106b\" +\n+              \"b2dbf1f901377d4d3380c70fa5175ebc550481ac6f15986a4407fde5c23ff3\" +\n+              \"17e37544c0a25f87117506597db5bb79850c86247b73a5d0090417d63e4c25\" +\n+              \"7ea0220c2c04db07a34f0ab7954e1dfa2007a1466795c4d0c2aa09ca3986c0\" +\n+              \"28185b43a466526594afc9c891c263a7c608304bc1957c9873f544dc71e6f8\" +\n+              \"47c48d32026ed03b2333825452ee7e12a50e1cd7d678319264c65f78001996\" +\n+              \"d37fae7f9861fbd21cb506c2f8a3b0ee53c7debe17111b6e3f78a5c5677857\" +\n+              \"b082c2c4943dfd1edf6337fea98a44fc25928361156ef38d865948b979cf6f\" +\n+              \"4b46bd2119f12f0891cef7fc9d0638fd105fc05f9968d16948d1cb820751e8\" +\n+              \"2e44cb68e99d4f072ffd1577da6c0631b5827bec7e1b9ec72d18b74cf5f233\" +\n+              \"e85013c1668ceb5d7a1f5e0f016b0ff726a0a9d41e2cea8e14a2f56492b146\" +\n+              \"06d3fafd8ac141335f39f90d56863735628e8f17be90e100ef0785f3cd57db\" +\n+              \"8b9d89a6b2189dc2ea00c285d2657983f8bd7883c215477e67a55556401f1d\" +\n+              \"8b27d4e0d541c7fb7ace370c2e428884\", 512,\n+              \"876f3e53ba9cf4f6a521ac198bc813d0ede0f862ab6082e3e0a06ad82b4f27\" +\n+              \"9582f7c43bb63574608446bc2a05f401a68f74086cf2776b4b3df6b3679c2e\" +\n+              \"dfb91c024db54c6831e0752ae6f86c7596462de905ee0be908c1b9d043ecaf\" +\n+              \"e2ad1cbddb904e18ebc9b7a107031be3a87059516a3d1257812d9c801b0b9f\" +\n+              \"21539e70c47150c128d87c5e58fa6e4371aedde69c7b5cd16b73ac42267632\" +\n+              \"8131f3ac48c602bb6e0741805aad9d23b33b3523b86cf0588cdf9dc6c4d5f9\" +\n+              \"fa43d88ca17976eaf48fb37a41a598266da04144373df5631cc5126341c200\" +\n+              \"a0c8499b29ae96e6e6e6c2bdf8d8903da62bf8ddae970569b695240e77f8ac\" +\n+              \"5b191da5034008b6ef21936858e69bac372bbafd8794f6b03711503c187552\" +\n+              \"8a9348681844edb199a0664d740f0f0b1f866c4248c80fe8b5700a3c4134cd\" +\n+              \"ddb17676e0cd37d6d81831a0f4adfba071bb0935502480eccd48b28be5954e\" +\n+              \"a6c7d873b51b8bd2b709c5b6132ed31296510915073c18f7012f0eff6a9aad\" +\n+              \"5340a19fd5e372d35260b718d9e4807b1954c24e6a4fd48e4dbb8f395474e9\" +\n+              \"9ab577367d2ab5ccaa18c947331047dc3986e213a878b41089aa221019dad4\" +\n+              \"191a4feefd095f8606c2700a46d71cbb13efb6957df925ec26071c04d04d5a\" +\n+              \"94e138e5fc5d1f059236aad76208077dcc607b1dd2086f9c04e33f955822b4\" +\n+              \"57eecd68bd5f24836ecedbac675e6ed93d8a787cb57ad68e\" },\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/NISTWrapKAT.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4953556 8210838\n+ * @bug 4953556 8210838 8248268\n@@ -42,1 +42,11 @@\n-    private static final String ALGO = \"DES\";\n+    private static final String[] TRANSFORMATIONS = {\n+        \"DES\/ECB\/PKCS5Padding\",\n+        \"AES\/KW\/NoPadding\",\n+        \"AES\/KW\/PKCS5Padding\",\n+        \"AES\/KWP\/NoPadding\",\n+    };\n+\n+    private static final SecretKey DES_KEY =\n+            new SecretKeySpec(new byte[8], \"DES\");\n+    private static final SecretKey AES_KEY =\n+            new SecretKeySpec(new byte[16], \"AES\");\n@@ -45,9 +55,13 @@\n-        TestCipherMode test = new TestCipherMode();\n-        System.out.println(\"Testing ENCRYPT_MODE...\");\n-        test.checkMode(Cipher.ENCRYPT_MODE, \"encryption\");\n-        System.out.println(\"Testing DECRYPT_MODE...\");\n-        test.checkMode(Cipher.DECRYPT_MODE, \"decryption\");\n-        System.out.println(\"Testing WRAP_MODE...\");\n-        test.checkMode(Cipher.WRAP_MODE, \"key wrapping\");\n-        System.out.println(\"Testing UNWRAP_MODE...\");\n-        test.checkMode(Cipher.UNWRAP_MODE, \"key unwrapping\");\n+        for (String t : TRANSFORMATIONS) {\n+            System.out.println(\"Testing SunJCE provider, Cipher \" + t );\n+\n+            TestCipherMode test = new TestCipherMode(t);\n+            System.out.println(\"Testing ENCRYPT_MODE...\");\n+            test.checkMode(Cipher.ENCRYPT_MODE, \"encryption\");\n+            System.out.println(\"Testing DECRYPT_MODE...\");\n+            test.checkMode(Cipher.DECRYPT_MODE, \"decryption\");\n+            System.out.println(\"Testing WRAP_MODE...\");\n+            test.checkMode(Cipher.WRAP_MODE, \"key wrapping\");\n+            System.out.println(\"Testing UNWRAP_MODE...\");\n+            test.checkMode(Cipher.UNWRAP_MODE, \"key unwrapping\");\n+        }\n@@ -60,10 +74,10 @@\n-    private TestCipherMode() throws NoSuchAlgorithmException,\n-    NoSuchProviderException, NoSuchPaddingException {\n-        c = Cipher.getInstance(ALGO + \"\/ECB\/PKCS5Padding\", \"SunJCE\");\n-        String output = c.toString();\n-        if (!output.equals(\n-                \"Cipher.DES\/ECB\/PKCS5Padding, mode: not initialized, algorithm from: SunJCE\")) {\n-            throw new RuntimeException(\n-                    \"Unexpected Cipher.toString() output:\" + output);\n-        }\n-        key = new SecretKeySpec(new byte[8], ALGO);\n+    private TestCipherMode(String transformation)\n+            throws NoSuchAlgorithmException, NoSuchProviderException,\n+            NoSuchPaddingException {\n+        c = Cipher.getInstance(transformation, \"SunJCE\");\n+        this.key = switch (transformation.split(\"\/\")[0]) {\n+            case \"DES\" -> DES_KEY;\n+            case \"AES\" -> AES_KEY;\n+            default -> throw new RuntimeException\n+                    (\"Error: Unsupported key algorithm\");\n+        };\n@@ -74,6 +88,0 @@\n-        String output = c.toString();\n-        if (!output.contains(\"Cipher.DES\/ECB\/PKCS5Padding\")\n-                && !output.contains(opString)\n-                && !output.contains(\"Algorithm from: SunJCE\")) {\n-            throw new Exception(\"Unexpected toString() output:\" + output);\n-        }\n@@ -92,1 +100,1 @@\n-                c.unwrap(new byte[16], ALGO, Cipher.SECRET_KEY);\n+                c.unwrap(new byte[16], key.getAlgorithm(), Cipher.SECRET_KEY);\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestCipherMode.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"}]}