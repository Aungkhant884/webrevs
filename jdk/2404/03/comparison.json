{"files":[{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import static com.sun.crypto.provider.KWUtil.*;\n+\n+\/**\n+ * This class implement the AES KeyWrap mode of operation as defined in\n+ * <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"<\/a>\n+ * and represents AES cipher in KW mode.\n+ *\/\n+class AESKeyWrap extends FeedbackCipher {\n+\n+    \/\/ default integrity check value (icv) if iv is not supplied\n+    private static final byte[] ICV1 = {\n+        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6,\n+        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6\n+    };\n+\n+    AESKeyWrap() {\n+        super(new AESCrypt());\n+    }\n+\n+    \/**\n+     * Gets the name of this feedback mode.\n+     *\n+     * @return the string <code>KW<\/code>\n+     *\/\n+    @Override\n+    String getFeedback() {\n+        return \"KW\";\n+    }\n+\n+    \/**\n+     * Save the current content of this cipher.\n+     *\/\n+    @Override\n+    void save() {\n+        throw new UnsupportedOperationException(\"save not supported\");\n+    };\n+\n+    \/**\n+     * Restores the content of this cipher to the previous saved one.\n+     *\/\n+    @Override\n+    void restore() {\n+        throw new UnsupportedOperationException(\"restore not supported\");\n+    };\n+\n+    \/**\n+     * Initializes the cipher in the specified mode with the given key\n+     * and iv.\n+     *\n+     * @param decrypting flag indicating encryption or decryption\n+     * @param algorithm the algorithm name\n+     * @param key the key\n+     * @param iv the iv\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given iv is\n+     * non-null and not the right length\n+     *\/\n+    @Override\n+    void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Invalid null key\");\n+        }\n+        if (iv != null && iv.length != ICV1.length) {\n+            throw new InvalidAlgorithmParameterException(\"Invalid IV\");\n+        }\n+        embeddedCipher.init(decrypting, algorithm, key);\n+        \/\/ iv is retrieved from IvParameterSpec.getIV() which is already cloned\n+        this.iv = (iv == null? ICV1 : iv);\n+    }\n+\n+    \/**\n+     * Resets the iv to its original value.\n+     * This is used when doFinal is called in the Cipher class, so that the\n+     * cipher can be reused (with its original iv).\n+     *\/\n+    @Override\n+    void reset() {\n+        throw new UnsupportedOperationException(\"reset not supported\");\n+    };\n+\n+\n+    \/\/ no support for multi-part encryption\n+    @Override\n+    int encrypt(byte[] pt, int ptOfs, int ptLen, byte[] ct, int ctOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/\/ no support for multi-part decryption\n+    @Override\n+    int decrypt(byte[] ct, int ctOfs, int ctLen, byte[] pt, int ptOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/**\n+     * Performs single-part encryption operation.\n+     *\n+     * <p>The input <code>pt<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ptLen-1<\/code>, is encrypted.\n+     * The result is stored in place into <code>pt<\/code>, starting at\n+     * <code>0<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param pt the input buffer with the data to be encrypted\n+     * @param dummy1 the offset in <code>pt<\/code> which is always 0\n+     * @param ptLen the length of the input data\n+     * @param dummy2 the output buffer for the encryption which is always pt\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>pt<\/code>\n+     *\/\n+    @Override\n+    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n+        \/\/ adjust the min value since pt contains the first semi-block\n+        if (ptLen < (BLKSIZE + SEMI_BLKSIZE) || (ptLen % SEMI_BLKSIZE) != 0) {\n+            throw new IllegalBlockSizeException(\"data should\" +\n+                \" be at least 16 bytes and multiples of 8\");\n+        }\n+\n+        W(iv, pt, ptLen, embeddedCipher);\n+        return ptLen;\n+    }\n+\n+    \/**\n+     * Performs single-part decryption operation.\n+     *\n+     * <p>The input <code>ct<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ctLen-1<\/code>, is decrypted.\n+     * The result is stored in place into <code>ct<\/code>, starting at\n+     * <code>0<\/code>.\n+     *\n+     * <p>NOTE: Purpose of this special impl is for minimizing array\n+     * copying, those unused arguments are named as dummyN.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param ct the input buffer with the data to be decrypted\n+     * @param dummy1 the offset in <code>ct<\/code> which is always 0\n+     * @param ctLen the length of the input data\n+     * @param dummy2 the output buffer for the decryption which is always ct\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>ct<\/code>\n+     *\/\n+    @Override\n+    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n+        if (ctLen < (BLKSIZE + SEMI_BLKSIZE) || (ctLen % SEMI_BLKSIZE) != 0) {\n+            throw new IllegalBlockSizeException\n+                (\"data should be at least 24 bytes and multiples of 8\");\n+        }\n+        byte[] ivOut = new byte[ICV1.length];\n+        W_INV(ct, ctLen, ivOut, embeddedCipher);\n+        ctLen -= SEMI_BLKSIZE;\n+\n+        \/\/ check against icv and fail if not match\n+        if (!MessageDigest.isEqual(ivOut, this.iv)) {\n+            throw new IllegalBlockSizeException(\"Integrity check failed\");\n+        }\n+        return ctLen;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import static com.sun.crypto.provider.KWUtil.*;\n+\n+\/**\n+ * This class implement the AES KeyWrap With Padding mode of operation as\n+ * defined in\n+ * <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"<\/a>\n+ * and represents AES cipher in KWP mode.\n+ *\/\n+class AESKeyWrapPadded extends FeedbackCipher {\n+\n+    \/\/ default integrity check value (icv) if iv is not supplied\n+    private static final byte[] ICV2 = {\n+        (byte) 0xA6, (byte) 0x59, (byte) 0x59, (byte) 0xA6,\n+    };\n+\n+    private static final byte[] PAD_BLK = new byte[SEMI_BLKSIZE - 1];\n+\n+    \/\/ set the first semiblock of dest with iv and inLen\n+    private static void setIvAndLen(byte[] dest, byte[] iv, int inLen) {\n+        assert(dest.length >= SEMI_BLKSIZE) : \"buffer needs at least 8 bytes\";\n+\n+        System.arraycopy(iv, 0, dest, 0, iv.length);\n+        dest[4] = (byte) ((inLen >>> 24) & 0xFF);\n+        dest[5] = (byte) ((inLen >>> 16) & 0xFF);\n+        dest[6] = (byte) ((inLen >>> 8) & 0xFF);\n+        dest[7] = (byte) (inLen & 0xFF);\n+    }\n+\n+    \/\/ validate the recovered internal ivAndLen semiblock against iv and\n+    \/\/ return the recovered input length\n+    private static int validateIV(byte[] ivAndLen, byte[] iv)\n+            throws IllegalBlockSizeException {\n+        \/\/ check against iv and fail if not match\n+        boolean match = true;\n+        for (int i = 0; i < ICV2.length; i++) {\n+            match &= (ivAndLen[i] == iv[i]);\n+        }\n+        if (!match) {\n+            throw new IllegalBlockSizeException(\"Integrity check failed\");\n+        }\n+        int outLen = ivAndLen[4];\n+\n+        for (int k = 5; k < SEMI_BLKSIZE; k++) {\n+            if (outLen != 0) {\n+                outLen <<= SEMI_BLKSIZE;\n+            }\n+            outLen |= ivAndLen[k] & 0xFF;\n+        }\n+        return outLen;\n+    }\n+\n+    AESKeyWrapPadded() {\n+        super(new AESCrypt());\n+    }\n+\n+    \/**\n+     * Gets the name of this feedback mode.\n+     *\n+     * @return the string <code>KW<\/code>\n+     *\/\n+    @Override\n+    String getFeedback() {\n+        return \"KWP\";\n+    }\n+\n+    \/**\n+     * Save the current content of this cipher.\n+     *\/\n+    @Override\n+    void save() {\n+        throw new UnsupportedOperationException(\"save not supported\");\n+    };\n+\n+    \/**\n+     * Restores the content of this cipher to the previous saved one.\n+     *\/\n+    @Override\n+    void restore() {\n+        throw new UnsupportedOperationException(\"restore not supported\");\n+    };\n+\n+    \/**\n+     * Initializes the cipher in the specified mode with the given key\n+     * and iv.\n+     *\n+     * @param decrypting flag indicating encryption or decryption\n+     * @param algorithm the algorithm name\n+     * @param key the key\n+     * @param iv the iv\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given iv is\n+     * non-null and not the right length\n+     *\/\n+    @Override\n+    void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Invalid null key\");\n+        }\n+        if (iv != null && iv.length != ICV2.length) {\n+            throw new InvalidAlgorithmParameterException(\"Invalid IV length\");\n+        }\n+        embeddedCipher.init(decrypting, algorithm, key);\n+        \/\/ iv is retrieved from IvParameterSpec.getIV() which is already cloned\n+        this.iv = (iv == null? ICV2 : iv);\n+    }\n+\n+    \/**\n+     * Resets the iv to its original value.\n+     * This is used when doFinal is called in the Cipher class, so that the\n+     * cipher can be reused (with its original iv).\n+     *\/\n+    @Override\n+    void reset() {\n+        throw new UnsupportedOperationException(\"reset not supported\");\n+    };\n+\n+    \/\/ no support for multi-part encryption\n+    @Override\n+    int encrypt(byte[] pt, int ptOfs, int ptLen, byte[] ct, int ctOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/\/ no support for multi-part decryption\n+    @Override\n+    int decrypt(byte[] ct, int ctOfs, int ctLen, byte[] pt, int ptOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/**\n+     * Performs single-part encryption operation.\n+     *\n+     * <p>The input <code>pt<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ptLen-1<\/code>, is encrypted.\n+     * The result is stored in place into <code>pt<\/code>, starting at\n+     * <code>0<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param pt the input buffer with the data to be encrypted\n+     * @param dummy1 the offset in <code>pt<\/code> which is always 0\n+     * @param ptLen the length of the input data\n+     * @param dummy2 the output buffer for the encryption which is always pt\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>pt<\/code>\n+     *\/\n+    @Override\n+    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n+        int actualLen = ptLen - SEMI_BLKSIZE;\n+        if (actualLen < 1) {\n+            throw new IllegalBlockSizeException\n+                (\"data should have at least 1 byte\");\n+        }\n+\n+        if (ptLen % SEMI_BLKSIZE != 0) {\n+            int rem = SEMI_BLKSIZE - (ptLen % SEMI_BLKSIZE);\n+            System.arraycopy(PAD_BLK, 0, pt, ptLen, rem);\n+            ptLen += rem;\n+        }\n+\n+        if (ptLen <= BLKSIZE) {\n+            \/\/ overwrite the first semiblock with iv and input length\n+            setIvAndLen(pt, iv, actualLen);\n+            embeddedCipher.encryptBlock(pt, 0, pt, 0);\n+        } else {\n+            byte[] ivAndLen = new byte[SEMI_BLKSIZE];\n+            setIvAndLen(ivAndLen, iv, actualLen);\n+            W(ivAndLen, pt, ptLen, embeddedCipher);\n+        }\n+        return ptLen;\n+    }\n+\n+    \/**\n+     * Performs single-part decryption operation.\n+     *\n+     * <p>The input <code>ct<\/code>, starting at <code>0<\/code>\n+     * and ending at <code>ctLen-1<\/code>, is decrypted.\n+     * The result is stored in place into <code>ct<\/code>, starting at\n+     * <code>0<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param ct the input buffer with the data to be decrypted\n+     * @param dummy1 the offset in <code>ct<\/code> which is always 0\n+     * @param ctLen the length of the input data\n+     * @param dummy2 the output buffer for the decryption which is always ct\n+     * @param dummy3 the offset in the output buffer which is always 0\n+     * @return the number of bytes placed into <code>ct<\/code>\n+     *\/\n+    @Override\n+    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy2,\n+            int dummy3) throws IllegalBlockSizeException {\n+        if (ctLen < BLKSIZE || ctLen % SEMI_BLKSIZE != 0) {\n+            throw new IllegalBlockSizeException\n+                (\"data should be at least 16 bytes and multiples of 8\");\n+        }\n+\n+        byte[] ivAndLen = new byte[SEMI_BLKSIZE];\n+        if (ctLen == BLKSIZE) {\n+            embeddedCipher.decryptBlock(ct, 0, ct, 0);\n+            System.arraycopy(ct, 0, ivAndLen, 0, SEMI_BLKSIZE);\n+            System.arraycopy(ct, SEMI_BLKSIZE, ct, 0, SEMI_BLKSIZE);\n+        } else {\n+            W_INV(ct, ctLen, ivAndLen, embeddedCipher);\n+        }\n+        ctLen -= SEMI_BLKSIZE;\n+\n+        int outLen = validateIV(ivAndLen, this.iv);\n+        \/\/ check padding bytes\n+        int padLen = ctLen - outLen;\n+        if (padLen < 0 || padLen >= SEMI_BLKSIZE) {\n+            throw new IllegalBlockSizeException(\"Invalid KWP pad length \" +\n+                    padLen);\n+        }\n+        for (int k = padLen; k > 0; k--) {\n+            if (ct[ctLen - k] != 0) {\n+                throw new IllegalBlockSizeException(\"Invalid KWP pad value\");\n+            }\n+        }\n+        return outLen;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -1,511 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.util.Arrays;\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-\n-\/**\n- * This class implements the AES KeyWrap algorithm as defined\n- * in <a href=http:\/\/www.w3.org\/TR\/xmlenc-core\/#sec-Alg-SymmetricKeyWrap>\n- * \"XML Encryption Syntax and Processing\" section 5.6.3 \"AES Key Wrap\".\n- * Note: only <code>ECB<\/code> mode and <code>NoPadding<\/code> padding\n- * can be used for this algorithm.\n- *\n- * @author Valerie Peng\n- *\n- *\n- * @see AESCipher\n- *\/\n-abstract class AESWrapCipher extends CipherSpi {\n-    public static final class General extends AESWrapCipher {\n-        public General() {\n-            super(-1);\n-        }\n-    }\n-    public static final class AES128 extends AESWrapCipher {\n-        public AES128() {\n-            super(16);\n-        }\n-    }\n-    public static final class AES192 extends AESWrapCipher {\n-        public AES192() {\n-            super(24);\n-        }\n-    }\n-    public static final class AES256 extends AESWrapCipher {\n-        public AES256() {\n-            super(32);\n-        }\n-    }\n-    private static final byte[] IV = {\n-        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6,\n-        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6\n-    };\n-\n-    private static final int blksize = AESConstants.AES_BLOCK_SIZE;\n-\n-    \/*\n-     * internal cipher object which does the real work.\n-     *\/\n-    private AESCrypt cipher;\n-\n-    \/*\n-     * are we encrypting or decrypting?\n-     *\/\n-    private boolean decrypting = false;\n-\n-    \/*\n-     * needed to support AES oids which associates a fixed key size\n-     * to the cipher object.\n-     *\/\n-    private final int fixedKeySize; \/\/ in bytes, -1 if no restriction\n-\n-    \/**\n-     * Creates an instance of AES KeyWrap cipher with default\n-     * mode, i.e. \"ECB\" and padding scheme, i.e. \"NoPadding\".\n-     *\/\n-    public AESWrapCipher(int keySize) {\n-        cipher = new AESCrypt();\n-        fixedKeySize = keySize;\n-\n-    }\n-\n-    \/**\n-     * Sets the mode of this cipher. Only \"ECB\" mode is accepted for this\n-     * cipher.\n-     *\n-     * @param mode the cipher mode\n-     *\n-     * @exception NoSuchAlgorithmException if the requested cipher mode\n-     * is not \"ECB\".\n-     *\/\n-    protected void engineSetMode(String mode)\n-        throws NoSuchAlgorithmException {\n-        if (!mode.equalsIgnoreCase(\"ECB\")) {\n-            throw new NoSuchAlgorithmException(mode + \" cannot be used\");\n-        }\n-    }\n-\n-    \/**\n-     * Sets the padding mechanism of this cipher. Only \"NoPadding\" schmem\n-     * is accepted for this cipher.\n-     *\n-     * @param padding the padding mechanism\n-     *\n-     * @exception NoSuchPaddingException if the requested padding mechanism\n-     * is not \"NoPadding\".\n-     *\/\n-    protected void engineSetPadding(String padding)\n-        throws NoSuchPaddingException {\n-        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n-            throw new NoSuchPaddingException(padding + \" cannot be used\");\n-        }\n-    }\n-\n-    \/**\n-     * Returns the block size (in bytes). i.e. 16 bytes.\n-     *\n-     * @return the block size (in bytes), i.e. 16 bytes.\n-     *\/\n-    protected int engineGetBlockSize() {\n-        return blksize;\n-    }\n-\n-    \/**\n-     * Returns the length in bytes that an output buffer would need to be\n-     * given the input length <code>inputLen<\/code> (in bytes).\n-     *\n-     * <p>The actual output length of the next <code>update<\/code> or\n-     * <code>doFinal<\/code> call may be smaller than the length returned\n-     * by this method.\n-     *\n-     * @param inputLen the input length (in bytes)\n-     *\n-     * @return the required output buffer size (in bytes)\n-     *\/\n-    protected int engineGetOutputSize(int inputLen) {\n-        \/\/ can only return an upper-limit if not initialized yet.\n-        int result = 0;\n-        if (decrypting) {\n-            result = inputLen - 8;\n-        } else {\n-            result = Math.addExact(inputLen, 8);\n-        }\n-        return (result < 0? 0:result);\n-    }\n-\n-    \/**\n-     * Returns the initialization vector (IV) which is null for this cipher.\n-     *\n-     * @return null for this cipher.\n-     *\/\n-    protected byte[] engineGetIV() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Initializes this cipher with a key and a source of randomness.\n-     *\n-     * <p>The cipher only supports the following two operation modes:<b>\n-     * Cipher.WRAP_MODE, and <b>\n-     * Cipher.UNWRAP_MODE.\n-     * <p>For modes other than the above two, UnsupportedOperationException\n-     * will be thrown.\n-     *\n-     * @param opmode the operation mode of this cipher. Only\n-     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n-     * @param key the secret key.\n-     * @param random the source of randomness.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher.\n-     *\/\n-    protected void engineInit(int opmode, Key key, SecureRandom random)\n-        throws InvalidKeyException {\n-        if (opmode == Cipher.WRAP_MODE) {\n-            decrypting = false;\n-        } else if (opmode == Cipher.UNWRAP_MODE) {\n-            decrypting = true;\n-        } else {\n-            throw new UnsupportedOperationException(\"This cipher can \" +\n-                \"only be used for key wrapping and unwrapping\");\n-        }\n-        AESCipher.checkKeySize(key, fixedKeySize);\n-        cipher.init(decrypting, key.getAlgorithm(), key.getEncoded());\n-    }\n-\n-    \/**\n-     * Initializes this cipher with a key, a set of algorithm parameters,\n-     * and a source of randomness.\n-     *\n-     * <p>The cipher only supports the following two operation modes:<b>\n-     * Cipher.WRAP_MODE, and <b>\n-     * Cipher.UNWRAP_MODE.\n-     * <p>For modes other than the above two, UnsupportedOperationException\n-     * will be thrown.\n-     *\n-     * @param opmode the operation mode of this cipher. Only\n-     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n-     * @param key the secret key.\n-     * @param params the algorithm parameters; must be null for this cipher.\n-     * @param random the source of randomness.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher\n-     * @exception InvalidAlgorithmParameterException if the given algorithm\n-     * parameters is not null.\n-     *\/\n-    protected void engineInit(int opmode, Key key,\n-                              AlgorithmParameterSpec params,\n-                              SecureRandom random)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (params != null) {\n-            throw new InvalidAlgorithmParameterException(\"This cipher \" +\n-                \"does not accept any parameters\");\n-        }\n-        engineInit(opmode, key, random);\n-    }\n-\n-    \/**\n-     * Initializes this cipher with a key, a set of algorithm parameters,\n-     * and a source of randomness.\n-     *\n-     * <p>The cipher only supports the following two operation modes:<b>\n-     * Cipher.WRAP_MODE, and <b>\n-     * Cipher.UNWRAP_MODE.\n-     * <p>For modes other than the above two, UnsupportedOperationException\n-     * will be thrown.\n-     *\n-     * @param opmode the operation mode of this cipher. Only\n-     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n-     * @param key the secret key.\n-     * @param params the algorithm parameters; must be null for this cipher.\n-     * @param random the source of randomness.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate.\n-     * @exception InvalidAlgorithmParameterException if the given algorithm\n-     * parameters is not null.\n-     *\/\n-    protected void engineInit(int opmode, Key key,\n-                              AlgorithmParameters params,\n-                              SecureRandom random)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (params != null) {\n-            throw new InvalidAlgorithmParameterException(\"This cipher \" +\n-                \"does not accept any parameters\");\n-        }\n-        engineInit(opmode, key, random);\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param in the input buffer.\n-     * @param inOffset the offset in <code>in<\/code> where the input\n-     * starts.\n-     * @param inLen the input length.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected byte[] engineUpdate(byte[] in, int inOffset, int inLen) {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param in the input buffer.\n-     * @param inOffset the offset in <code>in<\/code> where the input\n-     * starts.\n-     * @param inLen the input length.\n-     * @param out the buffer for the result.\n-     * @param outOffset the offset in <code>out<\/code> where the result\n-     * is stored.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected int engineUpdate(byte[] in, int inOffset, int inLen,\n-                               byte[] out, int outOffset)\n-        throws ShortBufferException {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param input the input buffer\n-     * @param inputOffset the offset in <code>in<\/code> where the input\n-     * starts\n-     * @param inputLen the input length.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected byte[] engineDoFinal(byte[] input, int inputOffset,\n-                                   int inputLen)\n-        throws IllegalBlockSizeException, BadPaddingException {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param in the input buffer.\n-     * @param inOffset the offset in <code>in<\/code> where the input\n-     * starts.\n-     * @param inLen the input length.\n-     * @param out the buffer for the result.\n-     * @param outOffset the ofset in <code>out<\/code> where the result\n-     * is stored.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected int engineDoFinal(byte[] in, int inOffset, int inLen,\n-                                byte[] out, int outOffset)\n-        throws IllegalBlockSizeException, ShortBufferException,\n-               BadPaddingException {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * Returns the parameters used with this cipher which is always null\n-     * for this cipher.\n-     *\n-     * @return null since this cipher does not use any parameters.\n-     *\/\n-    protected AlgorithmParameters engineGetParameters() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Returns the key size of the given key object in number of bits.\n-     *\n-     * @param key the key object.\n-     *\n-     * @return the \"effective\" key size of the given key object.\n-     *\n-     * @exception InvalidKeyException if <code>key<\/code> is invalid.\n-     *\/\n-    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n-        byte[] encoded = key.getEncoded();\n-        if (!AESCrypt.isKeySizeValid(encoded.length)) {\n-            throw new InvalidKeyException(\"Invalid key length: \" +\n-                                          encoded.length + \" bytes\");\n-        }\n-        return Math.multiplyExact(encoded.length, 8);\n-    }\n-\n-    \/**\n-     * Wrap a key.\n-     *\n-     * @param key the key to be wrapped.\n-     *\n-     * @return the wrapped key.\n-     *\n-     * @exception IllegalBlockSizeException if this cipher is a block\n-     * cipher, no padding has been requested, and the length of the\n-     * encoding of the key to be wrapped is not a\n-     * multiple of the block size.\n-     *\n-     * @exception InvalidKeyException if it is impossible or unsafe to\n-     * wrap the key with this cipher (e.g., a hardware protected key is\n-     * being passed to a software only cipher).\n-     *\/\n-    protected byte[] engineWrap(Key key)\n-        throws IllegalBlockSizeException, InvalidKeyException {\n-        byte[] keyVal = key.getEncoded();\n-        if ((keyVal == null) || (keyVal.length == 0)) {\n-            throw new InvalidKeyException(\"Cannot get an encoding of \" +\n-                                          \"the key to be wrapped\");\n-        }\n-        byte[] out = new byte[Math.addExact(keyVal.length, 8)];\n-\n-        if (keyVal.length == 8) {\n-            System.arraycopy(IV, 0, out, 0, IV.length);\n-            System.arraycopy(keyVal, 0, out, IV.length, 8);\n-            cipher.encryptBlock(out, 0, out, 0);\n-        } else {\n-            if (keyVal.length % 8 != 0) {\n-                throw new IllegalBlockSizeException(\"length of the \" +\n-                    \"to be wrapped key should be multiples of 8 bytes\");\n-            }\n-            System.arraycopy(IV, 0, out, 0, IV.length);\n-            System.arraycopy(keyVal, 0, out, IV.length, keyVal.length);\n-            int N = keyVal.length\/8;\n-            byte[] buffer = new byte[blksize];\n-            for (int j = 0; j < 6; j++) {\n-                for (int i = 1; i <= N; i++) {\n-                    int T = i + j*N;\n-                    System.arraycopy(out, 0, buffer, 0, IV.length);\n-                    System.arraycopy(out, i*8, buffer, IV.length, 8);\n-                    cipher.encryptBlock(buffer, 0, buffer, 0);\n-                    for (int k = 1; T != 0; k++) {\n-                        byte v = (byte) T;\n-                        buffer[IV.length - k] ^= v;\n-                        T >>>= 8;\n-                    }\n-                    System.arraycopy(buffer, 0, out, 0, IV.length);\n-                    System.arraycopy(buffer, 8, out, 8*i, 8);\n-                }\n-            }\n-        }\n-        return out;\n-    }\n-\n-    \/**\n-     * Unwrap a previously wrapped key.\n-     *\n-     * @param wrappedKey the key to be unwrapped.\n-     *\n-     * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.\n-     *\n-     * @param wrappedKeyType the type of the wrapped key.\n-     * This is one of <code>Cipher.SECRET_KEY<\/code>,\n-     * <code>Cipher.PRIVATE_KEY<\/code>, or <code>Cipher.PUBLIC_KEY<\/code>.\n-     *\n-     * @return the unwrapped key.\n-     *\n-     * @exception NoSuchAlgorithmException if no installed providers\n-     * can create keys of type <code>wrappedKeyType<\/code> for the\n-     * <code>wrappedKeyAlgorithm<\/code>.\n-     *\n-     * @exception InvalidKeyException if <code>wrappedKey<\/code> does not\n-     * represent a wrapped key of type <code>wrappedKeyType<\/code> for\n-     * the <code>wrappedKeyAlgorithm<\/code>.\n-     *\/\n-    protected Key engineUnwrap(byte[] wrappedKey,\n-                               String wrappedKeyAlgorithm,\n-                               int wrappedKeyType)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-        int wrappedKeyLen = wrappedKey.length;\n-        \/\/ ensure the wrappedKey length is multiples of 8 bytes and non-zero\n-        if (wrappedKeyLen == 0) {\n-            throw new InvalidKeyException(\"The wrapped key is empty\");\n-        }\n-        if (wrappedKeyLen % 8 != 0) {\n-            throw new InvalidKeyException\n-                (\"The wrapped key has invalid key length\");\n-        }\n-        byte[] out = new byte[wrappedKeyLen - 8];\n-        byte[] buffer = new byte[blksize];\n-        if (wrappedKeyLen == 16) {\n-            cipher.decryptBlock(wrappedKey, 0, buffer, 0);\n-            for (int i = 0; i < IV.length; i++) {\n-                if (IV[i] != buffer[i]) {\n-                    throw new InvalidKeyException(\"Integrity check failed\");\n-                }\n-            }\n-            System.arraycopy(buffer, IV.length, out, 0, out.length);\n-        } else {\n-            System.arraycopy(wrappedKey, 0, buffer, 0, IV.length);\n-            System.arraycopy(wrappedKey, IV.length, out, 0, out.length);\n-            int N = out.length\/8;\n-            for (int j = 5; j >= 0; j--) {\n-                for (int i = N; i > 0; i--) {\n-                    int T = i + j*N;\n-                    System.arraycopy(out, 8*(i-1), buffer, IV.length, 8);\n-                    for (int k = 1; T != 0; k++) {\n-                        byte v = (byte) T;\n-                        buffer[IV.length - k] ^= v;\n-                        T >>>= 8;\n-                    }\n-                    cipher.decryptBlock(buffer, 0, buffer, 0);\n-                    System.arraycopy(buffer, IV.length, out, 8*(i-1), 8);\n-                }\n-            }\n-            for (int i = 0; i < IV.length; i++) {\n-                if (IV[i] != buffer[i]) {\n-                    throw new InvalidKeyException(\"Integrity check failed\");\n-                }\n-            }\n-        }\n-        return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESWrapCipher.java","additions":0,"deletions":511,"binary":false,"changes":511,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-\n+import java.util.Arrays;\n@@ -61,3 +61,2 @@\n-                                              String encodedKeyAlgorithm)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n+            String encodedKeyAlgorithm)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n@@ -65,1 +64,0 @@\n-\n@@ -112,3 +110,2 @@\n-                                                String encodedKeyAlgorithm)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n+            String encodedKeyAlgorithm)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n@@ -163,3 +160,2 @@\n-                                              String encodedKeyAlgorithm)\n-    {\n-        return (new SecretKeySpec(encodedKey, encodedKeyAlgorithm));\n+            int ofs, int len, String encodedKeyAlgorithm) {\n+        return (new SecretKeySpec(encodedKey, ofs, len, encodedKeyAlgorithm));\n@@ -169,3 +165,1 @@\n-                                  int keyType)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-        Key result = null;\n+            int keyType) throws InvalidKeyException, NoSuchAlgorithmException {\n@@ -174,3 +168,2 @@\n-            result = ConstructKeys.constructSecretKey(encoding,\n-                                                      keyAlgorithm);\n-            break;\n+            return ConstructKeys.constructSecretKey(encoding, 0,\n+                    encoding.length, keyAlgorithm);\n@@ -178,3 +171,1 @@\n-            result = ConstructKeys.constructPrivateKey(encoding,\n-                                                       keyAlgorithm);\n-            break;\n+            return ConstructKeys.constructPrivateKey(encoding, keyAlgorithm);\n@@ -182,3 +173,23 @@\n-            result = ConstructKeys.constructPublicKey(encoding,\n-                                                      keyAlgorithm);\n-            break;\n+            return ConstructKeys.constructPublicKey(encoding, keyAlgorithm);\n+        default:\n+            throw new RuntimeException(\"Unsupported key type\");\n+        }\n+    }\n+\n+    static final Key constructKey(byte[] encoding, int ofs, int len,\n+            String keyAlgorithm, int keyType)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n+        if (keyType == Cipher.SECRET_KEY) {\n+            return ConstructKeys.constructSecretKey(encoding, ofs, len,\n+                    keyAlgorithm);\n+        } else {\n+            if (ofs == 0 && len == encoding.length) {\n+                return constructKey(encoding, keyAlgorithm, keyType);\n+            } else {\n+                byte[] encoding2 = Arrays.copyOfRange(encoding, ofs, ofs + len);\n+                try {\n+                    return constructKey(encoding2, keyAlgorithm, keyType);\n+                } finally {\n+                    Arrays.fill(encoding2, (byte)0);\n+                }\n+            }\n@@ -186,1 +197,0 @@\n-        return result;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ConstructKeys.java","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.*;\n+import java.security.AlgorithmParametersSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class implements the parameter (IV) used with the AES algorithm in\n+ * KWP mode. IV is defined in the standards as follows:\n+ *\n+ * <pre>\n+ * IV ::= OCTET STRING  -- 4 octets\n+ * <\/pre>\n+ *\n+ *\/\n+\n+public final class KWPParameters extends AlgorithmParametersSpi {\n+\n+    private BlockCipherParamsCore core;\n+\n+    public KWPParameters() {\n+        \/\/ same length as AESKeyWrapPadded.ICV2\n+        core = new BlockCipherParamsCore(4);\n+    }\n+    protected void engineInit(AlgorithmParameterSpec paramSpec)\n+        throws InvalidParameterSpecException {\n+        core.init(paramSpec);\n+    }\n+\n+    protected void engineInit(byte[] encoded)\n+        throws IOException {\n+        core.init(encoded);\n+    }\n+\n+    protected void engineInit(byte[] encoded, String decodingMethod)\n+        throws IOException {\n+        core.init(encoded, decodingMethod);\n+    }\n+\n+    protected <T extends AlgorithmParameterSpec>\n+        T engineGetParameterSpec(Class<T> paramSpec)\n+        throws InvalidParameterSpecException {\n+        if (AlgorithmParameterSpec.class.isAssignableFrom(paramSpec)) {\n+            return core.getParameterSpec(paramSpec);\n+        } else {\n+            throw new InvalidParameterSpecException\n+                (\"Inappropriate parameter Specification\");\n+        }\n+    }\n+\n+    protected byte[] engineGetEncoded() throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected byte[] engineGetEncoded(String encodingMethod)\n+        throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected String engineToString() {\n+        return core.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWPParameters.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.*;\n+import java.security.AlgorithmParametersSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class implements the parameter (IV) used with the AES algorithm in\n+ * KW mode. IV is defined in the standards as follows:\n+ *\n+ * <pre>\n+ * IV ::= OCTET STRING  -- 8 octets\n+ * <\/pre>\n+ *\n+ *\/\n+\n+public final class KWParameters extends AlgorithmParametersSpi {\n+\n+    private BlockCipherParamsCore core;\n+\n+    public KWParameters() {\n+        core = new BlockCipherParamsCore(8); \/\/ same length as AESKeyWrap.ICV1\n+    }\n+    protected void engineInit(AlgorithmParameterSpec paramSpec)\n+        throws InvalidParameterSpecException {\n+        core.init(paramSpec);\n+    }\n+\n+    protected void engineInit(byte[] encoded)\n+        throws IOException {\n+        core.init(encoded);\n+    }\n+\n+    protected void engineInit(byte[] encoded, String decodingMethod)\n+        throws IOException {\n+        core.init(encoded, decodingMethod);\n+    }\n+\n+    protected <T extends AlgorithmParameterSpec>\n+        T engineGetParameterSpec(Class<T> paramSpec)\n+        throws InvalidParameterSpecException {\n+        if (AlgorithmParameterSpec.class.isAssignableFrom(paramSpec)) {\n+            return core.getParameterSpec(paramSpec);\n+        } else {\n+            throw new InvalidParameterSpecException\n+                (\"Inappropriate parameter Specification\");\n+        }\n+    }\n+\n+    protected byte[] engineGetEncoded() throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected byte[] engineGetEncoded(String encodingMethod)\n+        throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected String engineToString() {\n+        return core.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWParameters.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+\/**\n+ * This class acts as the base class for AES KeyWrap algorithms as defined\n+ * in <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"\n+ *\/\n+class KWUtil {\n+\n+    static final int BLKSIZE = 16;\n+    static final int SEMI_BLKSIZE = BLKSIZE >> 1;\n+\n+    \/*\n+     * The wrapping function W as defined in section 6.1 of NIST SP 800-38F as\n+     * well as sec 2.2.1 of RFC 3394.\n+     * @param firstSemiblk the first semi block value to overwrite the input\n+     *         with\n+     * @param in input bytes\n+     * @param inLen length of the to-be-processed bytes\n+     * @param cipher the initialized cipher object used\n+     *\/\n+    static final void W(byte[] firstSemiblk, byte[] in, int inLen,\n+            SymmetricCipher cipher) {\n+        \/\/ overwrite the first block of in with the iv semiblock\n+        System.arraycopy(firstSemiblk, 0, in, 0, SEMI_BLKSIZE);\n+\n+        \/\/ assert (inLen % SEMI_BLKSIZE == 0) {\n+        int n = inLen \/ SEMI_BLKSIZE - 1;\n+\n+        byte[] buffer = new byte[BLKSIZE];\n+        byte[] out = in; \/\/ in-place\n+        for (int j = 0; j < 6; j++) {\n+            for (int i = 1; i <= n; i++) {\n+                int T = i + j*n;\n+                System.arraycopy(out, 0, buffer, 0, SEMI_BLKSIZE);\n+                System.arraycopy(out, i << 3, buffer, SEMI_BLKSIZE, 8);\n+                cipher.encryptBlock(buffer, 0, buffer, 0);\n+                for (int k = 1; T != 0; k++) {\n+                    byte v = (byte) T;\n+                    buffer[SEMI_BLKSIZE - k] ^= v;\n+                    T >>>= SEMI_BLKSIZE;\n+                }\n+                System.arraycopy(buffer, 0, out, 0, SEMI_BLKSIZE);\n+                System.arraycopy(buffer, SEMI_BLKSIZE, out, i << 3,\n+                        SEMI_BLKSIZE);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * The unwrapping function W^-1 as defined in section 6.1 of NIST SP\n+     * 800-38F as well as sec 2.2.2 of RFC 3394.\n+     * - separated out the initial value from the remaining recovered data\n+     * - no output buffer argument since we cannot write out the recovered\n+     *   data until the initial value and padding bytes are verified.\n+     * @param in input bytes, i.e. the to-be-processed data\n+     * @param inLen length of the to-be-processed bytes\n+     * @param ivOut buffer for holding the recovered ICV semiblock\n+     * @param cipher the initialized cipher object used\n+     *\/\n+    static final void W_INV(byte[] in, int inLen, byte[] ivOut,\n+            SymmetricCipher cipher) {\n+        int outLen = inLen - SEMI_BLKSIZE;\n+        \/\/ assert inLen?\n+        \/\/ assert (ivOut.length == SEMI_BLKSIZE)\n+\n+        byte[] buffer = new byte[BLKSIZE];\n+        System.arraycopy(in, 0, buffer, 0, SEMI_BLKSIZE);\n+        System.arraycopy(in, SEMI_BLKSIZE, in, 0, inLen - SEMI_BLKSIZE);\n+        int n = (inLen - SEMI_BLKSIZE) \/ SEMI_BLKSIZE;\n+\n+        for (int j = 5; j >= 0; j--) {\n+            for (int i = n; i > 0; i--) {\n+                int T = i + n*j;\n+                int idx = (i-1) << 3;\n+                System.arraycopy(in, idx, buffer, SEMI_BLKSIZE, SEMI_BLKSIZE);\n+                for (int k = 1; T != 0; k++) {\n+                    byte v = (byte) T;\n+                    buffer[SEMI_BLKSIZE - k] ^= v;\n+                    T >>>= SEMI_BLKSIZE;\n+                }\n+                cipher.decryptBlock(buffer, 0, buffer, 0);\n+                System.arraycopy(buffer, SEMI_BLKSIZE, in, idx, SEMI_BLKSIZE);\n+            }\n+        }\n+        System.arraycopy(buffer, 0, ivOut, 0, SEMI_BLKSIZE);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,724 @@\n+\/*\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import static com.sun.crypto.provider.KWUtil.*;\n+\n+\/**\n+ * This class is the impl class for AES KeyWrap algorithms as defined in\n+ * <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"\n+ *\/\n+abstract class KeyWrapCipher extends CipherSpi {\n+\n+    \/\/ for AESWrap + AES\/KW\/NoPadding\n+    public static final class AES_KW_NoPadding extends KeyWrapCipher {\n+        public AES_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, -1);\n+        }\n+    }\n+\n+    \/\/ for AESWrap_128 + AES_128\/KW\/NoPadding\n+    public static final class AES128_KW_NoPadding extends KeyWrapCipher {\n+        public AES128_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, 16);\n+        }\n+    }\n+\n+    \/\/ for AESWrap_192 + AES_192\/KW\/NoPadding\n+    public static final class AES192_KW_NoPadding extends KeyWrapCipher {\n+        public AES192_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, 24);\n+        }\n+    }\n+\n+    \/\/ for AESWrap_256 + AES_256\/KW\/NoPadding\n+    public static final class AES256_KW_NoPadding extends KeyWrapCipher {\n+        public AES256_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, 32);\n+        }\n+    }\n+\n+    \/\/ for AES\/KW\/NoPadding\n+    public static final class AES_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), -1);\n+        }\n+    }\n+\n+    \/\/ for AES_128\/KW\/NoPadding\n+    public static final class AES128_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES128_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), 16);\n+        }\n+    }\n+\n+    \/\/ for AES_192\/KW\/NoPadding\n+    public static final class AES192_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES192_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), 24);\n+        }\n+    }\n+\n+    \/\/ for AES_256\/KW\/NoPadding\n+    public static final class AES256_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES256_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), 32);\n+        }\n+    }\n+\n+    \/\/ for AES\/KWP\/NoPadding\n+    public static final class AES_KWP_NoPadding extends KeyWrapCipher {\n+        public AES_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, -1);\n+        }\n+    }\n+\n+    \/\/ for AES_128\/KWP\/NoPadding\n+    public static final class AES128_KWP_NoPadding extends KeyWrapCipher {\n+        public AES128_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, 16);\n+        }\n+    }\n+\n+    \/\/ for AES_192\/KWP\/NoPadding\n+    public static final class AES192_KWP_NoPadding extends KeyWrapCipher {\n+        public AES192_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, 24);\n+        }\n+    }\n+\n+    \/\/ for AES_256\/KWP\/NoPadding\n+    public static final class AES256_KWP_NoPadding extends KeyWrapCipher {\n+        public AES256_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, 32);\n+        }\n+    }\n+\n+    \/\/ store the specified bytes, e.g. in[inOfs...(inOfs+inLen-1)] into\n+    \/\/ 'dataBuf' starting at startIdx.\n+    \/\/ NOTE: if in is null, this method will ensure that dataBuf has enough\n+    \/\/ capacity for inLen bytes but will NOT copy bytes from in.\n+    private void store(int startIdx, byte[] in, int inOfs, int inLen) {\n+        \/\/ In NIST SP 800-38F, KWP input size is limited to be no longer\n+        \/\/ than 2^32 bytes. Otherwise, the length cannot be encoded in 32 bits\n+        \/\/ However, given the current spec requirement that recovered text\n+        \/\/ can only be returned after successful tag verification, we are\n+        \/\/ bound by limiting the data size to the size limit of java byte array,\n+        \/\/ e.g. Integer.MAX_VALUE, since all data are returned by doFinal().\n+        int remain = Integer.MAX_VALUE - startIdx;\n+        if (inLen > remain) {\n+            throw new ProviderException(\"SunJCE provider can only take \" +\n+                remain + \" more bytes\");\n+        }\n+\n+        \/\/ resize dataBuf to the smallest (n * BLKSIZE) + SEMI_BLKSIZE)\n+        if (dataBuf.length - startIdx < inLen) {\n+            int newSize = Math.addExact(startIdx, inLen);\n+            int lastBlk = (startIdx + inLen - SEMI_BLKSIZE) % BLKSIZE;\n+            if (lastBlk != 0 || padding != null) {\n+                newSize = Math.addExact(newSize, BLKSIZE - lastBlk);\n+            }\n+            dataBuf = Arrays.copyOf(dataBuf, newSize);\n+        }\n+\n+        if (in != null) {\n+            System.arraycopy(in, inOfs, dataBuf, startIdx, inLen);\n+            dataIdx = startIdx + inLen;\n+        }\n+    }\n+\n+    \/\/ internal cipher object which does the real work.\n+    private final FeedbackCipher cipher;\n+\n+    \/\/ internal padding object; null if NoPadding\n+    private final Padding padding;\n+\n+    \/\/ encrypt\/wrap or decrypt\/unwrap?\n+    private int opmode = -1; \/\/ must be set by init(..)\n+\n+    \/*\n+     * needed to support oids which associates a fixed key size\n+     * to the cipher object.\n+     *\/\n+    private final int fixedKeySize; \/\/ in bytes, -1 if no restriction\n+\n+    \/\/ internal data buffer for encrypt, decrypt and unwrap calls\n+    \/\/ must use store() to store data into dataBuf as it will resize if needed\n+    private byte[] dataBuf;\n+    private int dataIdx;\n+\n+    \/**\n+     * Creates an instance of KeyWrap cipher using the specified\n+     * symmetric cipher whose block size must be 128-bit, and\n+     * the supported mode and padding scheme.\n+     *\/\n+    public KeyWrapCipher(FeedbackCipher cipher, Padding padding, int keySize) {\n+        this.cipher = cipher;\n+        this.padding = padding;\n+        this.fixedKeySize = keySize;\n+        this.dataBuf = new byte[40];\n+        this.dataIdx = 0;\n+    }\n+\n+    \/**\n+     * Sets the mode of this cipher. Must match the mode specified in\n+     * the constructor.\n+     *\n+     * @param mode the cipher mode\n+     *\n+     * @exception NoSuchAlgorithmException if the requested cipher mode\n+     * does not match the supported mode\n+     *\/\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        if (mode != null && !cipher.getFeedback().equalsIgnoreCase(mode)) {\n+            throw new NoSuchAlgorithmException(mode + \" cannot be used\");\n+        }\n+    }\n+\n+    \/**\n+     * Sets the padding mechanism of this cipher. The specified padding\n+     * scheme should match what this cipher is configured with.\n+     *\n+     * @param padding the padding mechanism\n+     *\n+     * @exception NoSuchPaddingException if the requested padding mechanism\n+     * does not match the supported padding scheme\n+     *\/\n+    @Override\n+    protected void engineSetPadding(String padding)\n+            throws NoSuchPaddingException {\n+        if ((this.padding == null && !\"NoPadding\".equalsIgnoreCase(padding)) ||\n+                 this.padding instanceof PKCS5Padding &&\n+                 !\"PKCS5Padding\".equalsIgnoreCase(padding)) {\n+            throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the block size (in bytes). i.e. 16 bytes.\n+     *\n+     * @return the block size (in bytes), i.e. 16 bytes.\n+     *\/\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return cipher.getBlockSize();\n+    }\n+\n+    \/**\n+     * Returns the length in bytes that an output buffer would need to be\n+     * given the input length <code>inLen<\/code> (in bytes).\n+     *\n+     * <p>The actual output length of the next <code>update<\/code> or\n+     * <code>doFinal<\/code> call may be smaller than the length returned\n+     * by this method.\n+     *\n+     * @param inLen the input length (in bytes)\n+     *\n+     * @return the required output buffer size (in bytes)\n+     *\/\n+    protected int engineGetOutputSize(int inLen) {\n+        int result = inLen;\n+        int buffered = dataIdx - SEMI_BLKSIZE;\n+        if (buffered > 0) {\n+            result = Math.addExact(result, buffered);\n+        }\n+        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE) {\n+            \/\/ calculate padding length first\n+            if (padding != null) {\n+                result = Math.addExact(result, padding.padLength(result));\n+            } else if (cipher instanceof AESKeyWrapPadded) {\n+                int n = result % SEMI_BLKSIZE;\n+                if (n != 0) {\n+                    result = Math.addExact(result, SEMI_BLKSIZE - n);\n+                }\n+            }\n+            \/\/ then add the first semiblock\n+            result = Math.addExact(result, SEMI_BLKSIZE);\n+        } else {\n+            result -= SEMI_BLKSIZE;\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the initialization vector (IV).\n+     *\n+     * @return the user-specified iv or null if default iv is used.\n+     *\/\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return cipher.getIV().clone();\n+    }\n+\n+    \/\/ actual impl for various engineInit(...) methods\n+    private void implInit(int opmode, Key key, byte[] iv, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (opmode < Cipher.ENCRYPT_MODE || opmode > Cipher.UNWRAP_MODE) {\n+            throw new RuntimeException(\"Invalid opmode for Cipher\");\n+        }\n+        byte[] keyBytes = key.getEncoded();\n+        if (keyBytes == null) {\n+            throw new InvalidKeyException(\"Null key\");\n+        }\n+        this.opmode = opmode;\n+        boolean decrypting = (opmode == Cipher.DECRYPT_MODE ||\n+                opmode == Cipher.UNWRAP_MODE);\n+        try {\n+            cipher.init(decrypting, key.getAlgorithm(), keyBytes, iv);\n+            dataIdx = 0;\n+        } finally {\n+            Arrays.fill(keyBytes, (byte) 0);\n+        }\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key and a source of randomness.\n+     *\n+     * @param opmode the operation mode of this cipher.\n+     * @param key the secret key.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+        throws InvalidKeyException {\n+        try {\n+            implInit(opmode, key, (byte[])null, random);\n+        } catch (InvalidAlgorithmParameterException iae) {\n+            \/\/ should never happen\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key, a set of algorithm parameters,\n+     * and a source of randomness.\n+     *\n+     * @param opmode the operation mode of this cipher.\n+     * @param key the secret key.\n+     * @param params the algorithm parameters; if not null, must be of type\n+     * IvParameterSpec\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters is invalid.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (params != null && !(params instanceof IvParameterSpec)) {\n+            throw new InvalidAlgorithmParameterException(\n+                \"Only IvParameterSpec is accepted\");\n+        }\n+        byte[] iv = (params == null? null : ((IvParameterSpec)params).getIV());\n+        implInit(opmode, key, iv, random);\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key, a set of algorithm parameters,\n+     * and a source of randomness.\n+     *\n+     * @param opmode the operation mode of this cipher.\n+     * @param key the secret key.\n+     * @param params the algorithm parameters; if not null, must be able to\n+     * be converted to IvParameterSpec.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate.\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters is invalid.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key, AlgorithmParameters params,\n+            SecureRandom random) throws InvalidKeyException,\n+            InvalidAlgorithmParameterException {\n+        byte[] iv = null;\n+        if (params != null) {\n+            try {\n+                AlgorithmParameterSpec spec =\n+                        params.getParameterSpec(IvParameterSpec.class);\n+                iv = ((IvParameterSpec)spec).getIV();\n+            } catch (InvalidParameterSpecException ispe) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Only IvParameterSpec is accepted\");\n+            }\n+        }\n+        try {\n+            implInit(opmode, key, iv, random);\n+        } catch (IllegalArgumentException iae) {\n+            throw new InvalidAlgorithmParameterException(iae.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * See CipherSpi.engineUpdate(...) - buffers data internally as\n+     * only single part operation is supported.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     *\n+     * @return null.\n+     *\/\n+    @Override\n+    protected byte[] engineUpdate(byte[] in, int inOffset, int inLen) {\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException(\"Cipher not initialized for update\");\n+        }\n+        implUpdate(in, inOffset, inLen);\n+        return null;\n+    }\n+\n+    \/**\n+     * See CipherSpi.engineUpdate(...) - buffers data internally as\n+     * only single part operation is supported.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     * @param out the buffer for the result.\n+     * @param outOffset the offset in <code>out<\/code> where the result\n+     * is stored.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected int engineUpdate(byte[] in, int inOffset, int inLen,\n+            byte[] out, int outOffset) throws ShortBufferException {\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException(\"Cipher not initialized for update\");\n+        }\n+        implUpdate(in, inOffset, inLen);\n+        return 0;\n+    }\n+\n+    \/\/ actual impl for various engineUpdate(...) methods\n+    private void implUpdate(byte[] in, int inOffset, int inLen) {\n+        boolean encrypting = (opmode == Cipher.ENCRYPT_MODE ||\n+                opmode == Cipher.WRAP_MODE);\n+        if (encrypting && dataIdx == 0) {\n+            \/\/ the first semiblock is for iv, store data after it\n+            dataIdx += SEMI_BLKSIZE;\n+        }\n+        store(dataIdx, in, inOffset, inLen);\n+    }\n+\n+    \/**\n+     * See CipherSpi.engineDoFinal(...)\n+     *\n+     * @param input the input buffer\n+     * @param inputOffset the offset in <code>in<\/code> where the input\n+     * starts\n+     * @param inputLen the input length.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for doFinal\");\n+        }\n+        try {\n+            \/\/ implDoFinal() use internal 'dataBuf' as output buffer\n+            int outLen = implDoFinal(in, inOfs, inLen);\n+            return Arrays.copyOf(dataBuf, outLen);\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError(sbe);\n+        }\n+    }\n+\n+    \/**\n+     * See CipherSpi.doFinal(...)\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     * @param out the buffer for the result.\n+     * @param outOffset the ofset in <code>out<\/code> where the result\n+     * is stored.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    protected int engineDoFinal(byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) throws IllegalBlockSizeException,\n+            ShortBufferException, BadPaddingException {\n+        if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for doFinal\");\n+        }\n+        int estOutLen = engineGetOutputSize(inLen);\n+        if (out.length - outOfs < estOutLen) {\n+            throw new ShortBufferException(\"Need at least \" + estOutLen);\n+        }\n+        \/\/ implDoFinal() use internal 'dataBuf' as output buffer\n+        int outLen = implDoFinal(in, inOfs, inLen);\n+        \/\/ only write out the result after verification succeeds\n+        System.arraycopy(dataBuf, 0, out, outOfs, outLen);\n+        return outLen;\n+    }\n+\n+    \/\/ actual impl for various engineDoFinal(...) methods, i.e. write the first\n+    \/\/ semiblock containing IV if needed, buffer input data, and then perform\n+    \/\/ single-part encryption\/decrytion\n+    private int implDoFinal(byte[] in, int inOfs, int inLen)\n+        throws IllegalBlockSizeException, BadPaddingException,\n+            ShortBufferException {\n+        boolean encrypting = (opmode == Cipher.ENCRYPT_MODE ||\n+                opmode == Cipher.WRAP_MODE);\n+        if (encrypting && dataIdx == 0) {\n+            \/\/ the first semiblock is for iv, store data after it\n+            dataIdx += SEMI_BLKSIZE;\n+        }\n+        if (inLen > 0) {\n+            store(dataIdx, in, inOfs, inLen);\n+        }\n+\n+        try {\n+            return (encrypting? helperEncrypt(dataBuf, dataIdx) :\n+                    helperDecrypt(dataBuf, dataIdx));\n+        } finally {\n+            dataIdx = 0;\n+        }\n+    }\n+\n+    \/\/ helper routine for encryption; assuming all data is in 'inBuf'\n+    \/\/ with the first semiblock reserved for iv\n+    private int helperEncrypt(byte[] inBuf, int inLen)\n+            throws IllegalBlockSizeException, ShortBufferException {\n+\n+        \/\/ pad data if padding is used\n+        if (padding != null) {\n+            int paddingLen = padding.padLength(inLen - SEMI_BLKSIZE);\n+\n+            if (inLen + paddingLen > inBuf.length) {\n+                if (inBuf == dataBuf) {\n+                    \/\/ enlarge dataBuf to fit padding bytes\n+                    store(dataIdx, null, 0, paddingLen);\n+                } else {\n+                    throw new ProviderException(\"data buffer too small\");\n+                }\n+            }\n+            try {\n+                padding.padWithLen(inBuf, inLen, paddingLen);\n+                inLen += paddingLen;\n+            } catch (ShortBufferException sbe) {\n+                \/\/ should never happen\n+                throw new AssertionError(sbe);\n+            }\n+        }\n+        return cipher.encryptFinal(inBuf, 0, inLen, null, 0);\n+    }\n+\n+    private int helperDecrypt(byte[] inBuf, int inLen)\n+            throws IllegalBlockSizeException, BadPaddingException,\n+            ShortBufferException {\n+\n+        int outLen = cipher.decryptFinal(inBuf, 0, inLen, null, 0);\n+        \/\/ unpad data if padding is used\n+        if (padding != null) {\n+            int padIdx = padding.unpad(inBuf, 0, outLen);\n+            if (padIdx <= 0) {\n+                throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n+            }\n+            outLen = padIdx;\n+        }\n+        return outLen;\n+    }\n+\n+    \/**\n+     * Returns the parameters used with this cipher.\n+     *\n+     * @return AlgorithmParameters object containing IV.\n+     *\/\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        AlgorithmParameters params = null;\n+\n+        byte[] iv = cipher.getIV();\n+        String algo = \"AES\/\" + cipher.getFeedback() + \"\/NoPadding\";\n+        try {\n+            params = AlgorithmParameters.getInstance(algo,\n+                    SunJCE.getInstance());\n+            params.init(new IvParameterSpec(iv));\n+        } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+        return params;\n+    }\n+\n+    \/**\n+     * Returns the key size of the given key object in number of bits.\n+     *\n+     * @param key the key object.\n+     *\n+     * @return the \"effective\" key size of the given key object.\n+     *\n+     * @exception InvalidKeyException if <code>key<\/code> is invalid.\n+     *\/\n+    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n+        byte[] encoded = key.getEncoded();\n+        if (encoded == null)  {\n+            throw new InvalidKeyException(\"Cannot decide key length\");\n+        }\n+\n+        \/\/ only need length\n+        Arrays.fill(encoded, (byte) 0);\n+        int keyLen = encoded.length;\n+        if (!key.getAlgorithm().equalsIgnoreCase(\"AES\") ||\n+            !AESCrypt.isKeySizeValid(keyLen) ||\n+            (fixedKeySize != -1 && fixedKeySize != keyLen)) {\n+            throw new InvalidKeyException(\"Invalid key length: \" +\n+                    keyLen + \" bytes\");\n+        }\n+        return Math.multiplyExact(keyLen, 8);\n+    }\n+\n+    \/**\n+     * Wrap a key.\n+     *\n+     * @param key the key to be wrapped.\n+     *\n+     * @return the wrapped key.\n+     *\n+     * @exception IllegalBlockSizeException if this cipher is a block\n+     * cipher, no padding has been requested, and the length of the\n+     * encoding of the key to be wrapped is not a\n+     * multiple of the block size.\n+     *\n+     * @exception InvalidKeyException if it is impossible or unsafe to\n+     * wrap the key with this cipher (e.g., a hardware protected key is\n+     * being passed to a software only cipher).\n+     *\/\n+    @Override\n+    protected byte[] engineWrap(Key key)\n+            throws IllegalBlockSizeException, InvalidKeyException {\n+\n+        if (opmode != Cipher.WRAP_MODE) {\n+            throw new IllegalStateException(\"Cipher not initialized for wrap\");\n+        }\n+        byte[] encoded = key.getEncoded();\n+        if ((encoded == null) || (encoded.length == 0)) {\n+            throw new InvalidKeyException(\"Cannot get an encoding of \" +\n+                                          \"the key to be wrapped\");\n+        }\n+        \/\/ output size is known, allocate output buffer\n+        byte[] out = new byte[engineGetOutputSize(encoded.length)];\n+\n+        \/\/ reserve the first semiblock and do not write data\n+        int outOfs = SEMI_BLKSIZE;\n+        System.arraycopy(encoded, 0, out, outOfs, encoded.length);\n+        outOfs += encoded.length;\n+\n+        \/\/ discard key data\n+        Arrays.fill(encoded, (byte) 0);\n+\n+        try {\n+            int outLen = helperEncrypt(out, outOfs);\n+            if (outLen != out.length) {\n+                throw new ProviderException(\"Need to resize output buffer\");\n+            }\n+            return out;\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Unwrap a previously wrapped key.\n+     *\n+     * @param wrappedKey the key to be unwrapped.\n+     *\n+     * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.\n+     *\n+     * @param wrappedKeyType the type of the wrapped key.\n+     * This is one of <code>Cipher.SECRET_KEY<\/code>,\n+     * <code>Cipher.PRIVATE_KEY<\/code>, or <code>Cipher.PUBLIC_KEY<\/code>.\n+     *\n+     * @return the unwrapped key.\n+     *\n+     * @exception NoSuchAlgorithmException if no installed providers\n+     * can create keys of type <code>wrappedKeyType<\/code> for the\n+     * <code>wrappedKeyAlgorithm<\/code>.\n+     *\n+     * @exception InvalidKeyException if <code>wrappedKey<\/code> does not\n+     * represent a wrapped key of type <code>wrappedKeyType<\/code> for\n+     * the <code>wrappedKeyAlgorithm<\/code>.\n+     *\/\n+    @Override\n+    protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n+            int wrappedKeyType) throws InvalidKeyException,\n+            NoSuchAlgorithmException {\n+\n+        if (opmode != Cipher.UNWRAP_MODE) {\n+            throw new IllegalStateException\n+                    (\"Cipher not initialized for unwrap\");\n+        }\n+\n+        store(0, wrappedKey, 0, wrappedKey.length);\n+\n+        int outLen = 0;\n+        try {\n+            outLen = helperDecrypt(dataBuf, dataIdx);\n+            return ConstructKeys.constructKey(dataBuf, 0, outLen,\n+                    wrappedKeyAlgorithm, wrappedKeyType);\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            Arrays.fill(dataBuf, 0, outLen, (byte) 0);\n+            \/\/ reset dataBuf for subsequent operations\n+            dataIdx = 0;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":724,"deletions":0,"binary":false,"changes":724,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,10 @@\n+        psA(\"Cipher\", \"AES\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES_KW_PKCS5Padding\",\n+                null, attrs);\n+        ps(\"Cipher\", \"AES\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES_KWP_NoPadding\",\n+                null, attrs);\n+\n@@ -209,0 +219,9 @@\n+        psA(\"Cipher\", \"AES_128\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES128_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES_128\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES128_KW_PKCS5Padding\",\n+                null, attrs);\n+        psA(\"Cipher\", \"AES_128\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES128_KWP_NoPadding\",\n+                attrs);\n@@ -225,0 +244,9 @@\n+        psA(\"Cipher\", \"AES_192\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES192_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES_192\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES192_KW_PKCS5Padding\",\n+                null, attrs);\n+        psA(\"Cipher\", \"AES_192\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES192_KWP_NoPadding\",\n+                attrs);\n@@ -241,0 +269,9 @@\n+        psA(\"Cipher\", \"AES_256\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES256_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES_256\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES256_KW_PKCS5Padding\",\n+                null, attrs);\n+        psA(\"Cipher\", \"AES_256\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES256_KWP_NoPadding\",\n+                attrs);\n@@ -255,11 +292,0 @@\n-        ps(\"Cipher\", \"AESWrap\", \"com.sun.crypto.provider.AESWrapCipher$General\",\n-                null, attrs);\n-        psA(\"Cipher\", \"AESWrap_128\",\n-                \"com.sun.crypto.provider.AESWrapCipher$AES128\",\n-                attrs);\n-        psA(\"Cipher\", \"AESWrap_192\",\n-                \"com.sun.crypto.provider.AESWrapCipher$AES192\",\n-                attrs);\n-        psA(\"Cipher\", \"AESWrap_256\",\n-                \"com.sun.crypto.provider.AESWrapCipher$AES256\",\n-                attrs);\n@@ -499,0 +525,7 @@\n+        ps(\"AlgorithmParameters\", \"AES\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KWParameters\",\n+                List.of(\"AES\/KW\/PKCS5Padding\", \"AESWrap\"), null);\n+\n+        ps(\"AlgorithmParameters\", \"AES\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KWPParameters\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":45,"deletions":12,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,2 @@\n-    AESWRAP_128(\"2.16.840.1.101.3.4.1.5\"),\n+    AES_128$KW$NoPadding(\"2.16.840.1.101.3.4.1.5\", \"AES_128\/KW\/NoPadding\",\n+            \"AESWrap_128\"),\n@@ -121,0 +122,2 @@\n+    AES_128$KWP$NoPadding(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\"),\n+\n@@ -125,1 +128,2 @@\n-    AESWRAP_192(\"2.16.840.1.101.3.4.1.25\"),\n+    AES_192$KW$NoPadding(\"2.16.840.1.101.3.4.1.25\", \"AES_192\/KW\/NoPadding\",\n+            \"AESWrap_192\"),\n@@ -127,0 +131,2 @@\n+    AES_192$KWP$NoPadding(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\"),\n+\n@@ -131,1 +137,2 @@\n-    AESWRAP_256(\"2.16.840.1.101.3.4.1.45\"),\n+    AES_256$KW$NoPadding(\"2.16.840.1.101.3.4.1.45\", \"AES_256\/KW\/NoPadding\",\n+            \"AESWrap_256\"),\n@@ -133,0 +140,1 @@\n+    AES_256$KWP$NoPadding(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,0 +226,2 @@\n+\n+        store(\"AES\/KW\/NoPadding\", null, \"AESWrap\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,4 @@\n- * @bug 5008156\n- * @run main NISTWrapKAT\n- * @summary Verify that the \"AESWrap\" key wrap cipher work as\n- * expected using NIST test vectors.\n+ * @bug 5008156 8248268\n+ * @run testng NISTWrapKAT\n+ * @summary Verify that the AES-Key-Wrap and AES-Key-Wrap-Pad ciphers\n+ * work as expected using NIST test vectors.\n@@ -38,0 +38,3 @@\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n@@ -45,2 +48,2 @@\n-\n-    private static String AES128_128 =\n+    \/\/ from RFC 3394 sec4\n+    private static String KW_AES128_128 =\n@@ -48,1 +51,1 @@\n-    private static String AES192_128 =\n+    private static String KW_AES192_128 =\n@@ -50,1 +53,1 @@\n-    private static String AES192_192 =\n+    private static String KW_AES192_192 =\n@@ -52,1 +55,1 @@\n-    private static String AES256_128 =\n+    private static String KW_AES256_128 =\n@@ -54,1 +57,1 @@\n-    private static String AES256_192 =\n+    private static String KW_AES256_192 =\n@@ -56,1 +59,1 @@\n-    private static String AES256_256 =\n+    private static String KW_AES256_256 =\n@@ -59,7 +62,17 @@\n-    public static void testKeyWrap(int keyLen, int dataLen,\n-                                   String expected) throws Exception {\n-        System.out.println(\"Testing AESWrap Cipher with \" +\n-            dataLen + \"-byte data with \" + 8*keyLen + \"-bit key\");\n-        Cipher c = Cipher.getInstance(\"AESWrap\", \"SunJCE\");\n-        byte[] keyVal = new byte[keyLen];\n-        byte[] dataVal = new byte[dataLen];\n+    private static String KWP_AES128_56 = \"1B1D4BC2A90B1FA389412B3D40FECB20\";\n+    private static String KWP_AES128_112 =\n+            \"EA0BFDE8AF063E8918E811A05D2A4C23A367B45315716B5B\";\n+    private static String KWP_AES192_56 = \"87CE2C5C2D7196E09381056B319D91E9\";\n+    private static String KWP_AES192_112 =\n+            \"900484950F84EB6ED74CE81DCDACA26E72BB29D4A6F7AC74\";\n+    private static String KWP_AES192_168 =\n+            \"A402348F1956DB968FDDFD8976420F9DDEB7183CF16B91B0AEB74CAB196C343E\";\n+    private static String KWP_AES256_56 = \"809BB1864A18938529E97EFCD9544E9A\";\n+    private static String KWP_AES256_112 =\n+            \"C68168173F141E6D5767611574A941259090DA78D7DF9DF7\";\n+    private static String KWP_AES256_168 =\n+            \"308D49692B5F8CF638D54BB4B985633504237329964C76EBB3F669870A708DBC\";\n+    private static String KWP_AES256_224 =\n+            \"0942747DB07032A3F04CDB2E7DE1CBA038F92BC355393AE9A0E4AE8C901912AC3D3AF0F16D240607\";\n+     \/\/ from RFC 5649 sec6\n+     private static String KEK2 = \"5840DF6E29B02AF1AB493B705BF16EA1AE8338F4DCC176A8\";\n@@ -67,2 +80,8 @@\n-        \/\/ setup the key encryption key and the to-be-wrapped key\n-        BigInteger temp = new BigInteger(KEK.substring(0, keyLen*2), 16);\n+    private static byte[] toBytes(String hex, int hexLen) {\n+        if (hexLen < hex.length()) {\n+            hex = hex.substring(0, hexLen);\n+        } else {\n+            hexLen = hex.length();\n+        }\n+        int outLen = hexLen >> 1;\n+        BigInteger temp = new BigInteger(hex, 16);\n@@ -70,6 +89,161 @@\n-        System.arraycopy(val, 0, keyVal, keyVal.length-val.length,\n-                         val.length);\n-        temp = new BigInteger(DATA.substring(0, dataLen*2), 16);\n-        val = temp.toByteArray();\n-        System.arraycopy(val, 0, dataVal, dataVal.length-val.length,\n-                         val.length);\n+        if (val.length == outLen) {\n+            return val;\n+        } else {\n+            byte[] out = new byte[outLen];\n+            if (val.length < outLen) {\n+                \/\/ enlarge\n+                System.arraycopy(val, 0, out, outLen - val.length, val.length);\n+            } else {\n+                \/\/ truncate\n+                System.arraycopy(val, val.length - outLen, out, 0, outLen);\n+            }\n+            return out;\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] testData() {\n+        return new Object[][] {\n+            { \"AESWrap\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AESWrap\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AESWrap\", KEK, 24, DATA, 24, KW_AES192_192 },\n+            { \"AESWrap\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AESWrap\", KEK, 32, DATA, 24, KW_AES256_192 },\n+            { \"AESWrap\", KEK, 32, DATA, 32, KW_AES256_256 },\n+            { \"AES\/KW\/NoPadding\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 24, DATA, 24, KW_AES192_192 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 24, KW_AES256_192 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 32, KW_AES256_256 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 16, DATA, 14, KWP_AES128_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 14, KWP_AES192_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 21, KWP_AES192_168 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 7, KWP_AES256_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 14, KWP_AES256_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 21, KWP_AES256_168 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 28, KWP_AES256_224 },\n+            { \"AES\/KWP\/NoPadding\", KEK2, 24, \"466F7250617369\", 7,\n+              \"AFBEB0F07DFBF5419200F2CCB50BB24F\" },\n+            { \"AES\/KWP\/NoPadding\", KEK2, 24,\n+              \"C37B7E6492584340BED12207808941155068F738\", 20,\n+              \"138BDEAA9B8FA7FC61F97742E72248EE5AE6AE5360D1AE6A5F54F373FA543B6A\" },\n+            \/\/ some more test vectors for KW and KWP\n+            \/\/ from csrc.nist.gov\/groups\/STM\/cavp\/documents\/mac\/kwtestvectors.zip\n+            { \"AES\/KW\/NoPadding\", \"7575da3a93607cc2bfd8cec7aadfd9a6\", 16,\n+              \"42136d3c384a3eeac95a066fd28fed3f\", 16,\n+              \"031f6bd7e61e643df68594816f64caa3f56fabea2548f5fb\" },\n+            { \"AES\/KW\/NoPadding\", \"e5d058e7f1c22c016c4e1cc9b26b9f8f\", 16,\n+              \"7f604e9b8d39d3c91e193fe6f196c1e3da6211a7c9a33b8873b64b138d1803\" +\n+              \"e4\", 32,\n+              \"60b9f8ac797c56e01e9b5f84d65816a980777869f67991a0e6dc19b8cd75c9\" +\n+              \"b54db4a38456bbd6f3\" },\n+            { \"AES\/KW\/NoPadding\", \"67ae4270bcdd31e8326b7e7f94c80276\", 16,\n+              \"57e748b62fbc37ba25e904ee973d01b136cf7c1d0c8c5c87\", 24,\n+              \"96cec0e3272a21faa550a857957aa38ce3c1cf06f0dd9f5b5c5c422cef6c69\" +\n+              \"a1\" },\n+            { \"AES\/KW\/NoPadding\", \"d7aa53aefad65cd95b57c8eee7b0a906\", 16,\n+              \"4a8daee6774751fc4489e837b8f7fba6896c70bb3d5e53053c92eb58046ee4\" +\n+              \"a7002e542311253b97\", 40,\n+              \"84ebd38cf06c674dcf186977de4a40c6dde3e7f49361a43420a887d2931b29\" +\n+              \"c23e2db72e95e4107001da925181bb7097\" },\n+            { \"AES\/KW\/NoPadding\", \"98311985c4661d7e811ee56070e6fecf\", 16,\n+              \"18840c96813864ef3093b48cdde6ac5d78248b96d4a2cd1f15f0b56f98213d\" +\n+              \"bf87e1ccad04e0d4f1954c233ea3e48fdad8f2b1156e54e19e3b5f4a66d2e9\" +\n+              \"149032b876c51249165fe8c28e112a685b2d228a8ac308017574274af36a4e\" +\n+              \"a3877bcc9850bafe8fc0e0a712faca0dea98396f9143bc5819fe4933a806e9\" +\n+              \"b965133e3c695a45f0fbd6961798c400d7477287df64798b651e0d3009c13f\" +\n+              \"7a2246c28f983509b9e5339919f2cdffcdfc550693cba9491c00334c4a62d8\" +\n+              \"78c4d0ca57b1104bc0174968ea8e3730b9e68db49678b23cd508ebe3e12e94\" +\n+              \"b0ad3791023a8ef95473f0b32f906738f34e94e45a4480ad768072e1853adb\" +\n+              \"63996b9ac27a1dade70804b82290a2274c6dcc3ccd40a8b38a56a5eb03f590\" +\n+              \"75de015e8f9096f53549f6374e02da947fb849287a447f757cc340b6bded71\" +\n+              \"d480988b6d2fcd984fba841470519830304667fef0a577b4cf84f76aef9deb\" +\n+              \"84dde36abfbd76673c17113dbea7a3e24bf9b57a8fd17173a1ef91497b732b\" +\n+              \"3fa8889bed58a503a0d3e20bc27ec4dbf5d13a93cbad05495e3df15e1fe34a\" +\n+              \"3a6d6f648ea4aa60b2f114f30944ae593675dac2db188f90a3c483fb82cec0\" +\n+              \"f0d295544d798b62cdcb51c6c036af1a341d78babf87b92609c1d866e311a4\" +\n+              \"6abccc8ba8c6a41420359bb061d7e752c0ed25990eef57c9f9e190572203f8\" +\n+              \"c473edf8cfc8c26d34e37240f45ded97\", 512,\n+              \"625aea9122b7b57b9f36446f9053acc42c6435a7f69d91b41547026f833291\" +\n+              \"d488e477c7ccba698c143633a304f463d6af4a3e72c189234fcfc360013e65\" +\n+              \"b07b7f7a36c529d3fdbbdbd6224bf100c14bc5354893b44790f54c739a2b1f\" +\n+              \"5bda82d70fb600ed9b0606dbddea52e508b492b72d8779856274aaaaddc0a3\" +\n+              \"edb6cfc788b603101bedfcc3f44baa62336bd950c2e349d5daf04f2e23ec26\" +\n+              \"28893d214e277569c565e5e6aa8b72ffa14118a3b57f814b4deb179980b5ee\" +\n+              \"efa4fd93f1751850466e929be537801babc2120f3ff1ffe5fea813ec7788ea\" +\n+              \"f43f5ef657e5af48395c3ad11aaf741549090b58670695f7c95c68e00576ca\" +\n+              \"18ef0313f2b4b757219fc8db3dc2db28721d6f912547ebfebcd96935c3100a\" +\n+              \"a4e4df9955acae1b4e2c10df1166d46c4285ab631c6d2ce58ad3ae99c07c01\" +\n+              \"9dcd15958694055281ccd6f803af290431f188cc4c429e84a4c30fd9c63968\" +\n+              \"dfd0951c417efb71921c207de172a9546bdd3e2bb35b45e140892c649f88c3\" +\n+              \"1a438f864e801a69f8010aa3d77a26601a7a89067c81b0f7e70d8e82f21f88\" +\n+              \"c7d0bb0c8ca0db875d6c3f8c6f6d709bbb31c7da2e31f3571daa2c5ab13bfc\" +\n+              \"16624cf35abd526e84269fb45bbd2fcd8c383d6fbb700bc4b5205b3ef8c432\" +\n+              \"3dc0d9e0370e56a3d1e5e76aa4de082e4c2a0afd092845bd5dab52a4594318\" +\n+              \"1461b76e3984b95f48bea80a94944241d04b5634c86274e7\" },\n+            { \"AES\/KWP\/NoPadding\", \"6decf10a1caf8e3b80c7a4be8c9c84e8\", 16,\n+              \"49\", 1, \"01a7d657fc4a5b216f261cca4d052c2b\" },\n+            { \"AES\/KWP\/NoPadding\", \"a8e06da625a65b25cf5030826830b661\", 16,\n+              \"43acff293120dd5d\", 8, \"b6f967616dd8d772e9fea295a456dba7\" },\n+            { \"AES\/KWP\/NoPadding\", \"7865e20f3c21659ab4690b629cdf3cc4\", 16,\n+              \"bd6843d420378dc896\", 9,\n+              \"41eca956d4aa047eb5cf4efe659661e74db6f8c564e23500\" },\n+            { \"AES\/KWP\/NoPadding\", \"be96dc195ec034d616486ed70e97fe83\", 16,\n+              \"85b5437b6335ebba7635903a4493d12a77d9357a9e0dbc013456d85f1d3201\",\n+              31,\n+              \"974769b3a7b4d5d32985f87fddf9990631e5610fbfb278387b58b1f48e05c7\" +\n+              \"7d2fb7575c5169eb0e\" },\n+            { \"AES\/KWP\/NoPadding\", \"0e54956a24c7d4a343f90269fb18a17f\", 16,\n+              \"817ddabdc5d215eee233adff97e92193c6beec52a71340477f70243a794ce9\" +\n+              \"54af51e356c9940e4ab198f0e68c543355f65ad179cb2d60dd369eaeb9ed14\" +\n+              \"1fb18c9e4054ac7fdc83506896990a4d20833d2d6e9a34938796ee67c9d7d2\" +\n+              \"3058544a4a35f2954103ce443a95a7e785602075ca0a73da37899e4568106b\" +\n+              \"b2dbf1f901377d4d3380c70fa5175ebc550481ac6f15986a4407fde5c23ff3\" +\n+              \"17e37544c0a25f87117506597db5bb79850c86247b73a5d0090417d63e4c25\" +\n+              \"7ea0220c2c04db07a34f0ab7954e1dfa2007a1466795c4d0c2aa09ca3986c0\" +\n+              \"28185b43a466526594afc9c891c263a7c608304bc1957c9873f544dc71e6f8\" +\n+              \"47c48d32026ed03b2333825452ee7e12a50e1cd7d678319264c65f78001996\" +\n+              \"d37fae7f9861fbd21cb506c2f8a3b0ee53c7debe17111b6e3f78a5c5677857\" +\n+              \"b082c2c4943dfd1edf6337fea98a44fc25928361156ef38d865948b979cf6f\" +\n+              \"4b46bd2119f12f0891cef7fc9d0638fd105fc05f9968d16948d1cb820751e8\" +\n+              \"2e44cb68e99d4f072ffd1577da6c0631b5827bec7e1b9ec72d18b74cf5f233\" +\n+              \"e85013c1668ceb5d7a1f5e0f016b0ff726a0a9d41e2cea8e14a2f56492b146\" +\n+              \"06d3fafd8ac141335f39f90d56863735628e8f17be90e100ef0785f3cd57db\" +\n+              \"8b9d89a6b2189dc2ea00c285d2657983f8bd7883c215477e67a55556401f1d\" +\n+              \"8b27d4e0d541c7fb7ace370c2e428884\", 512,\n+              \"876f3e53ba9cf4f6a521ac198bc813d0ede0f862ab6082e3e0a06ad82b4f27\" +\n+              \"9582f7c43bb63574608446bc2a05f401a68f74086cf2776b4b3df6b3679c2e\" +\n+              \"dfb91c024db54c6831e0752ae6f86c7596462de905ee0be908c1b9d043ecaf\" +\n+              \"e2ad1cbddb904e18ebc9b7a107031be3a87059516a3d1257812d9c801b0b9f\" +\n+              \"21539e70c47150c128d87c5e58fa6e4371aedde69c7b5cd16b73ac42267632\" +\n+              \"8131f3ac48c602bb6e0741805aad9d23b33b3523b86cf0588cdf9dc6c4d5f9\" +\n+              \"fa43d88ca17976eaf48fb37a41a598266da04144373df5631cc5126341c200\" +\n+              \"a0c8499b29ae96e6e6e6c2bdf8d8903da62bf8ddae970569b695240e77f8ac\" +\n+              \"5b191da5034008b6ef21936858e69bac372bbafd8794f6b03711503c187552\" +\n+              \"8a9348681844edb199a0664d740f0f0b1f866c4248c80fe8b5700a3c4134cd\" +\n+              \"ddb17676e0cd37d6d81831a0f4adfba071bb0935502480eccd48b28be5954e\" +\n+              \"a6c7d873b51b8bd2b709c5b6132ed31296510915073c18f7012f0eff6a9aad\" +\n+              \"5340a19fd5e372d35260b718d9e4807b1954c24e6a4fd48e4dbb8f395474e9\" +\n+              \"9ab577367d2ab5ccaa18c947331047dc3986e213a878b41089aa221019dad4\" +\n+              \"191a4feefd095f8606c2700a46d71cbb13efb6957df925ec26071c04d04d5a\" +\n+              \"94e138e5fc5d1f059236aad76208077dcc607b1dd2086f9c04e33f955822b4\" +\n+              \"57eecd68bd5f24836ecedbac675e6ed93d8a787cb57ad68e\" },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testData\")\n+    public void testKeyWrap(String algo, String key, int keyLen,\n+            String data, int dataLen, String expected) throws Exception {\n+        System.out.println(\"Testing \" +  algo + \" Cipher with wrapping \" +\n+            dataLen + \"-byte key with \" + 8*keyLen + \"-bit KEK\");\n+        int allowed = Cipher.getMaxAllowedKeyLength(\"AES\");\n+        if (keyLen > allowed) {\n+            System.out.println(\"=> skip, exceeds max allowed size \" + allowed);\n+            return;\n+        }\n+        Cipher c = Cipher.getInstance(algo, \"SunJCE\");\n+        byte[] keyVal = toBytes(key, keyLen << 1);\n+        byte[] dataVal = toBytes(data, dataLen << 1);\n@@ -83,7 +257,4 @@\n-        byte[] expectedVal = new BigInteger(expected, 16).toByteArray();\n-        \/\/ need to add offset since BigInteger may pad \"0x00\" in the beginning\n-        int offset = expectedVal.length - wrapped.length;\n-        for (int i=0; i<wrapped.length; i++) {\n-            if (wrapped[i] != expectedVal[offset + i]) {\n-                throw new Exception(\"Wrap failed; got different result\");\n-            }\n+        byte[] expectedVal = toBytes(expected, expected.length());\n+\n+        if (!Arrays.equals(wrapped, expectedVal)) {\n+            throw new Exception(\"Wrap failed; got different result\");\n@@ -100,4 +271,5 @@\n-    public static void main(String[] argv) throws Exception {\n-        testKeyWrap(16, 16, AES128_128);\n-        \/\/ only run the tests on longer key lengths if unlimited version\n-        \/\/ of JCE jurisdiction policy files are installed\n+    @Test(dataProvider = \"testData\")\n+    public void testEnc(String algo, String key, int keyLen, String data, int dataLen, String expected)\n+            throws Exception {\n+        System.out.println(\"Testing \" +  algo + \" Cipher with enc \" +\n+            dataLen + \"-byte data with \" + 8*keyLen + \"-bit KEK\");\n@@ -105,3 +277,3 @@\n-        if (allowed >= 24*8) {\n-            testKeyWrap(24, 16, AES192_128);\n-            testKeyWrap(24, 24, AES192_192);\n+        if (keyLen > allowed) {\n+            System.out.println(\"=> skip, exceeds max allowed size \" + allowed);\n+            return;\n@@ -109,4 +281,27 @@\n-        if (allowed >= 32*8) {\n-            testKeyWrap(32, 16, AES256_128);\n-            testKeyWrap(32, 24, AES256_192);\n-            testKeyWrap(32, 32, AES256_256);\n+        Cipher c = Cipher.getInstance(algo, \"SunJCE\");\n+\n+        byte[] keyVal = toBytes(key, keyLen << 1);\n+        byte[] dataVal = toBytes(data, dataLen << 1);\n+\n+        SecretKey cipherKey = new SecretKeySpec(keyVal, \"AES\");\n+        c.init(Cipher.ENCRYPT_MODE, cipherKey);\n+\n+        \/\/ first test encryption with known values\n+        byte[] ct11 = c.update(dataVal);\n+        byte[] ct12 = c.doFinal();\n+        byte[] ct2 = c.doFinal(dataVal);\n+        byte[] expectedVal = toBytes(expected, expected.length());\n+\n+        if (ct11 != null || !Arrays.equals(ct12, ct2) ||\n+            !Arrays.equals(ct2, expectedVal)) {\n+            throw new Exception(\"Encryption failed; got different result\");\n+        }\n+\n+        \/\/ then test decryption and compare with the initial values\n+        c.init(Cipher.DECRYPT_MODE, cipherKey);\n+        byte[] pt11 = c.update(ct12);\n+        byte[] pt12 = c.doFinal();\n+        byte[] pt2 = c.doFinal(ct2);\n+        if (pt11 != null || !Arrays.equals(pt12, pt2) ||\n+            !Arrays.equals(pt2, dataVal)) {\n+            throw new Exception(\"Decryption failed; got different result\");\n@@ -114,1 +309,0 @@\n-        System.out.println(\"All Tests Passed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/NISTWrapKAT.java","additions":240,"deletions":46,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8248268\n+ * @summary Verify general properties of the AES\/KW\/NoPadding,\n+ *     AES\/KW\/PKCS5Padding, and AES\/KWP\/NoPadding.\n+ * @run main TestGeneral\n+ *\/\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.security.Key;\n+import java.security.InvalidAlgorithmParameterException;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+public class TestGeneral {\n+\n+    private static final SecretKey KEY = new SecretKeySpec(new byte[16], \"AES\");;\n+    private static final int KW_IV_LEN = 8;\n+    private static final int KWP_IV_LEN = 4;\n+    private static final int MAX_KW_PKCS5PAD_LEN = 16; \/\/ 1-16\n+    private static final int MAX_KWP_PAD_LEN = 7; \/\/ 0...7\n+\n+    public static void testEnc(Cipher c, byte[] in, int inLen, int ivLen,\n+            int maxPadLen) throws Exception {\n+\n+        System.out.println(\"input len: \" + inLen);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+\n+        int estOutLen = c.getOutputSize(inLen);\n+\n+        byte[] out = c.doFinal(in, 0, inLen);\n+\n+        \/\/ for encryption output, the estimate should match the actual\n+        if (estOutLen != out.length) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual enc out length: \" + out.length);\n+            throw new RuntimeException(\"Failed enc output len check\");\n+        }\n+\n+        \/\/ encryption outout should always be multiple of 8 and at least 8-byte\n+        \/\/ longer than input\n+        if ((out.length % 8 != 0) || (out.length - inLen < 8)) {\n+            throw new RuntimeException(\"Invalid length of encrypted data: \" +\n+                out.length);\n+        }\n+\n+        c.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+        estOutLen = c.getOutputSize(out.length);\n+\n+        byte[] in2 = c.doFinal(out);\n+\n+        \/\/ for decryption output, the estimate should match the actual for\n+        \/\/ AES\/KW\/NoPadding and slightly larger than the actual for the rest\n+        if (estOutLen < in2.length || (estOutLen - in2.length) > maxPadLen) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual dec out length: \" + in2.length);\n+            throw new RuntimeException(\"Failed dec output len check\");\n+        }\n+\n+        if (!Arrays.equals(in, 0, inLen, in2, 0, inLen)) {\n+            throw new RuntimeException(\"Failed decrypted data check\");\n+        }\n+    }\n+\n+    public static void testWrap(Cipher c, byte[] in, int inLen, int ivLen,\n+            int maxPadLen) throws Exception {\n+\n+        System.out.println(\"key len: \" + inLen);\n+        c.init(Cipher.WRAP_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+\n+        int estOutLen = c.getOutputSize(inLen);\n+\n+        byte[] out = c.wrap(new SecretKeySpec(in, 0, inLen, \"Any\"));\n+\n+        \/\/ for encryption output, the estimate should match the actual\n+        if (estOutLen != out.length) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual wrap out length: \" + out.length);\n+            throw new RuntimeException(\"Failed wrap output len check\");\n+        }\n+\n+        \/\/ encryption outout should always be multiple of 8 and at least 8-byte\n+        \/\/ longer than input\n+        if ((out.length % 8 != 0) || (out.length - inLen < 8)) {\n+            throw new RuntimeException(\"Invalid length of encrypted data: \" +\n+                out.length);\n+        }\n+        c.init(Cipher.UNWRAP_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+        estOutLen = c.getOutputSize(out.length);\n+\n+        Key key2 = c.unwrap(out, \"Any\", Cipher.SECRET_KEY);\n+\n+        if (!(key2 instanceof SecretKey)) {\n+            throw new RuntimeException(\"Failed unwrap output type check\");\n+        }\n+\n+        byte[] in2 = key2.getEncoded();\n+        \/\/ for decryption output, the estimate should match the actual for\n+        \/\/ AES\/KW\/NoPadding and slightly larger than the actual for the rest\n+        if (estOutLen < in2.length || (estOutLen - in2.length) > maxPadLen) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual unwrap out length: \" + in2.length);\n+            throw new RuntimeException(\"Failed unwrap output len check\");\n+        }\n+\n+        if (inLen != in2.length ||\n+                !Arrays.equals(in, 0, inLen, in2, 0, inLen)) {\n+            throw new RuntimeException(\"Failed unwrap data check\");\n+        }\n+    }\n+\n+    public static void testIv(Cipher c) throws Exception {\n+        c.init(Cipher.ENCRYPT_MODE, KEY);\n+        byte[] defIv = c.getIV();\n+        \/\/ try init w\/ an iv w\/ different length\n+        try {\n+            c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv, 0,\n+                defIv.length\/2));\n+        } catch (InvalidAlgorithmParameterException iape) {\n+            System.out.println(\"Invalid IV rejected as expected\");\n+        }\n+        Arrays.fill(defIv, (byte) 0xFF);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv));\n+        byte[] newIv = c.getIV();\n+        if (!Arrays.equals(newIv, defIv)) {\n+            throw new RuntimeException(\"Failed iv check\");\n+        }\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+        \/\/ test all possible pad lengths, i.e. 1 - 16\n+        byte[] data = new byte[128];\n+        new Random().nextBytes(data);\n+\n+        String ALGO = \"AES\/KW\/PKCS5Padding\";\n+        System.out.println(\"Testing \" + ALGO);\n+        Cipher c = Cipher.getInstance(ALGO, \"SunJCE\");\n+        for (int i = 0; i < MAX_KW_PKCS5PAD_LEN; i++) {\n+            testEnc(c, data, data.length - i, KW_IV_LEN, MAX_KW_PKCS5PAD_LEN);\n+            testWrap(c, data, data.length - i, KW_IV_LEN, MAX_KW_PKCS5PAD_LEN);\n+        }\n+        testIv(c);\n+\n+        ALGO = \"AES\/KW\/NoPadding\";\n+        System.out.println(\"Testing \" + ALGO);\n+        c = Cipher.getInstance(ALGO, \"SunJCE\");\n+        testEnc(c, data, data.length, KW_IV_LEN, 0);\n+        testEnc(c, data, data.length >> 1, KW_IV_LEN, 0);\n+        testWrap(c, data, data.length, KW_IV_LEN, 0);\n+        testWrap(c, data, data.length >> 1, KW_IV_LEN, 0);\n+        testIv(c);\n+\n+        ALGO = \"AES\/KWP\/NoPadding\";\n+        System.out.println(\"Testing \" + ALGO);\n+        c = Cipher.getInstance(ALGO, \"SunJCE\");\n+        for (int i = 0; i < MAX_KWP_PAD_LEN; i++) {\n+            testEnc(c, data, data.length - i, KWP_IV_LEN, MAX_KWP_PAD_LEN);\n+            testWrap(c, data, data.length - i, KWP_IV_LEN, MAX_KWP_PAD_LEN);\n+        }\n+        testIv(c);\n+\n+        System.out.println(\"All Tests Passed\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestGeneral.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n- * @bug 8075286\n- * @summary Test the AESWrap algorithm OIDs in JDK.\n+ * @bug 8075286 8248268\n+ * @summary Test the AES-Key-Wrap and AES-Key-Wrap-Pad algorithm OIDs in JDK.\n@@ -52,3 +52,9 @@\n-            new DataTuple(\"2.16.840.1.101.3.4.1.5\", \"AESWrap_128\", 128),\n-            new DataTuple(\"2.16.840.1.101.3.4.1.25\", \"AESWrap_192\", 192),\n-            new DataTuple(\"2.16.840.1.101.3.4.1.45\", \"AESWrap_256\", 256));\n+            new DataTuple(\"2.16.840.1.101.3.4.1.5\", \"AESWrap_128\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.25\", \"AESWrap_192\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.45\", \"AESWrap_256\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.5\", \"AES_128\/KW\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.25\", \"AES_192\/KW\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.45\", \"AES_256\/KW\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\"));\n@@ -148,1 +154,1 @@\n-        private DataTuple(String oid, String algorithm, int keyLength) {\n+        private DataTuple(String oid, String algorithm) {\n@@ -151,1 +157,6 @@\n-            this.keyLength = keyLength;\n+            this.keyLength = switch (oid) {\n+                case \"2.16.840.1.101.3.4.1.5\", \"2.16.840.1.101.3.4.1.8\"->128;\n+                case \"2.16.840.1.101.3.4.1.25\", \"2.16.840.1.101.3.4.1.28\"->192;\n+                case \"2.16.840.1.101.3.4.1.45\", \"2.16.840.1.101.3.4.1.48\"->256;\n+                default->throw new RuntimeException(\"Unrecognized oid: \" + oid);\n+            };\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/NSASuiteB\/TestAESWrapOids.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4953556 8210838\n+ * @bug 4953556 8210838 8248268\n@@ -42,1 +42,11 @@\n-    private static final String ALGO = \"DES\";\n+    private static final String[] TRANSFORMATIONS = {\n+        \"DES\/ECB\/PKCS5Padding\",\n+        \"AES\/KW\/NoPadding\",\n+        \"AES\/KW\/PKCS5Padding\",\n+        \"AES\/KWP\/NoPadding\",\n+    };\n+\n+    private static final SecretKey DES_KEY =\n+            new SecretKeySpec(new byte[8], \"DES\");\n+    private static final SecretKey AES_KEY =\n+            new SecretKeySpec(new byte[16], \"AES\");\n@@ -45,9 +55,13 @@\n-        TestCipherMode test = new TestCipherMode();\n-        System.out.println(\"Testing ENCRYPT_MODE...\");\n-        test.checkMode(Cipher.ENCRYPT_MODE, \"encryption\");\n-        System.out.println(\"Testing DECRYPT_MODE...\");\n-        test.checkMode(Cipher.DECRYPT_MODE, \"decryption\");\n-        System.out.println(\"Testing WRAP_MODE...\");\n-        test.checkMode(Cipher.WRAP_MODE, \"key wrapping\");\n-        System.out.println(\"Testing UNWRAP_MODE...\");\n-        test.checkMode(Cipher.UNWRAP_MODE, \"key unwrapping\");\n+        for (String t : TRANSFORMATIONS) {\n+            System.out.println(\"Testing SunJCE provider, Cipher \" + t );\n+\n+            TestCipherMode test = new TestCipherMode(t);\n+            System.out.println(\"Testing ENCRYPT_MODE...\");\n+            test.checkMode(Cipher.ENCRYPT_MODE, \"encryption\");\n+            System.out.println(\"Testing DECRYPT_MODE...\");\n+            test.checkMode(Cipher.DECRYPT_MODE, \"decryption\");\n+            System.out.println(\"Testing WRAP_MODE...\");\n+            test.checkMode(Cipher.WRAP_MODE, \"key wrapping\");\n+            System.out.println(\"Testing UNWRAP_MODE...\");\n+            test.checkMode(Cipher.UNWRAP_MODE, \"key unwrapping\");\n+        }\n@@ -60,10 +74,10 @@\n-    private TestCipherMode() throws NoSuchAlgorithmException,\n-    NoSuchProviderException, NoSuchPaddingException {\n-        c = Cipher.getInstance(ALGO + \"\/ECB\/PKCS5Padding\", \"SunJCE\");\n-        String output = c.toString();\n-        if (!output.equals(\n-                \"Cipher.DES\/ECB\/PKCS5Padding, mode: not initialized, algorithm from: SunJCE\")) {\n-            throw new RuntimeException(\n-                    \"Unexpected Cipher.toString() output:\" + output);\n-        }\n-        key = new SecretKeySpec(new byte[8], ALGO);\n+    private TestCipherMode(String transformation)\n+            throws NoSuchAlgorithmException, NoSuchProviderException,\n+            NoSuchPaddingException {\n+        c = Cipher.getInstance(transformation, \"SunJCE\");\n+        this.key = switch (transformation.split(\"\/\")[0]) {\n+            case \"DES\" -> DES_KEY;\n+            case \"AES\" -> AES_KEY;\n+            default -> throw new RuntimeException\n+                    (\"Error: Unsupported key algorithm\");\n+        };\n@@ -74,6 +88,0 @@\n-        String output = c.toString();\n-        if (!output.contains(\"Cipher.DES\/ECB\/PKCS5Padding\")\n-                && !output.contains(opString)\n-                && !output.contains(\"Algorithm from: SunJCE\")) {\n-            throw new Exception(\"Unexpected toString() output:\" + output);\n-        }\n@@ -92,1 +100,1 @@\n-                c.unwrap(new byte[16], ALGO, Cipher.SECRET_KEY);\n+                c.unwrap(new byte[16], key.getAlgorithm(), Cipher.SECRET_KEY);\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestCipherMode.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+import java.security.Key;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\n+public class AESKeyWrapBench extends CryptoBase {\n+\n+    @Param({\"AES\/KW\/NoPadding\" , \"AES\/KW\/PKCS5Padding\", \"AES\/KWP\/NoPadding\"})\n+    private String algorithm;\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"16\", \"24\"})\n+    private int dataSize;\n+\n+    SecretKeySpec toBeWrappedKey;\n+    byte[] wrappedKey;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+\n+    @Setup\n+    public void setup() throws NoSuchAlgorithmException, NoSuchPaddingException,\n+            InvalidKeyException, IllegalBlockSizeException {\n+        setupProvider();\n+\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        encryptCipher = makeCipher(prov, algorithm);\n+        encryptCipher.init(Cipher.WRAP_MODE, ks);\n+        decryptCipher = makeCipher(prov, algorithm);\n+        decryptCipher.init(Cipher.UNWRAP_MODE, ks);\n+        byte[] data = fillRandom(new byte[dataSize]);\n+        toBeWrappedKey = new SecretKeySpec(data, \"Custom\");\n+        wrappedKey = encryptCipher.wrap(toBeWrappedKey);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public byte[] wrap() throws InvalidKeyException, IllegalBlockSizeException {\n+        return encryptCipher.wrap(toBeWrappedKey);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Key unwrap() throws InvalidKeyException, NoSuchAlgorithmException {\n+        return decryptCipher.unwrap(wrappedKey, \"Custom\", Cipher.SECRET_KEY);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESKeyWrapBench.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}