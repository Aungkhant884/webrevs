{"files":[{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_GC_G1_G1GLOBALS_AARCH64_HPP\n+#define CPU_AARCH64_GC_G1_G1GLOBALS_AARCH64_HPP\n+\n+const size_t G1MergeHeapRootsPrefetchCacheSize = 16;\n+\n+#endif \/\/ CPU_AARCH64_GC_G1_G1GLOBALS_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1Globals_aarch64.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_GC_G1_G1GLOBALS_ARM_HPP\n+#define CPU_AARCH64_GC_G1_G1GLOBALS_ARM_HPP\n+\n+const size_t G1MergeHeapRootsPrefetchCacheSize = 16;\n+\n+#endif \/\/ CPU_AARCH64_GC_G1_G1GLOBALS_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1Globals_arm.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_GC_G1_G1GLOBALS_PPC_HPP\n+#define CPU_AARCH64_GC_G1_G1GLOBALS_PPC_HPP\n+\n+const size_t G1MergeHeapRootsPrefetchCacheSize = 8;\n+\n+#endif \/\/ CPU_AARCH64_GC_G1_G1GLOBALS_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1Globals_ppc.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_GC_G1_G1GLOBALS_S390_HPP\n+#define CPU_AARCH64_GC_G1_G1GLOBALS_S390_HPP\n+\n+const size_t G1MergeHeapRootsPrefetchCacheSize = 8;\n+\n+#endif \/\/ CPU_AARCH64_GC_G1_G1GLOBALS_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1Globals_s390.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_GC_G1_G1GLOBALS_X86_HPP\n+#define CPU_AARCH64_GC_G1_G1GLOBALS_X86_HPP\n+\n+const size_t G1MergeHeapRootsPrefetchCacheSize = 8;\n+\n+#endif \/\/ CPU_AARCH64_GC_G1_G1GLOBALS_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1Globals_x86.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_GC_G1_G1GLOBALS_ZERO_HPP\n+#define CPU_AARCH64_GC_G1_G1GLOBALS_ZERO_HPP\n+\n+const size_t G1MergeHeapRootsPrefetchCacheSize = 8;\n+\n+#endif \/\/ CPU_AARCH64_GC_G1_G1GLOBALS_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/gc\/g1\/g1Globals_zero.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -96,2 +96,2 @@\n-  \/\/ Mark the given card as Dirty if it is Clean. Returns the number of dirtied\n-  \/\/ cards that were not yet dirty. This result may be inaccurate as it does not\n+  \/\/ Mark the given card as Dirty if it is Clean. Returns whether the card has\n+  \/\/ been Clean before this operation. This result may be inaccurate as it does not\n@@ -99,1 +99,1 @@\n-  inline size_t mark_clean_as_dirty(size_t card_index);\n+  inline bool mark_clean_as_dirty(CardValue* card);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-inline size_t G1CardTable::mark_clean_as_dirty(size_t card_index) {\n-  CardValue value = _byte_map[card_index];\n+inline bool G1CardTable::mark_clean_as_dirty(CardValue* card) {\n+  CardValue value = *card;\n@@ -39,2 +39,2 @@\n-    _byte_map[card_index] = dirty_card_val();\n-    return 1;\n+    *card = dirty_card_val();\n+    return true;\n@@ -42,1 +42,1 @@\n-  return 0;\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include CPU_HEADER(gc\/g1\/g1Globals)\n@@ -1063,0 +1064,46 @@\n+\/\/ Small ring buffer used for prefetching cards for read\/write from the card\n+\/\/ table during GC.\n+template <class T, bool for_write>\n+class G1MergeHeapRootsPrefetchCache {\n+public:\n+  static const uint CacheSize = G1MergeHeapRootsPrefetchCacheSize;\n+\n+  STATIC_ASSERT(is_power_of_2(CacheSize));\n+\n+private:\n+  T* _cache[CacheSize];\n+\n+  uint _cur_cache_idx;\n+\n+  NONCOPYABLE(G1MergeHeapRootsPrefetchCache);\n+\n+protected:\n+  \/\/ Initial content of all elements in the cache. It's value be \"neutral\", i.e.\n+  \/\/ no work done on it.\n+  G1CardTable::CardValue _dummy_card;\n+\n+public:\n+\n+  G1MergeHeapRootsPrefetchCache(G1CardTable::CardValue dummy_card_value) :\n+    _cur_cache_idx(0),\n+    _dummy_card(dummy_card_value) {\n+\n+    for (uint i = 0; i < CacheSize; i++) {\n+      push(&_dummy_card);\n+    }\n+  }\n+\n+  T* push(T* elem) {\n+    if (for_write) {\n+      Prefetch::write(elem, 0);\n+    } else {\n+      Prefetch::read(elem, 0);\n+    }\n+    T* result = _cache[_cur_cache_idx];\n+    _cache[_cur_cache_idx++] = elem;\n+    _cur_cache_idx &= (CacheSize - 1);\n+\n+    return result;\n+  }\n+};\n+\n@@ -1066,0 +1113,3 @@\n+  \/\/ We add a small prefetching cache in front of the actual work as dropping\n+  \/\/ onto the card table is basically random memory access. This improves\n+  \/\/ performance of this operation significantly.\n@@ -1067,0 +1117,2 @@\n+    friend class G1MergeCardSetCache;\n+\n@@ -1076,1 +1128,22 @@\n-    \/\/ Returns if the region contains cards we need to scan. If so, remember that\n+    \/\/ Cached card table index of the currently processed region to avoid constant\n+    \/\/ recalculation as our remembered set containers are per region.\n+    size_t _region_base_idx;\n+\n+    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true> {\n+      G1MergeCardSetClosure* const _merge_card_cl;\n+\n+    public:\n+      G1MergeCardSetCache(G1MergeCardSetClosure* const merge_card_cl) :\n+        \/\/ Initially set dummy card value to dirty to avoid any actual mark work if we\n+        \/\/ try to process it.\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true>(G1CardTable::dirty_card_val()),\n+        _merge_card_cl(merge_card_cl) { }\n+\n+      ~G1MergeCardSetCache() {\n+        for (uint i = 0; i < CacheSize; i++) {\n+          _merge_card_cl->mark_card(push(&_dummy_card));\n+        }\n+      }\n+    } _merge_card_set_cache;\n+\n+    \/\/ Returns whether the region contains cards we need to scan. If so, remember that\n@@ -1085,0 +1158,12 @@\n+\n+    void mark_card(G1CardTable::CardValue* value) {\n+      if (_ct->mark_clean_as_dirty(value)) {\n+        _cards_dirty++;\n+        _scan_state->set_chunk_dirty(_ct->index_for_cardvalue(value));\n+      }\n+    }\n+\n+    void start_iterate(uint const region_idx) {\n+      _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+    }\n+\n@@ -1092,1 +1177,11 @@\n-      _cards_dirty(0) { }\n+      _cards_dirty(0),\n+      _region_base_idx(0),\n+      _merge_card_set_cache(this) {\n+    }\n+\n+    void do_card(uint const card_idx) {\n+      G1CardTable::CardValue* to_prefetch = _ct->byte_for_index(_region_base_idx + card_idx);\n+      G1CardTable::CardValue* to_process = _merge_card_set_cache.push(to_prefetch);\n+\n+      mark_card(to_process);\n+    }\n@@ -1101,3 +1196,3 @@\n-      size_t region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n-      _cards_dirty += _ct->mark_region_dirty(region_base_idx, HeapRegion::CardsPerRegion);\n-      _scan_state->set_chunk_region_dirty(region_base_idx);\n+      start_iterate(region_idx);\n+      _cards_dirty += _ct->mark_region_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n+      _scan_state->set_chunk_region_dirty(_region_base_idx);\n@@ -1113,1 +1208,1 @@\n-      size_t const region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+      start_iterate(region_idx);\n@@ -1116,2 +1211,1 @@\n-        _cards_dirty += _ct->mark_clean_as_dirty(region_base_idx + cur);\n-        _scan_state->set_chunk_dirty(region_base_idx + cur);\n+        do_card((uint)cur);\n@@ -1129,1 +1223,1 @@\n-      size_t const region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+      start_iterate(region_idx);\n@@ -1131,3 +1225,1 @@\n-        size_t card_idx = region_base_idx + cards[i];\n-        _cards_dirty += _ct->mark_clean_as_dirty(card_idx);\n-        _scan_state->set_chunk_dirty(card_idx);\n+        do_card(cards[i]);\n@@ -1225,0 +1317,2 @@\n+    friend class G1MergeLogBufferCardsCache;\n+\n@@ -1230,0 +1324,27 @@\n+\n+    class G1MergeLogBufferCardsCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false> {\n+      G1MergeLogBufferCardsClosure* const _merge_log_buffer_cl;\n+\n+    public:\n+      G1MergeLogBufferCardsCache(G1MergeLogBufferCardsClosure* const merge_log_buffer_cl) :\n+        \/\/ Initially set dummy card value to clean to avoid any actual work if we\n+        \/\/ try to process it.\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false>(G1CardTable::clean_card_val()),\n+        _merge_log_buffer_cl(merge_log_buffer_cl) { }\n+\n+      ~G1MergeLogBufferCardsCache() {\n+        for (uint i = 0; i < CacheSize; i++) {\n+          _merge_log_buffer_cl->process_card(push(&_dummy_card));\n+        }\n+      }\n+    } _merge_log_buffer_cache;\n+\n+    void process_card(CardValue* card_ptr) {\n+      if (*card_ptr == G1CardTable::dirty_card_val()) {\n+        uint const region_idx = _ct->region_idx_for(card_ptr);\n+        _scan_state->add_dirty_region(region_idx);\n+        _scan_state->set_chunk_dirty(_ct->index_for_cardvalue(card_ptr));\n+        _cards_dirty++;\n+      }\n+    }\n+\n@@ -1232,1 +1353,5 @@\n-      _scan_state(scan_state), _ct(g1h->card_table()), _cards_dirty(0), _cards_skipped(0)\n+      _scan_state(scan_state),\n+      _ct(g1h->card_table()),\n+      _cards_dirty(0),\n+      _cards_skipped(0),\n+      _merge_log_buffer_cache(this)\n@@ -1248,4 +1373,3 @@\n-      if (_scan_state->contains_cards_to_process(region_idx) && (*card_ptr == G1CardTable::dirty_card_val())) {\n-        _scan_state->add_dirty_region(region_idx);\n-        _scan_state->set_chunk_dirty(_ct->index_for_cardvalue(card_ptr));\n-        _cards_dirty++;\n+      if (_scan_state->contains_cards_to_process(region_idx)) {\n+        CardValue* to_process = _merge_log_buffer_cache.push(card_ptr);\n+        process_card(to_process);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":141,"deletions":17,"binary":false,"changes":158,"status":"modified"}]}