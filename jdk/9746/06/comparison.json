{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.source.tree.CaseTree.CaseKind;\n@@ -67,1 +68,1 @@\n-import java.util.HashMap;\n+import java.util.Collections;\n@@ -70,0 +71,2 @@\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n@@ -71,0 +74,1 @@\n+import java.util.Set;\n@@ -80,0 +84,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCBlock.PatternMatchingCatch;\n@@ -83,0 +88,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCCatch;\n@@ -87,0 +93,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n@@ -97,0 +104,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCTry;\n@@ -99,0 +107,1 @@\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -102,0 +111,1 @@\n+import com.sun.tools.javac.util.Pair;\n@@ -166,4 +176,0 @@\n-    JCLabeledStatement pendingMatchLabel = null;\n-\n-    boolean debugTransPatterns;\n-\n@@ -176,0 +182,2 @@\n+    private Set<JCMethodInvocation> deconstructorCalls;\n+    private int variableIndex = 0;\n@@ -188,1 +196,0 @@\n-        debugTransPatterns = Options.instance(context).isSet(\"debug.patterns\");\n@@ -193,2 +200,13 @@\n-        if (tree.pattern instanceof JCPattern) {\n-            \/\/E instanceof $pattern\n+        if (tree.pattern instanceof JCPattern pattern) {\n+            \/\/first, resolve any parenthesized and record patterns:\n+            pattern = TreeInfo.skipParens(pattern);\n+            JCExpression extraConditions = null;\n+            if (pattern instanceof JCRecordPattern recordPattern) {\n+                UnrolledRecordPattern unrolledRecordPattern = unrollRecordPattern(recordPattern);\n+                pattern = unrolledRecordPattern.primaryPattern();\n+                extraConditions = unrolledRecordPattern.newGuard();\n+            }\n+            \/\/$pattern is now always a binding pattern, $extraConditions are possibly additional tests\n+            \/\/implementing to the record pattern\n+            \/\/\n+            \/\/E instanceof $patternType $patternName && $extraConditions\n@@ -196,2 +214,3 @@\n-            \/\/(let T' N$temp = E; N$temp instanceof typeof($pattern) && <desugared $pattern>)\n-            \/\/note the pattern desugaring performs binding variable assignments\n+            \/\/(let $patternType N$temp = E; N$temp instanceof $patternType &&\n+            \/\/                              (let $patternName = ($patternType) N$temp; true) &&\n+            \/\/                              $extraConditions)\n@@ -213,1 +232,1 @@\n-                            names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                            names.fromString(\"patt\" + variableIndex++ + target.syntheticNameChar() + \"temp\"),\n@@ -218,5 +237,12 @@\n-                Type principalType = principalType((JCPattern) tree.pattern);\n-                JCExpression resultExpression=\n-                        makeBinary(Tag.AND,\n-                                   makeTypeTest(make.Ident(currentValue), make.Type(principalType)),\n-                                   (JCExpression) this.<JCTree>translate(tree.pattern));\n+                Type principalType = types.erasure(TreeInfo.primaryPatternType((pattern)));\n+                 JCExpression resultExpression= (JCExpression) this.<JCTree>translate(pattern);\n+                if (!tree.allowNull || !types.isSubtype(currentValue.type, principalType)) {\n+                    resultExpression =\n+                            makeBinary(Tag.AND,\n+                                       makeTypeTest(make.Ident(currentValue), make.Type(principalType)),\n+                                       resultExpression);\n+                }\n+                if (extraConditions != null) {\n+                    extraConditions = translate(extraConditions);\n+                    resultExpression = makeBinary(Tag.AND, resultExpression, extraConditions);\n+                }\n@@ -243,1 +269,1 @@\n-        Type castTargetType = principalType(tree);\n+        Type castTargetType = types.erasure(TreeInfo.primaryPatternType(tree));\n@@ -266,1 +292,8 @@\n-        \/\/type test already done, finish handling of deconstruction patterns (\"T(PATT1, PATT2, ...)\")\n+        \/\/record patterns should be resolved by the constructs that use them.\n+        Assert.error();\n+    }\n+\n+    private UnrolledRecordPattern unrollRecordPattern(JCRecordPattern recordPattern) {\n+        \/\/Convert a record pattern in the basic binding pattern and additional conditions\n+        \/\/implementing the record pattern:\n+        \/\/$record($nestedPattern1, $nestedPattern2, ...) $r\n@@ -268,19 +301,10 @@\n-        \/\/<PATT1-handling> && <PATT2-handling> && ...\n-        List<? extends RecordComponent> components = tree.record.getRecordComponents();\n-        List<? extends Type> nestedFullComponentTypes = tree.fullComponentTypes;\n-        List<? extends JCPattern> nestedPatterns = tree.nested;\n-        JCExpression test = null;\n-        while (components.nonEmpty() && nestedFullComponentTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n-            \/\/PATTn for record component COMPn of type Tn;\n-            \/\/PATTn is a type test pattern or a deconstruction pattern:\n-            \/\/=>\n-            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); <PATTn extractor>)\n-            \/\/or\n-            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null && <PATTn extractor>)\n-            \/\/or\n-            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T' && <PATTn extractor>)\n-            RecordComponent component = components.head;\n-            JCPattern nested = nestedPatterns.head;\n-            VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,\n-                names.fromString(target.syntheticNameChar() + \"c\" + target.syntheticNameChar() + component.name),\n-                                 component.erasure(types),\n+        \/\/$record $r; type-test-of($nestedPattern1) && type-test-of($nestedPattern2) && ... &&\n+        \/\/            nested-conditions-of($nestedPattern1) && nested-conditions-of($nestedPattern2)\n+        Type recordType = recordPattern.record.erasure(types);\n+        JCVariableDecl recordBindingVar;\n+\n+        if (recordPattern.var != null) {\n+            recordBindingVar = recordPattern.var;\n+        } else {\n+            BindingSymbol tempBind = new BindingSymbol(Flags.SYNTHETIC,\n+                names.fromString(target.syntheticNameChar() + \"b\" + target.syntheticNameChar() + variableIndex++), recordType,\n@@ -288,18 +312,25 @@\n-            Symbol accessor = getAccessor(tree.pos(), component);\n-            JCVariableDecl nestedTempVar =\n-                    make.VarDef(nestedTemp,\n-                                make.App(make.QualIdent(accessor),\n-                                         List.of(convert(make.Ident(currentValue), tree.type))));\n-            JCExpression extracted;\n-            VarSymbol prevCurrentValue = currentValue;\n-            try {\n-                currentValue = nestedTemp;\n-                extracted = (JCExpression) this.<JCTree>translate(nested);\n-            } finally {\n-                currentValue = prevCurrentValue;\n-            }\n-            JCExpression extraTest = null;\n-            if (!types.isAssignable(nestedTemp.type, nested.type)) {\n-                if (!types.isAssignable(nestedFullComponentTypes.head, nested.type)) {\n-                    extraTest = makeTypeTest(make.Ident(nestedTemp),\n-                                             make.Type(nested.type));\n+            recordBindingVar = make.VarDef(tempBind, null);\n+        }\n+\n+        VarSymbol recordBinding = recordBindingVar.sym;\n+        List<? extends RecordComponent> components = recordPattern.record.getRecordComponents();\n+        List<? extends Type> nestedFullComponentTypes = recordPattern.fullComponentTypes;\n+        List<? extends JCPattern> nestedPatterns = recordPattern.nested;\n+        JCExpression firstLevelChecks = null;\n+        JCExpression secondLevelChecks = null;\n+\n+        while (components.nonEmpty()) {\n+            RecordComponent component = components.head;\n+            Type componentType = types.erasure(nestedFullComponentTypes.head);\n+            JCPattern nestedPattern = TreeInfo.skipParens(nestedPatterns.head);\n+            JCBindingPattern nestedBinding;\n+            boolean allowNull;\n+            if (nestedPattern instanceof JCRecordPattern nestedRecordPattern) {\n+                UnrolledRecordPattern nestedDesugared = unrollRecordPattern(nestedRecordPattern);\n+                JCExpression newGuard = nestedDesugared.newGuard();\n+                if (newGuard != null) {\n+                    if (secondLevelChecks == null) {\n+                        secondLevelChecks = newGuard;\n+                    } else {\n+                        secondLevelChecks = mergeConditions(secondLevelChecks, newGuard);\n+                    }\n@@ -307,2 +338,5 @@\n-            } else if (nested.type.isReference() && nested.hasTag(Tag.RECORDPATTERN)) {\n-                extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n+                nestedBinding = nestedDesugared.primaryPattern();\n+                allowNull = false;\n+            } else {\n+                nestedBinding = (JCBindingPattern) nestedPattern;\n+                allowNull = true;\n@@ -310,2 +344,5 @@\n-            if (extraTest != null) {\n-                extracted = makeBinary(Tag.AND, extraTest, extracted);\n+            JCMethodInvocation componentAccessor =\n+                    make.App(make.Select(convert(make.Ident(recordBinding), recordBinding.type), \/\/TODO - cast needed????\n+                             component.accessor));\n+            if (deconstructorCalls == null) {\n+                deconstructorCalls = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -313,5 +350,8 @@\n-            LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);\n-            getAndRun.needsCond = true;\n-            getAndRun.setType(syms.booleanType);\n-            if (test == null) {\n-                test = getAndRun;\n+            deconstructorCalls.add(componentAccessor);\n+            JCExpression accessedComponentValue =\n+                    convert(componentAccessor, componentType);\n+            JCInstanceOf firstLevelCheck = (JCInstanceOf) make.TypeTest(accessedComponentValue, nestedBinding).setType(syms.booleanType);\n+            \/\/TODO: verify deep\/complex nesting with nulls\n+            firstLevelCheck.allowNull = allowNull;\n+            if (firstLevelChecks == null) {\n+                firstLevelChecks = firstLevelCheck;\n@@ -319,1 +359,1 @@\n-                test = makeBinary(Tag.AND, test, getAndRun);\n+                firstLevelChecks = mergeConditions(firstLevelChecks, firstLevelCheck);\n@@ -325,18 +365,0 @@\n-\n-        if (tree.var != null) {\n-            BindingSymbol binding = (BindingSymbol) tree.var.sym;\n-            Type castTargetType = principalType(tree);\n-            VarSymbol bindingVar = bindingContext.bindingDeclared(binding);\n-\n-            JCAssign fakeInit =\n-                    (JCAssign) make.at(TreeInfo.getStartPos(tree))\n-                                   .Assign(make.Ident(bindingVar),\n-                                           convert(make.Ident(currentValue), castTargetType))\n-                                   .setType(bindingVar.erasure(types));\n-            LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n-                                            make.Literal(true));\n-            nestedLE.needsCond = true;\n-            nestedLE.setType(syms.booleanType);\n-            test = test != null ? makeBinary(Tag.AND, test, nestedLE) : nestedLE;\n-        }\n-\n@@ -344,2 +366,8 @@\n-        Assert.check(components.isEmpty() == nestedFullComponentTypes.isEmpty());\n-        result = test != null ? test : makeLit(syms.booleanType, 1);\n+        JCExpression guard = null;\n+        if (firstLevelChecks != null) {\n+            guard = firstLevelChecks;\n+            if (secondLevelChecks != null) {\n+                guard = mergeConditions(guard, secondLevelChecks);\n+            }\n+        }\n+        return new UnrolledRecordPattern((JCBindingPattern) make.BindingPattern(recordBindingVar).setType(recordBinding.type), guard);\n@@ -348,36 +376,1 @@\n-    private MethodSymbol getAccessor(DiagnosticPosition pos, RecordComponent component) {\n-        return component2Proxy.computeIfAbsent(component, c -> {\n-            MethodType type = new MethodType(List.of(component.owner.erasure(types)),\n-                                             types.erasure(component.type),\n-                                             List.nil(),\n-                                             syms.methodClass);\n-            MethodSymbol proxy = new MethodSymbol(Flags.PRIVATE | Flags.STATIC | Flags.SYNTHETIC,\n-                                                  names.fromString(\"$proxy$\" + component.name),\n-                                                  type,\n-                                                  currentClass);\n-            JCStatement accessorStatement =\n-                    make.Return(make.App(make.Select(make.Ident(proxy.params().head), c.accessor)));\n-            VarSymbol ctch = new VarSymbol(Flags.SYNTHETIC,\n-                    names.fromString(\"catch\" + currentClassTree.pos + target.syntheticNameChar()),\n-                    syms.throwableType,\n-                    currentMethodSym);\n-            JCNewClass newException = makeNewClass(syms.matchExceptionType,\n-                                                   List.of(makeApply(make.Ident(ctch),\n-                                                                     names.toString,\n-                                                                     List.nil()),\n-                                                           make.Ident(ctch)));\n-            JCTree.JCCatch catchClause = make.Catch(make.VarDef(ctch, null),\n-                                                    make.Block(0, List.of(make.Throw(newException))));\n-            JCStatement tryCatchAll = make.Try(make.Block(0, List.of(accessorStatement)),\n-                                               List.of(catchClause),\n-                                               null);\n-            JCMethodDecl md = make.MethodDef(proxy,\n-                                             proxy.externalType(types),\n-                                             make.Block(0, List.of(tryCatchAll)));\n-\n-            pendingMethods.append(md);\n-            currentClass.members().enter(proxy);\n-\n-            return proxy;\n-        });\n-    }\n+    record UnrolledRecordPattern(JCBindingPattern primaryPattern, JCExpression newGuard) {}\n@@ -409,1 +402,8 @@\n-            \/\/rewrite pattern matching switches:\n+            \/\/rewrite pattern matching switches, performed in several steps:\n+            \/\/1. record patterns are unrolled into a binding pattern and guards using unrollRecordPattern\n+            \/\/   (guards implement the nested pattern checks)\n+            \/\/   the switch only has constants and binding patterns as the\n+            \/\/2. the cases are processed through processCases, that will group cases with the same\n+            \/\/   binding pattern and similar guards, and will factor out the common binding pattern,\n+            \/\/   creating nested switches.\n+            \/\/3. the simplified binding-only switch with guards is then converted to an ordinary switch:\n@@ -411,4 +411,4 @@\n-            \/\/     case $constant: $stats$\n-            \/\/     case $pattern1: $stats$\n-            \/\/     case $pattern2, null: $stats$\n-            \/\/     case $pattern3: $stats$\n+            \/\/     case $constant: $stats1$\n+            \/\/     case $pattern2 when $guard2: $stats2$\n+            \/\/     case $pattern3, null: $stats3$\n+            \/\/     case $pattern4: $stats4$\n@@ -420,2 +420,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 1; continue $RESTART; }\n-            \/\/         $stats$\n+            \/\/         $stats1$\n@@ -423,1 +422,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 2; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern2> && $guard2)) { $idx = 2; continue $RESTART; }\n@@ -426,1 +425,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 3; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern3>)) { $idx = 3; continue $RESTART; }\n@@ -429,1 +428,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 4; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern4>)) { $idx = 4; continue $RESTART; }\n@@ -442,2 +441,0 @@\n-            \/\/\n-            \/\/note the selector is evaluated only once and stored in a temporary variable\n@@ -446,0 +443,14 @@\n+                c.head.labels = c.head.labels.map(l -> {\n+                    if (l instanceof JCPatternCaseLabel patternLabel) {\n+                        JCPattern pattern = TreeInfo.skipParens(patternLabel.pat);\n+                        if (pattern instanceof JCRecordPattern recordPattern) {\n+                            UnrolledRecordPattern deconstructed = unrollRecordPattern(recordPattern);\n+                            JCExpression guard = deconstructed.newGuard();\n+                            if (patternLabel.guard != null) {\n+                                guard = mergeConditions(guard, patternLabel.guard);\n+                            }\n+                            return make.PatternCaseLabel(deconstructed.primaryPattern(), guard);\n+                        }\n+                    }\n+                    return l;\n+                });\n@@ -452,1 +463,1 @@\n-            cases = newCases.toList();\n+            cases = processCases(tree, newCases.toList());\n@@ -455,1 +466,1 @@\n-                    names.fromString(\"selector\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                    names.fromString(\"selector\" + variableIndex++ + target.syntheticNameChar() + \"temp\"),\n@@ -469,1 +480,1 @@\n-                    names.fromString(tree.pos + target.syntheticNameChar() + \"index\"),\n+                    names.fromString(\"index\" + target.syntheticNameChar()  + variableIndex++),\n@@ -567,0 +578,3 @@\n+\n+                fixupContinue(tree, c, index, i);\n+\n@@ -623,0 +637,17 @@\n+    \/\/where:\n+        private void fixupContinue(JCTree switchTree, JCCase c, VarSymbol indexVariable, int currentCaseIndex) {\n+            \/\/inject 'index = currentCaseIndex + 1;` before continue which has the current switch as the target\n+            new TreeScanner() {\n+                @Override\n+                public void visitCase(JCCase c) {\n+                    if (c.stats.size() == 1 && c.stats.head instanceof JCContinue cont &&\n+                        cont.target == switchTree) {\n+                        JCExpressionStatement setIndex =\n+                                make.Exec(make.Assign(make.Ident(indexVariable),\n+                                                      makeLit(syms.intType, currentCaseIndex + 1))\n+                                              .setType(syms.intType));\n+                        c.stats = c.stats.prepend(setIndex);\n+                    }\n+                }\n+            }.scan(c.stats);\n+        }\n@@ -643,0 +674,159 @@\n+    \/**\n+     * Considering a list of cases, find consecutive cases with the same binding pattern as their label,\n+     * and type tests with binding patterns as the first element in the guard. These cases are then\n+     * merged into a single case, and a nested switch is generated from the first element of the guard.\n+     *\n+     * For example:\n+     *\n+     * OUTER:\n+     * switch (selector) {\n+     *     case Box b when b.o() instanceof String s -> {}\n+     *     case Box b when b.o() instanceof Integer i-> {}\n+     *     case Box b when b.o() instanceof Number n -> {}\n+     *     ...\n+     * }\n+     * =>\n+     * OUTER:\n+     * switch (selector) {\n+     *     case Box b ->\n+     *         switch (b.o()) {\n+     *             case String s -> {}\n+     *             case Integer i -> {}\n+     *             case Number n -> {}\n+     *             default -> continue OUTER; \/\/continue matching on next case of the outer switch\n+     *         }\n+     *     ...\n+     * }\n+     *\/\n+    private List<JCCase> processCases(JCTree currentSwitch, List<JCCase> inputCases) {\n+        interface AccummulatorResolver {\n+            public void resolve(VarSymbol commonBinding,\n+                                JCExpression commonNestedExpression,\n+                                VarSymbol commonNestedBinding);\n+        }\n+        ListBuffer<JCCase> accummulator = new ListBuffer<>();\n+        ListBuffer<JCCase> result = new ListBuffer<>();\n+        AccummulatorResolver resolveAccummulator = (commonBinding, commonNestedExpression, commonNestedBinding) -> {\n+                boolean hasUnconditional = false;\n+                if (accummulator.size() > 1) {\n+                    Assert.check(commonBinding != null &&\n+                                 commonNestedExpression != null &&\n+                                 commonNestedBinding != null,\n+                                 () -> \"commonBinding: \" + commonBinding +\n+                                       \"commonNestedExpression: \" + commonNestedExpression +\n+                                       \"commonNestedBinding: \" + commonNestedBinding);\n+                    ListBuffer<JCCase> nestedCases = new ListBuffer<>();\n+\n+                    for(List<JCCase> accList = accummulator.toList(); accList.nonEmpty(); accList = accList.tail) {\n+                        var accummulated = accList.head;\n+                        JCPatternCaseLabel accummulatedFirstLabel =\n+                                (JCPatternCaseLabel) accummulated.labels.head;\n+                        JCBindingPattern accummulatedPattern =\n+                                (JCBindingPattern) accummulatedFirstLabel.pat;\n+                        VarSymbol accummulatedBinding = accummulatedPattern.var.sym;\n+                        TreeScanner replaceNested =\n+                                new ReplaceVar(Map.of(accummulatedBinding, commonBinding));\n+\n+                        replaceNested.scan(accummulated);\n+                        JCExpression newGuard;\n+                        JCInstanceOf instanceofCheck;\n+                        if (accummulatedFirstLabel.guard instanceof JCBinary binOp) {\n+                            newGuard = binOp.rhs;\n+                            instanceofCheck = (JCInstanceOf) binOp.lhs;\n+                        } else {\n+                            newGuard = null;\n+                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.guard;\n+                        }\n+                        JCBindingPattern binding = (JCBindingPattern) instanceofCheck.pattern;\n+                        hasUnconditional =\n+                                instanceofCheck.allowNull &&\n+                                types.isSubtype(commonNestedExpression.type,\n+                                                types.boxedTypeOrType(types.erasure(binding.type))) &&\n+                                accList.tail.isEmpty();\n+                        List<JCCaseLabel> newLabel;\n+                        if (hasUnconditional) {\n+                            newLabel = List.of(make.ConstantCaseLabel(makeNull()),\n+                                               make.DefaultCaseLabel());\n+                        } else {\n+                            newLabel = List.of(make.PatternCaseLabel(binding, newGuard));\n+                        }\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.stats, null));\n+                    }\n+                    if (!hasUnconditional) {\n+                        JCContinue continueSwitch = make.Continue(null);\n+                        continueSwitch.target = currentSwitch;\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT,\n+                                                  List.of(make.ConstantCaseLabel(makeNull()),\n+                                                          make.DefaultCaseLabel()),\n+                                                  List.of(continueSwitch),\n+                                                  null));\n+                    }\n+                    JCSwitch newSwitch = make.Switch(commonNestedExpression, nestedCases.toList());\n+                    newSwitch.patternSwitch = true;\n+                    JCPatternCaseLabel leadingTest =\n+                            (JCPatternCaseLabel) accummulator.first().labels.head;\n+                    leadingTest.guard = null;\n+                    result.add(make.Case(CaseKind.STATEMENT,\n+                                         List.of(leadingTest),\n+                                         List.of(newSwitch),\n+                                         null));\n+                } else {\n+                    result.addAll(accummulator);\n+                }\n+                accummulator.clear();\n+        };\n+\n+        VarSymbol commonBinding = null;\n+        JCExpression commonNestedExpression = null;\n+        VarSymbol commonNestedBinding = null;\n+\n+        for (List<JCCase> c = inputCases; c.nonEmpty(); c = c.tail) {\n+            VarSymbol currentBinding = null;\n+            JCExpression currentNestedExpression = null;\n+            VarSymbol currentNestedBinding = null;\n+\n+            if (c.head.labels.size() == 1 &&\n+                c.head.labels.head instanceof JCPatternCaseLabel patternLabel) {\n+                if (patternLabel.guard instanceof JCBinary binOp &&\n+                    binOp.lhs instanceof JCInstanceOf instanceofCheck &&\n+                    instanceofCheck.pattern instanceof JCBindingPattern binding) {\n+                    currentBinding = ((JCBindingPattern) patternLabel.pat).var.sym;\n+                    currentNestedExpression = instanceofCheck.expr;\n+                    currentNestedBinding = binding.var.sym;\n+                } else if (patternLabel.guard instanceof JCInstanceOf instanceofCheck &&\n+                    instanceofCheck.pattern instanceof JCBindingPattern binding) {\n+                    currentBinding = ((JCBindingPattern) patternLabel.pat).var.sym;\n+                    currentNestedExpression = instanceofCheck.expr;\n+                    currentNestedBinding = binding.var.sym;\n+                }\n+            }\n+            if (commonBinding == null) {\n+                if (currentBinding != null) {\n+                    commonBinding = currentBinding;\n+                    commonNestedExpression = currentNestedExpression;\n+                    commonNestedBinding = currentNestedBinding;\n+                    accummulator.add(c.head);\n+                } else {\n+                    result.add(c.head);\n+                }\n+            } else if (currentBinding != null &&\n+                       commonBinding.type.tsym == currentBinding.type.tsym &&\n+                       new TreeDiffer(List.of(commonBinding), List.of(currentBinding))\n+                               .scan(commonNestedExpression, currentNestedExpression)) {\n+                accummulator.add(c.head);\n+            } else {\n+                resolveAccummulator.resolve(commonBinding, commonNestedExpression, commonNestedBinding);\n+                if (currentBinding != null) {\n+                    accummulator.add(c.head);\n+                } else {\n+                    result.add(c.head);\n+                }\n+                commonBinding = currentBinding;\n+                commonNestedExpression = currentNestedExpression;\n+                commonNestedBinding = currentNestedBinding;\n+            }\n+        }\n+        resolveAccummulator.resolve(commonBinding, commonNestedExpression, commonNestedBinding);\n+        return result.toList();\n+    }\n+\n@@ -743,0 +933,2 @@\n+        int prevVariableIndex = variableIndex;\n+        Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n@@ -745,0 +937,2 @@\n+            variableIndex = 0;\n+            deconstructorCalls = null;\n@@ -746,0 +940,1 @@\n+            preparePatternMatchingCatchIfNeeded(tree.body);\n@@ -747,0 +942,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -748,0 +944,1 @@\n+            deconstructorCalls = prevDeconstructorCalls;\n@@ -789,0 +986,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -790,9 +988,24 @@\n-            if (currentMethodSym == null) {\n-                \/\/ Block is a static or instance initializer.\n-                currentMethodSym =\n-                    new MethodSymbol(tree.flags | Flags.BLOCK,\n-                                     names.empty, null,\n-                                     currentClass);\n-            }\n-            for (List<JCStatement> l = tree.stats; l.nonEmpty(); l = l.tail) {\n-                statements.append(translate(l.head));\n+            boolean isInit = currentMethodSym == null;\n+            Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n+            try {\n+                if (isInit) {\n+                    \/\/ Block is a static or instance initializer.\n+                    currentMethodSym =\n+                        new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                         names.empty, null,\n+                                         currentClass);\n+                    variableIndex = 0;\n+                    deconstructorCalls = null;\n+                }\n+\n+                for (List<JCStatement> l = tree.stats; l.nonEmpty(); l = l.tail) {\n+                    statements.append(translate(l.head));\n+                }\n+\n+                if (isInit) {\n+                    preparePatternMatchingCatchIfNeeded(tree);\n+                }\n+            } finally {\n+                if (isInit) {\n+                    deconstructorCalls = prevDeconstructorCalls;\n+                }\n@@ -804,0 +1017,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -812,0 +1026,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -814,1 +1029,20 @@\n-            super.visitLambda(tree);\n+            variableIndex = 0;\n+            tree.params = translate(tree.params);\n+            Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n+            try {\n+                deconstructorCalls = null;\n+                tree.body = translate(tree.body);\n+                if (deconstructorCalls != null) {\n+                    if (tree.body instanceof JCExpression value) {\n+                        tree.body = make.Block(0, List.of(make.Return(value)));\n+                    }\n+                    if (tree.body instanceof JCBlock block) {\n+                        preparePatternMatchingCatchIfNeeded(block);\n+                    } else {\n+                        throw Assert.error(\"Unexpected lambda body type: \" + tree.body.getKind());\n+                    }\n+                }\n+            } finally {\n+                deconstructorCalls = prevDeconstructorCalls;\n+            }\n+            result = tree;\n@@ -816,0 +1050,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -846,0 +1081,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -855,0 +1091,1 @@\n+                variableIndex = 0;\n@@ -859,0 +1096,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -863,0 +1101,37 @@\n+    @Override\n+    public void visitTry(JCTry tree) {\n+        tree.resources = translate(tree.resources);\n+        Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n+        try {\n+            deconstructorCalls = null;\n+            tree.body = translate(tree.body);\n+            preparePatternMatchingCatchIfNeeded(tree.body);\n+        } finally {\n+            deconstructorCalls = prevDeconstructorCalls;\n+        }\n+        tree.catchers = translateCatchers(tree.catchers);\n+        tree.finalizer = translate(tree.finalizer);\n+        result = tree;\n+    }\n+\n+    private void preparePatternMatchingCatchIfNeeded(JCBlock tree) {\n+        if (deconstructorCalls != null) {\n+            VarSymbol ctch = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"catch\" + variableIndex++ + target.syntheticNameChar()),\n+                    syms.throwableType,\n+                    currentMethodSym);\n+\n+            JCCatch patternMatchingCatch =\n+                    make.Catch(make.VarDef(ctch, null),\n+                               make.Block(0,\n+                                          List.of(make.Throw(makeNewClass(syms.matchExceptionType,\n+                                                                          List.of(makeApply(make.Ident(ctch),\n+                                                                                            names.toString,\n+                                                                                            List.nil()),\n+                                                                                  make.Ident(ctch)))))));\n+            tree.patternMatchingCatch =\n+                    new PatternMatchingCatch(patternMatchingCatch, deconstructorCalls);\n+            deconstructorCalls = null;\n+        }\n+    }\n+\n@@ -912,0 +1187,4 @@\n+        if (types.isSubtype(expr.type, target)) {\n+            \/\/cast not needed\n+            return expr;\n+        }\n@@ -917,0 +1196,12 @@\n+    JCExpression mergeConditions(JCExpression left, JCExpression right) {\n+        if (left instanceof JCBinary lastBinary) {\n+            while (lastBinary.rhs instanceof JCBinary nextBinary) {\n+                lastBinary = nextBinary;\n+            }\n+            lastBinary.rhs = makeBinary(Tag.AND, lastBinary.rhs, right);\n+            return left;\n+        } else {\n+            return makeBinary(Tag.AND, left, right);\n+        }\n+    }\n+\n@@ -940,1 +1231,1 @@\n-                res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, currentMethodSym);\n+                res = new VarSymbol(varSymbol.flags() & ~Flags.MATCH_BINDING, varSymbol.name, varSymbol.type, currentMethodSym);\n@@ -1042,0 +1333,15 @@\n+\n+    private class ReplaceVar extends TreeScanner {\n+\n+        private final Map<Symbol, Symbol> fromTo;\n+\n+        public ReplaceVar(Map<Symbol, Symbol> fromTo) {\n+            this.fromTo = fromTo;\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            tree.sym = fromTo.getOrDefault(tree.sym, tree.sym);\n+            super.visitIdent(tree);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":453,"deletions":147,"binary":false,"changes":600,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -47,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCConstantCaseLabel;\n@@ -72,0 +74,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCPatternCaseLabel;\n@@ -300,0 +303,12 @@\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+        JCConstantCaseLabel that = (JCConstantCaseLabel) parameter;\n+        result = scan(tree.expr, that.expr);\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+        JCPatternCaseLabel that = (JCPatternCaseLabel) parameter;\n+        result = scan(tree.pat, that.pat) && scan(tree.guard, that.guard);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Set;\n@@ -174,0 +175,2 @@\n+    Set<JCMethodInvocation> invocationsWithPatternMatchingCatch = Set.of();\n+    ListBuffer<int[]> patternMatchingInvocationRanges;\n@@ -1099,0 +1102,23 @@\n+        if (tree.patternMatchingCatch != null) {\n+            Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n+            ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n+            State startState = code.state.dup();\n+            try {\n+                invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n+                patternMatchingInvocationRanges = new ListBuffer<>();\n+                doVisitBlock(tree);\n+            } finally {\n+                Chain skipCatch = code.branch(goto_);\n+                JCCatch handler = tree.patternMatchingCatch.handler();\n+                code.entryPoint(startState, handler.param.sym.type);\n+                genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+                code.resolve(skipCatch);\n+                invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n+                patternMatchingInvocationRanges = prevRanges;\n+            }\n+        } else {\n+            doVisitBlock(tree);\n+        }\n+    }\n+\n+    private void doVisitBlock(JCBlock tree) {\n@@ -1661,10 +1687,1 @@\n-                VarSymbol exparam = tree.param.sym;\n-                code.statBegin(tree.pos);\n-                code.markStatBegin();\n-                int limit = code.nextreg;\n-                code.newLocal(exparam);\n-                items.makeLocalItem(exparam).store();\n-                code.statBegin(TreeInfo.firstStatPos(tree.body));\n-                genStat(tree.body, env, CRT_BLOCK);\n-                code.endScopes(limit);\n-                code.statBegin(TreeInfo.endPos(tree.body));\n+                genCatchBlock(tree, env);\n@@ -1673,0 +1690,24 @@\n+        void genPatternMatchingCatch(JCCatch tree,\n+                                     Env<GenContext> env,\n+                                     List<int[]> ranges) {\n+            for (int[] range : ranges) {\n+                JCExpression subCatch = tree.param.vartype;\n+                int catchType = makeRef(tree.pos(), subCatch.type);\n+                registerCatch(tree.pos(),\n+                              range[0], range[1], code.curCP(),\n+                              catchType);\n+            }\n+            genCatchBlock(tree, env);\n+        }\n+        void genCatchBlock(JCCatch tree, Env<GenContext> env) {\n+            VarSymbol exparam = tree.param.sym;\n+            code.statBegin(tree.pos);\n+            code.markStatBegin();\n+            int limit = code.nextreg;\n+            code.newLocal(exparam);\n+            items.makeLocalItem(exparam).store();\n+            code.statBegin(TreeInfo.firstStatPos(tree.body));\n+            genStat(tree.body, env, CRT_BLOCK);\n+            code.endScopes(limit);\n+            code.statBegin(TreeInfo.endPos(tree.body));\n+        }\n@@ -1889,1 +1930,7 @@\n-        result = m.invoke();\n+        if (invocationsWithPatternMatchingCatch.contains(tree)) {\n+            int start = code.curCP();\n+            result = m.invoke();\n+            patternMatchingInvocationRanges.add(new int[] {start, code.curCP()});\n+        } else {\n+            result = m.invoke();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCBindingPattern;\n@@ -97,0 +98,3 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -1468,0 +1472,1 @@\n+            protected boolean hasPatterns;\n@@ -1478,0 +1483,1 @@\n+                            boolean prevHasPatterns = hasPatterns;\n@@ -1482,4 +1488,5 @@\n-                                 * ignore any updates to hasLambdas made during\n-                                 * the nested scan, this ensures an initialized\n-                                 * LambdaToMethod is available only to those\n-                                 * classes that contain lambdas\n+                                 * ignore any updates to hasLambdas and hasPatterns\n+                                 * made during the nested scan, this ensures an\n+                                 * initialized LambdaToMethod or TransPatterns is\n+                                 * available only to those classes that contain\n+                                 * lambdas or patterns, respectivelly\n@@ -1488,0 +1495,1 @@\n+                                hasPatterns = prevHasPatterns;\n@@ -1506,0 +1514,25 @@\n+            @Override\n+            public void visitBindingPattern(JCBindingPattern tree) {\n+                hasPatterns = true;\n+                super.visitBindingPattern(tree);\n+            }\n+            @Override\n+            public void visitRecordPattern(JCRecordPattern that) {\n+                hasPatterns = true;\n+                super.visitRecordPattern(that);\n+            }\n+            @Override\n+            public void visitParenthesizedPattern(JCTree.JCParenthesizedPattern tree) {\n+                hasPatterns = true;\n+                super.visitParenthesizedPattern(tree);\n+            }\n+            @Override\n+            public void visitSwitch(JCSwitch tree) {\n+                hasPatterns |= tree.patternSwitch;\n+                super.visitSwitch(tree);\n+            }\n+            @Override\n+            public void visitSwitchExpression(JCSwitchExpression tree) {\n+                hasPatterns |= tree.patternSwitch;\n+                super.visitSwitchExpression(tree);\n+            }\n@@ -1554,1 +1587,4 @@\n-            env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            if (scanner.hasPatterns) {\n+                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1077,0 +1077,6 @@\n+        \/** If this block contains record pattern, it is necessary to catch\n+         *  exceptions from the deconstructors and wrap them.\n+         * The {@code patternMatchingCatch} keeps the list of the deconstructor\n+         * invocations, and the additional catch block that wraps the exceptions.\n+         *\/\n+        public PatternMatchingCatch patternMatchingCatch;\n@@ -1101,0 +1107,2 @@\n+\n+        public record PatternMatchingCatch(JCCatch handler, Set<JCMethodInvocation> calls2Handle) {}\n@@ -2211,0 +2219,3 @@\n+        \/**{@code true} if this instanceof test should have\n+         * value {@code true} when the {@code expr} is {@code null}.*\/\n+        public boolean allowNull;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -822,0 +822,9 @@\n+    \/** Skip parens and return the enclosed expression\n+     *\/\n+    public static JCPattern skipParens(JCPattern tree) {\n+        while (tree.hasTag(PARENTHESIZEDPATTERN)) {\n+            tree = ((JCParenthesizedPattern) tree).pattern;\n+        }\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=251, length=11, index=2}\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=316, length=11, index=2}\n@@ -214,1 +214,1 @@\n-                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=290, length=11, index=3}\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=359, length=11, index=3}\n@@ -218,1 +218,1 @@\n-                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=26, length=11, index=1}\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=30, length=11, index=1}\n@@ -220,1 +220,1 @@\n-                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=63, length=11, index=1}\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=71, length=11, index=1}\n@@ -224,1 +224,1 @@\n-                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=101, length=11, index=2}\n+                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=114, length=11, index=2}\n@@ -226,1 +226,1 @@\n-                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=140, length=11, index=3}\n+                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=157, length=11, index=3}\n@@ -230,1 +230,1 @@\n-                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=176, length=11, index=2}\n+                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=215, length=11, index=2}\n@@ -232,1 +232,1 @@\n-                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=215, length=11, index=3}\n+                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=258, length=11, index=3}\n@@ -241,1 +241,1 @@\n-                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=23, length=11, index=2}\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=28, length=11, index=2}\n@@ -243,1 +243,1 @@\n-                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=62, length=11, index=3}\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=71, length=11, index=3}\n@@ -248,4 +248,0 @@\n-                            private static java.lang.String $proxy$s(Patterns$DeconstructionPattern$R);\n-                              descriptor: (LPatterns$DeconstructionPattern$R;)Ljava\/lang\/String;\n-                              flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC\n-\n@@ -256,1 +252,1 @@\n-                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=26, length=11, index=0}\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=28, length=11, index=0}\n@@ -258,1 +254,1 @@\n-                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=62, length=11, index=0}\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=66, length=11, index=0}\n@@ -262,1 +258,1 @@\n-                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=98, length=11, index=1}\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=106, length=11, index=1}\n@@ -264,1 +260,1 @@\n-                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=134, length=11, index=2}\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=147, length=11, index=2}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8291769\n+ * @summary Verify more complex switches work properly\n+ * @compile --enable-preview -source ${jdk.version} DeconstructionDesugaring.java\n+ * @run main\/othervm --enable-preview DeconstructionDesugaring\n+ *\/\n+\n+import java.util.function.ToIntFunction;\n+public class DeconstructionDesugaring {\n+\n+    public static void main(String... args) throws Throwable {\n+        new DeconstructionDesugaring().test();\n+    }\n+\n+    private void test() {\n+        test(this::runCheckStatement);\n+        test(this::runCheckExpression);\n+        assertEquals(runCheckExpressionWithUnconditional(new R5(new R4(new Sub3()))), 3);\n+        assertEquals(runCheckExpressionWithUnconditional(new R5(new R4(null))), 3);\n+        assertEquals(runCheckExpressionWithUnconditional1(new R5(new R4(null))), 2);\n+        assertEquals(runCheckExpressionWithUnconditional1(new R5(null)), 3);\n+    }\n+\n+    private void test(ToIntFunction<Object> task) {\n+        assertEquals(1, task.applyAsInt(new R1(new R2(\"\"))));\n+        assertEquals(2, task.applyAsInt(new R1(new R2(1))));\n+        assertEquals(3, task.applyAsInt(new R1(new R2(1.0))));\n+        assertEquals(-1, task.applyAsInt(new R1(new R2(null))));\n+        assertEquals(4, task.applyAsInt(new R1(new R2(new StringBuilder()))));\n+        assertEquals(5, task.applyAsInt(new R1(new R3(\"\"))));\n+        assertEquals(6, task.applyAsInt(new R1(new R3(1))));\n+        assertEquals(7, task.applyAsInt(new R1(new R3(1.0))));\n+        assertEquals(8, task.applyAsInt(new R1(new R3(new StringBuilder()))));\n+        assertEquals(-1, task.applyAsInt(new R1(1.0f)));\n+        assertEquals(-1, task.applyAsInt(\"foo\"));\n+    }\n+\n+    private int runCheckStatement(Object o) {\n+        switch (o) {\n+            case (((R1((((R2((((String s))))))))))) -> { return 1; }\n+            case R1(R2(Integer i)) -> { return 2; }\n+            case R1(R2(Double d)) -> { return 3; }\n+            case R1(R2(CharSequence cs)) -> { return 4; }\n+            case R1(R3(String s)) -> { return 5; }\n+            case R1(R3(Integer i)) -> { return 6; }\n+            case R1(R3(Double f)) -> { return 7; }\n+            case R1(R3(CharSequence cs)) -> { return 8; }\n+            default -> { return -1; }\n+        }\n+    }\n+\n+    private int runCheckExpression(Object o) {\n+        return switch (o) {\n+            case (((R1((((R2((((String s))))))))))) -> 1;\n+            case R1(R2(Integer i)) -> 2;\n+            case R1(R2(Double d)) -> 3;\n+            case R1(R2(CharSequence cs)) -> 4;\n+            case R1(R3(String s)) -> 5;\n+            case R1(R3(Integer i)) -> 6;\n+            case R1(R3(Double f)) -> 7;\n+            case R1(R3(CharSequence cs)) -> 8;\n+            default -> -1;\n+        };\n+    }\n+\n+    private int runCheckExpressionWithUnconditional(R5 o) {\n+        return switch (o) {\n+            case R5(R4(Sub1 s)) -> 1;\n+            case R5(R4(Sub2 s)) -> 2;\n+            case R5(R4(Super s)) -> 3;\n+        };\n+    }\n+\n+    private int runCheckExpressionWithUnconditional1(R5 o) {\n+        return switch (o) {\n+            case R5(R4(Sub1 s)) -> 1;\n+            case R5(R4(Super s)) -> 2;\n+            case R5(Object obj) -> 3;\n+        };\n+    }\n+\n+    private void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"expected: \" + expected + \", \" +\n+                                     \"actual: \" + actual);\n+        }\n+    }\n+\n+    record R1(Object o) {}\n+    record R2(Object o) {}\n+    record R3(Object o) {}\n+\n+    sealed class Super permits Sub1, Sub2, Sub3 {}\n+    final class Sub1 extends Super {}\n+    final class Sub2 extends Super {}\n+    final class Sub3 extends Super {}\n+\n+    record R4(Super o) {}\n+    record R5(R4 o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionDesugaring.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -60,0 +60,1 @@\n+        assertEquals(\"box with non-empty\", convert.apply(new Box(\"a\")));\n@@ -75,0 +76,1 @@\n+            case Box(String s) : return \"box with non-empty\";\n@@ -85,0 +87,1 @@\n+            case Box(String s) -> \"box with non-empty\";\n@@ -96,0 +99,1 @@\n+            case Box(String s) -> {x = \"box with non-empty\"; yield true; }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8291769\n+ * @summary Verify the compiled code does not have unwanted constructs.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main PatternDesugaring\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class PatternDesugaring extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new PatternDesugaring().runTests();\n+    }\n+\n+    PatternDesugaring() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testPrimitiveNoBoxUnbox(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return switch (obj) {\n+                           case R(int i) -> i;\n+                           default -> -1;\n+                       };\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.contains(\"intValue\") || decompiled.contains(\"valueOf\")) {\n+                       throw new AssertionError(\"Has boxing\/unboxing.\");\n+                   }\n+               });\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return obj instanceof R(int i) ? i : -1;\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.contains(\"intValue\") || decompiled.contains(\"valueOf\")) {\n+                       throw new AssertionError(\"Has boxing\/unboxing.\");\n+                   }\n+               });\n+    }\n+\n+    @Test\n+    public void testCacheRecordsForRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return switch (obj) {\n+                           case R(Integer i, Integer j, Integer k) -> i + j + k;\n+                           default -> -1;\n+                       };\n+                   }\n+                   record R(Integer i, Integer j, Integer k) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.split(\"checkcast\").length != 2) {\n+                       throw new AssertionError(\"Unexpected number of checkcasts.\");\n+                   }\n+               });\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return obj instanceof R(Integer i, Integer j, Integer k) ? i + j + k: -1;\n+                   }\n+                   record R(Integer i, Integer j, Integer k) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.split(\"checkcast\").length != 2) {\n+                       throw new AssertionError(\"Unexpected number of checkcasts.\");\n+                   }\n+               });\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, Consumer<String> validate) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString(),\n+                             \"-XDshould-stop.at=FLOW\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+        var decompiled =\n+                new JavapTask(tb)\n+                    .classpath(classes.toString())\n+                    .classes(\"test.Test\")\n+                    .options(\"-s\", \"-verbose\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+        System.err.println(\"decompiled: \" + decompiled);\n+\n+        validate.accept(decompiled);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternDesugaring.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -97,0 +97,4 @@\n+        assertEquals(\"a\", translationTest(\"a\"));\n+        assertEquals(\"Rb\", translationTest(new R(\"b\")));\n+        assertEquals(\"R2c\", translationTest(new R2(\"c\")));\n+        assertEquals(\"other\", translationTest(0));\n@@ -101,0 +105,2 @@\n+        testSimpleSwitch();\n+        testSimpleSwitchExpression();\n@@ -640,0 +646,9 @@\n+    String translationTest(Object o) {\n+        return switch (o) {\n+            case R(String s) -> \"R\" + s;\n+            case String s -> s;\n+            case R2(String s) -> \"R2\" + s;\n+            default -> \"other\";\n+        };\n+    }\n+\n@@ -654,0 +669,16 @@\n+    void testSimpleSwitch() {\n+        Object o = \"\";\n+        int res;\n+        switch (o) {\n+            default -> res = 1;\n+        };\n+        assertEquals(1, res);\n+    }\n+\n+    void testSimpleSwitchExpression() {\n+        Object o = \"\";\n+        int res = switch (o) {\n+            default -> 1;\n+        };\n+        assertEquals(1, res);\n+    }\n@@ -695,0 +726,1 @@\n+    record R2(Object o) {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8291769\n+ * @summary Check expected translation of various pattern related constructs\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main TranslationTest\n+*\/\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n+import com.sun.tools.javac.comp.TransPatterns;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Context.Factory;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class TranslationTest extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new TranslationTest().runTests();\n+    }\n+\n+    TranslationTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSimple(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public record Box(Object o) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       return switch (obj) {\n+                           case Box(String s) -> 0;\n+                           case Box(Integer i) -> 0;\n+                           case Box(Number n) -> 0;\n+                           case Box(CharSequence cs) -> 0;\n+\n+                           default -> -1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               toplevel -> printSwitchStructure(toplevel),\n+               \"\"\"\n+               switch\n+                   case\n+                       switch\n+                           case\n+                           case\n+                           case\n+                           case\n+                           case ..., default\n+                   default\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testMultiComponent(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public record Pair(Object o1, Object o2) {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record Triplet(Object o1, Object o2, Object o3) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       return switch (obj) {\n+                           case Pair(String c1, Pair(String o2, String s2)) -> 0;\n+                           case Pair(String c1, Pair(String o2, Integer s2)) -> 0;\n+                           case Pair(String c1, Pair(Integer o2, String s2)) -> 0;\n+                           case Pair(String c1, Pair(Integer o2, Integer s2)) -> 0;\n+\n+                           case Pair(Integer c1, Pair(String o2, String s2)) -> 0;\n+                           case Pair(Integer c1, Pair(String o2, Integer s2)) -> 0;\n+                           case Pair(Integer c1, Pair(Integer o2, String s2)) -> 0;\n+                           case Pair(Integer c1, Pair(Integer o2, Integer s2)) -> 0;\n+\n+                           default -> -1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               toplevel -> printSwitchStructure(toplevel),\n+               \"\"\"\n+               switch\n+                   case\n+                       switch\n+                           case\n+                               switch\n+                                   case\n+                                       switch\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case ..., default\n+                                   case ..., default\n+                           case\n+                               switch\n+                                   case\n+                                       switch\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case ..., default\n+                                   case ..., default\n+                           case ..., default\n+                   default\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode,\n+                        Callback callback, String expectedOutput) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        List<String> output = new ArrayList<>();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\",\n+                     \"-source\", JAVA_VERSION,\n+                     \"-Xlint:-preview\",\n+                     \"--class-path\", libClasses.toString(),\n+                     \"-XDshould-stop.at=FLOW\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .callback(task -> {\n+                 Context ctx = ((JavacTaskImpl) task).getContext();\n+\n+                 TestTransPatterns.preRegister(ctx, callback, output);\n+             })\n+            .run()\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (output.size() != 1 || !expectedOutput.equals(output.get(0))) {\n+            throw new AssertionError(\"Unexpected output:\\n\" + output);\n+        }\n+    }\n+\n+    private String printSwitchStructure(JCTree topLevel) {\n+        StringBuilder structure = new StringBuilder();\n+\n+        new TreeScanner() {\n+            private static final int INDENT = 4;\n+            private int indent = 0;\n+            @Override\n+            public void visitSwitch(JCSwitch node) {\n+                int prevIndent = indent;\n+                appendLine(\"switch\");\n+                try {\n+                    indent += INDENT;\n+                    super.visitSwitch(node);\n+                } finally {\n+                    indent = prevIndent;\n+                }\n+            }\n+\n+            @Override\n+            public void visitSwitchExpression(JCSwitchExpression node) {\n+                int prevIndent = indent;\n+                appendLine(\"switch\");\n+                try {\n+                    indent += INDENT;\n+                    super.visitSwitchExpression(node);\n+                } finally {\n+                    indent = prevIndent;\n+                }\n+            }\n+            @Override\n+            public void visitCase(JCCase node) {\n+                int prevIndent = indent;\n+                if (node.labels.size() == 1 && node.labels.head.hasTag(Tag.DEFAULTCASELABEL)) {\n+                    appendLine(\"default\");\n+                } else if (node.labels.stream().anyMatch(l -> l.hasTag(Tag.DEFAULTCASELABEL))) {\n+                    appendLine(\"case ..., default\");\n+                } else {\n+                    appendLine(\"case\");\n+                }\n+                try {\n+                    indent += INDENT;\n+                    super.visitCase(node);\n+                } finally {\n+                    indent = prevIndent;\n+                }\n+            }\n+            private void appendLine(String what) {\n+                for (int i = 0; i < indent; i++) {\n+                    structure.append(' ');\n+                }\n+                structure.append(what);\n+                structure.append('\\n');\n+            }\n+        }.scan(topLevel);\n+\n+        return structure.toString();\n+    }\n+\n+    public interface Callback {\n+        public String patternsTranslated(JCTree topLevel);\n+    }\n+\n+    private static final class TestTransPatterns extends TransPatterns {\n+\n+        public static void preRegister(Context ctx, Callback validator, List<String> output) {\n+            ctx.put(transPatternsKey, (Factory<TransPatterns>) c -> new TestTransPatterns(c, validator, output));\n+        }\n+\n+        private final Callback callback;\n+        private final List<String> output;\n+\n+        public TestTransPatterns(Context context, Callback callback, List<String> output) {\n+            super(context);\n+            this.callback = callback;\n+            this.output = output;\n+        }\n+\n+        @Override\n+        public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n+            JCTree result = super.translateTopLevelClass(env, cdef, make);\n+            output.add(callback.patternsTranslated(cdef));\n+            return result;\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/TranslationTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.function.ToIntFunction;\n@@ -42,0 +43,3 @@\n+        testTryExpr();\n+        run(this::testLambda);\n+        runBoxed();\n@@ -86,0 +90,76 @@\n+    void testTryExpr() {\n+        TEST: {\n+            try {\n+                var v = switch ((Pair<String, Integer>) (Object) new Pair<Integer, Integer>(1, 1)) {\n+                    case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+                    case Object o -> -1;\n+                };\n+            } catch (ClassCastException ex) {\n+                \/\/OK\n+                break TEST;\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Unexpected Throwable!\");\n+            }\n+            fail(\"ClassCastException not thrown!\");\n+        }\n+        TEST: {\n+            try {\n+                var v = switch (new Pair<String, Integer>(\"fail\", 1)) {\n+                    case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+                    case Object o -> -1;\n+                };\n+            } catch (MatchException ex) {\n+                \/\/OK\n+                break TEST;\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Unexpected Throwable!\");\n+            }\n+            fail(\"MatchException not thrown!\");\n+        }\n+    }\n+\n+    int testLambda(Pair<String, Integer> p) {\n+        var r = prepareLambda();\n+        return r.applyAsInt(p);\n+    }\n+\n+    ToIntFunction<Pair<String, Integer>> prepareLambda() {\n+        return p -> switch (p) {\n+            case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+            case Object o -> -1;\n+        };\n+    }\n+\n+    void runBoxed() {\n+        assertEquals(2, testBoxed(new Box(new Pair<>(\"1\", 1))));\n+        try {\n+            testBoxed(new Box((Pair<String, Integer>) (Object) new Pair<Integer, Integer>(1, 1)));\n+            fail(\"Expected an exception, but none happened!\");\n+        } catch (ClassCastException ex) {\n+            System.err.println(\"expected exception:\");\n+            ex.printStackTrace();\n+        }\n+        try {\n+            testBoxed(new Box(new Pair<String, Integer>(\"fail\", 1)));\n+            fail(\"Expected an exception, but none happened!\");\n+        } catch (MatchException ex) {\n+            assertEquals(TestPatternFailed.class.getName() + \": \" + EXCEPTION_MESSAGE,\n+                         ex.getMessage());\n+            if (ex.getCause() instanceof TestPatternFailed ex2) {\n+                System.err.println(\"expected exception:\");\n+                ex2.printStackTrace();\n+            } else {\n+                fail(\"Not the correct exception.\");\n+            }\n+        }\n+    }\n+\n+    int testBoxed(Object p) {\n+        return switch (p) {\n+            case Box(Pair<String, Integer>(String s, Integer i)) -> s.length() + i;\n+            case Object o -> -1;\n+        };\n+    }\n+\n@@ -100,0 +180,2 @@\n+    record Box(Pair<String, Integer> boxed) {}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/TypedDeconstructionPatternExc.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"}]}