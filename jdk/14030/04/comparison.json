{"files":[{"patch":"@@ -51,2 +51,2 @@\n- * MemorySegment segment = Arena.global().allocate(100, 1);\n- * ...\n+ * MemorySegment segment = Arena.global().allocate(100, 1); \/\/ @highlight regex='global()'\n+ * \/\/ ...\n@@ -54,1 +54,1 @@\n- *}\n+ * }\n@@ -61,1 +61,0 @@\n- *\n@@ -63,2 +62,2 @@\n- * MemorySegment segment = Arena.ofAuto().allocate(100, 1);\n- * ...\n+ * MemorySegment segment = Arena.ofAuto().allocate(100, 1); \/\/ @highlight regex='ofAuto()'\n+ * \/\/ ...\n@@ -66,1 +65,1 @@\n- *}\n+ * }\n@@ -80,1 +79,1 @@\n- * try (Arena arena = Arena.ofConfined()) {\n+ * try (Arena arena = Arena.ofConfined()) { \/\/ @highlight regex='ofConfined()'\n@@ -82,1 +81,1 @@\n- *     ...\n+ *     \/\/ ...\n@@ -85,1 +84,1 @@\n- *}\n+ * }\n@@ -160,2 +159,6 @@\n- *      final Arena arena = Arena.ofConfined();\n- *      final SegmentAllocator slicingAllocator;\n+ *     final Arena arena = Arena.ofConfined();\n+ *     final SegmentAllocator slicingAllocator;\n+ *\n+ *     SlicingArena(long size) {\n+ *         slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+ *     }\n@@ -163,3 +166,3 @@\n- *      SlicingArena(long size) {\n- *          slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n- *      }\n+ *     public MemorySegment allocate(long byteSize, long byteAlignment) {\n+ *         return slicingAllocator.allocate(byteSize, byteAlignment);\n+ *     }\n@@ -167,3 +170,3 @@\n- *      public void allocate(long byteSize, long byteAlignment) {\n- *          return slicingAllocator.allocate(byteSize, byteAlignment);\n- *      }\n+ *     public MemorySegment.Scope scope() {\n+ *         return arena.scope();\n+ *     }\n@@ -171,3 +174,3 @@\n- *      public MemorySegment.Scope scope() {\n- *          return arena.scope();\n- *      }\n+ *     public void close() {\n+ *         arena.close();\n+ *     }\n@@ -175,3 +178,0 @@\n- *      public void close() {\n- *          return arena.close();\n- *      }\n@@ -186,4 +186,4 @@\n- *      for (int i = 0 ; i < 10 ; i++) {\n- *          MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n- *          ...\n- *      }\n+ *     for (int i = 0; i < 10; i++) {\n+ *         MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+ *         \/\/ ...\n+ *     }\n@@ -255,3 +255,3 @@\n-     * {@snippet lang = java:\n-     * S1.overlappingSlice(S2).isEmpty() == true\n-     *}\n+     * {@snippet file=Snippets.java region=arena-overlap lang = java:\n+     *     S1.asOverlappingSlice(S2).isEmpty() == true\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n- *     linker.defaultLookup().find(\"strlen\").get(),\n+ *     linker.defaultLookup().find(\"strlen\").orElseThrow(),\n@@ -94,1 +94,1 @@\n- * try (Arena arena = Arena.openConfined()) {\n+ * try (Arena arena = Arena.ofConfined()) {\n@@ -96,1 +96,1 @@\n- *     long len          = strlen.invoke(str);  \/\/ 5\n+ *     long len = (long) strlen.invokeExact(str);  \/\/ 5\n@@ -229,1 +229,1 @@\n- *     linker.defaultLookup().find(\"qsort\").get(),\n+ *     linker.defaultLookup().find(\"qsort\").orElseThrow(),\n@@ -243,1 +243,1 @@\n- *     static int qsortCompare(MemorySegment elem1, MemorySegmet elem2) {\n+ *     static int qsortCompare(MemorySegment elem1, MemorySegment elem2) {\n@@ -252,1 +252,1 @@\n- * FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+ * FunctionDescriptor compareDesc = FunctionDescriptor.of(JAVA_INT,\n@@ -255,1 +255,1 @@\n- * MethodHandle comparHandle = MethodHandles.lookup()\n+ * MethodHandle compareHandle = MethodHandles.lookup()\n@@ -257,1 +257,1 @@\n- *                                                      comparDesc.toMethodType());\n+ *                                                      compareDesc.toMethodType());\n@@ -270,3 +270,3 @@\n- *     MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n- *     MemorySegment array = session.allocateArray(0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n- *     qsort.invokeExact(array, 10L, 4L, comparFunc);\n+ *     MemorySegment compareFunc = linker.upcallStub(compareHandle, compareDesc, arena);\n+ *     MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     qsort.invokeExact(array, 10L, 4L, compareFunc);\n@@ -310,1 +310,1 @@\n- *     linker.defaultLookup().find(\"malloc\").get(),\n+ *     linker.defaultLookup().find(\"malloc\").orElseThrow(),\n@@ -315,1 +315,1 @@\n- *     linker.defaultLookup().find(\"free\").get(),\n+ *     linker.defaultLookup().find(\"free\").orElseThrow(),\n@@ -337,3 +337,9 @@\n- * MemorySegment allocateMemory(long byteSize, Arena arena) {\n- *     MemorySegment segment = (MemorySegment)malloc.invokeExact(byteSize);    \/\/ size = 0, scope = always alive\n- *     return segment.reinterpret(byteSize, arena, s -> free.invokeExact(s));  \/\/ size = byteSize, scope = arena.scope()\n+ * MemorySegment allocateMemory(long byteSize, Arena arena) throws Throwable {\n+ *     MemorySegment segment = (MemorySegment) malloc.invokeExact(byteSize); \/\/ size = 0, scope = always alive\n+ *     return segment.reinterpret(byteSize, arena, s -> {\n+ *         try {\n+ *             free.invokeExact(s);\n+ *         } catch (Throwable e) {\n+ *             throw new RuntimeException(e);\n+ *         }\n+ *     });  \/\/ size = byteSize, scope = arena.scope()\n@@ -392,1 +398,1 @@\n- *     linker.defaultLookup().lookup(\"printf\").get(),\n+ *     linker.defaultLookup().find(\"printf\").orElseThrow(),\n@@ -619,1 +625,1 @@\n-         * StructLayout capturedStateLayout = Linker.Option.capturedStateLayout();\n+         * StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n@@ -624,1 +630,1 @@\n-         *     int errno = errnoHandle.get(capturedState);\n+         *     int errno = (int) errnoHandle.get(capturedState);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -663,1 +663,1 @@\n-     * structLayout(JAVA_SHORT, JAVA_INT)\n+     * structLayout(JAVA_SHORT, JAVA_INT);\n@@ -669,1 +669,1 @@\n-     * structLayout(JAVA_SHORT, MemoryLayout.ofPadding(2), JAVA_INT)\n+     * structLayout(JAVA_SHORT, MemoryLayout.paddingLayout(2), JAVA_INT);\n@@ -676,1 +676,1 @@\n-     * structLayout(JAVA_SHORT, JAVA_INT.withByteAlignment(2))\n+     * structLayout(JAVA_SHORT, JAVA_INT.withByteAlignment(2));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n- * intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n@@ -155,1 +155,1 @@\n- * intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n@@ -759,2 +759,2 @@\n-     * byteHandle = MemoryLayout.ofSequence(ValueLayout.JAVA_BYTE)\n-     *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+     * var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+     *         .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -788,1 +788,1 @@\n-     * MemorySegment.copy(src, 0, this, 0, src.byteSize);\n+     * MemorySegment.copy(src, 0, this, 0, src.byteSize());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-     * int value1 = arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-     * int value2 = arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n+     * int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n+     * int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n- *     stdlib.find(\"strlen\").get(),\n+ *     stdlib.find(\"strlen\").orElseThrow(),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,679 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.foreign.snippets;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static java.lang.foreign.MemoryLayout.sequenceLayout;\n+import static java.lang.foreign.MemoryLayout.structLayout;\n+import static java.lang.foreign.SymbolLookup.libraryLookup;\n+import static java.lang.foreign.SymbolLookup.loaderLookup;\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+\n+\/**\n+ * Snippets for the java.lang.foreign documentation.\n+ *\/\n+class Snippets {\n+\n+    \/**\n+     * Creates a new snippet.\n+     *\/\n+    public Snippets() {\n+    }\n+\n+    static class ArenaSnippets {\n+\n+        void globalArena() {\n+            \/\/ @start region=\"global-allocation\":\n+            MemorySegment segment = Arena.global().allocate(100, 1); \/\/ @highlight regex='global()'\n+            \/\/ ...\n+            \/\/ segment is never deallocated!\n+            \/\/ @end\n+        }\n+\n+        void autoArena() {\n+            \/\/ @start region=\"auto-allocation\":\n+            MemorySegment segment = Arena.ofAuto().allocate(100, 1); \/\/ @highlight regex='ofAuto()'\n+            \/\/ ...\n+            segment = null; \/\/ the segment region becomes available for deallocation after this point\n+            \/\/ @end\n+        }\n+\n+        void confinedArena() {\n+            \/\/ @start region=\"confined-allocation\":\n+            MemorySegment segment = null;\n+            try (Arena arena = Arena.ofConfined()) { \/\/ @highlight regex='ofConfined()'\n+                segment = arena.allocate(100);\n+                \/\/ ...\n+            } \/\/ segment region deallocated here\n+            segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n+            \/\/ @end\n+        }\n+\n+        static\n+        \/\/ @start region=\"slicing-arena\":\n+        class SlicingArena implements Arena {\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicingAllocator;\n+\n+            SlicingArena(long size) {\n+                slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+            }\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicingAllocator.allocate(byteSize, byteAlignment);\n+            }\n+\n+            public MemorySegment.Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                arena.close();\n+            }\n+\n+        }\n+        \/\/ @end\n+\n+        public static void main(String[] args) {\n+            \/\/ @start region=\"slicing-arena-main\":\n+            try (Arena slicingArena = new SlicingArena(1000)) {\n+                for (int i = 0; i < 10; i++) {\n+                    MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+                    \/\/ ...\n+                }\n+            } \/\/ all memory allocated is released here\n+            \/\/ @end\n+        }\n+\n+        void arenaOverlap() {\n+            try (var arena = Arena.ofConfined()) {\n+                var S1 = arena.allocate(16L);\n+                var S2 = arena.allocate(16L);\n+\n+                if (\n+                    \/\/ @start region=\"arena-overlap\":\n+                        S1.asOverlappingSlice(S2).isEmpty() == true\n+                    \/\/ @end\n+                ) {}\n+\n+            }\n+        }\n+    }\n+\n+    static class AddressLayoutSnippets {\n+        void withTargetLayout() {\n+            AddressLayout addressLayout = ADDRESS;\n+            AddressLayout unboundedLayout = addressLayout.withTargetLayout(\n+                    sequenceLayout(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    static class FunctionDescriptionSnippets {\n+    }\n+\n+    static class GroupLayoutSnippets {\n+    }\n+\n+    static class LinkerSnippets {\n+\n+        void downcall() throws Throwable {\n+            Linker linker = Linker.nativeLinker();\n+            MethodHandle strlen = linker.downcallHandle(\n+                    linker.defaultLookup().find(\"strlen\").orElseThrow(),\n+                    FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+            );\n+\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+                long len = (long) strlen.invokeExact(str);  \/\/ 5\n+            }\n+\n+        }\n+\n+        void qsort() throws Throwable {\n+            Linker linker = Linker.nativeLinker();\n+            MethodHandle qsort = linker.downcallHandle(\n+                    linker.defaultLookup().find(\"qsort\").orElseThrow(),\n+                    FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+            );\n+\n+            class Qsort {\n+                static int qsortCompare(MemorySegment elem1, MemorySegment elem2) {\n+                    return Integer.compare(elem1.get(JAVA_INT, 0), elem2.get(JAVA_INT, 0));\n+                }\n+            }\n+\n+            FunctionDescriptor compareDesc = FunctionDescriptor.of(JAVA_INT,\n+                    ADDRESS.withTargetLayout(JAVA_INT),\n+                    ADDRESS.withTargetLayout(JAVA_INT));\n+            MethodHandle compareHandle = MethodHandles.lookup()\n+                    .findStatic(Qsort.class, \"qsortCompare\",\n+                            compareDesc.toMethodType());\n+\n+\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment compareFunc = linker.upcallStub(compareHandle, compareDesc, arena);\n+                MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+                qsort.invokeExact(array, 10L, 4L, compareFunc);\n+                int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+\n+            }\n+        }\n+\n+        void returnPointer() throws Throwable {\n+            Linker linker = Linker.nativeLinker();\n+\n+            MethodHandle malloc = linker.downcallHandle(\n+                    linker.defaultLookup().find(\"malloc\").orElseThrow(),\n+                    FunctionDescriptor.of(ADDRESS, JAVA_LONG)\n+            );\n+\n+            MethodHandle free = linker.downcallHandle(\n+                    linker.defaultLookup().find(\"free\").orElseThrow(),\n+                    FunctionDescriptor.ofVoid(ADDRESS)\n+            );\n+\n+            MemorySegment segment = (MemorySegment) malloc.invokeExact(100);\n+\n+            class AllocateMemory {\n+\n+                MemorySegment allocateMemory(long byteSize, Arena arena) throws Throwable {\n+                    MemorySegment segment = (MemorySegment) malloc.invokeExact(byteSize); \/\/ size = 0, scope = always alive\n+                    return segment.reinterpret(byteSize, arena, s -> {\n+                        try {\n+                            free.invokeExact(s);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    });  \/\/ size = byteSize, scope = arena.scope()\n+                }\n+\n+            }\n+\n+\n+            class AllocateMemory2 {\n+\n+                MemorySegment allocateMemory(long byteSize, Arena arena) {\n+                    MemorySegment segment = trySupplier(() -> (MemorySegment) malloc.invokeExact(byteSize));   \/\/ size = 0, scope = always alive\n+                    return segment.reinterpret(byteSize, arena, s -> trySupplier(() -> free.invokeExact(s)));  \/\/ size = byteSize, scope = arena.scope()\n+                }\n+\n+                @FunctionalInterface\n+                interface ThrowingSupplier<T> {\n+                    T get() throws Throwable;\n+\n+                }\n+\n+                <T> T trySupplier(ThrowingSupplier<? extends T> supplier) {\n+                    try {\n+                        return supplier.get();\n+                    } catch (Throwable t) {\n+                        throw new RuntimeException(t);\n+                    }\n+                }\n+\n+\n+            }\n+\n+\n+            class AllocateMemory3 {\n+\n+                MemorySegment allocateMemory(long byteSize, Arena arena) throws Throwable {\n+                    MemorySegment segment = (MemorySegment) malloc.invokeExact(byteSize); \/\/ size = 0, scope = always alive\n+                    return segment.reinterpret(byteSize, arena, this::freeMemory);        \/\/ size = byteSize, scope = arena.scope()\n+                }\n+\n+                void freeMemory(MemorySegment segment) {\n+                    try {\n+                        free.invokeExact(segment);\n+                    } catch (Throwable e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+\n+        }\n+\n+        void variadicFunc() throws Throwable {\n+\n+            Linker linker = Linker.nativeLinker();\n+            MethodHandle printf = linker.downcallHandle(\n+                    linker.defaultLookup().find(\"printf\").orElseThrow(),\n+                    FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),\n+                    Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+            );\n+\n+            try (Arena arena = Arena.ofConfined()) {\n+                int res = (int) printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+            }\n+\n+        }\n+\n+        void downcallHandle() {\n+            Linker linker = Linker.nativeLinker();\n+            FunctionDescriptor function = null;\n+            MemorySegment symbol = null;\n+\n+            linker.downcallHandle(function).bindTo(symbol);\n+\n+        }\n+\n+        void captureCallState() throws Throwable {\n+\n+            MemorySegment targetAddress = null; \/\/ ...\n+            Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n+            MethodHandle handle = Linker.nativeLinker().downcallHandle(targetAddress, FunctionDescriptor.ofVoid(), ccs);\n+\n+            StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n+            VarHandle errnoHandle = capturedStateLayout.varHandle(PathElement.groupElement(\"errno\"));\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment capturedState = arena.allocate(capturedStateLayout);\n+                handle.invoke(capturedState);\n+                int errno = (int) errnoHandle.get(capturedState);\n+                \/\/ use errno\n+            }\n+        }\n+\n+        void captureStateLayout() {\n+            String capturedNames = Linker.Option.captureStateLayout().memberLayouts().stream()\n+                    .map(MemoryLayout::name)\n+                    .flatMap(Optional::stream)\n+                    .map(Objects::toString)\n+                    .collect(Collectors.joining(\", \"));\n+        }\n+\n+\n+    }\n+\n+    static class MemoryLayoutSnippets {\n+\n+        void header() throws Throwable {\n+            SequenceLayout taggedValues = sequenceLayout(5,\n+                    structLayout(\n+                            ValueLayout.JAVA_BYTE.withName(\"kind\"),\n+                            MemoryLayout.paddingLayout(24),\n+                            ValueLayout.JAVA_INT.withName(\"value\")\n+                    )\n+            ).withName(\"TaggedValues\");\n+\n+            long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+                    PathElement.groupElement(\"value\")); \/\/ yields 4\n+\n+            MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),\n+                    PathElement.groupElement(\"value\"));\n+\n+            VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n+                    PathElement.groupElement(\"value\"));\n+\n+            MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n+                    PathElement.groupElement(\"kind\"));\n+            long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n+            long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+        }\n+\n+        void sliceHandle() {\n+            MemorySegment segment = null;\n+            long offset = 0;\n+            MemoryLayout layout = null;\n+\n+            segment.asSlice(offset, layout.byteSize());\n+        }\n+\n+        void sequenceLayout0() {\n+            MemoryLayout elementLayout = JAVA_INT;\n+\n+            sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n+        }\n+\n+        void structLayout0() {\n+            MemoryLayout elementLayout = JAVA_INT;\n+\n+            structLayout(JAVA_SHORT, JAVA_INT);\n+            structLayout(JAVA_SHORT, MemoryLayout.paddingLayout(16), JAVA_INT);\n+            structLayout(JAVA_SHORT, JAVA_INT.withByteAlignment(2));\n+        }\n+\n+    }\n+\n+    static class MemorySegmentSnippets {\n+        void header() throws NoSuchMethodException, IllegalAccessException {\n+\n+            {\n+                MemorySegment segment = null; \/\/ ...\n+                int value = segment.get(ValueLayout.JAVA_INT, 0);\n+            }\n+\n+            {\n+                MemorySegment segment = null; \/\/ ...\n+\n+                int value = segment.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+            }\n+\n+            {\n+                MemorySegment segment = null; \/\/ ...\n+\n+                VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+                MethodHandle multiplyExact = MethodHandles.lookup()\n+                        .findStatic(Math.class, \"multiplyExact\",\n+                                MethodType.methodType(long.class, long.class, long.class));\n+                intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n+                        MethodHandles.insertArguments(multiplyExact, 0, 4L));\n+                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+            }\n+\n+            {\n+                MemorySegment segment = null; \/\/ ...\n+\n+                VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+            }\n+\n+            {\n+                Arena arena = Arena.ofConfined();\n+                MemorySegment segment = arena.allocate(100);\n+                MemorySegment slice = segment.asSlice(50, 10);\n+                slice.get(ValueLayout.JAVA_INT, 20); \/\/ Out of bounds!\n+                arena.close();\n+                slice.get(ValueLayout.JAVA_INT, 0); \/\/ Already closed!\n+            }\n+\n+\n+            {\n+                try (Arena arena = Arena.ofShared()) {\n+                    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n+                    MemorySegment segment = arena.allocate(SEQUENCE_LAYOUT);\n+                    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                            .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n+                            .sum();\n+                }\n+            }\n+\n+            {\n+                MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+                byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: layout alignment is 4, segment max alignment is 1\n+            }\n+\n+            {\n+                MemorySegment longSegment = MemorySegment.ofArray(new long[10]);\n+                longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: layout alignment is 4, segment max alignment is 8\n+            }\n+\n+            {\n+                MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+                byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+            }\n+\n+            {\n+                MemorySegment segment = null;\n+                long offset = 42;\n+\n+                MemorySegment z = segment.get(ValueLayout.ADDRESS, offset);   \/\/ size = 0\n+                MemorySegment ptr = z.reinterpret(16);                \/\/ size = 16\n+                int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);        \/\/ ok\n+            }\n+\n+            {\n+                MemorySegment segment = null;\n+                long offset = 42;\n+\n+                MemorySegment ptr = null;\n+                try (Arena arena = Arena.ofConfined()) {\n+                    MemorySegment z = segment.get(ValueLayout.ADDRESS, offset);   \/\/ size = 0, scope = always alive\n+                    ptr = z.reinterpret(16, arena, null);          \/\/ size = 4, scope = arena.scope()\n+                    int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);        \/\/ ok\n+                }\n+                int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);            \/\/ throws IllegalStateException\n+            }\n+\n+            {\n+                MemorySegment segment = null;\n+                long offset = 42;\n+\n+                AddressLayout intArrPtrLayout = ValueLayout.ADDRESS.withTargetLayout(\n+                        MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT)); \/\/ layout for int (*ptr)[4]\n+                MemorySegment ptr = segment.get(intArrPtrLayout, offset);                  \/\/ size = 16\n+                int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);                     \/\/ ok\n+            }\n+\n+\n+        }\n+\n+        boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n+            return ((segment.address() + offset) % layout.byteAlignment()) == 0;\n+        }\n+\n+        void elements() {\n+            MemorySegment segment = null;\n+            MemoryLayout elementLayout = JAVA_INT;\n+\n+            StreamSupport.stream(segment.spliterator(elementLayout), false);\n+        }\n+\n+        void asSlice() {\n+            MemorySegment segment = null;\n+            long offset = 42;\n+            MemoryLayout layout = JAVA_INT;\n+\n+            segment.asSlice(offset, layout.byteSize(), 1);\n+\n+            segment.asSlice(offset, layout.byteSize(), layout.byteAlignment());\n+\n+            segment.asSlice(offset, segment.byteSize() - offset);\n+\n+        }\n+\n+        void reinterpret() {\n+            MemorySegment segment = null;\n+\n+            MemorySegment cleanupSegment = MemorySegment.ofAddress(segment.address());\n+\n+        }\n+\n+        void segmentOffset() {\n+            MemorySegment segment = null;\n+            MemorySegment other = null;\n+\n+            long offset = other.address() - segment.address();\n+        }\n+\n+        void fill() {\n+            MemorySegment segment = null;\n+            byte value = 42;\n+\n+            var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(MemoryLayout.PathElement.sequenceElement());\n+            for (long l = 0; l < segment.byteSize(); l++) {\n+                byteHandle.set(segment.address(), l, value);\n+            }\n+        }\n+\n+        void copyFrom() {\n+            MemorySegment src = null;\n+            MemorySegment dst = null;\n+\n+            \/\/ MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+            MemorySegment.copy(src, 0, dst, 0, src.byteSize());\n+        }\n+\n+        void copy() {\n+            MemorySegment srcSegment = null;\n+            long srcOffset = 42;\n+            MemorySegment dstSegment = null;\n+            long dstOffset = 13;\n+            long bytes = 3;\n+\n+            MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+        }\n+\n+\n+    }\n+\n+    static class PackageInfoSnippets {\n+\n+        void header() throws Throwable {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(10 * 4);\n+                for (int i = 0; i < 10; i++) {\n+                    segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n+                }\n+            }\n+\n+            Linker linker = Linker.nativeLinker();\n+            SymbolLookup stdlib = linker.defaultLookup();\n+            MethodHandle strlen = linker.downcallHandle(\n+                    stdlib.find(\"strlen\").orElseThrow(),\n+                    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n+            );\n+\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+                long len = (long) strlen.invokeExact(cString); \/\/ 5\n+            }\n+\n+        }\n+    }\n+\n+    static class PaddingLayoutSnippets {\n+    }\n+\n+    static class SegmentAllocatorSnippets {\n+        void prefixAllocator() {\n+            MemorySegment segment = null; \/\/...\n+            SegmentAllocator prefixAllocator = (size, align) -> segment.asSlice(0, size);\n+        }\n+\n+    }\n+\n+    static class SequenceLayoutSnippets {\n+        void header() {\n+            MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n+\n+            MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n+\n+        }\n+\n+        void reshape() {\n+            var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n+            var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n+\n+            var reshapeSeqImplicit1 = seq.reshape(-1, 6);\n+            var reshapeSeqImplicit2 = seq.reshape(2, -1);\n+\n+        }\n+\n+        void flatten() {\n+            var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n+            var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n+        }\n+\n+    }\n+\n+    static class StructLayoutSnippets {\n+    }\n+\n+    static class SymbolLookupSnippets {\n+\n+        void header() {\n+            try (Arena arena = Arena.ofConfined()) {\n+                SymbolLookup libGL = libraryLookup(\"libGL.so\", arena); \/\/ libGL.so loaded here\n+                MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n+                \/\/ ...\n+            } \/\/  libGL.so unloaded here\n+\n+            System.loadLibrary(\"GL\"); \/\/ libGL.so loaded here\n+            \/\/ ...\n+            SymbolLookup libGL = loaderLookup();\n+            MemorySegment glGetString = libGL.find(\"glGetString\").orElseThrow();\n+\n+\n+            Arena arena = Arena.ofAuto();\n+\n+\n+            libraryLookup(\"libGL.so\", arena).find(\"glGetString\").isPresent(); \/\/ true\n+            loaderLookup().find(\"glGetString\").isPresent(); \/\/ false\n+\n+            libraryLookup(\"libGL.so\", arena).find(\"glGetString\").isPresent(); \/\/ true\n+            loaderLookup().find(\"glGetString\").isPresent(); \/\/ false\n+\n+            Linker nativeLinker = Linker.nativeLinker();\n+            SymbolLookup stdlib = nativeLinker.defaultLookup();\n+            MemorySegment malloc = stdlib.find(\"malloc\").orElseThrow();\n+        }\n+\n+    }\n+\n+    static class UnionLayoutSnippets {\n+    }\n+\n+    static class ValueLayoutSnippets {\n+\n+        void arrayElementVarHandle() {\n+            VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n+\n+            SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n+                    MemoryLayout.sequenceLayout(10,\n+                            MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n+\n+            int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n+            int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n+        }\n+\n+        void statics() {\n+            ADDRESS.withByteAlignment(1);\n+            JAVA_CHAR.withByteAlignment(1);\n+            JAVA_SHORT.withByteAlignment(1);\n+            JAVA_INT.withByteAlignment(1);\n+            JAVA_LONG.withByteAlignment(1);\n+            JAVA_FLOAT.withByteAlignment(1);\n+            JAVA_DOUBLE.withByteAlignment(1);\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":679,"deletions":0,"binary":false,"changes":679,"status":"added"}]}