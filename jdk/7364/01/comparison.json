{"files":[{"patch":"@@ -855,1 +855,4 @@\n-    strip_mined_nest_back_to_counted_loop(loop, head, back_control, exit_test, safepoint);\n+    OuterStripMinedLoopNode* outer_loop = head->as_CountedLoop()->outer_loop();\n+    safepoint = outer_loop->outer_safepoint();\n+    outer_loop->transform_to_counted_loop(&_igvn, this);\n+    exit_test = head->loopexit();\n@@ -1061,62 +1064,0 @@\n-\/\/ Convert the strip mined loop nest back to a single loop with the safepoint right before the loop exit test\n-void PhaseIdealLoop::strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head,\n-                                                           Node* back_control, IfNode*& exit_test,\n-                                                           SafePointNode*& safepoint) {\n-  CountedLoopNode* cl = head->as_CountedLoop();\n-  cl->verify_strip_mined(1);\n-  safepoint = cl->outer_safepoint();\n-  CountedLoopEndNode* cle = cl->loopexit();\n-  OuterStripMinedLoopNode* outer_head = cl->outer_loop();\n-  OuterStripMinedLoopEndNode* outer_end = cl->outer_loop_end();\n-\n-  cl->clear_strip_mined();\n-\n-  _igvn.replace_input_of(cl, LoopNode::EntryControl, outer_head->in(LoopNode::EntryControl));\n-  _igvn.replace_input_of(outer_head, LoopNode::EntryControl, C->top());\n-  set_idom(cl, cl->in(LoopNode::EntryControl), dom_depth(cl));\n-\n-  Node* exit_bol = cle->in(1);\n-  Node *zero = _igvn.intcon(0);\n-  set_ctrl(zero, C->root());\n-  _igvn.replace_input_of(cle, 1, zero);\n-\n-  _igvn.replace_input_of(outer_end, 1, exit_bol);\n-\n-  assert(outer_head->in(LoopNode::LoopBackControl)->in(0) == outer_end, \"\");\n-  _igvn.replace_input_of(outer_head->in(LoopNode::LoopBackControl), 0, C->top());\n-  _igvn.replace_input_of(back_control, 0, outer_end);\n-  set_idom(back_control, outer_end, dom_depth(outer_end) + 1);\n-\n-  Unique_Node_List wq;\n-  wq.push(safepoint);\n-\n-  IdealLoopTree* outer_loop_ilt = get_loop(outer_head);\n-\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    for (uint j = 0; j < n->req(); ++j) {\n-      Node* in = n->in(j);\n-      if (in == NULL || in->is_CFG()) {\n-        continue;\n-      }\n-      if (get_loop(get_ctrl(in)) != outer_loop_ilt) {\n-        continue;\n-      }\n-      assert(!loop->_body.contains(in), \"\");\n-      loop->_body.push(in);\n-      wq.push(in);\n-    }\n-  }\n-\n-  set_loop(outer_end, loop);\n-  loop->_body.push(outer_end);\n-  set_loop(safepoint, loop);\n-  loop->_body.push(safepoint);\n-  set_loop(safepoint->in(0), loop);\n-  loop->_body.push(safepoint->in(0));\n-\n-  exit_test = outer_end;\n-\n-  outer_loop_ilt->_tail = C->top();\n-}\n-\n@@ -1993,1 +1934,0 @@\n-                         LoopStripMiningIter > 1 &&\n@@ -2021,1 +1961,1 @@\n-    if (sfpt != NULL && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt))) {\n+    if (sfpt != NULL && (strip_mine_loop || is_deleteable_safept(sfpt))) {\n@@ -2563,0 +2503,117 @@\n+void OuterStripMinedLoopNode::fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* target, PhaseIterGVN* igvn,\n+                                              PhaseIdealLoop* iloop) {\n+  Node* cle_out = inner_cle->proj_out(false);\n+  Node* cle_tail = inner_cle->proj_out(true);\n+  if (cle_out->outcnt() > 1) {\n+    \/\/ Look for chains of stores that were sunk\n+    \/\/ out of the inner loop and are in the outer loop\n+    for (DUIterator_Fast imax, i = cle_out->fast_outs(imax); i < imax; i++) {\n+      Node* u = cle_out->fast_out(i);\n+      if (u->is_Store()) {\n+        int alias_idx = igvn->C->get_alias_index(u->adr_type());\n+        Node* first = u;\n+        for(;;) {\n+          Node* next = first->in(MemNode::Memory);\n+          if (!next->is_Store() || next->in(0) != cle_out) {\n+            break;\n+          }\n+          assert(igvn->C->get_alias_index(next->adr_type()) == alias_idx, \"\");\n+          first = next;\n+        }\n+        Node* last = u;\n+        for(;;) {\n+          Node* next = NULL;\n+          for (DUIterator_Fast jmax, j = last->fast_outs(jmax); j < jmax; j++) {\n+            Node* uu = last->fast_out(j);\n+            if (uu->is_Store() && uu->in(0) == cle_out) {\n+              assert(next == NULL, \"only one in the outer loop\");\n+              next = uu;\n+              assert(igvn->C->get_alias_index(next->adr_type()) == alias_idx, \"\");\n+            }\n+          }\n+          if (next == NULL) {\n+            break;\n+          }\n+          last = next;\n+        }\n+        Node* phi = NULL;\n+        for (DUIterator_Fast jmax, j = target->fast_outs(jmax); j < jmax; j++) {\n+          Node* uu = target->fast_out(j);\n+          if (uu->is_Phi()) {\n+            Node* be = uu->in(LoopNode::LoopBackControl);\n+            if (be->is_Store() && be->in(0) == target->in(LoopNode::LoopBackControl)) {\n+              assert(igvn->C->get_alias_index(uu->adr_type()) != alias_idx && igvn->C->get_alias_index(uu->adr_type()) != Compile::AliasIdxBot, \"unexpected store\");\n+            }\n+            if (be == last || be == first->in(MemNode::Memory)) {\n+              assert(igvn->C->get_alias_index(uu->adr_type()) == alias_idx || igvn->C->get_alias_index(uu->adr_type()) == Compile::AliasIdxBot, \"unexpected alias\");\n+              assert(phi == NULL, \"only one phi\");\n+              phi = uu;\n+            }\n+          }\n+        }\n+#ifdef ASSERT\n+        for (DUIterator_Fast jmax, j = target->fast_outs(jmax); j < jmax; j++) {\n+          Node* uu = target->fast_out(j);\n+          if (uu->is_Phi() && uu->bottom_type() == Type::MEMORY) {\n+            if (uu->adr_type() == igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type()))) {\n+              assert(phi == uu, \"what's that phi?\");\n+            } else if (uu->adr_type() == TypePtr::BOTTOM) {\n+              Node* n = uu->in(LoopNode::LoopBackControl);\n+              uint limit = igvn->C->live_nodes();\n+              uint i = 0;\n+              while (n != uu) {\n+                i++;\n+                assert(i < limit, \"infinite loop\");\n+                if (n->is_Proj()) {\n+                  n = n->in(0);\n+                } else if (n->is_SafePoint() || n->is_MemBar()) {\n+                  n = n->in(TypeFunc::Memory);\n+                } else if (n->is_Phi()) {\n+                  n = n->in(1);\n+                } else if (n->is_MergeMem()) {\n+                  n = n->as_MergeMem()->memory_at(igvn->C->get_alias_index(u->adr_type()));\n+                } else if (n->is_Store() || n->is_LoadStore() || n->is_ClearArray()) {\n+                  n = n->in(MemNode::Memory);\n+                } else {\n+                  n->dump();\n+                  ShouldNotReachHere();\n+                }\n+              }\n+            }\n+          }\n+        }\n+#endif\n+        if (phi == NULL) {\n+          \/\/ If the an entire chains was sunk, the\n+          \/\/ inner loop has no phi for that memory\n+          \/\/ slice, create one for the outer loop\n+          phi = PhiNode::make(target, first->in(MemNode::Memory), Type::MEMORY,\n+                              igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type())));\n+          phi->set_req(LoopNode::LoopBackControl, last);\n+          phi = register_new_node(phi, target, igvn, iloop);\n+          igvn->replace_input_of(first, MemNode::Memory, phi);\n+        } else {\n+          \/\/ Or fix the outer loop fix to include\n+          \/\/ that chain of stores.\n+          Node* be = phi->in(LoopNode::LoopBackControl);\n+          assert(!(be->is_Store() && be->in(0) == target->in(LoopNode::LoopBackControl)), \"store on the backedge + sunk stores: unsupported\");\n+          if (be == first->in(MemNode::Memory)) {\n+            if (be == phi->in(LoopNode::LoopBackControl)) {\n+              igvn->replace_input_of(phi, LoopNode::LoopBackControl, last);\n+            } else {\n+              igvn->replace_input_of(be, MemNode::Memory, last);\n+            }\n+          } else {\n+#ifdef ASSERT\n+            if (be == phi->in(LoopNode::LoopBackControl)) {\n+              assert(phi->in(LoopNode::LoopBackControl) == last, \"\");\n+            } else {\n+              assert(be->in(MemNode::Memory) == last, \"\");\n+            }\n+#endif\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n@@ -2570,0 +2627,8 @@\n+  if (LoopStripMiningIter == 0) {\n+    remove_outer_loop_and_safepoint(igvn);\n+    return;\n+  }\n+  if (LoopStripMiningIter == 1) {\n+    transform_to_counted_loop(igvn, NULL);\n+    return;\n+  }\n@@ -2589,5 +2654,1 @@\n-    Node* outer_sfpt = outer_safepoint();\n-    Node* outer_out = outer_loop_exit();\n-    igvn->replace_node(outer_out, outer_sfpt->in(0));\n-    igvn->replace_input_of(outer_sfpt, 0, igvn->C->top());\n-    inner_cl->clear_strip_mined();\n+    remove_outer_loop_and_safepoint(igvn);\n@@ -2674,115 +2735,0 @@\n-  Node* cle_out = inner_cle->proj_out(false);\n-  if (cle_out->outcnt() > 1) {\n-    \/\/ Look for chains of stores that were sunk\n-    \/\/ out of the inner loop and are in the outer loop\n-    for (DUIterator_Fast imax, i = cle_out->fast_outs(imax); i < imax; i++) {\n-      Node* u = cle_out->fast_out(i);\n-      if (u->is_Store()) {\n-        Node* first = u;\n-        for(;;) {\n-          Node* next = first->in(MemNode::Memory);\n-          if (!next->is_Store() || next->in(0) != cle_out) {\n-            break;\n-          }\n-          first = next;\n-        }\n-        Node* last = u;\n-        for(;;) {\n-          Node* next = NULL;\n-          for (DUIterator_Fast jmax, j = last->fast_outs(jmax); j < jmax; j++) {\n-            Node* uu = last->fast_out(j);\n-            if (uu->is_Store() && uu->in(0) == cle_out) {\n-              assert(next == NULL, \"only one in the outer loop\");\n-              next = uu;\n-            }\n-          }\n-          if (next == NULL) {\n-            break;\n-          }\n-          last = next;\n-        }\n-        Node* phi = NULL;\n-        for (DUIterator_Fast jmax, j = fast_outs(jmax); j < jmax; j++) {\n-          Node* uu = fast_out(j);\n-          if (uu->is_Phi()) {\n-            Node* be = uu->in(LoopNode::LoopBackControl);\n-            if (be->is_Store() && old_new[be->_idx] != NULL) {\n-              assert(false, \"store on the backedge + sunk stores: unsupported\");\n-              \/\/ drop outer loop\n-              IfNode* outer_le = outer_loop_end();\n-              Node* iff = igvn->transform(new IfNode(outer_le->in(0), outer_le->in(1), outer_le->_prob, outer_le->_fcnt));\n-              igvn->replace_node(outer_le, iff);\n-              inner_cl->clear_strip_mined();\n-              return;\n-            }\n-            if (be == last || be == first->in(MemNode::Memory)) {\n-              assert(phi == NULL, \"only one phi\");\n-              phi = uu;\n-            }\n-          }\n-        }\n-#ifdef ASSERT\n-        for (DUIterator_Fast jmax, j = fast_outs(jmax); j < jmax; j++) {\n-          Node* uu = fast_out(j);\n-          if (uu->is_Phi() && uu->bottom_type() == Type::MEMORY) {\n-            if (uu->adr_type() == igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type()))) {\n-              assert(phi == uu, \"what's that phi?\");\n-            } else if (uu->adr_type() == TypePtr::BOTTOM) {\n-              Node* n = uu->in(LoopNode::LoopBackControl);\n-              uint limit = igvn->C->live_nodes();\n-              uint i = 0;\n-              while (n != uu) {\n-                i++;\n-                assert(i < limit, \"infinite loop\");\n-                if (n->is_Proj()) {\n-                  n = n->in(0);\n-                } else if (n->is_SafePoint() || n->is_MemBar()) {\n-                  n = n->in(TypeFunc::Memory);\n-                } else if (n->is_Phi()) {\n-                  n = n->in(1);\n-                } else if (n->is_MergeMem()) {\n-                  n = n->as_MergeMem()->memory_at(igvn->C->get_alias_index(u->adr_type()));\n-                } else if (n->is_Store() || n->is_LoadStore() || n->is_ClearArray()) {\n-                  n = n->in(MemNode::Memory);\n-                } else {\n-                  n->dump();\n-                  ShouldNotReachHere();\n-                }\n-              }\n-            }\n-          }\n-        }\n-#endif\n-        if (phi == NULL) {\n-          \/\/ If the an entire chains was sunk, the\n-          \/\/ inner loop has no phi for that memory\n-          \/\/ slice, create one for the outer loop\n-          phi = PhiNode::make(this, first->in(MemNode::Memory), Type::MEMORY,\n-                              igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type())));\n-          phi->set_req(LoopNode::LoopBackControl, last);\n-          phi = igvn->transform(phi);\n-          igvn->replace_input_of(first, MemNode::Memory, phi);\n-        } else {\n-          \/\/ Or fix the outer loop fix to include\n-          \/\/ that chain of stores.\n-          Node* be = phi->in(LoopNode::LoopBackControl);\n-          assert(!(be->is_Store() && old_new[be->_idx] != NULL), \"store on the backedge + sunk stores: unsupported\");\n-          if (be == first->in(MemNode::Memory)) {\n-            if (be == phi->in(LoopNode::LoopBackControl)) {\n-              igvn->replace_input_of(phi, LoopNode::LoopBackControl, last);\n-            } else {\n-              igvn->replace_input_of(be, MemNode::Memory, last);\n-            }\n-          } else {\n-#ifdef ASSERT\n-            if (be == phi->in(LoopNode::LoopBackControl)) {\n-              assert(phi->in(LoopNode::LoopBackControl) == last, \"\");\n-            } else {\n-              assert(be->in(MemNode::Memory) == last, \"\");\n-            }\n-#endif\n-          }\n-        }\n-      }\n-    }\n-  }\n@@ -2837,0 +2783,90 @@\n+void OuterStripMinedLoopNode::transform_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop) {\n+  CountedLoopNode* inner_cl = unique_ctrl_out()->as_CountedLoop();\n+  CountedLoopEndNode* cle = inner_cl->loopexit();\n+  Node* inner_test = cle->in(1);\n+  IfNode* outer_le = outer_loop_end();\n+  CountedLoopEndNode* inner_cle = inner_cl->loopexit();\n+  Node* safepoint = outer_safepoint();\n+\n+  fix_sunk_stores(inner_cle, inner_cl, igvn, iloop);\n+\n+  \/\/ make counted loop exit test always fail\n+  ConINode* zero = igvn->intcon(0);\n+  if (iloop != NULL) {\n+    iloop->set_ctrl(zero, igvn->C->root());\n+  }\n+  igvn->replace_input_of(cle, 1, zero);\n+  \/\/ replace outer loop end with CountedLoopEndNode with formers' CLE's exit test\n+  Node* new_end = new CountedLoopEndNode(outer_le->in(0), inner_test, cle->_prob, cle->_fcnt);\n+  register_control(new_end, inner_cl, outer_le->in(0), igvn, iloop);\n+  if (iloop == NULL) {\n+    igvn->replace_node(outer_le, new_end);\n+  } else {\n+    iloop->lazy_replace(outer_le, new_end);\n+  }\n+  \/\/ the backedge of the inner loop must be rewired to the new loop end\n+  Node* backedge = cle->proj_out(true);\n+  igvn->replace_input_of(backedge, 0, new_end);\n+  if (iloop != NULL) {\n+    iloop->set_idom(backedge, new_end, iloop->dom_depth(new_end) + 1);\n+  }\n+  \/\/ make the outer loop go away\n+  igvn->replace_input_of(in(LoopBackControl), 0, igvn->C->top());\n+  igvn->replace_input_of(this, LoopBackControl, igvn->C->top());\n+  inner_cl->clear_strip_mined();\n+  if (iloop != NULL) {\n+    Unique_Node_List wq;\n+    wq.push(safepoint);\n+\n+    IdealLoopTree* outer_loop_ilt = iloop->get_loop(this);\n+    IdealLoopTree* loop = iloop->get_loop(inner_cl);\n+\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* n = wq.at(i);\n+      for (uint j = 0; j < n->req(); ++j) {\n+        Node* in = n->in(j);\n+        if (in == NULL || in->is_CFG()) {\n+          continue;\n+        }\n+        if (iloop->get_loop(iloop->get_ctrl(in)) != outer_loop_ilt) {\n+          continue;\n+        }\n+        assert(!loop->_body.contains(in), \"\");\n+        loop->_body.push(in);\n+        wq.push(in);\n+      }\n+    }\n+    iloop->set_loop(safepoint, loop);\n+    loop->_body.push(safepoint);\n+    iloop->set_loop(safepoint->in(0), loop);\n+    loop->_body.push(safepoint->in(0));\n+    outer_loop_ilt->_tail = igvn->C->top();\n+  }\n+}\n+\n+void OuterStripMinedLoopNode::remove_outer_loop_and_safepoint(PhaseIterGVN* igvn) const {\n+  CountedLoopNode* inner_cl = unique_ctrl_out()->as_CountedLoop();\n+  Node* outer_sfpt = outer_safepoint();\n+  Node* outer_out = outer_loop_exit();\n+  igvn->replace_node(outer_out, outer_sfpt->in(0));\n+  igvn->replace_input_of(outer_sfpt, 0, igvn->C->top());\n+  inner_cl->clear_strip_mined();\n+}\n+\n+Node* OuterStripMinedLoopNode::register_new_node(Node* node, LoopNode* ctrl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop) {\n+  if (iloop == NULL) {\n+    return igvn->transform(node);\n+  }\n+  iloop->register_new_node(node, ctrl);\n+  return node;\n+}\n+\n+Node* OuterStripMinedLoopNode::register_control(Node* node, Node* loop, Node* idom, PhaseIterGVN* igvn,\n+                                                PhaseIdealLoop* iloop) {\n+  if (iloop == NULL) {\n+    return igvn->transform(node);\n+  }\n+  iloop->register_control(node, iloop->get_loop(loop), idom);\n+  return node;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":221,"deletions":185,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -549,1 +549,2 @@\n-  CountedLoopNode* inner_loop() const;\n+  static void fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* target, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n@@ -565,0 +566,9 @@\n+\n+  void remove_outer_loop_and_safepoint(PhaseIterGVN* igvn) const;\n+\n+  void transform_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n+  static Node* register_new_node(Node* node, LoopNode* ctrl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n+  Node* register_control(Node* node, Node* loop, Node* idom, PhaseIterGVN* igvn,\n+                         PhaseIdealLoop* iloop);\n@@ -1659,2 +1669,0 @@\n-  void strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head, Node* back_control,\n-                                             IfNode*&exit_test, SafePointNode*&safepoint);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * bug 8281322\n+ * @summary check counted loop is properly constructed with\/without safepoint\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestCountedLoopSafepoint\n+ *\/\n+\n+public class TestCountedLoopSafepoint {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:-UseCountedLoopSafepoints\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\");\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"0\" }, failOn = { IRNode.SAFEPOINT, IRNode.OUTERSTRIPMINEDLOOP })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"1\" }, counts = { IRNode.SAFEPOINT, \"1\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"> 1\" }, counts = { IRNode.SAFEPOINT, \"1\", IRNode.OUTERSTRIPMINEDLOOP, \"1\" })\n+    public static float test(int start, int stop) {\n+        float v = 1;\n+        for (int i = start; i < stop; i++) {\n+            v *= 2;\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test\")\n+    private void testRunner() {\n+        test(0, 100);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestCountedLoopSafepoint.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -39,1 +39,3 @@\n-        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}