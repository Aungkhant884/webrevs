{"files":[{"patch":"@@ -1080,0 +1080,6 @@\n+\/\/ Just marks the methods in this class as needing deoptimization\n+void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n+}\n+\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  static void mark_for_evol_deoptimization(InstanceKlass* dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -315,0 +315,1 @@\n+bool              JvmtiExport::_all_dependencies_are_recorded             = false;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,0 +190,7 @@\n+  \/\/ Flag to indicate if the compiler has recorded all dependencies. When the\n+  \/\/ can_redefine_classes capability is enabled in the OnLoad phase then the compiler\n+  \/\/ records all dependencies from startup. However if the capability is first\n+  \/\/ enabled some time later then the dependencies recorded by the compiler\n+  \/\/ are incomplete. This flag is used by RedefineClasses to know if the\n+  \/\/ dependency information is complete or not.\n+  static bool _all_dependencies_are_recorded;\n@@ -210,0 +217,8 @@\n+  inline static bool all_dependencies_are_recorded() {\n+    return _all_dependencies_are_recorded;\n+  }\n+\n+  inline static void set_all_dependencies_are_recorded(bool on) {\n+    _all_dependencies_are_recorded = (on != 0);\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,0 +331,7 @@\n+  \/\/ If can_redefine_classes is enabled in the onload phase then we know that the\n+  \/\/ dependency information recorded by the compiler is complete.\n+  if ((avail.can_redefine_classes || avail.can_retransform_classes) &&\n+      JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {\n+    JvmtiExport::set_all_dependencies_are_recorded(true);\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4071,1 +4071,27 @@\n-\/\/ Deoptimize all compiled code that depends on the classes redefined.\n+\/\/ Deoptimize all compiled code that depends on this class.\n+\/\/\n+\/\/ If the can_redefine_classes capability is obtained in the onload\n+\/\/ phase then the compiler has recorded all dependencies from startup.\n+\/\/ In that case we need only deoptimize and throw away all compiled code\n+\/\/ that depends on the class.\n+\/\/\n+\/\/ If can_redefine_classes is obtained sometime after the onload\n+\/\/ phase then the dependency information may be incomplete. In that case\n+\/\/ the first call to RedefineClasses causes all compiled code to be\n+\/\/ thrown away. As can_redefine_classes has been obtained then\n+\/\/ all future compilations will record dependencies so second and\n+\/\/ subsequent calls to RedefineClasses need only throw away code\n+\/\/ that depends on the class.\n+\/\/\n+\n+\/\/ First step is to walk the code cache for each class redefined and mark\n+\/\/ dependent methods.  Wait until all classes are processed to deoptimize everything.\n+void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {\n+  assert_locked_or_safepoint(Compile_lock);\n+\n+  \/\/ All dependencies have been recorded from startup or this is a second or\n+  \/\/ subsequent use of RedefineClasses\n+  if (JvmtiExport::all_dependencies_are_recorded()) {\n+    CodeCache::mark_for_evol_deoptimization(ik);\n+  }\n+}\n@@ -4076,2 +4102,12 @@\n-  int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n-  log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n+  bool deopt_needed;\n+\n+  \/\/ This is the first redefinition, mark all the nmethods for deoptimization\n+  if (!JvmtiExport::all_dependencies_are_recorded()) {\n+    log_debug(redefine, class, nmethod)(\"Marked all nmethods for deopt\");\n+    CodeCache::mark_all_nmethods_for_evol_deoptimization();\n+    deopt_needed = true;\n+  } else {\n+    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n+    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n+    deopt_needed = (deopt != 0);\n+  }\n@@ -4079,1 +4115,1 @@\n-  if (deopt != 0) {\n+  if (deopt_needed) {\n@@ -4082,0 +4118,3 @@\n+\n+  \/\/ From now on we know that the dependency information is complete\n+  JvmtiExport::set_all_dependencies_are_recorded(true);\n@@ -4184,0 +4223,3 @@\n+\n+  \/\/ Mark all compiled code that depends on this class\n+  mark_dependent_code(the_class);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+  void mark_dependent_code(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}