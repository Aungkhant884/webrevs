{"files":[{"patch":"@@ -1547,1 +1547,1 @@\n-\/\/ vector fmla - predicated\n+\/\/ vector fmad - predicated\n@@ -1550,1 +1550,1 @@\n-instruct vfmlaF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+instruct vfmadF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n@@ -1563,1 +1563,1 @@\n-instruct vfmlaD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+instruct vfmadD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n@@ -1578,3 +1578,4 @@\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-instruct vfmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n+\/\/ The NegVF must not be predicated.\n+instruct vfmlsF1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n@@ -1582,0 +1583,14 @@\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegVF must not be predicated.\n+instruct vfmlsF2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n@@ -1593,3 +1608,4 @@\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-instruct vfmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n+\/\/ The NegVD must not be predicated.\n+instruct vfmlsD1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n@@ -1597,0 +1613,14 @@\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegVD must not be predicated.\n+instruct vfmlsD2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n@@ -1607,0 +1637,32 @@\n+\/\/ vector fmsb - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegVF must not be predicated.\n+instruct vfmsbF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegVD must not be predicated.\n+instruct vfmsbD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1610,3 +1672,5 @@\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-instruct vfnmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n+\/\/ The NegVF must not be predicated.\n+instruct vfnmlaF1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n@@ -1614,0 +1678,15 @@\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegVF must not be predicated.\n+instruct vfnmlaF2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n@@ -1625,3 +1704,5 @@\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-instruct vfnmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n+\/\/ The NegVD must not be predicated.\n+instruct vfnmlaD1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n@@ -1629,0 +1710,15 @@\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegVD must not be predicated.\n+instruct vfnmlaD2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n@@ -1639,0 +1735,34 @@\n+\/\/ vector fnmad - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegVF must not be predicated.\n+instruct vfnmadF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegVD must not be predicated.\n+instruct vfnmadD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1642,0 +1772,1 @@\n+\/\/ The NegVF must not be predicated.\n@@ -1643,1 +1774,2 @@\n-  predicate(UseFMA && UseSVE > 0);\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n@@ -1655,0 +1787,1 @@\n+\/\/ The NegVD must not be predicated.\n@@ -1656,1 +1789,2 @@\n-  predicate(UseFMA && UseSVE > 0);\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n@@ -1667,0 +1801,32 @@\n+\/\/ vector fnmsb - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegVF must not be predicated.\n+instruct vfnmsbF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegVD must not be predicated.\n+instruct vfnmsbD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1725,0 +1891,58 @@\n+\/\/ vector mla - predicated\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaB_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaS_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaI_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaL_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1783,0 +2007,58 @@\n+\/\/ vector mls - predicated\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsB_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsS_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsI_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsL_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":299,"deletions":17,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -906,2 +906,2 @@\n-dnl VFMLA($1           $2    $3         )\n-dnl VFMLA(name_suffix, size, min_vec_len)\n+dnl VFMLA($1           $2  )\n+dnl VFMLA(name_suffix, size)\n@@ -923,2 +923,2 @@\n-VFMLA(F, S, 4)\n-VFMLA(D, D, 2)\n+VFMLA(F, S)\n+VFMLA(D, D)\n@@ -927,3 +927,3 @@\n-dnl VFMLA_PREDICATE($1,   $2  )\n-dnl VFMLA_PREDICATE(type, size)\n-define(`VFMLA_PREDICATE', `\n+dnl VFMAD_PREDICATE($1           $2  )\n+dnl VFMAD_PREDICATE(name_suffix, size)\n+define(`VFMAD_PREDICATE', `\n@@ -931,1 +931,1 @@\n-instruct vfmla$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+instruct vfmad$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n@@ -943,3 +943,3 @@\n-\/\/ vector fmla - predicated\n-VFMLA_PREDICATE(F, S)\n-VFMLA_PREDICATE(D, D)\n+\/\/ vector fmad - predicated\n+VFMAD_PREDICATE(F, S)\n+VFMAD_PREDICATE(D, D)\n@@ -948,3 +948,3 @@\n-dnl VFMLS($1           $2    $3         )\n-dnl VFMLS(name_suffix, size, min_vec_len)\n-define(`VFMLS', `\n+dnl VFMLS1($1           $2  )\n+dnl VFMLS1(name_suffix, size)\n+define(`VFMLS1', `\n@@ -952,3 +952,4 @@\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-instruct vfmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfmls`$1'1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n@@ -956,0 +957,17 @@\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VFMLS2($1           $2  )\n+dnl VFMLS2(name_suffix, size)\n+define(`VFMLS2', `\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfmls`$1'2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n@@ -967,2 +985,27 @@\n-VFMLS(F, S, 4)\n-VFMLS(D, D, 2)\n+VFMLS1(F, S)\n+VFMLS2(F, S)\n+VFMLS1(D, D)\n+VFMLS2(D, D)\n+\n+dnl\n+dnl VFMSB_PREDICATE($1           $2  )\n+dnl VFMSB_PREDICATE(name_suffix, size)\n+define(`VFMSB_PREDICATE', `\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfmsb$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaV$1 (Binary dst_src1 (NegV$1 src2)) (Binary src3 pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fmsb - predicated\n+VFMSB_PREDICATE(F, S)\n+VFMSB_PREDICATE(D, D)\n@@ -971,3 +1014,3 @@\n-dnl VFNMLA($1           $2    $3         )\n-dnl VFNMLA(name_suffix, size, min_vec_len)\n-define(`VFNMLA', `\n+dnl VFNMLA1($1           $2  )\n+dnl VFNMLA1(name_suffix, size)\n+define(`VFNMLA1', `\n@@ -975,3 +1018,5 @@\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-instruct vfnmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfnmla`$1'1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n@@ -979,0 +1024,18 @@\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VFNMLA2($1           $2  )\n+dnl VFNMLA2(name_suffix, size)\n+define(`VFNMLA2', `\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfnmla`$1'2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n@@ -990,2 +1053,28 @@\n-VFNMLA(F, S, 4)\n-VFNMLA(D, D, 2)\n+VFNMLA1(F, S)\n+VFNMLA2(F, S)\n+VFNMLA1(D, D)\n+VFNMLA2(D, D)\n+\n+dnl\n+dnl VFNMAD_PREDICATE($1           $2  )\n+dnl VFNMAD_PREDICATE(name_suffix, size)\n+define(`VFNMAD_PREDICATE', `\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfnmad$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaV$1 (Binary dst_src1 (NegV$1 src2)) (Binary (NegV$1 src3) pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fnmad - predicated\n+VFNMAD_PREDICATE(F, S)\n+VFNMAD_PREDICATE(D, D)\n@@ -994,2 +1083,2 @@\n-dnl VFNMLS($1           $2    $3         )\n-dnl VFNMLS(name_suffix, size, min_vec_len)\n+dnl VFNMLS($1           $2  )\n+dnl VFNMLS(name_suffix, size)\n@@ -998,0 +1087,1 @@\n+\/\/ The NegV$1 must not be predicated.\n@@ -999,1 +1089,2 @@\n-  predicate(UseFMA && UseSVE > 0);\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n@@ -1011,2 +1102,2 @@\n-VFNMLS(F, S, 4)\n-VFNMLS(D, D, 2)\n+VFNMLS(F, S)\n+VFNMLS(D, D)\n@@ -1015,2 +1106,25 @@\n-dnl VMLA($1           $2    $3         )\n-dnl VMLA(name_suffix, size, min_vec_len)\n+dnl VFNMSB_PREDICATE($1           $2  )\n+dnl VFNMSB_PREDICATE(name_suffix, size)\n+define(`VFNMSB_PREDICATE', `\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegV$1 must not be predicated.\n+instruct vfnmsb$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaV$1 (Binary dst_src1 src2) (Binary (NegV$1 src3) pg)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fnmsb - predicated\n+VFNMSB_PREDICATE(F, S)\n+VFNMSB_PREDICATE(D, D)\n+\n+dnl\n+dnl VMLA($1           $2  )\n+dnl VMLA(name_suffix, size)\n@@ -1033,4 +1147,28 @@\n-VMLA(B, B, 16)\n-VMLA(S, H, 8)\n-VMLA(I, S, 4)\n-VMLA(L, D, 2)\n+VMLA(B, B)\n+VMLA(S, H)\n+VMLA(I, S)\n+VMLA(L, D)\n+\n+dnl\n+dnl VMLA_PREDICATE($1           $2  )\n+dnl VMLA_PREDICATE(name_suffix, size)\n+define(`VMLA_PREDICATE', `\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmla$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddV$1 (Binary dst_src1 (MulV$1 src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mla - predicated\n+VMLA_PREDICATE(B, B)\n+VMLA_PREDICATE(S, H)\n+VMLA_PREDICATE(I, S)\n+VMLA_PREDICATE(L, D)\n@@ -1039,2 +1177,2 @@\n-dnl VMLS($1           $2    $3         )\n-dnl VMLS(name_suffix, size, min_vec_len)\n+dnl VMLS($1           $2  )\n+dnl VMLS(name_suffix, size)\n@@ -1057,4 +1195,28 @@\n-VMLS(B, B, 16)\n-VMLS(S, H, 8)\n-VMLS(I, S, 4)\n-VMLS(L, D, 2)\n+VMLS(B, B)\n+VMLS(S, H)\n+VMLS(I, S)\n+VMLS(L, D)\n+\n+dnl\n+dnl VMLS_PREDICATE($1           $2  )\n+dnl VMLS_PREDICATE(name_suffix, size)\n+define(`VMLS_PREDICATE', `\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmls$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubV$1 (Binary dst_src1 (MulV$1 src2 src3)) pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n+         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mls - predicated\n+VMLS_PREDICATE(B, B)\n+VMLS_PREDICATE(S, H)\n+VMLS_PREDICATE(I, S)\n+VMLS_PREDICATE(L, D)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":206,"deletions":44,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -3176,2 +3176,5 @@\n-  INSN(sve_mla,   0b00000100, 0, 0b010); \/\/ multiply-add: Zda = Zda + Zn*Zm\n-  INSN(sve_mls,   0b00000100, 0, 0b011); \/\/ multiply-subtract: Zda = Zda + -Zn*Zm\n+  INSN(sve_fmsb,  0b01100101, 1, 0b101); \/\/ floating-point fused multiply-subtract, writing multiplicand: Zda = Zm + -Zda * Zn\n+  INSN(sve_fnmad, 0b01100101, 1, 0b110); \/\/ floating-point negated fused multiply-add, writing multiplicand: Zda = -Zm + -Zda * Zn\n+  INSN(sve_fnmsb, 0b01100101, 1, 0b111); \/\/ floating-point negated fused multiply-subtract, writing multiplicand: Zda = -Zm + Zda * Zn\n+  INSN(sve_mla,   0b00000100, 0, 0b010); \/\/ multiply-add, writing addend: Zda = Zda + Zn*Zm\n+  INSN(sve_mls,   0b00000100, 0, 0b011); \/\/ multiply-subtract, writing addend: Zda = Zda + -Zn*Zm\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1852,0 +1852,3 @@\n+                       [\"fmsb\", \"ZPZZ\", \"m\"],\n+                       [\"fnmad\", \"ZPZZ\", \"m\"],\n+                       [\"fnmsb\", \"ZPZZ\", \"m\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1156,10 +1156,13 @@\n-    __ sve_fnmla(z29, __ D, p3, z3, z3);               \/\/       fnmla   z29.d, p3\/m, z3.d, z3.d\n-    __ sve_fnmls(z9, __ S, p0, z24, z27);              \/\/       fnmls   z9.s, p0\/m, z24.s, z27.s\n-    __ sve_mla(z19, __ S, p5, z7, z25);                \/\/       mla     z19.s, p5\/m, z7.s, z25.s\n-    __ sve_mls(z13, __ B, p1, z7, z25);                \/\/       mls     z13.b, p1\/m, z7.b, z25.b\n-    __ sve_and(z21, z17, z17);                         \/\/       and     z21.d, z17.d, z17.d\n-    __ sve_eor(z3, z9, z19);                           \/\/       eor     z3.d, z9.d, z19.d\n-    __ sve_orr(z7, z11, z14);                          \/\/       orr     z7.d, z11.d, z14.d\n-    __ sve_bic(z17, z11, z13);                         \/\/       bic     z17.d, z11.d, z13.d\n-    __ sve_uzp1(z17, __ H, z30, z17);                  \/\/       uzp1    z17.h, z30.h, z17.h\n-    __ sve_uzp2(z15, __ S, z14, z26);                  \/\/       uzp2    z15.s, z14.s, z26.s\n+    __ sve_fmsb(z29, __ D, p3, z3, z3);                \/\/       fmsb    z29.d, p3\/m, z3.d, z3.d\n+    __ sve_fnmad(z9, __ S, p0, z24, z27);              \/\/       fnmad   z9.s, p0\/m, z24.s, z27.s\n+    __ sve_fnmsb(z19, __ D, p5, z7, z25);              \/\/       fnmsb   z19.d, p5\/m, z7.d, z25.d\n+    __ sve_fnmla(z13, __ S, p1, z7, z25);              \/\/       fnmla   z13.s, p1\/m, z7.s, z25.s\n+    __ sve_fnmls(z21, __ S, p4, z17, z0);              \/\/       fnmls   z21.s, p4\/m, z17.s, z0.s\n+    __ sve_mla(z9, __ H, p5, z11, z7);                 \/\/       mla     z9.h, p5\/m, z11.h, z7.h\n+    __ sve_mls(z14, __ H, p4, z17, z11);               \/\/       mls     z14.h, p4\/m, z17.h, z11.h\n+    __ sve_and(z24, z17, z30);                         \/\/       and     z24.d, z17.d, z30.d\n+    __ sve_eor(z8, z15, z14);                          \/\/       eor     z8.d, z15.d, z14.d\n+    __ sve_orr(z22, z27, z22);                         \/\/       orr     z22.d, z27.d, z22.d\n+    __ sve_bic(z8, z5, z27);                           \/\/       bic     z8.d, z5.d, z27.d\n+    __ sve_uzp1(z10, __ D, z0, z14);                   \/\/       uzp1    z10.d, z0.d, z14.d\n+    __ sve_uzp2(z21, __ B, z20, z0);                   \/\/       uzp2    z21.b, z20.b, z0.b\n@@ -1168,9 +1171,9 @@\n-    __ sve_andv(v27, __ H, p5, z7);                    \/\/       andv h27, p5, z7.h\n-    __ sve_orv(v5, __ H, p7, z27);                     \/\/       orv h5, p7, z27.h\n-    __ sve_eorv(v0, __ S, p3, z24);                    \/\/       eorv s0, p3, z24.s\n-    __ sve_smaxv(v20, __ S, p0, z3);                   \/\/       smaxv s20, p0, z3.s\n-    __ sve_sminv(v25, __ D, p1, z25);                  \/\/       sminv d25, p1, z25.d\n-    __ sve_fminv(v17, __ S, p4, z1);                   \/\/       fminv s17, p4, z1.s\n-    __ sve_fmaxv(v14, __ S, p7, z13);                  \/\/       fmaxv s14, p7, z13.s\n-    __ sve_fadda(v17, __ D, p0, z30);                  \/\/       fadda d17, p0, d17, z30.d\n-    __ sve_uaddv(v22, __ H, p5, z29);                  \/\/       uaddv d22, p5, z29.h\n+    __ sve_andv(v22, __ D, p6, z5);                    \/\/       andv d22, p6, z5.d\n+    __ sve_orv(v29, __ B, p4, z17);                    \/\/       orv b29, p4, z17.b\n+    __ sve_eorv(v12, __ H, p3, z29);                   \/\/       eorv h12, p3, z29.h\n+    __ sve_smaxv(v0, __ D, p4, z2);                    \/\/       smaxv d0, p4, z2.d\n+    __ sve_sminv(v20, __ D, p5, z21);                  \/\/       sminv d20, p5, z21.d\n+    __ sve_fminv(v12, __ S, p2, z2);                   \/\/       fminv s12, p2, z2.s\n+    __ sve_fmaxv(v14, __ S, p5, z22);                  \/\/       fmaxv s14, p5, z22.s\n+    __ sve_fadda(v19, __ D, p6, z26);                  \/\/       fadda d19, p6, d19, z26.d\n+    __ sve_uaddv(v12, __ B, p5, z21);                  \/\/       uaddv d12, p5, z21.b\n@@ -1195,7 +1198,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003d2,     0x94000000,\n-    0x97ffffd4,     0x940003cf,     0x3400000a,     0x34fffa2a,\n-    0x3400798a,     0x35000008,     0x35fff9c8,     0x35007928,\n-    0xb400000b,     0xb4fff96b,     0xb40078cb,     0xb500001d,\n-    0xb5fff91d,     0xb500787d,     0x10000013,     0x10fff8b3,\n-    0x10007813,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307796,     0x3758000c,     0x375ff7cc,     0x3758772c,\n+    0x14000000,     0x17ffffd7,     0x140003d5,     0x94000000,\n+    0x97ffffd4,     0x940003d2,     0x3400000a,     0x34fffa2a,\n+    0x340079ea,     0x35000008,     0x35fff9c8,     0x35007988,\n+    0xb400000b,     0xb4fff96b,     0xb400792b,     0xb500001d,\n+    0xb5fff91d,     0xb50078dd,     0x10000013,     0x10fff8b3,\n+    0x10007873,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363077f6,     0x3758000c,     0x375ff7cc,     0x3758778c,\n@@ -1206,13 +1209,13 @@\n-    0x54007500,     0x54000001,     0x54fff541,     0x540074a1,\n-    0x54000002,     0x54fff4e2,     0x54007442,     0x54000002,\n-    0x54fff482,     0x540073e2,     0x54000003,     0x54fff423,\n-    0x54007383,     0x54000003,     0x54fff3c3,     0x54007323,\n-    0x54000004,     0x54fff364,     0x540072c4,     0x54000005,\n-    0x54fff305,     0x54007265,     0x54000006,     0x54fff2a6,\n-    0x54007206,     0x54000007,     0x54fff247,     0x540071a7,\n-    0x54000008,     0x54fff1e8,     0x54007148,     0x54000009,\n-    0x54fff189,     0x540070e9,     0x5400000a,     0x54fff12a,\n-    0x5400708a,     0x5400000b,     0x54fff0cb,     0x5400702b,\n-    0x5400000c,     0x54fff06c,     0x54006fcc,     0x5400000d,\n-    0x54fff00d,     0x54006f6d,     0x5400000e,     0x54ffefae,\n-    0x54006f0e,     0x5400000f,     0x54ffef4f,     0x54006eaf,\n+    0x54007560,     0x54000001,     0x54fff541,     0x54007501,\n+    0x54000002,     0x54fff4e2,     0x540074a2,     0x54000002,\n+    0x54fff482,     0x54007442,     0x54000003,     0x54fff423,\n+    0x540073e3,     0x54000003,     0x54fff3c3,     0x54007383,\n+    0x54000004,     0x54fff364,     0x54007324,     0x54000005,\n+    0x54fff305,     0x540072c5,     0x54000006,     0x54fff2a6,\n+    0x54007266,     0x54000007,     0x54fff247,     0x54007207,\n+    0x54000008,     0x54fff1e8,     0x540071a8,     0x54000009,\n+    0x54fff189,     0x54007149,     0x5400000a,     0x54fff12a,\n+    0x540070ea,     0x5400000b,     0x54fff0cb,     0x5400708b,\n+    0x5400000c,     0x54fff06c,     0x5400702c,     0x5400000d,\n+    0x54fff00d,     0x54006fcd,     0x5400000e,     0x54ffefae,\n+    0x54006f6e,     0x5400000f,     0x54ffef4f,     0x54006f0f,\n@@ -1435,6 +1438,6 @@\n-    0x65ee2a86,     0x65e34c7d,     0x65bb6309,     0x049954f3,\n-    0x041964ed,     0x04313235,     0x04b33123,     0x046e3167,\n-    0x04ed3171,     0x05716bd1,     0x05ba6dcf,     0x045a34fb,\n-    0x04583f65,     0x04992f00,     0x04882074,     0x04ca2739,\n-    0x65873031,     0x65863dae,     0x65d823d1,     0x044137b6,\n-\n+    0x65ee2a86,     0x65e3ac7d,     0x65bbc309,     0x65f9f4f3,\n+    0x65b944ed,     0x65a07235,     0x04475569,     0x044b722e,\n+    0x043e3238,     0x04ae31e8,     0x04763376,     0x04fb30a8,\n+    0x05ee680a,     0x05206e95,     0x04da38b6,     0x0418323d,\n+    0x04592fac,     0x04c83040,     0x04ca36b4,     0x6587284c,\n+    0x658636ce,     0x65d83b53,     0x040136ac,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":48,"deletions":45,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8282431\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary AArch64: Add optimized rules for masked vector multiply-add\/sub for SVE\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorFusedMultiplyAddSubTest\n+ *\/\n+\n+public class VectorFusedMultiplyAddSubTest {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    private static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+\n+    private static int LENGTH = 1024;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static byte[] bc;\n+    private static byte[] br;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static short[] sc;\n+    private static short[] sr;\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static int[] ir;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lc;\n+    private static long[] lr;\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fc;\n+    private static float[] fr;\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dc;\n+    private static double[] dr;\n+    private static boolean[] m;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        bc = new byte[LENGTH];\n+        br = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        sc = new short[LENGTH];\n+        sr = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        ir = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        lr = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        fc = new float[LENGTH];\n+        fr = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        dc = new double[LENGTH];\n+        dr = new double[LENGTH];\n+        m = new boolean[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte) RD.nextInt(25);\n+            bb[i] = (byte) RD.nextInt(25);\n+            bc[i] = (byte) RD.nextInt(25);\n+            sa[i] = (short) RD.nextInt(25);\n+            sb[i] = (short) RD.nextInt(25);\n+            sc[i] = (short) RD.nextInt(25);\n+            ia[i] = RD.nextInt(25);\n+            ib[i] = RD.nextInt(25);\n+            ic[i] = RD.nextInt(25);\n+            la[i] = RD.nextLong(25);\n+            lb[i] = RD.nextLong(25);\n+            lc[i] = RD.nextLong(25);\n+            fa[i] = RD.nextFloat((float) 25.0);\n+            fb[i] = RD.nextFloat((float) 25.0);\n+            fc[i] = RD.nextFloat((float) 25.0);\n+            da[i] = RD.nextDouble(25.0);\n+            db[i] = RD.nextDouble(25.0);\n+            dc[i] = RD.nextDouble(25.0);\n+            m[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    interface BTenOp {\n+        byte apply(byte a, byte b, byte c);\n+    }\n+\n+    interface STenOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface ITenOp {\n+        int apply(int a, int b, int c);\n+    }\n+\n+    interface LTenOp {\n+        long apply(long a, long b, long c);\n+    }\n+\n+    interface FTenOp {\n+        float apply(float a, float b, float c);\n+    }\n+\n+    interface DTenOp {\n+        double apply(double a, double b, double c);\n+    }\n+\n+    private static void assertArrayEquals(byte[] r, byte[] a, byte[] b, byte[] c, boolean[] m, BTenOp f) {\n+       for (int i = 0; i < LENGTH; i++) {\n+           if (m[i % B_SPECIES.length()]) {\n+               Asserts.assertEquals(f.apply(a[i], b[i], c[i]), r[i]);\n+           } else {\n+               Asserts.assertEquals(a[i], r[i]);\n+           }\n+       }\n+    }\n+\n+    private static void assertArrayEquals(short[] r, short[] a, short[] b, short[] c, boolean[] m, STenOp f) {\n+       for (int i = 0; i < LENGTH; i++) {\n+           if (m[i % S_SPECIES.length()]) {\n+               Asserts.assertEquals(f.apply(a[i], b[i], c[i]), r[i]);\n+           } else {\n+               Asserts.assertEquals(a[i], r[i]);\n+           }\n+       }\n+    }\n+\n+    private static void assertArrayEquals(int[] r, int[] a, int[] b, int[] c, boolean[] m, ITenOp f) {\n+       for (int i = 0; i < LENGTH; i++) {\n+           if (m[i % I_SPECIES.length()]) {\n+               Asserts.assertEquals(f.apply(a[i], b[i], c[i]), r[i]);\n+           } else {\n+               Asserts.assertEquals(a[i], r[i]);\n+           }\n+       }\n+    }\n+\n+    private static void assertArrayEquals(long[] r, long[] a, long[] b, long[] c, boolean[] m, LTenOp f) {\n+       for (int i = 0; i < LENGTH; i++) {\n+           if (m[i % L_SPECIES.length()]) {\n+               Asserts.assertEquals(f.apply(a[i], b[i], c[i]), r[i]);\n+           } else {\n+               Asserts.assertEquals(a[i], r[i]);\n+           }\n+       }\n+    }\n+\n+    private static void assertArrayEquals(float[] r, float[] a, float[] b, float[] c, boolean[] m, FTenOp f) {\n+       for (int i = 0; i < LENGTH; i++) {\n+           if (m[i % F_SPECIES.length()]) {\n+               Asserts.assertEquals(f.apply(a[i], b[i], c[i]), r[i]);\n+           } else {\n+               Asserts.assertEquals(a[i], r[i]);\n+           }\n+       }\n+    }\n+\n+    private static void assertArrayEquals(double[] r, double[] a, double[] b, double[] c, boolean[] m, DTenOp f) {\n+       for (int i = 0; i < LENGTH; i++) {\n+           if (m[i % D_SPECIES.length()]) {\n+               Asserts.assertEquals(f.apply(a[i], b[i], c[i]), r[i]);\n+           } else {\n+               Asserts.assertEquals(a[i], r[i]);\n+           }\n+       }\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_add\", \"sve_mul\" })\n+    public static void testByteMultiplyAddMasked() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, i);\n+            ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, i);\n+            ByteVector cv = ByteVector.fromArray(B_SPECIES, bc, i);\n+            av.add(bv.mul(cv), mask).intoArray(br, i);\n+        }\n+        assertArrayEquals(br, ba, bb, bc, m, (a, b, c) -> (byte) (a + b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_sub\", \"sve_mul\" })\n+    public static void testByteMultiplySubMasked() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, i);\n+            ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, i);\n+            ByteVector cv = ByteVector.fromArray(B_SPECIES, bc, i);\n+            av.sub(bv.mul(cv), mask).intoArray(br, i);\n+        }\n+        assertArrayEquals(br, ba, bb, bc, m, (a, b, c) -> (byte) (a - b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_add\", \"sve_mul\" })\n+    public static void testShortMultiplyAddMasked() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, i);\n+            ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, i);\n+            ShortVector cv = ShortVector.fromArray(S_SPECIES, sc, i);\n+            av.add(bv.mul(cv), mask).intoArray(sr, i);\n+        }\n+        assertArrayEquals(sr, sa, sb, sc, m, (a, b, c) -> (short) (a + b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_sub\", \"sve_mul\" })\n+    public static void testShortMultiplySubMasked() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, i);\n+            ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, i);\n+            ShortVector cv = ShortVector.fromArray(S_SPECIES, sc, i);\n+            av.sub(bv.mul(cv), mask).intoArray(sr, i);\n+        }\n+        assertArrayEquals(sr, sa, sb, sc, m, (a, b, c) -> (short) (a - b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_add\", \"sve_mul\" })\n+    public static void testIntMultiplyAddMasked() {\n+        VectorMask<Integer> mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, i);\n+            IntVector bv = IntVector.fromArray(I_SPECIES, ib, i);\n+            IntVector cv = IntVector.fromArray(I_SPECIES, ic, i);\n+            av.add(bv.mul(cv), mask).intoArray(ir, i);\n+        }\n+        assertArrayEquals(ir, ia, ib, ic, m, (a, b, c) -> (int) (a + b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_sub\", \"sve_mul\" })\n+    public static void testIntMultiplySubMasked() {\n+        VectorMask<Integer> mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, i);\n+            IntVector bv = IntVector.fromArray(I_SPECIES, ib, i);\n+            IntVector cv = IntVector.fromArray(I_SPECIES, ic, i);\n+            av.sub(bv.mul(cv), mask).intoArray(ir, i);\n+        }\n+        assertArrayEquals(ir, ia, ib, ic, m, (a, b, c) -> (int) (a - b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_add\", \"sve_mul\" })\n+    public static void testLongMultiplyAddMasked() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, i);\n+            LongVector bv = LongVector.fromArray(L_SPECIES, lb, i);\n+            LongVector cv = LongVector.fromArray(L_SPECIES, lc, i);\n+            av.add(bv.mul(cv), mask).intoArray(lr, i);\n+        }\n+        assertArrayEquals(lr, la, lb, lc, m, (a, b, c) -> (long) (a + b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_sub\", \"sve_mul\" })\n+    public static void testLongMultiplySubMasked() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, i);\n+            LongVector bv = LongVector.fromArray(L_SPECIES, lb, i);\n+            LongVector cv = LongVector.fromArray(L_SPECIES, lc, i);\n+            av.sub(bv.mul(cv), mask).intoArray(lr, i);\n+        }\n+        assertArrayEquals(lr, la, lb, lc, m, (a, b, c) -> (long) (a - b * c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_fneg\", \"sve_fmad\" })\n+    public static void testFloatMultiplySubMasked() {\n+        VectorMask<Float> mask = VectorMask.fromArray(F_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += F_SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(F_SPECIES, fa, i);\n+            FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, i);\n+            FloatVector cv = FloatVector.fromArray(F_SPECIES, fc, i);\n+            av.lanewise(VectorOperators.FMA, bv.neg(), cv, mask).intoArray(fr, i);\n+        }\n+        assertArrayEquals(fr, fa, fb, fc, m, (a, b, c) -> (float) Math.fma(a, -b, c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_fneg\", \"sve_fmad\" })\n+    public static void testFloatNegatedMultiplyAddMasked() {\n+        VectorMask<Float> mask = VectorMask.fromArray(F_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += F_SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(F_SPECIES, fa, i);\n+            FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, i);\n+            FloatVector cv = FloatVector.fromArray(F_SPECIES, fc, i);\n+            av.lanewise(VectorOperators.FMA, bv.neg(), cv.neg(), mask).intoArray(fr, i);\n+        }\n+        assertArrayEquals(fr, fa, fb, fc, m, (a, b, c) -> (float) Math.fma(a, -b, -c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_fneg\", \"sve_fmad\" })\n+    public static void testFloatNegatedMultiplySubMasked() {\n+        VectorMask<Float> mask = VectorMask.fromArray(F_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += F_SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(F_SPECIES, fa, i);\n+            FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, i);\n+            FloatVector cv = FloatVector.fromArray(F_SPECIES, fc, i);\n+            av.lanewise(VectorOperators.FMA, bv, cv.neg(), mask).intoArray(fr, i);\n+        }\n+        assertArrayEquals(fr, fa, fb, fc, m, (a, b, c) -> (float) Math.fma(a, b, -c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_fneg\", \"sve_fmad\" })\n+    public static void testDoubleMultiplySubMasked() {\n+        VectorMask<Double> mask = VectorMask.fromArray(D_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += D_SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, i);\n+            DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, i);\n+            DoubleVector cv = DoubleVector.fromArray(D_SPECIES, dc, i);\n+            av.lanewise(VectorOperators.FMA, bv.neg(), cv, mask).intoArray(dr, i);\n+        }\n+        assertArrayEquals(dr, da, db, dc, m, (a, b, c) -> (double) Math.fma(a, -b, c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_fneg\", \"sve_fmad\" })\n+    public static void testDoubleNegatedMultiplyAddMasked() {\n+        VectorMask<Double> mask = VectorMask.fromArray(D_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += D_SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, i);\n+            DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, i);\n+            DoubleVector cv = DoubleVector.fromArray(D_SPECIES, dc, i);\n+            av.lanewise(VectorOperators.FMA, bv.neg(), cv.neg(), mask).intoArray(dr, i);\n+        }\n+        assertArrayEquals(dr, da, db, dc, m, (a, b, c) -> (double) Math.fma(a, -b, -c));\n+    }\n+\n+    @Test\n+    @IR(failOn = { \"sve_fneg\", \"sve_fmad\" })\n+    public static void testDoubleNegatedMultiplySubMasked() {\n+        VectorMask<Double> mask = VectorMask.fromArray(D_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += D_SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, i);\n+            DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, i);\n+            DoubleVector cv = DoubleVector.fromArray(D_SPECIES, dc, i);\n+            av.lanewise(VectorOperators.FMA, bv, cv.neg(), mask).intoArray(dr, i);\n+        }\n+        assertArrayEquals(dr, da, db, dc, m, (a, b, c) -> (double) Math.fma(a, b, -c));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFusedMultiplyAddSubTest.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"}]}