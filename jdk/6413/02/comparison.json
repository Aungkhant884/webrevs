{"files":[{"patch":"@@ -106,0 +106,1 @@\n+  bool _inline_late;\n@@ -723,1 +724,1 @@\n-  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <klass> <name> <signature>)*\n+  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <inline_late> <klass> <name> <signature>)*\n@@ -765,0 +766,8 @@\n+        int inline_late = 0;\n+        if (_version >= 2) {\n+          inline_late = parse_int(\"inline_late\");\n+          if (had_error()) {\n+              break;\n+          }\n+        }\n+\n@@ -769,1 +778,1 @@\n-        new_ciInlineRecord(inl_method, bci, depth);\n+        new_ciInlineRecord(inl_method, bci, depth, inline_late);\n@@ -1229,1 +1238,1 @@\n-  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {\n+  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth, int inline_late) {\n@@ -1236,0 +1245,1 @@\n+    rec->_inline_late = inline_late;\n@@ -1472,1 +1482,1 @@\n-bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {\n+bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay) {\n@@ -1474,1 +1484,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n@@ -1477,1 +1487,6 @@\n-    return CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1481,1 +1496,6 @@\n-    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1488,1 +1508,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth);\n+  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay);\n@@ -138,1 +138,2 @@\n-#define REPLAY_VERSION 1 \/\/ current version, bump up for incompatible changes\n+\/\/ 2: incremental inlining support (8254108)\n+#define REPLAY_VERSION 2 \/\/ current version, bump up for incompatible changes\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  _late_inline(false),\n@@ -116,1 +117,1 @@\n-                               int caller_bci, ciCallProfile& profile) {\n+                               int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -131,3 +132,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -197,1 +202,1 @@\n-                                   int caller_bci, ciCallProfile& profile) {\n+                                   int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -235,3 +240,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -372,1 +381,3 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, profile)) {\n+\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (!should_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -375,1 +386,2 @@\n-  if (should_not_inline(callee_method, caller_method, caller_bci, profile)) {\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (should_not_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -560,2 +572,0 @@\n-  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n-  assert(!should_delay, \"should be initialized to false\");\n@@ -563,0 +573,1 @@\n+  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n@@ -598,1 +609,5 @@\n-    build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    InlineTree* callee_tree = build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    if (should_delay) {\n+      \/\/ Record late inlining decision in order to dump it for compiler replay\n+      callee_tree->set_late_inline();\n+    }\n@@ -703,1 +718,1 @@\n-  out->print(\" %d %d \", inline_level(), caller_bci());\n+  out->print(\" %d %d %d \", inline_level(), caller_bci(), _late_inline);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-      bool should_delay = false;\n+      bool should_delay = AlwaysIncrementalInline;\n@@ -192,1 +192,1 @@\n-          } else if ((should_delay || AlwaysIncrementalInline)) {\n+          } else if (should_delay) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool        _late_inline;       \/\/ method is inlined incrementally\n@@ -78,0 +79,1 @@\n+                            NOT_PRODUCT_ARG(bool& should_delay)\n@@ -82,0 +84,1 @@\n+                                NOT_PRODUCT_ARG(bool& should_delay)\n@@ -115,0 +118,4 @@\n+  void set_late_inline() {\n+    _late_inline = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,2 +27,7 @@\n-import java.io.IOException;\n-import java.io.File;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.CoreUtils;\n+\n@@ -30,0 +35,1 @@\n+import java.io.File;\n@@ -31,0 +37,1 @@\n+import java.io.IOException;\n@@ -39,8 +46,0 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.util.CoreUtils;\n@@ -299,0 +298,37 @@\n+\n+    protected void removeVersionFromReplayFile() {\n+        setNewVersionLineInReplayFile(null);\n+    }\n+\n+    protected void setNewVersionInReplayFile(int newVersionNumber) {\n+        setNewVersionLineInReplayFile(\"version \" + newVersionNumber);\n+    }\n+\n+    private void setNewVersionLineInReplayFile(String firstLineString) {\n+        List<String> newLines = new ArrayList<>();\n+        Path replayFilePath = Paths.get(getReplayFileName());\n+        try (var br = Files.newBufferedReader(replayFilePath)) {\n+            String line;\n+            boolean firstLine = true;\n+            while ((line = br.readLine()) != null) {\n+                if (firstLine) {\n+                    firstLine = false;\n+                    Asserts.assertTrue(line.startsWith(\"version\"), \"version number must exist in a proper replay file\");\n+                    if (firstLineString != null) {\n+                        newLines.add(firstLineString);\n+                    }\n+                    \/\/ Else: Remove first line by skipping it.\n+                } else {\n+                    newLines.add(line);\n+                }\n+            }\n+            Asserts.assertFalse(firstLine, replayFilePath + \" should not be empty\");\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read replay data: \" + e, e);\n+        }\n+        try {\n+            Files.write(replayFilePath, newLines, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to write replay data: \" + e, e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public abstract class InliningBase extends DumpReplayBase {\n+    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n+    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n+    protected final String[] commandLineReplay;\n+    protected final List<String> commandLineNormal;\n+    protected final Class<?> testClass;\n+\n+    protected InliningBase(Class<?> testClass) {\n+        this.testClass = testClass;\n+        commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n+                                                                 \"-XX:CompileCommand=exclude,\" + testClass.getName() + \"::main\",\n+                                                                 \"-XX:CompileCommand=option,\" + testClass.getName() + \"::test,bool,PrintInlining,true\"));\n+        commandLineReplay = new String[]\n+                {\"-XX:LogFile=\" + LOG_FILE_REPLAY, \"-XX:+LogCompilation\",\n+                 \"-XX:CompileCommand=option,\" + testClass.getName()  + \"::test,bool,PrintInlining,true\"};\n+    }\n+\n+    protected void runTest() {\n+        runTest(commandLineNormal.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    public String getTestClass() {\n+        return testClass.getName();\n+    }\n+\n+    @Override\n+    public void cleanup() {\n+        super.cleanup();\n+        remove(LOG_FILE_NORMAL);\n+        remove(LOG_FILE_REPLAY);\n+    }\n+\n+    static class InlineEntry {\n+        String klass;\n+        String method;\n+        String reason;\n+\n+        public InlineEntry(String klass, String method, String reason) {\n+            this.klass = klass;\n+            this.method = method;\n+            this.reason = reason;\n+        }\n+\n+        public boolean isNormalInline() {\n+            return reason.equals(\"inline (hot)\");\n+        }\n+\n+        public boolean isForcedByReplay() {\n+            return reason.equals(\"force inline by ciReplay\");\n+        }\n+\n+        public boolean isDisallowedByReplay() {\n+            return reason.equals(\"disallowed by ciReplay\");\n+        }\n+\n+        public boolean isUnloadedSignatureClasses() {\n+            return reason.equals(\"unloaded signature classes\");\n+        }\n+\n+        public boolean isForcedIncrementalInlineByReplay() {\n+            return reason.equals(\"force (incremental) inline by ciReplay\");\n+        }\n+\n+        public boolean isForcedInline() {\n+            return reason.equals(\"force inline by annotation\");\n+        }\n+\n+        public boolean isTooDeep() {\n+            return reason.equals(\"inlining too deep\");\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+\n+            if (!(other instanceof InlineEntry)) {\n+                return false;\n+            }\n+\n+            InlineEntry e = (InlineEntry)other;\n+            return klass.equals(e.klass) && method.equals(e.method);\n+        }\n+\n+        public boolean compare(String klass, String method, boolean kind) {\n+            return this.klass.equals(klass) && this.method.equals(method) && kind;\n+        }\n+    }\n+\n+    protected static List<InlineEntry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n+        String nmethodStart = \"<nmethod\";\n+        List<InlineEntry> inlinees = new ArrayList<>();\n+        int foundLines = 0;\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            boolean nmethodLine = false;\n+            boolean inlinineLine = false;\n+            while ((line = br.readLine()) != null) {\n+                if (nmethodLine) {\n+                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n+                    if (line.startsWith(\"             \")) {\n+                        inlinineLine = true;\n+                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n+                        Matcher matcher = p.matcher(line);\n+                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n+                        inlinees.add(new InlineEntry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n+                        foundLines++;\n+                    } else if (inlinineLine) {\n+                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n+                        return inlinees;\n+                    }\n+                } else {\n+                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n+                    if (nmethodLine) {\n+                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        Asserts.fail(\"Should have found inlinees\");\n+        return inlinees;\n+    }\n+\n+    protected void verifyLists(List<InlineEntry> inlineesNormal, List<InlineEntry> inlineesReplay, int expectedSize) {\n+        if (!inlineesNormal.equals(inlineesReplay)) {\n+            System.err.println(\"Normal entries:\");\n+            inlineesNormal.forEach(System.err::println);\n+            System.err.println(\"Replay entries:\");\n+            inlineesReplay.forEach(System.err::println);\n+            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n+        }\n+        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/InliningBase.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8254108\n+ * @library \/ \/test\/lib\n+ * @summary Testing of ciReplay with incremental inlining.\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" & vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.ciReplay.TestIncrementalInlining\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestIncrementalInlining extends InliningBase {\n+\n+    private List<InlineEntry> inlineesNormal;\n+    private List<InlineEntry> inlineesReplay;\n+    public static void main(String[] args) {\n+        new TestIncrementalInlining();\n+    }\n+\n+    TestIncrementalInlining() {\n+        super(IncrementalInliningTest.class);\n+        \/\/ Enable Whitebox access for test VM.\n+        commandLineNormal.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        commandLineNormal.add(\"-cp\");\n+        commandLineNormal.add(Utils.TEST_CLASS_PATH);\n+        commandLineNormal.add(\"-Xbootclasspath\/a:.\");\n+        commandLineNormal.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commandLineNormal.add(\"-XX:+WhiteBoxAPI\");\n+        commandLineNormal.add(\"-XX:MaxInlineLevel=2\");\n+        commandLineNormal.add(\"-XX:-AlwaysIncrementalInline\");\n+        runTest();\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        positiveTest(commandLineReplay);\n+        inlineesNormal = parseLogFile(LOG_FILE_NORMAL, getTestClass() + \" \" + \"test\", \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), 5);\n+        verify(true);\n+\n+        \/\/ Incremental inlining is supported in version 2+\n+        \/\/ Test replay file version 1.\n+        removeIncrementalInlineInfo();\n+        setNewVersionInReplayFile(1);\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+\n+        \/\/ Test replay file without version.\n+        removeVersionFromReplayFile();\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+    }\n+\n+    private void verify(boolean isNewFormat) {\n+        inlineesReplay = parseLogFile(LOG_FILE_REPLAY, getTestClass() + \" \" + \"test\", \"test ()V\", 5);\n+        verifyLists(inlineesNormal, inlineesReplay, 5);\n+        checkInlining(isNewFormat);\n+    }\n+\n+    \/\/ Check if inlining is done correctly in ciReplay.\n+    private void checkInlining(boolean isNewFormat) {\n+        String klass = getTestClass();\n+        Asserts.assertTrue(inlineesNormal.get(0).compare(klass, \"level0\", inlineesNormal.get(0).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(0).compare(klass, \"level0\", inlineesReplay.get(0).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(1).compare(klass, \"level1\", inlineesNormal.get(1).isNormalInline()));\n+        Asserts.assertTrue(inlineesReplay.get(1).compare(klass, \"level1\", inlineesReplay.get(1).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(2).compare(klass, \"level2\", inlineesNormal.get(2).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(2).compare(klass, \"level2\", inlineesReplay.get(2).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(3).compare(klass, \"late\", inlineesNormal.get(3).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(3).compare(klass, \"late\", isNewFormat ?\n+                inlineesReplay.get(3).isForcedIncrementalInlineByReplay()\n+                : inlineesReplay.get(3).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(4).compare(klass, \"level4\", inlineesNormal.get(4).isTooDeep()));\n+        Asserts.assertTrue(inlineesReplay.get(4).compare(klass, \"level4\", inlineesReplay.get(4).isDisallowedByReplay()));\n+    }\n+\n+    private void removeIncrementalInlineInfo() {\n+        try {\n+            Path replayFilePath = Paths.get(getReplayFileName());\n+            List<String> replayContent = Files.readAllLines(replayFilePath);\n+            for (int i = 0; i < replayContent.size(); i++) {\n+                String line = replayContent.get(i);\n+                if (line.startsWith(\"compile \")) {\n+                    int lastIndex = 0;\n+                    StringBuilder newLine = new StringBuilder();\n+                    Pattern p = Pattern.compile(\"(\\\\d (-?\\\\d)) \\\\d compiler\");\n+                    Matcher m = p.matcher(line);\n+                    boolean firstMatch = true;\n+                    while (m.find()) {\n+                        newLine.append(line, lastIndex, m.start())\n+                              .append(m.group(1))\n+                              .append(\" compiler\");\n+                        lastIndex = m.end();\n+                        String bci = m.group(2);\n+                        Asserts.assertTrue(firstMatch ? bci.equals(\"-1\") : bci.equals(\"0\"), \"only root has -1\");\n+                        firstMatch = false;\n+                    }\n+                    Asserts.assertLessThan(lastIndex, line.length(), \"not reached end of line, yet\");\n+                    newLine.append(line, lastIndex, line.length());\n+                    replayContent.set(i, newLine.toString());\n+                }\n+            }\n+            Files.write(replayFilePath, replayContent, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException ioe) {\n+            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n+        }\n+    }\n+}\n+\n+class IncrementalInliningTest {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static String s;\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level0\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level2\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"late\"), true);\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    private static void test() {\n+        level0();\n+    }\n+\n+    public static void level0() {\n+        level1();\n+    }\n+\n+    public static void level1() {\n+        level2();\n+    }\n+\n+    public static void level2() {\n+        late();\n+    }\n+\n+    \/\/ Reached max inline level but forced to be inlined -> inline late.\n+    public static void late() {\n+        level4();\n+    }\n+\n+    \/\/ Reached max inline level and not forced to be inlined -> no inline.\n+    public static void level4() {\n+        s = \"HelloWorld\";\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestIncrementalInlining.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -31,4 +31,1 @@\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      compiler.ciReplay.TestInliningProtectionDomain\n+ * @run driver compiler.ciReplay.TestInliningProtectionDomain\n@@ -41,4 +38,0 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n@@ -46,2 +39,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -49,6 +40,1 @@\n-public class TestInliningProtectionDomain extends DumpReplayBase {\n-    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n-    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n-    private final String[] commandLineReplay;\n-\n-    private final String className;\n+public class TestInliningProtectionDomain extends InliningBase {\n@@ -57,4 +43,4 @@\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestCompiledBefore\", true);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPublic\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivate\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivateString\", false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestCompiledBefore.class, true);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPublic.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivate.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivateString.class, false);\n@@ -63,5 +49,2 @@\n-    public TestInliningProtectionDomain(String className, boolean compileBar) {\n-        this.className = className;\n-        List<String> commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n-                                                           \"-XX:CompileCommand=exclude,\" + getTestClass() + \"::main\",\n-                                                           \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"));\n+    public TestInliningProtectionDomain(Class<?> testClass, boolean compileBar) {\n+        super(testClass);\n@@ -69,1 +52,1 @@\n-            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::bar\");\n+            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + testClass.getName() + \"::bar\");\n@@ -71,4 +54,1 @@\n-        commandLineReplay = new String[]\n-                {\"-XX:LogFile=\" + LOG_FILE_REPLAY + \"\", \"-XX:+LogCompilation\",\n-                 \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"};\n-        runTest(commandLineNormal.toArray(new String[0]));\n+        runTest();\n@@ -80,3 +60,2 @@\n-        String klass = \"compiler.ciReplay.\" + className;\n-        String entryString = klass + \" \" + \"test\";\n-        boolean inlineFails = className.equals(\"ProtectionDomainTestNoOtherCompilationPrivate\");\n+        String entryString = getTestClass() + \" \" + \"test\";\n+        boolean inlineFails = testClass == ProtectionDomainTestNoOtherCompilationPrivate.class;\n@@ -85,2 +64,2 @@\n-        List<Entry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n-        List<Entry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n@@ -90,4 +69,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n+            Asserts.assertTrue(inlineesNormal.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n+            Asserts.assertTrue(inlineesReplay.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n@@ -95,103 +72,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n-        }\n-        remove(LOG_FILE_NORMAL);\n-        remove(LOG_FILE_REPLAY);\n-    }\n-\n-    private void verifyLists(List<Entry> inlineesNormal, List<Entry> inlineesReplay, int expectedSize) {\n-        if (!inlineesNormal.equals(inlineesReplay)) {\n-            System.err.println(\"Normal entries:\");\n-            inlineesNormal.forEach(System.err::println);\n-            System.err.println(\"Replay entries:\");\n-            inlineesReplay.forEach(System.err::println);\n-            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n-        }\n-        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n-    }\n-\n-    public static boolean compare(Entry e, String klass, String method, boolean kind) {\n-        return e.klass.equals(klass) && e.method.equals(method) && kind;\n-    }\n-\n-    public static List<Entry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n-        String nmethodStart = \"<nmethod\";\n-        List<Entry> inlinees = new ArrayList<>();\n-        int foundLines = 0;\n-        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n-            String line;\n-            boolean nmethodLine = false;\n-            boolean inlinineLine = false;\n-            while ((line = br.readLine()) != null) {\n-                if (nmethodLine) {\n-                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n-                    if (line.startsWith(\"             \")) {\n-                        inlinineLine = true;\n-                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n-                        Matcher matcher = p.matcher(line);\n-                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n-                        inlinees.add(new Entry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n-                        foundLines++;\n-                    } else if (inlinineLine) {\n-                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n-                        return inlinees;\n-                    }\n-                } else {\n-                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n-                    if (nmethodLine) {\n-                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n-                    }\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n-        }\n-        Asserts.fail(\"Should have found inlinees\");\n-        return inlinees;\n-    }\n-\n-\n-    @Override\n-    public String getTestClass() {\n-        return \"compiler.ciReplay.\" + className;\n-    }\n-\n-    static class Entry {\n-        String klass;\n-        String method;\n-        String reason;\n-\n-        public Entry(String klass, String method, String reason) {\n-            this.klass = klass;\n-            this.method = method;\n-            this.reason = reason;\n-        }\n-\n-        public boolean isNormalInline() {\n-            return reason.equals(\"inline (hot)\");\n-        }\n-\n-        public boolean isForcedByReplay() {\n-            return reason.equals(\"force inline by ciReplay\");\n-        }\n-\n-        public boolean isDisallowedByReplay() {\n-            return reason.equals(\"disallowed by ciReplay\");\n-        }\n-\n-        public boolean isUnloadedSignatureClasses() {\n-            return reason.equals(\"unloaded signature classes\");\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (other == this) {\n-                return true;\n-            }\n-\n-            if (!(other instanceof Entry)) {\n-                return false;\n-            }\n-\n-            Entry e = (Entry)other;\n-            return klass.equals(e.klass) && method.equals(e.method);\n+            Asserts.assertTrue(inlineesNormal.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n+            Asserts.assertTrue(inlineesReplay.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":18,"deletions":142,"binary":false,"changes":160,"status":"modified"}]}