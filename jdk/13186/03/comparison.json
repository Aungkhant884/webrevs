{"files":[{"patch":"@@ -27,2 +27,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -190,35 +188,0 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    static List<String> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<String> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(descriptor.substring(cur, cur + len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, descriptor.substring(cur, cur + rLen));\n-        return ptypes;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return new MethodTypeDescImpl(returnDesc, ConstantUtils.EMPTY_CLASSDESC);\n+        return new MethodTypeDescImpl(returnDesc, List.of());\n@@ -83,1 +83,1 @@\n-        return of(returnDesc, paramDescs.toArray(ConstantUtils.EMPTY_CLASSDESC));\n+        return new MethodTypeDescImpl(returnDesc, paramDescs);\n@@ -98,1 +98,1 @@\n-        return new MethodTypeDescImpl(returnDesc, paramDescs);\n+        return new MethodTypeDescImpl(returnDesc, List.of(paramDescs));\n@@ -199,5 +199,12 @@\n-        return String.format(\"(%s)%s\",\n-                             Stream.of(parameterArray())\n-                                   .map(ClassDesc::descriptorString)\n-                                   .collect(Collectors.joining()),\n-                             returnType().descriptorString());\n+        int stringLength = 2 \/* () *\/ + returnType().descriptorString().length();\n+        for (var paramType : parameterList()) {\n+            stringLength += paramType.descriptorString().length();\n+        }\n+\n+        var descString = new StringBuilder(stringLength);\n+        descString.append('(');\n+        for (var paramType : parameterList()) {\n+            descString.append(paramType.descriptorString());\n+        }\n+        return descString.append(')')\n+                .append(returnType().descriptorString()).toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -31,1 +35,1 @@\n-import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -35,0 +39,1 @@\n+import static java.lang.constant.ConstantUtils.*;\n@@ -43,0 +48,2 @@\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n@@ -44,1 +51,2 @@\n-    private final ClassDesc[] argTypes;\n+    private final List<ClassDesc> argTypes;\n+    private @Stable String cachedDescriptorString;\n@@ -48,1 +56,2 @@\n-     * and parameter types\n+     * and parameter types. Performs a check over parameter types to ensure their\n+     * validity.\n@@ -51,1 +60,1 @@\n-     * @param argTypes {@link ClassDesc}s describing the parameter types\n+     * @param argTypes a list of {@link ClassDesc}s describing the parameter types\n@@ -53,1 +62,1 @@\n-    MethodTypeDescImpl(ClassDesc returnType, ClassDesc[] argTypes) {\n+    MethodTypeDescImpl(ClassDesc returnType, List<ClassDesc> argTypes) {\n@@ -55,1 +64,1 @@\n-        this.argTypes = requireNonNull(argTypes);\n+        this.argTypes = List.copyOf(argTypes); \/\/ implicit null-check\n@@ -57,2 +66,2 @@\n-        for (ClassDesc cr : argTypes)\n-            if (cr.isPrimitive() && cr.descriptorString().equals(\"V\"))\n+        for (ClassDesc cr : this.argTypes)\n+            if (cr.isPrimitive() && cr.descriptorString().charAt(0) == 'V')\n@@ -72,4 +81,35 @@\n-        requireNonNull(descriptor);\n-        List<String> types = ConstantUtils.parseMethodDescriptor(descriptor);\n-        ClassDesc[] paramTypes = types.stream().skip(1).map(ClassDesc::ofDescriptor).toArray(ClassDesc[]::new);\n-        return new MethodTypeDescImpl(ClassDesc.ofDescriptor(types.get(0)), paramTypes);\n+        int cur = 0, end = descriptor.length(); \/\/ implicit null check\n+\n+        if (end == 0 || descriptor.charAt(0) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        cur++; \/\/ skip '('\n+        if (cur >= end) {\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        }\n+        ArrayList<ClassDesc> ptypes;\n+        if (descriptor.charAt(cur) != ')') {\n+            ptypes = new ArrayList<>();\n+            do {\n+                int len = skipOverFieldSignature(descriptor, cur, end, false);\n+                if (len == 0)\n+                    throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                ptypes.add(ClassDesc.ofDescriptor(descriptor.substring(cur, cur + len)));\n+                cur += len;\n+                if (cur >= end) {\n+                    throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                }\n+            } while (descriptor.charAt(cur) != ')');\n+        } else {\n+            ptypes = null;\n+        }\n+        cur++; \/\/ skip ')'\n+\n+        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n+        if (rLen == 0 || cur + rLen != descriptor.length())\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+\n+        ClassDesc retType = ClassDesc.ofDescriptor(descriptor.substring(cur));\n+        List<ClassDesc> types = ptypes == null ? List.of() : JUCA.listFromTrustedArray(ptypes.toArray());\n+        var ret = new MethodTypeDescImpl(retType, types);\n+        ret.cachedDescriptorString = descriptor;\n+        return ret;\n@@ -85,1 +125,1 @@\n-        return argTypes.length;\n+        return argTypes.size();\n@@ -90,1 +130,1 @@\n-        return argTypes[index];\n+        return argTypes.get(index);\n@@ -95,1 +135,1 @@\n-        return List.of(argTypes);\n+        return argTypes;\n@@ -100,1 +140,1 @@\n-        return argTypes.clone();\n+        return argTypes.toArray(EMPTY_CLASSDESC);\n@@ -105,1 +145,3 @@\n-        return MethodTypeDesc.of(returnType, argTypes);\n+        Objects.requireNonNull(returnType);\n+\n+        return new MethodTypeDescImpl(returnType, argTypes);\n@@ -110,1 +152,4 @@\n-        ClassDesc[] newArgs = argTypes.clone();\n+        Objects.checkIndex(index, argTypes.size());\n+        Objects.requireNonNull(paramType);\n+\n+        Object[] newArgs = argTypes.toArray();\n@@ -112,1 +157,1 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return new MethodTypeDescImpl(returnType, JUCA.listFromTrustedArray(newArgs));\n@@ -117,2 +162,2 @@\n-        Objects.checkIndex(start, argTypes.length);\n-        Objects.checkFromToIndex(start, end, argTypes.length);\n+        Objects.checkFromToIndex(start, end, argTypes.size());\n+        if (start == end) return this;\n@@ -120,1 +165,2 @@\n-        ClassDesc[] newArgs = new ClassDesc[argTypes.length - (end - start)];\n+        ClassDesc[] argTypes = this.argTypes.toArray(EMPTY_CLASSDESC);\n+        Object[] newArgs = new Object[argTypes.length - (end - start)];\n@@ -123,1 +169,1 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return new MethodTypeDescImpl(returnType, JUCA.listFromTrustedArray(newArgs));\n@@ -128,4 +174,5 @@\n-        if (pos < 0 || pos > argTypes.length)\n-            throw new IndexOutOfBoundsException(pos);\n-        ClassDesc[] newArgs = new ClassDesc[argTypes.length + paramTypes.length];\n-        System.arraycopy(argTypes, 0, newArgs, 0, pos);\n+        Objects.checkIndex(pos, argTypes.size() + 1);\n+        if (paramTypes.length == 0) return this; \/\/ Implicit null check\n+\n+        Object[] newArgs = argTypes.toArray(new Object[argTypes.size() + paramTypes.length]);\n+        System.arraycopy(newArgs, pos, newArgs, pos + paramTypes.length, argTypes.size() - pos);\n@@ -133,2 +180,10 @@\n-        System.arraycopy(argTypes, pos, newArgs, pos+paramTypes.length, argTypes.length - pos);\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return new MethodTypeDescImpl(returnType, JUCA.listFromTrustedArray(newArgs));\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        var str = cachedDescriptorString;\n+        if (str != null)\n+            return str;\n+\n+        return cachedDescriptorString = MethodTypeDesc.super.descriptorString();\n@@ -144,1 +199,1 @@\n-                                                             lookup.lookupClass().getClassLoader());\n+                        lookup.lookupClass().getClassLoader());\n@@ -175,1 +230,1 @@\n-               && Arrays.equals(argTypes, constant.argTypes);\n+               && Objects.equals(argTypes, constant.argTypes);\n@@ -181,1 +236,1 @@\n-        result = 31 * result + Arrays.hashCode(argTypes);\n+        result = 31 * result + Objects.hashCode(argTypes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":88,"deletions":33,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.ArrayList;\n@@ -35,2 +36,1 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -39,3 +39,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertThrows;\n-import static org.testng.Assert.fail;\n+import static org.testng.Assert.*;\n@@ -45,0 +43,1 @@\n+ * @bug 8304932\n@@ -118,1 +117,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -120,4 +119,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -147,0 +143,9 @@\n+\n+            \/\/ drop multiple params\n+            for (int j = i; j < paramTypes.length; j++) {\n+                var t = new ArrayList<>(Arrays.asList(paramTypes));\n+                t.subList(i, j).clear();\n+                MethodTypeDesc multiDrop = mtDesc.dropParameterTypes(i, j);\n+                assertEquals(multiDrop, MethodTypeDesc.of(returnType, t.toArray(ClassDesc[]::new)));\n+                testMethodTypeDesc(multiDrop, mt.dropParameterTypes(i, j));\n+            }\n@@ -162,0 +167,15 @@\n+\n+            \/\/ add multiple params\n+            ClassDesc[] addition = {CD_int, CD_String};\n+            var a = new ArrayList<>(Arrays.asList(paramTypes));\n+            a.addAll(i, Arrays.asList(addition));\n+\n+            MethodTypeDesc newDesc = mtDesc.insertParameterTypes(i, addition);\n+            assertEquals(newDesc, MethodTypeDesc.of(returnType, a.toArray(ClassDesc[]::new)));\n+            testMethodTypeDesc(newDesc, mt.insertParameterTypes(i, Arrays.stream(addition).map(d -> {\n+                try {\n+                    return (Class<?>) d.resolveConstantDesc(LOOKUP);\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+            }).toArray(Class[]::new)));\n@@ -172,1 +192,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -174,4 +194,1 @@\n-            fail(\"pos < 0 should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -179,1 +196,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -181,4 +198,1 @@\n-            fail(\"pos > current arguments length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -186,1 +200,1 @@\n-        try {\n+        expectThrows(IllegalArgumentException.class, () -> {\n@@ -191,4 +205,1 @@\n-            fail(\"shouldn't allow parameters with class descriptor CD_void\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -196,1 +207,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -199,4 +210,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -204,1 +212,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -209,4 +217,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -220,1 +225,2 @@\n-        try {\n+\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -222,4 +228,1 @@\n-            fail(\"start index < 0 should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -227,1 +230,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -229,4 +232,1 @@\n-            fail(\"start index = arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -234,1 +234,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -236,4 +236,1 @@\n-            fail(\"start index > arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -241,1 +238,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -243,4 +240,1 @@\n-            fail(\"end index > arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -248,1 +242,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -250,4 +244,1 @@\n-            fail(\"start index > end index should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -277,0 +268,1 @@\n+\n@@ -285,2 +277,0 @@\n-        \/\/ try with void arguments, this will stress another code path in particular\n-        \/\/ ConstantMethodTypeDesc::init\n@@ -294,0 +284,23 @@\n+\n+    public void testOfArrayImmutability() {\n+        ClassDesc[] args = {CD_Object, CD_int};\n+        var mtd = MethodTypeDesc.of(CD_void, args);\n+\n+        args[1] = CD_void;\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+\n+        mtd.parameterArray()[1] = CD_void;\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+    }\n+\n+    public void testOfListImmutability() {\n+        List<ClassDesc> args = Arrays.asList(CD_Object, CD_int);\n+        var mtd = MethodTypeDesc.of(CD_void, args);\n+\n+        args.set(1, CD_void);\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                mtd.parameterList().set(1, CD_void));\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+    }\n","filename":"test\/jdk\/java\/lang\/constant\/MethodTypeDescTest.java","additions":75,"deletions":62,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Performance of different MethodTypeDesc factory methods\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class MethodTypeDescConstruct {\n+    public enum Kind {\n+        GENERIC(CD_Object, CD_Object, CD_Object),\n+        VOID(CD_void),\n+        NO_PARAM(CD_Class.arrayType()),\n+        ARBITRARY(CD_int, CD_String, CD_String.arrayType(), CD_double.arrayType());\n+\n+        final String desc;\n+        final ClassDesc ret;\n+        final ClassDesc[] args;\n+        final List<ClassDesc> argsList;\n+\n+        Kind(ClassDesc ret, ClassDesc... args) {\n+            this.desc = MethodTypeDesc.of(ret, args).descriptorString();\n+            this.ret = ret;\n+            this.args = args;\n+            this.argsList = List.of(args);\n+        }\n+    }\n+\n+    @Param\n+    public Kind kind;\n+\n+    @Benchmark\n+    public MethodTypeDesc ofDescriptorBench() {\n+        return MethodTypeDesc.ofDescriptor(kind.desc);\n+    }\n+\n+    @Benchmark\n+    public MethodTypeDesc ofArrayBench() {\n+        return MethodTypeDesc.of(kind.ret, kind.args);\n+    }\n+\n+    @Benchmark\n+    public MethodTypeDesc ofListBench() {\n+        return MethodTypeDesc.of(kind.ret, kind.argsList);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescConstruct.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Performance of computing a fresh method type descriptor string from a\n+ * descriptor symbol.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class MethodTypeDescDescriptor {\n+\n+    @Param({\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/String;)I\",\n+            \"()V\",\n+            \"([IJLjava\/lang\/String;Z)Ljava\/util\/List;\",\n+            \"()[Ljava\/lang\/String;\"\n+    })\n+    public String descString;\n+    public MethodTypeDesc desc;\n+\n+    @Setup\n+    public void setup() {\n+        desc = MethodTypeDesc.ofDescriptor(descString);\n+    }\n+\n+    @Benchmark\n+    public String computeDescriptorString(Blackhole blackhole) {\n+        var mtd = MethodTypeDesc.of(desc.returnType(), desc.parameterList());\n+        blackhole.consume(mtd);\n+        return mtd.descriptorString();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescDescriptor.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}