{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.util.Arrays;\n@@ -166,3 +167,6 @@\n-            } else if (value.length != fixedKeySize) {\n-                throw new InvalidKeyException(\"The key must be \" +\n-                    fixedKeySize + \" bytes\");\n+            } else {\n+                Arrays.fill(value, (byte)0);\n+                if (value.length != fixedKeySize) {\n+                    throw new InvalidKeyException(\"The key must be \" +\n+                            fixedKeySize + \" bytes\");\n+                }\n@@ -518,0 +522,1 @@\n+        Arrays.fill(encoded, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,3 @@\n+            if (lastKey != null) {\n+                Arrays.fill(lastKey, (byte)0);\n+            }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCrypt.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,1 +201,6 @@\n-        cipher.init(decrypting, key.getAlgorithm(), key.getEncoded());\n+        byte[] encoded = key.getEncoded();\n+        try {\n+            cipher.init(decrypting, key.getAlgorithm(), encoded);\n+        } finally {\n+            Arrays.fill(encoded, (byte)0);\n+        }\n@@ -377,0 +382,1 @@\n+        Arrays.fill(encoded, (byte)0);\n@@ -407,1 +413,2 @@\n-        byte[] out = new byte[Math.addExact(keyVal.length, 8)];\n+        try {\n+            byte[] out = new byte[Math.addExact(keyVal.length, 8)];\n@@ -409,23 +416,26 @@\n-        if (keyVal.length == 8) {\n-            System.arraycopy(IV, 0, out, 0, IV.length);\n-            System.arraycopy(keyVal, 0, out, IV.length, 8);\n-            cipher.encryptBlock(out, 0, out, 0);\n-        } else {\n-            if (keyVal.length % 8 != 0) {\n-                throw new IllegalBlockSizeException(\"length of the \" +\n-                    \"to be wrapped key should be multiples of 8 bytes\");\n-            }\n-            System.arraycopy(IV, 0, out, 0, IV.length);\n-            System.arraycopy(keyVal, 0, out, IV.length, keyVal.length);\n-            int N = keyVal.length\/8;\n-            byte[] buffer = new byte[blksize];\n-            for (int j = 0; j < 6; j++) {\n-                for (int i = 1; i <= N; i++) {\n-                    int T = i + j*N;\n-                    System.arraycopy(out, 0, buffer, 0, IV.length);\n-                    System.arraycopy(out, i*8, buffer, IV.length, 8);\n-                    cipher.encryptBlock(buffer, 0, buffer, 0);\n-                    for (int k = 1; T != 0; k++) {\n-                        byte v = (byte) T;\n-                        buffer[IV.length - k] ^= v;\n-                        T >>>= 8;\n+            if (keyVal.length == 8) {\n+                System.arraycopy(IV, 0, out, 0, IV.length);\n+                System.arraycopy(keyVal, 0, out, IV.length, 8);\n+                cipher.encryptBlock(out, 0, out, 0);\n+            } else {\n+                if (keyVal.length % 8 != 0) {\n+                    throw new IllegalBlockSizeException(\"length of the \" +\n+                            \"to be wrapped key should be multiples of 8 bytes\");\n+                }\n+                System.arraycopy(IV, 0, out, 0, IV.length);\n+                System.arraycopy(keyVal, 0, out, IV.length, keyVal.length);\n+                int N = keyVal.length \/ 8;\n+                byte[] buffer = new byte[blksize];\n+                for (int j = 0; j < 6; j++) {\n+                    for (int i = 1; i <= N; i++) {\n+                        int T = i + j * N;\n+                        System.arraycopy(out, 0, buffer, 0, IV.length);\n+                        System.arraycopy(out, i * 8, buffer, IV.length, 8);\n+                        cipher.encryptBlock(buffer, 0, buffer, 0);\n+                        for (int k = 1; T != 0; k++) {\n+                            byte v = (byte) T;\n+                            buffer[IV.length - k] ^= v;\n+                            T >>>= 8;\n+                        }\n+                        System.arraycopy(buffer, 0, out, 0, IV.length);\n+                        System.arraycopy(buffer, 8, out, 8 * i, 8);\n@@ -433,2 +443,0 @@\n-                    System.arraycopy(buffer, 0, out, 0, IV.length);\n-                    System.arraycopy(buffer, 8, out, 8*i, 8);\n@@ -437,0 +445,3 @@\n+            return out;\n+        } finally {\n+            Arrays.fill(keyVal, (byte)0);\n@@ -438,1 +449,0 @@\n-        return out;\n@@ -477,5 +487,7 @@\n-        if (wrappedKeyLen == 16) {\n-            cipher.decryptBlock(wrappedKey, 0, buffer, 0);\n-            for (int i = 0; i < IV.length; i++) {\n-                if (IV[i] != buffer[i]) {\n-                    throw new InvalidKeyException(\"Integrity check failed\");\n+        try {\n+            if (wrappedKeyLen == 16) {\n+                cipher.decryptBlock(wrappedKey, 0, buffer, 0);\n+                for (int i = 0; i < IV.length; i++) {\n+                    if (IV[i] != buffer[i]) {\n+                        throw new InvalidKeyException(\"Integrity check failed\");\n+                    }\n@@ -483,14 +495,16 @@\n-            }\n-            System.arraycopy(buffer, IV.length, out, 0, out.length);\n-        } else {\n-            System.arraycopy(wrappedKey, 0, buffer, 0, IV.length);\n-            System.arraycopy(wrappedKey, IV.length, out, 0, out.length);\n-            int N = out.length\/8;\n-            for (int j = 5; j >= 0; j--) {\n-                for (int i = N; i > 0; i--) {\n-                    int T = i + j*N;\n-                    System.arraycopy(out, 8*(i-1), buffer, IV.length, 8);\n-                    for (int k = 1; T != 0; k++) {\n-                        byte v = (byte) T;\n-                        buffer[IV.length - k] ^= v;\n-                        T >>>= 8;\n+                System.arraycopy(buffer, IV.length, out, 0, out.length);\n+            } else {\n+                System.arraycopy(wrappedKey, 0, buffer, 0, IV.length);\n+                System.arraycopy(wrappedKey, IV.length, out, 0, out.length);\n+                int N = out.length \/ 8;\n+                for (int j = 5; j >= 0; j--) {\n+                    for (int i = N; i > 0; i--) {\n+                        int T = i + j * N;\n+                        System.arraycopy(out, 8 * (i - 1), buffer, IV.length, 8);\n+                        for (int k = 1; T != 0; k++) {\n+                            byte v = (byte) T;\n+                            buffer[IV.length - k] ^= v;\n+                            T >>>= 8;\n+                        }\n+                        cipher.decryptBlock(buffer, 0, buffer, 0);\n+                        System.arraycopy(buffer, IV.length, out, 8 * (i - 1), 8);\n@@ -498,2 +512,0 @@\n-                    cipher.decryptBlock(buffer, 0, buffer, 0);\n-                    System.arraycopy(buffer, IV.length, out, 8*(i-1), 8);\n@@ -501,4 +513,4 @@\n-            }\n-            for (int i = 0; i < IV.length; i++) {\n-                if (IV[i] != buffer[i]) {\n-                    throw new InvalidKeyException(\"Integrity check failed\");\n+                for (int i = 0; i < IV.length; i++) {\n+                    if (IV[i] != buffer[i]) {\n+                        throw new InvalidKeyException(\"Integrity check failed\");\n+                    }\n@@ -507,0 +519,5 @@\n+            return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n+                    wrappedKeyType);\n+        } finally {\n+            Arrays.fill(out, (byte)0);\n+            Arrays.fill(buffer, (byte)0);\n@@ -508,2 +525,0 @@\n-        return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESWrapCipher.java","additions":71,"deletions":56,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Arrays;\n@@ -183,0 +184,3 @@\n+        if (lastKey != null) {\n+            Arrays.fill(lastKey, (byte)0);\n+        }\n@@ -202,0 +206,1 @@\n+            Arrays.fill(encodedKey, (byte)0);\n@@ -247,1 +252,5 @@\n-        return engineDoFinal(encoded, 0, encoded.length);\n+        try {\n+            return engineDoFinal(encoded, 0, encoded.length);\n+        } finally {\n+            Arrays.fill(encoded, (byte)0);\n+        }\n@@ -253,2 +262,9 @@\n-        byte[] encoded = engineDoFinal(wrappedKey, 0, wrappedKey.length);\n-        return ConstructKeys.constructKey(encoded, algorithm, type);\n+        byte[] encoded = null;\n+        try {\n+            encoded = engineDoFinal(wrappedKey, 0, wrappedKey.length);\n+            return ConstructKeys.constructKey(encoded, algorithm, type);\n+        } finally {\n+            if (encoded != null) {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n+        }\n@@ -260,0 +276,1 @@\n+        Arrays.fill(encodedKey, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ARCFOURCipher.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.util.Arrays;\n+\n@@ -376,1 +378,3 @@\n-        return Math.multiplyExact(key.getEncoded().length, 8);\n+        byte[] encodedKey = key.getEncoded();\n+        Arrays.fill(encodedKey, (byte)0);\n+        return Math.multiplyExact(encodedKey.length, 8);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/BlowfishCipher.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -549,0 +550,3 @@\n+        if (this.keyBytes != null) {\n+            Arrays.fill(this.keyBytes, (byte)0);\n+        }\n@@ -615,0 +619,3 @@\n+            if (encodedKey != null) {\n+                Arrays.fill(encodedKey, (byte)0);\n+            }\n@@ -793,0 +800,1 @@\n+        Arrays.fill(encodedKey, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,7 +507,15 @@\n-        int tagLen = -1;\n-        byte[] ivBytes = null;\n-        if (params != null) {\n-            if (cipherMode == GCM_MODE) {\n-                if (params instanceof GCMParameterSpec) {\n-                    tagLen = ((GCMParameterSpec)params).getTLen();\n-                    if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n+        try {\n+            int tagLen = -1;\n+            byte[] ivBytes = null;\n+            if (params != null) {\n+                if (cipherMode == GCM_MODE) {\n+                    if (params instanceof GCMParameterSpec) {\n+                        tagLen = ((GCMParameterSpec) params).getTLen();\n+                        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n+                            throw new InvalidAlgorithmParameterException\n+                                    (\"Unsupported TLen value; must be one of \" +\n+                                            \"{128, 120, 112, 104, 96}\");\n+                        }\n+                        tagLen = tagLen >> 3;\n+                        ivBytes = ((GCMParameterSpec) params).getIV();\n+                    } else {\n@@ -515,2 +523,1 @@\n-                            (\"Unsupported TLen value; must be one of \" +\n-                             \"{128, 120, 112, 104, 96}\");\n+                                (\"Unsupported parameter: \" + params);\n@@ -518,2 +525,0 @@\n-                    tagLen = tagLen >> 3;\n-                    ivBytes = ((GCMParameterSpec)params).getIV();\n@@ -521,14 +526,15 @@\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Unsupported parameter: \" + params);\n-               }\n-            } else {\n-                if (params instanceof IvParameterSpec) {\n-                    ivBytes = ((IvParameterSpec)params).getIV();\n-                    if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n-                        throw new InvalidAlgorithmParameterException\n-                            (\"Wrong IV length: must be \" + blockSize +\n-                             \" bytes long\");\n-                    }\n-                } else if (params instanceof RC2ParameterSpec) {\n-                    ivBytes = ((RC2ParameterSpec)params).getIV();\n-                    if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n+                    if (params instanceof IvParameterSpec) {\n+                        ivBytes = ((IvParameterSpec) params).getIV();\n+                        if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n+                            throw new InvalidAlgorithmParameterException\n+                                    (\"Wrong IV length: must be \" + blockSize +\n+                                            \" bytes long\");\n+                        }\n+                    } else if (params instanceof RC2ParameterSpec) {\n+                        ivBytes = ((RC2ParameterSpec) params).getIV();\n+                        if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n+                            throw new InvalidAlgorithmParameterException\n+                                    (\"Wrong IV length: must be \" + blockSize +\n+                                            \" bytes long\");\n+                        }\n+                    } else {\n@@ -536,2 +542,1 @@\n-                            (\"Wrong IV length: must be \" + blockSize +\n-                             \" bytes long\");\n+                                (\"Unsupported parameter: \" + params);\n@@ -539,3 +544,0 @@\n-                } else {\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Unsupported parameter: \" + params);\n@@ -544,11 +546,10 @@\n-        }\n-        if (cipherMode == ECB_MODE) {\n-            if (ivBytes != null) {\n-                throw new InvalidAlgorithmParameterException\n-                                                (\"ECB mode cannot use IV\");\n-            }\n-        } else if (ivBytes == null)  {\n-            if (decrypting) {\n-                throw new InvalidAlgorithmParameterException(\"Parameters \"\n-                                                             + \"missing\");\n-            }\n+            if (cipherMode == ECB_MODE) {\n+                if (ivBytes != null) {\n+                    throw new InvalidAlgorithmParameterException\n+                            (\"ECB mode cannot use IV\");\n+                }\n+            } else if (ivBytes == null) {\n+                if (decrypting) {\n+                    throw new InvalidAlgorithmParameterException(\"Parameters \"\n+                            + \"missing\");\n+                }\n@@ -556,7 +557,9 @@\n-            if (random == null) {\n-                random = SunJCE.getRandom();\n-            }\n-            if (cipherMode == GCM_MODE) {\n-                ivBytes = new byte[GaloisCounterMode.DEFAULT_IV_LEN];\n-            } else {\n-                ivBytes = new byte[blockSize];\n+                if (random == null) {\n+                    random = SunJCE.getRandom();\n+                }\n+                if (cipherMode == GCM_MODE) {\n+                    ivBytes = new byte[GaloisCounterMode.DEFAULT_IV_LEN];\n+                } else {\n+                    ivBytes = new byte[blockSize];\n+                }\n+                random.nextBytes(ivBytes);\n@@ -564,2 +567,0 @@\n-            random.nextBytes(ivBytes);\n-        }\n@@ -567,2 +568,2 @@\n-        buffered = 0;\n-        diffBlocksize = blockSize;\n+            buffered = 0;\n+            diffBlocksize = blockSize;\n@@ -570,1 +571,1 @@\n-        String algorithm = key.getAlgorithm();\n+            String algorithm = key.getAlgorithm();\n@@ -572,15 +573,4 @@\n-        \/\/ GCM mode needs additional handling\n-        if (cipherMode == GCM_MODE) {\n-            if(tagLen == -1) {\n-                tagLen = GaloisCounterMode.DEFAULT_TAG_LEN;\n-            }\n-            if (decrypting) {\n-                minBytes = tagLen;\n-            } else {\n-                \/\/ check key+iv for encryption in GCM mode\n-                requireReinit =\n-                    Arrays.equals(ivBytes, lastEncIv) &&\n-                    MessageDigest.isEqual(keyBytes, lastEncKey);\n-                if (requireReinit) {\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Cannot reuse iv for GCM encryption\");\n+            \/\/ GCM mode needs additional handling\n+            if (cipherMode == GCM_MODE) {\n+                if (tagLen == -1) {\n+                    tagLen = GaloisCounterMode.DEFAULT_TAG_LEN;\n@@ -588,2 +578,27 @@\n-                lastEncIv = ivBytes;\n-                lastEncKey = keyBytes;\n+                if (decrypting) {\n+                    minBytes = tagLen;\n+                } else {\n+                    \/\/ check key+iv for encryption in GCM mode\n+                    requireReinit =\n+                            Arrays.equals(ivBytes, lastEncIv) &&\n+                                    MessageDigest.isEqual(keyBytes, lastEncKey);\n+                    if (requireReinit) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Cannot reuse iv for GCM encryption\");\n+                    }\n+                    lastEncIv = ivBytes;\n+                    if (lastEncKey != null) {\n+                        Arrays.fill(lastEncKey, (byte) 0);\n+                    }\n+                    lastEncKey = keyBytes;\n+                }\n+                ((GaloisCounterMode) cipher).init\n+                        (decrypting, algorithm, keyBytes, ivBytes, tagLen);\n+            } else {\n+                cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n+            }\n+            \/\/ skip checking key+iv from now on until after doFinal()\n+            requireReinit = false;\n+        } finally {\n+            if (lastEncKey != keyBytes) {\n+                Arrays.fill(keyBytes, (byte) 0);\n@@ -591,4 +606,0 @@\n-            ((GaloisCounterMode) cipher).init\n-                (decrypting, algorithm, keyBytes, ivBytes, tagLen);\n-        } else {\n-            cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n@@ -596,2 +607,0 @@\n-        \/\/ skip checking key+iv from now on until after doFinal()\n-        requireReinit = false;\n@@ -1159,1 +1168,5 @@\n-            result = doFinal(encodedKey, 0, encodedKey.length);\n+            try {\n+                result = doFinal(encodedKey, 0, encodedKey.length);\n+            } finally {\n+                Arrays.fill(encodedKey, (byte)0);\n+            }\n@@ -1200,2 +1213,6 @@\n-        return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n+        try {\n+            return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n+                    wrappedKeyType);\n+        } finally {\n+            Arrays.fill(encodedKey, (byte)0);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":97,"deletions":80,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -1,259 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.KeyFactory;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchProviderException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-import java.security.spec.InvalidKeySpecException;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.CipherSpi;\n-import javax.crypto.SecretKey;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.spec.SecretKeySpec;\n-\n-\/**\n- * This class entends the javax.crypto.CipherSpi class with a concrete\n- * implementation of the methods for wrapping and unwrapping\n- * keys.\n- *\n- * @author Sharon Liu\n- *\n- *\n- * @see javax.crypto.CipherSpi\n- * @see BlowfishCipher\n- * @see DESCipher\n- * @see PBEWithMD5AndDESCipher\n- *\/\n-\n-public abstract class CipherWithWrappingSpi extends CipherSpi {\n-\n-    \/**\n-     * Wrap a key.\n-     *\n-     * @param key the key to be wrapped.\n-     *\n-     * @return the wrapped key.\n-     *\n-     * @exception IllegalBlockSizeException if this cipher is a block\n-     * cipher, no padding has been requested, and the length of the\n-     * encoding of the key to be wrapped is not a\n-     * multiple of the block size.\n-     *\n-     * @exception InvalidKeyException if it is impossible or unsafe to\n-     * wrap the key with this cipher (e.g., a hardware protected key is\n-     * being passed to a software only cipher).\n-     *\/\n-    protected final byte[] engineWrap(Key key)\n-        throws IllegalBlockSizeException, InvalidKeyException\n-    {\n-        byte[] result = null;\n-\n-        try {\n-            byte[] encodedKey = key.getEncoded();\n-            if ((encodedKey == null) || (encodedKey.length == 0)) {\n-                throw new InvalidKeyException(\"Cannot get an encoding of \" +\n-                                              \"the key to be wrapped\");\n-            }\n-\n-            result = engineDoFinal(encodedKey, 0, encodedKey.length);\n-        } catch (BadPaddingException e) {\n-            \/\/ Should never happen\n-        }\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Unwrap a previously wrapped key.\n-     *\n-     * @param wrappedKey the key to be unwrapped.\n-     *\n-     * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.\n-     *\n-     * @param wrappedKeyType the type of the wrapped key.\n-     * This is one of <code>Cipher.SECRET_KEY<\/code>,\n-     * <code>Cipher.PRIVATE_KEY<\/code>, or <code>Cipher.PUBLIC_KEY<\/code>.\n-     *\n-     * @return the unwrapped key.\n-     *\n-     * @exception InvalidKeyException if <code>wrappedKey<\/code> does not\n-     * represent a wrapped key, or if the algorithm associated with the\n-     * wrapped key is different from <code>wrappedKeyAlgorithm<\/code>\n-     * and\/or its key type is different from <code>wrappedKeyType<\/code>.\n-     *\n-     * @exception NoSuchAlgorithmException if no installed providers\n-     * can create keys for the <code>wrappedKeyAlgorithm<\/code>.\n-     *\/\n-    protected final Key engineUnwrap(byte[] wrappedKey,\n-                                     String wrappedKeyAlgorithm,\n-                                     int wrappedKeyType)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n-        byte[] encodedKey;\n-        Key result = null;\n-\n-        try {\n-            encodedKey = engineDoFinal(wrappedKey, 0,\n-                                       wrappedKey.length);\n-        } catch (BadPaddingException ePadding) {\n-            throw new InvalidKeyException();\n-        } catch (IllegalBlockSizeException eBlockSize) {\n-            throw new InvalidKeyException();\n-        }\n-\n-        switch (wrappedKeyType) {\n-        case Cipher.SECRET_KEY:\n-            result = constructSecretKey(encodedKey,\n-                                        wrappedKeyAlgorithm);\n-            break;\n-        case Cipher.PRIVATE_KEY:\n-            result = constructPrivateKey(encodedKey,\n-                                         wrappedKeyAlgorithm);\n-            break;\n-        case Cipher.PUBLIC_KEY:\n-            result = constructPublicKey(encodedKey,\n-                                        wrappedKeyAlgorithm);\n-            break;\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    \/**\n-     * Construct a public key from its encoding.\n-     *\n-     * @param encodedKey the encoding of a public key.\n-     *\n-     * @param encodedKeyAlgorithm the algorithm the encodedKey is for.\n-     *\n-     * @return a public key constructed from the encodedKey.\n-     *\/\n-    private final PublicKey constructPublicKey(byte[] encodedKey,\n-                                               String encodedKeyAlgorithm)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n-        PublicKey key = null;\n-\n-        try {\n-            KeyFactory keyFactory =\n-                KeyFactory.getInstance(encodedKeyAlgorithm,\n-                    SunJCE.getInstance());\n-            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);\n-            key = keyFactory.generatePublic(keySpec);\n-        } catch (NoSuchAlgorithmException nsae) {\n-            \/\/ Try to see whether there is another\n-            \/\/ provider which supports this algorithm\n-            try {\n-                KeyFactory keyFactory =\n-                    KeyFactory.getInstance(encodedKeyAlgorithm);\n-                X509EncodedKeySpec keySpec =\n-                    new X509EncodedKeySpec(encodedKey);\n-                key = keyFactory.generatePublic(keySpec);\n-            } catch (NoSuchAlgorithmException nsae2) {\n-                throw new NoSuchAlgorithmException(\"No installed providers \" +\n-                                                   \"can create keys for the \" +\n-                                                   encodedKeyAlgorithm +\n-                                                   \"algorithm\");\n-            } catch (InvalidKeySpecException ikse2) {\n-                \/\/ Should never happen.\n-            }\n-        } catch (InvalidKeySpecException ikse) {\n-            \/\/ Should never happen.\n-        }\n-\n-        return key;\n-    }\n-\n-    \/**\n-     * Construct a private key from its encoding.\n-     *\n-     * @param encodedKey the encoding of a private key.\n-     *\n-     * @param encodedKeyAlgorithm the algorithm the wrapped key is for.\n-     *\n-     * @return a private key constructed from the encodedKey.\n-     *\/\n-    private final PrivateKey constructPrivateKey(byte[] encodedKey,\n-                                                 String encodedKeyAlgorithm)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n-        PrivateKey key = null;\n-\n-        try {\n-            KeyFactory keyFactory =\n-                KeyFactory.getInstance(encodedKeyAlgorithm,\n-                    SunJCE.getInstance());\n-            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);\n-            return keyFactory.generatePrivate(keySpec);\n-        } catch (NoSuchAlgorithmException nsae) {\n-            \/\/ Try to see whether there is another\n-            \/\/ provider which supports this algorithm\n-            try {\n-                KeyFactory keyFactory =\n-                    KeyFactory.getInstance(encodedKeyAlgorithm);\n-                PKCS8EncodedKeySpec keySpec =\n-                    new PKCS8EncodedKeySpec(encodedKey);\n-                key = keyFactory.generatePrivate(keySpec);\n-            } catch (NoSuchAlgorithmException nsae2) {\n-                throw new NoSuchAlgorithmException(\"No installed providers \" +\n-                                                   \"can create keys for the \" +\n-                                                   encodedKeyAlgorithm +\n-                                                   \"algorithm\");\n-            } catch (InvalidKeySpecException ikse2) {\n-                \/\/ Should never happen.\n-            }\n-        } catch (InvalidKeySpecException ikse) {\n-            \/\/ Should never happen.\n-        }\n-\n-        return key;\n-    }\n-\n-    \/**\n-     * Construct a secret key from its encoding.\n-     *\n-     * @param encodedKey the encoding of a secret key.\n-     *\n-     * @param encodedKeyAlgorithm the algorithm the secret key is for.\n-     *\n-     * @return a secret key constructed from the encodedKey.\n-     *\/\n-    private final SecretKey constructSecretKey(byte[] encodedKey,\n-                                               String encodedKeyAlgorithm)\n-    {\n-        return (new SecretKeySpec(encodedKey, encodedKeyAlgorithm));\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherWithWrappingSpi.java","additions":0,"deletions":259,"binary":false,"changes":259,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -116,1 +118,1 @@\n-\n+        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);\n@@ -121,1 +123,0 @@\n-            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);\n@@ -129,2 +130,0 @@\n-                PKCS8EncodedKeySpec keySpec =\n-                    new PKCS8EncodedKeySpec(encodedKey);\n@@ -148,0 +147,2 @@\n+        } finally {\n+            SharedSecrets.getJavaSecuritySpecAccess().clearEncodedKeySpec(keySpec);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ConstructKeys.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Arrays;\n@@ -372,0 +373,1 @@\n+        Arrays.fill(encoded, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESCipher.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-                        getEncoded());\n+                        key);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -66,0 +67,1 @@\n+            byte[] encoded;\n@@ -67,1 +69,6 @@\n-                return new DESKey(((DESKeySpec)keySpec).getKey());\n+                encoded = ((DESKeySpec)keySpec).getKey();\n+            } else if (keySpec instanceof SecretKeySpec) {\n+                encoded = ((SecretKeySpec)keySpec).getEncoded();\n+            } else {\n+                throw new InvalidKeySpecException(\n+                        \"Inappropriate key specification\");\n@@ -69,3 +76,4 @@\n-\n-            if (keySpec instanceof SecretKeySpec) {\n-                return new DESKey(((SecretKeySpec)keySpec).getEncoded());\n+            try {\n+                return new DESKey(encoded);\n+            } finally {\n+                Arrays.fill(encoded, (byte)0);\n@@ -73,4 +81,0 @@\n-\n-            throw new InvalidKeySpecException(\n-                    \"Inappropriate key specification\");\n-\n@@ -109,3 +113,9 @@\n-                    DESKeySpec.class.isAssignableFrom(keySpec)) {\n-                    return new DESKeySpec(key.getEncoded());\n-\n+                        DESKeySpec.class.isAssignableFrom(keySpec)) {\n+                    byte[] encoded = key.getEncoded();\n+                    try {\n+                        return new DESKeySpec(encoded);\n+                    } finally {\n+                        if (encoded != null) {\n+                            Arrays.fill(encoded, (byte) 0);\n+                        }\n+                    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKeyFactory.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Arrays;\n@@ -369,0 +370,1 @@\n+        Arrays.fill(encoded, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeCipher.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Arrays;\n@@ -159,3 +160,3 @@\n-                        getAlgorithm(),\n-                        getFormat(),\n-                        getEncoded());\n+                getAlgorithm(),\n+                getFormat(),\n+                key);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKey.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -66,0 +67,1 @@\n+            byte[] encoded;\n@@ -67,1 +69,6 @@\n-                return new DESedeKey(((DESedeKeySpec)keySpec).getKey());\n+                encoded = ((DESedeKeySpec)keySpec).getKey();\n+            } else if (keySpec instanceof SecretKeySpec) {\n+                encoded = ((SecretKeySpec)keySpec).getEncoded();\n+            } else {\n+                throw new InvalidKeySpecException\n+                        (\"Inappropriate key specification\");\n@@ -69,3 +76,4 @@\n-            if (keySpec instanceof SecretKeySpec) {\n-                return new DESedeKey(((SecretKeySpec)keySpec).getEncoded());\n-\n+            try {\n+                return new DESedeKey(encoded);\n+            } finally {\n+                Arrays.fill(encoded, (byte)0);\n@@ -73,2 +81,0 @@\n-            throw new InvalidKeySpecException\n-                (\"Inappropriate key specification\");\n@@ -106,2 +112,8 @@\n-                    return new DESedeKeySpec(key.getEncoded());\n-\n+                    byte[] encoded = key.getEncoded();\n+                    try {\n+                        return new DESedeKeySpec(encoded);\n+                    } finally {\n+                        if (encoded != null) {\n+                            Arrays.fill(encoded, (byte) 0);\n+                        }\n+                    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKeyFactory.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Arrays;\n@@ -244,2 +245,8 @@\n-        cipher.init(decrypting, key.getAlgorithm(), key.getEncoded(),\n-                    currIv);\n+        byte[] encoded = key.getEncoded();\n+        try {\n+            cipher.init(decrypting, key.getAlgorithm(), encoded, currIv);\n+        } finally {\n+            if (encoded != null) {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n+        }\n@@ -419,0 +426,1 @@\n+        Arrays.fill(encoded, (byte)0);\n@@ -451,1 +459,0 @@\n-        byte[] cks = getChecksum(keyVal);\n@@ -453,3 +460,1 @@\n-        System.arraycopy(keyVal, 0, in, 0, keyVal.length);\n-        System.arraycopy(cks, 0, in, keyVal.length, CHECKSUM_LEN);\n-\n+        byte[] cipherKeyEncoded = cipherKey.getEncoded();\n@@ -457,1 +462,4 @@\n-        System.arraycopy(iv, 0, out, 0, iv.length);\n+        try {\n+            byte[] cks = getChecksum(keyVal);\n+            System.arraycopy(keyVal, 0, in, 0, keyVal.length);\n+            System.arraycopy(cks, 0, in, keyVal.length, CHECKSUM_LEN);\n@@ -459,1 +467,1 @@\n-        cipher.encrypt(in, 0, in.length, out, iv.length);\n+            System.arraycopy(iv, 0, out, 0, iv.length);\n@@ -461,18 +469,1 @@\n-        \/\/ reverse the array content\n-        for (int i = 0; i < out.length\/2; i++) {\n-            byte temp = out[i];\n-            out[i] = out[out.length-1-i];\n-            out[out.length-1-i] = temp;\n-        }\n-        try {\n-            cipher.init(false, cipherKey.getAlgorithm(),\n-                        cipherKey.getEncoded(), IV2);\n-        } catch (InvalidKeyException ike) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"Internal cipher key is corrupted\");\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"Internal cipher IV is invalid\");\n-        }\n-        byte[] out2 = new byte[out.length];\n-        cipher.encrypt(out, 0, out.length, out2, 0);\n+            cipher.encrypt(in, 0, in.length, out, iv.length);\n@@ -480,10 +471,38 @@\n-        \/\/ restore cipher state to prior to this call\n-        try {\n-            cipher.init(decrypting, cipherKey.getAlgorithm(),\n-                        cipherKey.getEncoded(), iv);\n-        } catch (InvalidKeyException ike) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"Internal cipher key is corrupted\");\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"Internal cipher IV is invalid\");\n+            \/\/ reverse the array content\n+            for (int i = 0; i < out.length \/ 2; i++) {\n+                byte temp = out[i];\n+                out[i] = out[out.length - 1 - i];\n+                out[out.length - 1 - i] = temp;\n+            }\n+            try {\n+                cipher.init(false, cipherKey.getAlgorithm(),\n+                        cipherKeyEncoded, IV2);\n+            } catch (InvalidKeyException ike) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"Internal cipher key is corrupted\");\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"Internal cipher IV is invalid\");\n+            }\n+            byte[] out2 = new byte[out.length];\n+            cipher.encrypt(out, 0, out.length, out2, 0);\n+\n+            \/\/ restore cipher state to prior to this call\n+            try {\n+                cipher.init(decrypting, cipherKey.getAlgorithm(),\n+                        cipherKeyEncoded, iv);\n+            } catch (InvalidKeyException ike) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"Internal cipher key is corrupted\");\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"Internal cipher IV is invalid\");\n+            }\n+            return out2;\n+        } finally {\n+            Arrays.fill(keyVal, (byte)0);\n+            Arrays.fill(in, (byte)0);\n+            Arrays.fill(out, (byte)0);\n+            if (cipherKeyEncoded != null) {\n+                Arrays.fill(cipherKeyEncoded, (byte) 0);\n+            }\n@@ -491,1 +510,0 @@\n-        return out2;\n@@ -533,6 +551,2 @@\n-        try {\n-            cipher.init(true, cipherKey.getAlgorithm(), cipherKey.getEncoded(),\n-                    iv);\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            throw new InvalidKeyException(\"IV in wrapped key is invalid\");\n-        }\n+        byte[] cipherKeyEncoded = cipherKey.getEncoded();\n+        byte[] out = null;\n@@ -540,11 +554,0 @@\n-        cipher.decrypt(buffer, iv.length, buffer2.length,\n-                       buffer2, 0);\n-        int keyValLen = buffer2.length - CHECKSUM_LEN;\n-        byte[] cks = getChecksum(buffer2, 0, keyValLen);\n-        int offset = keyValLen;\n-        for (int i = 0; i < CHECKSUM_LEN; i++) {\n-            if (buffer2[offset + i] != cks[i]) {\n-                throw new InvalidKeyException(\"Checksum comparison failed\");\n-            }\n-        }\n-        \/\/ restore cipher state to prior to this call\n@@ -552,4 +555,35 @@\n-          cipher.init(decrypting, cipherKey.getAlgorithm(),\n-                    cipherKey.getEncoded(), IV2);\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            throw new InvalidKeyException(\"IV in wrapped key is invalid\");\n+            try {\n+                cipher.init(true, cipherKey.getAlgorithm(), cipherKeyEncoded,\n+                        iv);\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                throw new InvalidKeyException(\"IV in wrapped key is invalid\");\n+            }\n+            cipher.decrypt(buffer, iv.length, buffer2.length,\n+                    buffer2, 0);\n+            int keyValLen = buffer2.length - CHECKSUM_LEN;\n+            byte[] cks = getChecksum(buffer2, 0, keyValLen);\n+            int offset = keyValLen;\n+            for (int i = 0; i < CHECKSUM_LEN; i++) {\n+                if (buffer2[offset + i] != cks[i]) {\n+                    throw new InvalidKeyException(\"Checksum comparison failed\");\n+                }\n+            }\n+            \/\/ restore cipher state to prior to this call\n+            try {\n+                cipher.init(decrypting, cipherKey.getAlgorithm(),\n+                        cipherKeyEncoded, IV2);\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                throw new InvalidKeyException(\"IV in wrapped key is invalid\");\n+            }\n+            out = new byte[keyValLen];\n+            System.arraycopy(buffer2, 0, out, 0, keyValLen);\n+            return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n+                    wrappedKeyType);\n+        } finally {\n+            if (out != null) {\n+                Arrays.fill(out, (byte)0);\n+            }\n+            if (cipherKeyEncoded != null) {\n+                Arrays.fill(cipherKeyEncoded, (byte) 0);\n+            }\n+            Arrays.fill(buffer2, (byte)0);\n@@ -557,4 +591,0 @@\n-        byte[] out = new byte[keyValLen];\n-        System.arraycopy(buffer2, 0, out, 0, keyValLen);\n-        return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n@@ -576,0 +606,1 @@\n+        md.reset();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeWrapCipher.java","additions":94,"deletions":63,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -102,2 +103,1 @@\n-        throws InvalidKeySpecException\n-    {\n+            throws InvalidKeySpecException {\n@@ -112,3 +112,6 @@\n-                return new DHPrivateKey\n-                    (((PKCS8EncodedKeySpec)keySpec).getEncoded());\n-\n+                byte[] encoded = ((PKCS8EncodedKeySpec)keySpec).getEncoded();\n+                try {\n+                    return new DHPrivateKey(encoded);\n+                } finally {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n@@ -175,2 +178,6 @@\n-                return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n-\n+                byte[] encoded = key.getEncoded();\n+                try {\n+                    return keySpec.cast(new PKCS8EncodedKeySpec(encoded));\n+                } finally {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyFactory.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Arrays;\n@@ -49,1 +50,1 @@\n-javax.crypto.interfaces.DHPrivateKey, Serializable {\n+        javax.crypto.interfaces.DHPrivateKey, Serializable {\n@@ -108,3 +109,6 @@\n-            this.key = new DerValue(DerValue.tag_Integer,\n-                                    this.x.toByteArray()).toByteArray();\n-            this.encodedKey = getEncoded();\n+            byte[] xbytes = x.toByteArray();\n+            DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n+            this.key = val.toByteArray();\n+            val.clear();\n+            Arrays.fill(xbytes, (byte)0);\n+            encode();\n@@ -125,1 +129,1 @@\n-        InputStream inStream = new ByteArrayInputStream(encodedKey);\n+        DerValue val = null;\n@@ -127,1 +131,1 @@\n-            DerValue val = new DerValue(inStream);\n+            val = new DerValue(encodedKey);\n@@ -185,0 +189,4 @@\n+        } finally {\n+            if (val != null) {\n+                val.clear();\n+            }\n@@ -206,0 +214,9 @@\n+        encode();\n+        return encodedKey.clone();\n+    }\n+\n+    \/**\n+     * Generate the encodedKey field if it has not been calculated.\n+     * Could generate null.\n+     *\/\n+    private void encode() {\n@@ -241,3 +258,3 @@\n-                DerOutputStream derKey = new DerOutputStream();\n-                derKey.write(DerValue.tag_Sequence, tmp);\n-                this.encodedKey = derKey.toByteArray();\n+                DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n+                this.encodedKey = val.toByteArray();\n+                val.clear();\n@@ -245,1 +262,1 @@\n-                return null;\n+                throw new AssertionError(e);\n@@ -248,1 +265,0 @@\n-        return this.encodedKey.clone();\n@@ -317,0 +333,1 @@\n+        encode();\n@@ -318,3 +335,3 @@\n-                        getAlgorithm(),\n-                        getFormat(),\n-                        getEncoded());\n+                getAlgorithm(),\n+                getFormat(),\n+                encodedKey);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":32,"deletions":15,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -204,0 +205,2 @@\n+            PrivateKeyInfo privateKeyInfo = new PrivateKeyInfo(plain);\n+            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(plain);\n@@ -205,3 +208,8 @@\n-                (new PrivateKeyInfo(plain).getAlgorithm().getOID()).getName();\n-            KeyFactory kFac = KeyFactory.getInstance(oidName);\n-            return kFac.generatePrivate(new PKCS8EncodedKeySpec(plain));\n+                (privateKeyInfo.getAlgorithm().getOID()).getName();\n+            try {\n+                KeyFactory kFac = KeyFactory.getInstance(oidName);\n+                return kFac.generatePrivate(spec);\n+            } finally {\n+                privateKeyInfo.clear();\n+                SharedSecrets.getJavaSecuritySpecAccess().clearEncodedKeySpec(spec);\n+            }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,3 +170,3 @@\n-                        getAlgorithm(),\n-                        getFormat(),\n-                        getEncoded());\n+                getAlgorithm(),\n+                getFormat(),\n+                key);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,2 +295,6 @@\n-                \/\/ Create key from spec, and return it\n-                return engineGenerateSecret(pbeKeySpec);\n+                try {\n+                    \/\/ Create key from spec, and return it\n+                    return engineGenerateSecret(pbeKeySpec);\n+                } finally {\n+                    pbeKeySpec.clearPassword();\n+                }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -540,1 +540,0 @@\n-        byte[] encodedKey;\n@@ -542,1 +541,7 @@\n-            encodedKey = doFinal(wrappedKey, 0, wrappedKey.length);\n+            byte[] encodedKey = doFinal(wrappedKey, 0, wrappedKey.length);\n+            try {\n+                return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n+                        wrappedKeyType);\n+            } finally {\n+                Arrays.fill(encodedKey, (byte)0);\n+            }\n@@ -550,2 +555,0 @@\n-        return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES1Core.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,1 +277,1 @@\n-        SecretKey s = null;\n+        PBKDF2KeyImpl s;\n@@ -280,2 +280,1 @@\n-            s = kdf.engineGenerateSecret(pbeSpec);\n-\n+            s = (PBKDF2KeyImpl)kdf.engineGenerateSecret(pbeSpec);\n@@ -287,0 +286,2 @@\n+        } finally {\n+            pbeSpec.clearPassword();\n@@ -289,0 +290,1 @@\n+        s.clearPassword();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Core.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Arrays;\n@@ -97,3 +98,11 @@\n-                return new PBEKeySpec\n-                    (pKey.getPassword(), pKey.getSalt(),\n-                     pKey.getIterationCount(), pKey.getEncoded().length*8);\n+                char[] passwd = pKey.getPassword();\n+                byte[] encoded = pKey.getEncoded();\n+                try {\n+                    return new PBEKeySpec(passwd, pKey.getSalt(),\n+                            pKey.getIterationCount(), encoded.length * 8);\n+                } finally {\n+                    if (passwd != null) {\n+                        Arrays.fill(passwd, (char) 0);\n+                    }\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n@@ -135,0 +144,7 @@\n+                char[] password = pKey.getPassword();\n+                byte[] encoding = pKey.getEncoded();\n+                PBEKeySpec spec =\n+                        new PBEKeySpec(password,\n+                                pKey.getSalt(),\n+                                pKey.getIterationCount(),\n+                                encoding.length*8);\n@@ -136,5 +152,0 @@\n-                    PBEKeySpec spec =\n-                        new PBEKeySpec(pKey.getPassword(),\n-                                       pKey.getSalt(),\n-                                       pKey.getIterationCount(),\n-                                       pKey.getEncoded().length*8);\n@@ -147,0 +158,6 @@\n+                } finally {\n+                    if (password != null) {\n+                        Arrays.fill(password, (char) 0);\n+                        spec.clearPassword();\n+                    }\n+                    Arrays.fill(encoding, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2Core.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Arrays;\n@@ -97,3 +98,11 @@\n-                return new PBEKeySpec\n-                    (pKey.getPassword(), pKey.getSalt(),\n-                     pKey.getIterationCount(), pKey.getEncoded().length*8);\n+                char[] passwd = pKey.getPassword();\n+                byte[] encoded = pKey.getEncoded();\n+                try {\n+                    return new PBEKeySpec(passwd, pKey.getSalt(),\n+                            pKey.getIterationCount(), encoded.length * 8);\n+                } finally {\n+                    if (passwd != null) {\n+                        Arrays.fill(passwd, (char) 0);\n+                    }\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n@@ -135,0 +144,7 @@\n+                char[] password = pKey.getPassword();\n+                byte[] encoding = pKey.getEncoded();\n+                PBEKeySpec spec =\n+                        new PBEKeySpec(password,\n+                                pKey.getSalt(),\n+                                pKey.getIterationCount(),\n+                                encoding.length*8);\n@@ -136,5 +152,0 @@\n-                    PBEKeySpec spec =\n-                        new PBEKeySpec(pKey.getPassword(),\n-                                       pKey.getSalt(),\n-                                       pKey.getIterationCount(),\n-                                       pKey.getEncoded().length*8);\n@@ -147,0 +158,6 @@\n+                } finally {\n+                    if (password != null) {\n+                        Arrays.fill(password, (char) 0);\n+                        spec.clearPassword();\n+                    }\n+                    Arrays.fill(encoding, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2HmacSHA1Factory.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+        bb.clear().put(new byte[len]);\n@@ -162,1 +163,1 @@\n-                    return password;\n+                    return password.clone();\n@@ -228,0 +229,4 @@\n+    public void clearPassword() {\n+        Arrays.fill(passwd, (char)0);\n+    }\n+\n@@ -285,2 +290,2 @@\n-            return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),\n-                              getFormat(), getEncoded());\n+        return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),\n+                getFormat(), key);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-        SecretKey s;\n+        PBKDF2KeyImpl s = null;\n@@ -179,0 +179,1 @@\n+        byte[] derivedKey;\n@@ -180,1 +181,2 @@\n-            s = kdf.engineGenerateSecret(pbeSpec);\n+            s = (PBKDF2KeyImpl)kdf.engineGenerateSecret(pbeSpec);\n+            derivedKey = s.getEncoded();\n@@ -186,0 +188,5 @@\n+        } finally {\n+            pbeSpec.clearPassword();\n+            if (s != null) {\n+                s.clearPassword();\n+            }\n@@ -187,1 +194,0 @@\n-        byte[] derivedKey = s.getEncoded();\n@@ -189,0 +195,1 @@\n+        Arrays.fill(derivedKey, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBMAC1Core.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.security.auth.DestroyFailedException;\n@@ -121,1 +122,2 @@\n-                if (i + 1 == c)\n+                if (i + 1 == c) {\n+                    Arrays.fill(I, (byte)0);\n@@ -123,0 +125,1 @@\n+                }\n@@ -131,1 +134,2 @@\n-                    if (tmp.length != v)\n+                    if (tmp.length != v) {\n+                        Arrays.fill(tmp, (byte)0);\n@@ -133,0 +137,1 @@\n+                    }\n@@ -135,0 +140,1 @@\n+                    Arrays.fill(tmp, (byte)0);\n@@ -145,0 +151,1 @@\n+                Arrays.fill(tmp, (byte)0);\n@@ -344,0 +351,1 @@\n+            Arrays.fill(derivedKey, (byte)0);\n@@ -345,2 +353,3 @@\n-            if (cipherImpl != null && cipherImpl instanceof ARCFOURCipher) {\n-                ((ARCFOURCipher)cipherImpl).engineInit(opmode, cipherKey, random);\n+            try {\n+                if (cipherImpl != null && cipherImpl instanceof ARCFOURCipher) {\n+                    ((ARCFOURCipher) cipherImpl).engineInit(opmode, cipherKey, random);\n@@ -348,4 +357,4 @@\n-            } else {\n-                byte[] derivedIv = derive(passwdChars, salt, iCount, 8,\n-                        CIPHER_IV);\n-                IvParameterSpec ivSpec = new IvParameterSpec(derivedIv, 0, 8);\n+                } else {\n+                    byte[] derivedIv = derive(passwdChars, salt, iCount, 8,\n+                            CIPHER_IV);\n+                    IvParameterSpec ivSpec = new IvParameterSpec(derivedIv, 0, 8);\n@@ -353,2 +362,9 @@\n-                \/\/ initialize the underlying cipher\n-                cipher.init(opmode, cipherKey, ivSpec, random);\n+                    \/\/ initialize the underlying cipher\n+                    cipher.init(opmode, cipherKey, ivSpec, random);\n+                }\n+            } finally {\n+                try {\n+                    cipherKey.destroy();\n+                } catch (DestroyFailedException e) {\n+                    \/\/ Ignore the failure\n+                }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS12PBECipherCore.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.util.Arrays;\n+\n@@ -65,2 +67,3 @@\n-        if (val.tag != DerValue.tag_Sequence)\n-            throw new IOException(\"private key parse error: not a sequence\");\n+        try {\n+            if (val.tag != DerValue.tag_Sequence)\n+                throw new IOException(\"private key parse error: not a sequence\");\n@@ -68,6 +71,6 @@\n-        \/\/ version\n-        BigInteger parsedVersion = val.data.getBigInteger();\n-        if (!parsedVersion.equals(VERSION)) {\n-            throw new IOException(\"version mismatch: (supported: \" +\n-                                  VERSION + \", parsed: \" + parsedVersion);\n-        }\n+            \/\/ version\n+            BigInteger parsedVersion = val.data.getBigInteger();\n+            if (!parsedVersion.equals(VERSION)) {\n+                throw new IOException(\"version mismatch: (supported: \" +\n+                        VERSION + \", parsed: \" + parsedVersion);\n+            }\n@@ -75,2 +78,2 @@\n-        \/\/ privateKeyAlgorithm\n-        this.algid = AlgorithmId.parse(val.data.getDerValue());\n+            \/\/ privateKeyAlgorithm\n+            this.algid = AlgorithmId.parse(val.data.getDerValue());\n@@ -78,2 +81,2 @@\n-        \/\/ privateKey\n-        this.privkey = val.data.getOctetString();\n+            \/\/ privateKey\n+            this.privkey = val.data.getOctetString();\n@@ -81,1 +84,4 @@\n-        \/\/ OPTIONAL attributes not supported yet\n+            \/\/ OPTIONAL attributes not supported yet\n+        } finally {\n+            val.clear();\n+        }\n@@ -90,0 +96,4 @@\n+\n+    public void clear() {\n+        Arrays.fill(privkey, (byte)0);\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PrivateKeyInfo.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Arrays;\n@@ -136,0 +137,1 @@\n+        Arrays.fill(keyBytes, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RC2Cipher.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import jdk.internal.access.JavaSecuritySpecAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.util.Arrays;\n+\n@@ -48,1 +53,11 @@\n-    \/**\n+    static {\n+        SharedSecrets.setJavaSecuritySpecAccess(\n+                new JavaSecuritySpecAccess() {\n+                    @Override\n+                    public void clearEncodedKeySpec(EncodedKeySpec keySpec) {\n+                        keySpec.clear();\n+                    }\n+                });\n+    }\n+\n+                    \/**\n@@ -128,0 +143,7 @@\n+\n+    \/**\n+     * Clear the encoding inside.\n+     *\/\n+    void clear() {\n+        Arrays.fill(encodedKey, (byte)0);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -174,2 +175,1 @@\n-        }\n-        catch (BadPaddingException ex) {\n+        } catch (BadPaddingException ex) {\n@@ -178,0 +178,2 @@\n+        } finally {\n+            Arrays.fill(content, (byte)0);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/SealedObject.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaxCryptoSpecAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -30,0 +33,1 @@\n+import java.util.Arrays;\n@@ -69,0 +73,10 @@\n+    static {\n+        SharedSecrets.setJavaxCryptoSpecAccess(\n+                new JavaxCryptoSpecAccess() {\n+                    @Override\n+                    public void clearSecretKeySpec(SecretKeySpec keySpec) {\n+                        keySpec.clear();\n+                    }\n+                });\n+    }\n+\n@@ -230,0 +244,8 @@\n+        try {\n+            return MessageDigest.isEqual(this.key, thatKey);\n+        } finally {\n+            if (thatKey != null) {\n+                Arrays.fill(thatKey, (byte)0);\n+            }\n+        }\n+    }\n@@ -231,1 +253,5 @@\n-        return MessageDigest.isEqual(this.key, thatKey);\n+    \/**\n+     * Clear the key bytes inside.\n+     *\/\n+    void clear() {\n+        Arrays.fill(key, (byte)0);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/SecretKeySpec.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.security.spec.EncodedKeySpec;\n+\n+public interface JavaSecuritySpecAccess {\n+    void clearEncodedKeySpec(EncodedKeySpec keySpec);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaSecuritySpecAccess.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public interface JavaxCryptoSpecAccess {\n+    void clearSecretKeySpec(SecretKeySpec keySpec);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaxCryptoSpecAccess.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.crypto.spec.SecretKeySpec;\n@@ -32,0 +33,1 @@\n+import java.security.spec.EncodedKeySpec;\n@@ -79,0 +81,1 @@\n+    private static JavaSecuritySpecAccess javaSecuritySpecAccess;\n@@ -80,0 +83,1 @@\n+    private static JavaxCryptoSpecAccess javaxCryptoSpecAccess;\n@@ -401,0 +405,22 @@\n+    public static void setJavaSecuritySpecAccess(JavaSecuritySpecAccess jssa) {\n+        javaSecuritySpecAccess = jssa;\n+    }\n+\n+    public static JavaSecuritySpecAccess getJavaSecuritySpecAccess() {\n+        if (javaSecuritySpecAccess == null) {\n+            ensureClassInitialized(EncodedKeySpec.class);\n+        }\n+        return javaSecuritySpecAccess;\n+    }\n+\n+    public static void setJavaxCryptoSpecAccess(JavaxCryptoSpecAccess jcsa) {\n+        javaxCryptoSpecAccess = jcsa;\n+    }\n+\n+    public static JavaxCryptoSpecAccess getJavaxCryptoSpecAccess() {\n+        if (javaxCryptoSpecAccess == null) {\n+            ensureClassInitialized(SecretKeySpec.class);\n+        }\n+        return javaxCryptoSpecAccess;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -98,0 +99,1 @@\n+        DerValue val = null;\n@@ -99,1 +101,1 @@\n-            DerValue val = new DerValue(is);\n+            val = new DerValue(is);\n@@ -109,1 +111,1 @@\n-            key = val.data.getOctetString ();\n+            key = val.data.getOctetString();\n@@ -134,0 +136,4 @@\n+        } finally {\n+            if (val != null) {\n+                val.clear();\n+            }\n@@ -138,1 +144,1 @@\n-     * Construct PKCS#8 subject public key from a DER value.  If a\n+     * Construct PKCS#8 subject public key from a DER encoding.  If a\n@@ -148,1 +154,1 @@\n-     * @param in the DER-encoded SubjectPublicKeyInfo value\n+     * @param encoded the DER-encoded SubjectPublicKeyInfo value\n@@ -151,1 +157,1 @@\n-    public static PrivateKey parseKey(DerValue in) throws IOException {\n+    public static PrivateKey parseKey(byte[] encoded) throws IOException {\n@@ -153,3 +159,4 @@\n-            PKCS8Key rawKey = new PKCS8Key(in.toByteArray());\n-            PKCS8EncodedKeySpec pkcs8KeySpec\n-                = new PKCS8EncodedKeySpec(rawKey.getEncoded());\n+            PKCS8Key rawKey = new PKCS8Key(encoded);\n+            byte[] internal = rawKey.getEncodedInternal();\n+            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(internal);\n+            PrivateKey result = null;\n@@ -157,1 +164,1 @@\n-                return KeyFactory.getInstance(rawKey.algid.getName())\n+                result = KeyFactory.getInstance(rawKey.algid.getName())\n@@ -161,1 +168,7 @@\n-                return rawKey;\n+                result = rawKey;\n+            } finally {\n+                if (result != rawKey) {\n+                    rawKey.clear();\n+                }\n+                SharedSecrets.getJavaSecuritySpecAccess()\n+                        .clearEncodedKeySpec(pkcs8KeySpec);\n@@ -163,0 +176,1 @@\n+            return result;\n@@ -186,8 +200,3 @@\n-    public synchronized byte[] getEncoded() {\n-        try {\n-            encode();\n-            return encodedKey.clone();\n-        } catch (InvalidKeyException e) {\n-            \/\/ ignored and return null\n-        }\n-        return null;\n+    public byte[] getEncoded() {\n+        byte[] b = getEncodedInternal();\n+        return (b == null) ? null : b.clone();\n@@ -204,2 +213,2 @@\n-     * DER-encodes this key as a byte array that can be retrieved\n-     * by the {@link #getEncoded()} method.\n+     * DER-encodes this key as a byte array stored inside this object\n+     * and return it.\n@@ -207,1 +216,1 @@\n-     * @exception InvalidKeyException if an encoding error occurs.\n+     * @return the encoding, or null if there is an I\/O error.\n@@ -209,1 +218,1 @@\n-    private void encode() throws InvalidKeyException {\n+    private synchronized byte[] getEncodedInternal() {\n@@ -212,1 +221,0 @@\n-                DerOutputStream out = new DerOutputStream ();\n@@ -217,1 +225,1 @@\n-                out.write(DerValue.tag_Sequence, tmp);\n+                DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n@@ -219,0 +227,1 @@\n+                out.clear();\n@@ -220,2 +229,1 @@\n-                throw new InvalidKeyException (\"IOException : \" +\n-                                               e.getMessage());\n+                \/\/ encodedKey is still null\n@@ -224,0 +232,1 @@\n+        return encodedKey;\n@@ -229,3 +238,3 @@\n-                        getAlgorithm(),\n-                        getFormat(),\n-                        getEncoded());\n+                getAlgorithm(),\n+                getFormat(),\n+                getEncodedInternal());\n@@ -261,1 +270,1 @@\n-        if (object instanceof Key) {\n+        if (object instanceof PKCS8Key) {\n@@ -264,2 +273,14 @@\n-                    getEncoded(),\n-                    ((Key)object).getEncoded());\n+                    getEncodedInternal(),\n+                    ((PKCS8Key)object).getEncodedInternal());\n+        } else if (object instanceof Key) {\n+            \/\/ time-constant comparison\n+            byte[] otherEncoded = ((Key)object).getEncoded();\n+            try {\n+                return MessageDigest.isEqual(\n+                        getEncodedInternal(),\n+                        otherEncoded);\n+            } finally {\n+                if (otherEncoded != null) {\n+                    Arrays.fill(otherEncoded, (byte) 0);\n+                }\n+            }\n@@ -275,1 +296,8 @@\n-        return Arrays.hashCode(getEncoded());\n+        return Arrays.hashCode(getEncodedInternal());\n+    }\n+\n+    public void clear() {\n+        if (encodedKey != null) {\n+            Arrays.fill(encodedKey, (byte)0);\n+        }\n+        Arrays.fill(key, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":62,"deletions":34,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -362,1 +363,0 @@\n-                SecretKey skey = getPBEKey(pass);\n@@ -365,1 +365,6 @@\n-                cipher.init(Cipher.DECRYPT_MODE, skey, algParams);\n+                SecretKey skey = getPBEKey(pass);\n+                try {\n+                    cipher.init(Cipher.DECRYPT_MODE, skey, algParams);\n+                } finally {\n+                    destroyPBEKey(skey);\n+                }\n@@ -372,20 +377,6 @@\n-                DerInputStream in = val.toDerInputStream();\n-                int i = in.getInteger();\n-                DerValue[] value = in.getSequence(2);\n-                if (value.length < 1 || value.length > 2) {\n-                    throw new IOException(\"Invalid length for AlgorithmIdentifier\");\n-                }\n-                AlgorithmId algId = new AlgorithmId(value[0].getOID());\n-                String keyAlgo = algId.getName();\n-\n-                \/\/ decode private key\n-                if (entry instanceof PrivateKeyEntry) {\n-                    KeyFactory kfac = KeyFactory.getInstance(keyAlgo);\n-                    PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(keyInfo);\n-                    Key tmp = kfac.generatePrivate(kspec);\n-\n-                    if (debug != null) {\n-                        debug.println(\"Retrieved a protected private key at alias\" +\n-                                \" '\" + alias + \"' (\" +\n-                                mapPBEParamsToAlgorithm(algOid, algParams) +\n-                                \" iterations: \" + ic + \")\");\n+                try {\n+                    DerInputStream in = val.toDerInputStream();\n+                    int i = in.getInteger();\n+                    DerValue[] value = in.getSequence(2);\n+                    if (value.length < 1 || value.length > 2) {\n+                        throw new IOException(\"Invalid length for AlgorithmIdentifier\");\n@@ -393,15 +384,22 @@\n-                    return tmp;\n-                    \/\/ decode secret key\n-                } else {\n-                    byte[] keyBytes = in.getOctetString();\n-                    SecretKeySpec secretKeySpec =\n-                            new SecretKeySpec(keyBytes, keyAlgo);\n-\n-                    \/\/ Special handling required for PBE: needs a PBEKeySpec\n-                    Key tmp;\n-                    if (keyAlgo.startsWith(\"PBE\")) {\n-                        SecretKeyFactory sKeyFactory =\n-                                SecretKeyFactory.getInstance(keyAlgo);\n-                        KeySpec pbeKeySpec =\n-                                sKeyFactory.getKeySpec(secretKeySpec, PBEKeySpec.class);\n-                        tmp = sKeyFactory.generateSecret(pbeKeySpec);\n+                    AlgorithmId algId = new AlgorithmId(value[0].getOID());\n+                    String keyAlgo = algId.getName();\n+\n+                    \/\/ decode private key\n+                    if (entry instanceof PrivateKeyEntry) {\n+                        KeyFactory kfac = KeyFactory.getInstance(keyAlgo);\n+                        PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(keyInfo);\n+                        try {\n+                            Key tmp = kfac.generatePrivate(kspec);\n+\n+                            if (debug != null) {\n+                                debug.println(\"Retrieved a protected private key at alias\" +\n+                                        \" '\" + alias + \"' (\" +\n+                                        mapPBEParamsToAlgorithm(algOid, algParams) +\n+                                        \" iterations: \" + ic + \")\");\n+                            }\n+                            return tmp;\n+                        } finally {\n+                            SharedSecrets.getJavaSecuritySpecAccess()\n+                                    .clearEncodedKeySpec(kspec);\n+                        }\n+                        \/\/ decode secret key\n@@ -409,8 +407,33 @@\n-                        tmp = secretKeySpec;\n-                    }\n-\n-                    if (debug != null) {\n-                        debug.println(\"Retrieved a protected secret key at alias \" +\n-                                \"'\" + alias + \"' (\" +\n-                                mapPBEParamsToAlgorithm(algOid, algParams) +\n-                                \" iterations: \" + ic + \")\");\n+                        byte[] keyBytes = in.getOctetString();\n+                        SecretKeySpec secretKeySpec =\n+                                new SecretKeySpec(keyBytes, keyAlgo);\n+\n+                        try {\n+                            \/\/ Special handling required for PBE: needs a PBEKeySpec\n+                            Key tmp;\n+                            if (keyAlgo.startsWith(\"PBE\")) {\n+                                SecretKeyFactory sKeyFactory =\n+                                        SecretKeyFactory.getInstance(keyAlgo);\n+                                KeySpec pbeKeySpec =\n+                                        sKeyFactory.getKeySpec(secretKeySpec, PBEKeySpec.class);\n+                                try {\n+                                    tmp = sKeyFactory.generateSecret(pbeKeySpec);\n+                                } finally {\n+                                    ((PBEKeySpec)pbeKeySpec).clearPassword();\n+                                    SharedSecrets.getJavaxCryptoSpecAccess()\n+                                            .clearSecretKeySpec(secretKeySpec);\n+                                }\n+                            } else {\n+                                tmp = secretKeySpec;\n+                            }\n+\n+                            if (debug != null) {\n+                                debug.println(\"Retrieved a protected secret key at alias \" +\n+                                        \"'\" + alias + \"' (\" +\n+                                        mapPBEParamsToAlgorithm(algOid, algParams) +\n+                                        \" iterations: \" + ic + \")\");\n+                            }\n+                            return tmp;\n+                        } finally {\n+                            Arrays.fill(keyBytes, (byte)0);\n+                        }\n@@ -418,1 +441,3 @@\n-                    return tmp;\n+                } finally {\n+                    val.clear();\n+                    Arrays.fill(keyInfo, (byte) 0);\n@@ -603,2 +628,9 @@\n-                    keyEntry.protectedPrivKey =\n-                        encryptPrivateKey(key.getEncoded(), passwordProtection);\n+                    byte[] encoded = key.getEncoded();\n+                    try {\n+                        keyEntry.protectedPrivKey =\n+                                encryptPrivateKey(encoded, passwordProtection);\n+                    } finally {\n+                        if (encoded != null) {\n+                            Arrays.fill(encoded, (byte) 0);\n+                        }\n+                    }\n@@ -632,1 +664,0 @@\n-                DerOutputStream pkcs8 = new DerOutputStream();\n@@ -637,2 +668,0 @@\n-                secretKeyInfo.putOctetString(key.getEncoded());\n-                pkcs8.write(DerValue.tag_Sequence, secretKeyInfo);\n@@ -640,3 +669,14 @@\n-                \/\/ Encrypt the secret key (using same PBE as for private keys)\n-                keyEntry.protectedSecretKey =\n-                    encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);\n+                byte[] encoded = key.getEncoded();\n+                secretKeyInfo.putOctetString(encoded);\n+                Arrays.fill(encoded, (byte)0);\n+\n+                DerValue pkcs8 = DerValue.wrap(DerValue.tag_Sequence, secretKeyInfo);\n+                byte[] p8Array = pkcs8.toByteArray();\n+                pkcs8.clear();\n+                try {\n+                    \/\/ Encrypt the secret key (using same PBE as for private keys)\n+                    keyEntry.protectedSecretKey =\n+                            encryptPrivateKey(p8Array, passwordProtection);\n+                } finally {\n+                    Arrays.fill(p8Array, (byte)0);\n+                }\n@@ -833,0 +873,11 @@\n+    \/*\n+     * Destroy the key obtained from getPBEKey().\n+     *\/\n+    private void destroyPBEKey(SecretKey key) {\n+        try {\n+            key.destroy();\n+        } catch (DestroyFailedException e) {\n+            \/\/ Accept this\n+        }\n+    }\n+\n@@ -877,1 +928,0 @@\n-            SecretKey skey = getPBEKey(passwordProtection.getPassword());\n@@ -879,1 +929,6 @@\n-            cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);\n+            SecretKey skey = getPBEKey(passwordProtection.getPassword());\n+            try {\n+                cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);\n+            } finally {\n+                destroyPBEKey(skey);\n+            }\n@@ -1465,1 +1520,5 @@\n-            m.init(key, params);\n+            try {\n+                m.init(key, params);\n+            } finally {\n+                destroyPBEKey(key);\n+            }\n@@ -1870,1 +1929,0 @@\n-            SecretKey skey = getPBEKey(password);\n@@ -1872,1 +1930,6 @@\n-            cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);\n+            SecretKey skey = getPBEKey(password);\n+            try {\n+                cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);\n+            } finally {\n+                destroyPBEKey(skey);\n+            }\n@@ -2078,1 +2141,0 @@\n-                        SecretKey skey = getPBEKey(pass);\n@@ -2081,1 +2143,6 @@\n-                        cipher.init(Cipher.DECRYPT_MODE, skey, algParams);\n+                        SecretKey skey = getPBEKey(pass);\n+                        try {\n+                            cipher.init(Cipher.DECRYPT_MODE, skey, algParams);\n+                        } finally {\n+                            destroyPBEKey(skey);\n+                        }\n@@ -2131,1 +2198,5 @@\n-                        m.init(key, params);\n+                        try {\n+                            m.init(key, params);\n+                        } finally {\n+                            destroyPBEKey(key);\n+                        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":134,"deletions":63,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -96,1 +97,1 @@\n-    throws InvalidKeySpecException {\n+            throws InvalidKeySpecException {\n@@ -106,3 +107,6 @@\n-                return new DSAPrivateKey\n-                    (((PKCS8EncodedKeySpec)keySpec).getEncoded());\n-\n+                byte[] encoded = ((PKCS8EncodedKeySpec)keySpec).getEncoded();\n+                try {\n+                    return new DSAPrivateKey(encoded);\n+                } finally {\n+                    Arrays.fill(encoded, (byte) 0);\n+                }\n@@ -186,2 +190,6 @@\n-                    return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n-\n+                    byte[] encoded = key.getEncoded();\n+                    try {\n+                        return keySpec.cast(new PKCS8EncodedKeySpec(encoded));\n+                    } finally {\n+                        Arrays.fill(encoded, (byte)0);\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAKeyFactory.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.Arrays;\n@@ -71,2 +72,5 @@\n-            key = new DerValue(DerValue.tag_Integer,\n-                               x.toByteArray()).toByteArray();\n+            byte[] xbytes = x.toByteArray();\n+            DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n+            key = val.toByteArray();\n+            val.clear();\n+            Arrays.fill(xbytes, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPrivateKey.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,1 @@\n+        Arrays.fill(plainKey, (byte)0);\n@@ -311,1 +312,1 @@\n-            return PKCS8Key.parseKey(new DerValue(plainKey));\n+            return PKCS8Key.parseKey(plainKey);\n@@ -314,0 +315,2 @@\n+        } finally {\n+            Arrays.fill(plainKey, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Arrays;\n@@ -311,2 +312,8 @@\n-            return RSAPrivateCrtKeyImpl.newKey(type, key.getFormat(),\n-                    key.getEncoded());\n+            byte[] encoded = key.getEncoded();\n+            try {\n+                return RSAPrivateCrtKeyImpl.newKey(type, key.getFormat(), encoded);\n+            } finally {\n+                if (encoded != null) {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n+            }\n@@ -343,2 +350,6 @@\n-            return RSAPrivateCrtKeyImpl.newKey(type, \"PKCS#8\",\n-                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            byte[] encoded = ((PKCS8EncodedKeySpec)keySpec).getEncoded();\n+            try {\n+                return RSAPrivateCrtKeyImpl.newKey(type, \"PKCS#8\", encoded);\n+            } finally {\n+                Arrays.fill(encoded, (byte)0);\n+            }\n@@ -407,1 +418,6 @@\n-                return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n+                byte[] encoded = key.getEncoded();\n+                try {\n+                    return keySpec.cast(new PKCS8EncodedKeySpec(encoded));\n+                } finally {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -195,2 +196,19 @@\n-            \/\/ generate the key encoding\n-            DerOutputStream out = new DerOutputStream();\n+            byte[][] nbytes = new byte[8][];\n+            nbytes[0] = n.toByteArray();\n+            nbytes[1] = e.toByteArray();\n+            nbytes[2] = d.toByteArray();\n+            nbytes[3] = p.toByteArray();\n+            nbytes[4] = q.toByteArray();\n+            nbytes[5] = pe.toByteArray();\n+            nbytes[6] = qe.toByteArray();\n+            nbytes[7] = coeff.toByteArray();\n+\n+            \/\/ Initiate with a big enough size so there's no need to\n+            \/\/ reallocate memory later and thus can be cleaned up\n+            \/\/ reliably.\n+            DerOutputStream out = new DerOutputStream(\n+                    nbytes[0].length + nbytes[1].length +\n+                    nbytes[2].length + nbytes[3].length +\n+                    nbytes[4].length + nbytes[5].length +\n+                    nbytes[6].length + nbytes[7].length +\n+                    100); \/\/ Enough for version(3) and 8 tag+length(3 or 4)\n@@ -198,10 +216,16 @@\n-            out.putInteger(n);\n-            out.putInteger(e);\n-            out.putInteger(d);\n-            out.putInteger(p);\n-            out.putInteger(q);\n-            out.putInteger(pe);\n-            out.putInteger(qe);\n-            out.putInteger(coeff);\n-            DerValue val =\n-                new DerValue(DerValue.tag_Sequence, out.toByteArray());\n+            out.putInteger(nbytes[0]);\n+            out.putInteger(nbytes[1]);\n+            out.putInteger(nbytes[2]);\n+            out.putInteger(nbytes[3]);\n+            out.putInteger(nbytes[4]);\n+            out.putInteger(nbytes[5]);\n+            out.putInteger(nbytes[6]);\n+            out.putInteger(nbytes[7]);\n+            \/\/ Private values from [2] on.\n+            Arrays.fill(nbytes[2], (byte)0);\n+            Arrays.fill(nbytes[3], (byte)0);\n+            Arrays.fill(nbytes[4], (byte)0);\n+            Arrays.fill(nbytes[5], (byte)0);\n+            Arrays.fill(nbytes[6], (byte)0);\n+            Arrays.fill(nbytes[7], (byte)0);\n+            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n@@ -209,0 +233,1 @@\n+            val.clear();\n@@ -288,7 +313,8 @@\n-        if (derValue.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"Not a SEQUENCE\");\n-        }\n-        int version = derValue.data.getInteger();\n-        if (version != 0) {\n-            throw new IOException(\"Version must be 0\");\n-        }\n+        try {\n+            if (derValue.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Not a SEQUENCE\");\n+            }\n+            int version = derValue.data.getInteger();\n+            if (version != 0) {\n+                throw new IOException(\"Version must be 0\");\n+            }\n@@ -296,13 +322,17 @@\n-        BigInteger[] result = new BigInteger[8]; \/\/ n, e, d, p, q, pe, qe, coeff\n-        \/*\n-         * Some implementations do not correctly encode ASN.1 INTEGER values\n-         * in 2's complement format, resulting in a negative integer when\n-         * decoded. Correct the error by converting it to a positive integer.\n-         *\n-         * See CR 6255949\n-         *\/\n-        for (int i = 0; i < result.length; i++) {\n-            result[i] = derValue.data.getPositiveBigInteger();\n-        }\n-        if (derValue.data.available() != 0) {\n-            throw new IOException(\"Extra data available\");\n+            BigInteger[] result = new BigInteger[8]; \/\/ n, e, d, p, q, pe, qe, coeff\n+            \/*\n+             * Some implementations do not correctly encode ASN.1 INTEGER values\n+             * in 2's complement format, resulting in a negative integer when\n+             * decoded. Correct the error by converting it to a positive integer.\n+             *\n+             * See CR 6255949\n+             *\/\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = derValue.data.getPositiveBigInteger();\n+            }\n+            if (derValue.data.available() != 0) {\n+                throw new IOException(\"Extra data available\");\n+            }\n+            return result;\n+        } finally {\n+            derValue.clear();\n@@ -310,1 +340,0 @@\n-        return result;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":62,"deletions":33,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -93,1 +94,5 @@\n-            DerOutputStream out = new DerOutputStream();\n+            byte[] nbytes = n.toByteArray();\n+            byte[] dbytes = d.toByteArray();\n+            DerOutputStream out = new DerOutputStream(\n+                    nbytes.length + dbytes.length + 50);\n+                    \/\/ Enough for 7 zeroes (21) and 2 tag+length(4)\n@@ -95,1 +100,2 @@\n-            out.putInteger(n);\n+            out.putInteger(nbytes);\n+            Arrays.fill(nbytes, (byte)0);\n@@ -97,1 +103,2 @@\n-            out.putInteger(d);\n+            out.putInteger(dbytes);\n+            Arrays.fill(dbytes, (byte)0);\n@@ -103,2 +110,1 @@\n-            DerValue val =\n-                new DerValue(DerValue.tag_Sequence, out.toByteArray());\n+            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n@@ -106,0 +112,1 @@\n+            val.clear();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,11 @@\n+    \/**\n+     * Marshals a DER integer on the output stream.\n+     *\n+     * @param i the integer in bytes, equivalent to BigInteger::toByteArray.\n+     *\/\n+    public void putInteger(byte[] buf) throws IOException {\n+        write(DerValue.tag_Integer);\n+        putLength(buf.length);\n+        write(buf, 0, buf.length);\n+    }\n+\n@@ -578,0 +589,4 @@\n+\n+    byte[] buf() {\n+        return buf;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerOutputStream.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -286,0 +286,16 @@\n+    \/**\n+     * Wraps an DerOutputStream. All bytes currently written\n+     * into the stream will become the content of the newly\n+     * created DerValue.\n+     *\n+     * Attention: do not reset the DerOutputStream after this call.\n+     * No array copying is made.\n+     *\n+     * @param tag the tag\n+     * @param out the DerOutputStream\n+     * @returns a new DerValue using out as its content\n+     *\/\n+    public static DerValue wrap(byte tag, DerOutputStream out) {\n+        return new DerValue(tag, out.buf(), 0, out.size(), false);\n+    }\n+\n@@ -1066,0 +1082,2 @@\n+        data.pos = data.start; \/\/ Compatibility. At head.\n+        \/\/ Minimize content duplication by writing out tag and length only\n@@ -1067,3 +1085,6 @@\n-        encode(out);\n-        data.pos = data.start; \/\/ encode go last, should go back\n-        return out.toByteArray();\n+        out.write(tag);\n+        out.putLength(end - start);\n+        int headLen = out.size();\n+        byte[] result = Arrays.copyOf(out.buf(), end - start + headLen);\n+        System.arraycopy(buffer, start, result, headLen, end - start);\n+        return result;\n@@ -1207,0 +1228,4 @@\n+\n+    public void clear() {\n+        Arrays.fill(buffer, start, end, (byte)0);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -125,2 +127,5 @@\n-\n-        return (ECPrivateKey)keyFactory.generatePrivate(keySpec);\n+        try {\n+            return (ECPrivateKey) keyFactory.generatePrivate(keySpec);\n+        } finally {\n+            SharedSecrets.getJavaSecuritySpecAccess().clearEncodedKeySpec(keySpec);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ECUtil.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import java.util.Arrays;\n@@ -83,2 +84,6 @@\n-            if (\"RAW\".equals(format) && sk.getEncoded() != null) {\n-                size = (sk.getEncoded().length * 8);\n+            if (\"RAW\".equals(format)) {\n+                byte[] encoded = sk.getEncoded();\n+                if (encoded != null) {\n+                    size = (encoded.length * 8);\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,26 +103,0 @@\n-    AlgIdDSA (DerValue val) throws IOException\n-        { super(val.getOID()); }\n-\n-    \/**\n-     * Construct an AlgIdDSA from an X.509 encoded byte array.\n-     *\/\n-    public AlgIdDSA (byte[] encodedAlg) throws IOException\n-        { super (new DerValue(encodedAlg).getOID()); }\n-\n-    \/**\n-     * Constructs a DSS\/DSA Algorithm ID from unsigned integers that\n-     * define the algorithm parameters.  Those integers are encoded\n-     * as big-endian byte arrays.\n-     *\n-     * @param p the DSS\/DSA parameter \"P\"\n-     * @param q the DSS\/DSA parameter \"Q\"\n-     * @param g the DSS\/DSA parameter \"G\"\n-     *\/\n-    public AlgIdDSA (byte[] p, byte[] q, byte[] g)\n-    throws IOException\n-    {\n-        this (new BigInteger (1, p),\n-            new BigInteger (1, q),\n-            new BigInteger (1, g));\n-    }\n-\n@@ -138,2 +112,1 @@\n-    public AlgIdDSA (BigInteger p, BigInteger q, BigInteger g)\n-    {\n+    public AlgIdDSA (BigInteger p, BigInteger q, BigInteger g) {\n@@ -171,5 +144,2 @@\n-    private void initializeParams ()\n-    throws IOException\n-    {\n-        DerOutputStream out = new DerOutputStream ();\n-\n+    private void initializeParams () throws IOException {\n+        DerOutputStream out = new DerOutputStream();\n@@ -179,1 +149,3 @@\n-        params = new DerValue (DerValue.tag_Sequence,out.toByteArray ());\n+        DerOutputStream result = new DerOutputStream();\n+        result.write(DerValue.tag_Sequence, out);\n+        encodedParams = result.toByteArray();\n@@ -186,4 +158,2 @@\n-    protected void decodeParams ()\n-    throws IOException\n-    {\n-        if (params == null)\n+    protected void decodeParams () throws IOException {\n+        if (encodedParams == null) {\n@@ -191,2 +161,6 @@\n-        if (params.tag != DerValue.tag_Sequence)\n-            throw new  IOException(\"DSA alg parsing error\");\n+        }\n+\n+        DerValue params = new DerValue(encodedParams);\n+        if (params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"DSA alg parsing error\");\n+        }\n@@ -209,2 +183,3 @@\n-    public String toString ()\n-        { return paramsToString (); }\n+    public String toString () {\n+        return paramsToString();\n+    }\n@@ -215,3 +190,2 @@\n-    protected String paramsToString ()\n-    {\n-        if (params == null)\n+    protected String paramsToString () {\n+        if (encodedParams == null) {\n@@ -219,6 +193,6 @@\n-        else\n-            return\n-                \"\\n    p:\\n\" + Debug.toHexString(p) +\n-                \"\\n    q:\\n\" + Debug.toHexString(q) +\n-                \"\\n    g:\\n\" + Debug.toHexString(g) +\n-                \"\\n\";\n+        } else {\n+            return \"\\n    p:\\n\" + Debug.toHexString(p) +\n+                    \"\\n    q:\\n\" + Debug.toHexString(q) +\n+                    \"\\n    g:\\n\" + Debug.toHexString(g) +\n+                    \"\\n\";\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgIdDSA.java","additions":26,"deletions":52,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,3 +80,1 @@\n-    @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n-    protected DerValue          params;\n-\n+    protected transient byte[] encodedParams;\n@@ -111,0 +109,12 @@\n+        if (algParams != null) {\n+            try {\n+                encodedParams = algParams.getEncoded();\n+            } catch (IOException ioe) {\n+                \/\/ It should be safe to ignore this.\n+                \/\/ This exception can occur if AlgorithmParameters was not\n+                \/\/ initialized (which should not occur), or if it was\n+                \/\/ initialized with bogus parameters, which should have\n+                \/\/ been detected when init was called.\n+                assert false;\n+            }\n+        }\n@@ -122,2 +132,2 @@\n-        this.params = params;\n-        if (this.params != null) {\n+        if (params != null) {\n+            encodedParams = params.toByteArray();\n@@ -142,1 +152,1 @@\n-        algParams.init(params.toByteArray());\n+        algParams.init(encodedParams.clone());\n@@ -161,0 +171,1 @@\n+    @Override\n@@ -167,8 +178,1 @@\n-        if (constructedFromDer == false) {\n-            if (algParams != null) {\n-                params = new DerValue(algParams.getEncoded());\n-            } else {\n-                params = null;\n-            }\n-        }\n-        if (params == null) {\n+        if (encodedParams == null) {\n@@ -226,1 +230,1 @@\n-            bytes.putDerValue(params);\n+            bytes.write(encodedParams);\n@@ -269,1 +273,1 @@\n-            if (params != null) {\n+            if (encodedParams != null) {\n@@ -272,1 +276,1 @@\n-                        AlgorithmId.parse(new DerValue(params.toByteArray()));\n+                        AlgorithmId.parse(new DerValue(encodedParams));\n@@ -307,4 +311,4 @@\n-        return (params == null ||\n-            algid.toString().equals(KnownOIDs.SpecifiedSHA2withECDSA.value()))\n-                ? null\n-                : params.toByteArray();\n+        return (encodedParams == null\n+                || algid.toString().equals(KnownOIDs.SpecifiedSHA2withECDSA.value()))\n+                    ? null\n+                    : encodedParams.clone();\n@@ -318,2 +322,2 @@\n-        boolean paramsEqual = Objects.equals(other.params, params);\n-        return (algid.equals((Object)other.algid) && paramsEqual);\n+        return algid.equals((Object)other.algid) &&\n+            Arrays.equals(encodedParams, other.encodedParams);\n@@ -329,0 +333,1 @@\n+    @Override\n@@ -355,0 +360,1 @@\n+    @Override\n@@ -356,4 +362,3 @@\n-        StringBuilder sbuf = new StringBuilder();\n-        sbuf.append(algid.toString());\n-        sbuf.append(paramsToString());\n-        return sbuf.toString().hashCode();\n+        int hashCode = algid.hashCode();\n+        hashCode = 31 * hashCode + Arrays.hashCode(encodedParams);\n+        return hashCode;\n@@ -367,1 +372,1 @@\n-        if (params == null) {\n+        if (encodedParams == null) {\n@@ -370,1 +375,1 @@\n-            return algParams.toString();\n+            return \", \" + algParams.toString();\n@@ -379,0 +384,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,1 +231,1 @@\n-        return new KeyRep(type, getAlgorithm(), format, getEncoded());\n+        return new KeyRep(type, getAlgorithm(), format, getEncodedInternal());\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Arrays;\n@@ -207,1 +208,6 @@\n-            return new ECPrivateKeyImpl(key.getEncoded());\n+            byte[] encoded = key.getEncoded();\n+            try {\n+                return new ECPrivateKeyImpl(encoded);\n+            } finally {\n+                Arrays.fill(encoded, (byte)0);\n+            }\n@@ -237,1 +243,6 @@\n-            return new ECPrivateKeyImpl(pkcsSpec.getEncoded());\n+            byte[] encoded = pkcsSpec.getEncoded();\n+            try {\n+                return new ECPrivateKeyImpl(encoded);\n+            } finally {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -273,1 +284,6 @@\n-                return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n+                byte[] encoded = key.getEncoded();\n+                try {\n+                    return keySpec.cast(new PKCS8EncodedKeySpec(encoded));\n+                } finally {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -127,0 +128,1 @@\n+            Arrays.fill(sArr, (byte)0);\n@@ -131,2 +133,2 @@\n-            DerValue val =\n-                new DerValue(DerValue.tag_Sequence, out.toByteArray());\n+            Arrays.fill(sOctets, (byte)0);\n+            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n@@ -134,0 +136,1 @@\n+            val.clear();\n@@ -150,0 +153,1 @@\n+            Arrays.fill(arrCopy, (byte)0);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -90,3 +91,8 @@\n-            XDHPrivateKeyImpl result =  new XDHPrivateKeyImpl(key.getEncoded());\n-            checkLockedParams(InvalidKeyException::new, result.getParams());\n-            return result;\n+            byte[] encoded = key.getEncoded();\n+            try {\n+                XDHPrivateKeyImpl result = new XDHPrivateKeyImpl(encoded);\n+                checkLockedParams(InvalidKeyException::new, result.getParams());\n+                return result;\n+            } finally {\n+                Arrays.fill(encoded, (byte)0);\n+            }\n@@ -168,5 +174,9 @@\n-            XDHPrivateKeyImpl result =\n-                new XDHPrivateKeyImpl(pkcsSpec.getEncoded());\n-            checkLockedParams(InvalidKeySpecException::new,\n-                result.getParams());\n-            return result;\n+            byte[] encoded = pkcsSpec.getEncoded();\n+            try {\n+                XDHPrivateKeyImpl result = new XDHPrivateKeyImpl(encoded);\n+                checkLockedParams(InvalidKeySpecException::new,\n+                        result.getParams());\n+                return result;\n+            } finally {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -178,1 +188,6 @@\n-            return new XDHPrivateKeyImpl(params, privateKeySpec.getScalar());\n+            byte[] scalar = privateKeySpec.getScalar();\n+            try {\n+                return new XDHPrivateKeyImpl(params, scalar);\n+            } finally {\n+                Arrays.fill(scalar, (byte)0);\n+            }\n@@ -213,1 +228,6 @@\n-                return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n+                byte[] encoded = key.getEncoded();\n+                try {\n+                    return keySpec.cast(new PKCS8EncodedKeySpec(encoded));\n+                } finally {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n@@ -219,2 +239,6 @@\n-                return keySpec.cast(\n-                    new XECPrivateKeySpec(xecKey.getParams(), scalar));\n+                try {\n+                    return keySpec.cast(\n+                            new XECPrivateKeySpec(xecKey.getParams(), scalar));\n+                } finally {\n+                    Arrays.fill(scalar, (byte)0);\n+                }\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-        DerOutputStream derKey = new DerOutputStream();\n+\n+        DerValue val = new DerValue(DerValue.tag_OctetString, k);\n@@ -54,2 +55,1 @@\n-            derKey.putOctetString(k);\n-            this.key = derKey.toByteArray();\n+            this.key = val.toByteArray();\n@@ -58,0 +58,2 @@\n+        } finally {\n+            val.clear();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -82,4 +83,9 @@\n-            EdDSAPrivateKeyImpl result =\n-                new EdDSAPrivateKeyImpl(key.getEncoded());\n-            checkLockedParams(InvalidKeyException::new, result.getParams());\n-            return result;\n+            byte[] encoded = key.getEncoded();\n+            try {\n+                EdDSAPrivateKeyImpl result =\n+                        new EdDSAPrivateKeyImpl(encoded);\n+                checkLockedParams(InvalidKeyException::new, result.getParams());\n+                return result;\n+            } finally {\n+                Arrays.fill(encoded, (byte)0);\n+            }\n@@ -161,5 +167,10 @@\n-            EdDSAPrivateKeyImpl result =\n-                new EdDSAPrivateKeyImpl(pkcsSpec.getEncoded());\n-            checkLockedParams(InvalidKeySpecException::new,\n-                result.getParams());\n-            return result;\n+            byte[] encoded = pkcsSpec.getEncoded();\n+            try {\n+                EdDSAPrivateKeyImpl result =\n+                        new EdDSAPrivateKeyImpl(encoded);\n+                checkLockedParams(InvalidKeySpecException::new,\n+                        result.getParams());\n+                return result;\n+            } finally {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -171,1 +182,6 @@\n-            return new EdDSAPrivateKeyImpl(params, privateKeySpec.getBytes());\n+            byte[] bytes = privateKeySpec.getBytes();\n+            try {\n+                return new EdDSAPrivateKeyImpl(params, bytes);\n+            } finally {\n+                Arrays.fill(bytes, (byte)0);\n+            }\n@@ -206,1 +222,6 @@\n-                return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n+                byte[] encoded = key.getEncoded();\n+                try {\n+                    return keySpec.cast(new PKCS8EncodedKeySpec(encoded));\n+                } finally {\n+                    Arrays.fill(encoded, (byte)0);\n+                }\n@@ -212,2 +233,6 @@\n-                return keySpec.cast(\n-                    new EdECPrivateKeySpec(edKey.getParams(), scalar));\n+                try {\n+                    return keySpec.cast(\n+                            new EdECPrivateKeySpec(edKey.getParams(), scalar));\n+                } finally {\n+                    Arrays.fill(scalar, (byte)0);\n+                }\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        DerOutputStream derKey = new DerOutputStream();\n+        DerValue val = new DerValue(DerValue.tag_OctetString, h);\n@@ -56,2 +56,1 @@\n-            derKey.putOctetString(h);\n-            this.key = derKey.toByteArray();\n+            this.key = val.toByteArray();\n@@ -60,0 +59,2 @@\n+        } finally {\n+            val.clear();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    static final String EXPECTED_ALG_ID_CHRS = \"DSA\\n\" +\n+    static final String EXPECTED_ALG_ID_CHRS = \"DSA, \\n\" +\n@@ -79,2 +79,1 @@\n-        PKCS8Key decodedKey = (PKCS8Key)PKCS8Key.parseKey(\n-                new DerValue(encodedKey));\n+        PKCS8Key decodedKey = (PKCS8Key)PKCS8Key.parseKey(encodedKey);\n@@ -82,4 +81,4 @@\n-        Assert.assertEquals(ALGORITHM, decodedKey.getAlgorithm());\n-        Assert.assertEquals(FORMAT, decodedKey.getFormat());\n-        Assert.assertEquals(EXPECTED_ALG_ID_CHRS,\n-                decodedKey.getAlgorithmId().toString());\n+        Assert.assertEquals(decodedKey.getAlgorithm(), ALGORITHM);\n+        Assert.assertEquals(decodedKey.getFormat(), FORMAT);\n+        Assert.assertEquals(decodedKey.getAlgorithmId().toString(),\n+                EXPECTED_ALG_ID_CHRS);\n@@ -123,1 +122,1 @@\n-        PKCS8Key.parseKey(new DerValue(original));\n+        PKCS8Key.parseKey(original);\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -101,2 +101,1 @@\n-                \/\/ skip cloning for testing key.\n-                return encodedPriv;\n+                return encodedPriv.clone();\n@@ -117,2 +116,1 @@\n-                \/\/ skip cloning for testing key.\n-                return encodedPub;\n+                return encodedPub.clone();\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestKeyFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,2 +100,1 @@\n-                \/\/ skip cloning for testing key.\n-                return encodedPriv;\n+                return encodedPriv.clone();\n@@ -116,2 +115,1 @@\n-                \/\/ skip cloning for testing key.\n-                return encodedPub;\n+                return encodedPub.clone();\n","filename":"test\/jdk\/sun\/security\/rsa\/TestKeyFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}