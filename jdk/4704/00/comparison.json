{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -34,0 +35,17 @@\n+static void startTestThread(JavaThread* thread, const char* name) {\n+  EXCEPTION_MARK;\n+  HandleMark hm(THREAD);\n+  Handle thread_oop;\n+\n+  \/\/ This code can be called from the main thread, which is _thread_in_native,\n+  \/\/ or by an existing JavaTestThread, which is _thread_in_vm.\n+  if (THREAD->thread_state() == _thread_in_native) {\n+    ThreadInVMfromNative tivfn(THREAD);\n+    thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK);\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NoPriority);\n+  } else {\n+    thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK);\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NoPriority);\n+  }\n+}\n+\n@@ -47,1 +65,0 @@\n-public:\n@@ -50,12 +67,4 @@\n-  VMThreadBlocker() {}\n-  virtual ~VMThreadBlocker() {}\n-  const char* get_thread_name_string(char* buf, int buflen) const {\n-    return \"VMThreadBlocker\";\n-  }\n-  void run() {\n-    this->set_thread_state(_thread_in_vm);\n-    {\n-      MutexLocker ml(Threads_lock);\n-      Threads::add(this);\n-    }\n-    VM_StopSafepoint ss(&_ready, &_unblock);\n+\n+  static void blocker_thread_entry(JavaThread* thread, TRAPS) {\n+    VMThreadBlocker* t = static_cast<VMThreadBlocker*>(thread);\n+    VM_StopSafepoint ss(&t->_ready, &t->_unblock);\n@@ -65,6 +74,1 @@\n-  \/\/ Override as JavaThread::post_run() calls JavaThread::exit which\n-  \/\/ expects a valid thread object oop.\n-  virtual void post_run() {\n-    Threads::remove(this, false);\n-    this->smr_delete();\n-  }\n+  VMThreadBlocker() : JavaThread(&blocker_thread_entry) {};\n@@ -72,6 +76,10 @@\n-  void doit() {\n-    if (os::create_thread(this, os::os_thread)) {\n-      os::start_thread(this);\n-    } else {\n-      ASSERT_TRUE(false);\n-    }\n+  virtual ~VMThreadBlocker() {}\n+\n+public:\n+  \/\/ Convenience method for client code\n+  static VMThreadBlocker* start() {\n+    const char* name = \"VMThreadBlocker\";\n+    VMThreadBlocker* thread = new VMThreadBlocker();\n+    JavaThread::vm_exit_on_osthread_failure(thread);\n+    startTestThread(thread, name);\n+    return thread;\n@@ -79,0 +87,1 @@\n+\n@@ -89,1 +98,0 @@\n-public:\n@@ -91,0 +99,2 @@\n+\n+protected:\n@@ -92,1 +102,2 @@\n-    : _post(post) {\n+    : JavaThread(&test_thread_entry), _post(post) {\n+    JavaThread::vm_exit_on_osthread_failure(this);\n@@ -96,10 +107,4 @@\n-  const char* get_thread_name_string(char* buf, int buflen) const {\n-    return \"JavaTestThread\";\n-  }\n-\n-  void pre_run() {\n-    this->set_thread_state(_thread_in_vm);\n-    {\n-      MutexLocker ml(Threads_lock);\n-      Threads::add(this);\n-    }\n+public:\n+  \/\/ simplified starting for callers and subclasses\n+  void doit() {\n+    startTestThread(this, \"JavaTestThread\");\n@@ -110,18 +115,4 @@\n-  void run() {\n-    main_run();\n-  }\n-\n-  \/\/ Override as JavaThread::post_run() calls JavaThread::exit which\n-  \/\/ expects a valid thread object oop. And we need to call signal.\n-  void post_run() {\n-    Threads::remove(this, false);\n-    _post->signal();\n-    this->smr_delete();\n-  }\n-\n-  void doit() {\n-    if (os::create_thread(this, os::os_thread)) {\n-      os::start_thread(this);\n-    } else {\n-      ASSERT_TRUE(false);\n-    }\n+  static void test_thread_entry(JavaThread* thread, TRAPS) {\n+    JavaTestThread* t = static_cast<JavaTestThread*>(thread);\n+    t->main_run();\n+    t->_post->signal();\n@@ -133,1 +124,0 @@\n-public:\n@@ -135,0 +125,1 @@\n+public:\n@@ -150,2 +141,2 @@\n-  VMThreadBlocker* blocker = new VMThreadBlocker();\n-  blocker->doit();\n+  VMThreadBlocker* blocker = VMThreadBlocker::start();\n+\n@@ -165,2 +156,2 @@\n-  VMThreadBlocker* blocker = new VMThreadBlocker();\n-  blocker->doit();\n+  VMThreadBlocker* blocker = VMThreadBlocker::start();\n+\n","filename":"test\/hotspot\/gtest\/threadHelper.inline.hpp","additions":51,"deletions":60,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1068,0 +1068,2 @@\n+  Semaphore run;\n+\n@@ -1069,2 +1071,2 @@\n-  MT_BD_Thread(Semaphore* post, TestTable::BulkDeleteTask* bd)\n-    : JavaTestThread(post), _bd(bd){}\n+  MT_BD_Thread(Semaphore* post)\n+    : JavaTestThread(post) {}\n@@ -1073,0 +1075,1 @@\n+    run.wait();\n@@ -1077,0 +1080,5 @@\n+  void set_bd_task(TestTable::BulkDeleteTask* bd) {\n+    _bd = bd;\n+    run.signal();\n+  }\n+\n@@ -1101,2 +1109,0 @@\n-    TestTable::BulkDeleteTask bdt(cht, true \/* mt *\/ );\n-    EXPECT_TRUE(bdt.prepare(this)) << \"Uncontended prepare must work.\";\n@@ -1104,0 +1110,1 @@\n+    \/\/ Must create and start threads before acquiring mutex inside BulkDeleteTask.\n@@ -1106,1 +1113,1 @@\n-      tt[i] = new MT_BD_Thread(&done, &bdt);\n+      tt[i] = new MT_BD_Thread(&done);\n@@ -1110,0 +1117,7 @@\n+    TestTable::BulkDeleteTask bdt(cht, true \/* mt *\/ );\n+    EXPECT_TRUE(bdt.prepare(this)) << \"Uncontended prepare must work.\";\n+\n+    for (int i = 0; i < 4; i++) {\n+      tt[i]->set_bd_task(&bdt);\n+    }\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"}]}