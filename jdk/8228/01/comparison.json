{"files":[{"patch":"@@ -654,0 +654,7 @@\n+    case Op_Blackhole: {\n+      add_local_var(n, PointsToNode::GlobalEscape);\n+      \/\/ Do not add edges during first iteration because some could be\n+      \/\/ not defined yet.\n+      delayed_worklist->push(n);\n+      break;\n+    }\n@@ -803,0 +810,20 @@\n+    case Op_Blackhole: {\n+      \/\/ All blackhole pointer arguments are globally escaping.\n+      for (uint i = 0; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in != nullptr) {\n+          const Type* at = _igvn->type(in);\n+          if (!at->isa_ptr()) continue;\n+\n+          if (in->is_AddP()) {\n+            in = get_addp_base(in);\n+          }\n+\n+          PointsToNode* ptn = ptnode_adr(in->_idx);\n+          assert(ptn != nullptr, \"should be defined already\");\n+          set_escape_state(ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA \"blackhole\"));\n+          add_edge(n_ptn, ptn);\n+        }\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284848\n+ * @requires vm.compiler2.enabled\n+ * @summary Blackhole arguments are globally escaping, thus preventing advanced EA optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.blackhole.BlackholeStoreStoreEATest\n+ *\/\n+\n+package compiler.c2.irTests.blackhole;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class BlackholeStoreStoreEATest {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=blackhole,compiler.c2.irTests.blackhole.BlackholeStoreStoreEATest::blackhole\"\n+        );\n+    }\n+\n+    \/*\n+     * Negative test is not possible: the StoreStore barrier is still in, even if we just do dontinline.\n+     * Positive test: check that blackhole keeps the StoreStore barrier in.\n+     *\/\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    static void testBlackholed() {\n+        Object o = new Object();\n+        blackhole(o);\n+    }\n+\n+    static void blackhole(Object o) {}\n+\n+    @Run(test = \"testBlackholed\")\n+    static void runBlackholed() {\n+        testBlackholed();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/blackhole\/BlackholeStoreStoreEATest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284848\n+ * @requires vm.compiler2.enabled\n+ * @summary Blackhole arguments are globally escaping, thus preventing advanced EA optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.blackhole.BlackholeSyncEATest\n+ *\/\n+\n+package compiler.c2.irTests.blackhole;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class BlackholeSyncEATest {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=blackhole,compiler.c2.irTests.blackhole.BlackholeSyncEATest::blackhole\",\n+            \"-XX:CompileCommand=dontinline,compiler.c2.irTests.blackhole.BlackholeSyncEATest::dontinline\"\n+        );\n+    }\n+\n+    \/*\n+     * Negative test: check that dontinline method still allows EA to eliminate the synchronization.\n+     *\/\n+\n+    @Test\n+    @IR(failOn = {IRNode.FAST_LOCK, IRNode.FAST_UNLOCK})\n+    static void testDontline() {\n+        Object o = new Object();\n+        synchronized (o) {}\n+        dontinline(o);\n+    }\n+\n+    static void dontinline(Object o) {}\n+\n+    @Run(test = \"testDontline\")\n+    static void runDontinline() {\n+        testDontline();\n+    }\n+\n+    \/*\n+     * Positive test: check that blackhole keeps the synchronization in.\n+     *\/\n+\n+    @Test\n+    @IR(counts = {IRNode.FAST_LOCK, \"1\"})\n+    @IR(counts = {IRNode.FAST_UNLOCK, \"1\"})\n+    static void testBlackholed() {\n+        Object o = new Object();\n+        synchronized (o) {}\n+        blackhole(o);\n+    }\n+\n+    static void blackhole(Object o) {}\n+\n+    @Run(test = \"testBlackholed\")\n+    static void runBlackholed() {\n+        testBlackholed();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/blackhole\/BlackholeSyncEATest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -140,0 +140,1 @@\n+    public static final String MEMBAR_STORESTORE = START + \"MemBarStoreStore\" + MID + END;\n@@ -189,0 +190,3 @@\n+    public static final String FAST_LOCK   = START + \"FastLock\" + MID + END;\n+    public static final String FAST_UNLOCK = START + \"FastUnlock\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}