{"files":[{"patch":"@@ -163,1 +163,1 @@\n-    _collector->update_attribute_table(hr);\n+    _collector->before_marking_update_attribute_table(hr);\n@@ -232,1 +232,1 @@\n-void G1FullCollector::update_attribute_table(HeapRegion* hr, bool force_not_compacted) {\n+void G1FullCollector::before_marking_update_attribute_table(HeapRegion* hr) {\n@@ -234,1 +234,2 @@\n-    _region_attr_table.set_invalid(hr->hrm_index());\n+    \/\/ Set as Invalid by default.\n+    _region_attr_table.verify_is_invalid(hr->hrm_index());\n@@ -237,2 +238,2 @@\n-  } else if (hr->is_pinned() || force_not_compacted) {\n-    _region_attr_table.set_not_compacted(hr->hrm_index());\n+  } else if (hr->is_pinned()) {\n+    _region_attr_table.set_skip_compacting(hr->hrm_index());\n@@ -240,2 +241,2 @@\n-    \/\/ Everything else is processed normally.\n-    _region_attr_table.set_compacted(hr->hrm_index());\n+    \/\/ Everything else should be compacted.\n+    _region_attr_table.set_compacting(hr->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  void update_attribute_table(HeapRegion* hr, bool force_not_compacted = false);\n+  void before_marking_update_attribute_table(HeapRegion* hr);\n@@ -108,2 +108,2 @@\n-  inline bool is_compacted(oop obj) const;\n-  inline bool is_compacted_or_skip_marking(uint region_index) const;\n+  inline bool is_compacting(oop obj) const;\n+  inline bool is_skip_compacting(uint region_index) const;\n@@ -112,0 +112,3 @@\n+  inline void set_invalid(uint region_idx);\n+  inline void update_from_compacting_to_skip_compacting(uint region_idx);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-bool G1FullCollector::is_compacted(oop obj) const {\n-  return _region_attr_table.is_compacted(cast_from_oop<HeapWord*>(obj));\n+bool G1FullCollector::is_compacting(oop obj) const {\n+  return _region_attr_table.is_compacting(cast_from_oop<HeapWord *>(obj));\n@@ -37,2 +37,2 @@\n-bool G1FullCollector::is_compacted_or_skip_marking(uint region_index) const {\n-  return _region_attr_table.is_compacted_or_skip_marking(region_index);\n+bool G1FullCollector::is_skip_compacting(uint region_index) const {\n+  return _region_attr_table.is_skip_compacting(region_index);\n@@ -45,0 +45,9 @@\n+void G1FullCollector::set_invalid(uint region_idx) {\n+  _region_attr_table.set_invalid(region_idx);\n+}\n+\n+void G1FullCollector::update_from_compacting_to_skip_compacting(uint region_idx) {\n+  _region_attr_table.verify_is_compacting(region_idx);\n+  _region_attr_table.set_skip_compacting(region_idx);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-\/\/ Do work for all not-compacted regions.\n-class G1ResetNotCompactedClosure : public HeapRegionClosure {\n+\/\/ Do work for all skip-compacting regions.\n+class G1ResetSkipCompactingClosure : public HeapRegionClosure {\n@@ -43,1 +43,1 @@\n-  G1ResetNotCompactedClosure(G1FullCollector* collector) : _collector(collector) { }\n+  G1ResetSkipCompactingClosure(G1FullCollector* collector) : _collector(collector) { }\n@@ -47,2 +47,3 @@\n-    \/\/ There is nothing to do for compacted or skip marking regions.\n-    if (_collector->is_compacted_or_skip_marking(region_index)) {\n+    \/\/ Only for skip-compaction regions; early return otherwise.\n+    if (!_collector->is_skip_compacting(region_index)) {\n+\n@@ -52,4 +53,4 @@\n-           !r->is_starts_humongous() ||\n-           _collector->mark_bitmap()->is_marked(cast_to_oop(r->bottom())),\n-           \"must be, otherwise reclaimed earlier\");\n-    r->reset_not_compacted_after_full_gc();\n+         !r->is_starts_humongous() ||\n+         _collector->mark_bitmap()->is_marked(cast_to_oop(r->bottom())),\n+         \"must be, otherwise reclaimed earlier\");\n+    r->reset_skip_compacting_after_full_gc();\n@@ -100,1 +101,1 @@\n-  G1ResetNotCompactedClosure hc(collector());\n+  G1ResetSkipCompactingClosure hc(collector());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,5 +31,5 @@\n-\/\/ fast access during the full collection. In particular some parts of the region\n-\/\/ type information is encoded in these per-region bytes.\n-\/\/ Value encoding has been specifically chosen to make required accesses fast.\n-\/\/ In particular, the table collects whether a region should be compacted, not\n-\/\/ compacted, or marking (liveness analysis) completely skipped.\n+\/\/ fast access during the full collection. In particular some parts of the\n+\/\/ region type information is encoded in these per-region bytes. Value encoding\n+\/\/ has been specifically chosen to make required accesses fast. In particular,\n+\/\/ the table specifies whether a Full GC cycle should be compacting, skip\n+\/\/ compacting, or skip marking (liveness analysis) a region.\n@@ -41,2 +41,2 @@\n-  static const uint8_t Compacted = 0;        \/\/ Region will be compacted.\n-  static const uint8_t NotCompacted = 1;     \/\/ Region should not be compacted, but otherwise handled as usual.\n+  static const uint8_t Compacting = 0;       \/\/ Region will be compacted.\n+  static const uint8_t SkipCompacting = 1;   \/\/ Region should not be compacted, but otherwise handled as usual.\n@@ -56,1 +56,2 @@\n-  void set_compacted(uint idx) { set_by_index(idx, Compacted); }\n+\n+  void set_compacting(uint idx) { set_by_index(idx, Compacting); }\n@@ -58,1 +59,1 @@\n-  void set_not_compacted(uint idx) { set_by_index(idx, NotCompacted); }\n+  void set_skip_compacting(uint idx) { set_by_index(idx, SkipCompacting); }\n@@ -65,1 +66,1 @@\n-  bool is_compacted(HeapWord* obj) const {\n+  bool is_compacting(HeapWord* obj) const {\n@@ -67,1 +68,1 @@\n-    return get_by_address(obj) == Compacted;\n+    return get_by_address(obj) == Compacting;\n@@ -70,2 +71,2 @@\n-  bool is_compacted_or_skip_marking(uint idx) const {\n-    return get_by_index(idx) != NotCompacted;\n+  bool is_skip_compacting(uint idx) const {\n+    return get_by_index(idx) == SkipCompacting;\n@@ -73,0 +74,4 @@\n+\n+  void verify_is_compacting(uint idx) { assert(get_by_index(idx) == Compacting, \"invariant\"); }\n+\n+  void verify_is_invalid(uint idx) { assert(get_by_index(idx) == Invalid, \"invariant\"); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-      _collector->is_compacted(obj)) {\n+      _collector->is_compacting(obj)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-  if (!_collector->is_compacted(obj)) {\n-    \/\/ We never forward objects in non-compacted regions so there is no need to\n+  if (!_collector->is_compacting(obj)) {\n+    \/\/ We never forward objects in non-compacting regions so there is no need to\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1FullCollector.hpp\"\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -51,0 +51,1 @@\n+  _collector->set_invalid(hr->hrm_index());\n@@ -79,3 +80,2 @@\n-      \/\/ Force the high live ratio region as not-compacting to skip these regions in the\n-      \/\/ later compaction step.\n-      force_not_compacted = true;\n+      \/\/ Too many live objects; skip compacting it.\n+      _collector->update_from_compacting_to_skip_compacting(hr->hrm_index());\n@@ -96,1 +96,0 @@\n-  _collector->update_attribute_table(hr, force_not_compacted);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -173,2 +173,2 @@\n-  \/\/ Update pinned heap region (not compacted) to be consistent after Full GC.\n-  void reset_not_compacted_after_full_gc();\n+  \/\/ Update skip-compacting heap region to be consistent after Full GC.\n+  void reset_skip_compacting_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-inline void HeapRegion::reset_not_compacted_after_full_gc() {\n+inline void HeapRegion::reset_skip_compacting_after_full_gc() {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}