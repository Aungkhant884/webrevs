{"files":[{"patch":"@@ -2765,12 +2765,8 @@\n-\/\/------------------------------Ideal_masked_input-----------------------------\n-\/\/ Check for a useless mask before a partial-word store\n-\/\/ (StoreB ... (AndI valIn conIa) )\n-\/\/ If (conIa & mask == mask) this simplifies to\n-\/\/ (StoreB ... (valIn) )\n-Node *StoreNode::Ideal_masked_input(PhaseGVN *phase, uint mask) {\n-  Node *val = in(MemNode::ValueIn);\n-  if( val->Opcode() == Op_AndI ) {\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() & mask) == mask ) {\n-      set_req_X(MemNode::ValueIn, val->in(1), phase);\n-      return this;\n+\/\/------------------------------used_only_for_this_opcode--------------\n+\/\/ Check if all use nodes of the given node have the same opcode as\n+\/\/ current node, *this.\n+bool StoreNode::used_only_for_this_opcode(Node* node) {\n+  for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n+    Node* use = node->fast_out(i);\n+    if (use->Opcode() != Opcode()) {\n+      return false;\n@@ -2779,1 +2775,22 @@\n-  return NULL;\n+  return true;\n+}\n+\n+\/\/------------------------------no_need_sign_extension-----------------------\n+\/\/ Check whether the given operation on byte\/short types holds that the upper\n+\/\/ bits of the operands have no influence on real lower bits of the\n+\/\/ operation result. If so, there is no need to do any sign extension before\n+\/\/ the given subword interger operation. So that we can optimize it out by\n+\/\/ StoreNode::Ideal_masked_or_sign_extended_input.\n+bool StoreNode::no_need_sign_extension(int opc) {\n+  switch (opc) {\n+    case Op_AddI:\n+    case Op_SubI:\n+    case Op_NegI:\n+    case Op_MulI:\n+    case Op_XorI:\n+    case Op_AndI:\n+    case Op_OrI:\n+    case Op_LShiftI:\n+      return true;\n+  }\n+  return false;\n@@ -2782,0 +2799,12 @@\n+\/\/------------------------------is_masked_input-------------------------\n+\/\/ Check if the node can be recognized as the pattern:\n+\/\/ (AndI valIn conIa) and (conIa & mask == mask)\n+bool StoreNode::is_masked_input(Node* input, PhaseGVN* phase, uint mask) {\n+  if (input->Opcode() == Op_AndI) {\n+    const TypeInt* t = phase->type(input->in(2))->isa_int();\n+    if (t && t->is_con() && (t->get_con() & mask) == mask) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n@@ -2783,16 +2812,12 @@\n-\/\/------------------------------Ideal_sign_extended_input----------------------\n-\/\/ Check for useless sign-extension before a partial-word store\n-\/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n-\/\/ If (conIL == conIR && conIR <= num_bits)  this simplifies to\n-\/\/ (StoreB ... (valIn) )\n-Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n-  Node *val = in(MemNode::ValueIn);\n-  if( val->Opcode() == Op_RShiftI ) {\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n-      Node *shl = val->in(1);\n-      if( shl->Opcode() == Op_LShiftI ) {\n-        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n-        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n-          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n-          return this;\n+\/\/----------------------------is_sign_extended_input-----------------------\n+\/\/ Check if the node can be recognized as the pattern\n+\/\/ (RShiftI _ (LShiftI _ valIn conIL ) conIR) and (conIL == conIR && conIR <= num_bits)\n+bool StoreNode::is_sign_extended_input(Node* input, PhaseGVN* phase, int num_bits) {\n+  if (input->Opcode() == Op_RShiftI) {\n+    const TypeInt* t = phase->type(input->in(2))->isa_int();\n+    if (t && t->is_con() && (t->get_con() <= num_bits)) {\n+      Node* shl = input->in(1);\n+      if (shl->Opcode() == Op_LShiftI) {\n+        const TypeInt* t2 = phase->type(shl->in(2))->isa_int();\n+        if (t2 && t2->is_con() && (t2->get_con() == t->get_con())) {\n+          return true;\n@@ -2803,0 +2828,61 @@\n+  return false;\n+}\n+\n+\/\/------------------------------Ideal_masked_or_sign_extended_input-----------------------------\n+\/\/ Check for a useless mask or useless sign-extension before a subword store\n+Node* StoreNode::Ideal_masked_or_sign_extended_input(PhaseGVN* phase, uint mask, int num_bits) {\n+  Node* val = in(MemNode::ValueIn);\n+  \/\/ (StoreB ... (AndI valIn conIa) )\n+  \/\/ If (conIa & mask == mask) this simplifies to\n+  \/\/ (StoreB ... (valIn) )\n+  if (is_masked_input(val, phase, mask)) {\n+    set_req_X(MemNode::ValueIn, val->in(1), phase);\n+    return this;\n+  }\n+\n+  \/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n+  \/\/ If (conIL == conIR && conIR <= num_bits)  this simplifies to\n+  \/\/ (StoreB ... (valIn) )\n+  if (is_sign_extended_input(val, phase, num_bits)) {\n+    Node* shl = val->in(1);\n+    set_req_X(MemNode::ValueIn, shl->in(1), phase);\n+    return this;\n+  }\n+\n+  if (no_need_sign_extension(val->Opcode())) {\n+    Node* orig_value = NULL;\n+    int idx = 0;\n+    for (uint i = 1; i < val->req(); ++i) {\n+      \/\/ Further constraint for no_need_sign_extension():\n+      \/\/ Only the first operand of LSfhitI is optimizable,\n+      \/\/ i.e. its upper bits have no influence to the result.\n+      if (val->Opcode() == Op_LShiftI && i != 1) {\n+        break;\n+      }\n+      \/\/ (StoreB ... (AddI (AndI valIn1 conIa) valIn2 )\n+      \/\/ If (conIa & mask == mask) this simplifies to\n+      \/\/ (StoreB ... (AddI valIn1, valIn2) )\n+      if (is_masked_input(val->in(i), phase, mask)) {\n+        idx = i;\n+        orig_value = val->in(i)->in(1);\n+        break;\n+      }\n+      \/\/ (StoreB ... (AddI (RShiftI _ (LShiftI _ valIn1 conIL ) conIR) valIn2) )\n+      \/\/ If (conIL == conIR && conIR <= num_bits)  this simplifies to\n+      \/\/ (StoreB ... (AddI valIn1, valIn2) )\n+      if (is_sign_extended_input(val->in(i), phase, num_bits)) {\n+        idx = i;\n+        orig_value = val->in(i)->in(1)->in(1);\n+        break;\n+      }\n+    }\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    if (igvn != NULL && orig_value != NULL && used_only_for_this_opcode(val)) {\n+      igvn->replace_input_of(val, idx, orig_value);\n+      return this;\n+    } else if (igvn == NULL && orig_value != NULL) {\n+      \/\/ We can try it again during the next IGVN once the graph is cleaner.\n+      phase->record_for_igvn(this);\n+    }\n+  }\n+\n@@ -2859,5 +2945,2 @@\n-Node *StoreBNode::Ideal(PhaseGVN *phase, bool can_reshape){\n-  Node *progress = StoreNode::Ideal_masked_input(phase, 0xFF);\n-  if( progress != NULL ) return progress;\n-\n-  progress = StoreNode::Ideal_sign_extended_input(phase, 24);\n+Node* StoreBNode::Ideal(PhaseGVN* phase, bool can_reshape){\n+  Node* progress = StoreNode::Ideal_masked_or_sign_extended_input(phase, 0xFF, 24);\n@@ -2873,6 +2956,4 @@\n-\/\/ we can skip the AND operation\n-Node *StoreCNode::Ideal(PhaseGVN *phase, bool can_reshape){\n-  Node *progress = StoreNode::Ideal_masked_input(phase, 0xFFFF);\n-  if( progress != NULL ) return progress;\n-\n-  progress = StoreNode::Ideal_sign_extended_input(phase, 16);\n+\/\/ we can skip the AND operation. If the store is from a sign-extension\n+\/\/ (a left shift, then right shift) we can skip both.\n+Node* StoreCNode::Ideal(PhaseGVN* phase, bool can_reshape){\n+  Node* progress = StoreNode::Ideal_masked_or_sign_extended_input(phase, 0xFFFF, 16);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":121,"deletions":40,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -562,2 +562,6 @@\n-  Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);\n-  Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);\n+  bool used_only_for_this_opcode(Node* in);\n+  bool no_need_sign_extension(int opc);\n+  bool is_masked_input(Node* input, PhaseGVN* phase, uint mask);\n+  bool is_sign_extended_input(Node* input, PhaseGVN* phase, int num_bits);\n+\n+  Node* Ideal_masked_or_sign_extended_input(PhaseGVN* phase, uint mask, int num_bits);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8282470\n+ * @summary C2: Optimize patterns like s = (short) ((x << Imm) >> Imm + y) when Imm < 16 and apply the optimization to byte and char.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIRStoreCorBAddIMask\n+ *\/\n+public class TestIRStoreCorBAddIMask {\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private static final int[] SPECIAL_IN = {\n+        0, 0x1, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x80, 0x81, 0x8F, 0xF3, 0xF8, 0xFF,\n+        0x38FF, 0x3FFF, 0x8F8F, 0x8FFF, 0x7FF3, 0x7FFF, 0xFF33, 0xFFF8, 0xFFFF, 0xFFFFFF,\n+        Integer.MAX_VALUE, Integer.MIN_VALUE\n+    };\n+\n+    private byte BYTE_OUT = 0;\n+    private char CHAR_OUT = 0;\n+    private short SHORT_OUT = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.ADD_I, \"1\", IRNode.STORE_B, \"1\"})\n+    public void testByte0(int x, int y) {\n+        BYTE_OUT = (byte) (((x << 24) >> 24) + y); \/\/ transformed to (byte) (x + y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.MUL_I, \"1\", IRNode.STORE_B, \"1\"})\n+    public void testByte1(int x, int y) {\n+        BYTE_OUT = (byte) (((x << 8) >> 8) * y); \/\/ transformed to (byte) (x * y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.SUB_I, \"1\", IRNode.STORE_B, \"1\"})\n+    public void testByte2(int x, int y) {\n+        BYTE_OUT = (byte) (((x << 16) >> 16) - y); \/\/ transformed to (byte) (x - y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT})\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.SUB_I, \"1\", IRNode.STORE_B, \"1\"})\n+    public void testByte3(int x) {\n+        BYTE_OUT = (byte) (-((x << 16) >> 16)); \/\/ transformed to (byte) (-x)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\", IRNode.RSHIFT_I, \"1\", IRNode.OR_I, \"1\", IRNode.STORE_B, \"1\"})\n+    public void testByte4(int x, int y) {\n+        BYTE_OUT = (byte) (((x << 25) >> 25) | y); \/\/ no transformation\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.AND_I})\n+    @IR(counts = {IRNode.XOR_I, \"1\", IRNode.STORE_B, \"1\"})\n+    public void testByte5(int x, int y) {\n+        BYTE_OUT = (byte) ((x & 0xFF) ^ y); \/\/ transformed to (byte) (x ^ y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.AND_I, \"2\", IRNode.STORE_B, \"1\"})\n+    public void testByte6(int x, int y) {\n+        BYTE_OUT = (byte) ((x & 0xF) & y); \/\/ no transformation\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.AND_I})\n+    @IR(counts = {IRNode.ADD_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testChar0(int x, int y) {\n+        CHAR_OUT = (char) ((x & 0xFFFF) + y); \/\/ transformed to (char) (x + y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.AND_I})\n+    @IR(counts = {IRNode.MUL_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testChar1(int x, int y) {\n+        CHAR_OUT = (char) ((x & 0xFFFF) * y); \/\/ transformed to (char) (x * y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.AND_I})\n+    @IR(counts = {IRNode.SUB_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testChar2(int x, int y) {\n+        CHAR_OUT = (char) ((x & 0xFFFF) - y); \/\/ transformed to (char) (x - y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.AND_I, \"2\", IRNode.STORE_C, \"1\"})\n+    public void testChar3(int x, int y) {\n+        CHAR_OUT = (char) ((x & 0xFF) & y); \/\/ no transformation\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.OR_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testShort0(int x, int y) {\n+        SHORT_OUT = (short) (((x << 16) >> 16) | y); \/\/ transformed to (short) (x | y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.AND_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testShort1(int x, int y) {\n+        SHORT_OUT = (short) (((x << 10) >> 10) & y); \/\/ transformed to (short) (x & y)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\", IRNode.RSHIFT_I, \"1\", IRNode.XOR_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testShort2(int x, int y) {\n+        SHORT_OUT = (short) (((x << 18) >> 18) ^ y); \/\/ no transformation\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = {IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\", IRNode.STORE_C, \"1\"})\n+    public void testShort3(int x, int y) {\n+        SHORT_OUT = (short) (((x << 16) >> 16) << y); \/\/ transformed to (short) (x << y)\n+    }\n+\n+    @Test\n+    public void checkTest(int x, int y) {\n+        testByte0(x, y);\n+        Asserts.assertEquals((byte)(((x << 24) >> 24) + y), BYTE_OUT);\n+        testByte1(x, y);\n+        Asserts.assertEquals((byte)(((x << 8) >> 8) * y), BYTE_OUT);\n+        testByte2(x, y);\n+        Asserts.assertEquals((byte)(((x << 16) >> 16) - y), BYTE_OUT);\n+        testByte3(x);\n+        Asserts.assertEquals((byte)(-((x << 16) >> 16)), BYTE_OUT);\n+        testByte4(x, y);\n+        Asserts.assertEquals((byte)(((x << 25) >> 25) | y), BYTE_OUT);\n+        testByte5(x, y);\n+        Asserts.assertEquals((byte)((x & 0xFF) ^ y), BYTE_OUT);\n+        testByte6(x, y);\n+        Asserts.assertEquals((byte)((x & 0xF) & y), BYTE_OUT);\n+        testChar0(x, y);\n+        Asserts.assertEquals((char)((x & 0xFFFF) + y), CHAR_OUT);\n+        testChar1(x, y);\n+        Asserts.assertEquals((char)((x & 0xFFFF) * y), CHAR_OUT);\n+        testChar2(x, y);\n+        Asserts.assertEquals((char)((x & 0xFFFF) - y), CHAR_OUT);\n+        testChar3(x, y);\n+        Asserts.assertEquals((char)((x & 0xFF) & y), CHAR_OUT);\n+        testShort0(x, y);\n+        Asserts.assertEquals((short)(((x << 16) >> 16) | y), SHORT_OUT);\n+        testShort1(x, y);\n+        Asserts.assertEquals((short)(((x << 10) >> 10) & y), SHORT_OUT);\n+        testShort2(x, y);\n+        Asserts.assertEquals((short)(((x << 18) >> 18) ^ y), SHORT_OUT);\n+        testShort3(x, y);\n+        Asserts.assertEquals((short)(((x << 16) >> 16) << y), SHORT_OUT);\n+    }\n+\n+    @Run(test = \"checkTest\")\n+    public void checkTest_runner() {\n+        int x = RANDOM.nextInt();\n+        int y = RANDOM.nextInt();\n+        checkTest(x, y);\n+        for (int i = 0; i < SPECIAL_IN.length; ++i) {\n+            for (int j = 0; j < SPECIAL_IN.length; ++j) {\n+                checkTest(SPECIAL_IN[i], SPECIAL_IN[j]);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRStoreCorBAddIMask.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -150,0 +150,2 @@\n+    public static final String OR_I = START + \"OrI\" + MID + END;\n+    public static final String OR_L = START + \"OrL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+    private byte[] bytesC;\n@@ -41,1 +42,3 @@\n-    private short[] shorts;\n+    private short[] shortA;\n+    private short[] shortB;\n+    private short[] shortC;\n@@ -61,1 +64,3 @@\n-        shorts = new short[COUNT];\n+        shortA = new short[COUNT];\n+        shortB = new short[COUNT];\n+        shortC = new short[COUNT];\n@@ -73,1 +78,2 @@\n-            shorts[i] = (short) r.nextInt(Short.MAX_VALUE + 1);\n+            shortA[i] = (short) r.nextInt(Short.MAX_VALUE + 1);\n+            shortB[i] = (short) r.nextInt(Short.MAX_VALUE + 1);\n@@ -123,0 +129,8 @@\n+    @Benchmark\n+    public void addB() {\n+        for (int i = 0; i < COUNT; i++) {\n+            bytesC[i] = (byte) (bytesA[i] + 3);\n+            resB[i] = (byte) (bytesC[i] + bytesB[i]);\n+        }\n+    }\n+\n@@ -126,1 +140,1 @@\n-            short a = shorts[i];\n+            short a = shortA[i];\n@@ -131,0 +145,8 @@\n+    @Benchmark\n+    public void addS() {\n+        for (int i = 0; i < COUNT; i++) {\n+            shortC[i] = (short) (shortA[i] + 3);\n+            resS[i] = (short) (shortC[i] + shortB[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"}]}