[{"commit":{"message":"8282470: Eliminate useless sign extension before some subword integer operations\n\nSome loop cases of subword types, including byte and\nshort, can't be vectorized by C2's SLP. Here is an example:\n```\nshort[] addShort(short[] a, short[] b, short[] c) {\n  for (int i = 0; i < SIZE; i++) {\n    b[i] = (short) (a[i] + 8); \/\/  *line A*\n    sres[i] = (short) (b[i] + c[i]); \/\/ *line B*\n  }\n}\n```\nHowever, similar cases of int\/float\/double\/long\/char type can\nbe vectorized successfully.\n\nThe reason why SLP can't vectorize the short case above is\nthat, as illustrated here[1], the result of the scalar add\noperation on *line A* has been promoted to int type. It needs\nto be narrowed to short type first before it can work as one\nof source operands of addition on *line B*. The demotion is\ndone by left-shifting 16 bits then right-shifting 16 bits.\nThe ideal graph for the process is showed like below.\n\n LoadS a[i]  8\n       \\   \/\n        AddI (line A)\n       \/    \\\nStoreC b[i]  Lshift 16bits\n                 \\\n               RShiftI 16 bits    LoadS c[i]\n                       \\           \/\n                       AddI (line B)\n                           \\\n                         StoreC sres[i]\n\nIn SLP, for most short-type cases, we can determine the precise\ntype of the scalar int-type operation and finally execute it\nwith short-type vector operations[2], except rshift opcode and\nabs in some situations[3]. But in this case, the source operand\nof RShiftI is from LShiftI rather than from any LoadS[4], so we\ncan't determine its real type and conservatively assign it with\nint type rather than real short type. The int-type opearation\nRShiftI here can't be vectorized together with other short-type\noperations, like AddI(line B). The reason for byte loop cases\nis the same. Similar loop cases of char type could be\nvectorized because its demotion from int to char is done by\n`and` with mask rather than `lshift_rshift`.\n\nTherefore, we try to remove the patterns like\n`RShiftI _ (LShiftI _ valIn1 conIL ) conIR` in the byte\/short\ncases, to vectorize more scenarios. Optimizing it in the\nmid-end by i-GVN is more reasonable.\n\nWhat we do in the mid-end is eliminating the sign extension\nbefore some subword integer operations like:\n\n```\nint x, y;\nshort s = (short) (((x << Imm) >> Imm) OP y); \/\/ Imm <= 16\n```\nto\n```\nshort s = (short) (x OP y);\n```\n\nIn the patch, assuming that `x` can be any int number, we need\nguarantee that the optimization doesn't have any impact on\nresult. Not all arithmetic logic OPs meet the requirements. For\nexample, assuming that `Imm` equals `16`, `x` equals `131068`,\n`y` equals `50` and `OP` is division`\/`,\n`short s = (short) (((131068 << 16) >> 16) \/ 50)` is not\nequal to `short s = (short) (131068 \/ 50)`. When OP is division,\nwe may get different result with or without demotion\nbefore OP, because the upper 16 bits of division may have\ninfluence on the lower 16 bits of result, which can't be\noptimized. All optimizable opcodes are listed in\nStoreNode::no_need_sign_extension(), whose upper 16 bits of src\noperands don't influence the lower 16 bits of result for short\ntype and upper 24 bits of src operand don't influence the lower\n8 bits of dst operand for byte.\n\nAfter the patch, the short loop case above can be vectorized as:\n```\nmovi    v18.8h, #0x8\n...\nldr     q16, [x14, #32] \/\/ vector load a[i]\n\/\/ vector add, a[i] + 8, no promotion or demotion\nadd     v17.8h, v16.8h, v18.8h\nstr     q17, [x6, #32]  \/\/ vector store a[i] + 8, b[i]\nldr     q17, [x0, #32]  \/\/ vector load c[i]\n\/\/ vector add, a[i] + c[i], no promotion or demotion\nadd     v16.8h, v17.8h, v16.8h\n\/\/ vector add, a[i] + c[i] + 8, no promotion or demotion\nadd     v16.8h, v16.8h, v18.8h\nstr     q16, [x11, #32]  \/\/vector store sres[i]\n...\n```\n\nThe patch works for byte cases as well.\n\nHere is the performance data for micro-benchmark before\nand after this patch on both AArch64 and x64 machines.\nWe can observe about ~83% improvement with this patch.\n\non AArch64:\nBefore the patch:\nBenchmark (length)  Mode  Cnt    Score    Error  Units\naddB       523      avgt   15  401.521 ±  0.033  ns\/op\naddS       523      avgt   15  401.512 ±  0.021  ns\/op\n\nAfter the patch:\nBenchmark (length)  Mode  Cnt    Score   Error  Units\naddB       523      avgt   15   68.444 ± 0.318  ns\/op\naddS       523      avgt   15   69.847 ± 0.043  ns\/op\n\non x86:\nBefore the patch:\nBenchmark (length)  Mode  Cnt    Score    Error  Units\naddB       523      avgt   15  454.102 ± 36.180  ns\/op\naddS       523      avgt   15  432.245 ± 22.640  ns\/op\n\nAfter the patch:\nBenchmark (length)  Mode  Cnt    Score    Error  Units\naddB       523      avgt   15   75.812 ±  5.063  ns\/op\naddS       523      avgt   15   72.839 ± 10.109  ns\/op\n\n[1]: https:\/\/github.com\/openjdk\/jdk\/blob\/6013d09e82693a1c07cf0bf6daffd95114b3cbfa\/src\/hotspot\/share\/opto\/superword.cpp#L3241\n[2]: https:\/\/github.com\/openjdk\/jdk\/blob\/6013d09e82693a1c07cf0bf6daffd95114b3cbfa\/src\/hotspot\/share\/opto\/superword.cpp#L3206\n[3]: https:\/\/github.com\/openjdk\/jdk\/blob\/6013d09e82693a1c07cf0bf6daffd95114b3cbfa\/src\/hotspot\/share\/opto\/superword.cpp#L3249\n[4]: https:\/\/github.com\/openjdk\/jdk\/blob\/6013d09e82693a1c07cf0bf6daffd95114b3cbfa\/src\/hotspot\/share\/opto\/superword.cpp#L3251\n\nChange-Id: I92ce42b550ef057964a3b58716436735275d8d31"},"files":[{"filename":"src\/hotspot\/share\/opto\/memnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/memnode.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRStoreCorBAddIMask.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java"}],"sha":"0897864a6abe625febb4ece2c7e1ad867b35be2d"}]