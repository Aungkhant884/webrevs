{"files":[{"patch":"@@ -60,0 +60,1 @@\n+#include \"services\/mallocLimit.hpp\"\n@@ -4447,1 +4448,1 @@\n-void Arguments::parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]) {\n+void Arguments::parse_malloc_limits(MallocLimitInfo* mli) {\n@@ -4449,5 +4450,1 @@\n-  \/\/ Reset output to 0\n-  *total_limit = 0;\n-  for (int i = 0; i < mt_number_of_types; i ++) {\n-    limits[i] = 0;\n-  }\n+  mli->reset();\n@@ -4460,6 +4457,0 @@\n-  \/\/ Global form?\n-  if (parse_malloc_limit_size(MallocLimit, total_limit)) {\n-    return;\n-  }\n-\n-  \/\/ No. So it must be in category-specific form: MallocLimit=<nmt category>:<size>[,<nmt category>:<size> ..]\n@@ -4471,1 +4462,16 @@\n-  char* p = copy, *q;\n+  \/\/ First parse and remove trailing options (which is simple for now since there is only one possible option)\n+  char* p = strrchr(copy, ',');\n+  if (p != nullptr) {\n+    if (::strcasecmp(p, \",oom\") == 0) {\n+      *p = '\\0';\n+      mli->_fake_oom = true;\n+    }\n+  }\n+\n+  \/\/ Global form?\n+  if (parse_malloc_limit_size(copy, &(mli->_total_limit))) {\n+    return;\n+  }\n+\n+  p = copy;\n+  char* q;\n@@ -4479,1 +4485,1 @@\n-    parse_single_category_limit(q, limits);\n+    parse_single_category_limit(q, mli->_limits_per_category);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"services\/mallocLimit.hpp\"\n@@ -660,9 +661,3 @@\n-  \/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits.\n-  \/\/ 1) If option is not given, it will set all limits to 0 (aka \"no limit\").\n-  \/\/ 2) If option is given in the global form (-XX:MallocLimit=<size>), it\n-  \/\/    will return the size in *total_limit.\n-  \/\/ 3) If option is given in its per-NMT-category form (-XX:MallocLimit=<category>:<size>[,<category>:<size>]),\n-  \/\/    it will return all found limits in the limits array.\n-  \/\/ 4) If option is malformed, it will exit the VM.\n-  \/\/ For (2) and (3), limits not affected by the switch will be set to 0.\n-  static void parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]);\n+  \/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits in the MallocLimitInfo structure.\n+  \/\/ If option string is malformed, it will exit the VM.\n+  static void parse_malloc_limits(MallocLimitInfo* limits);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1345,1 +1345,1 @@\n-          \"trigger a fatal error. This feature requires \"                   \\\n+          \"trigger a fatal error or mimick a native OOM. This feature requires \" \\\n@@ -1348,2 +1348,2 @@\n-          \"- MallocLimit=<size> to set a total limit. \"                     \\\n-          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>...] \" \\\n+          \"- MallocLimit=<size>[,oom] to set a total limit. \"               \\\n+          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>...][,oom] \" \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -667,0 +667,3 @@\n+  if (inner_ptr == NULL) { \/\/ MallocLimit?\n+    return NULL;\n+  }\n@@ -717,0 +720,3 @@\n+  if (new_inner_ptr == NULL) { \/\/ MallocLimit?\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"services\/mallocLimit.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+MallocLimitInfo::MallocLimitInfo() { reset(); }\n+\n+void MallocLimitInfo::reset() {\n+  _total_limit = 0;\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    _limits_per_category[i] = 0;\n+  }\n+  _fake_oom = false;\n+}\n+\n+void MallocLimitInfo::print(outputStream* st) const {\n+  if (_total_limit > 0) {\n+    st->print_cr(\"MallocLimit: total limit: \" SIZE_FORMAT \"%s\",\n+                 byte_size_in_proper_unit(_total_limit),\n+                 proper_unit_for_byte_size(_total_limit));\n+  } else {\n+    for (int i = 0; i < mt_number_of_types; i ++) {\n+      size_t catlim = _limits_per_category[i];\n+      if (catlim > 0) {\n+        st->print_cr(\"MallocLimit: category \\\"%s\\\" limit: \" SIZE_FORMAT \"%s\",\n+                     NMTUtil::flag_to_name((MEMFLAGS)i),\n+                     byte_size_in_proper_unit(catlim),\n+                     proper_unit_for_byte_size(catlim));\n+      }\n+    }\n+  }\n+  if (_fake_oom) {\n+    st->print_raw(\"MallocLimit: fake-oom mode\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/mallocLimit.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCLIMIT_HPP\n+#define SHARE_SERVICES_MALLOCLIMIT_HPP\n+\n+#include \"memory\/allocation.hpp\" \/\/ for MEMFLAGS\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class Arguments;\n+class outputStream;\n+\n+\/\/ This class contains the parsed MallocLimit argument.\n+class MallocLimitInfo {\n+  friend class Arguments;\n+\n+  \/\/ If _total_limit != 0, category limits are ignored.\n+  size_t _limits_per_category[mt_number_of_types];\n+  size_t _total_limit;\n+  bool _fake_oom;\n+\n+public:\n+  NONCOPYABLE(MallocLimitInfo);\n+\n+  MallocLimitInfo();\n+\n+  void reset();\n+\n+  size_t total_limit() const { return _total_limit; }\n+  bool is_global_limit() const { return total_limit() > 0; }\n+\n+  size_t get_limit_for_category(MEMFLAGS f) const {\n+    return _limits_per_category[(int)f];\n+  }\n+\n+  bool should_fake_oom() const { return _fake_oom; }\n+\n+  void print(outputStream* st) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCLIMIT_HPP\n","filename":"src\/hotspot\/share\/services\/mallocLimit.hpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -42,2 +43,2 @@\n-size_t MallocMemorySummary::_limits_per_category[mt_number_of_types] = { 0 };\n-size_t MallocMemorySummary::_total_limit = 0;\n+MallocLimitInfo MallocMemorySummary::_limits;\n+bool MallocMemorySummary::_limit_reached = false;\n@@ -102,16 +103,5 @@\n-  Arguments::parse_malloc_limits(&_total_limit, _limits_per_category);\n-\n-  if (_total_limit > 0) {\n-    log_info(nmt)(\"MallocLimit: total limit: \" SIZE_FORMAT \"%s\",\n-                  byte_size_in_proper_unit(_total_limit),\n-                  proper_unit_for_byte_size(_total_limit));\n-  } else {\n-    for (int i = 0; i < mt_number_of_types; i ++) {\n-      size_t catlim = _limits_per_category[i];\n-      if (catlim > 0) {\n-        log_info(nmt)(\"MallocLimit: category \\\"%s\\\" limit: \" SIZE_FORMAT \"%s\",\n-                      NMTUtil::flag_to_name((MEMFLAGS)i),\n-                      byte_size_in_proper_unit(catlim),\n-                      proper_unit_for_byte_size(catlim));\n-      }\n-    }\n+  Arguments::parse_malloc_limits(&_limits);\n+  LogTarget(Info, nmt) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    _limits.print(&ls);\n@@ -122,1 +112,1 @@\n-  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n+  \/\/ Ignore the threshold during error reporting to allow it to progress unhampered.\n@@ -124,2 +114,8 @@\n-    fatal(\"MallocLimit: reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n-          size, limit);\n+    _limit_reached = true;\n+    if (!_limits.should_fake_oom()) {\n+      fatal(\"MallocLimit: reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+            size, limit);\n+    } else {\n+      log_warning(nmt)(\"MallocLimit: reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+                       size, limit);\n+    }\n@@ -130,1 +126,1 @@\n-  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n+  \/\/ Ignore the threshold during error reporting to allow it to progress unhampered.\n@@ -132,2 +128,8 @@\n-    fatal(\"MallocLimit: category \\\"%s\\\" reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n-          NMTUtil::flag_to_name(flag), size, limit);\n+    _limit_reached = true;\n+    if (!_limits.should_fake_oom()) {\n+      fatal(\"MallocLimit: category \\\"%s\\\" reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+            NMTUtil::flag_to_name(flag), size, limit);\n+    } else {\n+      log_warning(nmt)(\"MallocLimit: category \\\"%s\\\" reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n+                       NMTUtil::flag_to_name(flag), size, limit);\n+    }\n@@ -138,12 +140,1 @@\n-  if (_total_limit != 0) {\n-    st->print(\"MallocLimit: \" SIZE_FORMAT, _total_limit);\n-  } else {\n-    bool first = true;\n-    for (int i = 0; i < mt_number_of_types; i ++) {\n-      if (_limits_per_category[i] > 0) {\n-        st->print(\"%s%s:\" SIZE_FORMAT, (first ? \"MallocLimit: \" : \", \"),\n-                  NMTUtil::flag_to_name((MEMFLAGS)i), _limits_per_category[i]);\n-        first = false;\n-      }\n-    }\n-  }\n+  _limits.print(st);\n@@ -171,0 +162,3 @@\n+  if (MallocMemorySummary::reached_limit()) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":30,"deletions":36,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"services\/mallocLimit.hpp\"\n@@ -201,2 +202,2 @@\n-  static size_t _limits_per_category[mt_number_of_types];\n-  static size_t _total_limit;\n+  static MallocLimitInfo _limits;\n+  static bool _limit_reached;\n@@ -211,1 +212,1 @@\n-    if (_total_limit != 0) {\n+    if (_limits.is_global_limit()) {\n@@ -213,2 +214,2 @@\n-      if (s > _total_limit) {\n-        total_limit_reached(s, _total_limit);\n+      if (s > _limits.total_limit()) {\n+        total_limit_reached(s, _limits.total_limit());\n@@ -217,1 +218,1 @@\n-      size_t per_cat_limit = _limits_per_category[(int)flag];\n+      size_t per_cat_limit = _limits.get_limit_for_category(flag);\n@@ -255,0 +256,4 @@\n+   static bool reached_limit() {\n+     return _limit_reached;\n+   }\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+\/*\n+ * @test id=global-limit-oom\n+ * @summary Verify -XX:MallocLimit with a global limit in fake OOM mode\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest global-limit-oom\n+ *\/\n+\n@@ -50,0 +58,8 @@\n+\/*\n+ * @test id=multi-limit-oom\n+ * @summary Verify -XX:MallocLimit with multiple limits\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver MallocLimitTest multi-limit-oom\n+ *\/\n+\n@@ -105,1 +121,16 @@\n-        String s = output.firstMatch(\".*MallocLimit: reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        String s = output.firstMatch(\"#  fatal error: MallocLimit: reached limit \\\\(size: (\\\\d+), \" +\n+                \"limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        Asserts.assertNotNull(s);\n+        long size = Long.parseLong(s);\n+        Asserts.assertGreaterThan(size, smallMemorySize);\n+    }\n+\n+    private static void testGlobalLimitOom() throws IOException {\n+        long smallMemorySize = 1024*1024; \/\/ 1m\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + smallMemorySize + \",oom\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K\"); \/\/ printed by byte_size_in_proper_unit()\n+        output.shouldContain(\"[nmt] MallocLimit: fake-oom mode\");\n+        String s = output.firstMatch(\".*\\\\[warning *\\\\]\\\\[nmt *\\\\] MallocLimit: reached limit \\\\(size: (\\\\d+), \" +\n+                \"limit: \" + smallMemorySize + \"\\\\).*\", 1);\n@@ -109,0 +140,1 @@\n+        output.shouldContain(\"# There is insufficient memory for the Java Runtime Environment to continue.\");\n@@ -124,1 +156,2 @@\n-        String s = output.firstMatch(\".*MallocLimit: category \\\"Compiler\\\" reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        String s = output.firstMatch(\"#  fatal error: MallocLimit: category \\\"Compiler\\\" reached limit \" +\n+                \"\\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n@@ -139,1 +172,18 @@\n-        String s = output.firstMatch(\".*MallocLimit: category \\\"Internal\\\" reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        String s = output.firstMatch(\"#  fatal error: MallocLimit: category \\\"Internal\\\" reached limit \" +\n+                \"\\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n+        long size = Long.parseLong(s);\n+        Asserts.assertGreaterThan(size, smallMemorySize);\n+    }\n+\n+    private static void testMultiLimitOom() throws IOException {\n+        long smallMemorySize = 1024; \/\/ 1k\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=mtOther:2g,compiler:1g,internal:\"\n+                + smallMemorySize + \",oom\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1024M\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Internal\\\" limit: 1024B\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"Other\\\" limit: 2048M\");\n+        output.shouldContain(\"[nmt] MallocLimit: fake-oom mode\");\n+        String s = output.firstMatch(\".*\\\\[warning *\\\\]\\\\[nmt *\\\\] MallocLimit: category \\\"Internal\\\" \" +\n+                \"reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n@@ -160,0 +210,6 @@\n+        testValidSetting(\n+                \"2097152k,oom\",\n+                \"[nmt] MallocLimit: total limit: 2048M\",\n+                \"[nmt] MallocLimit: fake-oom mode\",\n+                \"[nmt] NMT initialized: summary\"\n+        );\n@@ -234,0 +290,2 @@\n+        } else if (args[0].equals(\"global-limit-oom\")) {\n+            testGlobalLimitOom();\n@@ -238,0 +296,2 @@\n+        } else if (args[0].equals(\"multi-limit-oom\")) {\n+            testMultiLimitOom();\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocLimitTest.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"}]}