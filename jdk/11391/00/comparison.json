{"files":[{"patch":"@@ -5447,1 +5447,1 @@\n-Node* CountedLoopNode::is_canonical_loop_entry() {\n+Node* CountedLoopNode::is_canonical_loop_entry(bool cross_check) {\n@@ -5485,0 +5485,3 @@\n+  if (cross_check && res) {\n+    assert(cmpzm->in(input)->as_Opaque1()->guarded_counted_loop() == this, \"\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-  Node* is_canonical_loop_entry();\n+  Node* is_canonical_loop_entry(bool cross_check = true);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"opto\/cfgnode.hpp\"\n+#include \"opto\/loopnode.hpp\"\n@@ -47,0 +49,75 @@\n+\/\/ If this node is part of the zero trip guard for a loop, find that loop.\n+CountedLoopNode* Opaque1Node::guarded_counted_loop() const {\n+  if (Opcode() != Op_Opaque1) {\n+    return NULL;\n+  }\n+\n+  CountedLoopNode* loop = NULL;\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* u1 = fast_out(i);\n+    if (u1->Opcode() == Op_CmpI) {\n+      Node* cmp = u1;\n+      for (DUIterator_Fast jmax, j = cmp->fast_outs(jmax); j < jmax; j++) {\n+        Node* u2 = cmp->fast_out(j);\n+        if (u2->is_Bool()) {\n+          Node* bol = u2;\n+          for (DUIterator_Fast kmax, k = bol->fast_outs(kmax); k < kmax; k++) {\n+            Node* u3 = bol->fast_out(k);\n+            if (u3->is_If()) {\n+              IfNode* iff = u3->as_If();\n+              Node* ctrl_true = try_find_loop(iff, 1);\n+              Node* ctrl_false = try_find_loop(iff, 0);\n+              if (ctrl_true != NULL && ctrl_true->is_CountedLoop()) {\n+                CountedLoopNode* cl = ctrl_true->as_CountedLoop();\n+                if (cl->is_canonical_loop_entry(false) == this) {\n+                  assert(loop == NULL, \"this Opaque1 should guard a single loop\");\n+                  loop = cl;\n+                }\n+              }\n+              if (ctrl_false != NULL && ctrl_false->is_CountedLoop()) {\n+                CountedLoopNode* cl = ctrl_false->as_CountedLoop();\n+                if (cl->is_canonical_loop_entry(false) == this) {\n+                  assert(loop == NULL, \"this Opaque1 should guard a single loop\");\n+                  loop = cl;\n+                }\n+                assert(loop == NULL || (outcnt() == 1 && cmp->outcnt() == 1 && bol->outcnt() == 1), \"this Opaque1 can't be shared\");\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return loop;\n+}\n+\n+Node* Opaque1Node::try_find_loop(const IfNode* iff, uint proj) const {\n+  Node* ctrl = iff->proj_out_or_null(proj);\n+  if (ctrl != NULL) {\n+    ctrl = ctrl->unique_ctrl_out_or_null();\n+  }\n+  \/\/ step over skeleton predicates\n+  while (ctrl != NULL && ctrl->is_If()) {\n+    Node* ctrl_true = ctrl->as_If()->proj_out_or_null(0);\n+    if (ctrl_true != NULL) {\n+      ctrl_true = ctrl_true->unique_ctrl_out();\n+    }\n+    Node* ctrl_false = ctrl->as_If()->proj_out_or_null(1);\n+    if (ctrl_false != NULL) {\n+      ctrl_false = ctrl_false->unique_ctrl_out();\n+    }\n+    if (ctrl_true == NULL || ctrl_true->Opcode() == Op_Halt) {\n+      ctrl = ctrl_false;\n+    } else if (ctrl_false == NULL || ctrl_false->Opcode() == Op_Halt) {\n+      ctrl = ctrl_true;\n+    } else {\n+      ctrl = NULL;\n+    }\n+  }\n+  if (ctrl != NULL && ctrl->is_OuterStripMinedLoop()) {\n+    ctrl = ctrl->unique_ctrl_out();\n+  }\n+  return ctrl;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+\n+  CountedLoopNode* guarded_counted_loop() const;\n+private:\n+  Node* try_find_loop(const IfNode* iff, uint proj) const;\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -223,0 +224,23 @@\n+  if (n->Opcode() == Op_Opaque1) {\n+    CountedLoopNode* cl = n->as_Opaque1()->guarded_counted_loop();\n+    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n+    \/\/ 1- it can't be shared\n+    \/\/ 2- the zero trip guard can't be the if that's being split\n+    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n+    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n+    if (cl != NULL) {\n+      \/\/ Find the zero trip guard from the loop\n+      Node* ctrl = cl->skip_predicates();\n+      assert(ctrl->in(0)->is_If(), \"expect and If from the zero trip guard\");\n+      assert(ctrl->in(0) != blk1 && ctrl->in(0) != blk2, \"shouldn't split a zero trip guard\");\n+      Node* bol = ctrl->in(0)->in(1);\n+      assert(bol->is_Bool(), \"bad zero trip guard shape\");\n+      Node* cmp = bol->in(1);\n+      assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+      set_ctrl(n, ctrl->in(0)->in(0));\n+      set_ctrl(cmp, ctrl->in(0)->in(0));\n+      set_ctrl(bol, ctrl->in(0)->in(0));\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269820\n+ * @summary C2 PhaseIdealLoop::do_unroll get wrong opaque node\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation TestCanonicalLoopEntryOpaqueOrder\n+ *\n+ *\/\n+\n+public class TestCanonicalLoopEntryOpaqueOrder {\n+    static void test() {\n+        int ina8[] = new int[1478];\n+        int in2 = 136;\n+        long lo3 = 0L;\n+        try {\n+            for (int i = 0; i < 34; i++) {\n+                Math.log1p(1);\n+            }\n+        } catch (Exception e) {\n+            in2 = 1;\n+        }\n+\n+        for (int i = 0; i < in2; i++) {\n+            if (in2 > 10) {  \/\/ split if and create wrong opaque order\n+                for (int j = 0; j < in2; j++) {\n+                    lo3 -= 1L;\n+                }\n+            }\n+        }\n+    }\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCanonicalLoopEntryOpaqueOrder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}