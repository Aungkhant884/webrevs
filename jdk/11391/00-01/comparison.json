{"files":[{"patch":"@@ -621,1 +621,1 @@\n-          assert(opaq->Opcode() == Op_Opaque1, \"\");\n+          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+macro(OpaqueZeroTripGuard)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1303,1 +1303,1 @@\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_Opaque1, \"must be Opaque1\");\n+  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_OpaqueZeroTripGuard, \"must be OpaqueZeroTripGuard\");\n@@ -1708,1 +1708,1 @@\n-  Node *min_opaq = new Opaque1Node(C, limit);\n+  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n@@ -1997,1 +1997,1 @@\n-  Node *zer_opaq = new Opaque1Node(C, incr);\n+  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5447,1 +5447,1 @@\n-Node* CountedLoopNode::is_canonical_loop_entry(bool cross_check) {\n+Node* CountedLoopNode::is_canonical_loop_entry() {\n@@ -5473,1 +5473,1 @@\n-  bool res = cmpzm->in(input)->Opcode() == Op_Opaque1;\n+  bool res = cmpzm->in(input)->Opcode() == Op_OpaqueZeroTripGuard;\n@@ -5478,1 +5478,1 @@\n-    if (opnd && opnd->Opcode() == Op_Opaque1) {\n+    if (opnd && opnd->is_Opaque1()) {\n@@ -5485,3 +5485,0 @@\n-  if (cross_check && res) {\n-    assert(cmpzm->in(input)->as_Opaque1()->guarded_counted_loop() == this, \"\");\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-  Node* is_canonical_loop_entry(bool cross_check = true);\n+  Node* is_canonical_loop_entry();\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"opto\/cfgnode.hpp\"\n-#include \"opto\/loopnode.hpp\"\n@@ -49,75 +47,0 @@\n-\/\/ If this node is part of the zero trip guard for a loop, find that loop.\n-CountedLoopNode* Opaque1Node::guarded_counted_loop() const {\n-  if (Opcode() != Op_Opaque1) {\n-    return NULL;\n-  }\n-\n-  CountedLoopNode* loop = NULL;\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    Node* u1 = fast_out(i);\n-    if (u1->Opcode() == Op_CmpI) {\n-      Node* cmp = u1;\n-      for (DUIterator_Fast jmax, j = cmp->fast_outs(jmax); j < jmax; j++) {\n-        Node* u2 = cmp->fast_out(j);\n-        if (u2->is_Bool()) {\n-          Node* bol = u2;\n-          for (DUIterator_Fast kmax, k = bol->fast_outs(kmax); k < kmax; k++) {\n-            Node* u3 = bol->fast_out(k);\n-            if (u3->is_If()) {\n-              IfNode* iff = u3->as_If();\n-              Node* ctrl_true = try_find_loop(iff, 1);\n-              Node* ctrl_false = try_find_loop(iff, 0);\n-              if (ctrl_true != NULL && ctrl_true->is_CountedLoop()) {\n-                CountedLoopNode* cl = ctrl_true->as_CountedLoop();\n-                if (cl->is_canonical_loop_entry(false) == this) {\n-                  assert(loop == NULL, \"this Opaque1 should guard a single loop\");\n-                  loop = cl;\n-                }\n-              }\n-              if (ctrl_false != NULL && ctrl_false->is_CountedLoop()) {\n-                CountedLoopNode* cl = ctrl_false->as_CountedLoop();\n-                if (cl->is_canonical_loop_entry(false) == this) {\n-                  assert(loop == NULL, \"this Opaque1 should guard a single loop\");\n-                  loop = cl;\n-                }\n-                assert(loop == NULL || (outcnt() == 1 && cmp->outcnt() == 1 && bol->outcnt() == 1), \"this Opaque1 can't be shared\");\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return loop;\n-}\n-\n-Node* Opaque1Node::try_find_loop(const IfNode* iff, uint proj) const {\n-  Node* ctrl = iff->proj_out_or_null(proj);\n-  if (ctrl != NULL) {\n-    ctrl = ctrl->unique_ctrl_out_or_null();\n-  }\n-  \/\/ step over skeleton predicates\n-  while (ctrl != NULL && ctrl->is_If()) {\n-    Node* ctrl_true = ctrl->as_If()->proj_out_or_null(0);\n-    if (ctrl_true != NULL) {\n-      ctrl_true = ctrl_true->unique_ctrl_out();\n-    }\n-    Node* ctrl_false = ctrl->as_If()->proj_out_or_null(1);\n-    if (ctrl_false != NULL) {\n-      ctrl_false = ctrl_false->unique_ctrl_out();\n-    }\n-    if (ctrl_true == NULL || ctrl_true->Opcode() == Op_Halt) {\n-      ctrl = ctrl_false;\n-    } else if (ctrl_false == NULL || ctrl_false->Opcode() == Op_Halt) {\n-      ctrl = ctrl_true;\n-    } else {\n-      ctrl = NULL;\n-    }\n-  }\n-  if (ctrl != NULL && ctrl->is_OuterStripMinedLoop()) {\n-    ctrl = ctrl->unique_ctrl_out();\n-  }\n-  return ctrl;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -56,4 +56,0 @@\n-\n-  CountedLoopNode* guarded_counted_loop() const;\n-private:\n-  Node* try_find_loop(const IfNode* iff, uint proj) const;\n@@ -77,0 +73,7 @@\n+class OpaqueZeroTripGuardNode : public Opaque1Node {\n+public:\n+  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -224,2 +224,1 @@\n-  if (n->Opcode() == Op_Opaque1) {\n-    CountedLoopNode* cl = n->as_Opaque1()->guarded_counted_loop();\n+  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n@@ -231,14 +230,10 @@\n-    if (cl != NULL) {\n-      \/\/ Find the zero trip guard from the loop\n-      Node* ctrl = cl->skip_predicates();\n-      assert(ctrl->in(0)->is_If(), \"expect and If from the zero trip guard\");\n-      assert(ctrl->in(0) != blk1 && ctrl->in(0) != blk2, \"shouldn't split a zero trip guard\");\n-      Node* bol = ctrl->in(0)->in(1);\n-      assert(bol->is_Bool(), \"bad zero trip guard shape\");\n-      Node* cmp = bol->in(1);\n-      assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n-      set_ctrl(n, ctrl->in(0)->in(0));\n-      set_ctrl(cmp, ctrl->in(0)->in(0));\n-      set_ctrl(bol, ctrl->in(0)->in(0));\n-      return true;\n-    }\n+    Node* cmp = n->unique_out();\n+    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+    Node* bol = cmp->unique_out();\n+    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n+    Node* iff = bol->unique_out();\n+    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n+    set_ctrl(n, iff->in(0));\n+    set_ctrl(cmp, iff->in(0));\n+    set_ctrl(bol, iff->in(0));\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1456,1 +1456,1 @@\n-  if( con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_Opaque1 &&\n+  if( con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}