{"files":[{"patch":"@@ -312,0 +312,2 @@\n+  static bool is_any_thread_filtered_event_enabled_globally();\n+  static void recompute_thread_filtered(JvmtiThreadState *state);\n@@ -733,0 +735,14 @@\n+bool\n+JvmtiEventControllerPrivate::is_any_thread_filtered_event_enabled_globally() {\n+  julong global_thread_events = JvmtiEventController::_universal_global_event_enabled.get_bits() & THREAD_FILTERED_EVENT_BITS;\n+  return global_thread_events != 0L;\n+}\n+\n+void\n+JvmtiEventControllerPrivate::recompute_thread_filtered(JvmtiThreadState *state) {\n+  assert(Threads::number_of_threads() == 0 || JvmtiThreadState_lock->is_locked(), \"sanity check\");\n+\n+  if (is_any_thread_filtered_event_enabled_globally()) {\n+    JvmtiEventControllerPrivate::recompute_thread_enabled(state);\n+  }\n+}\n@@ -742,7 +758,2 @@\n-  if ((JvmtiEventController::_universal_global_event_enabled.get_bits() & THREAD_FILTERED_EVENT_BITS) != 0) {\n-    MutexLocker mu(JvmtiThreadState_lock);\n-    \/\/ create the thread state if missing\n-    JvmtiThreadState *state = JvmtiThreadState::state_for_while_locked(thread);\n-    if (state != nullptr) {    \/\/ skip threads with no JVMTI thread state\n-      recompute_thread_enabled(state);\n-    }\n+  if (is_any_thread_filtered_event_enabled_globally()) { \/\/ intentionally racy\n+    JvmtiThreadState::state_for(thread);\n@@ -752,1 +763,0 @@\n-\n@@ -1118,0 +1128,5 @@\n+void\n+JvmtiEventController::recompute_thread_filtered(JvmtiThreadState *state) {\n+  JvmtiEventControllerPrivate::recompute_thread_filtered(state);\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+  static void recompute_thread_filtered(JvmtiThreadState *state);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -420,0 +420,9 @@\n+JvmtiThreadState*\n+JvmtiExport::get_jvmti_thread_state(JavaThread *thread) {\n+  assert(thread == JavaThread::current(), \"must be current thread\");\n+  if (thread->is_vthread_mounted() && thread->jvmti_thread_state() == nullptr) {\n+    JvmtiEventController::thread_started(thread);\n+  }\n+  return thread->jvmti_thread_state();\n+}\n+\n@@ -923,1 +932,1 @@\n-    _state = _thread->jvmti_thread_state();\n+    _state = JvmtiExport::get_jvmti_thread_state(_thread);\n@@ -1215,1 +1224,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1313,1 +1322,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1332,1 +1341,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1340,1 +1349,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1355,1 +1364,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1393,1 +1402,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1522,1 +1531,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1570,1 +1579,1 @@\n-  JvmtiThreadState *state = cur_thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(cur_thread);\n@@ -1604,1 +1613,1 @@\n-  JvmtiThreadState *state = cur_thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(cur_thread);\n@@ -1639,1 +1648,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1674,1 +1683,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1707,1 +1716,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1801,1 +1810,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1841,1 +1850,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1962,1 +1971,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2004,1 +2013,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2092,1 +2101,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2208,1 +2217,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2364,1 +2373,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2606,1 +2615,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2725,1 +2734,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2733,3 +2745,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2758,1 +2767,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2766,3 +2778,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2792,1 +2801,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2800,3 +2812,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2826,1 +2835,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2834,3 +2846,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2889,1 +2898,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2899,2 +2911,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -301,0 +301,5 @@\n+  \/\/ If the jvmti_thread_state is absent and any thread filtered event\n+  \/\/ is enabled globally then it is created.\n+  \/\/ Otherwise, the thread->jvmti_thread_state() is returned.\n+  static JvmtiThreadState* get_jvmti_thread_state(JavaThread *thread);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -468,0 +468,2 @@\n+  \/\/ Callers are responsible to call recompute_thread_filtered() to update event bits\n+  \/\/ if thread-filtered events are enabled globally.\n@@ -471,0 +473,1 @@\n+  \/\/ Calls recompute_thread_filtered() to update event bits if thread-filtered events are enabled globally.\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    JvmtiEventController::recompute_thread_filtered(state);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8312174\n+ * @summary missing JVMTI events from vthreads parked during JVMTI attach\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @run main\/othervm\/native\n+ *     -Djdk.attach.allowAttachSelf=true -XX:+EnableDynamicAgentLoading VThreadEventTest attach\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+\/*\n+ * The test uses custom implementation of the CountDownLatch class.\n+ * The reason is we want the state of tested thread to be predictable.\n+ * With original CountDownLatch it is not clear what thread state is expected.\n+ *\/\n+class CountDownLatch {\n+    private int count = 0;\n+\n+    CountDownLatch(int count) {\n+        this.count = count;\n+    }\n+\n+    public synchronized void countDown() {\n+        count--;\n+        notify();\n+    }\n+\n+    public synchronized void await() throws InterruptedException {\n+        while (count > 0) {\n+            wait(1);\n+        }\n+    }\n+}\n+\n+public class VThreadEventTest {\n+    static final int TCNT1 = 10;\n+    static final int TCNT2 = 4;\n+    static final int TCNT3 = 4;\n+    static final int THREAD_CNT = TCNT1 + TCNT2 + TCNT3;\n+    static final long TIMEOUT_BASE = 1_000_000L;\n+\n+    private static void log(String msg) { System.out.println(msg); }\n+\n+    private static native int threadEndCount();\n+    private static native int threadMountCount();\n+    private static native int threadUnmountCount();\n+\n+    private static volatile boolean attached;\n+    private static boolean failed;\n+    private static List<Thread> test1Threads = new ArrayList(TCNT1);\n+\n+    private static CountDownLatch ready0 = new CountDownLatch(THREAD_CNT);\n+    private static CountDownLatch ready1 = new CountDownLatch(TCNT1);\n+    private static CountDownLatch ready2 = new CountDownLatch(THREAD_CNT);\n+    private static CountDownLatch mready = new CountDownLatch(1);\n+\n+    private static void await(CountDownLatch dumpedLatch) {\n+        try {\n+            dumpedLatch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ The test1 vthreads are kept unmounted until interrupted after agent attach.\n+    static final Runnable test1 = () -> {\n+        synchronized (test1Threads) {\n+            test1Threads.add(Thread.currentThread());\n+        }\n+        log(\"test1 vthread started\");\n+        ready0.countDown();\n+        await(mready);\n+        ready1.countDown(); \/\/ to guaranty state is not State.WAITING after await(mready)\n+        try {\n+            Thread.sleep(20000); \/\/ big timeout to keep unmounted untill interrupted\n+        } catch (InterruptedException ex) {\n+            \/\/ it is expected, ignore\n+        }\n+        ready2.countDown();\n+    };\n+\n+    \/\/ The test2 vthreads are kept mounted until agent attach.\n+    static final Runnable test2 = () -> {\n+        log(\"test2 vthread started\");\n+        ready0.countDown();\n+        await(mready);\n+        while (!attached) {\n+            \/\/ keep mounted\n+        }\n+        ready2.countDown();\n+    };\n+\n+    \/\/ The test3 vthreads are kept mounted until agent attach.\n+    static final Runnable test3 = () -> {\n+        log(\"test3 vthread started\");\n+        ready0.countDown();\n+        await(mready);\n+        while (!attached) {\n+            \/\/ keep mounted\n+        }\n+        LockSupport.parkNanos(10 * TIMEOUT_BASE); \/\/ will cause extra mount and unmount\n+        ready2.countDown();\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        if (Runtime.getRuntime().availableProcessors() < 8) {\n+            log(\"WARNING: test expects at least 8 processors.\");\n+        }\n+        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n+            for (int i = 0; i < TCNT1; i++) {\n+                executorService.execute(test1);\n+            }\n+            for (int i = 0; i < TCNT2; i++) {\n+                executorService.execute(test2);\n+            }\n+            for (int i = 0; i < TCNT3; i++) {\n+                executorService.execute(test3);\n+            }\n+            await(ready0);\n+            mready.countDown();\n+            await(ready1); \/\/ to guaranty state is not State.WAITING after await(mready) in test1() \n+            \/\/ wait for test1 threads to reach WAITING state in sleep()\n+            for (Thread t : test1Threads) {\n+                Thread.State state = t.getState();\n+                log(\"DBG: state: \" + state);\n+                while (state != Thread.State.WAITING) {\n+                    Thread.sleep(10);\n+                    state = t.getState();\n+                    log(\"DBG: state: \" + state);\n+                }\n+            }\n+\n+            VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n+            vm.loadAgentLibrary(\"VThreadEventTest\");\n+            Thread.sleep(200); \/\/ to allow the agent to get ready\n+\n+            attached = true;\n+            for (Thread t : test1Threads) {\n+                 t.interrupt();\n+            }\n+            ready2.await();\n+        }\n+        \/\/ wait until all VirtualThreadEnd events have been sent\n+        for (int sleepNo = 1; threadEndCount() < THREAD_CNT; sleepNo++) {\n+            Thread.sleep(100);\n+            if (sleepNo % 100 == 0) { \/\/ 10 sec period of waiting\n+                log(\"main: waited seconds: \" + sleepNo\/10);\n+            }\n+        }\n+        int threadEndCnt = threadEndCount();\n+        int threadMountCnt = threadMountCount();\n+        int threadUnmountCnt = threadUnmountCount();\n+        int threadEndExp = THREAD_CNT;\n+        int threadMountExp = THREAD_CNT - TCNT2;\n+        int threadUnmountExp = THREAD_CNT + TCNT3;\n+\n+        log(\"ThreadEnd cnt: \"     + threadEndCnt     + \" (expected: \" + threadEndExp + \")\");\n+        log(\"ThreadMount cnt: \"   + threadMountCnt   + \" (expected: \" + threadMountExp + \")\");\n+        log(\"ThreadUnmount cnt: \" + threadUnmountCnt + \" (expected: \" + threadUnmountExp + \")\");\n+\n+        if (threadEndCnt != threadEndExp) {\n+            log(\"FAILED: unexpected count of ThreadEnd events\");\n+            failed = true;\n+        }\n+        if (threadMountCnt != threadMountExp) {\n+            log(\"FAILED: unexpected count of ThreadMount events\");\n+            failed = true;\n+        }\n+        if (threadUnmountCnt != threadUnmountExp) {\n+            log(\"FAILED: unexpected count of ThreadUnmount events\");\n+            failed = true;\n+        }\n+        if (failed) {\n+            throw new RuntimeException(\"FAILED: event count is wrong\");\n+        }\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <cstdlib>\n+#include <cstring>\n+#include <jvmti.h>\n+#include <mutex>\n+#include <atomic>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static std::atomic<int> thread_end_cnt(0);\n+static std::atomic<int> thread_unmount_cnt(0);\n+static std::atomic<int> thread_mount_cnt(0);\n+\n+void JNICALL VirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread vthread) {\n+  thread_end_cnt++;\n+}\n+\n+void JNICALL VirtualThreadMount(jvmtiEnv* jvmti, ...) {\n+  thread_mount_cnt++;\n+}\n+\n+void JNICALL VirtualThreadUnmount(jvmtiEnv* jvmti, ...) {\n+  thread_unmount_cnt++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_VThreadEventTest_threadEndCount(JNIEnv* jni, jclass clazz) {\n+  return thread_end_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_VThreadEventTest_threadMountCount(JNIEnv* jni, jclass clazz) {\n+  return thread_mount_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_VThreadEventTest_threadUnmountCount(JNIEnv* jni, jclass clazz) {\n+  return thread_unmount_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  LOG(\"Agent_OnAttach started\\n\");\n+  if (vm->GetEnv(reinterpret_cast<void **>(&jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {\n+    LOG(\"Could not initialize JVMTI env\\n\");\n+    return JNI_ERR;\n+  }\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_support_virtual_threads = 1;\n+  check_jvmti_error(jvmti->AddCapabilities(&caps), \"AddCapabilities\");\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VirtualThreadEnd = &VirtualThreadEnd;\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, (jint)sizeof(callbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+\n+  err = set_ext_event_callback(jvmti, \"VirtualThreadMount\", VirtualThreadMount);\n+  check_jvmti_error(err, \"SetExtEventCallback for VirtualThreadMount\");\n+\n+  err = set_ext_event_callback(jvmti, \"VirtualThreadUnmount\", VirtualThreadUnmount);\n+  check_jvmti_error(err, \"SetExtEventCallback for VirtualThreadUnmount\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode for VirtualThreadEnd\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode for VirtualThreadMount\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode for VirtualThreadUnmount\");\n+\n+  LOG(\"vthread events enabled\\n\");\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+} \/\/ extern \"C\"\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/libVThreadEventTest.cpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -131,0 +131,7 @@\n+static void\n+check_jvmti_error(jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"check_jvmti_error: JVMTI function returned error: %s: %s(%d)\\n\", msg, TranslateError(err), err);\n+    abort();\n+  }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}