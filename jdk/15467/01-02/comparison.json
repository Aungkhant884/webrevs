{"files":[{"patch":"@@ -423,1 +423,1 @@\n-  if (thread->is_virtual() && thread->jvmti_thread_state() == nullptr) {\n+  if (thread->is_vthread_mounted() && thread->jvmti_thread_state() == nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -468,0 +468,2 @@\n+  \/\/ Callers are responsible to call recompute_thread_filtered() to update event bits\n+  \/\/ if thread-filtered events are enabled globally.\n@@ -471,0 +473,1 @@\n+  \/\/ Calls recompute_thread_filtered() to update event bits if thread-filtered events are enabled globally.\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-  JvmtiEventController::recompute_thread_filtered(state);\n@@ -113,0 +112,1 @@\n+    JvmtiEventController::recompute_thread_filtered(state);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-  inline bool is_virtual() const;\n+\/\/inline bool is_virtual() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+#if 0\n@@ -183,0 +184,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n@@ -41,1 +42,1 @@\n-class Counter {\n+class CountDownLatch {\n@@ -44,1 +45,1 @@\n-    Counter (int count) {\n+    CountDownLatch(int count) {\n@@ -48,1 +49,1 @@\n-    public synchronized void decr() {\n+    public synchronized void countDown() {\n@@ -53,7 +54,3 @@\n-    public synchronized void await() {\n-        try {\n-            while (count > 0) {\n-                wait(1);\n-            }\n-        } catch (InterruptedException ex) {\n-            throw new RuntimeException(\"wait was interrupted: \" + ex);\n+    public synchronized void await() throws InterruptedException {\n+        while (count > 0) {\n+            wait(1);\n@@ -80,1 +77,57 @@\n-    private static List<Thread> threads = new ArrayList(TCNT1);\n+    private static List<Thread> test1Threads = new ArrayList(TCNT1);\n+\n+    private static CountDownLatch ready0 = new CountDownLatch(THREAD_CNT);\n+    private static CountDownLatch ready1 = new CountDownLatch(TCNT1);\n+    private static CountDownLatch ready2 = new CountDownLatch(THREAD_CNT);\n+    private static CountDownLatch mready = new CountDownLatch(1);\n+\n+    private static void await(CountDownLatch dumpedLatch) {\n+        try {\n+            dumpedLatch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ The test1 vthreads are kept unmounted until interrupted after agent attach.\n+    static final Runnable test1 = () -> {\n+        synchronized (test1Threads) {\n+            test1Threads.add(Thread.currentThread());\n+        }\n+        log(\"test1 vthread started\");\n+        ready0.countDown();\n+        await(mready);\n+        ready1.countDown(); \/\/ to guaranty state is not State.WAITING after await() above\n+        try {\n+            Thread.sleep(20000); \/\/ big timeout to keep unmounted untill interrupted\n+        } catch (InterruptedException ex) {\n+            \/\/ it is expected, ignore\n+        }\n+        ready2.countDown();\n+        completedNo++;\n+    };\n+\n+    \/\/ The test2 vthreads are kept mounted until agent attach.\n+    static final Runnable test2 = () -> {\n+        log(\"test2 vthread started\");\n+        ready0.countDown();\n+        await(mready);\n+        while (!attached) {\n+            \/\/ keep mounted\n+        }\n+        ready2.countDown();\n+        completedNo++;\n+    };\n+\n+    \/\/ The test3 vthreads are kept mounted until agent attach.\n+    static final Runnable test3 = () -> {\n+        log(\"test3 vthread started\");\n+        ready0.countDown();\n+        await(mready);\n+        while (!attached) {\n+            \/\/ keep mounted\n+        }\n+        LockSupport.parkNanos(10 * TIMEOUT_BASE); \/\/ will cause extra mount and unmount\n+        ready2.countDown();\n+        completedNo++;\n+    };\n@@ -86,4 +139,0 @@\n-        Counter ready1 = new Counter(THREAD_CNT);\n-        Counter ready2 = new Counter(THREAD_CNT);\n-        Counter mready = new Counter(1);\n-\n@@ -91,17 +140,5 @@\n-            for (int tCnt = 0; tCnt < TCNT1; tCnt++) {\n-                executorService.execute(() -> {\n-                    synchronized (threads) {\n-                        threads.add(Thread.currentThread());\n-                    }\n-                    log(\"test1 vthread started\");\n-                    ready1.decr();\n-                    mready.await();\n-                    try {\n-                        \/\/ timeout is big enough to keep mounted untill interrupted\n-                        Thread.sleep(20000);\n-                    } catch (InterruptedException ex) {\n-                        \/\/ it is expected, ignore\n-                    }\n-                    ready2.decr();\n-                    completedNo++;\n-                });\n+            for (int i = 0; i < TCNT1; i++) {\n+                executorService.execute(test1);\n+            }\n+            for (int i = 0; i < TCNT2; i++) {\n+                executorService.execute(test2);\n@@ -109,11 +146,2 @@\n-            for (int tCnt = 0; tCnt < TCNT2; tCnt++) {\n-                executorService.execute(() -> {\n-                    log(\"test2 vthread started\");\n-                    ready1.decr();\n-                    mready.await();\n-                    while (!attached) {\n-                        \/\/ keep mounted\n-                    }\n-                    ready2.decr();\n-                    completedNo++;\n-                });\n+            for (int i = 0; i < TCNT3; i++) {\n+                executorService.execute(test3);\n@@ -121,12 +149,12 @@\n-            for (int tCnt = 0; tCnt < TCNT3; tCnt++) {\n-                executorService.execute(() -> {\n-                    log(\"test3 vthread started\");\n-                    ready1.decr();\n-                    mready.await();\n-                    while (!attached) {\n-                        \/\/ keep mounted\n-                    }\n-                    LockSupport.parkNanos(10 * TIMEOUT_BASE);\n-                    ready2.decr();\n-                    completedNo++;\n-                });\n+            await(ready0);\n+            mready.countDown();\n+            await(ready1);\n+            \/\/ wait for test1 threads to reach WAITING state in sleep()\n+            for (Thread t : test1Threads) {\n+                Thread.State state = t.getState();\n+                log(\"DBG: state: \" + state);\n+                while (state != Thread.State.WAITING) {\n+                    Thread.sleep(10);\n+                    state = t.getState();\n+                    log(\"DBG: state: \" + state);\n+                }\n@@ -134,2 +162,1 @@\n-            ready1.await();\n-            mready.decr();\n+\n@@ -138,1 +165,2 @@\n-            Thread.sleep(100);\n+            Thread.sleep(200); \/\/ to allow the agent to get ready\n+\n@@ -140,0 +168,3 @@\n+            if (completedNo > 0) {\n+                throw new RuntimeException(\"FAILED: none of vthreadsexpected to complete at this point\");\n+            }\n@@ -141,2 +172,2 @@\n-            for (Thread t : threads) {\n-                t.interrupt();\n+            for (Thread t : test1Threads) {\n+                 t.interrupt();\n@@ -146,3 +177,2 @@\n-        \/\/ wait not more than 10 secs until all VirtualThreadEnd events are sent\n-        for (int sleepNo = 0; sleepNo < 10 && threadEndCount() < THREAD_CNT; sleepNo++) {\n-            log(\"main: wait iter: \" + sleepNo);\n+        \/\/ wait until all VirtualThreadEnd events have been sent\n+        for (int sleepNo = 1; threadEndCount() < THREAD_CNT; sleepNo++) {\n@@ -150,0 +180,3 @@\n+            if (sleepNo % 100 == 0) { \/\/ 10 sec period of waiting\n+                log(\"main: waited seconds: \" + sleepNo\/10);\n+            }\n@@ -163,1 +196,1 @@\n-            log(\"unexpected count of ThreadEnd events\");\n+            log(\"FAILED: unexpected count of ThreadEnd events\");\n@@ -167,1 +200,1 @@\n-            log(\"unexpected count of ThreadMount events\");\n+            log(\"FAILED: unexpected count of ThreadMount events\");\n@@ -171,1 +204,1 @@\n-            log(\"unexpected count of ThreadUnmount events\");\n+            log(\"FAILED: unexpected count of ThreadUnmount events\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":99,"deletions":66,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <atomic>\n@@ -30,17 +31,1 @@\n-#ifdef _WIN32\n-#define VARIADICJNI __cdecl\n-#else\n-#define VARIADICJNI JNICALL\n-#endif\n-\n-namespace {\n-  std::mutex lock;\n-  jvmtiEnv *jvmti = nullptr;\n-  int thread_end_cnt = 0;\n-  int thread_unmount_cnt = 0;\n-  int thread_mount_cnt = 0;\n-\n-  void JNICALL VirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread virtual_thread) {\n-    std::lock_guard<std::mutex> lockGuard(lock);\n-    thread_end_cnt++;\n-  }\n+extern \"C\" {\n@@ -48,4 +33,4 @@\n-  void VARIADICJNI VirtualThreadMount(jvmtiEnv* jvmti, ...) {\n-    std::lock_guard<std::mutex> lockGuard(lock);\n-    thread_mount_cnt++;\n-  }\n+static jvmtiEnv *jvmti = nullptr;\n+static std::atomic<int> thread_end_cnt(0);\n+static std::atomic<int> thread_unmount_cnt(0);\n+static std::atomic<int> thread_mount_cnt(0);\n@@ -53,4 +38,2 @@\n-  void VARIADICJNI VirtualThreadUnmount(jvmtiEnv* jvmti, ...) {\n-    std::lock_guard<std::mutex> lockGuard(lock);\n-    thread_unmount_cnt++;\n-  }\n+void JNICALL VirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread vthread) {\n+  thread_end_cnt++;\n@@ -59,1 +42,3 @@\n-extern \"C\" {\n+void JNICALL VirtualThreadMount(jvmtiEnv* jvmti, ...) {\n+  thread_mount_cnt++;\n+}\n@@ -61,6 +46,2 @@\n-void\n-check_jvmti_err(jvmtiError err, const char* msg) {\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"Error in JVMTI %s: %s(%d)\\n\", msg, TranslateError(err), err);\n-    abort();\n-  }\n+void JNICALL VirtualThreadUnmount(jvmtiEnv* jvmti, ...) {\n+  thread_unmount_cnt++;\n@@ -71,1 +52,0 @@\n-  std::lock_guard<std::mutex> lockGuard(lock);\n@@ -77,1 +57,0 @@\n-  std::lock_guard<std::mutex> lockGuard(lock);\n@@ -83,1 +62,0 @@\n-  std::lock_guard<std::mutex> lockGuard(lock);\n@@ -100,1 +78,1 @@\n-  check_jvmti_err(jvmti->AddCapabilities(&caps), \"AddCapabilities\");\n+  check_jvmti_error(jvmti->AddCapabilities(&caps), \"AddCapabilities\");\n@@ -106,1 +84,1 @@\n-  check_jvmti_err(err, \"SetEventCallbacks\");\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n@@ -109,1 +87,1 @@\n-  check_jvmti_err(err, \"SetExtEventCallback for VirtualThreadMount\");\n+  check_jvmti_error(err, \"SetExtEventCallback for VirtualThreadMount\");\n@@ -112,1 +90,1 @@\n-  check_jvmti_err(err, \"SetExtEventCallback for VirtualThreadUnmount\");\n+  check_jvmti_error(err, \"SetExtEventCallback for VirtualThreadUnmount\");\n@@ -115,1 +93,1 @@\n-  check_jvmti_err(err, \"SetEventNotificationMode for VirtualThreadEnd\");\n+  check_jvmti_error(err, \"SetEventNotificationMode for VirtualThreadEnd\");\n@@ -118,1 +96,1 @@\n-  check_jvmti_err(err, \"SetEventNotificationMode for VirtualThreadMount\");\n+  check_jvmti_error(err, \"SetEventNotificationMode for VirtualThreadMount\");\n@@ -121,1 +99,1 @@\n-  check_jvmti_err(err, \"SetEventNotificationMode for VirtualThreadUnmount\");\n+  check_jvmti_error(err, \"SetEventNotificationMode for VirtualThreadUnmount\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/libVThreadEventTest.cpp","additions":20,"deletions":42,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -131,0 +131,7 @@\n+static void\n+check_jvmti_error(jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"check_jvmti_error: JVMTI function returned error: %s: %s(%d)\\n\", msg, TranslateError(err), err);\n+    abort();\n+  }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}