{"files":[{"patch":"@@ -42,0 +42,5 @@\n+\/*\n+ * The test uses custom implementation of the CountDownLatch class.\n+ * The reason is we want the state of tested thread to be predictable.\n+ * With original CountDownLatch it is not clear what thread state is expected.\n+ *\/\n@@ -74,1 +79,0 @@\n-    private static volatile int completedNo;\n@@ -100,1 +104,1 @@\n-        ready1.countDown(); \/\/ to guaranty state is not State.WAITING after await() above\n+        ready1.countDown(); \/\/ to guaranty state is not State.WAITING after await(mready)\n@@ -107,1 +111,0 @@\n-        completedNo++;\n@@ -119,1 +122,0 @@\n-        completedNo++;\n@@ -132,1 +134,0 @@\n-        completedNo++;\n@@ -151,1 +152,1 @@\n-            await(ready1);\n+            await(ready1); \/\/ to guaranty state is not State.WAITING after await(mready) in test1() \n@@ -167,4 +168,0 @@\n-            log(\"main: completedNo: \" + completedNo);\n-            if (completedNo > 0) {\n-                throw new RuntimeException(\"FAILED: none of vthreadsexpected to complete at this point\");\n-            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"}]}