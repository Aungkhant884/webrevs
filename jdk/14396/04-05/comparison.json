{"files":[{"patch":"@@ -295,1 +295,8 @@\n-  constexpr uint8_t cast(int x) const { return checked_cast<uint8_t>(x); }\n+  \/\/ -1 tolerant cast needed by callers of emit_int8 and emit_int16\n+  template <typename T>\n+  constexpr T cast(int x) const {\n+   if (x == -1) {\n+    return std::numeric_limits<T>::max();\n+   } else {\n+     return checked_cast<T>(x); }\n+  }\n@@ -306,1 +313,1 @@\n-  void emit_int8(int v)     { emit_int8(cast(v)); }\n+  void emit_int8(int v)     { emit_int8(cast<uint8_t>(v)); }\n@@ -309,1 +316,1 @@\n-  void emit_int16(int x)        { emit_int16(checked_cast<uint16_t>(x)); }\n+  void emit_int16(int x)        { emit_int16(cast<uint16_t>(x)); }\n@@ -311,2 +318,3 @@\n-  void emit_int16(int x1, int x2)                                  { code_section()->emit_int16(cast(x1), cast(x2)); }\n-  void emit_int24(int x1, int x2, int x3)                          { code_section()->emit_int24(cast(x1), cast(x2), cast(x3)); }\n+  void emit_int16(int x1, int x2)                 { code_section()->emit_int16(cast<uint8_t>(x1), cast<uint8_t>(x2)); }\n+  void emit_int24(int x1, int x2, int x3)         { code_section()->emit_int24(cast<uint8_t>(x1), cast<uint8_t>(x2),\n+                                                                               cast<uint8_t>(x3)); }\n@@ -314,2 +322,3 @@\n-  void emit_int32(uint32_t x)                                      { code_section()->emit_int32(x); }\n-  void emit_int32(int x1, int x2, int x3, int x4)                  { code_section()->emit_int32(cast(x1), cast(x2), cast(x3), cast(x4)); }\n+  void emit_int32(uint32_t x)                     { code_section()->emit_int32(x); }\n+  void emit_int32(int x1, int x2, int x3, int x4) { code_section()->emit_int32(cast<uint8_t>(x1), cast<uint8_t>(x2),\n+                                                                               cast<uint8_t>(x3), cast<uint8_t>(x4)); }\n@@ -317,1 +326,1 @@\n-  void emit_int64(  uint64_t x)                                     { code_section()->emit_int64(x); }\n+  void emit_int64(  uint64_t x)                   { code_section()->emit_int64(x); }\n@@ -319,3 +328,3 @@\n-  void emit_float(  jfloat  x)                                      { code_section()->emit_float(x); }\n-  void emit_double( jdouble x)                                      { code_section()->emit_double(x); }\n-  void emit_address(address x)                                      { code_section()->emit_address(x); }\n+  void emit_float(  jfloat  x)                    { code_section()->emit_float(x); }\n+  void emit_double( jdouble x)                    { code_section()->emit_double(x); }\n+  void emit_address(address x)                    { code_section()->emit_address(x); }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -42,1 +41,0 @@\n-#include <limits>\n@@ -517,3 +515,3 @@\n-\/\/ lives safer with this function, which ensures that any cast\n-\/\/ fits within the size of the type cast to, and tolerates -1\n-\/\/ It doesn't check everything: it isn't intended to make sure that pointer types are\n+\/\/ lives safer with this function, which ensures that any cast is\n+\/\/ reversible without loss of information. It doesn't check\n+\/\/ everything: it isn't intended to make sure that pointer types are\n@@ -521,12 +519,1 @@\n-template <typename T2, typename T1, ENABLE_IF(std::is_signed<T1>::value)>\n-constexpr T2 checked_cast(T1 thing) {\n-  if (!std::is_signed<T2>::value && thing == -1) {\n-    return std::numeric_limits<T2>::max();\n-  } else {\n-    T2 result = static_cast<T2>(thing);\n-    assert(static_cast<T1>(result) == thing, \"must be\");\n-    return result;\n-  }\n-}\n-\n-template <typename T2, typename T1, ENABLE_IF(!std::is_signed<T1>::value)>\n+template <typename T2, typename T1>\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"}]}