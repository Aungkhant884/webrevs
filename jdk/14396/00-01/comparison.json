{"files":[{"patch":"@@ -301,3 +301,1 @@\n-  \/\/ These take full width arguments and cast down without checking. Many callers have sign extension converting up to\n-  \/\/ full int width arguments, so this casts this away.\n-  void emit_int8(   uint32_t x1)                                    { code_section()->emit_int8((uint8_t)x1); }\n+  void emit_int8(   uint32_t x1)                                    { code_section()->emit_int8(checked_cast<uint8_t>(x1)); }\n@@ -305,2 +303,3 @@\n-  void emit_int16(  uint32_t x)                                     { code_section()->emit_int16((uint16_t)x); }\n-  void emit_int16(  uint32_t x1, uint32_t x2)                       { code_section()->emit_int16((uint8_t)x1, (uint8_t)x2); }\n+  void emit_int16(  uint32_t x)                                     { code_section()->emit_int16(checked_cast<uint16_t>(x)); }\n+  void emit_int16(  uint32_t x1, uint32_t x2)                       { code_section()->emit_int16(checked_cast<uint8_t>(x1),\n+                                                                                                 checked_cast<uint8_t>(x2)); }\n@@ -308,1 +307,3 @@\n-  void emit_int24(  uint32_t x1, uint32_t x2, uint32_t x3)          { code_section()->emit_int24((uint8_t)x1, (uint8_t)x2, (uint8_t)x3); }\n+  void emit_int24(  uint32_t x1, uint32_t x2, uint32_t x3)          { code_section()->emit_int24(checked_cast<uint8_t>(x1),\n+                                                                                                 checked_cast<uint8_t>(x2),\n+                                                                                                 checked_cast<uint8_t>(x3)); }\n@@ -310,2 +311,5 @@\n-  void emit_int32(  uint64_t x)                                     { code_section()->emit_int32((uint32_t)x); }\n-  void emit_int32(  uint32_t x1, uint32_t x2, uint32_t x3, uint32_t x4) { code_section()->emit_int32((uint8_t)x1, (uint8_t)x2, (uint8_t)x3, (uint8_t)x4); }\n+  void emit_int32(  uint64_t x)                                     { code_section()->emit_int32(checked_cast<uint32_t>(x)); }\n+  void emit_int32(  uint32_t x1, uint32_t x2, uint32_t x3, uint32_t x4) { code_section()->emit_int32(checked_cast<uint8_t>(x1),\n+                                                                                                     checked_cast<uint8_t>(x2),\n+                                                                                                     checked_cast<uint8_t>(x3),\n+                                                                                                     checked_cast<uint8_t>(x4)); }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include <limits>\n@@ -515,3 +516,3 @@\n-\/\/ lives safer with this function, which ensures that any cast is\n-\/\/ reversible without loss of information. It doesn't check\n-\/\/ everything: it isn't intended to make sure that pointer types are\n+\/\/ lives safer with this function, which ensures that any cast\n+\/\/ fits within the size of the type cast to, and tolerates sign extension.\n+\/\/ It doesn't check everything: it isn't intended to make sure that pointer types are\n@@ -521,3 +522,8 @@\n-  T2 result = static_cast<T2>(thing);\n-  assert(static_cast<T1>(result) == thing, \"must be\");\n-  return result;\n+#ifdef ASSERT\n+  typedef typename std::make_signed<T1>::type S1;\n+  S1 test = static_cast<S1>(thing);\n+  S1 max = std::numeric_limits<T2>::max();\n+  S1 min = (std::is_signed<T2>::value) ? std::numeric_limits<T2>::min() : -max;\n+  assert(test <= max && test >= min, \"out of range of destination type\");\n+#endif\n+  return static_cast<T2>(thing);\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"}]}