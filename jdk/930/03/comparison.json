{"files":[{"patch":"@@ -1272,1 +1272,4 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))\n+\/\/ This is a JRT_BLOCK_ENTRY because we have to stash away the return oop\n+\/\/ before transitioning to VM, and restore it after transitioning back\n+\/\/ to Java. The return oop at the top-of-stack, is not walked by the GC.\n+JRT_BLOCK_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1563,1 +1563,1 @@\n-void JvmtiExport::post_method_exit(JavaThread *thread, Method* method, frame current_frame) {\n+void JvmtiExport::post_method_exit(JavaThread* thread, Method* method, frame current_frame) {\n@@ -1567,5 +1567,0 @@\n-  EVT_TRIG_TRACE(JVMTI_EVENT_METHOD_EXIT, (\"[%s] Trg Method Exit triggered %s.%s\",\n-                     JvmtiTrace::safe_get_thread_name(thread),\n-                     (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                     (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n-\n@@ -1573,0 +1568,1 @@\n+\n@@ -1581,1 +1577,3 @@\n-\n+  Handle result;\n+  jvalue value;\n+  value.j = 0L;\n@@ -1584,4 +1582,0 @@\n-    Handle result;\n-    jvalue value;\n-    value.j = 0L;\n-\n@@ -1597,0 +1591,1 @@\n+        value.l = JNIHandles::make_local(thread, result());\n@@ -1599,0 +1594,1 @@\n+  }\n@@ -1600,0 +1596,25 @@\n+  \/\/ Deferred transition to VM, so we can stash away the return oop before GC\n+  \/\/ Note that this transition is not needed when throwing an exception, because\n+  \/\/ there is no oop to retain.\n+  JRT_BLOCK\n+    post_method_exit_inner(thread, mh, state, exception_exit, current_frame, value);\n+  JRT_BLOCK_END\n+\n+  if (result.not_null() && !mh->is_native()) {\n+    \/\/ We have to restore the oop on the stack for interpreter frames\n+    *(oop*)current_frame.interpreter_frame_tos_address() = result();\n+  }\n+}\n+\n+void JvmtiExport::post_method_exit_inner(JavaThread* thread,\n+                                         methodHandle& mh,\n+                                         JvmtiThreadState *state,\n+                                         bool exception_exit,\n+                                         frame current_frame,\n+                                         jvalue& value) {\n+  EVT_TRIG_TRACE(JVMTI_EVENT_METHOD_EXIT, (\"[%s] Trg Method Exit triggered %s.%s\",\n+                                           JvmtiTrace::safe_get_thread_name(thread),\n+                                           (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n+                                           (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n+\n+  if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT)) {\n@@ -1610,3 +1631,0 @@\n-        if (result.not_null()) {\n-          value.l = JNIHandles::make_local(thread, result());\n-        }\n@@ -1804,1 +1822,3 @@\n-        JvmtiExport::post_method_exit(thread, method, thread->last_frame());\n+        jvalue no_value;\n+        no_value.j = 0L;\n+        JvmtiExport::post_method_exit_inner(thread, mh, state, true, thread->last_frame(), no_value);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -196,0 +196,7 @@\n+  static void post_method_exit_inner(JavaThread* thread,\n+                                     methodHandle& mh,\n+                                     JvmtiThreadState *state,\n+                                     bool exception_exit,\n+                                     frame current_frame,\n+                                     jvalue& value);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}