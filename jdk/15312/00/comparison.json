{"files":[{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_DOUBLYLINKEDLIST_HPP\n+#define SHARE_UTILITIES_DOUBLYLINKEDLIST_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+template<typename NodeTraits>\n+class DoublyLinkedList;\n+\n+\/\/ Base element in a doubly linked list.\n+class DoublyLinkedListNode {\n+  template<typename T>\n+  friend class DoublyLinkedList;\n+\n+  DoublyLinkedListNode* _next;\n+  DoublyLinkedListNode* _prev;\n+\n+  NONCOPYABLE(DoublyLinkedListNode);\n+\n+  void verify_links() const;\n+  void verify_links_linked() const;\n+  void verify_links_unlinked() const;\n+\n+public:\n+  DoublyLinkedListNode();\n+  ~DoublyLinkedListNode();\n+};\n+\n+template <typename T, size_t m_offset>\n+struct ListNodeTraits {\n+  using ValueType = T;\n+\n+  static DoublyLinkedListNode* to_node_ptr(ValueType* elem) {\n+    return reinterpret_cast<DoublyLinkedListNode*>(\n+              reinterpret_cast<char*>(elem) + m_offset);\n+  }\n+\n+  static ValueType* to_value_ptr(DoublyLinkedListNode* node ) {\n+    return reinterpret_cast<ValueType*>(\n+              reinterpret_cast<char*>(node) - m_offset);\n+  }\n+};\n+\n+\n+\/\/ The DoublyLinkedList template provides insertion, removal, and traversal of elements in a doubly\n+\/\/ linked list structure. The DoublyLinkedList is configured using NodeTraits which contain\n+\/\/ information on the Nodes in the list. NodeTraits must support the interface:\n+\/\/    typedef ValueType; - Type of elements in the list\n+\/\/    static ValueType* to_value_ptr(DoublyLinkedListNode* node ); - return the element that contains the list node.\n+\/\/    static DoublyLinkedListNode* to_node_ptr(ValueType* elem); - return the DoublyLinkedList node associated with the list.\n+\/\/\n+\/\/ Note: The DoublyLinkedList does not perform memory allocation or deallocation for the elements.\n+\/\/ Therefore, it is the responsibility of the class template users to manage the memory of the\n+\/\/ elements added or removed from the list.\n+\/\/\n+template<typename NodeTraits>\n+class DoublyLinkedList {\n+  using Node = DoublyLinkedListNode;\n+  using T = typename NodeTraits::ValueType;\n+\n+  Node _head;\n+  size_t _size;\n+\n+  NONCOPYABLE(DoublyLinkedList);\n+\n+  void verify_head() const;\n+\n+  void insert(Node* before, Node* node);\n+\n+  Node* cast_to_inner(T* elem) const;\n+  T* cast_to_outer(Node* node) const;\n+\n+  Node* next(Node* elem) const;\n+  Node* prev(Node* elem) const;\n+\n+public:\n+  DoublyLinkedList();\n+  ~DoublyLinkedList();\n+\n+  size_t size() const;\n+  bool is_empty() const;\n+\n+  T* first() const;\n+  T* last() const;\n+\n+  void insert_first(T* elem);\n+  void insert_last(T* elem);\n+  void insert_before(T* before, T* elem);\n+  void insert_after(T* after, T* elem);\n+\n+  void remove(T* elem);\n+  T* remove_first();\n+  T* remove_last();\n+\n+  class Iterator;\n+\n+  class RemoveIterator;\n+\n+  Iterator begin();\n+  Iterator end();\n+};\n+\n+template <typename NodeTraits>\n+class DoublyLinkedList<NodeTraits>::Iterator : public StackObj {\n+  using T = typename NodeTraits::ValueType;\n+  friend class DoublyLinkedList<NodeTraits>;\n+\n+  const DoublyLinkedList<NodeTraits>* const _list;\n+  DoublyLinkedListNode* _cur_node;\n+\n+  Iterator(const DoublyLinkedList<NodeTraits>* list, DoublyLinkedListNode* start);\n+\n+public:\n+  Iterator& operator++() {\n+    _cur_node = _list->next(_cur_node);\n+    return *this;\n+  }\n+\n+  Iterator operator++(int) {\n+    Iterator tmp = *this;\n+    ++(*this);\n+    return tmp;\n+  }\n+\n+  Iterator& operator--() {\n+    assert(_cur_node != nullptr, \"Sanity\");\n+    _cur_node = _list->prev(_cur_node);\n+    return *this;\n+  }\n+\n+  Iterator operator--(int) {\n+    Iterator tmp = *this;\n+    --(*this);\n+    return tmp;\n+  }\n+\n+  T* operator*() { return _list->cast_to_outer(_cur_node); }\n+\n+  bool operator==(const Iterator& rhs) {\n+    assert(_list == rhs._list, \"iterator belongs to different List\");\n+    return _cur_node == rhs._cur_node;\n+  }\n+\n+  bool operator!=(const Iterator& rhs) {\n+    assert(_list == rhs._list, \"iterator belongs to different List\");\n+    return _cur_node != rhs._cur_node;\n+  }\n+};\n+\n+template <typename NodeTraits>\n+class DoublyLinkedList<NodeTraits>::RemoveIterator : public StackObj {\n+  using T = typename NodeTraits::ValueType;\n+private:\n+  DoublyLinkedList<NodeTraits>* const _list;\n+  const bool _forward;\n+\n+public:\n+  explicit RemoveIterator(DoublyLinkedList<NodeTraits>* list, bool forward_iterate = true);\n+\n+  bool next(T** elem);\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_DOUBLYLINKEDLIST_HPP\n","filename":"src\/hotspot\/share\/utilities\/doublyLinkedList.hpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_DOUBLYLINKEDLIST_INLINE_HPP\n+#define SHARE_UTILITIES_DOUBLYLINKEDLIST_INLINE_HPP\n+\n+#include \"utilities\/doublyLinkedList.hpp\"\n+\n+#include \"utilities\/debug.hpp\"\n+\n+inline DoublyLinkedListNode::DoublyLinkedListNode()\n+  : _next(this),\n+    _prev(this) { }\n+\n+inline DoublyLinkedListNode::~DoublyLinkedListNode() {\n+  verify_links_unlinked();\n+}\n+\n+inline void DoublyLinkedListNode::verify_links() const {\n+  assert(_next->_prev == this, \"Corrupt list node\");\n+  assert(_prev->_next == this, \"Corrupt list node\");\n+}\n+\n+inline void DoublyLinkedListNode::verify_links_linked() const {\n+  assert(_next != this, \"Should be in a list\");\n+  assert(_prev != this, \"Should be in a list\");\n+  verify_links();\n+}\n+\n+inline void DoublyLinkedListNode::verify_links_unlinked() const {\n+  assert(_next == this, \"Should not be in a list\");\n+  assert(_prev == this, \"Should not be in a list\");\n+}\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::verify_head() const {\n+  _head.verify_links();\n+}\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedList<NodeTraits>::~DoublyLinkedList() = default;\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::insert(Node* before, Node* node) {\n+  verify_head();\n+  before->verify_links();\n+  node->verify_links_unlinked();\n+\n+  node->_prev = before;\n+  node->_next = before->_next;\n+  before->_next = node;\n+  node->_next->_prev = node;\n+\n+  before->verify_links_linked();\n+  node->verify_links_linked();\n+\n+  _size++;\n+}\n+\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedListNode* DoublyLinkedList<NodeTraits>::cast_to_inner(T* elem) const {\n+  return NodeTraits::to_node_ptr(elem);\n+}\n+\n+template <typename NodeTraits>\n+inline typename NodeTraits::ValueType* DoublyLinkedList<NodeTraits>::cast_to_outer(Node* node) const {\n+  return NodeTraits::to_value_ptr(node);\n+}\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedList<NodeTraits>::DoublyLinkedList()\n+  : _head(),\n+    _size(0) {\n+  verify_head();\n+}\n+\n+template <typename NodeTraits>\n+inline size_t DoublyLinkedList<NodeTraits>::size() const {\n+  verify_head();\n+  return _size;\n+}\n+\n+template <typename NodeTraits>\n+inline bool DoublyLinkedList<NodeTraits>::is_empty() const {\n+  return size() == 0;\n+}\n+\n+template <typename NodeTraits>\n+inline typename NodeTraits::ValueType* DoublyLinkedList<NodeTraits>::first() const {\n+  return is_empty() ? nullptr : cast_to_outer(_head._next);\n+}\n+\n+template <typename NodeTraits>\n+inline typename NodeTraits::ValueType* DoublyLinkedList<NodeTraits>::last() const {\n+  return is_empty() ? nullptr : cast_to_outer(_head._prev);\n+}\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedListNode* DoublyLinkedList<NodeTraits>::next(Node* elem) const {\n+  verify_head();\n+\n+  return elem->_next;\n+}\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedListNode* DoublyLinkedList<NodeTraits>::prev(Node* elem) const {\n+  verify_head();\n+\n+  return elem->_prev;\n+}\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::insert_first(T* elem) {\n+  insert(&_head, cast_to_inner(elem));\n+}\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::insert_last(T* elem) {\n+  insert(_head._prev, cast_to_inner(elem));\n+}\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::insert_before(T* before, T* elem) {\n+  insert(cast_to_inner(before)->_prev, cast_to_inner(elem));\n+}\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::insert_after(T* after, T* elem) {\n+  insert(cast_to_inner(after), cast_to_inner(elem));\n+}\n+\n+template <typename NodeTraits>\n+inline void DoublyLinkedList<NodeTraits>::remove(T* elem) {\n+  verify_head();\n+\n+  Node* const node = cast_to_inner(elem);\n+  node->verify_links_linked();\n+\n+  Node* const next = node->_next;\n+  Node* const prev = node->_prev;\n+  next->verify_links_linked();\n+  prev->verify_links_linked();\n+\n+  node->_next = prev->_next;\n+  node->_prev = next->_prev;\n+  node->verify_links_unlinked();\n+\n+  next->_prev = prev;\n+  prev->_next = next;\n+  next->verify_links();\n+  prev->verify_links();\n+\n+  assert(_size > 0, \"Sanity check!\");\n+  _size--;\n+}\n+\n+template <typename NodeTraits>\n+inline typename NodeTraits::ValueType* DoublyLinkedList<NodeTraits>::remove_first() {\n+  T* elem = first();\n+  if (elem != nullptr) {\n+    remove(elem);\n+  }\n+  return elem;\n+}\n+\n+template <typename NodeTraits>\n+inline typename NodeTraits::ValueType* DoublyLinkedList<NodeTraits>::remove_last() {\n+  T* elem = last();\n+  if (elem != nullptr) {\n+    remove(elem);\n+  }\n+  return elem;\n+}\n+\n+template <typename NodeTraits>\n+inline typename DoublyLinkedList<NodeTraits>::Iterator DoublyLinkedList<NodeTraits>::begin() {\n+ return Iterator(this, _head._next);\n+}\n+\n+template <typename NodeTraits>\n+inline typename DoublyLinkedList<NodeTraits>::Iterator DoublyLinkedList<NodeTraits>::end() {\n+ return Iterator(this, &_head);\n+}\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedList<NodeTraits>::Iterator::Iterator(const DoublyLinkedList<NodeTraits>* list, DoublyLinkedListNode* start)\n+  : _list(list),\n+    _cur_node(start) {}\n+\n+template <typename NodeTraits>\n+inline DoublyLinkedList<NodeTraits>::RemoveIterator::RemoveIterator(DoublyLinkedList<NodeTraits>* list, bool forward_iterate)\n+  : _list(list),\n+    _forward(forward_iterate) {}\n+\n+\n+template <typename NodeTraits>\n+inline bool DoublyLinkedList<NodeTraits>::RemoveIterator::next(T** elem) {\n+  *elem = _forward ? _list->remove_first() : _list->remove_last();\n+  return *elem != nullptr;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_DOUBLYLINKEDLIST_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/doublyLinkedList.inline.hpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/doublyLinkedList.inline.hpp\"\n+\n+class ListTestElement : public StackObj {\n+ private:\n+  size_t _value;\n+ public:\n+  DoublyLinkedListNode _node;\n+\n+  ListTestElement(size_t i = 0)\n+    : _value(i),\n+      _node() { }\n+\n+  size_t value() const { return _value; }\n+\n+  void set_value(size_t value) { _value = value; }\n+};\n+\n+struct ListTestElement2 : public StackObj {\n+  size_t _value;\n+  DoublyLinkedListNode _list1;\n+  DoublyLinkedListNode _list2;\n+\n+  ListTestElement2(size_t i = 0)\n+    : _value(i),\n+      _list1(),\n+      _list2() { }\n+\n+  size_t value() const { return _value; }\n+  void set_value(size_t value) { _value = value; }\n+};\n+\n+struct TestNodeTraits {\n+  using ValueType = ListTestElement;\n+  using NodeType = DoublyLinkedListNode;\n+\n+  static NodeType* to_node_ptr(ValueType* elem) {\n+    return &elem->_node;\n+  }\n+\n+  static ValueType* to_value_ptr(NodeType* node ) {\n+    return (ValueType*)((uintptr_t)node - offset_of(ValueType, _node));\n+  }\n+};\n+\n+typedef DoublyLinkedList<TestNodeTraits> TestDoublyLinkedList;\n+\n+struct DoublyLinkedListTest : public ::testing::Test {\n+  static const size_t num_elements = 10;\n+  ListTestElement elements[num_elements];\n+  TestDoublyLinkedList dlist;\n+\n+  DoublyLinkedListTest();\n+  ~DoublyLinkedListTest();\n+\n+  void initialize();\n+  void teardown();\n+};\n+\n+const size_t DoublyLinkedListTest::num_elements;\n+\n+DoublyLinkedListTest::DoublyLinkedListTest() : dlist() {\n+  initialize();\n+}\n+\n+void DoublyLinkedListTest::initialize() {\n+  ASSERT_TRUE(dlist.is_empty());\n+  ASSERT_EQ(0u, dlist.size());\n+  ASSERT_TRUE(dlist.first() == nullptr);\n+  ASSERT_TRUE(dlist.last() == nullptr);\n+  ASSERT_TRUE(dlist.remove_first() == nullptr);\n+  ASSERT_TRUE(dlist.remove_last() == nullptr);\n+\n+  for (size_t i = 0; i < num_elements; ++i) {\n+    elements[i].set_value(i);\n+    ListTestElement* e = &elements[i];\n+    dlist.insert_last(e);\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(e, dlist.last());\n+  }\n+\n+  ASSERT_TRUE(dlist.first() == &elements[0]);\n+  ASSERT_EQ(num_elements, dlist.size());\n+}\n+\n+void DoublyLinkedListTest::teardown() {\n+  TestDoublyLinkedList::RemoveIterator rm_iter(&dlist);\n+\n+  ListTestElement* e = nullptr;\n+  while (rm_iter.next(&e)) { }\n+\n+  ASSERT_TRUE(dlist.is_empty());\n+  ASSERT_EQ(0u, dlist.size());\n+}\n+\n+DoublyLinkedListTest::~DoublyLinkedListTest() {\n+  teardown();\n+}\n+\n+TEST(DoublyLinkedList, node_traits) {\n+  ListTestElement2 e;\n+  constexpr uintptr_t offset = offsetof(ListTestElement2, _list1);\n+  DoublyLinkedListNode* list_node = ListNodeTraits<ListTestElement2, offset>::to_node_ptr(&e);\n+  ASSERT_EQ(list_node, &e._list1);\n+\n+  ListTestElement e2;\n+  DoublyLinkedListNode* list_node2 = TestNodeTraits::to_node_ptr(&e2);\n+  ASSERT_EQ(list_node2, &e2._node);\n+}\n+\n+TEST_F(DoublyLinkedListTest, insert_remove_last) {\n+\n+  for (size_t i = num_elements; i > 0; ) {\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(i, dlist.size());\n+    --i;\n+    ListTestElement* e = dlist.remove_last();\n+    ASSERT_TRUE(e != nullptr);\n+    ASSERT_EQ(e, &elements[i]);\n+  }\n+\n+  ASSERT_TRUE(dlist.is_empty());\n+  ASSERT_EQ(0u, dlist.size());\n+}\n+\n+TEST_F(DoublyLinkedListTest, insert_remove_first) {\n+  teardown(); \/\/ First clear the list\n+\n+  ASSERT_TRUE(dlist.is_empty());\n+  ASSERT_EQ(0u, dlist.size());\n+  ASSERT_TRUE(dlist.first() == nullptr);\n+  ASSERT_TRUE(dlist.last() == nullptr);\n+  ASSERT_TRUE(dlist.remove_first() == nullptr);\n+  ASSERT_TRUE(dlist.remove_last() == nullptr);\n+\n+  for (size_t i = 0; i < num_elements; ++i) {\n+    elements[i].set_value(i);\n+    ListTestElement* e = &elements[i];\n+    dlist.insert_first(e);\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(e, dlist.first());\n+  }\n+\n+  ASSERT_EQ(num_elements, dlist.size());\n+\n+  for (size_t i = num_elements; i > 0; ) {\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(i, dlist.size());\n+    --i;\n+    ListTestElement* e = dlist.remove_first();\n+    ASSERT_TRUE(e != nullptr);\n+    ASSERT_EQ(e, &elements[i]);\n+  }\n+\n+  ASSERT_TRUE(dlist.is_empty());\n+  ASSERT_EQ(0u, dlist.size());\n+}\n+\n+TEST_F(DoublyLinkedListTest, insert_remove) {\n+\n+  ListTestElement* first = dlist.remove_first();\n+  ListTestElement* last = dlist.last();\n+\n+  dlist.insert_after(last, first);\n+  ASSERT_EQ(first, dlist.last());\n+\n+  first = dlist.remove_last();\n+  dlist.insert_before(last, first);\n+  ASSERT_EQ(last, dlist.last());\n+}\n+\n+TEST_F(DoublyLinkedListTest, forward_iterate) {\n+  size_t i = 0;\n+  for (ListTestElement* e : dlist) {\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(e, &elements[i++]);\n+  }\n+\n+  TestDoublyLinkedList::Iterator iter = dlist.begin();\n+  i = 0;\n+  while (iter != dlist.end()) {\n+    ListTestElement* e = *iter;\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(e, &elements[i++]);\n+    ++iter;\n+  }\n+}\n+\n+TEST_F(DoublyLinkedListTest, reverse_iterate) {\n+  size_t i = num_elements;\n+  TestDoublyLinkedList::Iterator iter = dlist.end();\n+\n+  while (iter-- != dlist.begin()) {\n+    ListTestElement* e = *iter;\n+    ASSERT_FALSE(dlist.is_empty());\n+    ASSERT_EQ(e, &elements[--i]);\n+  }\n+}\n+\n+TEST_F(DoublyLinkedListTest, remove_iterate) {\n+  size_t i = num_elements;\n+  TestDoublyLinkedList::RemoveIterator rm_iter(&dlist, false \/* forward_iterate *\/);\n+\n+  ListTestElement* e = nullptr;\n+  while (rm_iter.next(&e)) {\n+    ASSERT_EQ(e, &elements[--i]);\n+  }\n+\n+  ASSERT_TRUE(dlist.is_empty());\n+  ASSERT_EQ(0u, dlist.size());\n+}\n+\n+TEST(DoublyLinkedList, two_lists) {\n+  constexpr uintptr_t offset_list_1 = offsetof(ListTestElement2, _list1);\n+  constexpr uintptr_t offset_list_2 = offsetof(ListTestElement2, _list2);\n+\n+  using TestListType_1 = DoublyLinkedList<ListNodeTraits<ListTestElement2, offset_list_1>>;\n+  using TestListType_2 = DoublyLinkedList<ListNodeTraits<ListTestElement2, offset_list_2>>;\n+\n+  TestListType_1 dlist_1;\n+  TestListType_2 dlist_2;\n+\n+  static const size_t num_elements = 10;\n+  ListTestElement2 elements[num_elements];\n+\n+  ASSERT_TRUE(dlist_1.is_empty());\n+  ASSERT_TRUE(dlist_2.is_empty());\n+\n+  for (size_t i = 0; i < num_elements; ++i) {\n+    elements[i].set_value(i);\n+    ListTestElement2* e = &elements[i];\n+    dlist_1.insert_last(e);\n+    ASSERT_FALSE(dlist_1.is_empty());\n+    ASSERT_EQ(e, dlist_1.last());\n+\n+    dlist_2.insert_last(e);\n+  }\n+\n+  ASSERT_EQ(num_elements, dlist_1.size());\n+  ASSERT_EQ(num_elements, dlist_2.size());\n+\n+  TestListType_1::RemoveIterator rm_iter(&dlist_1, false \/* forward_iterate *\/);\n+\n+  size_t i = num_elements;\n+  ListTestElement2* e = nullptr;\n+  while (rm_iter.next(&e)) {\n+    ASSERT_EQ(e, &elements[--i]);\n+  }\n+\n+  ASSERT_TRUE(dlist_1.is_empty());\n+  ASSERT_EQ(0u, dlist_1.size());\n+\n+  ASSERT_EQ(num_elements, dlist_2.size());\n+\n+  TestListType_2::RemoveIterator rm_iter2(&dlist_2, true \/* forward_iterate *\/);\n+\n+  i = 0;\n+  while (rm_iter2.next(&e)) {\n+    ASSERT_EQ(e, &elements[i++]);\n+  }\n+\n+  ASSERT_TRUE(dlist_2.is_empty());\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_doublyLinkedList.cpp","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"}]}