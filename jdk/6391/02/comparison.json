{"files":[{"patch":"@@ -486,0 +486,1 @@\n+  assert(i < _n, \"index out of range.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -323,0 +323,1 @@\n+  assert(queue_num < _n, \"index out of range.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,6 @@\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -36,0 +42,1 @@\n+import java.io.Serial;\n@@ -39,0 +46,1 @@\n+import java.util.concurrent.RecursiveTask;\n@@ -41,6 +49,0 @@\n-import jdk.internal.math.DoubleConsts;\n-import jdk.internal.math.FloatConsts;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -1068,1 +1070,1 @@\n-            v2 = v.square().add(d.multiply(u.square())).mod(n);\n+            v2 = v.square(false).add(d.multiply(u.square(false))).mod(n);\n@@ -1584,1 +1586,16 @@\n-        return multiply(val, false);\n+        return multiply(val, false, false);\n+    }\n+\n+    \/**\n+     * Returns a BigInteger whose value is {@code (this * val)}.\n+     * When both {@code this} and {@code val} are large, typically\n+     * in the thousands of bits, parallel multiply might be used.\n+     *\n+     * @implNote An implementation may offer better algorithmic\n+     * performance when {@code val == this}.\n+     *\n+     * @param  val value to be multiplied by this BigInteger.\n+     * @return {@code this * val}\n+     *\/\n+    public BigInteger parallelMultiply(BigInteger val) {\n+        return multiply(val, false, true);\n@@ -1593,0 +1610,1 @@\n+     * @param  parallel whether the multiply should be done in parallel\n@@ -1595,1 +1613,1 @@\n-    private BigInteger multiply(BigInteger val, boolean isRecursion) {\n+    private BigInteger multiply(BigInteger val, boolean isRecursion, boolean parallel) {\n@@ -1602,1 +1620,1 @@\n-            return square();\n+            return square(parallel);\n@@ -1680,1 +1698,1 @@\n-                return multiplyToomCook3(this, val);\n+                return multiplyToomCook3(this, val, parallel);\n@@ -1847,0 +1865,27 @@\n+    private static final class RecursiveMultiply extends RecursiveTask<BigInteger> {\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n+        private final BigInteger a;\n+        private final BigInteger b;\n+        private final boolean isRecursive;\n+        private final boolean parallel;\n+\n+        private RecursiveMultiply(BigInteger a, BigInteger b, boolean isRecursive, boolean parallel) {\n+            this.a = a;\n+            this.b = b;\n+            this.isRecursive = isRecursive;\n+            this.parallel = parallel;\n+        }\n+\n+        @Override\n+        protected BigInteger compute() {\n+            return a.multiply(b, isRecursive, parallel);\n+        }\n+\n+        public static RecursiveMultiply create(BigInteger a, BigInteger b, boolean isRecursive, boolean parallel) {\n+            var result = new RecursiveMultiply(a, b, isRecursive, parallel);\n+            if (parallel) result.fork(); else result.invoke();\n+            return result;\n+        }\n+    }\n+\n@@ -1875,1 +1920,1 @@\n-    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {\n+    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b, boolean parallel) {\n@@ -1899,1 +1944,2 @@\n-        v0 = a0.multiply(b0, true);\n+        var v0_task = RecursiveMultiply.create(a0, b0, true, parallel);\n+\/\/        v0 = a0.multiply(b0, true, parallel);\n@@ -1902,1 +1948,2 @@\n-        vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);\n+        var vm1_task = RecursiveMultiply.create(da1.subtract(a1), db1.subtract(b1), true, parallel);\n+\/\/        vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true, parallel);\n@@ -1905,1 +1952,2 @@\n-        v1 = da1.multiply(db1, true);\n+        var v1_task = RecursiveMultiply.create(da1, db1, true, parallel);\n+\/\/        v1 = da1.multiply(db1, true, parallel);\n@@ -1907,2 +1955,5 @@\n-             db1.add(b2).shiftLeft(1).subtract(b0), true);\n-        vinf = a2.multiply(b2, true);\n+             db1.add(b2).shiftLeft(1).subtract(b0), true, parallel);\n+        vinf = a2.multiply(b2, true, parallel);\n+        v0 = v0_task.join();\n+        vm1 = vm1_task.join();\n+        v1 = v1_task.join();\n@@ -2073,2 +2124,2 @@\n-    private BigInteger square() {\n-        return square(false);\n+    private BigInteger square(boolean parallel) {\n+        return square(false, parallel);\n@@ -2084,1 +2135,1 @@\n-    private BigInteger square(boolean isRecursion) {\n+    private BigInteger square(boolean isRecursion, boolean parallel) {\n@@ -2106,1 +2157,1 @@\n-                return squareToomCook3();\n+                return squareToomCook3(parallel);\n@@ -2226,2 +2277,2 @@\n-        BigInteger xhs = xh.square();  \/\/ xhs = xh^2\n-        BigInteger xls = xl.square();  \/\/ xls = xl^2\n+        BigInteger xhs = xh.square(false);  \/\/ xhs = xh^2\n+        BigInteger xls = xl.square(false);  \/\/ xls = xl^2\n@@ -2230,1 +2281,26 @@\n-        return xhs.shiftLeft(half*32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);\n+        return xhs.shiftLeft(half*32).add(xl.add(xh).square(false).subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);\n+    }\n+\n+    private static final class RecursiveSquare extends RecursiveTask<BigInteger> {\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n+        private final BigInteger num;\n+        private final boolean isRecursive;\n+        private final boolean parallel;\n+\n+        private RecursiveSquare(BigInteger a, boolean isRecursive, boolean parallel) {\n+            this.num = a;\n+            this.isRecursive = isRecursive;\n+            this.parallel = parallel;\n+        }\n+\n+        @Override\n+        protected BigInteger compute() {\n+            return num.square(isRecursive, parallel);\n+        }\n+\n+        public static RecursiveSquare create(BigInteger a, boolean isRecursive, boolean parallel) {\n+            var result = new RecursiveSquare(a, isRecursive, parallel);\n+            if (parallel) result.fork(); else result.invoke();\n+            return result;\n+        }\n@@ -2240,1 +2316,1 @@\n-    private BigInteger squareToomCook3() {\n+    private BigInteger squareToomCook3(boolean parallel) {\n@@ -2257,1 +2333,2 @@\n-        v0 = a0.square(true);\n+        var v0_fork = RecursiveSquare.create(a0, true, parallel);\n+\/\/        v0 = a0.square(true, parallel);\n@@ -2259,1 +2336,2 @@\n-        vm1 = da1.subtract(a1).square(true);\n+        var vm1_fork = RecursiveSquare.create(da1.subtract(a1), true, parallel);\n+\/\/        vm1 = da1.subtract(a1).square(true, parallel);\n@@ -2261,3 +2339,7 @@\n-        v1 = da1.square(true);\n-        vinf = a2.square(true);\n-        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true);\n+        var v1_fork = RecursiveSquare.create(da1, true, parallel);\n+\/\/        v1 = da1.square(true, parallel);\n+        vinf = a2.square(true, parallel);\n+        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true, parallel);\n+        v0 = v0_fork.join();\n+        vm1 = vm1_fork.join();\n+        v1 = v1_fork.join();\n@@ -2518,1 +2600,1 @@\n-                    partToSquare = partToSquare.square();\n+                    partToSquare = partToSquare.square(false);\n@@ -2577,1 +2659,1 @@\n-        BigInteger r = this.subtract(s.square());\n+        BigInteger r = this.subtract(s.square(false));\n@@ -3253,1 +3335,1 @@\n-                baseToPow2 = baseToPow2.square().mod2(p);\n+                baseToPow2 = baseToPow2.square(false).mod2(p);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":115,"deletions":33,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -314,17 +314,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            float left   = Math.min(Math.min(x1, x2),\n-                                    Math.min(ctrlx1, ctrlx2));\n-            float top    = Math.min(Math.min(y1, y2),\n-                                    Math.min(ctrly1, ctrly2));\n-            float right  = Math.max(Math.max(x1, x2),\n-                                    Math.max(ctrlx1, ctrlx2));\n-            float bottom = Math.max(Math.max(y1, y2),\n-                                    Math.max(ctrly1, ctrly2));\n-            return new Rectangle2D.Float(left, top,\n-                                         right - left, bottom - top);\n-        }\n-\n@@ -561,17 +544,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            double left   = Math.min(Math.min(x1, x2),\n-                                     Math.min(ctrlx1, ctrlx2));\n-            double top    = Math.min(Math.min(y1, y2),\n-                                     Math.min(ctrly1, ctrly2));\n-            double right  = Math.max(Math.max(x1, x2),\n-                                     Math.max(ctrlx1, ctrlx2));\n-            double bottom = Math.max(Math.max(y1, y2),\n-                                     Math.max(ctrly1, ctrly2));\n-            return new Rectangle2D.Double(left, top,\n-                                          right - left, bottom - top);\n-        }\n-\n@@ -1512,0 +1478,9 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.2\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return Path2D.getBounds2D(getPathIterator(null));\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/CubicCurve2D.java","additions":9,"deletions":34,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -798,24 +798,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.6\n-         *\/\n-        public final synchronized Rectangle2D getBounds2D() {\n-            float x1, y1, x2, y2;\n-            int i = numCoords;\n-            if (i > 0) {\n-                y1 = y2 = floatCoords[--i];\n-                x1 = x2 = floatCoords[--i];\n-                while (i > 0) {\n-                    float y = floatCoords[--i];\n-                    float x = floatCoords[--i];\n-                    if (x < x1) x1 = x;\n-                    if (y < y1) y1 = y;\n-                    if (x > x2) x2 = x;\n-                    if (y > y2) y2 = y;\n-                }\n-            } else {\n-                x1 = y1 = x2 = y2 = 0.0f;\n-            }\n-            return new Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);\n-        }\n-\n@@ -1590,24 +1566,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.6\n-         *\/\n-        public final synchronized Rectangle2D getBounds2D() {\n-            double x1, y1, x2, y2;\n-            int i = numCoords;\n-            if (i > 0) {\n-                y1 = y2 = doubleCoords[--i];\n-                x1 = x2 = doubleCoords[--i];\n-                while (i > 0) {\n-                    double y = doubleCoords[--i];\n-                    double x = doubleCoords[--i];\n-                    if (x < x1) x1 = x;\n-                    if (y < y1) y1 = y;\n-                    if (x > x2) x2 = x;\n-                    if (y > y2) y2 = y;\n-                }\n-            } else {\n-                x1 = y1 = x2 = y2 = 0.0;\n-            }\n-            return new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);\n-        }\n-\n@@ -2132,0 +2084,134 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.6\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return getBounds2D(getPathIterator(null));\n+    }\n+\n+    \/**\n+     * Returns a high precision bounding box of the specified PathIterator.\n+     * <p>\n+     * This method provides a basic facility for implementors of the {@link Shape} interface to\n+     * implement support for the {@link Shape#getBounds2D()} method.\n+     * <\/p>\n+     * @return an instance of {@code Rectangle2D} that is a high-precision bounding box of the\n+     *         {@code PathIterator}.\n+     * @see Shape#getBounds2D()\n+     *\/\n+    public static Rectangle2D getBounds2D(PathIterator pi) {\n+        \/\/ define x and y parametric coefficients where:\n+        \/\/ x(t) = x_coeff[0] + x_coeff[1] * t + x_coeff[2] * t^2 + x_coeff[3] * t^3\n+        double[] x_coeff = new double[4];\n+        double[] y_coeff = new double[4];\n+\n+        double[] coords = new double[6];\n+        double[] tExtrema = new double[3];\n+        boolean isEmpty = true;\n+        double leftX = 0.0;\n+        double rightX = 0.0;\n+        double topY = 0.0;\n+        double bottomY = 0.0;\n+        double lastX = 0.0;\n+        double lastY = 0.0;\n+\n+        pathIteratorLoop : while (!pi.isDone()) {\n+            int type = pi.currentSegment(coords);\n+            pi.next();\n+            double endX, endY;\n+            switch (type) {\n+                case PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO:\n+                    endX = coords[0];\n+                    endY = coords[1];\n+                    break;\n+                case PathIterator.SEG_QUADTO:\n+                    endX = coords[2];\n+                    endY = coords[3];\n+                    break;\n+                case PathIterator.SEG_CUBICTO:\n+                    endX = coords[4];\n+                    endY = coords[5];\n+                    break;\n+                default:\n+                    continue pathIteratorLoop;\n+            }\n+\n+            if (isEmpty) {\n+                \/\/ we're seeding our bounds for the first time:\n+                isEmpty = false;\n+                leftX = rightX = endX;\n+                topY = bottomY = endY;\n+            } else {\n+                \/\/ extend our rectangle to cover the point at t = 1:\n+                leftX = (endX < leftX) ? endX : leftX;\n+                rightX = (endX > rightX) ? endX : rightX;\n+                topY = (endY < topY) ? endY : topY;\n+                bottomY = (endY > bottomY) ? endY : bottomY;\n+            }\n+\n+            \/\/ here's the slightly trickier part: examine quadratic and cubic\n+            \/\/ segments for extrema where t is between (0, 1):\n+\n+            boolean definedParametricEquations;\n+            if (type == PathIterator.SEG_QUADTO) {\n+                definedParametricEquations = true;\n+\n+                x_coeff[3] = 0.0;\n+                x_coeff[2] = lastX - 2.0 * coords[0] + coords[2];\n+                x_coeff[1] = -2.0 * lastX + 2.0 * coords[0];\n+                x_coeff[0] = lastX;\n+\n+                y_coeff[3] = 0;\n+                y_coeff[2] = lastY - 2.0 * coords[1] + coords[3];\n+                y_coeff[1] = -2.0 * lastY + 2.0 * coords[1];\n+                y_coeff[0] = lastY;\n+            } else if (type == PathIterator.SEG_CUBICTO) {\n+                definedParametricEquations = true;\n+\n+                x_coeff[3] = -lastX + 3.0 * coords[0] - 3.0 * coords[2] + coords[4];\n+                x_coeff[2] = 3.0 * lastX - 6.0 * coords[0] + 3.0 * coords[2];\n+                x_coeff[1] = -3.0 * lastX + 3.0 * coords[0];\n+                x_coeff[0] = lastX;\n+\n+                y_coeff[3] = -lastY + 3.0 * coords[1] - 3.0 * coords[3] + coords[5];\n+                y_coeff[2] = 3.0 * lastY - 6.0 * coords[1] + 3.0 * coords[3];\n+                y_coeff[1] = -3.0 * lastY + 3.0 * coords[1];\n+                y_coeff[0] = lastY;\n+            } else {\n+                definedParametricEquations = false;\n+            }\n+\n+            if (definedParametricEquations) {\n+                int tExtremaCount = Curve.findExtrema(x_coeff, tExtrema);\n+                for(int i = 0; i < tExtremaCount; i++) {\n+                    double t = tExtrema[i];\n+                    if (t > 0 && t < 1) {\n+                        double x = x_coeff[0] + t * (x_coeff[1] + t * (x_coeff[2] + t * x_coeff[3]));\n+                        leftX = (x < leftX) ? x : leftX;\n+                        rightX = (x > rightX) ? x : rightX;\n+                    }\n+                }\n+\n+                tExtremaCount = Curve.findExtrema(y_coeff, tExtrema);\n+                for(int i = 0; i < tExtremaCount; i++) {\n+                    double t = tExtrema[i];\n+                    if (t > 0 && t < 1) {\n+                        double y = y_coeff[0] + t * (y_coeff[1] + t * (y_coeff[2] + t * y_coeff[3]));\n+                        topY = (y < topY) ? y : topY;\n+                        bottomY = (y > bottomY) ? y : bottomY;\n+                    }\n+                }\n+            }\n+\n+            lastX = endX;\n+            lastY = endY;\n+        }\n+        if (!isEmpty) {\n+            return new Rectangle2D.Double(leftX, topY, rightX - leftX, bottomY - topY);\n+        }\n+\n+        \/\/ there's room to debate what should happen here, but historically we return a zeroed\n+        \/\/ out rectangle here. So for backwards compatibility let's keep doing that:\n+        return new Rectangle2D.Double();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":134,"deletions":48,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -241,13 +241,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            float left   = Math.min(Math.min(x1, x2), ctrlx);\n-            float top    = Math.min(Math.min(y1, y2), ctrly);\n-            float right  = Math.max(Math.max(x1, x2), ctrlx);\n-            float bottom = Math.max(Math.max(y1, y2), ctrly);\n-            return new Rectangle2D.Float(left, top,\n-                                         right - left, bottom - top);\n-        }\n-\n@@ -431,13 +418,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            double left   = Math.min(Math.min(x1, x2), ctrlx);\n-            double top    = Math.min(Math.min(y1, y2), ctrly);\n-            double right  = Math.max(Math.max(x1, x2), ctrlx);\n-            double bottom = Math.max(Math.max(y1, y2), ctrly);\n-            return new Rectangle2D.Double(left, top,\n-                                          right - left, bottom - top);\n-        }\n-\n@@ -1338,0 +1312,8 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.2\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return Path2D.getBounds2D(getPathIterator(null));\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/QuadCurve2D.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -715,0 +715,66 @@\n+    \/**\n+     * Return the t values that correspond to possible extrema in a given cubic function.\n+     * <p>\n+     * If the coefficient of the t^3 is large then the polynomial is a cubic and up to\n+     * two values may be returned. If that coefficient is zero then the polynomial\n+     * is a quadratic and up to one value may be returned. But if that coefficient is\n+     * small then this method considers the possibility it could be either, so in that\n+     * scenario this method may return up to three values. For ex: if the leading\n+     * coefficient is .000001 that might be because the polynomial really is a cubic, or\n+     * it might be because of rounding error and the polynomial is basically a quadratic.\n+     * <\/p>\n+     *\n+     * @param coefficients four coefficients for a cubic polynomial equation. The nth element in this array is\n+     *                     the coefficient for (t^n).\n+     * @param dest an array to store the t values in. This must be at least 3 elements.\n+     * @return the number of t-values that were stored in dest. This will be between 0-3.\n+     *\/\n+    public static int findExtrema(double[] coefficients, double[] dest) {\n+\n+        int returnValue = 0;\n+\n+        if (coefficients[3] != 0.0) {\n+            \/\/ evaluate this as a cubic, where:\n+\n+            \/\/ f(t) = c[3] * t^3 + c[2] * t^2 + c[1] * t + c[0]\n+            \/\/ df\/dt = 3 * c[3] * t^2 + 2 * c[2] * t + c[1]\n+\n+            \/\/ so we have a quadratic polynomial:\n+            \/\/ df\/dt = A * t^2 + B * t + C\n+\n+            \/\/ ... where:\n+            \/\/ A = 3 * c[3]\n+            \/\/ B = 2 * c[2]\n+            \/\/ C = c[1]\n+\n+            double[] eqn = new double[]{ coefficients[1],\n+                    2.0 * coefficients[2],\n+                    3.0 * coefficients[3] };\n+            returnValue = QuadCurve2D.solveQuadratic(eqn, dest);\n+\n+            if (returnValue < 0.0)\n+                returnValue = 0;\n+        }\n+\n+        if (coefficients[3] > -.01 && coefficients[3] < .01 && coefficients[2] != 0.0) {\n+            \/\/ evaluate this as if it's a quadratic, where:\n+\n+            \/\/ f = c[2] * t^2 + c[1] * t + c[0]\n+\n+            \/\/ this only really makes sense if coefficients[3] is close to zero.\n+            \/\/ We chose \"less than .01\" as the threshold for \"close to zero\". It's\n+            \/\/ a very generous threshold, but it should be harmless to err on the\n+            \/\/ side of a generously high threshold in this case. The worst-case\n+            \/\/ scenario is: we return an extra t-value that isn't really an extrema.\n+\n+            \/\/ df\/dt = 2 * c[2] * t + c[1]\n+\n+            \/\/ so our only extrema is at:\n+            \/\/ t = -c[1] \/ (2*c[2])\n+\n+            double t = -coefficients[1] \/ (2.0 * coefficients[2]);\n+            dest[returnValue++] = t;\n+        }\n+        return returnValue;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Curve.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1651,2 +1651,1 @@\n-        final IOException x = new IOException(message);\n-        return EnvHelp.initCause(x,cause);\n+        return new IOException(message, cause);\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectionImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-            throw EnvHelp.initCause(new IOException(msg),e);\n+            throw new IOException(msg, e);\n@@ -546,3 +546,1 @@\n-            final IOException x =\n-                    new IOException(\"Failed to close: \" + closeException);\n-            throw EnvHelp.initCause(x,closeException);\n+            throw new IOException(\"Failed to close: \" + closeException, closeException);\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnector.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,2 +423,1 @@\n-                    throw EnvHelp.initCause(\n-                        new IllegalArgumentException(e.getMessage()), e);\n+                    throw new IllegalArgumentException(e.getMessage(), e);\n@@ -437,3 +436,1 @@\n-            IllegalArgumentException x = new\n-                IllegalArgumentException(\"ClassLoader not found: \"+infc);\n-            throw EnvHelp.initCause(x,infc);\n+            throw new IllegalArgumentException(\"ClassLoader not found: \" + infc, infc);\n@@ -834,2 +831,1 @@\n-        final IOException x = new IOException(message);\n-        return EnvHelp.initCause(x,cause);\n+        return new IOException(message, cause);\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectorServer.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.io.ObjectInputStream;\n@@ -83,1 +82,0 @@\n-import javax.management.OperationsException;\n@@ -211,2 +209,1 @@\n-            throw EnvHelp.initCause(\n-                new IllegalArgumentException(\"Unexpected exception: \" + e), e);\n+            throw new IllegalArgumentException(\"Unexpected exception: \" + e, e);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/interceptor\/DefaultMBeanServerInterceptor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -613,2 +613,0 @@\n-            RuntimeException re = new IllegalArgumentException(msg + e);\n-            EnvHelp.initCause(re, e);\n@@ -617,1 +615,1 @@\n-            throw re;\n+            throw new IllegalArgumentException(msg + e, e);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ArrayNotificationBuffer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import java.lang.reflect.UndeclaredThrowableException;\n@@ -343,3 +342,1 @@\n-                IOException ioe = new IOException(ire.toString());\n-                EnvHelp.initCause(ioe, ire);\n-                throw ioe;\n+                throw new IOException(ire.toString(), ire);\n@@ -384,3 +381,1 @@\n-                      IOException ioe = new IOException(ire.toString());\n-                      EnvHelp.initCause(ioe, ire);\n-                      throw ioe;\n+                      throw new IOException(ire.toString(), ire);\n@@ -824,4 +819,1 @@\n-                    IOException ioe = new IOException(ire.toString());\n-                    EnvHelp.initCause(ioe, ire);\n-\n-                    throw ioe;\n+                    throw new IOException(ire.toString(), ire);\n@@ -904,4 +896,1 @@\n-                IOException ioe = new IOException(ire.toString());\n-                EnvHelp.initCause(ioe, ire);\n-\n-                throw ioe;\n+                throw new IOException(ire.toString(), ire);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ClientNotifForwarder.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -124,3 +124,1 @@\n-                IOException ioe = new IOException(mfoe.getMessage());\n-                ioe.initCause(mfoe);\n-                throw ioe;\n+                throw new IOException(mfoe.getMessage(), mfoe);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ServerNotifForwarder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import com.sun.jmx.remote.util.EnvHelp;\n@@ -231,3 +230,1 @@\n-            final SecurityException e = new SecurityException(msg);\n-            EnvHelp.initCause(e, exception);\n-            se = e;\n+            se = new SecurityException(msg, exception);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/JMXPluggableAuthenticator.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,1 @@\n+            int cmp = sval1.compareTo(sval2);\n@@ -172,1 +173,1 @@\n-                return sval1.compareTo(sval2) > 0;\n+                return cmp > 0;\n@@ -174,1 +175,1 @@\n-                return sval1.compareTo(sval2) < 0;\n+                return cmp < 0;\n@@ -176,1 +177,1 @@\n-                return sval1.compareTo(sval2) >= 0;\n+                return cmp >= 0;\n@@ -178,1 +179,1 @@\n-                return sval1.compareTo(sval2) <= 0;\n+                return cmp <= 0;\n@@ -180,1 +181,1 @@\n-                return sval1.compareTo(sval2) == 0;\n+                return cmp == 0;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/BinaryRelQueryExp.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-\/\/ Java import\n-import com.sun.jmx.defaults.JmxProperties;\n-\n@@ -37,1 +34,0 @@\n-import java.io.FileOutputStream;\n@@ -74,1 +70,0 @@\n-import com.sun.jmx.defaults.ServiceName;\n@@ -1273,18 +1268,10 @@\n-        if (type.compareTo(\"java.lang.Boolean\") == 0)\n-             return Boolean.valueOf(param);\n-        if (type.compareTo(\"java.lang.Byte\") == 0)\n-             return Byte.valueOf(param);\n-        if (type.compareTo(\"java.lang.Short\") == 0)\n-             return Short.valueOf(param);\n-        if (type.compareTo(\"java.lang.Long\") == 0)\n-             return Long.valueOf(param);\n-        if (type.compareTo(\"java.lang.Integer\") == 0)\n-             return Integer.valueOf(param);\n-        if (type.compareTo(\"java.lang.Float\") == 0)\n-             return Float.valueOf(param);\n-        if (type.compareTo(\"java.lang.Double\") == 0)\n-             return Double.valueOf(param);\n-        if (type.compareTo(\"java.lang.String\") == 0)\n-             return param;\n-\n-        return param;\n+         return switch (type) {\n+             case \"java.lang.Boolean\" -> Boolean.valueOf(param);\n+             case \"java.lang.Byte\" -> Byte.valueOf(param);\n+             case \"java.lang.Short\" -> Short.valueOf(param);\n+             case \"java.lang.Long\" -> Long.valueOf(param);\n+             case \"java.lang.Integer\" -> Integer.valueOf(param);\n+             case \"java.lang.Float\" -> Float.valueOf(param);\n+             case \"java.lang.Double\" -> Double.valueOf(param);\n+             default -> param;\n+         };\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLet.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-\/\/ java import\n-\/\/\n@@ -47,1 +45,0 @@\n-import com.sun.jmx.remote.util.EnvHelp;\n@@ -629,1 +626,1 @@\n-            throw EnvHelp.initCause(new IllegalArgumentException(msg), e);\n+            throw new IllegalArgumentException(msg, e);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -622,2 +622,1 @@\n-                                exception = EnvHelp.initCause(\n-                                    new IOException(e.getMessage()), e);\n+                                exception = new IOException(e.getMessage(), e);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnectorFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,4 +58,2 @@\n-        Iterator i = threadTable.entrySet().iterator();\n-        while (i.hasNext()) {\n-            Entry e = (Entry)i.next();\n-            if (dfn(e) >= 0) {\n+        for (Entry<JavaThread, Integer> e : threadTable.entrySet()) {\n+            if (e.getValue() >= 0) {\n@@ -67,1 +65,1 @@\n-            JavaThread thread = (JavaThread)e.getKey();\n+            JavaThread thread = e.getKey();\n@@ -121,1 +119,1 @@\n-                waitingToLockMonitor = (ObjectMonitor)currentThread.getCurrentPendingMonitor();\n+                waitingToLockMonitor = currentThread.getCurrentPendingMonitor();\n@@ -165,4 +163,0 @@\n-    private static int dfn(Entry e) {\n-        return ((Integer)e.getValue()).intValue();\n-    }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/DeadlockDetector.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.*;\n@@ -196,3 +195,2 @@\n-      Iterator i = updates.iterator();\n-      while (i.hasNext()) {\n-        textArea.append((String)i.next());\n+      for (String update : updates) {\n+        textArea.append(update);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/FindInHeapPanel.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        if ((uriString == null) || (uriString.compareTo(\"localhost\") == 0)) {\n+        if (uriString == null || uriString.equals(\"localhost\")) {\n@@ -250,1 +250,1 @@\n-        if ((scheme != null) && (scheme.compareTo(\"file\") == 0)) {\n+        if (\"file\".equals(scheme)) {\n@@ -346,1 +346,1 @@\n-        if ((scheme != null) && (scheme.compareTo(\"file\") == 0)) {\n+        if (\"file\".equals(scheme)) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/HostIdentifier.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,1 +206,1 @@\n-            if (hostname.compareTo(\"localhost\") == 0) {\n+            if (hostname.equals(\"localhost\")) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/MonitoredHost.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-        } else if (commandLine.compareTo(\"Unknown\") == 0) {\n+        } else if (commandLine.equals(\"Unknown\")) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/MonitoredVmUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-        if ((s != null) && (s.compareTo(\"file\") == 0)) {\n+        if (\"file\".equals(s)) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/VmIdentifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.util.regex.*;\n@@ -130,1 +129,1 @@\n-                    || (currentToken.sval.compareTo(ALIAS) != 0)) {\n+                    || !currentToken.sval.equals(ALIAS)) {\n@@ -146,1 +145,1 @@\n-                     && (currentToken.sval.compareTo(ALIAS) != 0));\n+                     && !currentToken.sval.equals(ALIAS));\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/AliasFileParser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.net.URI;\n@@ -63,1 +62,1 @@\n-            if (mode.compareTo(\"r\") == 0) {\n+            if (mode.equals(\"r\")) {\n@@ -65,1 +64,1 @@\n-            } else if (mode.compareTo(\"rw\") == 0) {\n+            } else if (mode.equals(\"rw\")) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/file\/PerfDataBuffer.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.regex.*;\n@@ -363,1 +362,1 @@\n-        if (collector.stringValue().compareTo(\"PSScavenge\") == 0) {\n+        if (collector.stringValue().equals(\"PSScavenge\")) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v1_0\/PerfDataBuffer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.attach.VirtualMachineDescriptor;\n@@ -174,2 +173,1 @@\n-        for (int i = 0; i < subopts.length; i++) {\n-            String subopt = subopts[i];\n+        for (String subopt : subopts) {\n@@ -187,2 +185,2 @@\n-               parallel = subopt.substring(\"parallel=\".length());\n-               if (parallel == null) {\n+                parallel = subopt.substring(\"parallel=\".length());\n+                if (parallel == null) {\n@@ -191,1 +189,1 @@\n-               }\n+                }\n@@ -212,2 +210,1 @@\n-        for (int i = 0; i < subopts.length; i++) {\n-            String subopt = subopts[i];\n+        for (String subopt : subopts) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jmap\/JMap.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,3 +67,3 @@\n-            if ((args[0].compareTo(\"-?\") == 0)\n-                || (args[0].compareTo(\"-h\")== 0)\n-                || (args[0].compareTo(\"--help\")== 0)\n+            if ((args[0].equals(\"-?\"))\n+                || (args[0].equals(\"-h\"))\n+                || (args[0].equals(\"--help\"))\n@@ -71,1 +71,1 @@\n-                || (args[0].compareTo(\"-help\")== 0)) {\n+                || (args[0].equals(\"-help\"))) {\n@@ -81,1 +81,1 @@\n-            if (arg.compareTo(\"-q\") == 0) {\n+            if (arg.equals(\"-q\")) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jps\/Arguments.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,2 +118,2 @@\n-        for (int i = 0; i < unitStrings.length; i++) {\n-            int index = s.indexOf(unitStrings[i]);\n+        for (String unit : unitStrings) {\n+            int index = s.indexOf(unit);\n@@ -130,1 +130,1 @@\n-            if (unitString == null || unitString.compareTo(\"ms\") == 0) {\n+            if (unitString == null || unitString.equals(\"ms\")) {\n@@ -132,1 +132,1 @@\n-            } else if (unitString.compareTo(\"s\") == 0) {\n+            } else if (unitString.equals(\"s\")) {\n@@ -152,3 +152,3 @@\n-        if ((args[0].compareTo(\"-?\") == 0)\n-                || (args[0].compareTo(\"-h\") == 0)\n-                || (args[0].compareTo(\"--help\") == 0)\n+        if ((args[0].equals(\"-?\"))\n+                || (args[0].equals(\"-h\"))\n+                || (args[0].equals(\"--help\"))\n@@ -156,1 +156,1 @@\n-                || (args[0].compareTo(\"-help\") == 0)) {\n+                || (args[0].equals(\"-help\"))) {\n@@ -159,1 +159,1 @@\n-        } else if (args[0].compareTo(\"-options\") == 0) {\n+        } else if (args[0].equals(\"-options\")) {\n@@ -162,1 +162,1 @@\n-        } else if (args[0].compareTo(\"-list\") == 0) {\n+        } else if (args[0].equals(\"-list\")) {\n@@ -174,1 +174,1 @@\n-            if (arg.compareTo(\"-a\") == 0) {\n+            if (arg.equals(\"-a\")) {\n@@ -176,1 +176,1 @@\n-            } else if (arg.compareTo(\"-d\") == 0) {\n+            } else if (arg.equals(\"-d\")) {\n@@ -178,1 +178,1 @@\n-            } else if (arg.compareTo(\"-t\") == 0) {\n+            } else if (arg.equals(\"-t\")) {\n@@ -180,1 +180,1 @@\n-            } else if (arg.compareTo(\"-v\") == 0) {\n+            } else if (arg.equals(\"-v\")) {\n@@ -182,2 +182,2 @@\n-            } else if ((arg.compareTo(\"-constants\") == 0)\n-                       || (arg.compareTo(\"-c\") == 0)) {\n+            } else if ((arg.equals(\"-constants\"))\n+                       || (arg.equals(\"-c\"))) {\n@@ -185,2 +185,2 @@\n-            } else if ((arg.compareTo(\"-strings\") == 0)\n-                       || (arg.compareTo(\"-s\") == 0)) {\n+            } else if ((arg.equals(\"-strings\"))\n+                       || (arg.equals(\"-s\"))) {\n@@ -190,1 +190,1 @@\n-                if (arg.compareTo(\"-h\") != 0) {\n+                if (!arg.equals(\"-h\")) {\n@@ -248,1 +248,1 @@\n-                    if ((argc == 0) && (args[argc].compareTo(\"-snap\") == 0)) {\n+                    if ((argc == 0) && (args[argc].equals(\"-snap\"))) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/Arguments.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.*;\n-\n@@ -159,3 +157,2 @@\n-        for (Iterator<OptionFormat> i = children.iterator();  i.hasNext(); \/* empty *\/) {\n-            OptionFormat of = i.next();\n-            of.printFormat(indentLevel+1);\n+        for (OptionFormat of : children) {\n+            of.printFormat(indentLevel + 1);\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/ColumnFormat.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,4 +80,4 @@\n-      for (Iterator<OptionFormat> i = children.iterator(); i.hasNext(); \/* empty *\/) {\n-          OptionFormat o = i.next();\n-          c.visit(o, i.hasNext());\n-      }\n+        for (Iterator<OptionFormat> i = children.iterator(); i.hasNext(); \/* empty *\/) {\n+            OptionFormat o = i.next();\n+            c.visit(o, i.hasNext());\n+        }\n@@ -85,4 +85,3 @@\n-      for (Iterator <OptionFormat>i = children.iterator(); i.hasNext(); \/* empty *\/) {\n-          OptionFormat o = i.next();\n-          o.apply(c);\n-      }\n+        for (OptionFormat o : children) {\n+            o.apply(c);\n+        }\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/OptionFormat.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-            if (of.getName().compareTo(\"timestamp\") == 0) {\n+            if (of.getName().equals(\"timestamp\")) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/OptionLister.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-    private static Set<String> reservedWords;\n+    private static final Set<String> reservedWords = Set.of(otherKeyWords);\n@@ -106,3 +106,2 @@\n-        reservedWords = new HashSet<String>();\n-        for (int i = 0; i < otherKeyWords.length; i++) {\n-            reservedWords.add(otherKeyWords[i]);\n+        for (char delimiter : delimiters) {\n+            st.ordinaryChar(delimiter);\n@@ -111,6 +110,2 @@\n-        for (int i = 0; i < delimiters.length; i++ ) {\n-            st.ordinaryChar(delimiters[i]);\n-        }\n-\n-        for (int i = 0; i < infixOps.length; i++ ) {\n-            st.ordinaryChar(infixOps[i]);\n+        for (char infixOp : infixOps) {\n+            st.ordinaryChar(infixOp);\n@@ -234,2 +229,2 @@\n-        for (int i = 0; i < infixOps.length; i++) {\n-            if (op == infixOps[i]) {\n+        for (char infixOp : infixOps) {\n+            if (op == infixOp) {\n@@ -476,1 +471,1 @@\n-            if (lookahead.sval.compareTo(DATA) == 0) {\n+            if (lookahead.sval.equals(DATA)) {\n@@ -478,1 +473,1 @@\n-            } else if (lookahead.sval.compareTo(HEADER) == 0) {\n+            } else if (lookahead.sval.equals(HEADER)) {\n@@ -480,1 +475,1 @@\n-            } else if (lookahead.sval.compareTo(WIDTH) == 0) {\n+            } else if (lookahead.sval.equals(WIDTH)) {\n@@ -482,1 +477,1 @@\n-            } else if (lookahead.sval.compareTo(FORMAT) == 0) {\n+            } else if (lookahead.sval.equals(FORMAT)) {\n@@ -484,1 +479,1 @@\n-            } else if (lookahead.sval.compareTo(ALIGN) == 0) {\n+            } else if (lookahead.sval.equals(ALIGN)) {\n@@ -486,1 +481,1 @@\n-            } else if (lookahead.sval.compareTo(SCALE) == 0) {\n+            } else if (lookahead.sval.equals(SCALE)) {\n@@ -488,1 +483,1 @@\n-            } else if (lookahead.sval.compareTo(REQUIRED) == 0) {\n+            } else if (lookahead.sval.equals(REQUIRED)) {\n@@ -547,1 +542,1 @@\n-                    || (lookahead.sval.compareTo(START) != 0)) {\n+                    || (!lookahead.sval.equals(START))) {\n@@ -577,1 +572,1 @@\n-                    || (lookahead.sval.compareTo(START) != 0)) {\n+                    || (!lookahead.sval.equals(START))) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/Parser.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,1 @@\n-            for (Iterator<Monitor> i = logged.iterator(); i.hasNext(); \/* empty *\/ ) {\n-                Monitor m = i.next();\n+            for (Monitor m : logged) {\n@@ -63,2 +62,1 @@\n-        for (Iterator<Monitor> i = logged.iterator(); i.hasNext(); \/* empty *\/ ) {\n-            Monitor m = i.next();\n+        for (Monitor m : logged) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/RawOutputFormatter.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4172661\n+ * @bug 4172661 8176501\n@@ -135,0 +135,10 @@\n+            makeJDK8176501(),\n+\n+            \/\/ this shape has a special property: some coefficients to the t^3 term\n+            \/\/ are *nearly* zero. And analytically they should be zero, but machine\n+            \/\/ error prevented it. In these cases cubic polynomials should degenerate\n+            \/\/ into quadratic polynomials, but because the coefficient is not exactly\n+            \/\/ zero that may not always be handled correctly:\n+            AffineTransform.getRotateInstance(Math.PI \/ 4).createTransformedShape(\n+                    new Ellipse2D.Float(0, 0, 100, 100))\n+\n@@ -196,0 +206,14 @@\n+    \/**\n+     * JDK-8176501 focused on a shape whose bounds included a lot of dead space.\n+     * This recreates that shape, and the unit test testGetBounds2D checks the\n+     * accuracy of {@link Shape#getBounds2D()}\n+     *\/\n+    public static Path2D makeJDK8176501() {\n+        Path2D.Double path = new Path2D.Double();\n+        path.moveTo(40, 140);\n+        path.curveTo(40, 60, 160, 60, 160, 140);\n+        path.curveTo(160, 220, 40, 220, 40, 140);\n+        path.closePath();\n+        return path;\n+    }\n+\n@@ -541,22 +565,0 @@\n-        private Rectangle2D cachedBounds;\n-        public Rectangle2D getCachedBounds2D() {\n-            if (cachedBounds == null) {\n-                double xmin, ymin, xmax, ymax;\n-                int ci = 0;\n-                xmin = xmax = theCoords[ci++];\n-                ymin = ymax = theCoords[ci++];\n-                while (ci < numCoords) {\n-                    double c = theCoords[ci++];\n-                    if (xmin > c) xmin = c;\n-                    if (xmax < c) xmax = c;\n-                    c = theCoords[ci++];\n-                    if (ymin > c) ymin = c;\n-                    if (ymax < c) ymax = c;\n-                }\n-                cachedBounds = new Rectangle2D.Double(xmin, ymin,\n-                                                      xmax - xmin,\n-                                                      ymax - ymin);\n-            }\n-            return cachedBounds;\n-        }\n-\n@@ -564,1 +566,1 @@\n-            return getCachedBounds2D().getBounds();\n+            return getBounds2D().getBounds();\n@@ -567,1 +569,1 @@\n-            return getCachedBounds2D().getBounds2D();\n+            return getTestShape().getBounds2D();\n@@ -1300,0 +1302,1 @@\n+            testGetBounds2D(stest);\n@@ -1315,0 +1318,87 @@\n+    \/**\n+     * Make sure the {@link Shape#getBounds2D()} returns a Rectangle2D that tightly fits the\n+     * shape data. It shouldn't contain lots of dead space (see JDK 8176501), and it shouldn't\n+     * leave out any shape path. This test relies on the accuracy of\n+     * {@link Shape#intersects(double, double, double, double)}\n+     *\/\n+    public static void testGetBounds2D(Shape shape) {\n+        \/\/ first: make sure the shape is actually close to the perimeter of shape.getBounds2D().\n+        \/\/ this is the crux of JDK 8176501:\n+\n+        Rectangle2D r = shape.getBounds2D();\n+\n+        if (r.getWidth() == 0 || r.getHeight() == 0) {\n+            \/\/ this can happen for completely empty paths, which are part of our\n+            \/\/ edge test cases in this class.\n+            return;\n+        }\n+\n+        if (verbose) System.out.println(\"testGetBounds2D \"+shape+\", \"+r);\n+\n+        double xminInterior = r.getMinX() + .000001;\n+        double yminInterior = r.getMinY() + .000001;\n+        double xmaxInterior = r.getMaxX() - .000001;\n+        double ymaxInterior = r.getMaxY() - .000001;\n+\n+        Rectangle2D topStrip = new Rectangle2D.Double(r.getMinX(), r.getMinY(), r.getWidth(), yminInterior - r.getMinY());\n+        Rectangle2D leftStrip = new Rectangle2D.Double(r.getMinX(), r.getMinY(), xminInterior - r.getMinX(), r.getHeight());\n+        Rectangle2D bottomStrip = new Rectangle2D.Double(r.getMinX(), ymaxInterior, r.getWidth(), r.getMaxY() - ymaxInterior);\n+        Rectangle2D rightStrip = new Rectangle2D.Double(xmaxInterior, r.getMinY(), r.getMaxX() - xmaxInterior, r.getHeight());\n+        if (!shape.intersects(topStrip)) {\n+            if (verbose)\n+                System.out.println(\"topStrip = \"+topStrip);\n+            throw new RuntimeException(\"the shape must intersect the top strip of its bounds\");\n+        }\n+        if (!shape.intersects(leftStrip)) {\n+            if (verbose)\n+                System.out.println(\"leftStrip = \" + leftStrip);\n+            throw new RuntimeException(\"the shape must intersect the left strip of its bounds\");\n+        }\n+        if (!shape.intersects(bottomStrip)) {\n+            if (verbose)\n+                System.out.println(\"bottomStrip = \" + bottomStrip);\n+            throw new RuntimeException(\"the shape must intersect the bottom strip of its bounds\");\n+        }\n+        if (!shape.intersects(rightStrip)) {\n+            if (verbose)\n+                System.out.println(\"rightStrip = \" + rightStrip);\n+            throw new RuntimeException(\"the shape must intersect the right strip of bounds\");\n+        }\n+\n+        \/\/ Similarly: make sure our shape doesn't exist OUTSIDE of r, either. To my knowledge this has never\n+        \/\/ been a problem, but if it did happen this would be an even more serious breach of contract than\n+        \/\/ the former case.\n+\n+        double xminExterior = r.getMinX() - .000001;\n+        double yminExterior = r.getMinY() - .000001;\n+        double xmaxExterior = r.getMaxX() + .000001;\n+        double ymaxExterior = r.getMaxY() + .000001;\n+\n+        \/\/ k is simply meant to mean \"a large number, functionally similar to infinity for this test\"\n+        double k = 10000.0;\n+        leftStrip = new Rectangle2D.Double(xminExterior - k, -k, k, 3 * k);\n+        rightStrip = new Rectangle2D.Double(xmaxExterior, -k, k, 3 * k);\n+        topStrip = new Rectangle2D.Double(-k, yminExterior - k, 3 * k, k);\n+        bottomStrip = new Rectangle2D.Double(-k, ymaxExterior, 3 * k, k);\n+        if (shape.intersects(leftStrip)) {\n+            if (verbose)\n+                System.out.println(\"leftStrip = \" + leftStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything to the left of its bounds\");\n+        }\n+        if (shape.intersects(rightStrip)) {\n+            if (verbose)\n+                System.out.println(\"rightStrip = \" + rightStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything to the right of its bounds\");\n+        }\n+        if (shape.intersects(topStrip)) {\n+            if (verbose)\n+                System.out.println(\"topStrip = \" + topStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything above its bounds\");\n+        }\n+        if (shape.intersects(bottomStrip)) {\n+            if (verbose)\n+                System.out.println(\"bottomStrip = \" + bottomStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything below its bounds\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/geom\/Path2D\/UnitTest.java","additions":115,"deletions":25,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main BigIntegerParallelMultiplyTest\n+ * @summary tests parallelMultiply() method in BigInteger\n+ * @author Heinz Kabutz heinz@javaspecialists.eu\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.util.function.BinaryOperator;\n+\n+\/**\n+ * This is a simple test class created to ensure that the results\n+ * of multiply() are the same as multiplyParallel(). We calculate\n+ * the Fibonacci numbers using Dijkstra's sum of squares to get\n+ * very large numbers (hundreds of thousands of bits).\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+public class BigIntegerParallelMultiplyTest {\n+    public static BigInteger fibonacci(int n, BinaryOperator<BigInteger> multiplyOperator) {\n+        if (n == 0) return BigInteger.ZERO;\n+        if (n == 1) return BigInteger.ONE;\n+\n+        int half = (n + 1) \/ 2;\n+        BigInteger f0 = fibonacci(half - 1, multiplyOperator);\n+        BigInteger f1 = fibonacci(half, multiplyOperator);\n+        if (n % 2 == 1) {\n+            BigInteger b0 = multiplyOperator.apply(f0, f0);\n+            BigInteger b1 = multiplyOperator.apply(f1, f1);\n+            return b0.add(b1);\n+        } else {\n+            BigInteger b0 = f0.shiftLeft(1).add(f1);\n+            return multiplyOperator.apply(b0, f1);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int n = 0; n <= 10; n++) {\n+            BigInteger fib = fibonacci(n, BigInteger::multiply);\n+            System.out.printf(\"fibonacci(%d) = %d%n\", n, fib);\n+        }\n+\n+        compare(1000, 324);\n+        compare(10_000, 3473);\n+        compare(100_000, 34883);\n+        compare(1_000_000, 347084);\n+    }\n+\n+    private static void compare(int n, int expectedBitCount) {\n+        BigInteger multiplyResult = fibonacci(n, BigInteger::multiply);\n+        BigInteger parallelMultiplyResult = fibonacci(n, BigInteger::parallelMultiply);\n+        checkBitCount(n, expectedBitCount, multiplyResult);\n+        checkBitCount(n, expectedBitCount, parallelMultiplyResult);\n+        if (!multiplyResult.equals(parallelMultiplyResult))\n+            throw new AssertionError(\"multiply() and parallelMultiply() give different results\");\n+    }\n+\n+    private static void checkBitCount(int n, int expectedBitCount, BigInteger number) {\n+        if (number.bitCount() != expectedBitCount)\n+            throw new AssertionError(\n+                    \"bitCount of fibonacci(\" + n + \") was expected to be \" + expectedBitCount\n+                            + \" but was \" + number.bitCount());\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerParallelMultiplyTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BinaryOperator;\n+\n+\/**\n+ * Benchmark for checking performance difference between\n+ * sequential and parallel multiply methods in BigInteger,\n+ * using a large Fibonacci calculation of up to n = 100 million.\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 2, jvmArgsAppend = {\"-XX:+UseParallelGC\", \"-Xmx16g\", \"-Xms16g\", \"-XX:+AlwaysPreTouch\", \"-XX:NewRatio=1\", \"-XX:SurvivorRatio=1\"})\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 2) \/\/ only 2 iterations because each one takes very long\n+@State(Scope.Thread)\n+public class BigIntegerParallelMultiply {\n+    private static BigInteger fibonacci(int n, BinaryOperator<BigInteger> multiplyOperator) {\n+        if (n == 0) return BigInteger.ZERO;\n+        if (n == 1) return BigInteger.ONE;\n+\n+        int half = (n + 1) \/ 2;\n+        BigInteger f0 = fibonacci(half - 1, multiplyOperator);\n+        BigInteger f1 = fibonacci(half, multiplyOperator);\n+        if (n % 2 == 1) {\n+            BigInteger b0 = multiplyOperator.apply(f0, f0);\n+            BigInteger b1 = multiplyOperator.apply(f1, f1);\n+            return b0.add(b1);\n+        } else {\n+            BigInteger b0 = f0.shiftLeft(1).add(f1);\n+            return multiplyOperator.apply(b0, f1);\n+        }\n+    }\n+\n+    @Param({\"1000000\", \"10000000\", \"100000000\"})\n+    private int n;\n+\n+    @Benchmark\n+    public void multiply() {\n+        fibonacci(n, BigInteger::multiply);\n+    }\n+\n+    @Benchmark\n+    public void parallelMultiply() {\n+        fibonacci(n, BigInteger::parallelMultiply);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerParallelMultiply.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}