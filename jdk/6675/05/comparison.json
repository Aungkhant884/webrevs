{"files":[{"patch":"@@ -792,1 +792,1 @@\n-  \/\/ Left input is an add of a constant?\n+  \/\/ Left input is an add?\n@@ -797,5 +797,13 @@\n-    const TypeInt *t12 = phase->type(add1->in(2))->isa_int();\n-    if( t12 && t12->is_con() ){ \/\/ Left input is an add of a con?\n-      \/\/ Transform is legal, but check for profit.  Avoid breaking 'i2s'\n-      \/\/ and 'i2b' patterns which typically fold into 'StoreC\/StoreB'.\n-      if( con < 16 ) {\n+\n+    \/\/ Transform is legal, but check for profit.  Avoid breaking 'i2s'\n+    \/\/ and 'i2b' patterns which typically fold into 'StoreC\/StoreB'.\n+    if( con < 16 ) {\n+      \/\/ Left input is an add of the same number?\n+      if (add1->in(1) == add1->in(2)) {\n+        \/\/ Convert \"(x + x) << c0\" into \"x << (c0 + 1)\"\n+        return new LShiftINode(add1->in(1), phase->intcon(con + 1));\n+      }\n+\n+      \/\/ Left input is an add of a constant?\n+      const TypeInt *t12 = phase->type(add1->in(2))->isa_int();\n+      if( t12 && t12->is_con() ){ \/\/ Left input is an add of a con?\n@@ -905,1 +913,1 @@\n-  \/\/ Left input is an add of a constant?\n+  \/\/ Left input is an add?\n@@ -911,0 +919,8 @@\n+\n+    \/\/ Left input is an add of the same number?\n+    if (add1->in(1) == add1->in(2)) {\n+      \/\/ Convert \"(x + x) << c0\" into \"x << (c0 + 1)\"\n+      return new LShiftLNode(add1->in(1), phase->intcon(con + 1));\n+    }\n+\n+    \/\/ Left input is an add of a constant?\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8278114\n+ * @summary Test that transformation from (x + x) >> c to x >> (c + 1) works as intended.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIRAddIdeal_XPlusX_LShiftC\n+ *\/\n+public class TestIRAddIdeal_XPlusX_LShiftC {\n+\n+    private static final int[] INT_IN = {\n+        -10, -2, -1, 0, 1, 2, 10,\n+        0x8000_0000, 0x7FFF_FFFF, 0x5678_1234,\n+    };\n+\n+    private static final int[][] INT_OUT = {\n+        \/\/ Do testInt0(x) for each x in INT_IN\n+        {\n+            -160, -32, -16, 0, 16, 32, 160,\n+            0x0000_0000, 0xFFFF_FFF0, 0x6781_2340,\n+        },\n+\n+        \/\/ Do testInt1(x) for each x in INT_IN\n+        {\n+            -10485760, -2097152, -1048576, 0, 1048576, 2097152, 10485760,\n+            0x0000_0000, 0xFFF0_0000, 0x2340_0000,\n+        },\n+    };\n+\n+    private static final long[] LONG_IN = {\n+        -10L, -2L, -1L, 0L, 1L, 2L, 10L,\n+        0x8000_0000_0000_0000L, 0x7FFF_FFFF_FFFF_FFFFL, 0x5678_1234_4321_8765L,\n+    };\n+\n+    private static final long[][] LONG_OUT = {\n+        \/\/ Do testLong0(x) for each x in LONG_IN\n+        {\n+            -160L, -32L, -16L, 0L, 16L, 32L, 160L,\n+            0x0000_0000_0000_0000L, 0xFFFF_FFFF_FFFF_FFF0L, 0x6781_2344_3218_7650L,\n+        },\n+\n+        \/\/ Do testLong1(x) for each x in LONG_IN\n+        {\n+            -687194767360L, -137438953472L, -68719476736L, 0L, 68719476736L, 137438953472L, 687194767360L,\n+            0x0000_0000_0000_0000L, 0xFFFF_FFF0_0000_0000L, 0x3218_7650_0000_0000L,\n+        },\n+    };\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.MUL_I})\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    public int testInt0(int x) {\n+        return (x + x) << 3; \/\/ transformed to x << 4\n+    }\n+\n+    @Run(test = \"testInt0\")\n+    public void checkTestInt0(RunInfo info) {\n+        \/\/ Test VM allows C2 to work\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            \/\/ C2 compilation happens\n+            Asserts.assertTrue(info.isTestC2Compiled());\n+        }\n+        \/\/ Results are correct\n+        for (int i = 0; i < INT_IN.length; i++) {\n+            Asserts.assertEquals(INT_OUT[0][i], testInt0(INT_IN[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL_I})\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\",\n+                  IRNode.ADD_I, \"1\"})\n+    public int testInt1(int x) {\n+        return (x + x) << 19; \/\/ no transformation because 19 is\n+                              \/\/ greater than 16 (see implementation\n+                              \/\/ in LShiftINode::Ideal)\n+    }\n+\n+    @Run(test = \"testInt1\")\n+    public void checkTestInt1(RunInfo info) {\n+        \/\/ Test VM allows C2 to work\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            \/\/ C2 compilation happens\n+            Asserts.assertTrue(info.isTestC2Compiled());\n+        }\n+        \/\/ Results are correct\n+        for (int i = 0; i < INT_IN.length; i++) {\n+            Asserts.assertEquals(INT_OUT[1][i], testInt1(INT_IN[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.MUL_L})\n+    @IR(counts = {IRNode.LSHIFT_L, \"1\"})\n+    public long testLong0(long x) {\n+        return (x + x) << 3; \/\/ transformed to x << 4\n+    }\n+\n+    @Run(test = \"testLong0\")\n+    public void checkTestLong0(RunInfo info) {\n+        \/\/ Test VM allows C2 to work\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            \/\/ C2 compilation happens\n+            Asserts.assertTrue(info.isTestC2Compiled());\n+        }\n+        \/\/ Results are correct\n+        for (int i = 0; i < LONG_IN.length; i++) {\n+            Asserts.assertEquals(LONG_OUT[0][i], testLong0(LONG_IN[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.MUL_L})\n+    @IR(counts = {IRNode.LSHIFT_L, \"1\"})\n+    public long testLong1(long x) {\n+        return (x + x) << 35; \/\/ transformed to x << 36\n+    }\n+\n+    @Run(test = \"testLong1\")\n+    public void checkTestLong1(RunInfo info) {\n+        \/\/ Test VM allows C2 to work\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            \/\/ C2 compilation happens\n+            Asserts.assertTrue(info.isTestC2Compiled());\n+        }\n+        \/\/ Results are correct\n+        for (int i = 0; i < LONG_IN.length; i++) {\n+            Asserts.assertEquals(LONG_OUT[1][i], testLong1(LONG_IN[i]));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRAddIdeal_XPlusX_LShiftC.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -144,0 +144,2 @@\n+    public static final String MUL_I = START + \"MulI\" + MID + END;\n+    public static final String MUL_L = START + \"MulL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests transformation from \"(x + x) << c\" to \"x << (c + 1)\".\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 20, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 20, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3 , jvmArgsAppend = {\"-XX:-TieredCompilation\"})\n+public class AddIdeal_XPlusX_LShiftC {\n+\n+    private final int size = 100_000;\n+\n+    private int[] ints_a;\n+\n+    private long[] longs_a;\n+\n+    @Setup\n+    public void init() {\n+        ints_a = new int[size];\n+        longs_a = new long[size];\n+        for (int i = 0; i < size; i++) {\n+            ints_a[i] = i;\n+            longs_a[i] = i * i * i;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void baseline() {\n+        for (int i = 0; i < size; i++) {\n+            sink(ints_a[i]);\n+            sink(longs_a[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        for (int i = 0; i < size; i++) {\n+            sink(helper(ints_a[i]));\n+            sink(helper(longs_a[i]));\n+        }\n+    }\n+\n+    \/\/ Convert \"(x + x) << 10\" into \"x << 11\" for int.\n+    \/\/ (x << 11) >>> 11 is then further converted into zero-extends.\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int helper(int x) {\n+        return ((x + x) << 10) >>> 11;\n+    }\n+\n+    \/\/ Convert \"(x + x) << 40\" into \"x << 41\" for long.\n+    \/\/ (x << 41) >>> 41 is then further converted into zero-extends.\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static long helper(long x) {\n+        return ((x + x) << 40) >>> 41;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static void sink(int v) {}\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static void sink(long v) {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/AddIdeal_XPlusX_LShiftC.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}