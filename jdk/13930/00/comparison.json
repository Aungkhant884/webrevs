{"files":[{"patch":"@@ -83,4 +83,1 @@\n-  _num_reductions(0),                                       \/\/ amount of reduction work we have\n-  _ii_first(-1),                                            \/\/ first loop generation index - only if do_vector_loop()\n-  _ii_last(-1),                                             \/\/ last loop generation index - only if do_vector_loop()\n-  _ii_order(arena(), 8, 0, 0)\n+  _num_reductions(0)                                        \/\/ amount of reduction work we have\n@@ -97,2 +94,0 @@\n-static const bool _do_vector_loop_experimental = false; \/\/ Experimental vectorization which uses data from loop unrolling.\n-\n@@ -612,26 +607,0 @@\n-    if (_do_vector_loop_experimental) {\n-      if (mark_generations() != -1) {\n-        hoist_loads_in_graph(); \/\/ this only rebuild the graph; all basic structs need rebuild explicitly\n-\n-        if (!construct_bb()) {\n-          return false; \/\/ Exit if no interesting nodes or complex graph.\n-        }\n-        dependence_graph();\n-        compute_max_depth();\n-      }\n-\n-#ifndef PRODUCT\n-      if (TraceSuperWord) {\n-        tty->print_cr(\"\\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph\");\n-        _lpt->dump_head();\n-        for (int j = 0; j < _block.length(); j++) {\n-          Node* n = _block.at(j);\n-          int d = depth(n);\n-          for (int i = 0; i < d; i++) tty->print(\"%s\", \"  \");\n-          tty->print(\"%d :\", d);\n-          n->dump();\n-        }\n-      }\n-#endif\n-    }\n-\n@@ -650,11 +619,0 @@\n-    if (_do_vector_loop_experimental) {\n-      if (_packset.length() == 0) {\n-#ifndef PRODUCT\n-        if (TraceSuperWord) {\n-          tty->print_cr(\"\\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway\");\n-        }\n-#endif\n-        pack_parallel();\n-      }\n-    }\n-\n@@ -3744,2 +3702,0 @@\n-  \/\/ Build iterations order if needed\n-  bool build_ii_order = _do_vector_loop_experimental && _ii_order.is_empty();\n@@ -3750,10 +3706,0 @@\n-    if (build_ii_order && n->is_Load()) {\n-      if (ii_current == -1) {\n-        ii_current = _clone_map.gen(n->_idx);\n-        _ii_order.push(ii_current);\n-        load_idx = _clone_map.idx(n->_idx);\n-      } else if (_clone_map.idx(n->_idx) == load_idx && _clone_map.gen(n->_idx) != ii_current) {\n-        ii_current = _clone_map.gen(n->_idx);\n-        _ii_order.push(ii_current);\n-      }\n-    }\n@@ -3766,7 +3712,0 @@\n-  if (_vector_loop_debug && _ii_order.length() > 0) {\n-    tty->print(\"SuperWord::construct_bb: List of generations: \");\n-    for (int jj = 0; jj < _ii_order.length(); ++jj) {\n-      tty->print(\"  %d:%d\", jj, _ii_order.at(jj));\n-    }\n-    tty->print_cr(\" \");\n-  }\n@@ -4306,2 +4245,0 @@\n-  _iteration_first.clear();\n-  _iteration_last.clear();\n@@ -4316,13 +4253,0 @@\n-\/\/------------------------------restart---------------------------\n-void SuperWord::restart() {\n-  _dg.init();\n-  _packset.clear();\n-  _disjoint_ptrs.clear();\n-  _block.clear();\n-  _post_block.clear();\n-  _data_entry.clear();\n-  _mem_slice_head.clear();\n-  _mem_slice_tail.clear();\n-  _node_info.clear();\n-}\n-\n@@ -5222,394 +5146,0 @@\n-Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {\n-  assert(in_bb(ld), \"must be in block\");\n-  if (_clone_map.gen(ld->_idx) == _ii_first) {\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::find_phi_for_mem_dep _clone_map.gen(ld->_idx)=%d\",\n-        _clone_map.gen(ld->_idx));\n-    }\n-#endif\n-    return nullptr; \/\/we think that any ld in the first gen being vectorizable\n-  }\n-\n-  Node* mem = ld->in(MemNode::Memory);\n-  if (mem->outcnt() <= 1) {\n-    \/\/ we don't want to remove the only edge from mem node to load\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem->load cannot be removed\",\n-        mem->_idx, ld->_idx);\n-      ld->dump();\n-      mem->dump();\n-    }\n-#endif\n-    return nullptr;\n-  }\n-  if (!in_bb(mem) || same_generation(mem, ld)) {\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::find_phi_for_mem_dep _clone_map.gen(mem->_idx)=%d\",\n-        _clone_map.gen(mem->_idx));\n-    }\n-#endif\n-    return nullptr; \/\/ does not depend on loop volatile node or depends on the same generation\n-  }\n-\n-  \/\/otherwise first node should depend on mem-phi\n-  Node* first = first_node(ld);\n-  assert(first->is_Load(), \"must be Load\");\n-  Node* phi = first->as_Load()->in(MemNode::Memory);\n-  if (!phi->is_Phi() || phi->bottom_type() != Type::MEMORY) {\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it's `first` does not take input from mem phi\");\n-      ld->dump();\n-      first->dump();\n-    }\n-#endif\n-    return nullptr;\n-  }\n-\n-  Node* tail = 0;\n-  for (int m = 0; m < _mem_slice_head.length(); m++) {\n-    if (_mem_slice_head.at(m) == phi) {\n-      tail = _mem_slice_tail.at(m);\n-    }\n-  }\n-  if (tail == 0) { \/\/test that found phi is in the list  _mem_slice_head\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head\",\n-        ld->_idx, phi->_idx);\n-      ld->dump();\n-      phi->dump();\n-    }\n-#endif\n-    return nullptr;\n-  }\n-\n-  \/\/ now all conditions are met\n-  return phi;\n-}\n-\n-Node* SuperWord::first_node(Node* nd) {\n-  for (int ii = 0; ii < _iteration_first.length(); ii++) {\n-    Node* nnn = _iteration_first.at(ii);\n-    if (same_origin_idx(nnn, nd)) {\n-#ifndef PRODUCT\n-      if (_vector_loop_debug) {\n-        tty->print_cr(\"SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn->_idx) = %d)\",\n-          nnn->_idx, nd->_idx, _clone_map.idx(nnn->_idx));\n-      }\n-#endif\n-      return nnn;\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  if (_vector_loop_debug) {\n-    tty->print_cr(\"SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd->_idx)=%d)\",\n-      nd->_idx, _clone_map.idx(nd->_idx));\n-  }\n-#endif\n-  return 0;\n-}\n-\n-Node* SuperWord::last_node(Node* nd) {\n-  for (int ii = 0; ii < _iteration_last.length(); ii++) {\n-    Node* nnn = _iteration_last.at(ii);\n-    if (same_origin_idx(nnn, nd)) {\n-#ifndef PRODUCT\n-      if (_vector_loop_debug) {\n-        tty->print_cr(\"SuperWord::last_node _clone_map.idx(nnn->_idx)=%d, _clone_map.idx(nd->_idx)=%d\",\n-          _clone_map.idx(nnn->_idx), _clone_map.idx(nd->_idx));\n-      }\n-#endif\n-      return nnn;\n-    }\n-  }\n-  return 0;\n-}\n-\n-int SuperWord::mark_generations() {\n-  Node *ii_err = nullptr, *tail_err = nullptr;\n-  for (int i = 0; i < _mem_slice_head.length(); i++) {\n-    Node* phi  = _mem_slice_head.at(i);\n-    assert(phi->is_Phi(), \"must be phi\");\n-\n-    Node* tail = _mem_slice_tail.at(i);\n-    if (_ii_last == -1) {\n-      tail_err = tail;\n-      _ii_last = _clone_map.gen(tail->_idx);\n-    }\n-    else if (_ii_last != _clone_map.gen(tail->_idx)) {\n-#ifndef PRODUCT\n-      if (TraceSuperWord && Verbose) {\n-        tty->print_cr(\"SuperWord::mark_generations _ii_last error - found different generations in two tail nodes \");\n-        tail->dump();\n-        tail_err->dump();\n-      }\n-#endif\n-      return -1;\n-    }\n-\n-    \/\/ find first iteration in the loop\n-    for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n-      Node* ii = phi->fast_out(i);\n-      if (in_bb(ii) && ii->is_Store()) { \/\/ we speculate that normally Stores of one and one only generation have deps from mem phi\n-        if (_ii_first == -1) {\n-          ii_err = ii;\n-          _ii_first = _clone_map.gen(ii->_idx);\n-        } else if (_ii_first != _clone_map.gen(ii->_idx)) {\n-#ifndef PRODUCT\n-          if (TraceSuperWord && Verbose) {\n-            tty->print_cr(\"SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)\", _ii_first);\n-            ii->dump();\n-            if (ii_err!= 0) {\n-              ii_err->dump();\n-            }\n-          }\n-#endif\n-          return -1; \/\/ this phi has Stores from different generations of unroll and cannot be simd\/vectorized\n-        }\n-      }\n-    }\/\/for (DUIterator_Fast imax,\n-  }\/\/for (int i...\n-\n-  if (_ii_first == -1 || _ii_last == -1) {\n-    if (TraceSuperWord && Verbose) {\n-      tty->print_cr(\"SuperWord::mark_generations unknown error, something vent wrong\");\n-    }\n-    return -1; \/\/ something vent wrong\n-  }\n-  \/\/ collect nodes in the first and last generations\n-  assert(_iteration_first.length() == 0, \"_iteration_first must be empty\");\n-  assert(_iteration_last.length() == 0, \"_iteration_last must be empty\");\n-  for (int j = 0; j < _block.length(); j++) {\n-    Node* n = _block.at(j);\n-    node_idx_t gen = _clone_map.gen(n->_idx);\n-    if ((signed)gen == _ii_first) {\n-      _iteration_first.push(n);\n-    } else if ((signed)gen == _ii_last) {\n-      _iteration_last.push(n);\n-    }\n-  }\n-\n-  \/\/ building order of iterations\n-  if (_ii_order.length() == 0 && ii_err != 0) {\n-    assert(in_bb(ii_err) && ii_err->is_Store(), \"should be Store in bb\");\n-    Node* nd = ii_err;\n-    while(_clone_map.gen(nd->_idx) != _ii_last) {\n-      _ii_order.push(_clone_map.gen(nd->_idx));\n-      bool found = false;\n-      for (DUIterator_Fast imax, i = nd->fast_outs(imax); i < imax; i++) {\n-        Node* use = nd->fast_out(i);\n-        if (same_origin_idx(use, nd) && use->as_Store()->in(MemNode::Memory) == nd) {\n-          found = true;\n-          nd = use;\n-          break;\n-        }\n-      }\/\/for\n-\n-      if (found == false) {\n-        if (TraceSuperWord && Verbose) {\n-          tty->print_cr(\"SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d\", nd->_idx);\n-        }\n-        _ii_order.clear();\n-        return -1;\n-      }\n-    } \/\/while\n-    _ii_order.push(_clone_map.gen(nd->_idx));\n-  }\n-\n-#ifndef PRODUCT\n-  if (_vector_loop_debug) {\n-    tty->print_cr(\"SuperWord::mark_generations\");\n-    tty->print_cr(\"First generation (%d) nodes:\", _ii_first);\n-    for (int ii = 0; ii < _iteration_first.length(); ii++)  _iteration_first.at(ii)->dump();\n-    tty->print_cr(\"Last generation (%d) nodes:\", _ii_last);\n-    for (int ii = 0; ii < _iteration_last.length(); ii++)  _iteration_last.at(ii)->dump();\n-    tty->print_cr(\" \");\n-\n-    tty->print(\"SuperWord::List of generations: \");\n-    for (int jj = 0; jj < _ii_order.length(); ++jj) {\n-      tty->print(\"%d:%d \", jj, _ii_order.at(jj));\n-    }\n-    tty->print_cr(\" \");\n-  }\n-#endif\n-\n-  return _ii_first;\n-}\n-\n-bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {\n-  assert(gold->is_Add() && fix->is_Add() || gold->is_Mul() && fix->is_Mul(), \"should be only Add or Mul nodes\");\n-  assert(same_origin_idx(gold, fix), \"should be clones of the same node\");\n-  Node* gin1 = gold->in(1);\n-  Node* gin2 = gold->in(2);\n-  Node* fin1 = fix->in(1);\n-  Node* fin2 = fix->in(2);\n-  bool swapped = false;\n-\n-  if (in_bb(gin1) && in_bb(gin2) && in_bb(fin1) && in_bb(fin2)) {\n-    if (same_origin_idx(gin1, fin1) &&\n-        same_origin_idx(gin2, fin2)) {\n-      return true; \/\/ nothing to fix\n-    }\n-    if (same_origin_idx(gin1, fin2) &&\n-        same_origin_idx(gin2, fin1)) {\n-      fix->swap_edges(1, 2);\n-      swapped = true;\n-    }\n-  }\n-  \/\/ at least one input comes from outside of bb\n-  if (gin1->_idx == fin1->_idx)  {\n-    return true; \/\/ nothing to fix\n-  }\n-  if (!swapped && (gin1->_idx == fin2->_idx || gin2->_idx == fin1->_idx))  { \/\/swapping is expensive, check condition first\n-    fix->swap_edges(1, 2);\n-    swapped = true;\n-  }\n-\n-  if (swapped) {\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::fix_commutative_inputs: fixed node %d\", fix->_idx);\n-    }\n-#endif\n-    return true;\n-  }\n-\n-  if (TraceSuperWord && Verbose) {\n-    tty->print_cr(\"SuperWord::fix_commutative_inputs: cannot fix node %d\", fix->_idx);\n-  }\n-\n-  return false;\n-}\n-\n-bool SuperWord::pack_parallel() {\n-#ifndef PRODUCT\n-  if (_vector_loop_debug) {\n-    tty->print_cr(\"SuperWord::pack_parallel: START\");\n-  }\n-#endif\n-\n-  _packset.clear();\n-\n-  if (_ii_order.is_empty()) {\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::pack_parallel: EMPTY\");\n-    }\n-#endif\n-    return false;\n-  }\n-\n-  for (int ii = 0; ii < _iteration_first.length(); ii++) {\n-    Node* nd = _iteration_first.at(ii);\n-    if (in_bb(nd) && (nd->is_Load() || nd->is_Store() || nd->is_Add() || nd->is_Mul())) {\n-      Node_List* pk = new Node_List();\n-      pk->push(nd);\n-      for (int gen = 1; gen < _ii_order.length(); ++gen) {\n-        for (int kk = 0; kk < _block.length(); kk++) {\n-          Node* clone = _block.at(kk);\n-          if (same_origin_idx(clone, nd) &&\n-              _clone_map.gen(clone->_idx) == _ii_order.at(gen)) {\n-            if (nd->is_Add() || nd->is_Mul()) {\n-              fix_commutative_inputs(nd, clone);\n-            }\n-            pk->push(clone);\n-            if (pk->size() == 4) {\n-              _packset.append(pk);\n-#ifndef PRODUCT\n-              if (_vector_loop_debug) {\n-                tty->print_cr(\"SuperWord::pack_parallel: added pack \");\n-                pk->dump();\n-              }\n-#endif\n-              if (_clone_map.gen(clone->_idx) != _ii_last) {\n-                pk = new Node_List();\n-              }\n-            }\n-            break;\n-          }\n-        }\n-      }\/\/for\n-    }\/\/if\n-  }\/\/for\n-\n-#ifndef PRODUCT\n-  if (_vector_loop_debug) {\n-    tty->print_cr(\"SuperWord::pack_parallel: END\");\n-  }\n-#endif\n-\n-  return true;\n-}\n-\n-bool SuperWord::hoist_loads_in_graph() {\n-  GrowableArray<Node*> loads;\n-\n-#ifndef PRODUCT\n-  if (_vector_loop_debug) {\n-    tty->print_cr(\"SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d\", _mem_slice_head.length());\n-  }\n-#endif\n-\n-  for (int i = 0; i < _mem_slice_head.length(); i++) {\n-    Node* n = _mem_slice_head.at(i);\n-    if ( !in_bb(n) || !n->is_Phi() || n->bottom_type() != Type::MEMORY) {\n-      if (TraceSuperWord && Verbose) {\n-        tty->print_cr(\"SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d\", n->_idx);\n-      }\n-      continue;\n-    }\n-\n-#ifndef PRODUCT\n-    if (_vector_loop_debug) {\n-      tty->print_cr(\"SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);\", n->_idx, i);\n-    }\n-#endif\n-\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* ld = n->fast_out(i);\n-      if (ld->is_Load() && ld->as_Load()->in(MemNode::Memory) == n && in_bb(ld)) {\n-        for (int i = 0; i < _block.length(); i++) {\n-          Node* ld2 = _block.at(i);\n-          if (ld2->is_Load() && same_origin_idx(ld, ld2) &&\n-              !same_generation(ld, ld2)) { \/\/ <= do not collect the first generation ld\n-#ifndef PRODUCT\n-            if (_vector_loop_debug) {\n-              tty->print_cr(\"SuperWord::hoist_loads_in_graph: will try to hoist load ld2->_idx=%d, cloned from %d (ld->_idx=%d)\",\n-                ld2->_idx, _clone_map.idx(ld->_idx), ld->_idx);\n-            }\n-#endif\n-            \/\/ could not do on-the-fly, since iterator is immutable\n-            loads.push(ld2);\n-          }\n-        }\/\/ for\n-      }\/\/if\n-    }\/\/for (DUIterator_Fast imax,\n-  }\/\/for (int i = 0; i\n-\n-  for (int i = 0; i < loads.length(); i++) {\n-    LoadNode* ld = loads.at(i)->as_Load();\n-    Node* phi = find_phi_for_mem_dep(ld);\n-    if (phi != nullptr) {\n-#ifndef PRODUCT\n-      if (_vector_loop_debug) {\n-        tty->print_cr(\"SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d\",\n-          MemNode::Memory, ld->_idx, phi->_idx);\n-      }\n-#endif\n-      _igvn.replace_input_of(ld, MemNode::Memory, phi);\n-    }\n-  }\/\/for\n-\n-  restart(); \/\/ invalidate all basic structures, since we rebuilt the graph\n-\n-  if (TraceSuperWord && Verbose) {\n-    tty->print_cr(\"\\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild\");\n-  }\n-\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":471,"binary":false,"changes":472,"status":"modified"},{"patch":"@@ -310,2 +310,0 @@\n-  GrowableArray<Node*> _iteration_first; \/\/ nodes in the generation that has deps from phi\n-  GrowableArray<Node*> _iteration_last;  \/\/ nodes in the generation that has deps to   phi\n@@ -370,3 +368,0 @@\n-  int            _ii_first;        \/\/ generation with direct deps from mem phi\n-  int            _ii_last;         \/\/ generation with direct deps to   mem phi\n-  GrowableArray<int> _ii_order;\n@@ -558,16 +553,0 @@\n-  \/\/ rebuild the graph so all loads in different iterations of cloned loop become dependent on phi node (in _do_vector_loop only)\n-  bool hoist_loads_in_graph();\n-  \/\/ Test whether MemNode::Memory dependency to the same load but in the first iteration of this loop is coming from memory phi\n-  \/\/ Return false if failed\n-  Node* find_phi_for_mem_dep(LoadNode* ld);\n-  \/\/ Return same node but from the first generation. Return 0, if not found\n-  Node* first_node(Node* nd);\n-  \/\/ Return same node as this but from the last generation. Return 0, if not found\n-  Node* last_node(Node* n);\n-  \/\/ Mark nodes belonging to first and last generation\n-  \/\/ returns first generation index or -1 if vectorization\/simd is impossible\n-  int mark_generations();\n-  \/\/ swapping inputs of commutative instruction (Add or Mul)\n-  bool fix_commutative_inputs(Node* gold, Node* fix);\n-  \/\/ make packs forcefully (in _do_vector_loop only)\n-  bool pack_parallel();\n@@ -673,2 +652,0 @@\n-  \/\/ clean up some basic structures - used if the ideal graph was rebuilt\n-  void restart();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"}]}