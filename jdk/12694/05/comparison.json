{"files":[{"patch":"@@ -185,1 +185,1 @@\n-                if (frame instanceof ResetFrame) {\n+                if (frame instanceof ResetFrame rf) {\n@@ -187,1 +187,1 @@\n-                    handleReset((ResetFrame)frame, subscriber);\n+                    handleReset(rf, subscriber);\n@@ -466,3 +466,2 @@\n-        if ((frame instanceof HeaderFrame)) {\n-            HeaderFrame hframe = (HeaderFrame) frame;\n-            if (hframe.endHeaders()) {\n+        if ((frame instanceof HeaderFrame hf)) {\n+            if (hf.endHeaders()) {\n@@ -472,1 +471,1 @@\n-            if (hframe.getFlag(HeaderFrame.END_STREAM)) {\n+            if (hf.getFlag(HeaderFrame.END_STREAM)) {\n@@ -476,1 +475,1 @@\n-        } else if (frame instanceof DataFrame) {\n+        } else if (frame instanceof DataFrame df) {\n@@ -481,1 +480,1 @@\n-                connection.dropDataFrame((DataFrame) frame);\n+                connection.dropDataFrame(df);\n@@ -483,1 +482,1 @@\n-                receiveDataFrame((DataFrame) frame);\n+                receiveDataFrame(df);\n@@ -557,0 +556,10 @@\n+            if (!requestBodyCF.isDone()) {\n+                \/\/ If a RST_STREAM is received, complete the requestBody. This will allow the\n+                \/\/ response to be read before the Reset is handled in the case where the client's\n+                \/\/ input stream is partially consumed or not consumed at all by the server.\n+                if (frame.getErrorCode() != ResetFrame.NO_ERROR) {\n+                    requestBodyCF.completeExceptionally(new IOException(\"RST_STREAM received\"));\n+                } else {\n+                    requestBodyCF.complete(null);\n+                }\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293786\n+ * @summary Checks to see if the HttpClient can process a request to cancel a transmission from a remote if the server\n+ *          does not process any data. The client should read all data from the server and close the connection.\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm\/timeout=50 -Djdk.httpclient.HttpClient.log=all\n+ *                      PostPutTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.net.http.HttpRequest.BodyPublishers.ofByteArray;\n+\n+public class PostPutTest {\n+\n+    Http2TestServer http2TestServer;\n+    URI warmupURI, testHandlerBasicURI, testHandlerCloseBosURI, testHandleNegativeContentLengthURI;\n+    static PrintStream testLog = System.err;\n+\n+    \/\/ As per jdk.internal.net.http.WindowController.DEFAULT_INITIAL_WINDOW_SIZE\n+    final int DEFAULT_INITIAL_WINDOW_SIZE = (64 * 1024) - 1;\n+    \/\/ Add on a small amount of arbitrary bytes to see if client hangs when receiving RST_STREAM\n+    byte[] data = new byte[DEFAULT_INITIAL_WINDOW_SIZE + 10];\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        http2TestServer = new Http2TestServer(false, 0);\n+        http2TestServer.addHandler(new WarmupHandler(), \"\/Warmup\");\n+        http2TestServer.addHandler(new TestHandlerBasic(), \"\/TestHandlerBasic\");\n+        http2TestServer.addHandler(new TestHandlerCloseBos(), \"\/TestHandlerCloseBos\");\n+        http2TestServer.addHandler(new TestHandleNegativeContentLength(), \"\/TestHandleNegativeContentLength\");\n+        http2TestServer.start();\n+        testLog.println(\"PostPutTest.setup(): Starting server\");\n+        warmupURI = new URI(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/Warmup\");\n+        testHandlerBasicURI = new URI(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/TestHandlerBasic\");\n+        testHandlerCloseBosURI = new URI(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/TestHandlerCloseBos\");\n+        testHandleNegativeContentLengthURI = new URI(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/TestHandleNegativeContentLength\");\n+        testLog.println(\"PostPutTest.setup(): warmupURI: \" + warmupURI);\n+        testLog.println(\"PostPutTest.setup(): testHandlerBasicURI: \" + testHandlerBasicURI);\n+        testLog.println(\"PostPutTest.setup(): testHandlerCloseBosURI: \" + testHandlerCloseBosURI);\n+        testLog.println(\"PostPutTest.setup(): testHandleNegativeContentLengthURI: \" + testHandleNegativeContentLengthURI);\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        testLog.println(\"PostPutTest.teardown(): Stopping server\");\n+        http2TestServer.stop();\n+        data = null;\n+    }\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        HttpRequest over64kPost, over64kPut, over64kPostCloseBos, over64kPutCloseBos, over64kPostNegativeContentLength, over64kPutNegativeContentLength;\n+        over64kPost = HttpRequest.newBuilder().version(HTTP_2).POST(ofByteArray(data)).uri(testHandlerBasicURI).build();\n+        over64kPut = HttpRequest.newBuilder().version(HTTP_2).PUT(ofByteArray(data)).uri(testHandlerBasicURI).build();\n+\n+        over64kPostCloseBos = HttpRequest.newBuilder().version(HTTP_2).POST(ofByteArray(data)).uri(testHandlerCloseBosURI).build();\n+        over64kPutCloseBos = HttpRequest.newBuilder().version(HTTP_2).PUT(ofByteArray(data)).uri(testHandlerCloseBosURI).build();\n+\n+        over64kPostNegativeContentLength = HttpRequest.newBuilder().version(HTTP_2).POST(ofByteArray(data)).uri(testHandleNegativeContentLengthURI).build();\n+        over64kPutNegativeContentLength = HttpRequest.newBuilder().version(HTTP_2).PUT(ofByteArray(data)).uri(testHandleNegativeContentLengthURI).build();\n+\n+        return new Object[][] {\n+                { over64kPost, \"POST data over 64k bytes\" },\n+                { over64kPut, \"PUT data over 64k bytes\" },\n+                { over64kPostCloseBos, \"POST data over 64k bytes with close bos\" },\n+                { over64kPutCloseBos, \"PUT data over 64k bytes with close bos\" },\n+                { over64kPostNegativeContentLength, \"POST data over 64k bytes with negative content length\" },\n+                { over64kPutNegativeContentLength, \"PUT data over 64k bytes with negative content length\" }\n+        };\n+    }\n+\n+    public HttpRequest getWarmupReq() {\n+        return HttpRequest.newBuilder()\n+                .GET()\n+                .uri(warmupURI)\n+                .build();\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    public void testOver64kPUT(HttpRequest req, String testMessage) {\n+        testLog.println(\"PostPutTest: Performing test: \" + testMessage);\n+        HttpClient hc = HttpClient.newBuilder().version(HTTP_2).build();\n+        hc.sendAsync(getWarmupReq(), HttpResponse.BodyHandlers.ofString()).join();\n+        hc.sendAsync(req, HttpResponse.BodyHandlers.ofString()).join();\n+        \/*\n+            If this test fails in timeout, it is likely due to one of two reasons:\n+              - The responseSubscriber is null, so no incoming frames are being processed by the client\n+                (See Stream::schedule)\n+              - The test server is for some reason not sending a RST_STREAM with the NO_ERROR flag set after\n+                sending an empty DATA frame with the END_STREAM flag set.\n+        *\/\n+    }\n+\n+    private static class TestHandlerBasic implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            \/\/ The input stream is not read in this bug as this will trigger window updates for the server. This bug\n+            \/\/ concerns the case where no updates are sent and the server instead tells the client to abort the transmission.\n+            exchange.sendResponseHeaders(200, 0);\n+        }\n+    }\n+\n+    private static class TestHandlerCloseBos implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            \/\/ This case does actually cause the test to hang due to the body input stream being closed before it can send\n+            \/\/ the RST_STREAM frame.\n+            exchange.sendResponseHeaders(200, 0);\n+            exchange.getResponseBody().close();\n+        }\n+    }\n+\n+    private static class TestHandleNegativeContentLength implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            exchange.sendResponseHeaders(200, -1);\n+        }\n+    }\n+\n+    private static class WarmupHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            exchange.sendResponseHeaders(200, 0);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/PostPutTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -44,2 +44,2 @@\n-    boolean closed;\n-    boolean eof;\n+    volatile boolean closed;\n+    volatile boolean eof;\n@@ -103,0 +103,5 @@\n+\n+    public boolean isEof() {\n+        return eof;\n+    }\n+\n@@ -133,1 +138,0 @@\n-        \/\/ TODO reset this stream\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/BodyInputStream.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.net.http.frame.ResetFrame;\n@@ -42,0 +43,2 @@\n+    volatile BodyInputStream bis;\n+    volatile int resetErrorCode;\n@@ -134,0 +137,4 @@\n+            if (resetNeeded()) {\n+                \/\/ Send a reset if there is still unconsumed data in the input stream\n+                sendReset(EMPTY_BARRAY, 0, 0, ResetFrame.NO_ERROR);\n+            }\n@@ -135,1 +142,0 @@\n-            System.err.println(\"TestServer: OutputStream.close exception: \" + ex);\n@@ -140,1 +146,1 @@\n-    protected void sendEndStream() throws IOException {\n+    public void sendEndStream() throws IOException {\n@@ -143,0 +149,13 @@\n+\n+    public void sendReset(byte[] buf, int offset, int len, int flags) throws IOException {\n+        ByteBuffer buffer = ByteBuffer.allocate(len);\n+        buffer.put(buf, offset, len);\n+        buffer.flip();\n+        assert streamid != 0;\n+        ResetFrame rf = new ResetFrame(streamid, flags);\n+        outputQ.put(rf);\n+    }\n+\n+    private boolean resetNeeded() throws IOException {\n+        return (bis != null && (!bis.isEof() || bis.q.size() > 0));\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/BodyOutputStream.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.net.http.frame.ResetFrame;\n@@ -48,1 +49,1 @@\n-    final InputStream is;\n+    protected final InputStream is;\n@@ -152,0 +153,6 @@\n+            conn.outputQ.put(response);\n+            \/\/ Put a reset frame on the outputQ if there is still unconsumed data in the input stream and output stream\n+            \/\/ is going to be marked closed.\n+            if (is instanceof BodyInputStream bis && (!bis.isEof() || bis.q.size() > 0)) {\n+                conn.outputQ.put(new ResetFrame(streamid, ResetFrame.NO_ERROR));\n+            }\n@@ -153,0 +160,2 @@\n+        } else {\n+            conn.outputQ.put(response);\n@@ -154,1 +163,0 @@\n-        conn.outputQ.put(response);\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -721,0 +721,5 @@\n+\n+            \/\/ Need to pass the BodyInputStream reference to the BodyOutputStream, so it can determine if the stream\n+            \/\/ must be reset due to the BodyInputStream not being consumed by the handler when invoked.\n+            if (bis instanceof BodyInputStream bodyInputStream) bos.bis = bodyInputStream;\n+\n@@ -966,1 +971,1 @@\n-            protected void sendEndStream() throws IOException {\n+            public void sendEndStream() throws IOException {\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}