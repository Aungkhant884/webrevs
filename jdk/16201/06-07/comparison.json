{"files":[{"patch":"@@ -40,62 +40,0 @@\n-class DowncallStubGenerator : public StubCodeGenerator {\n-  BasicType* _signature;\n-  int _num_args;\n-  BasicType _ret_bt;\n-\n-  const ABIDescriptor& _abi;\n-  const GrowableArray<VMStorage>& _input_registers;\n-  const GrowableArray<VMStorage>& _output_registers;\n-\n-  bool _needs_return_buffer;\n-  int _captured_state_mask;\n-  bool _needs_transition;\n-\n-  int _frame_complete;\n-  int _frame_size_slots;\n-  OopMapSet* _oop_maps;\n-public:\n-  DowncallStubGenerator(CodeBuffer* buffer,\n-                        BasicType* signature,\n-                        int num_args,\n-                        BasicType ret_bt,\n-                        const ABIDescriptor& abi,\n-                        const GrowableArray<VMStorage>& input_registers,\n-                        const GrowableArray<VMStorage>& output_registers,\n-                        bool needs_return_buffer,\n-                        int captured_state_mask,\n-                        bool needs_transition)\n-   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n-     _signature(signature),\n-     _num_args(num_args),\n-     _ret_bt(ret_bt),\n-     _abi(abi),\n-     _input_registers(input_registers),\n-     _output_registers(output_registers),\n-     _needs_return_buffer(needs_return_buffer),\n-     _captured_state_mask(captured_state_mask),\n-     _needs_transition(needs_transition),\n-     _frame_complete(0),\n-     _frame_size_slots(0),\n-     _oop_maps(nullptr) {\n-  }\n-\n-  void generate();\n-\n-  int frame_complete() const {\n-    return _frame_complete;\n-  }\n-\n-  int framesize() const {\n-    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n-  }\n-\n-  OopMapSet* oop_maps() const {\n-    return _oop_maps;\n-  }\n-};\n-\n-void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n-                                                         VMStorage tmp1, VMStorage tmp2) const {\n-  Unimplemented();\n-}\n-\n@@ -117,4 +55,4 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n-                          input_registers, output_registers,\n-                          needs_return_buffer, captured_state_mask,\n-                          needs_transition);\n+  StubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                  input_registers, output_registers,\n+                  needs_return_buffer, captured_state_mask,\n+                  needs_transition);\n@@ -143,1 +81,30 @@\n-void DowncallStubGenerator::generate() {\n+static constexpr int FP_BIAS = 0; \/\/ sender_sp_offset is 0 on RISCV\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset, VMStorage tmp1, VMStorage tmp2) const {\n+  Register r_tmp1 = as_Register(tmp1);\n+  Register r_tmp2 = as_Register(tmp2);\n+  if (reg_oop.is_reg()) {\n+    assert(reg_oop.type() == StorageType::INTEGER, \"expected\");\n+    Register reg_oop_reg = as_Register(reg_oop);\n+    if (reg_offset.is_reg()) {\n+      assert(reg_offset.type() == StorageType::INTEGER, \"expected\");\n+      __ add(reg_oop_reg, reg_oop_reg, as_Register(reg_offset));\n+    } else {\n+      assert(reg_offset.is_stack(), \"expected\");\n+      assert(reg_offset.stack_size() == 8, \"expected long\");\n+      __ ld(r_tmp1, Address(fp, FP_BIAS + reg_offset.offset()));\n+      __ add(reg_oop_reg, reg_oop_reg, r_tmp1);\n+    }\n+  } else {\n+    assert(reg_oop.is_stack(), \"expected\");\n+    assert(reg_oop.stack_size() == 8, \"expected long\");\n+    assert(reg_offset.is_stack(), \"expected\");\n+    assert(reg_offset.stack_size() == 8, \"expected long\");\n+    __ ld(r_tmp1, Address(fp, FP_BIAS + reg_offset.offset()));\n+    __ ld(r_tmp2, Address(fp, FP_BIAS + reg_oop.offset()));\n+    __ add(r_tmp1, r_tmp2, r_tmp1);\n+    __ sd(r_tmp1, Address(fp, FP_BIAS + reg_oop.offset()));\n+  }\n+}\n+\n+void DowncallLinker::StubGenerator::generate() {\n@@ -155,0 +122,7 @@\n+  GrowableArray<VMStorage> java_regs;\n+  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n+  bool has_objects = false;\n+  GrowableArray<VMStorage> filtered_java_regs = ForeignGlobals::downcall_filter_offset_regs(java_regs, _signature,\n+                                                                                            _num_args, has_objects);\n+  assert(!(_needs_transition && has_objects), \"can not pass objects when doing transition\");\n+\n@@ -184,0 +158,14 @@\n+  \/\/ The space we have allocated will look like:\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      | (optional)          |\n+  \/\/      | capture state buf   |\n+  \/\/      |---------------------| = StubLocations::CAPTURED_STATE_BUFFER\n+  \/\/      | (optional)          |\n+  \/\/      | return buffer       |\n+  \/\/      |---------------------| = StubLocations::RETURN_BUFFER\n+  \/\/ SP-> | out\/stack args      | or | out_reg_spiller area |\n+  \/\/\n+  \/\/ Note how the last chunk can be shared, since the 3 uses occur at different times.\n+\n@@ -185,2 +173,0 @@\n-  GrowableArray<VMStorage> java_regs;\n-  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n@@ -188,1 +174,1 @@\n-  ArgumentShuffle arg_shuffle(java_regs, out_regs, shuffle_reg);\n+  ArgumentShuffle arg_shuffle(filtered_java_regs, out_regs, shuffle_reg);\n@@ -228,0 +214,4 @@\n+  if (has_objects) {\n+    add_offsets_to_oops(java_regs, as_VMStorage(t0), as_VMStorage(t1));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":60,"deletions":70,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-    log_debug_jni(\"Blocked from entering critical section while waiting on GC.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, options.allowsHeapAccess());\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, false) : new BoxBindingCalculator(false);\n@@ -257,1 +257,2 @@\n-        boolean forArguments;\n+        protected final boolean forArguments;\n+        private final boolean useAddressPairs;\n@@ -259,1 +260,1 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+        UnboxBindingCalculator(boolean forArguments, boolean useAddressPairs) {\n@@ -262,0 +263,1 @@\n+            this.useAddressPairs = useAddressPairs;\n@@ -285,1 +287,0 @@\n-                    bindings.unboxAddress();\n@@ -287,1 +288,10 @@\n-                    bindings.vmStore(storage, long.class);\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,0 +48,9 @@\n+    @Test\n+    public void testDowncallAllowHeap() {\n+        \/\/ Link a handle with a large number of address arguments, to try and overflow the code buffer\n+        Linker.nativeLinker().downcallHandle(\n+                FunctionDescriptor.of(C_LONG_LONG,\n+                        Stream.generate(() -> C_POINTER).limit(50).toArray(MemoryLayout[]::new)),\n+                Linker.Option.critical(true));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}