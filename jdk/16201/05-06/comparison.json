{"files":[{"patch":"@@ -39,60 +39,0 @@\n-class DowncallStubGenerator : public StubCodeGenerator {\n-  BasicType* _signature;\n-  int _num_args;\n-  BasicType _ret_bt;\n-  const ABIDescriptor& _abi;\n-\n-  const GrowableArray<VMStorage>&  _input_registers;\n-  const GrowableArray<VMStorage>&  _output_registers;\n-\n-  bool _needs_return_buffer;\n-  int _captured_state_mask;\n-  bool _needs_transition;\n-\n-  int _frame_complete;\n-  int _frame_size_slots;\n-  OopMapSet* _oop_maps;\n-  public:\n-  DowncallStubGenerator(CodeBuffer* buffer,\n-                         BasicType* signature,\n-                         int num_args,\n-                         BasicType ret_bt,\n-                         const ABIDescriptor& abi,\n-                         const GrowableArray<VMStorage>& input_registers,\n-                         const GrowableArray<VMStorage>& output_registers,\n-                         bool needs_return_buffer,\n-                         int captured_state_mask,\n-                         bool needs_transition)\n-    :StubCodeGenerator(buffer, PrintMethodHandleStubs),\n-    _signature(signature),\n-    _num_args(num_args),\n-    _ret_bt(ret_bt),\n-    _abi(abi),\n-    _input_registers(input_registers),\n-    _output_registers(output_registers),\n-    _needs_return_buffer(needs_return_buffer),\n-    _captured_state_mask(captured_state_mask),\n-    _needs_transition(needs_transition),\n-    _frame_complete(0),\n-    _frame_size_slots(0),\n-    _oop_maps(nullptr) {\n-    }\n-  void generate();\n-  int frame_complete() const {\n-    return _frame_complete;\n-  }\n-\n-  int framesize() const {\n-    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n-  }\n-\n-  OopMapSet* oop_maps() const {\n-    return _oop_maps;\n-  }\n-};\n-\n-void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n-                                                         VMStorage tmp1, VMStorage tmp2) const {\n-  Unimplemented();\n-}\n-\n@@ -116,4 +56,4 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n-                          input_registers, output_registers,\n-                          needs_return_buffer, captured_state_mask,\n-                          needs_transition);\n+  StubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                  input_registers, output_registers,\n+                  needs_return_buffer, captured_state_mask,\n+                  needs_transition);\n@@ -142,1 +82,35 @@\n-void DowncallStubGenerator::generate() {\n+static constexpr int FP_BIAS = frame::z_jit_out_preserve_size;\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Register r_tmp1 = as_Register(tmp1);\n+  Register r_tmp2 = as_Register(tmp2);\n+  Register callerSP = Z_R11;\n+  if (reg_oop.is_reg()) {\n+    assert(reg_oop.type() == StorageType::INTEGER, \"expected\");\n+    Register reg_oop_reg = as_Register(reg_oop);\n+    if (reg_offset.is_reg()) {\n+      assert(reg_offset.type() == StorageType::INTEGER, \"expected\");\n+      __ z_agr(reg_oop_reg, as_Register(reg_offset));\n+    } else {\n+      assert(reg_offset.is_stack(), \"expected\");\n+      assert(reg_offset.stack_size() == 8, \"expected long\");\n+      Address offset_addr(callerSP, FP_BIAS + reg_offset.offset());\n+      __ mem2reg_opt(r_tmp1, offset_addr, true);\n+      __ z_agr(reg_oop_reg, r_tmp1);\n+    }\n+  } else {\n+    assert(reg_oop.is_stack(), \"expected\");\n+    assert(reg_oop.stack_size() == 8, \"expected long\");\n+    assert(reg_offset.is_stack(), \"expected\");\n+    assert(reg_offset.stack_size() == 8, \"expected long\");\n+    Address offset_addr(callerSP, FP_BIAS + reg_offset.offset());\n+    Address oop_addr(callerSP, FP_BIAS + reg_oop.offset());\n+    __ mem2reg_opt(r_tmp1,offset_addr, true);\n+    __ mem2reg_opt(r_tmp2, oop_addr, true);\n+    __ z_agr(r_tmp1, r_tmp2);\n+    __ reg2mem_opt(r_tmp1, oop_addr, true);\n+  }\n+}\n+\n+void DowncallLinker::StubGenerator::generate() {\n@@ -168,0 +142,5 @@\n+  bool has_objects = false;\n+  GrowableArray<VMStorage> filtered_java_regs = ForeignGlobals::downcall_filter_offset_regs(java_regs, _signature,\n+                                                                                            _num_args, has_objects);\n+  assert(!(_needs_transition && has_objects), \"can not pass objects when doing transition\");\n+\n@@ -169,1 +148,1 @@\n-  ArgumentShuffle arg_shuffle(java_regs, out_regs, shuffle_reg);\n+  ArgumentShuffle arg_shuffle(filtered_java_regs, out_regs, _abi._scratch1);\n@@ -204,0 +183,3 @@\n+  if (has_objects) {\n+    add_offsets_to_oops(java_regs, _abi._scratch1, _abi._scratch2);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":48,"deletions":66,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, options.allowsHeapAccess());\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, false) : new BoxBindingCalculator(false);\n@@ -206,1 +206,3 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+            private final boolean useAddressPairs;\n+\n+            UnboxBindingCalculator(boolean forArguments, boolean useAddressPairs) {\n@@ -208,0 +210,1 @@\n+            this.useAddressPairs = useAddressPairs;\n@@ -238,2 +241,10 @@\n-                    bindings.unboxAddress()\n-                            .vmStore(storage, long.class);\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390CallArranger.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"}]}