{"files":[{"patch":"@@ -795,2 +795,1 @@\n-         * function call. As such, these temporary addresses, or any addresses derived from them, should not be used\n-         * after the function returns. Use of this mechanism is therefore only recommend when a function needs to do\n+         * function call. Use of this mechanism is therefore only recommend when a function needs to do\n@@ -800,4 +799,0 @@\n-         * @implNote As a consequence of allowing heap access, the JVM will either lock the garbage collector, or pin the\n-         * individual region of the heap in which the memory represented by a given memory segment resides, for the\n-         * duration of the function call.\n-         *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-                        heapBases[i] = ms.heapBase().get();\n+                        heapBases[i] = ms.unsafeGetBase();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                                String fName, FunctionDescriptor fDesc) {}\n+                                String fName, FunctionDescriptor fDesc, boolean readOnly) {}\n@@ -97,0 +97,3 @@\n+        if (testCase.readOnly()) {\n+            heapSegment = heapSegment.asReadOnly();\n+        }\n@@ -150,5 +153,7 @@\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc, false));\n+            \/\/ readOnly\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, true));\n","filename":"test\/jdk\/java\/foreign\/critical\/TestCritical.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -101,2 +101,1 @@\n-            MemorySegment nativeArr = arena.allocate(JAVA_INT, arr.length);\n-            MemorySegment.copy(arr, 0, nativeArr, JAVA_INT, 0, arr.length);\n+            MemorySegment nativeArr = arena.allocateFrom(JAVA_INT, arr);\n@@ -109,2 +108,1 @@\n-        MemorySegment nativeArr = recycler.allocate(JAVA_INT, arr.length);\n-        MemorySegment.copy(arr, 0, nativeArr, JAVA_INT, 0, arr.length);\n+        MemorySegment nativeArr = recycler.allocateFrom(JAVA_INT, arr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CriticalCalls.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    static final Unsafe unsafe;\n+    public static final Unsafe unsafe;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayCriticalXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Release}PrimitiveArrayCritical to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayCriticalXorOpImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayElementsXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Release}ByteArrayElements to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayElementsXorOpImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayForeignXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayForeignXorOpImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment srcBuf = arena.allocateFrom(JAVA_BYTE, MemorySegment.ofArray(src), JAVA_BYTE, sOff, len);\n+            MemorySegment dstBuf = arena.allocateFrom(JAVA_BYTE, MemorySegment.ofArray(dst), JAVA_BYTE, dOff, len);\n+            xor_op.invokeExact(srcBuf, dstBuf, len);\n+            MemorySegment.copy(dstBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpImpl.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_INT;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_POINTER;\n+\n+public class GetArrayForeignXorOpInitImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayForeignXorOpInitImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment srcBuf = arena.allocate(len);\n+            MemorySegment.copy(src, sOff, srcBuf, JAVA_BYTE, 0, len);\n+            MemorySegment dstBuf = arena.allocate(len);\n+            MemorySegment.copy(dst, dOff, dstBuf, JAVA_BYTE, 0, len);\n+            xor_op.invokeExact(srcBuf, dstBuf, len);\n+            MemorySegment.copy(dstBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpInitImpl.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayRegionXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Set}ByteArrayRegion to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayRegionXorOpImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import org.openjdk.bench.java.lang.foreign.Utils;\n+import sun.misc.Unsafe;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayUnsafeXorOpImpl implements XorOp {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    static final int BYTE_ARR_OFFSET = Utils.unsafe.arrayBaseOffset(byte[].class);\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayUnsafeXorOpImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        long srcBuf = UNSAFE.allocateMemory(len);\n+        long dstBuf = UNSAFE.allocateMemory(len);\n+        UNSAFE.copyMemory(src, sOff + BYTE_ARR_OFFSET, null, srcBuf, len);\n+        UNSAFE.copyMemory(dst, dOff + BYTE_ARR_OFFSET, null, dstBuf, len);\n+        xorOp(srcBuf, dstBuf, len);\n+        UNSAFE.copyMemory(null, dstBuf, dst, dOff + BYTE_ARR_OFFSET, len);\n+        UNSAFE.freeMemory(srcBuf);\n+        UNSAFE.freeMemory(dstBuf);\n+    }\n+\n+    native void xorOp(long src, long dst, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayUnsafeXorOpImpl.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public interface XorOp {\n+\n+    void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable;\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorOp.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+\n+public class XorTest {\n+\n+    XorOp impl = null;\n+    int alen;\n+    int off;\n+    int len;\n+    byte[] src, dst;\n+\n+    @Param\n+    SizeKind sizeKind;\n+\n+    @Param\n+    ArrayKind arrayKind;\n+\n+    public enum SizeKind {\n+        SMALL,\n+        MEDIUM,\n+        LARGE;\n+    }\n+\n+    public enum ArrayKind {\n+        JNI_ELEMENTS,\n+        JNI_REGION,\n+        JNI_CRITICAL,\n+        FOREIGN_NO_INIT,\n+        FOREIGN_INIT,\n+        FOREIGN_CRITICAL,\n+        UNSAFE;\n+    }\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        switch (arrayKind) {\n+            case JNI_CRITICAL:\n+                impl = new GetArrayCriticalXorOpImpl();\n+                break;\n+            case JNI_ELEMENTS:\n+                impl = new GetArrayElementsXorOpImpl();\n+                break;\n+            case JNI_REGION:\n+                impl = new GetArrayRegionXorOpImpl();\n+                break;\n+            case FOREIGN_NO_INIT:\n+                impl = new GetArrayForeignXorOpImpl();\n+                break;\n+            case FOREIGN_INIT:\n+                impl = new GetArrayForeignXorOpInitImpl();\n+                break;\n+            case FOREIGN_CRITICAL:\n+                impl = new GetArrayForeignXorOpCriticalImpl();\n+                break;\n+            case UNSAFE:\n+                impl = new GetArrayUnsafeXorOpImpl();\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(arrayKind.toString());\n+        }\n+\n+        switch (sizeKind) {\n+            case SMALL:\n+                alen = 1048576;             \/\/ 1 MB\n+                off = 1024 * 10;\n+                len = 1024 * 100;           \/\/ 100 KB\n+                break;\n+            case MEDIUM:\n+                alen = 1048576 * 8;         \/\/ 8 MB\n+                off = 1048576 * 1;\n+                len = 1048576 * 2;          \/\/ 2 MB\n+                break;\n+            case LARGE:\n+                alen = 1048576 * 100;       \/\/ 100 MB\n+                off = 1048576 * 5;\n+                len = 1048576 * 10;         \/\/ 10 MB\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(sizeKind.toString());\n+        }\n+\n+        src = new byte[alen];\n+        dst = new byte[alen];\n+        Arrays.fill(src, off, off + len, (byte)0xaa);\n+        Arrays.fill(dst, off, off + len, (byte)0x5a);\n+        check();\n+    }\n+\n+    void check() throws Throwable {\n+        impl.xor(src, off, dst, off, len);\n+        if (!verify(dst, off, off + len, (byte)0xf0)) {\n+            throw new IllegalStateException(\"Failed to verify\");\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void xor() throws Throwable {\n+        impl.xor(src, off, dst, off, len);\n+    }\n+\n+    static boolean verify(byte[] buf, int start, int end, byte val) {\n+        for (int i = start; i < end; ++i) {\n+            if (buf[i] != val)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+#include <stdlib.h>\n+#include <jni.h>\n+\n+JNIEXPORT void xor_op(jbyte *restrict src, jbyte *restrict dst, jint len) {\n+    for (int i = 0; i < len; ++i) {\n+        dst[i] ^= src[i];\n+    }\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayCriticalXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayCriticalXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len) {\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    sbuf = (*env)->GetPrimitiveArrayCritical(env, src, &sIsCopy);\n+    dbuf = (*env)->GetPrimitiveArrayCritical(env, dst, &dIsCopy);\n+    xor_op(&sbuf[sOff], &dbuf[dOff], len);\n+    (*env)->ReleasePrimitiveArrayCritical(env, dst, dbuf, 0);\n+    (*env)->ReleasePrimitiveArrayCritical(env, src, sbuf, JNI_ABORT);\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayElementsXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayElementsXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len) {\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    sbuf = (*env)->GetByteArrayElements(env, src, &sIsCopy);\n+    dbuf = (*env)->GetByteArrayElements(env, dst, &dIsCopy);\n+    xor_op(&sbuf[sOff], &dbuf[dOff], len);\n+    (*env)->ReleaseByteArrayElements(env, dst, dbuf, 0);\n+    (*env)->ReleaseByteArrayElements(env, src, sbuf, JNI_ABORT);\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayRegionXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayRegionXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len) {\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+\n+    sbuf = malloc(len);\n+    dbuf = malloc(len);\n+\n+    (*env)->GetByteArrayRegion(env, src, sOff, len, sbuf);\n+    (*env)->GetByteArrayRegion(env, dst, dOff, len, dbuf);\n+    xor_op(sbuf, dbuf, len);\n+    (*env)->SetByteArrayRegion(env, dst, dOff, len, dbuf);\n+\n+    free(dbuf);\n+    free(sbuf);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayUnsafeXorOpImpl_xorOp\n+  (JNIEnv *env, jobject obj, jlong src, jlong dst, jint len) {\n+    jbyte *sbuf = (jbyte*)(void*)src;\n+    jbyte *dbuf = (jbyte*)(void*)dst;\n+    xor_op(sbuf, dbuf, len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/libjnitest.c","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}