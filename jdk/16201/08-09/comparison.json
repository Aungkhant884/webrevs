{"files":[{"patch":"@@ -39,0 +39,6 @@\n+\n+    MemoryLayout STRUCT_LL = MemoryLayout.structLayout(\n+        C_LONG_LONG,\n+        C_LONG_LONG\n+    ); \/\/ 16 byte struct triggers return buffer usage on SysV\n+\n@@ -43,2 +49,2 @@\n-                FunctionDescriptor.of(C_LONG_LONG,\n-                        Stream.generate(() -> C_DOUBLE).limit(50).toArray(MemoryLayout[]::new)),\n+                FunctionDescriptor.of(STRUCT_LL,\n+                        Stream.generate(() -> C_DOUBLE).limit(124).toArray(MemoryLayout[]::new)),\n@@ -51,0 +57,2 @@\n+        \/\/ Using 83 parameters should get us 255 parameter slots in total:\n+        \/\/ 83 oops + 166 for offsets + 2 for the target address + 2 for return buffer + MH recv. + NEP\n@@ -52,2 +60,2 @@\n-                FunctionDescriptor.of(C_LONG_LONG,\n-                        Stream.generate(() -> C_POINTER).limit(50).toArray(MemoryLayout[]::new)),\n+                FunctionDescriptor.of(STRUCT_LL,\n+                        Stream.generate(() -> C_POINTER).limit(83).toArray(MemoryLayout[]::new)),\n@@ -61,2 +69,2 @@\n-                FunctionDescriptor.of(C_LONG_LONG,\n-                        Stream.generate(() -> C_DOUBLE).limit(50).toArray(MemoryLayout[]::new)));\n+                FunctionDescriptor.of(STRUCT_LL,\n+                        Stream.generate(() -> C_DOUBLE).limit(125).toArray(MemoryLayout[]::new)));\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"}]}