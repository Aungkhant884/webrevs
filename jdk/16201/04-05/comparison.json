{"files":[{"patch":"@@ -39,62 +39,0 @@\n-class DowncallStubGenerator : public StubCodeGenerator {\n-  BasicType* _signature;\n-  int _num_args;\n-  BasicType _ret_bt;\n-  const ABIDescriptor& _abi;\n-\n-  const GrowableArray<VMStorage>& _input_registers;\n-  const GrowableArray<VMStorage>& _output_registers;\n-\n-  bool _needs_return_buffer;\n-  int _captured_state_mask;\n-  bool _needs_transition;\n-\n-  int _frame_complete;\n-  int _frame_size_slots;\n-  OopMapSet* _oop_maps;\n-public:\n-  DowncallStubGenerator(CodeBuffer* buffer,\n-                         BasicType* signature,\n-                         int num_args,\n-                         BasicType ret_bt,\n-                         const ABIDescriptor& abi,\n-                         const GrowableArray<VMStorage>& input_registers,\n-                         const GrowableArray<VMStorage>& output_registers,\n-                         bool needs_return_buffer,\n-                         int captured_state_mask,\n-                         bool needs_transition)\n-   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n-     _signature(signature),\n-     _num_args(num_args),\n-     _ret_bt(ret_bt),\n-     _abi(abi),\n-     _input_registers(input_registers),\n-     _output_registers(output_registers),\n-     _needs_return_buffer(needs_return_buffer),\n-     _captured_state_mask(captured_state_mask),\n-     _needs_transition(needs_transition),\n-     _frame_complete(0),\n-     _frame_size_slots(0),\n-     _oop_maps(nullptr) {\n-  }\n-\n-  void generate();\n-\n-  int frame_complete() const {\n-    return _frame_complete;\n-  }\n-\n-  int framesize() const {\n-    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n-  }\n-\n-  OopMapSet* oop_maps() const {\n-    return _oop_maps;\n-  }\n-};\n-\n-void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n-                                                         VMStorage tmp1, VMStorage tmp2) const {\n-  Unimplemented();\n-}\n-\n@@ -116,4 +54,4 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n-                          input_registers, output_registers,\n-                          needs_return_buffer, captured_state_mask,\n-                          needs_transition);\n+  StubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                  input_registers, output_registers,\n+                  needs_return_buffer, captured_state_mask,\n+                  needs_transition);\n@@ -142,3 +80,33 @@\n-void DowncallStubGenerator::generate() {\n-  Register callerSP            = R2, \/\/ C\/C++ uses R2 as TOC, but we can reuse it here\n-           tmp                 = R11_scratch1, \/\/ same as shuffle_reg\n+static constexpr int FP_BIAS = frame::jit_out_preserve_size;\n+static const Register callerSP = R2; \/\/ C\/C++ uses R2 as TOC, but we can reuse it here\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Register r_tmp1 = as_Register(tmp1);\n+  Register r_tmp2 = as_Register(tmp2);\n+  if (reg_oop.is_reg()) {\n+    assert(reg_oop.type() == StorageType::INTEGER, \"expected\");\n+    Register reg_oop_reg = as_Register(reg_oop);\n+    if (reg_offset.is_reg()) {\n+      assert(reg_offset.type() == StorageType::INTEGER, \"expected\");\n+      __ add(reg_oop_reg, reg_oop_reg, as_Register(reg_offset));\n+    } else {\n+      assert(reg_offset.is_stack(), \"expected\");\n+      assert(reg_offset.stack_size() == 8, \"expected long\");\n+      __ ld(r_tmp1, reg_offset.offset() + FP_BIAS, callerSP);\n+      __ add(reg_oop_reg, reg_oop_reg, r_tmp1);\n+    }\n+  } else {\n+    assert(reg_oop.is_stack(), \"expected\");\n+    assert(reg_oop.stack_size() == 8, \"expected long\");\n+    assert(reg_offset.is_stack(), \"expected\");\n+    assert(reg_offset.stack_size() == 8, \"expected long\");\n+    __ ld(r_tmp1, reg_offset.offset() + FP_BIAS, callerSP);\n+    __ ld(r_tmp2, reg_oop.offset() + FP_BIAS, callerSP);\n+    __ add(r_tmp1, r_tmp2, r_tmp1);\n+    __ std(r_tmp1, reg_oop.offset() + FP_BIAS, callerSP);\n+  }\n+}\n+\n+void DowncallLinker::StubGenerator::generate() {\n+  Register tmp                 = R11_scratch1, \/\/ same as shuffle_reg\n@@ -188,0 +156,5 @@\n+  bool has_objects = false;\n+  GrowableArray<VMStorage> filtered_java_regs = ForeignGlobals::downcall_filter_offset_regs(java_regs, _signature,\n+                                                                                             _num_args, has_objects);\n+  assert(!(_needs_transition && has_objects), \"can not pass objects when doing transition\");\n+\n@@ -189,1 +162,2 @@\n-  ArgumentShuffle arg_shuffle(java_regs, out_regs, _abi._scratch1);\n+\n+  ArgumentShuffle arg_shuffle(filtered_java_regs, out_regs, _abi._scratch1);\n@@ -225,0 +199,4 @@\n+  if (has_objects) {\n+    add_offsets_to_oops(java_regs, _abi._scratch1, _abi._scratch2);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":48,"deletions":70,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, options.allowsHeapAccess());\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, false) : new BoxBindingCalculator(false);\n@@ -340,1 +340,3 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+        private final boolean useAddressPairs;\n+\n+        UnboxBindingCalculator(boolean forArguments, boolean useAddressPairs) {\n@@ -342,0 +344,1 @@\n+            this.useAddressPairs = useAddressPairs;\n@@ -407,2 +410,10 @@\n-                    bindings.unboxAddress()\n-                            .vmStore(storage, long.class);\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayForeignXorOpCriticalImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(true));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayForeignXorOpCriticalImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        xor_op.invokeExact(MemorySegment.ofArray(src).asSlice(sOff), MemorySegment.ofArray(dst).asSlice(dOff), len);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpCriticalImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"}]}