{"files":[{"patch":"@@ -1790,1 +1790,1 @@\n-int os::fork_and_exec(const char* cmd) {\n+int os::fork_and_exec(const char* cmd, bool prefer_vfork) {\n@@ -1797,10 +1797,4 @@\n-  \/\/ We use vfork() where possible to avoid native ooms when forking off from parents\n-  \/\/  with high memory footprints. While a bit unsafe, in this case using vfork is\n-  \/\/  perfectly fine (when called in a simple vfork->exec->_exit sequence with no\n-  \/\/  intermediate steps).\n-  \/\/ But since vfork is not async-safe we only use it where we are sure to be outside\n-  \/\/  of signal handling.\n-  const Thread* const t = Thread::current_or_null_safe();\n-  const bool use_vfork = t != NULL && t->is_in_signal_handler() == false;\n-\n-  pid = use_vfork ? ::vfork() : ::fork();\n+  \/\/ Use always vfork on AIX, since its safe and helps with analyzing OOM situations.\n+  \/\/ Otherwise leave it up to the caller.\n+  AIX_ONLY(prefer_vfork = true;)\n+  pid = prefer_vfork ? ::vfork() : ::fork();\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -568,16 +568,0 @@\n-class InSignalHandlerMark: public StackObj {\n-  Thread* const _thread;\n-public:\n-  InSignalHandlerMark() :\n-    _thread(Thread::current_or_null_safe()) {\n-    if (_thread) {\n-      _thread->set_in_signal_handler(true);\n-    }\n-  }\n-  ~InSignalHandlerMark() {\n-    if (_thread) {\n-      _thread->set_in_signal_handler(false);\n-    }\n-  }\n-};\n-\n@@ -600,2 +584,0 @@\n-  InSignalHandlerMark ishm;\n-\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -5517,1 +5517,1 @@\n-int os::fork_and_exec(const char* cmd) {\n+int os::fork_and_exec(const char* cmd, bool dummy \/* ignored *\/) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -508,1 +508,4 @@\n-  static int fork_and_exec(const char *cmd);\n+  \/\/ The \"prefer_vfork\" argument is only used on POSIX platforms to\n+  \/\/ indicate whether vfork should be used instead of fork to spawn the\n+  \/\/ child process (ignored on AIX, which always uses vfork).\n+  static int fork_and_exec(const char *cmd, bool prefer_vfork = false);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -298,2 +298,0 @@\n-  _in_signal_handler = false;\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -825,9 +825,0 @@\n-\n-#ifdef POSIX\n- private:\n-  bool _in_signal_handler;\n- public:\n-  bool is_in_signal_handler() const   { return _in_signal_handler; }\n-  void set_in_signal_handler(bool b)  { _in_signal_handler = b; }\n-#endif \/\/ POSIX\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -434,11 +434,0 @@\n-#if !defined(_WINDOWS)\n-#ifndef POSIX\n-#define POSIX\n-#endif\n-#define POSIX_ONLY(code) code\n-#define NOT_POSIX(code)\n-#else\n-#define POSIX_ONLY(code)\n-#define NOT_POSIX(code) code\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1663,1 +1663,1 @@\n-    if (os::fork_and_exec(cmd) < 0) {\n+    if (os::fork_and_exec(cmd, true) < 0) {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}