{"files":[{"patch":"@@ -111,1 +111,0 @@\n-#include <sys\/wait.h>\n@@ -3153,58 +3152,0 @@\n-extern char** environ;\n-\n-\/\/ Run the specified command in a separate process. Return its exit value,\n-\/\/ or -1 on failure (e.g. can't fork a new process).\n-\/\/ Unlike system(), this function can be called from signal handler. It\n-\/\/ doesn't block SIGINT et al.\n-int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {\n-  char* argv[4] = { (char*)\"sh\", (char*)\"-c\", cmd, NULL};\n-\n-  pid_t pid = fork();\n-\n-  if (pid < 0) {\n-    \/\/ fork failed\n-    return -1;\n-\n-  } else if (pid == 0) {\n-    \/\/ child process\n-\n-    \/\/ Try to be consistent with system(), which uses \"\/usr\/bin\/sh\" on AIX.\n-    execve(\"\/usr\/bin\/sh\", argv, environ);\n-\n-    \/\/ execve failed\n-    _exit(-1);\n-\n-  } else {\n-    \/\/ copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n-    \/\/ care about the actual exit code, for now.\n-\n-    int status;\n-\n-    \/\/ Wait for the child process to exit. This returns immediately if\n-    \/\/ the child has already exited. *\/\n-    while (waitpid(pid, &status, 0) < 0) {\n-      switch (errno) {\n-        case ECHILD: return 0;\n-        case EINTR: break;\n-        default: return -1;\n-      }\n-    }\n-\n-    if (WIFEXITED(status)) {\n-      \/\/ The child exited normally; get its exit code.\n-      return WEXITSTATUS(status);\n-    } else if (WIFSIGNALED(status)) {\n-      \/\/ The child exited because of a signal.\n-      \/\/ The best value to return is 0x80 + signal number,\n-      \/\/ because that is what all Unix shells do, and because\n-      \/\/ it allows callers to distinguish between process exit and\n-      \/\/ process death by signal.\n-      return 0x80 + WTERMSIG(status);\n-    } else {\n-      \/\/ Unknown exit code; pass it through.\n-      return status;\n-    }\n-  }\n-  return -1;\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-# include <sys\/wait.h>\n@@ -2613,74 +2612,0 @@\n-\/\/ Darwin has no \"environ\" in a dynamic library.\n-#ifdef __APPLE__\n-  #include <crt_externs.h>\n-  #define environ (*_NSGetEnviron())\n-#else\n-extern char** environ;\n-#endif\n-\n-\/\/ Run the specified command in a separate process. Return its exit value,\n-\/\/ or -1 on failure (e.g. can't fork a new process).\n-\/\/ Unlike system(), this function can be called from signal handler. It\n-\/\/ doesn't block SIGINT et al.\n-int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {\n-  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n-\n-  \/\/ fork() in BsdThreads\/NPTL is not async-safe. It needs to run\n-  \/\/ pthread_atfork handlers and reset pthread library. All we need is a\n-  \/\/ separate process to execve. Make a direct syscall to fork process.\n-  \/\/ On IA64 there's no fork syscall, we have to use fork() and hope for\n-  \/\/ the best...\n-  pid_t pid = fork();\n-\n-  if (pid < 0) {\n-    \/\/ fork failed\n-    return -1;\n-\n-  } else if (pid == 0) {\n-    \/\/ child process\n-\n-    \/\/ execve() in BsdThreads will call pthread_kill_other_threads_np()\n-    \/\/ first to kill every thread on the thread list. Because this list is\n-    \/\/ not reset by fork() (see notes above), execve() will instead kill\n-    \/\/ every thread in the parent process. We know this is the only thread\n-    \/\/ in the new process, so make a system call directly.\n-    \/\/ IA64 should use normal execve() from glibc to match the glibc fork()\n-    \/\/ above.\n-    execve(\"\/bin\/sh\", (char* const*)argv, environ);\n-\n-    \/\/ execve failed\n-    _exit(-1);\n-\n-  } else  {\n-    \/\/ copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n-    \/\/ care about the actual exit code, for now.\n-\n-    int status;\n-\n-    \/\/ Wait for the child process to exit.  This returns immediately if\n-    \/\/ the child has already exited. *\/\n-    while (waitpid(pid, &status, 0) < 0) {\n-      switch (errno) {\n-      case ECHILD: return 0;\n-      case EINTR: break;\n-      default: return -1;\n-      }\n-    }\n-\n-    if (WIFEXITED(status)) {\n-      \/\/ The child exited normally; get its exit code.\n-      return WEXITSTATUS(status);\n-    } else if (WIFSIGNALED(status)) {\n-      \/\/ The child exited because of a signal\n-      \/\/ The best value to return is 0x80 + signal number,\n-      \/\/ because that is what all Unix shells do, and because\n-      \/\/ it allows callers to distinguish between process exit and\n-      \/\/ process death by signal.\n-      return 0x80 + WTERMSIG(status);\n-    } else {\n-      \/\/ Unknown exit code; pass it through\n-      return status;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-# include <sys\/wait.h>\n@@ -5222,62 +5221,0 @@\n-extern char** environ;\n-\n-\/\/ Run the specified command in a separate process. Return its exit value,\n-\/\/ or -1 on failure (e.g. can't fork a new process).\n-\/\/ Unlike system(), this function can be called from signal handler. It\n-\/\/ doesn't block SIGINT et al.\n-int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {\n-  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n-\n-  pid_t pid ;\n-\n-  if (use_vfork_if_available) {\n-    pid = vfork();\n-  } else {\n-    pid = fork();\n-  }\n-\n-  if (pid < 0) {\n-    \/\/ fork failed\n-    return -1;\n-\n-  } else if (pid == 0) {\n-    \/\/ child process\n-\n-    execve(\"\/bin\/sh\", (char* const*)argv, environ);\n-\n-    \/\/ execve failed\n-    _exit(-1);\n-\n-  } else  {\n-    \/\/ copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n-    \/\/ care about the actual exit code, for now.\n-\n-    int status;\n-\n-    \/\/ Wait for the child process to exit.  This returns immediately if\n-    \/\/ the child has already exited. *\/\n-    while (waitpid(pid, &status, 0) < 0) {\n-      switch (errno) {\n-      case ECHILD: return 0;\n-      case EINTR: break;\n-      default: return -1;\n-      }\n-    }\n-\n-    if (WIFEXITED(status)) {\n-      \/\/ The child exited normally; get its exit code.\n-      return WEXITSTATUS(status);\n-    } else if (WIFSIGNALED(status)) {\n-      \/\/ The child exited because of a signal\n-      \/\/ The best value to return is 0x80 + signal number,\n-      \/\/ because that is what all Unix shells do, and because\n-      \/\/ it allows callers to distinguish between process exit and\n-      \/\/ process death by signal.\n-      return 0x80 + WTERMSIG(status);\n-    } else {\n-      \/\/ Unknown exit code; pass it through\n-      return status;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include <sys\/types.h>\n@@ -55,0 +56,1 @@\n+#include <sys\/wait.h>\n@@ -59,0 +61,4 @@\n+#ifdef __APPLE__\n+  #include <crt_externs.h>\n+#endif\n+\n@@ -1768,0 +1774,75 @@\n+\n+\/\/ Darwin has no \"environ\" in a dynamic library.\n+#ifdef __APPLE__\n+  #define environ (*_NSGetEnviron())\n+#else\n+  extern char** environ;\n+#endif\n+\n+char** os::get_environ() { return environ; }\n+\n+\/\/ Run the specified command in a separate process. Return its exit value,\n+\/\/ or -1 on failure (e.g. can't fork a new process).\n+\/\/ Notes: -Unlike system(), this function can be called from signal handler. It\n+\/\/         doesn't block SIGINT et al.\n+\/\/        -this function is unsafe to use in non-error situations, mainly\n+\/\/         because the child process will inherit all parent descriptors.\n+int os::fork_and_exec(const char* cmd) {\n+  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n+\n+  pid_t pid ;\n+\n+  char** env = os::get_environ();\n+\n+  \/\/ We use vfork() if possible since we it helps with spawning child processes from\n+  \/\/ parents with high footprints. Since vfork is not async safe, we avoid calling\n+  \/\/ it if this function is called from within signal handling.\n+  const Thread* const t = Thread::current_or_null_safe();\n+  const bool use_vfork = t != NULL && t->is_in_signal_handler() == false;\n+ printf(\">>%d\\n\", use_vfork);\n+  pid = use_vfork ? ::vfork() : ::fork();\n+\n+  if (pid < 0) {\n+    \/\/ fork failed\n+    return -1;\n+\n+  } else if (pid == 0) {\n+    \/\/ child process\n+\n+    ::execve(\"\/bin\/sh\", (char* const*)argv, env);\n+\n+    \/\/ execve failed\n+    ::_exit(-1);\n+\n+  } else  {\n+    \/\/ copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n+    \/\/ care about the actual exit code, for now.\n+\n+    int status;\n+\n+    \/\/ Wait for the child process to exit.  This returns immediately if\n+    \/\/ the child has already exited. *\/\n+    while (::waitpid(pid, &status, 0) < 0) {\n+      switch (errno) {\n+      case ECHILD: return 0;\n+      case EINTR: break;\n+      default: return -1;\n+      }\n+    }\n+\n+    if (WIFEXITED(status)) {\n+      \/\/ The child exited normally; get its exit code.\n+      return WEXITSTATUS(status);\n+    } else if (WIFSIGNALED(status)) {\n+      \/\/ The child exited because of a signal\n+      \/\/ The best value to return is 0x80 + signal number,\n+      \/\/ because that is what all Unix shells do, and because\n+      \/\/ it allows callers to distinguish between process exit and\n+      \/\/ process death by signal.\n+      return 0x80 + WTERMSIG(status);\n+    } else {\n+      \/\/ Unknown exit code; pass it through\n+      return status;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -568,0 +568,16 @@\n+class InSignalHandlerMark: public StackObj {\n+  Thread* const _thread;\n+public:\n+  InSignalHandlerMark() :\n+    _thread(Thread::current_or_null_safe()) {\n+    if (_thread) {\n+      _thread->set_in_signal_handler(true);\n+    }\n+  }\n+  ~InSignalHandlerMark() {\n+    if (_thread) {\n+      _thread->set_in_signal_handler(false);\n+    }\n+  }\n+};\n+\n@@ -584,0 +600,2 @@\n+  InSignalHandlerMark ishm;\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -269,0 +269,2 @@\n+char** os::get_environ() { return _environ; }\n+\n@@ -5515,1 +5517,1 @@\n-int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {\n+int os::fork_and_exec(const char* cmd) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,8 +37,0 @@\n-#ifdef __APPLE__\n-#include <crt_externs.h>\n-#define environ (*_NSGetEnviron())\n-#endif\n-\n-#ifndef environ\n-extern char** environ;\n-#endif\n@@ -284,1 +276,1 @@\n-  if (environ == NULL) {\n+  if (os::get_environ() == NULL) {\n@@ -291,1 +283,1 @@\n-    for (char** p = environ; *p != NULL; p++) {\n+    for (char** p = os::get_environ(); *p != NULL; p++) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,0 +185,2 @@\n+  \/\/ Get environ pointer, platform independently\n+  static char** get_environ();\n@@ -504,2 +506,3 @@\n-  \/\/ run cmd in a separate process and return its exit code; or -1 on failures\n-  static int fork_and_exec(char *cmd, bool use_vfork_if_available = false);\n+  \/\/ run cmd in a separate process and return its exit code; or -1 on failures.\n+  \/\/ Note: only safe to use in fatal error situations.\n+  static int fork_and_exec(const char *cmd);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -298,0 +298,2 @@\n+  _in_signal_handler = false;\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -825,0 +825,9 @@\n+\n+#ifdef POSIX\n+ private:\n+  bool _in_signal_handler;\n+ public:\n+  bool is_in_signal_handler() const   { return _in_signal_handler; }\n+  void set_in_signal_handler(bool b)  { _in_signal_handler = b; }\n+#endif \/\/ POSIX\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -434,0 +434,11 @@\n+#if !defined(_WINDOWS)\n+#ifndef POSIX\n+#define POSIX\n+#endif\n+#define POSIX_ONLY(code) code\n+#define NOT_POSIX(code)\n+#else\n+#define POSIX_ONLY(code)\n+#define NOT_POSIX(code) code\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1663,1 +1663,1 @@\n-    if (os::fork_and_exec(cmd, true) < 0) {\n+    if (os::fork_and_exec(cmd) < 0) {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}