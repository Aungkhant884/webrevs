{"files":[{"patch":"@@ -31,0 +31,2 @@\n+    _ZAddressMetadataMask(&ZAddressMetadataMask),\n+    _ZAddressMetadataFinalizable(&ZAddressMetadataFinalizable),\n","filename":"src\/hotspot\/share\/gc\/z\/vmStructs_z.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  uintptr_t* _ZAddressMetadataMask;\n+  uintptr_t* _ZAddressMetadataFinalizable;\n@@ -58,0 +60,1 @@\n+typedef ZGranuleMap<ZForwarding*> ZGranuleMapForForwarding;\n@@ -65,0 +68,2 @@\n+  nonstatic_field(ZGlobalsForVMStructs,         _ZAddressMetadataMask, uintptr_t*)                   \\\n+  nonstatic_field(ZGlobalsForVMStructs,         _ZAddressMetadataFinalizable, uintptr_t*)            \\\n@@ -75,0 +80,2 @@\n+  nonstatic_field(ZHeap,                        _forwarding_table,    ZForwardingTable)              \\\n+  nonstatic_field(ZHeap,                        _relocate,            ZRelocate)                     \\\n@@ -88,0 +95,3 @@\n+  nonstatic_field(ZGranuleMapForForwarding,     _map,                 ZForwarding** const)           \\\n+                                                                                                     \\\n+  nonstatic_field(ZForwardingTable,             _map,                 ZGranuleMapForForwarding)      \\\n@@ -92,1 +102,6 @@\n-  nonstatic_field(ZForwarding,                  _entries,             const ZAttachedArrayForForwarding)\n+  nonstatic_field(ZForwarding,                  _virtual,             const ZVirtualMemory)          \\\n+  nonstatic_field(ZForwarding,                  _object_alignment_shift, const size_t)               \\\n+  volatile_nonstatic_field(ZForwarding,         _ref_count,           int)                           \\\n+  nonstatic_field(ZForwarding,                  _entries,             const ZAttachedArrayForForwarding) \\\n+  nonstatic_field(ZForwardingEntry,             _entry,               uint64_t)                      \\\n+  nonstatic_field(ZAttachedArrayForForwarding,  _length,              const size_t)\n@@ -115,0 +130,1 @@\n+  declare_toplevel_type(ZRelocate)                                                                   \\\n@@ -120,0 +136,1 @@\n+  declare_toplevel_type(ZGranuleMapForForwarding)                                                    \\\n","filename":"src\/hotspot\/share\/gc\/z\/vmStructs_z.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+  friend class VMStructs;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zAttachedArray.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingEntry.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+  friend class VMStructs;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        return (as_long(value) & ZGlobals.ZAddressWeakBadMask()) != 0;\n+        return (as_long(value) & ZGlobals.ZAddressWeakBadMask()) != 0L;\n@@ -65,0 +65,12 @@\n+\n+    private static boolean isPowerOf2(long value) {\n+        return (value != 0L) && ((value & (value - 1)) == 0L);\n+    }\n+\n+    static boolean isIn(Address addr) {\n+        long value = as_long(addr);\n+        if (!isPowerOf2(value & ~ZGlobals.ZAddressOffsetMask())) {\n+            return false;\n+        }\n+        return (value & (ZGlobals.ZAddressMetadataMask() & ~ZGlobals.ZAddressMetadataFinalizable())) != 0L;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZAddress.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZAttachedArrayForForwarding extends VMObject {\n+    private static CIntegerField lengthField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ZAttachedArrayForForwarding\");\n+\n+        lengthField = type.getCIntegerField(\"_length\");\n+    }\n+\n+    public ZAttachedArrayForForwarding(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long length() {\n+        return lengthField.getValue(addr);\n+    }\n+\n+    \/\/ ObjectT: ZForwarding\n+    \/\/  ArrayT: ZForwardingEntry\n+    \/\/\n+    \/\/ template <typename ObjectT, typename ArrayT>\n+    \/\/ inline size_t ZAttachedArray<ObjectT, ArrayT>::object_size()\n+    private long objectSize() {\n+        return ZUtils.alignUp(ZForwarding.getSize(), ZForwardingEntry.getSize());\n+    }\n+\n+    \/\/ ArrayT* operator()(const ObjectT* obj) const\n+    public ZForwardingEntry get(ZForwarding obj) {\n+        Address o = obj.getAddress().addOffsetTo(objectSize());\n+        return VMObjectFactory.newObject(ZForwardingEntry.class, o);\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZAttachedArrayForForwarding.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,8 +44,1 @@\n-        ZHeap heap = zheap();\n-        if (heap.is_relocating(addr)) {\n-            \/\/ Forward\n-            return heap.relocate_object(addr);\n-        }\n-\n-        \/\/ Remap\n-        return ZAddress.good(addr);\n+        return zheap().relocate_object(addr);\n@@ -60,8 +53,1 @@\n-        ZHeap heap = zheap();\n-        if (heap.is_relocating(addr)) {\n-            \/\/ Forward\n-            return heap.forward_object(addr);\n-        }\n-\n-        \/\/ Remap\n-        return ZAddress.good(addr);\n+        return zheap().remapObject(addr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZBarrier.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,4 @@\n-\n+    @Override\n+    public boolean isInReserved(Address a) {\n+        return heap().isIn(a);\n+    }\n@@ -109,1 +112,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZCollectedHeap.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import java.util.Iterator;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZForwarding extends VMObject {\n+    private static Type type;\n+    private static long virtualFieldOffset;\n+    private static long entriesFieldOffset;\n+    private static CIntegerField objectAlignmentShiftField;\n+    private static CIntegerField refCountField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        type = db.lookupType(\"ZForwarding\");\n+\n+        virtualFieldOffset = type.getField(\"_virtual\").getOffset();\n+        entriesFieldOffset = type.getField(\"_entries\").getOffset();\n+        objectAlignmentShiftField = type.getCIntegerField(\"_object_alignment_shift\");\n+        refCountField = type.getCIntegerField(\"_ref_count\");\n+    }\n+\n+    public ZForwarding(Address addr) {\n+        super(addr);\n+    }\n+\n+    public static long getSize() {\n+        return type.getSize();\n+    }\n+\n+    private ZVirtualMemory virtual() {\n+        return VMObjectFactory.newObject(ZVirtualMemory.class, addr.addOffsetTo(virtualFieldOffset));\n+    }\n+\n+    private ZAttachedArrayForForwarding entries() {\n+        return VMObjectFactory.newObject(ZAttachedArrayForForwarding.class, addr.addOffsetTo(entriesFieldOffset));\n+    }\n+\n+    public long start() {\n+        return virtual().start();\n+    }\n+\n+    public int objectAlignmentShift() {\n+        return (int)objectAlignmentShiftField.getValue(addr);\n+    }\n+\n+    public boolean retainPage() {\n+        return refCountField.getValue(addr) > 0;\n+    }\n+\n+    private ZForwardingEntry at(long cursor) {\n+        long offset = ZForwardingEntry.getSize() * cursor;\n+        Address entryAddress = entries().get(this).getAddress().addOffsetTo(offset);\n+        return VMObjectFactory.newObject(ZForwardingEntry.class, entryAddress);\n+    }\n+\n+    private class ZForwardEntryIterator implements Iterator<ZForwardingEntry> {\n+\n+        private long cursor;\n+\n+        private ZForwardingEntry nextEntry;\n+\n+        public ZForwardEntryIterator(long fromIndex) {\n+            long mask = entries().length() - 1;\n+            long hash = ZHash.uint32_to_uint32(fromIndex);\n+            cursor = hash & mask;\n+            nextEntry = at(cursor);\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return nextEntry.populated();\n+        }\n+\n+        @Override\n+        public ZForwardingEntry next() {\n+            ZForwardingEntry entry = nextEntry;\n+\n+            long mask = entries().length() - 1;\n+            cursor = (cursor + 1) & mask;\n+            nextEntry = at(cursor);\n+\n+            return entry;\n+        }\n+\n+        public ZForwardingEntry peak() {\n+            return nextEntry;\n+        }\n+    }\n+\n+    public ZForwardingEntry find(long fromIndex) {\n+        ZForwardEntryIterator itr = new ZForwardEntryIterator(fromIndex);\n+        while (itr.hasNext()) {\n+            ZForwardingEntry entry = itr.next();\n+            if (entry.fromIndex() == fromIndex) {\n+                return entry;\n+            }\n+        }\n+        return itr.peak();\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwarding.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZForwardingEntry extends VMObject {\n+    private static Type type;\n+    private static CIntegerField entryField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        type = db.lookupType(\"ZForwardingEntry\");\n+\n+        entryField = type.getCIntegerField(\"_entry\");\n+    }\n+\n+    public static long getSize() {\n+        return type.getSize();\n+    }\n+\n+    public ZForwardingEntry(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long entry() {\n+        return entryField.getValue(addr);\n+    }\n+\n+    \/\/ typedef ZBitField<uint64_t, bool,   0,   1> field_populated\n+    private boolean fieldPopulatedDecode(long value) {\n+        long FieldMask = (1L << 1) - 1;\n+        int FieldShift = 1;\n+        int ValueShift = 0;\n+        return (((value >>> FieldShift) & FieldMask) << ValueShift) != 0L;\n+    }\n+\n+    \/\/ typedef ZBitField<uint64_t, size_t, 1,  45> field_to_offset;\n+    private long fieldToOffsetDecode(long value) {\n+        long FieldMask = (1L << 45) - 1;\n+        int FieldShift = 1;\n+        int ValueShift = 0;\n+        return ((value >>> FieldShift) & FieldMask) << ValueShift;\n+    }\n+\n+    \/\/ typedef ZBitField<uint64_t, size_t, 46, 18> field_from_index;\n+    private long fieldFromIndexDecode(long value) {\n+        long FieldMask = (1L << 18) - 1;\n+        int FieldShift = 46;\n+        int ValueShift = 0;\n+        return ((value >>> FieldShift) & FieldMask) << ValueShift;\n+    }\n+\n+    public boolean populated() {\n+        return fieldPopulatedDecode(entry());\n+    }\n+\n+    public long toOffset() {\n+        return fieldToOffsetDecode(entry());\n+    }\n+\n+    public long fromIndex() {\n+        return fieldFromIndexDecode(entry());\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwardingEntry.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n@@ -36,2 +37,1 @@\n-    private static AddressField tableField;\n-    private static CIntegerField sizeField;\n+    private static long mapFieldOffset;\n@@ -46,2 +46,1 @@\n-        tableField = type.getAddressField(\"_table\");\n-        sizeField = type.getCIntegerField(\"_size\");\n+        mapFieldOffset = type.getAddressField(\"_map\").getOffset();\n@@ -54,2 +53,2 @@\n-    Address table() {\n-        return tableField.getAddress(addr);\n+    private ZGranuleMapForForwarding map() {\n+        return VMObjectFactory.newObject(ZGranuleMapForForwarding.class, addr.addOffsetTo(mapFieldOffset));\n@@ -58,58 +57,2 @@\n-    long size() {\n-        return sizeField.getJLong(addr);\n-    }\n-\n-    ZForwardingTableEntry at(ZForwardingTableCursor cursor) {\n-        return new ZForwardingTableEntry(table().getAddressAt(cursor._value * VM.getVM().getBytesPerLong()));\n-    }\n-\n-    ZForwardingTableEntry first(long from_index, ZForwardingTableCursor cursor) {\n-        long mask = size() - 1;\n-        long hash = ZHash.uint32_to_uint32(from_index);\n-        cursor._value = hash & mask;\n-        return at(cursor);\n-    }\n-\n-    ZForwardingTableEntry next(ZForwardingTableCursor cursor) {\n-        long mask = size() - 1;\n-        cursor._value = (cursor._value + 1) & mask;\n-        return at(cursor);\n-    }\n-\n-    ZForwardingTableEntry find(long from_index, ZForwardingTableCursor cursor) {\n-        \/\/ Reading entries in the table races with the atomic cas done for\n-        \/\/ insertion into the table. This is safe because each entry is at\n-        \/\/ most updated once (from -1 to something else).\n-        ZForwardingTableEntry entry = first(from_index, cursor);\n-        while (!entry.is_empty()) {\n-            if (entry.from_index() == from_index) {\n-                \/\/ Match found, return matching entry\n-                return entry;\n-            }\n-\n-            entry = next(cursor);\n-        }\n-\n-        \/\/ Match not found, return empty entry\n-        return entry;\n-    }\n-\n-    ZForwardingTableEntry find(long from_index) {\n-        ZForwardingTableCursor dummy = new ZForwardingTableCursor();\n-        return find(from_index, dummy);\n-    }\n-\n-    void dump() {\n-        long s = size();\n-        long count = 0;\n-        System.out.println(\"Dumping ZForwardingTable[\" + s + \"]:\");\n-        ZForwardingTableCursor cursor = new ZForwardingTableCursor();\n-        for (long i = 0; i < s; i++) {\n-            cursor._value = i;\n-            ZForwardingTableEntry entry = at(cursor);\n-            if (!entry.is_empty()) {\n-                long hash = ZHash.uint32_to_uint32(entry.from_index());\n-                System.out.println(i + \" \" + count + \" \" + entry + \" hash: \" + hash + \" masked_hash: \" + (hash & (s - 1)));\n-                count++;\n-            }\n-        }\n+    public ZForwarding get(Address o) {\n+        return VMObjectFactory.newObject(ZForwarding.class, map().get(ZAddress.offset(o)));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwardingTable.java","additions":8,"deletions":65,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -105,0 +105,8 @@\n+    public static long ZAddressMetadataMask() {\n+        return instance().ZAddressMetadataMask();\n+    }\n+\n+    public static long ZAddressMetadataFinalizable() {\n+        return instance().ZAddressMetadataFinalizable();\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobals.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    private static AddressField ZAddressMetadataMaskField;\n+    private static AddressField ZAddressMetadataFinalizableField;\n@@ -54,0 +56,2 @@\n+        ZAddressMetadataMaskField = type.getAddressField(\"_ZAddressMetadataMask\");\n+        ZAddressMetadataFinalizableField = type.getAddressField(\"_ZAddressMetadataFinalizable\");\n@@ -77,0 +81,8 @@\n+    long ZAddressMetadataMask() {\n+        return ZAddressMetadataMaskField.getValue(addr).getJLongAt(0);\n+    }\n+\n+    long ZAddressMetadataFinalizable() {\n+        return ZAddressMetadataFinalizableField.getValue(addr).getJLongAt(0);\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobalsForVMStructs.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.AddressField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZGranuleMapForForwarding  extends VMObject {\n+    private static AddressField mapField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ZGranuleMapForForwarding\");\n+\n+        mapField = type.getAddressField(\"_map\");\n+    }\n+\n+    public ZGranuleMapForForwarding(Address addr) {\n+        super(addr);\n+    }\n+\n+    private Address map() {\n+        return mapField.getValue(addr);\n+    }\n+\n+    public long size() {\n+        return ZGlobals.ZAddressOffsetMax >> ZGlobals.ZGranuleSizeShift;\n+    }\n+\n+    private long index_for_offset(long offset) {\n+        long index = offset >>> ZGlobals.ZGranuleSizeShift;\n+\n+        return index;\n+    }\n+\n+    Address at(long index) {\n+        return map().getAddressAt(index * VM.getVM().getAddressSize());\n+    }\n+\n+    Address get(long offset) {\n+        long index = index_for_offset(offset);\n+        return at(index);\n+    }\n+\n+    public class Iterator {\n+        private long next = 0;\n+\n+        boolean hasNext() {\n+            return next < size();\n+        }\n+\n+        Address next() {\n+            if (next >= size()) {\n+                throw new RuntimeException(\"OOIBE\");\n+            }\n+\n+            return at(next++);\n+        }\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGranuleMapForForwarding.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-        key = uint32(key ^ (key >> 12));\n+        key = uint32(key ^ (key >>> 12));\n@@ -36,1 +36,1 @@\n-        key = uint32(key ^ (key >> 4));\n+        key = uint32(key ^ (key >>> 4));\n@@ -38,1 +38,1 @@\n-        key = uint32(key ^ (key >> 16));\n+        key = uint32(key ^ (key >>> 16));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZHash.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+    private static long forwardingTableFieldOffset;\n+    private static long relocateFieldOffset;\n@@ -52,0 +54,2 @@\n+        forwardingTableFieldOffset = type.getAddressField(\"_forwarding_table\").getOffset();\n+        relocateFieldOffset = type.getAddressField(\"_relocate\").getOffset();\n@@ -67,0 +71,8 @@\n+    ZForwardingTable forwardingTable() {\n+        return VMObjectFactory.newObject(ZForwardingTable.class, addr.addOffsetTo(forwardingTableFieldOffset));\n+    }\n+\n+    ZRelocate relocate() {\n+        return VMObjectFactory.newObject(ZRelocate.class, addr.addOffsetTo(relocateFieldOffset));\n+    }\n+\n@@ -83,3 +95,6 @@\n-    Address forward_object(Address addr) {\n-        ZPage page = pageTable().get(addr);\n-        return page.forward_object(addr);\n+    Address relocate_object(Address addr) {\n+        ZForwarding forwarding = forwardingTable().get(addr);\n+        if (forwarding == null) {\n+            return ZAddress.good(addr);\n+        }\n+        return relocate().relocateObject(forwarding, ZAddress.good(addr));\n@@ -88,3 +103,16 @@\n-    Address relocate_object(Address addr) {\n-        ZPage page = pageTable().get(addr);\n-        return page.relocate_object(addr);\n+    public boolean isIn(Address addr) {\n+        if (ZAddress.isIn(addr)) {\n+            ZPage page = pageTable().get(addr);\n+            if (page != null) {\n+                return page.isIn(addr);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Address remapObject(Address o) {\n+        ZForwarding forwarding = forwardingTable().get(addr);\n+        if (forwarding == null) {\n+            return ZAddress.good(o);\n+        }\n+        return relocate().forwardObject(forwarding, ZAddress.good(o));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZHeap.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-        return ZUtils.longToAddress(ZAddress.as_long(oop));\n+        return oop;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZOop.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,0 @@\n-    private static CIntegerField refcountField;\n-    private static long forwardingFieldOffset;\n@@ -63,2 +61,0 @@\n-        refcountField = type.getCIntegerField(\"_refcount\");\n-        forwardingFieldOffset = type.getField(\"_forwarding\").getOffset();\n@@ -87,13 +83,0 @@\n-    private int refcount() {\n-        \/\/ refcount is uint32_t so need to be cautious when using this field.\n-        return refcountField.getJInt(addr);\n-    }\n-\n-    private ZForwardingTable forwarding() {\n-        return VMObjectFactory.newObject(ZForwardingTable.class, addr.addOffsetTo(forwardingFieldOffset));\n-    }\n-\n-    private boolean is_forwarding() {\n-        return forwarding().table() != null;\n-    }\n-\n@@ -101,8 +84,1 @@\n-        return is_active() && seqnum() < ZGlobals.ZGlobalSeqNum();\n-    }\n-\n-    private boolean isPageRelocating() {\n-        assert(is_active());\n-        \/\/ is_forwarding():  Has a (relocation) forwarding table\n-        \/\/ is_relocatable(): Has not been freed yet\n-        return is_forwarding() && is_relocatable();\n+        return seqnum() < ZGlobals.ZGlobalSeqNum();\n@@ -119,25 +95,0 @@\n-    Address forward_object(Address from) {\n-        \/\/ Lookup address in forwarding table\n-        long from_offset = ZAddress.offset(from);\n-        long from_index = (from_offset - start()) >> object_alignment_shift();\n-        ZForwardingTableEntry entry = forwarding().find(from_index);\n-        assert(!entry.is_empty());\n-        assert(entry.from_index() == from_index);\n-\n-        return ZAddress.good(entry.to_offset());\n-    }\n-\n-    Address relocate_object(Address from) {\n-        \/\/ Lookup address in forwarding table\n-        long from_offset = ZAddress.offset(from);\n-        long from_index = (from_offset - start()) >> object_alignment_shift();\n-        ZForwardingTableEntry entry = forwarding().find(from_index);\n-        if (!entry.is_empty() && entry.from_index() == from_index) {\n-          return ZAddress.good(entry.to_offset());\n-        }\n-\n-        \/\/ There's no relocate operation in the SA.\n-        \/\/ Mimic object pinning and return the good view of the from object.\n-        return ZAddress.good(from);\n-    }\n-\n@@ -159,2 +110,4 @@\n-    public boolean is_active() {\n-        return refcount() != 0;\n+    public boolean isIn(Address addr) {\n+        long offset = ZAddress.offset(addr);\n+        \/\/ FIXME: it does not consider the sign.\n+        return (offset >= start()) && (offset < top().asLongValue());\n@@ -176,48 +129,0 @@\n-    private void addNotRelocatedRegions(List<MemRegion> regions) {\n-        MemRegion mr = null;\n-\n-        \/\/ Some objects have already been forwarded to new locations.\n-        long topValue = top().asLongValue();\n-        for (long offsetValue = start(); offsetValue < topValue;) {\n-            Address from = ZAddress.good(ZUtils.longToAddress(offsetValue));\n-\n-            Address to = relocate_object(from);\n-\n-            long byteSize;\n-            try {\n-                byteSize = getObjectSize(to);\n-            } catch (Exception e) {\n-                \/\/ Parsing the ZHeap is inherently unsafe\n-                \/\/ when classes have been unloaded. Dead objects\n-                \/\/ might have stale Klass pointers, and there's\n-                \/\/ no way to get the size of the dead object.\n-                \/\/\n-                \/\/ If possible, run with -XX:-ClassUnloading\n-                \/\/ to ensure that all Klasses are kept alive.\n-                System.err.println(\"Unparsable regions found. Skipping: \"\n-                        + from\n-                        + \" \"\n-                        + from.addOffsetTo(topValue - offsetValue));\n-\n-                \/\/ Can't proceed further. Just return the collected regions.\n-                return;\n-            }\n-\n-            if (from.equals(to)) {\n-                \/\/ Not relocated - add region\n-                if (mr == null) {\n-                    mr = new MemRegion(from, 0 \/* wordSize *\/);\n-                    regions.add(mr);\n-                }\n-\n-                long wordSize = byteSize \/ VM.getVM().getBytesPerWord();\n-                mr.setWordSize(mr.wordSize() + wordSize);\n-            } else {\n-                \/\/ Forwarded somewhere else, split region.\n-                mr = null;\n-            }\n-\n-            offsetValue += byteSize;\n-        }\n-    }\n-\n@@ -225,6 +130,1 @@\n-        List<MemRegion> res = new ArrayList<>();\n-\n-        if (isPageRelocating()) {\n-            addNotRelocatedRegions(res);\n-        } else {\n-            Address start = ZAddress.good(ZUtils.longToAddress(start()));\n+        Address start = ZAddress.good(ZUtils.longToAddress(start()));\n@@ -232,9 +132,6 @@\n-            \/\/ Can't convert top() to a \"good\" address because it might\n-            \/\/ be at the top of the \"offset\" range, and therefore also\n-            \/\/ looks like one of the color bits. Instead use the \"good\"\n-            \/\/ address and add the size.\n-            long size = top().asLongValue() - start();\n-            Address end = start.addOffsetTo(size);\n-\n-            res.add(new MemRegion(start, end));\n-        }\n+        \/\/ Can't convert top() to a \"good\" address because it might\n+        \/\/ be at the top of the \"offset\" range, and therefore also\n+        \/\/ looks like one of the color bits. Instead use the \"good\"\n+        \/\/ address and add the size.\n+        long size = top().asLongValue() - start();\n+        Address end = start.addOffsetTo(size);\n@@ -242,1 +139,1 @@\n-        return res;\n+        return List.of(new MemRegion(start, end));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPage.java","additions":14,"deletions":117,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        return getEntry(o).page();\n+        return VMObjectFactory.newObject(ZPage.class, map().get(VM.getVM().getDebugger().newAddress(ZAddress.offset(o))));\n@@ -172,1 +172,1 @@\n-                return page.is_active();\n+                return page != null;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPageTable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.AddressField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZRelocate  extends VMObject {\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ZRelocate\");\n+    }\n+\n+    public ZRelocate(Address addr) {\n+        super(addr);\n+    }\n+\n+    private long forwardingIndex(ZForwarding forwarding, Address from) {\n+        long fromOffset = ZAddress.offset(from);\n+        return (fromOffset - forwarding.start()) >>> forwarding.objectAlignmentShift();\n+    }\n+\n+    private Address forwardingFind(ZForwarding forwarding, Address from) {\n+        long fromIndex = forwardingIndex(forwarding, from);\n+        ZForwardingEntry entry = forwarding.find(fromIndex);\n+        return entry.populated() ? ZAddress.good(VM.getVM().getDebugger().newAddress(entry.toOffset())) : null;\n+    }\n+\n+    public Address forwardObject(ZForwarding forwarding, Address from) {\n+        return forwardingFind(forwarding, from);\n+    }\n+\n+    public Address relocateObject(ZForwarding forwarding, Address o) {\n+        Address toAddr = forwardingFind(forwarding, o);\n+        if (toAddr != null) {\n+            \/\/ Already relocated.\n+            return toAddr;\n+        } else {\n+            \/\/ Return original address because it is not yet relocated.\n+            return o;\n+        }\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZRelocate.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,2 @@\n-    private static final long MSB = ~0L ^ (~0L >>> 1);\n-\n-    private static Address msbAddress() {\n-        return VM.getVM().getUniverse().heap().start().orWithMask(MSB).andWithMask(MSB);\n+    static Address longToAddress(long value) {\n+        return VM.getVM().getDebugger().newAddress(value);\n@@ -37,5 +35,4 @@\n-    static Address longToAddress(long value) {\n-        \/\/ If the value of an Address becomes 0, null is returned instead of an Address.\n-        \/\/ Start with a one-bit address and as a last step, remove that bit.\n-        Address oneAddress = msbAddress();\n-        return oneAddress.orWithMask(value).xorWithMask(ZAddress.as_long(oneAddress));\n+    static long alignUp(long size, long alignment) {\n+        long mask = alignment - 1;\n+        long adjusted = size + mask;\n+        return adjusted & ~mask;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZUtils.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,6 +32,0 @@\n-serviceability\/sa\/ClhsdbDumpheap.java                         8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id0                       8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id1                       8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id2                       8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id3                       8220624   generic-all\n-serviceability\/sa\/ClhsdbInspect.java                          8220624   generic-all\n@@ -39,2 +33,0 @@\n-serviceability\/sa\/ClhsdbSymbol.java                           8220624   generic-all\n-serviceability\/sa\/TestHeapDumpForInvokeDynamic.java           8220624   generic-all\n@@ -42,2 +34,0 @@\n-serviceability\/sa\/TestJmapCore.java                           8220624   generic-all\n-serviceability\/sa\/TestJmapCoreMetaspace.java                  8267045   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}