{"files":[{"patch":"@@ -1924,2 +1924,2 @@\n-void Assembler::evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1927,1 +1927,0 @@\n-  attributes.set_is_evex_instruction();\n@@ -1929,3 +1928,1 @@\n-  emit_int8((unsigned char)0x1D);\n-  emit_int8((unsigned char)(0xC0 | encode));\n-  emit_int8(imm8);\n+  emit_int24((unsigned char)0x1D, (0xC0 | encode), imm8);\n@@ -1934,2 +1931,2 @@\n-void Assembler::evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n+void Assembler::vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1937,1 +1934,0 @@\n-  attributes.set_is_evex_instruction();\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1161,2 +1161,2 @@\n-  void evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n-  void evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2885,0 +2885,2 @@\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-                        : 2,\n+               f16c     : 1,\n+                        : 1,\n@@ -377,1 +378,2 @@\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/\n@@ -684,0 +686,1 @@\n+  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1685,1 +1685,2 @@\n-      if (!VM_Version::supports_evex() || !VM_Version::supports_avx512vl()) {\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex() &&\n+          !VM_Version::supports_avx512vl()) {\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11310,1 +11310,0 @@\n-  predicate(VM_Version::supports_evex());\n@@ -11313,1 +11312,1 @@\n-  format %{ \"evcvtps2ph $dst,$src\" %}\n+  format %{ \"vcvtps2ph $dst,$src \\t using $tmp as TEMP\"%}\n@@ -11315,1 +11314,1 @@\n-     __ evcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+     __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n@@ -11323,1 +11322,0 @@\n-  predicate(VM_Version::supports_evex());\n@@ -11325,1 +11323,1 @@\n-  format %{ \"evcvtph2ps $dst,$src\" %}\n+  format %{ \"vcvtph2ps $dst,$src\" %}\n@@ -11328,1 +11326,1 @@\n-     __ evcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+     __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -249,5 +249,0 @@\n-\/\/------------------------------Identity---------------------------------------\n-Node* ConvHF2FNode::Identity(PhaseGVN* phase) {\n-  return (in(1)->Opcode() == Op_ConvF2HF) ? in(1)->in(1) : this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+ * @run main\/othervm\/timeout=600 -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16Conversion\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+ * @run main Binary16ConversionNaN\n+ * @run main\/othervm\/timeout=600 -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16ConversionNaN\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -38,1 +39,1 @@\n-  public int TESTSIZE;\n+  public int size;\n@@ -40,13 +41,4 @@\n-  public short[] HFargV1;\n-  public short[] ResHF;\n-  public float[] FargV1;\n-  public float[] ResF;\n-\n-  public final short[] HFspecialVals = {\n-      0, (short)0xffff, (short)0xfc00, 0x7c00, 0x7bff, 0x400\n-  };\n-\n-  public final float[] FspecialVals = {\n-      0.0f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,\n-      Float.MAX_VALUE, Float.MIN_VALUE\n-  };\n+  public short[] f16in;\n+  public short[] f16out;\n+  public float[] fin;\n+  public float[] fout;\n@@ -59,2 +51,2 @@\n-      HFargV1 = new short[TESTSIZE];\n-      ResHF = new short[TESTSIZE];\n+      f16in  = new short[size];\n+      f16out = new short[size];\n@@ -62,2 +54,2 @@\n-      for (; i < HFspecialVals.length; i++) {\n-          HFargV1[i] = HFspecialVals[i];\n+      for (; i < size; i++) {\n+          f16in[i] = Float.floatToFloat16(r.nextFloat());;\n@@ -66,6 +58,2 @@\n-      for (; i < TESTSIZE; i++) {\n-          HFargV1[i] = Float.floatToFloat16(r.nextFloat());;\n-      }\n-\n-      FargV1 = new float[TESTSIZE];\n-      ResF = new float[TESTSIZE];\n+      fin  = new float[size];\n+      fout = new float[size];\n@@ -74,3 +62,0 @@\n-      for (; i < FspecialVals.length; i++) {\n-          FargV1[i] = FspecialVals[i];\n-      }\n@@ -78,2 +63,2 @@\n-      for (; i < TESTSIZE; i++) {\n-          FargV1[i] = Float.float16ToFloat((short)r.nextInt());\n+      for (; i < size; i++) {\n+          fin[i] = Float.float16ToFloat((short)r.nextInt());\n@@ -84,3 +69,3 @@\n-  public void floatToFloat16() {\n-      for (int i = 0; i < TESTSIZE; i++) {\n-          ResHF[i] = Float.floatToFloat16(FargV1[i]);\n+  public void floatToFloat16(Blackhole bh) {\n+      for (int i = 0; i < fin.length; i++) {\n+          f16out[i] = Float.floatToFloat16(fin[i]);\n@@ -88,0 +73,1 @@\n+      bh.consume(f16out);\n@@ -91,3 +77,3 @@\n-  public void float16ToFloat() {\n-      for (int i = 0; i < TESTSIZE; i++) {\n-          ResF[i] = Float.float16ToFloat(HFargV1[i]);\n+  public void float16ToFloat(Blackhole bh) {\n+      for (int i = 0; i < f16in.length; i++) {\n+          fout[i] = Float.float16ToFloat(f16in[i]);\n@@ -95,0 +81,1 @@\n+      bh.consume(fout);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/Fp16ConversionBenchmark.java","additions":22,"deletions":35,"binary":false,"changes":57,"status":"modified"}]}