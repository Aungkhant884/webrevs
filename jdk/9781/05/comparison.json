{"files":[{"patch":"@@ -1924,0 +1924,28 @@\n+void Assembler::vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0x1D, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::vcvtps2ph(Address dst, KRegister mask, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8((unsigned char) 0x1D);\n+  emit_operand(src, dst);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x13, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1160,0 +1160,5 @@\n+  \/\/ Convert Halffloat to Single Precision Floating-Point value\n+  void vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void vcvtps2ph(Address dst, KRegister mask, XMMRegister src, int imm8, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2885,0 +2885,2 @@\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-                        : 2,\n+               f16c     : 1,\n+                        : 1,\n@@ -377,1 +378,2 @@\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/\n@@ -684,0 +686,1 @@\n+  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1683,0 +1683,7 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      if (!VM_Version::supports_f16c() && !(VM_Version::supports_evex() &&\n+          VM_Version::supports_avx512vl())) {\n+        return false;\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -11309,0 +11309,37 @@\n+instruct convF2HF_reg_reg(rRegI dst, regF src, regF tmp) %{\n+  effect(TEMP tmp);\n+  match(Set dst (ConvF2HF src));\n+  ins_cost(125);\n+  format %{ \"vcvtps2ph $dst,$src \\t using $tmp as TEMP\"%}\n+  ins_encode %{\n+     __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+     __ movdl($dst$$Register, $tmp$$XMMRegister);\n+     __ movswl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convF2HF_mem_reg(memory mem, regF src, kReg ktmp, rRegI rtmp) %{\n+  predicate(UseAVX > 2);\n+  effect(TEMP ktmp, TEMP rtmp);\n+  match(Set mem (StoreC mem (ConvF2HF src)));\n+  format %{ \"vcvtps2ph $mem,$src \\t using $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+     __ movl($rtmp$$Register, 0x1);\n+     __ kmovdl($ktmp$$KRegister, $rtmp$$Register);\n+     __ vcvtps2ph($mem$$Address, $ktmp$$KRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, rRegI src) %{\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"vcvtph2ps $dst,$src\" %}\n+  ins_encode %{\n+     __ movdl($dst$$XMMRegister, $src$$Register);\n+     __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+  do_intrinsic(_float16ToFloat,           java_lang_Float,        float16ToFloat_name,      f16_float_signature, F_S)   \\\n+   do_name(     float16ToFloat_name,                             \"float16ToFloat\")                                      \\\n+   do_signature(f16_float_signature,                             \"(S)F\")                                                \\\n+  do_intrinsic(_floatToFloat16,           java_lang_Float,        floatToFloat16_name,      float_f16_signature, F_S)   \\\n+   do_name(     floatToFloat16_name,                             \"floatToFloat16\")                                      \\\n+   do_signature(float_f16_signature,                             \"(F)S\")                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,0 +302,6 @@\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!Matcher::match_rule_supported(Op_ConvHF2F)) return false;\n+    break;\n+  case vmIntrinsics::_floatToFloat16:\n+    if (!Matcher::match_rule_supported(Op_ConvF2HF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+macro(ConvF2HF)\n+macro(ConvHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,15 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvF2HFNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == Type::FLOAT ) return TypeInt::SHORT;\n+  const TypeF *tf = t->is_float_constant();\n+  return TypeInt::make( SharedRuntime::f2hf( tf->getf() ) );\n+}\n+\n+\/\/------------------------------Identity---------------------------------------\n+Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n+  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n+}\n+\n@@ -222,0 +237,12 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvHF2FNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == TypeInt::SHORT ) return Type::FLOAT;\n+  const TypeInt *ti = t->is_int();\n+  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+\n+  return bottom_type();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -103,0 +103,12 @@\n+\/\/------------------------------ConvF2HFNode------------------------------------\n+\/\/ Convert Float to Halffloat\n+class ConvF2HFNode : public Node {\n+  public:\n+  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -130,0 +142,11 @@\n+\/\/------------------------------ConvHF2FNode------------------------------------\n+\/\/ Convert Halffloat to float\n+class ConvHF2FNode : public Node {\n+  public:\n+  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -517,1 +517,3 @@\n-  case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:           return inline_fp_conversions(intrinsic_id());\n@@ -4437,0 +4439,2 @@\n+  case vmIntrinsics::_floatToFloat16:       result = new ConvF2HFNode(arg); break;\n+  case vmIntrinsics::_float16ToFloat:       result = new ConvHF2FNode(arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -273,0 +273,4 @@\n+JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n+  return (jfloat)x;\n+JRT_END\n+\n@@ -306,4 +310,0 @@\n-JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n-  return (jfloat)x;\n-JRT_END\n-\n@@ -450,0 +450,78 @@\n+JRT_LEAF(jshort, SharedRuntime::f2hf(jfloat  x))\n+  jint doppel = SharedRuntime::f2i(x);\n+  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n+  if (g_isnan(x))\n+    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n+\n+  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n+\n+  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n+  if (abs_f >= (65504.0f + 16.0f)) {\n+    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+  }\n+\n+  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n+  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n+    return sign_bit; \/\/ Positive or negative zero\n+  }\n+\n+  jint exp = 0x7f800000 & doppel;\n+\n+  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n+  \/\/ shift value, in addition to 13, to be used in the\n+  \/\/ computations below. Further the (hidden) msb with value 1\n+  \/\/ in f must be involved as well\n+  jint exp_delta = 0;\n+  jint msb = 0x00000000;\n+  if (exp < -14) {\n+    exp_delta = -14 - exp;\n+    exp = -15;\n+    msb = 0x00800000;\n+  }\n+  jint f_signif_bits = doppel & 0x007fffff | msb;\n+\n+  \/\/ Significand bits as if using rounding to zero\n+  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n+\n+  jint lsb = f_signif_bits & (1 << 13 + exp_delta);\n+  jint round  = f_signif_bits & (1 << 12 + exp_delta);\n+  jint sticky = f_signif_bits & ((1 << 12 + exp_delta) - 1);\n+\n+  if (round != 0 && ((lsb | sticky) != 0 )) {\n+    signif_bits++;\n+  }\n+\n+  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+JRT_END\n+\n+JRT_LEAF(jfloat, SharedRuntime::hf2f(jshort x))\n+  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n+  \/\/ 10 significand bits\n+  jint hf_arg = (jint)x;\n+  jint hf_sign_bit = 0x8000 & hf_arg;\n+  jint hf_exp_bits = 0x7c00 & hf_arg;\n+  jint hf_significand_bits = 0x03ff & hf_arg;\n+\n+  jint significand_shift = 13; \/\/difference between float and halffloat precision\n+\n+  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n+\n+  \/\/ Extract halffloat exponent, remove its bias\n+  jint hf_exp = (hf_exp_bits >> 10) - 15;\n+\n+  if (hf_exp == -15) {\n+    \/\/ For subnormal values, return 2^-24 * significand bits\n+    return (sign * (pow(2,-24)) * hf_significand_bits);\n+  }else if (hf_exp == 16) {\n+    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n+           (hf_significand_bits << significand_shift)));\n+  }\n+\n+  \/\/ Add the bias of float exponent and shift\n+  int float_exp_bits = (hf_exp + 127) << 24 - 1;\n+\n+  \/\/ Combine sign, exponent and significand bits\n+  return (jfloat) ((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  static jfloat  hf2f(jshort  x);\n+  static jshort  f2hf(jfloat  x);\n+  static jfloat  i2f (jint    x);\n@@ -134,1 +137,0 @@\n-  static jfloat  i2f (jint    x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -1090,1 +1090,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16Conversion\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+ * @run main Binary16ConversionNaN\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16ConversionNaN\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class Fp16ConversionBenchmark {\n+\n+  @Param({\"2048\"})\n+  public int size;\n+\n+  public short[] f16in;\n+  public short[] f16out;\n+  public float[] fin;\n+  public float[] fout;\n+  public static short f16, s;\n+  public static float f;\n+\n+  @Setup(Level.Trial)\n+  public void BmSetup() {\n+      int i = 0;\n+      Random r = new Random(1024);\n+\n+      f16in  = new short[size];\n+      f16out = new short[size];\n+      f16    = (short) r.nextInt();\n+\n+      for (; i < size; i++) {\n+          f16in[i] = Float.floatToFloat16(r.nextFloat());;\n+      }\n+\n+      fin  = new float[size];\n+      fout = new float[size];\n+      f    = r.nextFloat();\n+\n+      i = 0;\n+\n+      for (; i < size; i++) {\n+          fin[i] = Float.float16ToFloat((short)r.nextInt());\n+      }\n+  }\n+\n+  @Benchmark\n+  public short[] floatToFloat16() {\n+      for (int i = 0; i < fin.length; i++) {\n+          f16out[i] = Float.floatToFloat16(fin[i]);\n+      }\n+      return f16out;\n+  }\n+\n+  @Benchmark\n+  public float[] float16ToFloat() {\n+      for (int i = 0; i < f16in.length; i++) {\n+          fout[i] = Float.float16ToFloat(f16in[i]);\n+      }\n+      return fout;\n+  }\n+\n+  @Benchmark\n+  public float float16ToFloatMemory() {\n+      f = Float.float16ToFloat(f16);\n+      return f;\n+  }\n+\n+  @Benchmark\n+  public short floatToFloat16Memory() {\n+      s = Float.floatToFloat16(f);\n+      return s;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/Fp16ConversionBenchmark.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}