{"files":[{"patch":"@@ -1924,0 +1924,18 @@\n+void Assembler::evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8((unsigned char)0x1D);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x13, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1160,0 +1160,4 @@\n+  \/\/ Convert Halffloat to Single Precision Floating-Point value\n+  void evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1683,0 +1683,6 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      if (!VM_Version::supports_evex() || !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -11309,0 +11309,25 @@\n+instruct convF2HF_reg_reg(rRegI dst, regF src, regF tmp) %{\n+  predicate(VM_Version::supports_evex());\n+  effect(TEMP tmp);\n+  match(Set dst (ConvF2HF src));\n+  format %{ \"evcvtps2ph $dst,$src\" %}\n+  ins_encode %{\n+     __ evcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+     __ movdl($dst$$Register, $tmp$$XMMRegister);\n+     __ movswl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, rRegI src) %{\n+  predicate(VM_Version::supports_evex());\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"evcvtph2ps $dst,$src\" %}\n+  ins_encode %{\n+     __ movdl($dst$$XMMRegister, $src$$Register);\n+     __ evcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+  do_intrinsic(_float16ToFloat,           java_lang_Float,        float16ToFloat_name,      f16_float_signature, F_S)   \\\n+   do_name(     float16ToFloat_name,                             \"float16ToFloat\")                                      \\\n+   do_signature(f16_float_signature,                             \"(S)F\")                                                \\\n+  do_intrinsic(_floatToFloat16,           java_lang_Float,        floatToFloat16_name,      float_f16_signature, F_S)   \\\n+   do_name(     floatToFloat16_name,                             \"floatToFloat16\")                                      \\\n+   do_signature(float_f16_signature,                             \"(F)S\")                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,0 +302,6 @@\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!Matcher::match_rule_supported(Op_ConvHF2F)) return false;\n+    break;\n+  case vmIntrinsics::_floatToFloat16:\n+    if (!Matcher::match_rule_supported(Op_ConvF2HF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+macro(ConvF2HF)\n+macro(ConvHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,15 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvF2HFNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == Type::FLOAT ) return TypeInt::SHORT;\n+  const TypeF *tf = t->is_float_constant();\n+  return TypeInt::make( SharedRuntime::f2hf( tf->getf() ) );\n+}\n+\n+\/\/------------------------------Identity---------------------------------------\n+Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n+  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n+}\n+\n@@ -222,0 +237,17 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvHF2FNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == TypeInt::SHORT ) return Type::FLOAT;\n+  const TypeInt *ti = t->is_int();\n+  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+\n+  return bottom_type();\n+}\n+\n+\/\/------------------------------Identity---------------------------------------\n+Node* ConvHF2FNode::Identity(PhaseGVN* phase) {\n+  return (in(1)->Opcode() == Op_ConvF2HF) ? in(1)->in(1) : this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -103,0 +103,12 @@\n+\/\/------------------------------ConvF2HFNode------------------------------------\n+\/\/ Convert Float to Halffloat\n+class ConvF2HFNode : public Node {\n+  public:\n+  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -130,0 +142,12 @@\n+\/\/------------------------------ConvHF2FNode------------------------------------\n+\/\/ Convert Halffloat to float\n+class ConvHF2FNode : public Node {\n+  public:\n+  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -517,1 +517,3 @@\n-  case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:           return inline_fp_conversions(intrinsic_id());\n@@ -4437,0 +4439,2 @@\n+  case vmIntrinsics::_floatToFloat16:       result = new ConvF2HFNode(arg); break;\n+  case vmIntrinsics::_float16ToFloat:       result = new ConvHF2FNode(arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -273,0 +273,4 @@\n+JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n+  return (jfloat)x;\n+JRT_END\n+\n@@ -306,4 +310,0 @@\n-JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n-  return (jfloat)x;\n-JRT_END\n-\n@@ -450,0 +450,78 @@\n+JRT_LEAF(jshort, SharedRuntime::f2hf(jfloat  x))\n+  jint doppel = SharedRuntime::f2i(x);\n+  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n+  if (g_isnan(x))\n+    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n+\n+  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n+\n+  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n+  if (abs_f >= (65504.0f + 16.0f)) {\n+    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+  }\n+\n+  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n+  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n+    return sign_bit; \/\/ Positive or negative zero\n+  }\n+\n+  jint exp = 0x7f800000 & doppel;\n+\n+  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n+  \/\/ shift value, in addition to 13, to be used in the\n+  \/\/ computations below. Further the (hidden) msb with value 1\n+  \/\/ in f must be involved as well\n+  jint exp_delta = 0;\n+  jint msb = 0x00000000;\n+  if (exp < -14) {\n+    exp_delta = -14 - exp;\n+    exp = -15;\n+    msb = 0x00800000;\n+  }\n+  jint f_signif_bits = doppel & 0x007fffff | msb;\n+\n+  \/\/ Significand bits as if using rounding to zero\n+  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n+\n+  jint lsb = f_signif_bits & (1 << 13 + exp_delta);\n+  jint round  = f_signif_bits & (1 << 12 + exp_delta);\n+  jint sticky = f_signif_bits & ((1 << 12 + exp_delta) - 1);\n+\n+  if (round != 0 && ((lsb | sticky) != 0 )) {\n+    signif_bits++;\n+  }\n+\n+  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+JRT_END\n+\n+JRT_LEAF(jfloat, SharedRuntime::hf2f(jshort x))\n+  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n+  \/\/ 10 significand bits\n+  jint hf_arg = (jint)x;\n+  jint hf_sign_bit = 0x8000 & hf_arg;\n+  jint hf_exp_bits = 0x7c00 & hf_arg;\n+  jint hf_significand_bits = 0x03ff & hf_arg;\n+\n+  jint significand_shift = 13; \/\/difference between float and halffloat precision\n+\n+  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n+\n+  \/\/ Extract halffloat exponent, remove its bias\n+  jint hf_exp = (hf_exp_bits >> 10) - 15;\n+\n+  if (hf_exp == -15) {\n+    \/\/ For subnormal values, return 2^-24 * significand bits\n+    return (sign * (pow(2,-24)) * hf_significand_bits);\n+  }else if (hf_exp == 16) {\n+    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n+           (hf_significand_bits << significand_shift)));\n+  }\n+\n+  \/\/ Add the bias of float exponent and shift\n+  int float_exp_bits = (hf_exp + 127) << 24 - 1;\n+\n+  \/\/ Combine sign, exponent and significand bits\n+  return (jfloat) ((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  static jfloat  hf2f(jshort  x);\n+  static jshort  f2hf(jfloat  x);\n+  static jfloat  i2f (jint    x);\n@@ -134,1 +137,0 @@\n-  static jfloat  i2f (jint    x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -1090,1 +1090,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/\/\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.java.math;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class Fp16ConversionBenchmark {\n+\n+  @Param({\"2048\"})\n+  public int TESTSIZE;\n+\n+  public short[] HFargV1;\n+  public short[] ResHF;\n+  public float[] FargV1;\n+  public float[] ResF;\n+\n+  public final short[] HFspecialVals = {\n+      0, (short)0xffff, (short)0xfc00, 0x7c00, 0x7bff, 0x400\n+  };\n+\n+  public final float[] FspecialVals = {\n+      0.0f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,\n+      Float.MAX_VALUE, Float.MIN_VALUE\n+  };\n+\n+  @Setup(Level.Trial)\n+  public void BmSetup() {\n+      int i = 0;\n+      Random r = new Random(1024);\n+\n+      HFargV1 = new short[TESTSIZE];\n+      ResHF = new short[TESTSIZE];\n+\n+      for (; i < HFspecialVals.length; i++) {\n+          HFargV1[i] = HFspecialVals[i];\n+      }\n+\n+      for (; i < TESTSIZE; i++) {\n+          HFargV1[i] = Float.floatToFloat16(r.nextFloat());;\n+      }\n+\n+      FargV1 = new float[TESTSIZE];\n+      ResF = new float[TESTSIZE];\n+\n+      i = 0;\n+      for (; i < FspecialVals.length; i++) {\n+          FargV1[i] = FspecialVals[i];\n+      }\n+\n+      for (; i < TESTSIZE; i++) {\n+          FargV1[i] = Float.float16ToFloat((short)r.nextInt());\n+      }\n+  }\n+\n+  @Benchmark\n+  public void floatToFloat16() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResHF[i] = Float.floatToFloat16(FargV1[i]);\n+      }\n+  }\n+\n+  @Benchmark\n+  public void float16ToFloat() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResF[i] = Float.float16ToFloat(HFargV1[i]);\n+      }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/Fp16ConversionBenchmark.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}