{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import sun.invoke.util.ValueConversions;\n@@ -36,3 +35,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n@@ -64,16 +60,0 @@\n-    static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {\n-        \/\/ for some type signatures, there exist pre-defined concrete BMH classes\n-        try {\n-            return switch (xtype) {\n-                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n-                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n-            };\n-        } catch (Throwable t) {\n-            throw uncaughtException(t);\n-        }\n-    }\n-\n@@ -359,1 +339,2 @@\n-            assert(args.size() == transform.getMethodType().parameterCount());\n+            MethodType tType = transform.getMethodType();\n+            assert(args.size() == tType.parameterCount());\n@@ -363,1 +344,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF);\n+                assert(tType.parameterCount() == MH_AND_LF);\n@@ -365,1 +346,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);\n+                assert(tType.parameterCount() == MH_AND_LF+1);\n@@ -367,1 +348,1 @@\n-                assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());\n+                assert(tType.parameterType(MH_AND_LF) == type.basicTypeClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+            MethodType tmt = tm.getMethodType();\n@@ -333,1 +334,1 @@\n-            Collections.addAll(args, tm.getParameterTypes());\n+            Collections.addAll(args, tmt.ptypes());\n@@ -336,1 +337,1 @@\n-            return MethodType.methodType(tm.getReturnType(), helperArgs);\n+            return MethodType.methodType(tmt.returnType(), helperArgs);\n@@ -435,1 +436,1 @@\n-                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().parameterArray());\n+                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().ptypes());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-        return member.getReturnType().cast(obj);\n+        return member.getMethodType().returnType().cast(obj);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-        for (Class<?> ptype : mtype.parameterArray())\n+        for (Class<?> ptype : mtype.ptypes())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,10 +367,0 @@\n-    private static Name[] buildNames(Name[] formals, Name[] temps, Name result) {\n-        int arity = formals.length;\n-        int length = arity + temps.length + (result == null ? 0 : 1);\n-        Name[] names = Arrays.copyOf(formals, length);\n-        System.arraycopy(temps, 0, names, arity, temps.length);\n-        if (result != null)\n-            names[length - 1] = result;\n-        return names;\n-    }\n-\n@@ -1341,0 +1331,2 @@\n+        private static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1347,1 +1339,1 @@\n-            assert(this.index == index);\n+            assert(this.index == index && typesMatch(function, this.arguments));\n@@ -1368,0 +1360,9 @@\n+        Name(NamedFunction function) {\n+            this(-1, function.returnType(), function, EMPTY_ARGS);\n+        }\n+        Name(NamedFunction function, Object arg) {\n+            this(-1, function.returnType(), function, new Object[] { arg });\n+        }\n+        Name(NamedFunction function, Object arg0, Object arg1) {\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+        }\n@@ -1369,2 +1370,1 @@\n-            this(-1, function.returnType(), function, arguments = Arrays.copyOf(arguments, arguments.length, Object[].class));\n-            assert(typesMatch(function, arguments));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n@@ -1537,0 +1537,4 @@\n+            if (arguments == null) {\n+                assert(function == null);\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import sun.invoke.util.BytecodeDescriptor;\n@@ -36,4 +35,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -77,1 +72,1 @@\n-};\n+}\n@@ -201,10 +196,0 @@\n-    \/** Utility method producing the parameter types of the method type. *\/\n-    public Class<?>[] getParameterTypes() {\n-        return getMethodType().parameterArray();\n-    }\n-\n-    \/** Utility method producing the return type of the method type. *\/\n-    public Class<?> getReturnType() {\n-        return getMethodType().returnType();\n-    }\n-\n@@ -252,16 +237,0 @@\n-    \/** Utility method to produce the signature of this member,\n-     *  used within the class file format to describe its type.\n-     *\/\n-    public String getSignature() {\n-        if (type == null) {\n-            expandFromVM();\n-            if (type == null) {\n-                return null;\n-            }\n-        }\n-        if (isInvocable())\n-            return BytecodeDescriptor.unparse(getMethodType());\n-        else\n-            return BytecodeDescriptor.unparse(getFieldType());\n-    }\n-\n@@ -359,2 +328,1 @@\n-        assert(getReferenceKind() == oldKind);\n-        assert(MethodHandleNatives.refKindIsValid(refKind));\n+        assert(getReferenceKind() == oldKind && MethodHandleNatives.refKindIsValid(refKind));\n@@ -365,2 +333,2 @@\n-    private boolean testFlags(int mask, int value) {\n-        return (flags & mask) == value;\n+    private boolean matchingFlagsSet(int mask, int flags) {\n+        return (this.flags & mask) == flags;\n@@ -368,2 +336,2 @@\n-    private boolean testAllFlags(int mask) {\n-        return testFlags(mask, mask);\n+    private boolean allFlagsSet(int flags) {\n+        return (this.flags & flags) == flags;\n@@ -371,2 +339,2 @@\n-    private boolean testAnyFlags(int mask) {\n-        return !testFlags(mask, 0);\n+    private boolean anyFlagSet(int flags) {\n+        return (this.flags & flags) != 0;\n@@ -380,2 +348,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == MethodHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == MethodHandle.class) {\n@@ -387,7 +354,4 @@\n-        switch (name) {\n-        case \"invoke\":\n-        case \"invokeExact\":\n-            return true;\n-        default:\n-            return false;\n-        }\n+        return switch (name) {\n+            case \"invoke\", \"invokeExact\" -> true;\n+            default -> false;\n+        };\n@@ -398,2 +362,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == VarHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == VarHandle.class) {\n@@ -460,1 +423,1 @@\n-        return testAllFlags(IS_METHOD | BRIDGE);\n+        return allFlagsSet(IS_METHOD | BRIDGE);\n@@ -464,1 +427,1 @@\n-        return testAllFlags(VARARGS) && isInvocable();\n+        return allFlagsSet(VARARGS) && isInvocable();\n@@ -468,1 +431,1 @@\n-        return testAllFlags(SYNTHETIC);\n+        return allFlagsSet(SYNTHETIC);\n@@ -488,2 +451,0 @@\n-    static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;\n-    static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;\n@@ -493,5 +454,1 @@\n-        return testAnyFlags(IS_INVOCABLE);\n-    }\n-    \/** Utility method to query whether this member is a method, constructor, or field. *\/\n-    public boolean isFieldOrMethod() {\n-        return testAnyFlags(IS_FIELD_OR_METHOD);\n+        return anyFlagSet(IS_INVOCABLE);\n@@ -501,1 +458,1 @@\n-        return testAllFlags(IS_METHOD);\n+        return allFlagsSet(IS_METHOD);\n@@ -505,1 +462,1 @@\n-        return testAllFlags(IS_CONSTRUCTOR);\n+        return allFlagsSet(IS_CONSTRUCTOR);\n@@ -509,1 +466,1 @@\n-        return testAllFlags(IS_FIELD);\n+        return allFlagsSet(IS_FIELD);\n@@ -513,1 +470,1 @@\n-        return testAllFlags(IS_TYPE);\n+        return allFlagsSet(IS_TYPE);\n@@ -517,1 +474,1 @@\n-        return !testAnyFlags(ALL_ACCESS);\n+        return !anyFlagSet(ALL_ACCESS);\n@@ -521,1 +478,1 @@\n-        return testAllFlags(CALLER_SENSITIVE);\n+        return allFlagsSet(CALLER_SENSITIVE);\n@@ -524,7 +481,2 @@\n-    public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }\n-\n-    \/** Utility method to query whether this member is accessible from a given lookup class. *\/\n-    public boolean isAccessibleFrom(Class<?> lookupClass) {\n-        int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);\n-        return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,\n-                                               lookupClass, null, mode);\n+    public boolean isTrustedFinalField() {\n+        return allFlagsSet(TRUSTED_FINAL | IS_FIELD);\n@@ -550,2 +502,1 @@\n-        assert(testAnyFlags(ALL_KINDS));\n-        assert(this.resolution == null);  \/\/ nobody should have touched this yet\n+        assert(anyFlagSet(ALL_KINDS) && this.resolution == null);  \/\/ nobody should have touched this yet\n@@ -571,3 +522,3 @@\n-        assert((flags & RECOGNIZED_MODIFIERS) == 0);\n-        assert((mods & ~RECOGNIZED_MODIFIERS) == 0);\n-        assert((refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n+        assert((flags & RECOGNIZED_MODIFIERS) == 0\n+                && (mods & ~RECOGNIZED_MODIFIERS) == 0\n+                && (refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n@@ -610,1 +561,1 @@\n-        assert(isResolved() && this.clazz != null);\n+        assert(isResolved());\n@@ -652,1 +603,0 @@\n-        byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n@@ -654,9 +604,6 @@\n-        byte newRefKind = refKind;\n-        MemberName result = this;\n-        switch (refKind) {\n-        case REF_invokeInterface:\n-        case REF_invokeVirtual:\n-        case REF_invokeSpecial:\n-            newRefKind = normalVirtual;\n-            break;\n-        }\n+        byte newRefKind = switch (refKind) {\n+            case REF_invokeInterface,\n+                 REF_invokeVirtual,\n+                 REF_invokeSpecial -> clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n+            default -> refKind;\n+        };\n@@ -665,1 +612,1 @@\n-        result = clone().changeReferenceKind(newRefKind, refKind);\n+        MemberName result = clone().changeReferenceKind(newRefKind, refKind);\n@@ -685,0 +632,4 @@\n+    static {\n+        \/\/ the following MemberName constructor relies on these ranges matching up\n+        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n+    }\n@@ -693,1 +644,0 @@\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n@@ -706,7 +656,1 @@\n-    public MemberName asSetter() {\n-        byte refKind = getReferenceKind();\n-        assert(MethodHandleNatives.refKindIsGetter(refKind));\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n-        byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));\n-        return clone().changeReferenceKind(setterRefKind, refKind);\n-    }\n+\n@@ -847,5 +791,0 @@\n-    \/** Query whether this member name is resolved to a non-static, non-final method.\n-     *\/\n-    public boolean hasReceiverTypeDispatch() {\n-        return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());\n-    }\n@@ -933,1 +872,1 @@\n-        message = message + \": \"+ toString();\n+        message = message + \": \" + this;\n@@ -968,1 +907,1 @@\n-        String message = message() + \": \"+ toString();\n+        String message = message() + \": \" + this;\n@@ -995,3 +934,1 @@\n-        static Factory INSTANCE = new Factory();\n-\n-        private static int ALLOWED_FLAGS = ALL_KINDS;\n+        static final Factory INSTANCE = new Factory();\n@@ -999,60 +936,0 @@\n-        \/\/\/ Queries\n-        List<MemberName> getMembers(Class<?> defc,\n-                String matchName, Object matchType,\n-                int matchFlags, Class<?> lookupClass) {\n-            matchFlags &= ALLOWED_FLAGS;\n-            String matchSig = null;\n-            if (matchType != null) {\n-                matchSig = BytecodeDescriptor.unparse(matchType);\n-                if (matchSig.startsWith(\"(\"))\n-                    matchFlags &= ~(ALL_KINDS & ~IS_INVOCABLE);\n-                else\n-                    matchFlags &= ~(ALL_KINDS & ~IS_FIELD);\n-            }\n-            final int BUF_MAX = 0x2000;\n-            int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;\n-            MemberName[] buf = newMemberBuffer(len1);\n-            int totalCount = 0;\n-            ArrayList<MemberName[]> bufs = null;\n-            int bufCount = 0;\n-            for (;;) {\n-                bufCount = MethodHandleNatives.getMembers(defc,\n-                        matchName, matchSig, matchFlags,\n-                        lookupClass,\n-                        totalCount, buf);\n-                if (bufCount <= buf.length) {\n-                    if (bufCount < 0)  bufCount = 0;\n-                    totalCount += bufCount;\n-                    break;\n-                }\n-                \/\/ JVM returned to us with an intentional overflow!\n-                totalCount += buf.length;\n-                int excess = bufCount - buf.length;\n-                if (bufs == null)  bufs = new ArrayList<>(1);\n-                bufs.add(buf);\n-                int len2 = buf.length;\n-                len2 = Math.max(len2, excess);\n-                len2 = Math.max(len2, totalCount \/ 4);\n-                buf = newMemberBuffer(Math.min(BUF_MAX, len2));\n-            }\n-            ArrayList<MemberName> result = new ArrayList<>(totalCount);\n-            if (bufs != null) {\n-                for (MemberName[] buf0 : bufs) {\n-                    Collections.addAll(result, buf0);\n-                }\n-            }\n-            for (int i = 0; i < bufCount; i++) {\n-                result.add(buf[i]);\n-            }\n-            \/\/ Signature matching is not the same as type matching, since\n-            \/\/ one signature might correspond to several types.\n-            \/\/ So if matchType is a Class or MethodType, refilter the results.\n-            if (matchType != null && matchType != matchSig) {\n-                for (Iterator<MemberName> it = result.iterator(); it.hasNext();) {\n-                    MemberName m = it.next();\n-                    if (!matchType.equals(m.getType()))\n-                        it.remove();\n-                }\n-            }\n-            return result;\n-        }\n@@ -1134,64 +1011,0 @@\n-        \/** Return a list of all methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getMethods(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of matching methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned methods will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                String name, MethodType type, Class<?> lookupClass) {\n-            int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all constructors defined by the given class.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getConstructors(Class<?> defc, Class<?> lookupClass) {\n-            return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getFields(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned fields will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                String name, Class<?> type, Class<?> lookupClass) {\n-            int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all nested types defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getNestedTypes(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, null, null, matchFlags, lookupClass);\n-        }\n-        private static MemberName[] newMemberBuffer(int length) {\n-            MemberName[] buf = new MemberName[length];\n-            \/\/ fill the buffer with dummy structs for the JVM to fill in\n-            for (int i = 0; i < length; i++)\n-                buf[i] = new MemberName();\n-            return buf;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":46,"deletions":233,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -1008,1 +1008,2 @@\n-        MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,\n+        MethodType type = MethodType.methodType(method.getMethodType().returnType(),\n+                                                UnsupportedOperationException.class,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        for (Class<?> pType : type.parameterArray()) {\n+        for (Class<?> pType : type.ptypes()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,4 +116,0 @@\n-    public static String unparse(MethodType type) {\n-        return unparseMethod(type.returnType(), type.parameterArray());\n-    }\n-\n@@ -124,1 +120,1 @@\n-            return unparse((MethodType) type);\n+            return ((MethodType) type).toMethodDescriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,58 +345,0 @@\n-    static void empty() {\n-    }\n-\n-    static Object zeroObject() {\n-        return null;\n-    }\n-\n-    static int zeroInteger() {\n-        return 0;\n-    }\n-\n-    static long zeroLong() {\n-        return 0;\n-    }\n-\n-    static float zeroFloat() {\n-        return 0;\n-    }\n-\n-    static double zeroDouble() {\n-        return 0;\n-    }\n-\n-    private static final WrapperCache[] CONSTANT_FUNCTIONS = newWrapperCaches(2);\n-\n-    public static MethodHandle zeroConstantFunction(Wrapper wrap) {\n-        WrapperCache cache = CONSTANT_FUNCTIONS[0];\n-        MethodHandle mh = cache.get(wrap);\n-        if (mh != null) {\n-            return mh;\n-        }\n-        \/\/ slow path\n-        MethodType type = MethodType.methodType(wrap.primitiveType());\n-        switch (wrap) {\n-            case VOID:\n-                mh = Handles.EMPTY;\n-                break;\n-            case OBJECT:\n-            case INT: case LONG: case FLOAT: case DOUBLE:\n-                try {\n-                    mh = IMPL_LOOKUP.findStatic(THIS_CLASS, \"zero\"+wrap.wrapperSimpleName(), type);\n-                } catch (ReflectiveOperationException ex) {\n-                    mh = null;\n-                }\n-                break;\n-        }\n-        if (mh != null) {\n-            return cache.put(wrap, mh);\n-        }\n-\n-        \/\/ use zeroInt and cast the result\n-        if (wrap.isSubwordOrInt() && wrap != Wrapper.INT) {\n-            mh = MethodHandles.explicitCastArguments(zeroConstantFunction(Wrapper.INT), type);\n-            return cache.put(wrap, mh);\n-        }\n-        throw new IllegalArgumentException(\"cannot find zero constant for \" + wrap);\n-    }\n-\n@@ -404,1 +346,1 @@\n-        static final MethodHandle CAST_REFERENCE, IGNORE, EMPTY;\n+        static final MethodHandle IGNORE;\n@@ -409,1 +351,0 @@\n-                CAST_REFERENCE = IMPL_LOOKUP.findVirtual(Class.class, \"cast\", idType);\n@@ -411,1 +352,0 @@\n-                EMPTY = IMPL_LOOKUP.findStatic(THIS_CLASS, \"empty\", ignoreType.dropParameterTypes(0, 1));\n@@ -422,4 +362,0 @@\n-    \/** Return a method that casts its second argument (an Object) to the given type (a Class). *\/\n-    public static MethodHandle cast() {\n-        return Handles.CAST_REFERENCE;\n-    }\n@@ -676,3 +612,0 @@\n-    private static InternalError newInternalError(Throwable cause) {\n-        return new InternalError(cause);\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/ValueConversions.java","additions":2,"deletions":69,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -137,24 +137,0 @@\n-    @Test\n-    public void testCast() throws Throwable {\n-        Class<?>[] types = { Object.class, Serializable.class, String.class, Number.class, Integer.class };\n-        Object[] objects = { new Object(), Boolean.FALSE,      \"hello\",      (Long)12L,    (Integer)6    };\n-        for (Class<?> dst : types) {\n-            MethodHandle caster = ValueConversions.cast().bindTo(dst);\n-            assertEquals(caster.type(), MethodHandles.identity(Object.class).type());\n-            for (Object obj : objects) {\n-                Class<?> src = obj.getClass();\n-                boolean canCast = dst.isAssignableFrom(src);\n-                try {\n-                    Object result = caster.invokeExact(obj);\n-                    if (canCast)\n-                        assertEquals(obj, result);\n-                    else\n-                        assertEquals(\"cast should not have succeeded\", dst, obj);\n-                } catch (ClassCastException ex) {\n-                    if (canCast)\n-                        throw ex;\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/sun\/invoke\/util\/ValueConversionsTest.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"}]}