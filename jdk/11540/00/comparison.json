{"files":[{"patch":"@@ -359,1 +359,2 @@\n-            assert(args.size() == transform.getMethodType().parameterCount());\n+            MethodType tType = transform.getMethodType();\n+            assert(args.size() == tType.parameterCount());\n@@ -363,1 +364,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF);\n+                assert(tType.parameterCount() == MH_AND_LF);\n@@ -365,1 +366,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);\n+                assert(tType.parameterCount() == MH_AND_LF+1);\n@@ -367,1 +368,1 @@\n-                assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());\n+                assert(tType.parameterType(MH_AND_LF) == type.basicTypeClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+            MethodType tmt = tm.getMethodType();\n@@ -333,1 +334,1 @@\n-            Collections.addAll(args, tm.getParameterTypes());\n+            Collections.addAll(args, tmt.ptypes());\n@@ -336,1 +337,1 @@\n-            return MethodType.methodType(tm.getReturnType(), helperArgs);\n+            return MethodType.methodType(tmt.returnType(), helperArgs);\n@@ -435,1 +436,1 @@\n-                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().parameterArray());\n+                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().ptypes());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-        return member.getReturnType().cast(obj);\n+        return member.getMethodType().returnType().cast(obj);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-        for (Class<?> ptype : mtype.parameterArray())\n+        for (Class<?> ptype : mtype.ptypes())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,10 +367,0 @@\n-    private static Name[] buildNames(Name[] formals, Name[] temps, Name result) {\n-        int arity = formals.length;\n-        int length = arity + temps.length + (result == null ? 0 : 1);\n-        Name[] names = Arrays.copyOf(formals, length);\n-        System.arraycopy(temps, 0, names, arity, temps.length);\n-        if (result != null)\n-            names[length - 1] = result;\n-        return names;\n-    }\n-\n@@ -1341,0 +1331,2 @@\n+        private static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1347,1 +1339,1 @@\n-            assert(this.index == index);\n+            assert(this.index == index && typesMatch(function, this.arguments));\n@@ -1368,0 +1360,9 @@\n+        Name(NamedFunction function) {\n+            this(-1, function.returnType(), function, EMPTY_ARGS);\n+        }\n+        Name(NamedFunction function, Object arg) {\n+            this(-1, function.returnType(), function, new Object[] { arg });\n+        }\n+        Name(NamedFunction function, Object arg0, Object arg1) {\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+        }\n@@ -1369,2 +1370,1 @@\n-            this(-1, function.returnType(), function, arguments = Arrays.copyOf(arguments, arguments.length, Object[].class));\n-            assert(typesMatch(function, arguments));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n@@ -1537,0 +1537,4 @@\n+            if (arguments == null) {\n+                assert(function == null);\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -77,1 +73,1 @@\n-};\n+}\n@@ -201,10 +197,0 @@\n-    \/** Utility method producing the parameter types of the method type. *\/\n-    public Class<?>[] getParameterTypes() {\n-        return getMethodType().parameterArray();\n-    }\n-\n-    \/** Utility method producing the return type of the method type. *\/\n-    public Class<?> getReturnType() {\n-        return getMethodType().returnType();\n-    }\n-\n@@ -359,2 +345,1 @@\n-        assert(getReferenceKind() == oldKind);\n-        assert(MethodHandleNatives.refKindIsValid(refKind));\n+        assert(getReferenceKind() == oldKind && MethodHandleNatives.refKindIsValid(refKind));\n@@ -365,2 +350,2 @@\n-    private boolean testFlags(int mask, int value) {\n-        return (flags & mask) == value;\n+    private boolean matchingFlagsSet(int mask, int flags) {\n+        return (this.flags & mask) == flags;\n@@ -368,2 +353,2 @@\n-    private boolean testAllFlags(int mask) {\n-        return testFlags(mask, mask);\n+    private boolean allFlagsSet(int flags) {\n+        return (this.flags & flags) == flags;\n@@ -371,2 +356,2 @@\n-    private boolean testAnyFlags(int mask) {\n-        return !testFlags(mask, 0);\n+    private boolean anyFlagSet(int flags) {\n+        return (this.flags & flags) != 0;\n@@ -380,2 +365,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == MethodHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == MethodHandle.class) {\n@@ -387,7 +371,4 @@\n-        switch (name) {\n-        case \"invoke\":\n-        case \"invokeExact\":\n-            return true;\n-        default:\n-            return false;\n-        }\n+        return switch (name) {\n+            case \"invoke\", \"invokeExact\" -> true;\n+            default -> false;\n+        };\n@@ -398,2 +379,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == VarHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == VarHandle.class) {\n@@ -460,1 +440,1 @@\n-        return testAllFlags(IS_METHOD | BRIDGE);\n+        return allFlagsSet(IS_METHOD | BRIDGE);\n@@ -464,1 +444,1 @@\n-        return testAllFlags(VARARGS) && isInvocable();\n+        return allFlagsSet(VARARGS) && isInvocable();\n@@ -468,1 +448,1 @@\n-        return testAllFlags(SYNTHETIC);\n+        return allFlagsSet(SYNTHETIC);\n@@ -488,2 +468,0 @@\n-    static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;\n-    static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;\n@@ -493,5 +471,1 @@\n-        return testAnyFlags(IS_INVOCABLE);\n-    }\n-    \/** Utility method to query whether this member is a method, constructor, or field. *\/\n-    public boolean isFieldOrMethod() {\n-        return testAnyFlags(IS_FIELD_OR_METHOD);\n+        return anyFlagSet(IS_INVOCABLE);\n@@ -501,1 +475,1 @@\n-        return testAllFlags(IS_METHOD);\n+        return allFlagsSet(IS_METHOD);\n@@ -505,1 +479,1 @@\n-        return testAllFlags(IS_CONSTRUCTOR);\n+        return allFlagsSet(IS_CONSTRUCTOR);\n@@ -509,1 +483,1 @@\n-        return testAllFlags(IS_FIELD);\n+        return allFlagsSet(IS_FIELD);\n@@ -513,1 +487,1 @@\n-        return testAllFlags(IS_TYPE);\n+        return allFlagsSet(IS_TYPE);\n@@ -517,1 +491,1 @@\n-        return !testAnyFlags(ALL_ACCESS);\n+        return !anyFlagSet(ALL_ACCESS);\n@@ -521,1 +495,1 @@\n-        return testAllFlags(CALLER_SENSITIVE);\n+        return allFlagsSet(CALLER_SENSITIVE);\n@@ -524,7 +498,2 @@\n-    public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }\n-\n-    \/** Utility method to query whether this member is accessible from a given lookup class. *\/\n-    public boolean isAccessibleFrom(Class<?> lookupClass) {\n-        int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);\n-        return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,\n-                                               lookupClass, null, mode);\n+    public boolean isTrustedFinalField() {\n+        return allFlagsSet(TRUSTED_FINAL | IS_FIELD);\n@@ -550,2 +519,1 @@\n-        assert(testAnyFlags(ALL_KINDS));\n-        assert(this.resolution == null);  \/\/ nobody should have touched this yet\n+        assert(anyFlagSet(ALL_KINDS) && this.resolution == null);  \/\/ nobody should have touched this yet\n@@ -571,3 +539,3 @@\n-        assert((flags & RECOGNIZED_MODIFIERS) == 0);\n-        assert((mods & ~RECOGNIZED_MODIFIERS) == 0);\n-        assert((refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n+        assert((flags & RECOGNIZED_MODIFIERS) == 0\n+                && (mods & ~RECOGNIZED_MODIFIERS) == 0\n+                && (refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n@@ -610,1 +578,1 @@\n-        assert(isResolved() && this.clazz != null);\n+        assert(isResolved());\n@@ -652,1 +620,0 @@\n-        byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n@@ -654,9 +621,6 @@\n-        byte newRefKind = refKind;\n-        MemberName result = this;\n-        switch (refKind) {\n-        case REF_invokeInterface:\n-        case REF_invokeVirtual:\n-        case REF_invokeSpecial:\n-            newRefKind = normalVirtual;\n-            break;\n-        }\n+        byte newRefKind = switch (refKind) {\n+            case REF_invokeInterface,\n+                 REF_invokeVirtual,\n+                 REF_invokeSpecial -> clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n+            default -> refKind;\n+        };\n@@ -665,1 +629,1 @@\n-        result = clone().changeReferenceKind(newRefKind, refKind);\n+        MemberName result = clone().changeReferenceKind(newRefKind, refKind);\n@@ -693,1 +657,1 @@\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n+        \/\/ assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n@@ -706,7 +670,1 @@\n-    public MemberName asSetter() {\n-        byte refKind = getReferenceKind();\n-        assert(MethodHandleNatives.refKindIsGetter(refKind));\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n-        byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));\n-        return clone().changeReferenceKind(setterRefKind, refKind);\n-    }\n+\n@@ -847,5 +805,0 @@\n-    \/** Query whether this member name is resolved to a non-static, non-final method.\n-     *\/\n-    public boolean hasReceiverTypeDispatch() {\n-        return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());\n-    }\n@@ -933,1 +886,1 @@\n-        message = message + \": \"+ toString();\n+        message = message + \": \" + this;\n@@ -968,1 +921,1 @@\n-        String message = message() + \": \"+ toString();\n+        String message = message() + \": \" + this;\n@@ -995,1 +948,1 @@\n-        static Factory INSTANCE = new Factory();\n+        static final Factory INSTANCE = new Factory();\n@@ -997,62 +950,0 @@\n-        private static int ALLOWED_FLAGS = ALL_KINDS;\n-\n-        \/\/\/ Queries\n-        List<MemberName> getMembers(Class<?> defc,\n-                String matchName, Object matchType,\n-                int matchFlags, Class<?> lookupClass) {\n-            matchFlags &= ALLOWED_FLAGS;\n-            String matchSig = null;\n-            if (matchType != null) {\n-                matchSig = BytecodeDescriptor.unparse(matchType);\n-                if (matchSig.startsWith(\"(\"))\n-                    matchFlags &= ~(ALL_KINDS & ~IS_INVOCABLE);\n-                else\n-                    matchFlags &= ~(ALL_KINDS & ~IS_FIELD);\n-            }\n-            final int BUF_MAX = 0x2000;\n-            int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;\n-            MemberName[] buf = newMemberBuffer(len1);\n-            int totalCount = 0;\n-            ArrayList<MemberName[]> bufs = null;\n-            int bufCount = 0;\n-            for (;;) {\n-                bufCount = MethodHandleNatives.getMembers(defc,\n-                        matchName, matchSig, matchFlags,\n-                        lookupClass,\n-                        totalCount, buf);\n-                if (bufCount <= buf.length) {\n-                    if (bufCount < 0)  bufCount = 0;\n-                    totalCount += bufCount;\n-                    break;\n-                }\n-                \/\/ JVM returned to us with an intentional overflow!\n-                totalCount += buf.length;\n-                int excess = bufCount - buf.length;\n-                if (bufs == null)  bufs = new ArrayList<>(1);\n-                bufs.add(buf);\n-                int len2 = buf.length;\n-                len2 = Math.max(len2, excess);\n-                len2 = Math.max(len2, totalCount \/ 4);\n-                buf = newMemberBuffer(Math.min(BUF_MAX, len2));\n-            }\n-            ArrayList<MemberName> result = new ArrayList<>(totalCount);\n-            if (bufs != null) {\n-                for (MemberName[] buf0 : bufs) {\n-                    Collections.addAll(result, buf0);\n-                }\n-            }\n-            for (int i = 0; i < bufCount; i++) {\n-                result.add(buf[i]);\n-            }\n-            \/\/ Signature matching is not the same as type matching, since\n-            \/\/ one signature might correspond to several types.\n-            \/\/ So if matchType is a Class or MethodType, refilter the results.\n-            if (matchType != null && matchType != matchSig) {\n-                for (Iterator<MemberName> it = result.iterator(); it.hasNext();) {\n-                    MemberName m = it.next();\n-                    if (!matchType.equals(m.getType()))\n-                        it.remove();\n-                }\n-            }\n-            return result;\n-        }\n@@ -1134,64 +1025,0 @@\n-        \/** Return a list of all methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getMethods(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of matching methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned methods will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                String name, MethodType type, Class<?> lookupClass) {\n-            int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all constructors defined by the given class.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getConstructors(Class<?> defc, Class<?> lookupClass) {\n-            return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getFields(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned fields will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                String name, Class<?> type, Class<?> lookupClass) {\n-            int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all nested types defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getNestedTypes(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, null, null, matchFlags, lookupClass);\n-        }\n-        private static MemberName[] newMemberBuffer(int length) {\n-            MemberName[] buf = new MemberName[length];\n-            \/\/ fill the buffer with dummy structs for the JVM to fill in\n-            for (int i = 0; i < length; i++)\n-                buf[i] = new MemberName();\n-            return buf;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":43,"deletions":216,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -1008,1 +1008,2 @@\n-        MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,\n+        MethodType type = MethodType.methodType(method.getMethodType().returnType(),\n+                                                UnsupportedOperationException.class,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        for (Class<?> pType : type.parameterArray()) {\n+        for (Class<?> pType : type.ptypes()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        return unparseMethod(type.returnType(), type.parameterArray());\n+        return type.toMethodDescriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}