{"files":[{"patch":"@@ -36,3 +36,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n@@ -64,16 +61,0 @@\n-    static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {\n-        \/\/ for some type signatures, there exist pre-defined concrete BMH classes\n-        try {\n-            return switch (xtype) {\n-                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n-                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n-            };\n-        } catch (Throwable t) {\n-            throw uncaughtException(t);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"}]}