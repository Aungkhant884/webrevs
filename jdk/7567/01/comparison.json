{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,15 +56,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default: while (count-- > 0) {\n-             *to++ = *from++;\n-           }\n-           break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/cpu\/ppc\/copy_ppc.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -151,16 +151,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    while (count-- > 0) {\n-      *to++ = *from++;\n-    }\n-    break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/cpu\/x86\/copy_x86.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,16 +55,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    while (count-- > 0) {\n-      *to++ = *from++;\n-    }\n-    break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/cpu\/zero\/copy_zero.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,15 +53,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default: while (count-- > 0) {\n-             *to++ = *from++;\n-           }\n-           break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/copy_windows_aarch64.hpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -300,0 +301,22 @@\n+ protected:\n+  inline static void shared_disjoint_words_atomic(const HeapWord* from,\n+                                                  HeapWord* to, size_t count) {\n+\n+    switch (count) {\n+    case 8:  Atomic::store(&to[7], Atomic::load(&from[7]));\n+    case 7:  Atomic::store(&to[6], Atomic::load(&from[6]));\n+    case 6:  Atomic::store(&to[5], Atomic::load(&from[5]));\n+    case 5:  Atomic::store(&to[4], Atomic::load(&from[4]));\n+    case 4:  Atomic::store(&to[3], Atomic::load(&from[3]));\n+    case 3:  Atomic::store(&to[2], Atomic::load(&from[2]));\n+    case 2:  Atomic::store(&to[1], Atomic::load(&from[1]));\n+    case 1:  Atomic::store(&to[0], Atomic::load(&from[0]));\n+    case 0:  break;\n+    default:\n+      while (count-- > 0) {\n+        Atomic::store(to++, Atomic::load(from++));\n+      }\n+      break;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/copy.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}