{"files":[{"patch":"@@ -2054,1 +2054,1 @@\n-  class TraceSelfClosure : public AsyncHandshakeClosure {\n+  class TraceSelfClosure : public SelfExecutedHandshakeClosure {\n@@ -2069,1 +2069,1 @@\n-    TraceSelfClosure(JavaThread* self_target) : AsyncHandshakeClosure(\"WB_TraceSelf\"), _self(self_target) {}\n+    TraceSelfClosure(JavaThread* self_target) : SelfExecutedHandshakeClosure(\"WB_TraceSelf\"), _self(self_target) {}\n@@ -2075,1 +2075,1 @@\n-    Handshake::execute(tsc, target);\n+    Handshake::enqueue(tsc, target);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  bool remote_executable()         { return _handshake_cl->remote_executable(); }\n@@ -336,0 +337,1 @@\n+  assert(!hs_cl->is_async(), \"invariant\");\n@@ -342,0 +344,1 @@\n+  assert(!hs_cl->is_async(), \"invariant\");\n@@ -391,1 +394,1 @@\n-void Handshake::execute(AsyncHandshakeClosure* hs_cl, JavaThread* target) {\n+void Handshake::enqueue(AsyncHandshakeClosure* hs_cl, JavaThread* target) {\n@@ -440,2 +443,2 @@\n-static bool non_self_queue_filter(HandshakeOperation* op) {\n-  return !op->is_async();\n+static bool remote_executable_queue_filter(HandshakeOperation* op) {\n+  return op->remote_executable();\n@@ -444,1 +447,1 @@\n-bool HandshakeState::have_non_self_executable_operation() {\n+bool HandshakeState::has_remote_executable_operation() {\n@@ -447,1 +450,1 @@\n-  return _queue.contains(non_self_queue_filter);\n+  return _queue.contains(remote_executable_queue_filter);\n@@ -453,1 +456,1 @@\n-  return _queue.pop(non_self_queue_filter);\n+  return _queue.pop(remote_executable_queue_filter);\n@@ -533,1 +536,1 @@\n-  if (have_non_self_executable_operation()) {\n+  if (has_remote_executable_operation()) {\n@@ -592,1 +595,1 @@\n-  } while (have_non_self_executable_operation());\n+  } while (has_remote_executable_operation());\n@@ -628,1 +631,1 @@\n-class ThreadSelfSuspensionHandshake : public AsyncHandshakeClosure {\n+class ThreadSelfSuspensionHandshake : public SelfExecutedHandshakeClosure {\n@@ -630,1 +633,1 @@\n-  ThreadSelfSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSelfSuspensionHandshake\") {}\n+  ThreadSelfSuspensionHandshake() : SelfExecutedHandshakeClosure(\"ThreadSelfSuspensionHandshake\") {}\n@@ -665,1 +668,1 @@\n-  Handshake::execute(ts, _handshakee);\n+  Handshake::enqueue(ts, _handshakee);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  virtual bool remote_executable()                 { return true; }\n@@ -56,3 +57,12 @@\n-   AsyncHandshakeClosure(const char* name) : HandshakeClosure(name) {}\n-   virtual ~AsyncHandshakeClosure() {}\n-   virtual bool is_async()          { return true; }\n+  AsyncHandshakeClosure(const char* name) : HandshakeClosure(name) {}\n+  virtual ~AsyncHandshakeClosure() {}\n+  virtual bool is_async()          { return true; }\n+};\n+\n+\/\/ A handshake closure that must be executed by the target JavaThread\n+\/\/ itself. It cannot be executed by the initiating thread or the VMThread.\n+class SelfExecutedHandshakeClosure : public AsyncHandshakeClosure {\n+ public:\n+  SelfExecutedHandshakeClosure(const char* name) : AsyncHandshakeClosure(name) {}\n+  virtual ~SelfExecutedHandshakeClosure() {}\n+  virtual bool remote_executable() { return false; }\n@@ -66,1 +76,1 @@\n-  static void execute(AsyncHandshakeClosure*  hs_cl, JavaThread* target);\n+  static void enqueue(AsyncHandshakeClosure*  hs_cl, JavaThread* target);\n@@ -102,1 +112,1 @@\n-  bool have_non_self_executable_operation();\n+  bool has_remote_executable_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}