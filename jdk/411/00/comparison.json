{"files":[{"patch":"@@ -28,4 +28,0 @@\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n@@ -33,0 +29,4 @@\n+import javax.crypto.CipherSpi;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.ShortBufferException;\n@@ -34,0 +34,9 @@\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -644,0 +653,122 @@\n+    @Override\n+    protected int engineDoFinal(ByteBuffer input, ByteBuffer output)\n+            throws ShortBufferException, IllegalBlockSizeException,\n+            BadPaddingException {\n+        return bufferCrypt(input, output, false);\n+    }\n+\n+        \/**\n+     * Implementation for encryption using ByteBuffers. Used for both\n+     * engineUpdate() and engineDoFinal().\n+     *\/\n+    private int bufferCrypt(ByteBuffer input, ByteBuffer output,\n+            boolean isUpdate) throws ShortBufferException,\n+            IllegalBlockSizeException, BadPaddingException {\n+        if ((input == null) || (output == null)) {\n+            throw new NullPointerException\n+                (\"Input and output buffers must not be null\");\n+        }\n+        int inPos = input.position();\n+        int inLimit = input.limit();\n+        int inLen = inLimit - inPos;\n+        if (isUpdate && (inLen == 0)) {\n+            return 0;\n+        }\n+        int outLenNeeded = engineGetOutputSize(inLen);\n+\n+        if (output.remaining() < outLenNeeded) {\n+            throw new ShortBufferException(\"Need at least \" + outLenNeeded\n+                + \" bytes of space in output buffer\");\n+        }\n+\n+        \/\/ detecting input and output buffer overlap may be tricky\n+        \/\/ we can only write directly into output buffer when we\n+        \/\/ are 100% sure it's safe to do so\n+\n+        boolean a1 = input.hasArray();\n+        boolean a2 = output.hasArray();\n+        int total = 0;\n+\n+        if (a1) { \/\/ input has an accessible byte[]\n+            byte[] inArray = input.array();\n+            int inOfs = input.arrayOffset() + inPos;\n+\n+            if (a2) { \/\/ output has an accessible byte[]\n+                byte[] outArray = output.array();\n+                int outPos = output.position();\n+                int outOfs = output.arrayOffset() + outPos;\n+\n+                \/\/ check array address and offsets and use temp output buffer\n+                \/\/ if output offset is larger than input offset and\n+                \/\/ falls within the range of input data\n+                boolean useTempOut = false;\n+                if (inArray == outArray &&\n+                    ((inOfs < outOfs) && (outOfs < inOfs + inLen))) {\n+                    useTempOut = true;\n+                    outArray = new byte[outLenNeeded];\n+                    outOfs = 0;\n+                }\n+                if (isUpdate) {\n+                    total = engineUpdate(inArray, inOfs, inLen, outArray, outOfs);\n+                } else {\n+                    total = engineDoFinal(inArray, inOfs, inLen, outArray, outOfs);\n+                }\n+                if (useTempOut) {\n+                    output.put(outArray, outOfs, total);\n+                } else {\n+                    \/\/ adjust output position manually\n+                    output.position(outPos + total);\n+                }\n+                \/\/ adjust input position manually\n+                input.position(inLimit);\n+            } else { \/\/ output does not have an accessible byte[]\n+                byte[] outArray;\n+                if (isUpdate) {\n+                    outArray = engineUpdate(inArray, inOfs, inLen);\n+                } else {\n+                    outArray = engineDoFinal(inArray, inOfs, inLen);\n+                }\n+                if (outArray != null && outArray.length != 0) {\n+                    output.put(outArray);\n+                    total = outArray.length;\n+                }\n+                \/\/ adjust input position manually\n+                input.position(inLimit);\n+            }\n+        } else { \/\/ input does not have an accessible byte[]\n+            if (core.getMode() == CipherCore.GCM_MODE) {\n+                if (isUpdate) {\n+                    return core.update(input, output);\n+                } else {\n+                    return core.doFinal(input, output);\n+                }\n+            } else {\n+                \/\/ have to assume the worst, since we have no way of determine\n+                \/\/ if input and output overlaps or not\n+                byte[] tempOut = new byte[outLenNeeded];\n+                int outOfs = 0;\n+\n+                byte[] tempIn = new byte[Math.min(4096, inLen)];\n+                do {\n+                    int chunk = Math.min(inLen, tempIn.length);\n+                    if (chunk > 0) {\n+                        input.get(tempIn, 0, chunk);\n+                    }\n+                    int n;\n+                    if (isUpdate || (inLen > chunk)) {\n+                        n = engineUpdate(tempIn, 0, chunk, tempOut, outOfs);\n+                    } else {\n+                        n = engineDoFinal(tempIn, 0, chunk, tempOut, outOfs);\n+                    }\n+                    outOfs += n;\n+                    total += n;\n+                    inLen -= chunk;\n+                } while (inLen > 0);\n+                if (total > 0) {\n+                    output.put(tempOut, 0, total);\n+                }\n+            }\n+        }\n+\n+        return total;\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":135,"deletions":4,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -815,0 +816,7 @@\n+    int update(ByteBuffer src, ByteBuffer dst) throws ShortBufferException {\n+        if (decrypting) {\n+            return cipher.decrypt(src, dst);\n+        }\n+        return cipher.encrypt(src, dst);\n+    }\n+\n@@ -920,1 +928,1 @@\n-        int offset = decrypting ? 0 : outputOffset; \/\/ 0 for decrypting\n+        int offset = outputOffset; \/\/ 0 for decrypting\n@@ -923,1 +931,1 @@\n-        byte[] outWithPadding = null; \/\/ for decrypting only\n+        byte[] internalOutput = null; \/\/ for decrypting only\n@@ -937,3 +945,6 @@\n-            \/\/ create temporary output buffer so that only \"real\"\n-            \/\/ data bytes are passed to user's output buffer.\n-            outWithPadding = new byte[estOutSize];\n+            \/\/ create temporary output buffer if the estimated size is larger\n+            \/\/ than the user-provided buffer.\n+            if (output.length - outputOffset < estOutSize) {\n+                internalOutput = new byte[estOutSize];\n+                offset = 0;\n+            }\n@@ -941,1 +952,1 @@\n-        byte[] outBuffer = decrypting ? outWithPadding : output;\n+        byte[] outBuffer = (internalOutput != null) ? internalOutput : output;\n@@ -957,3 +968,5 @@\n-            System.arraycopy(outWithPadding, 0, output, outputOffset, outLen);\n-            \/\/ decrypt mode. Zero out output data that's not required\n-            Arrays.fill(outWithPadding, (byte) 0x00);\n+            if (internalOutput != null) {\n+                System.arraycopy(internalOutput, 0, output, outputOffset, outLen);\n+                \/\/ decrypt mode. Zero out output data that's not required\n+                Arrays.fill(internalOutput, (byte) 0x00);\n+            }\n@@ -973,1 +986,1 @@\n-    private int unpad(int outLen, byte[] outWithPadding)\n+    private int unpad(int outLen, int off, byte[] outWithPadding)\n@@ -975,1 +988,1 @@\n-        int padStart = padding.unpad(outWithPadding, 0, outLen);\n+        int padStart = padding.unpad(outWithPadding, off, outLen);\n@@ -981,2 +994,1 @@\n-        outLen = padStart;\n-        return outLen;\n+        return padStart - off;\n@@ -1058,1 +1070,1 @@\n-                len = unpad(len, output);\n+                len = unpad(len, outOfs, output);\n@@ -1228,0 +1240,23 @@\n+\n+    \/\/ This must only be used with GCM.\n+    \/\/ If some data has been buffered from an update call, operate on the buffer\n+    \/\/ then run doFinal.\n+    int doFinal(ByteBuffer src, ByteBuffer dst) throws ShortBufferException,\n+        IllegalBlockSizeException, BadPaddingException {\n+        int estOutSize = getOutputSizeByOperation(src.remaining(), true);\n+        if (estOutSize > dst.remaining()) {\n+            throw new ShortBufferException(\"output buffer too small\");\n+        }\n+\n+        if (decrypting) {\n+            if (buffered > 0) {\n+                cipher.decrypt(buffer, 0, buffered, new byte[0], 0);\n+            }\n+            return cipher.decryptFinal(src, dst);\n+        } else {\n+            if (buffered > 0) {\n+                cipher.encrypt(buffer, 0, buffered, new byte[0], 0);\n+            }\n+            return cipher.encryptFinal(src, dst);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CounterMode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -245,0 +246,25 @@\n+\n+    \/*\n+     * ByteBuffer methods should not be accessed as CipherCore and AESCipher\n+     * copy the data to byte arrays.  These methods are to satisfy the compiler.\n+     *\n+     *\/\n+    int encrypt(ByteBuffer src, ByteBuffer dst) {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    };\n+\n+    int decrypt(ByteBuffer src, ByteBuffer dst) {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    };\n+\n+    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, AEADBadTagException,\n+        ShortBufferException {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    };\n+\n+    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, AEADBadTagException,\n+        ShortBufferException {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,99 @@\n-}\n+\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    final int MAX_LEN = 1024;\n+\n+    int doFinal(ByteBuffer src, ByteBuffer dst) throws IllegalBlockSizeException {\n+        int len = src.remaining();\n+        int lastBlockSize = len % AES_BLOCK_SIZE;\n+        try {\n+            update(src, dst);\n+            if (lastBlockSize != 0) {\n+                \/\/ do the last partial block\n+                byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                for (int n = 0; n < lastBlockSize; n++) {\n+                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                }\n+            }\n+        } finally {\n+            reset();\n+        }\n+        return len;\n+    }\n+\n+    int update(ByteBuffer src, ByteBuffer dst) {\n+        long blocksLeft = blocksUntilRollover();\n+        int numOfCompleteBlocks = src.remaining() \/ AES_BLOCK_SIZE;\n+        if (numOfCompleteBlocks >= blocksLeft) {\n+            \/\/ Counter Mode encryption cannot be used because counter will\n+            \/\/ roll over incorrectly. Use GCM-specific code instead.\n+            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            for (int i = 0; i < numOfCompleteBlocks; i++) {\n+                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n+                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                }\n+                GaloisCounterMode.increment32(counter);\n+            }\n+            return numOfCompleteBlocks * AES_BLOCK_SIZE;\n+        }\n+\n+        int len = src.remaining() - (src.remaining() % AES_BLOCK_SIZE);\n+        int processed = len;\n+        byte[] in = new byte[Math.min(MAX_LEN, len)];\n+        while (processed > MAX_LEN) {\n+            src.get(in, 0, MAX_LEN);\n+            encrypt(in, 0, MAX_LEN, in, 0);\n+            dst.put(in, 0, MAX_LEN);\n+            processed -= MAX_LEN;\n+        }\n+        src.get(in, 0, processed);\n+        encrypt(in, 0, processed, in, 0);\n+        dst.put(in, 0, processed);\n+        return len;\n+    }\n+\n+    \/\/ input must be multiples of 128-bit blocks when calling update\n+    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        if (inLen - inOfs > in.length) {\n+            throw new RuntimeException(\"input length out of bound\");\n+        }\n+        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+            throw new RuntimeException(\"input length unsupported\");\n+        }\n+        if (dst.remaining() < inLen) {\n+            throw new RuntimeException(\"output buffer too small\");\n+        }\n+\n+        long blocksLeft = blocksUntilRollover();\n+        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        if (numOfCompleteBlocks >= blocksLeft) {\n+            \/\/ Counter Mode encryption cannot be used because counter will\n+            \/\/ roll over incorrectly. Use GCM-specific code instead.\n+            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            for (int i = 0; i < numOfCompleteBlocks; i++) {\n+                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n+                    int index = (i * AES_BLOCK_SIZE + n);\n+                    dst.put((byte) ((in[inOfs + index] ^ encryptedCntr[n])));\n+                }\n+                GaloisCounterMode.increment32(counter);\n+            }\n+            return inLen;\n+        } else {\n+            int len = inLen % AES_BLOCK_SIZE;\n+            int processed = len;\n+            byte[] out = new byte[Math.min(MAX_LEN, len)];\n+            int offset = inOfs;\n+            while (processed > MAX_LEN) {\n+                encrypt(in, offset, MAX_LEN, out, 0);\n+                dst.get(out, 0, MAX_LEN);\n+                processed -= MAX_LEN;\n+                offset += MAX_LEN;\n+            }\n+            encrypt(in, offset, processed, out, 0);\n+            dst.get(out, 0, processed);\n+            return len;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":100,"deletions":2,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.ByteBuffer;\n@@ -201,0 +202,32 @@\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    static final int MAX_LEN = 1024;\n+\n+    \/\/ Will process as many blocks it can and will leave the remaining.\n+    int update(ByteBuffer src, int inLen) {\n+        if (inLen == 0) {\n+            return 0;\n+        }\n+\n+        inLen -= (inLen % AES_BLOCK_SIZE);\n+        int processed = inLen;\n+        byte[] in = new byte[Math.min(MAX_LEN, inLen)];\n+        while (processed > MAX_LEN ) {\n+            src.get(in, 0, MAX_LEN);\n+            update(in, 0 , MAX_LEN);\n+            processed -= MAX_LEN;\n+        }\n+        src.get(in, 0, processed);\n+        update(in, 0, processed);\n+        return inLen;\n+    }\n+\n+    void doLastBlock(ByteBuffer src, int inLen) {\n+        int processed = update(src, inLen);\n+        if (inLen == processed) {\n+            return;\n+        }\n+        byte[] block = new byte[AES_BLOCK_SIZE];\n+        src.get(block, 0, inLen - processed);\n+        update(block, 0, AES_BLOCK_SIZE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.util.Arrays;\n+import java.nio.ByteBuffer;\n@@ -429,0 +429,43 @@\n+    \/\/ Process en\/decryption all the way to the last block.  It takes both\n+    \/\/ For input it takes the ibuffer which is wrapped in 'buffer' and 'src'\n+    \/\/ from doFinal.\n+    void doLastBlock(ByteBuffer buffer, ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException {\n+\n+        processed = 0;\n+        if (buffer != null && buffer.remaining() > 0) {\n+            \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n+            processed = gctrPAndC.update(buffer, dst);\n+\n+            \/\/ Process the remainder in the buffer\n+            if (buffer.remaining() > 0) {\n+                \/\/ Copy the remainder of the buffer into the extra block\n+                byte[] block = new byte[AES_BLOCK_SIZE];\n+                int over = buffer.remaining();\n+                int len = over;  \/\/ how much is processed by in the extra block\n+                buffer.get(block, 0, over);\n+\n+                \/\/ if src is empty, update the final block and wait for later\n+                \/\/ to finalize operation\n+                if (src.remaining() > 0) {\n+                    \/\/ Fill out block with what is in data\n+                    if (src.remaining() > AES_BLOCK_SIZE - over) {\n+                        src.get(block, over, AES_BLOCK_SIZE - over);\n+                        len += AES_BLOCK_SIZE - over;\n+                    } else {\n+                        \/\/ If the remaining in buffer + data does not fill a\n+                        \/\/ block, complete the ghash operation\n+                        int l = src.remaining();\n+                        src.get(block, over, l);\n+                        len += l;\n+                    }\n+                }\n+                gctrPAndC.update(block, 0, AES_BLOCK_SIZE, dst);\n+                processed += len;\n+            }\n+        }\n+\n+        \/\/ en\/decrypt whatever remains in src.\n+        \/\/ If src has been consumed, this will be a no-op\n+        processed += gctrPAndC.doFinal(src, dst);\n+    }\n@@ -465,0 +508,48 @@\n+    int decrypt(ByteBuffer src, ByteBuffer dst) {\n+        if (src.remaining() > 0) {\n+            byte[] b = new byte[src.remaining()];\n+            src.get(b);\n+            try {\n+                ibuffer.write(b);\n+            } catch (IOException e) {\n+                throw new ProviderException(\"Unable to add remaining input to the buffer\", e);\n+            }\n+        }\n+        return 0;\n+    }\n+\n+\n+    int encrypt(ByteBuffer src, ByteBuffer dst) {\n+        int len = src.remaining();\n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+        ArrayUtil.blockSizeCheck(src.remaining(), blockSize);\n+        checkDataLength(processed, src.remaining());\n+        processAAD();\n+\n+        if (len >= AES_BLOCK_SIZE) {\n+            ByteBuffer data = src.duplicate();\n+            len = gctrPAndC.update(data, dst);\n+        } else {\n+            if (src.remaining() > 0) {\n+                byte[] b = new byte[src.remaining()];\n+                src.get(b);\n+                try {\n+                    ibuffer.write(b);\n+                } catch (IOException e) {\n+                    throw new ProviderException(\n+                        \"Unable to add remaining input to the buffer\", e);\n+                }\n+            }\n+            return 0;\n+        }\n+\n+        processed += len;\n+        ghashAllToS.update(src, len);\n+        return len;\n+    }\n+\n+\n+\n@@ -497,3 +588,2 @@\n-        byte[] lengthBlock =\n-            getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(lengthBlock);\n+        byte[] block = getLengthBlock(sizeOfAAD, processed);\n+        ghashAllToS.update(block);\n@@ -501,1 +591,3 @@\n-        byte[] sOut = new byte[s.length];\n+        if (tagLenBytes > block.length) {\n+            block = new byte[tagLenBytes];\n+        }\n@@ -503,1 +595,1 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);\n+        gctrForSToTag.doFinal(s, 0, s.length, block, 0);\n@@ -505,1 +597,1 @@\n-        System.arraycopy(sOut, 0, out, (outOfs + len), tagLenBytes);\n+        System.arraycopy(block, 0, out, (outOfs + len), tagLenBytes);\n@@ -509,0 +601,37 @@\n+    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, ShortBufferException {\n+        int len = src.remaining();\n+        dst.mark();\n+        if (len > MAX_BUF_SIZE - tagLenBytes) {\n+            throw new ShortBufferException\n+                (\"Can't fit both data and tag into one buffer\");\n+        }\n+\n+        if (dst.remaining() < len + tagLenBytes) {\n+            throw new ShortBufferException(\"Output buffer too small\");\n+        }\n+\n+        checkDataLength(processed, len);\n+\n+        processAAD();\n+        if (len > 0) {\n+            doLastBlock((ibuffer == null || ibuffer.size() == 0) ?\n+                    null : ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n+            dst.reset();\n+            ghashAllToS.doLastBlock(dst, processed);\n+        }\n+\n+        byte[] block = getLengthBlock(sizeOfAAD, processed);\n+        ghashAllToS.update(block);\n+\n+        byte[] s = ghashAllToS.digest();\n+        if (tagLenBytes > block.length) {\n+            block = new byte[tagLenBytes];\n+        }\n+        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n+        gctrForSToTag.doFinal(s, 0, s.length, block, 0);\n+        dst.put(block, 0, tagLenBytes);\n+\n+        return (processed + tagLenBytes);\n+    }\n+\n@@ -605,3 +734,2 @@\n-        byte[] lengthBlock =\n-            getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(lengthBlock);\n+        byte[] block = getLengthBlock(sizeOfAAD, processed);\n+        ghashAllToS.update(block);\n@@ -610,1 +738,4 @@\n-        byte[] sOut = new byte[s.length];\n+        \/\/byte[] sOut = new byte[s.length];\n+        if (tagLenBytes != block.length) {\n+            block = new byte[tagLenBytes];\n+        }\n@@ -612,1 +743,1 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);\n+        gctrForSToTag.doFinal(s, 0, tagLenBytes, block, 0);\n@@ -617,1 +748,1 @@\n-            mismatch |= tag[i] ^ sOut[i];\n+            mismatch |= tag[i] ^ block[i];\n@@ -627,0 +758,121 @@\n+    \/\/ Note: In-place operations do not need an intermediary copy because\n+    \/\/ the GHASH check was performed before the decryption.\n+    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, AEADBadTagException,\n+        ShortBufferException {\n+        \/\/ Length of the input\n+        ByteBuffer tag;\n+        ByteBuffer data = src.duplicate();\n+        data.mark();\n+\n+        ByteBuffer buffer = ((ibuffer == null || ibuffer.size() == 0) ? null :\n+            ByteBuffer.wrap(ibuffer.toByteArray()));\n+        int len;\n+\n+        if (data.remaining() >= tagLenBytes) {\n+            tag = src.duplicate();\n+            tag.position(data.limit() - tagLenBytes);\n+            data.limit(data.limit() - tagLenBytes);\n+            len = data.remaining();\n+            if (buffer != null) {\n+                len += buffer.remaining();\n+            }\n+        } else if (buffer != null && buffer.remaining() >= tagLenBytes) {\n+            \/\/ It's unlikely the tag will be between the buffer and data\n+            tag = ByteBuffer.allocate(tagLenBytes);\n+            int limit = buffer.remaining() - tagLenBytes - data.remaining();\n+            buffer.position(limit);\n+            tag.put(buffer);\n+            \/\/ reset buffer to data only\n+            buffer.position(0);  \/\/ ibuffer should always start at zero.\n+            buffer.limit(limit);\n+            data.mark();  \/\/ Maybe data position is not zero\n+            tag.put(data);\n+            tag.flip();\n+            data.reset();\n+            \/\/ Limit is how much of the ibuffer has been chopped off.\n+            len = buffer.remaining();\n+        } else {\n+            throw new AEADBadTagException(\"Input too short - need tag\");\n+        }\n+\n+        \/\/ do this check here can also catch the potential integer overflow\n+        \/\/ scenario for the subsequent output buffer capacity check.\n+        checkDataLength(0, len);\n+\n+        if ((ibuffer.size() + data.remaining()) - tagLenBytes >\n+            dst.remaining()) {\n+            throw new ShortBufferException(\"Output buffer too small\");\n+        }\n+\n+        processAAD();\n+\n+        \/\/ If there is data stored in the buffer\n+        if (buffer != null && buffer.remaining() > 0) {\n+            ghashAllToS.update(buffer, buffer.remaining());\n+            \/\/ Process the overage\n+            if (buffer.remaining() > 0) {\n+                \/\/ Fill out block between two buffers\n+                if (data.remaining() > 0) {\n+                    int over = buffer.remaining();\n+                    byte[] block = new byte[AES_BLOCK_SIZE];\n+                    \/\/ Copy the remainder of the buffer into the extra block\n+                    buffer.get(block, 0, over);\n+\n+                    \/\/ Fill out block with what is in data\n+                    if (data.remaining() > AES_BLOCK_SIZE - over) {\n+                        data.get(block, over, AES_BLOCK_SIZE - over);\n+                        ghashAllToS.update(block, 0, AES_BLOCK_SIZE);\n+                    } else {\n+                        \/\/ If the remaining in buffer + data does not fill a\n+                        \/\/ block, complete the ghash operation\n+                        int l = data.remaining();\n+                        data.get(block, over, l);\n+                        ghashAllToS.doLastBlock(ByteBuffer.wrap(block), over + l);\n+                    }\n+                    processed += AES_BLOCK_SIZE;\n+                } else {\n+                    \/\/ data is empty, so complete the ghash op with the\n+                    \/\/ remaining buffer\n+                    ghashAllToS.doLastBlock(buffer, buffer.remaining());\n+                }\n+            }\n+        }\n+\n+        if (data.remaining() > 0) {\n+            ghashAllToS.doLastBlock(data, data.remaining());\n+        }\n+        byte[] block = getLengthBlock(sizeOfAAD, len);\n+        ghashAllToS.update(block);\n+        byte[] s = ghashAllToS.digest();\n+        if (tagLenBytes > block.length) {\n+            block = new byte[tagLenBytes];\n+        }\n+       \/\/ byte[] sOut = new byte[s.length];\n+        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n+        gctrForSToTag.doFinal(s, 0, s.length, block, 0);\n+\n+        \/\/ check entire authentication tag for time-consistency\n+        int mismatch = 0;\n+        for (int i = 0; i < tagLenBytes; i++) {\n+            mismatch |= tag.get() ^ block[i];\n+        }\n+\n+        if (mismatch != 0) {\n+            throw new AEADBadTagException(\"Tag mismatch!\");\n+        }\n+\n+        \/\/ Reset the buffers for the data decryption phase\n+        data.reset();\n+        if (buffer != null) {\n+            buffer.flip();\n+        }\n+\n+        \/\/ Decrypt the all the input data and put it into dst\n+        doLastBlock(buffer, data, dst);\n+        dst.limit(dst.position());\n+\n+        \/\/ 'processed' from the gctr decryption operation, not ghash\n+        return processed;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":265,"deletions":13,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.test.lib.Convert;\n@@ -38,0 +39,1 @@\n+ * @library \/test\/lib\n@@ -258,0 +260,7 @@\n+            System.err.println(\n+                \"\\noutputText:   len = \" + outputText.length + \"  txtOffset = \" + txtOffset + \"\\n\" +\n+                jdk.test.lib.Convert.byteArrayToHexString(outputText) + \"\\n\" +\n+                \"text:  len = \" + text.length + \"  myoff = \" + myoff + \"\\n\" +\n+                jdk.test.lib.Convert.byteArrayToHexString(text) + \"\\n\" +\n+                    \"lenght \" + lenght);\n+            System.err.println(\"tlen = \" + params.getParameterSpec(GCMParameterSpec.class).getTLen() \/ 8);\n@@ -390,0 +399,2 @@\n+                System.err.println(\"i = \" + i + \"   A[setA] = \" + A[setA] +\n+                    \"   B[setB] = \" + B[setB]);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/SameBuffer.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.ByteBuffer;\n@@ -58,0 +59,1 @@\n+        int id;\n@@ -66,1 +68,1 @@\n-        TestVector(String key, String iv, String pt, String aad,\n+        TestVector(int id, String key, String iv, String pt, String aad,\n@@ -68,0 +70,1 @@\n+            this.id = id;\n@@ -74,1 +77,1 @@\n-            this.info = \"key=\" + key + \", iv=\" + iv + \", pt=\" + pt +\n+            this.info = \"id = \" + id + \", key=\" + key + \", iv=\" + iv + \", pt=\" + pt +\n@@ -78,0 +81,15 @@\n+        TestVector() {};\n+\n+        TestVector duplicate() {\n+            TestVector t = new TestVector();\n+            t.id = id;\n+            t.key = key;\n+            t.plainText = plainText;\n+            t.cipherText = cipherText;\n+            t.aad = aad;\n+            t.tag = tag;\n+            t.spec = spec;\n+            t.info = info;\n+            return t;\n+        }\n+\n@@ -83,0 +101,2 @@\n+    static boolean testFailed = false;\n+\n@@ -91,1 +111,1 @@\n-        new TestVector(\"11754cd72aec309bf52f7687212e8957\",\n+        new TestVector(1, \"11754cd72aec309bf52f7687212e8957\",\n@@ -95,1 +115,1 @@\n-        new TestVector(\"272f16edb81a7abbea887357a58c1917\",\n+        new TestVector(2, \"272f16edb81a7abbea887357a58c1917\",\n@@ -99,1 +119,1 @@\n-        new TestVector(\"81b6844aab6a568c4556a2eb7eae752f\",\n+        new TestVector(3, \"81b6844aab6a568c4556a2eb7eae752f\",\n@@ -103,1 +123,1 @@\n-        new TestVector(\"cde2f9a9b1a004165ef9dc981f18651b\",\n+        new TestVector(4, \"cde2f9a9b1a004165ef9dc981f18651b\",\n@@ -107,1 +127,1 @@\n-        new TestVector(\"b01e45cc3088aaba9fa43d81d481823f\",\n+        new TestVector(5, \"b01e45cc3088aaba9fa43d81d481823f\",\n@@ -113,1 +133,1 @@\n-        new TestVector(\"77be63708971c4e240d1cb79e8d77feb\",\n+        new TestVector(6, \"77be63708971c4e240d1cb79e8d77feb\",\n@@ -119,1 +139,1 @@\n-        new TestVector(\"da0b615656135194ba6d3c851099bc48\",\n+        new TestVector(7, \"da0b615656135194ba6d3c851099bc48\",\n@@ -125,1 +145,1 @@\n-        new TestVector(\"7e0986937a88eef894235aba4a2f43b2\",\n+        new TestVector(8, \"7e0986937a88eef894235aba4a2f43b2\",\n@@ -131,1 +151,1 @@\n-        new TestVector(\"c3db570d7f0c21e86b028f11465d1dc9\",\n+        new TestVector(9, \"c3db570d7f0c21e86b028f11465d1dc9\",\n@@ -137,1 +157,1 @@\n-        new TestVector(\"bea48ae4980d27f357611014d4486625\",\n+        new TestVector(10, \"bea48ae4980d27f357611014d4486625\",\n@@ -145,1 +165,1 @@\n-        new TestVector(\"2fb45e5b8f993a2bfebc4b15b533e0b4\",\n+        new TestVector(11, \"2fb45e5b8f993a2bfebc4b15b533e0b4\",\n@@ -151,1 +171,1 @@\n-        new TestVector(\"9bf406339fcef9675bbcf156aa1a0661\",\n+        new TestVector(12, \"9bf406339fcef9675bbcf156aa1a0661\",\n@@ -157,1 +177,1 @@\n-        new TestVector(\"a2e962fff70fd0f4d63be728b80556fc\",\n+        new TestVector(13, \"a2e962fff70fd0f4d63be728b80556fc\",\n@@ -163,1 +183,1 @@\n-        new TestVector(\"6bf4fdce82926dcdfc52616ed5f23695\",\n+        new TestVector(14, \"6bf4fdce82926dcdfc52616ed5f23695\",\n@@ -169,1 +189,1 @@\n-        new TestVector(\"4df7a13e43c3d7b66b1a72fac5ba398e\",\n+        new TestVector(15, \"4df7a13e43c3d7b66b1a72fac5ba398e\",\n@@ -176,1 +196,1 @@\n-        new TestVector(\"fe9bb47deb3a61e423c2231841cfd1fb\",\n+        new TestVector(16, \"fe9bb47deb3a61e423c2231841cfd1fb\",\n@@ -182,1 +202,1 @@\n-        new TestVector(\"7fddb57453c241d03efbed3ac44e371c\",\n+        new TestVector(17, \"7fddb57453c241d03efbed3ac44e371c\",\n@@ -188,1 +208,1 @@\n-        new TestVector(\"9971071059abc009e4f2bd69869db338\",\n+        new TestVector(18, \"9971071059abc009e4f2bd69869db338\",\n@@ -194,1 +214,1 @@\n-        new TestVector(\"594157ec4693202b030f33798b07176d\",\n+        new TestVector(19, \"594157ec4693202b030f33798b07176d\",\n@@ -203,1 +223,1 @@\n-        new TestVector(\"c939cc13397c1d37de6ae0e1cb7c423c\",\n+        new TestVector(20, \"c939cc13397c1d37de6ae0e1cb7c423c\",\n@@ -209,1 +229,1 @@\n-        new TestVector(\"d4a22488f8dd1d5c6c19a7d6ca17964c\",\n+        new TestVector(21, \"d4a22488f8dd1d5c6c19a7d6ca17964c\",\n@@ -215,1 +235,1 @@\n-        new TestVector(\"89850dd398e1f1e28443a33d40162664\",\n+        new TestVector(22, \"89850dd398e1f1e28443a33d40162664\",\n@@ -222,1 +242,1 @@\n-        new TestVector(\"bd7c5c63b7542b56a00ebe71336a1588\",\n+        new TestVector(23, \"bd7c5c63b7542b56a00ebe71336a1588\",\n@@ -230,1 +250,1 @@\n-        new TestVector(\"1672c3537afa82004c6b8a46f6f0d026\",\n+        new TestVector(24, \"1672c3537afa82004c6b8a46f6f0d026\",\n@@ -234,1 +254,1 @@\n-        new TestVector(\"d0f1f4defa1e8c08b4b26d576392027c\",\n+        new TestVector(25, \"d0f1f4defa1e8c08b4b26d576392027c\",\n@@ -240,1 +260,1 @@\n-        new TestVector(\"9f79239f0904eace50784b863e723f6b\",\n+        new TestVector(26, \"9f79239f0904eace50784b863e723f6b\",\n@@ -248,1 +268,1 @@\n-        new TestVector(\"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n+        new TestVector(27, \"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n@@ -260,2 +280,1 @@\n-    public boolean execute(TestVector[] testValues) throws Exception {\n-        boolean testFailed = false;\n+    void executeArray(TestVector tv) throws Exception {\n@@ -263,32 +282,14 @@\n-        for (int i = 0; i < testValues.length; i++) {\n-            try {\n-                c.init(Cipher.ENCRYPT_MODE, testValues[i].key, testValues[i].spec);\n-                c.updateAAD(testValues[i].aad);\n-                byte[] ctPlusTag = c.doFinal(testValues[i].plainText);\n-\n-                c.init(Cipher.DECRYPT_MODE, testValues[i].key, testValues[i].spec);\n-                c.updateAAD(testValues[i].aad);\n-                byte[] pt = c.doFinal(ctPlusTag); \/\/ should fail if tag mismatched\n-\n-                \/\/ check encryption\/decryption results just to be sure\n-                if (!Arrays.equals(testValues[i].plainText, pt)) {\n-                    System.out.println(\"PlainText diff failed for test# \" + i);\n-                    testFailed = true;\n-                }\n-                int ctLen = testValues[i].cipherText.length;\n-                if (!Arrays.equals(testValues[i].cipherText,\n-                                   Arrays.copyOf(ctPlusTag, ctLen))) {\n-                    System.out.println(\"CipherText diff failed for test# \" + i);\n-                    testFailed = true;\n-                }\n-                int tagLen = testValues[i].tag.length;\n-                if (!Arrays.equals\n-                    (testValues[i].tag,\n-                     Arrays.copyOfRange(ctPlusTag, ctLen, ctLen+tagLen))) {\n-                    System.out.println(\"Tag diff failed for test# \" + i);\n-                    testFailed = true;\n-                }\n-            } catch (Exception ex) {\n-                \/\/ continue testing other test vectors\n-                System.out.println(\"Failed Test Vector: \" + testValues[i]);\n-                ex.printStackTrace();\n+        try {\n+            System.out.println(\"Test #\" + tv.id + \": byte[].\");\n+\n+            c.init(Cipher.ENCRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            byte[] ctPlusTag = c.doFinal(tv.plainText);\n+\n+            c.init(Cipher.DECRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            byte[] pt = c.doFinal(ctPlusTag); \/\/ should fail if tag mismatched\n+\n+            \/\/ check encryption\/decryption results just to be sure\n+            if (!Arrays.equals(tv.plainText, pt)) {\n+                System.out.println(\"PlainText diff failed for test# \" + tv.id);\n@@ -296,1 +297,0 @@\n-                continue;\n@@ -298,0 +298,18 @@\n+            int ctLen = tv.cipherText.length;\n+            if (!Arrays.equals(tv.cipherText,\n+                Arrays.copyOf(ctPlusTag, ctLen))) {\n+                System.out.println(\"CipherText diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+            int tagLen = tv.tag.length;\n+            if (!Arrays.equals\n+                (tv.tag,\n+                    Arrays.copyOfRange(ctPlusTag, ctLen, ctLen+tagLen))) {\n+                System.out.println(\"Tag diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+        } catch (Exception ex) {\n+            \/\/ continue testing other test vectors\n+            System.out.println(\"Failed Test Vector: \" + tv);\n+            ex.printStackTrace();\n+            testFailed = true;\n@@ -302,2 +320,80 @@\n-        \/\/ passed all tests...hooray!\n-        return true;\n+    }\n+\n+    void executeByteBuffer(TestVector tv, boolean direct, int offset) throws Exception {\n+        Cipher c = Cipher.getInstance(\"AES\/GCM\/NoPadding\", \"SunJCE\");\n+\n+        ByteBuffer src;\n+        ByteBuffer ctdst;\n+        ByteBuffer ptdst;\n+\n+        if (direct) {\n+            System.out.print(\"Test #\" + tv.id + \": ByteBuffer Direct.\");\n+            src = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n+            ctdst = ByteBuffer.allocateDirect(tv.cipherText.length + tv.tag.length + offset);\n+            ptdst = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n+        } else {\n+            System.out.print(\"Test #\" + tv.id + \": ByteBuffer Heap.\");\n+            src = ByteBuffer.allocate(tv.plainText.length + offset);\n+            ctdst = ByteBuffer.allocate(tv.cipherText.length + tv.tag.length + offset);\n+            ptdst = ByteBuffer.allocate(tv.plainText.length + offset);\n+        }\n+\n+        byte[] plainText;\n+\n+        if (offset > 0) {\n+            System.out.println(\"  offset = \" + offset);\n+            plainText = new byte[tv.plainText.length + offset];\n+            System.arraycopy(tv.plainText, 0, plainText, offset,\n+                tv.plainText.length);\n+        } else {\n+            System.out.println();\n+            plainText = tv.plainText;\n+        }\n+\n+        src.put(plainText);\n+        src.position(offset);\n+        ctdst.position(offset);\n+        ctdst.mark();\n+        ptdst.position(offset);\n+        ptdst.mark();\n+\n+        try {\n+            c.init(Cipher.ENCRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            c.doFinal(src, ctdst);\n+\n+            ctdst.reset();\n+            ByteBuffer tag = ctdst.duplicate();\n+            tag.position(tag.limit() - tv.tag.length);\n+\n+            c.init(Cipher.DECRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            c.doFinal(ctdst, ptdst); \/\/ should fail if tag mismatched\n+\n+            ptdst.reset();\n+            \/\/ check encryption\/decryption results just to be sure\n+            if (ptdst.compareTo(ByteBuffer.wrap(tv.plainText)) != 0) {\n+                System.out.println(\"\\t PlainText diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+\n+            ctdst.reset();\n+            ctdst.limit(ctdst.limit() - tv.tag.length);\n+            if (ctdst.compareTo(ByteBuffer.wrap(tv.cipherText)) != 0) {\n+                System.out.println(\"\\t CipherText diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+\n+            int mismatch = 0;\n+            for (int i = 0; i < tv.tag.length; i++) {\n+                mismatch |= tag.get() ^ tv.tag[i];\n+            }\n+            if (mismatch != 0) {\n+                System.out.println(\"\\t Tag diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+        } catch (Exception ex) {\n+            \/\/ continue testing other test vectors\n+            System.out.println(\"\\t Failed Test Vector ( #\" + tv.id + \") : \" + tv);\n+            ex.printStackTrace();\n+        }\n@@ -308,2 +404,9 @@\n-        if (test.execute(testValues)) {\n-            System.out.println(\"Test Passed!\");\n+        for (TestVector tv : testValues) {\n+            test.executeArray(tv);\n+            test.executeByteBuffer(tv, false, 0);\n+            test.executeByteBuffer(tv, true, 0);\n+            test.executeByteBuffer(tv, false, 2);\n+            test.executeByteBuffer(tv, true, 2);\n+        }\n+        if (!testFailed) {\n+            System.out.println(\"Tests passed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestKATForGCM.java","additions":171,"deletions":68,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-        System.out.println(\"\\tDIRECT: passed\");\n@@ -95,0 +94,1 @@\n+        System.out.println(\"\\tDIRECT: passed\");\n@@ -175,1 +175,0 @@\n-\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/CipherByteBufferOverwriteTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @run main\/othervm -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true CheckSessionContext\n@@ -37,0 +38,2 @@\n+import javax.net.ssl.SSLSession;\n+\n@@ -39,0 +42,7 @@\n+    static void toHex(byte[] id) {\n+        for (byte b : id) {\n+            System.out.printf(\"%02X \", b);\n+        }\n+        System.out.println();\n+    }\n+\n@@ -49,0 +59,11 @@\n+        SSLSession ss = server.getSession(client1);\n+        System.out.println(ss);\n+        byte[] id = ss.getId();\n+        System.out.print(\"id = \");\n+        toHex(id);\n+        System.out.println(\"ss.getSessionContext().getSession(id) = \" + ss.getSessionContext().getSession(id));\n+        if (ss.getSessionContext().getSession(id) != null) {\n+            id = ss.getSessionContext().getSession(id).getId();\n+            System.out.print(\"id = \");\n+            toHex(id);\n+        }\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}