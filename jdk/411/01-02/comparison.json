{"files":[{"patch":"@@ -423,0 +423,1 @@\n+\n@@ -653,0 +654,1 @@\n+\n@@ -742,6 +744,3 @@\n-            if (core.getMode() == CipherCore.GCM_MODE) {\n-                if (isUpdate) {\n-                    return core.update(input, output);\n-                } else {\n-                    return core.doFinal(input, output);\n-                }\n+\n+            if (!isUpdate && core.getMode() == CipherCore.GCM_MODE) {\n+                    return core.gcmDoFinal(input, output);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -726,2 +726,2 @@\n-        if ((output == null) ||\n-            ((output.length - outputOffset) < len)) {\n+        if (getMode() != GCM_MODE && (output == null ||\n+            ((output.length - outputOffset) < len))) {\n@@ -816,7 +816,0 @@\n-    int update(ByteBuffer src, ByteBuffer dst) throws ShortBufferException {\n-        if (decrypting) {\n-            return cipher.decrypt(src, dst);\n-        }\n-        return cipher.encrypt(src, dst);\n-    }\n-\n@@ -1242,1 +1235,1 @@\n-    int doFinal(ByteBuffer src, ByteBuffer dst) throws ShortBufferException,\n+    int gcmDoFinal(ByteBuffer src, ByteBuffer dst) throws ShortBufferException,\n@@ -1256,1 +1249,1 @@\n-                cipher.encrypt(buffer, 0, buffered, new byte[0], 0);\n+                ((GaloisCounterMode)cipher).encrypt(buffer, 0, buffered);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -260,2 +260,1 @@\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n+        throws IllegalBlockSizeException, ShortBufferException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    private static final int MAX_LEN = 1024;\n+\n@@ -60,2 +63,3 @@\n-            throw new RuntimeException(\"length of initial counter block (\" + initialCounterBlk.length +\n-                                       \") not equal to AES_BLOCK_SIZE (\" + AES_BLOCK_SIZE + \")\");\n+            throw new RuntimeException(\"length of initial counter block (\" +\n+                initialCounterBlk.length + \") not equal to AES_BLOCK_SIZE (\" +\n+                AES_BLOCK_SIZE + \")\");\n@@ -115,24 +119,10 @@\n-    \/\/ input can be arbitrary size when calling doFinal\n-    int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n-                          int outOfs) throws IllegalBlockSizeException {\n-        try {\n-            if (inLen < 0) {\n-                throw new IllegalBlockSizeException(\"Negative input size!\");\n-            } else if (inLen > 0) {\n-                int lastBlockSize = inLen % AES_BLOCK_SIZE;\n-                int completeBlkLen = inLen - lastBlockSize;\n-                \/\/ process the complete blocks first\n-                update(in, inOfs, completeBlkLen, out, outOfs);\n-                if (lastBlockSize != 0) {\n-                    \/\/ do the last partial block\n-                    byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n-                    embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                    for (int n = 0; n < lastBlockSize; n++) {\n-                        out[outOfs + completeBlkLen + n] =\n-                            (byte) ((in[inOfs + completeBlkLen + n] ^\n-                                     encryptedCntr[n]));\n-                    }\n-                }\n-            }\n-        } finally {\n-            reset();\n+    \/\/ input must be multiples of AES blocks, 128-bit, when calling update\n+    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        if (inLen - inOfs > in.length) {\n+            throw new RuntimeException(\"input length out of bound\");\n+        }\n+        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+            throw new RuntimeException(\"input length unsupported\");\n+        }\n+        if (dst.remaining() < inLen) {\n+            throw new RuntimeException(\"output buffer too small\");\n@@ -140,5 +130,0 @@\n-        return inLen;\n-    }\n-\n-    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n-    private static final int MAX_LEN = 1024;\n@@ -146,8 +131,7 @@\n-    int doFinal(ByteBuffer src, ByteBuffer dst) throws IllegalBlockSizeException {\n-        int len = src.remaining();\n-        int lastBlockSize = len % AES_BLOCK_SIZE;\n-        try {\n-            update(src, dst);\n-            if (lastBlockSize != 0) {\n-                \/\/ do the last partial block\n-                byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+        long blocksLeft = blocksUntilRollover();\n+        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        if (numOfCompleteBlocks >= blocksLeft) {\n+            \/\/ Counter Mode encryption cannot be used because counter will\n+            \/\/ roll over incorrectly. Use GCM-specific code instead.\n+            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            for (int i = 0; i < numOfCompleteBlocks; i++) {\n@@ -155,2 +139,3 @@\n-                for (int n = 0; n < lastBlockSize; n++) {\n-                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n+                    int index = (i * AES_BLOCK_SIZE + n);\n+                    dst.put((byte) ((in[inOfs + index] ^ encryptedCntr[n])));\n@@ -158,0 +143,1 @@\n+                GaloisCounterMode.increment32(counter);\n@@ -159,2 +145,15 @@\n-        } finally {\n-            reset();\n+            return inLen;\n+        } else {\n+            int len = inLen - inLen % AES_BLOCK_SIZE;\n+            int processed = len;\n+            byte[] out = new byte[Math.min(MAX_LEN, len)];\n+            int offset = inOfs;\n+            while (processed > MAX_LEN) {\n+                encrypt(in, offset, MAX_LEN, out, 0);\n+                dst.get(out, 0, MAX_LEN);\n+                processed -= MAX_LEN;\n+                offset += MAX_LEN;\n+            }\n+            encrypt(in, offset, processed, out, 0);\n+            dst.put(out, 0, processed);\n+            return len;\n@@ -162,1 +161,0 @@\n-        return len;\n@@ -165,0 +163,2 @@\n+    \/\/ input operates on multiples of AES blocks, 128-bit, when calling update.\n+    \/\/ The remainder is left in the src buffer.\n@@ -197,10 +197,24 @@\n-    \/\/ input must be multiples of 128-bit blocks when calling update\n-    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n-        if (inLen - inOfs > in.length) {\n-            throw new RuntimeException(\"input length out of bound\");\n-        }\n-        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n-            throw new RuntimeException(\"input length unsupported\");\n-        }\n-        if (dst.remaining() < inLen) {\n-            throw new RuntimeException(\"output buffer too small\");\n+    \/\/ input can be arbitrary size when calling doFinal\n+    int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+        int outOfs) throws IllegalBlockSizeException {\n+        try {\n+            if (inLen < 0) {\n+                throw new IllegalBlockSizeException(\"Negative input size!\");\n+            } else if (inLen > 0) {\n+                int lastBlockSize = inLen % AES_BLOCK_SIZE;\n+                int completeBlkLen = inLen - lastBlockSize;\n+                \/\/ process the complete blocks first\n+                update(in, inOfs, completeBlkLen, out, outOfs);\n+                if (lastBlockSize != 0) {\n+                    \/\/ do the last partial block\n+                    byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+                    embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                    for (int n = 0; n < lastBlockSize; n++) {\n+                        out[outOfs + completeBlkLen + n] =\n+                            (byte) ((in[inOfs + completeBlkLen + n] ^\n+                                encryptedCntr[n]));\n+                    }\n+                }\n+            }\n+        } finally {\n+            reset();\n@@ -208,0 +222,2 @@\n+        return inLen;\n+    }\n@@ -209,7 +225,9 @@\n-        long blocksLeft = blocksUntilRollover();\n-        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n-        if (numOfCompleteBlocks >= blocksLeft) {\n-            \/\/ Counter Mode encryption cannot be used because counter will\n-            \/\/ roll over incorrectly. Use GCM-specific code instead.\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n-            for (int i = 0; i < numOfCompleteBlocks; i++) {\n+    \/\/ src can be arbitrary size when calling doFinal\n+    int doFinal(ByteBuffer src, ByteBuffer dst) {\n+        int len = src.remaining();\n+        int lastBlockSize = len % AES_BLOCK_SIZE;\n+        try {\n+            update(src, dst);\n+            if (lastBlockSize != 0) {\n+                \/\/ do the last partial block\n+                byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n@@ -217,3 +235,2 @@\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    int index = (i * AES_BLOCK_SIZE + n);\n-                    dst.put((byte) ((in[inOfs + index] ^ encryptedCntr[n])));\n+                for (int n = 0; n < lastBlockSize; n++) {\n+                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n@@ -221,13 +238,0 @@\n-                GaloisCounterMode.increment32(counter);\n-            }\n-            return inLen;\n-        } else {\n-            int len = inLen % AES_BLOCK_SIZE;\n-            int processed = len;\n-            byte[] out = new byte[Math.min(MAX_LEN, len)];\n-            int offset = inOfs;\n-            while (processed > MAX_LEN) {\n-                encrypt(in, offset, MAX_LEN, out, 0);\n-                dst.get(out, 0, MAX_LEN);\n-                processed -= MAX_LEN;\n-                offset += MAX_LEN;\n@@ -235,3 +239,2 @@\n-            encrypt(in, offset, processed, out, 0);\n-            dst.get(out, 0, processed);\n-            return len;\n+        } finally {\n+            reset();\n@@ -239,0 +242,1 @@\n+        return len;\n@@ -240,1 +244,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":85,"deletions":81,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    \/\/ buffer for storing input in decryption, not used for encryption\n+    \/\/ buffer data for crypto operation\n@@ -435,1 +435,0 @@\n-        processed = 0;\n@@ -438,1 +437,1 @@\n-            processed = gctrPAndC.update(buffer, dst);\n+            processed += gctrPAndC.update(buffer, dst);\n@@ -473,0 +472,16 @@\n+     \/*\n+     * This method is for CipherCore to insert the remainder of its buffer\n+     * into the ibuffer before a doFinal(ByteBuffer, ByteBuffer) operation\n+     *\/\n+    int encrypt(byte[] in, int inOfs, int len) {\n+        if (len > 0) {\n+            \/\/ store internally until encryptFinal\n+            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n+            if (ibuffer == null) {\n+                ibuffer = new ByteArrayOutputStream();\n+            }\n+            ibuffer.write(in, inOfs, len);\n+        }\n+        return len;\n+    }\n+\n@@ -490,2 +505,0 @@\n-        ArrayUtil.blockSizeCheck(len, blockSize);\n-\n@@ -495,1 +508,8 @@\n-\n+        int remainder = len % blockSize;\n+        if ( remainder > 0) {\n+            if (ibuffer == null) {\n+                ibuffer = new ByteArrayOutputStream(len % blockSize);\n+            }\n+            len -= remainder;\n+            ibuffer.write(in, len, remainder);\n+        }\n@@ -508,48 +528,0 @@\n-    int decrypt(ByteBuffer src, ByteBuffer dst) {\n-        if (src.remaining() > 0) {\n-            byte[] b = new byte[src.remaining()];\n-            src.get(b);\n-            try {\n-                ibuffer.write(b);\n-            } catch (IOException e) {\n-                throw new ProviderException(\"Unable to add remaining input to the buffer\", e);\n-            }\n-        }\n-        return 0;\n-    }\n-\n-\n-    int encrypt(ByteBuffer src, ByteBuffer dst) {\n-        int len = src.remaining();\n-        if (len == 0) {\n-            return 0;\n-        }\n-\n-        ArrayUtil.blockSizeCheck(src.remaining(), blockSize);\n-        checkDataLength(processed, src.remaining());\n-        processAAD();\n-\n-        if (len >= AES_BLOCK_SIZE) {\n-            ByteBuffer data = src.duplicate();\n-            len = gctrPAndC.update(data, dst);\n-        } else {\n-            if (src.remaining() > 0) {\n-                byte[] b = new byte[src.remaining()];\n-                src.get(b);\n-                try {\n-                    ibuffer.write(b);\n-                } catch (IOException e) {\n-                    throw new ProviderException(\n-                        \"Unable to add remaining input to the buffer\", e);\n-                }\n-            }\n-            return 0;\n-        }\n-\n-        processed += len;\n-        ghashAllToS.update(src, len);\n-        return len;\n-    }\n-\n-\n-\n@@ -568,4 +540,2 @@\n-        if (len > MAX_BUF_SIZE - tagLenBytes) {\n-            throw new ShortBufferException\n-                (\"Can't fit both data and tag into one buffer\");\n-        }\n+        checkDataLength(processed, Math.addExact(len, tagLenBytes));\n+\n@@ -579,2 +549,0 @@\n-        checkDataLength(processed, len);\n-\n@@ -590,4 +558,1 @@\n-        byte[] s = ghashAllToS.digest();\n-        if (tagLenBytes > block.length) {\n-            block = new byte[tagLenBytes];\n-        }\n+        block = ghashAllToS.digest();\n@@ -595,1 +560,1 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, block, 0);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n@@ -604,4 +569,2 @@\n-        dst.mark();\n-        if (len > MAX_BUF_SIZE - tagLenBytes) {\n-            throw new ShortBufferException\n-                (\"Can't fit both data and tag into one buffer\");\n+        if (ibuffer != null) {\n+            len += ibuffer.size();\n@@ -610,0 +573,3 @@\n+        checkDataLength(processed, Math.addExact(len, tagLenBytes));\n+\n+        dst.mark();\n@@ -614,2 +580,0 @@\n-        checkDataLength(processed, len);\n-\n@@ -621,1 +585,1 @@\n-            ghashAllToS.doLastBlock(dst, processed);\n+            ghashAllToS.doLastBlock(dst, len);\n@@ -626,5 +590,1 @@\n-\n-        byte[] s = ghashAllToS.digest();\n-        if (tagLenBytes > block.length) {\n-            block = new byte[tagLenBytes];\n-        }\n+        block = ghashAllToS.digest();\n@@ -632,1 +592,1 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, block, 0);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n@@ -635,1 +595,1 @@\n-        return (processed + tagLenBytes);\n+        return (len + tagLenBytes);\n@@ -656,2 +616,0 @@\n-        ArrayUtil.blockSizeCheck(len, blockSize);\n-\n@@ -672,0 +630,13 @@\n+    int decrypt(ByteBuffer src, ByteBuffer dst) {\n+        if (src.remaining() > 0) {\n+            byte[] b = new byte[src.remaining()];\n+            src.get(b);\n+            try {\n+                ibuffer.write(b);\n+            } catch (IOException e) {\n+                throw new ProviderException(\"Unable to add remaining input to the buffer\", e);\n+            }\n+        }\n+        return 0;\n+    }\n+\n@@ -736,6 +707,1 @@\n-\n-        byte[] s = ghashAllToS.digest();\n-        \/\/byte[] sOut = new byte[s.length];\n-        if (tagLenBytes != block.length) {\n-            block = new byte[tagLenBytes];\n-        }\n+        block = ghashAllToS.digest();\n@@ -743,1 +709,1 @@\n-        gctrForSToTag.doFinal(s, 0, tagLenBytes, block, 0);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n@@ -765,2 +731,2 @@\n-        ByteBuffer data = src.duplicate();\n-        data.mark();\n+        ByteBuffer ct = src.duplicate();\n+        ct.mark();\n@@ -772,1 +738,1 @@\n-        if (data.remaining() >= tagLenBytes) {\n+        if (ct.remaining() >= tagLenBytes) {\n@@ -774,3 +740,3 @@\n-            tag.position(data.limit() - tagLenBytes);\n-            data.limit(data.limit() - tagLenBytes);\n-            len = data.remaining();\n+            tag.position(ct.limit() - tagLenBytes);\n+            ct.limit(ct.limit() - tagLenBytes);\n+            len = ct.remaining();\n@@ -780,1 +746,2 @@\n-        } else if (buffer != null && buffer.remaining() >= tagLenBytes) {\n+            ct.mark();\n+        } else if (buffer != null && ct.remaining() < tagLenBytes) {\n@@ -783,1 +750,2 @@\n-            int limit = buffer.remaining() - tagLenBytes - data.remaining();\n+            int limit = buffer.remaining() - (tagLenBytes - ct.remaining());\n+            buffer.mark();\n@@ -785,0 +753,1 @@\n+            \/\/ Read from \"new\" limit to buffer's end\n@@ -787,1 +756,1 @@\n-            buffer.position(0);  \/\/ ibuffer should always start at zero.\n+            buffer.reset();\n@@ -789,2 +758,1 @@\n-            data.mark();  \/\/ Maybe data position is not zero\n-            tag.put(data);\n+            tag.put(ct);\n@@ -792,1 +760,0 @@\n-            data.reset();\n@@ -803,1 +770,1 @@\n-        if ((ibuffer.size() + data.remaining()) - tagLenBytes >\n+        if ((ibuffer.size() + ct.remaining()) - tagLenBytes >\n@@ -816,1 +783,1 @@\n-                if (data.remaining() > 0) {\n+                if (ct.remaining() > 0) {\n@@ -823,2 +790,2 @@\n-                    if (data.remaining() > AES_BLOCK_SIZE - over) {\n-                        data.get(block, over, AES_BLOCK_SIZE - over);\n+                    if (ct.remaining() > AES_BLOCK_SIZE - over) {\n+                        ct.get(block, over, AES_BLOCK_SIZE - over);\n@@ -829,2 +796,2 @@\n-                        int l = data.remaining();\n-                        data.get(block, over, l);\n+                        int l = ct.remaining();\n+                        ct.get(block, over, l);\n@@ -833,1 +800,0 @@\n-                    processed += AES_BLOCK_SIZE;\n@@ -840,0 +806,2 @@\n+            \/\/ Prepare buffer for decryption\n+            buffer.flip();\n@@ -842,2 +810,4 @@\n-        if (data.remaining() > 0) {\n-            ghashAllToS.doLastBlock(data, data.remaining());\n+        if (ct.remaining() > 0) {\n+            ghashAllToS.doLastBlock(ct, ct.remaining());\n+            \/\/ Prepare buffer for decryption\n+            ct.reset();\n@@ -847,5 +817,1 @@\n-        byte[] s = ghashAllToS.digest();\n-        if (tagLenBytes > block.length) {\n-            block = new byte[tagLenBytes];\n-        }\n-       \/\/ byte[] sOut = new byte[s.length];\n+        block = ghashAllToS.digest();\n@@ -853,1 +819,1 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, block, 0);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n@@ -865,6 +831,0 @@\n-        \/\/ Reset the buffers for the data decryption phase\n-        data.reset();\n-        if (buffer != null) {\n-            buffer.flip();\n-        }\n-\n@@ -872,1 +832,1 @@\n-        doLastBlock(buffer, data, dst);\n+        doLastBlock(buffer, ct, dst);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":82,"deletions":122,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -0,0 +1,547 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Use Cipher update and doFinal with a mixture of byte[], bytebuffer,\n+ * and offset while verifying return values.  Also using different and\n+ * in-place buffers.\n+ *\n+ * in-place is not tested with different buffer types as it is not a logical\n+ * scenerio and is complicated by getOutputSize calculations.\n+ *\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+public class GCMBufferTest {\n+    \/\/ Data type for the operation\n+    enum dtype { BYTE, HEAP, DIRECT };\n+    static HashMap<String, List<Data>> datamap = new HashMap<>();\n+    \/\/ List of enum values for order of operation\n+    List<dtype> ops;\n+\n+    static final int AESBLOCK = 16;\n+\n+    static class Data {\n+        SecretKey key;\n+        byte[] iv;\n+        byte[] pt;\n+        byte[] aad;\n+        byte[] ct;\n+        byte[] tag;\n+\n+        Data(String keyalgo, String key, String iv, byte[] pt, String aad,\n+            String ct, String tag) {\n+            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n+            this.iv = HexToBytes(iv);\n+            this.pt = pt;\n+            this.aad = HexToBytes(aad);\n+            this.ct = HexToBytes(ct);\n+            this.tag = HexToBytes(tag);\n+        }\n+\n+        Data(String keyalgo, String key, String iv, String pt, String aad,\n+            String ct, String tag) {\n+            this(keyalgo, key, iv, HexToBytes(pt), aad, ct, tag);\n+\n+        }\n+\n+    }\n+\n+\n+    GCMBufferTest(String algo, List<dtype> ops, boolean same) throws Exception {\n+        this.ops = ops;\n+        int i = 1;\n+        System.out.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n+        for (Data data : datamap.get(algo)) {\n+            System.out.println(\"Encrypt:  Data Index: \" + i);\n+            encrypt(algo, data, 0);\n+            encrypt(algo, data, 2);\n+            if (same) {\n+                encrypt(algo, data, 0, true);\n+                encrypt(algo, data, 2, true);\n+            }\n+\n+            System.out.println(\"Decrypt:  Data Index: \" + i);\n+            decrypt(algo, data, 0);\n+            decrypt(algo, data, 2);\n+            if (same) {\n+                decrypt(algo, data, 0, true);\n+                decrypt(algo, data, 2, true);\n+            }\n+            i++;\n+        }\n+    }\n+\n+    GCMBufferTest(String algo, List<dtype> ops) throws Exception {\n+        this(algo, ops, true);\n+    }\n+\n+    void encrypt(String algo, Data data, int offset) throws Exception {\n+        encrypt(algo, data, offset, false);\n+    }\n+\n+    void encrypt(String algo, Data data, int offset, boolean same)\n+        throws Exception {\n+        byte[] input, output;\n+\n+        System.out.print(\"\\t input len: \" + data.pt.length + \"  offset: \" +\n+            offset + \"  in-place: \");\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init(Cipher.ENCRYPT_MODE, data.key, new GCMParameterSpec(\n+            data.tag.length * 8, data.iv));\n+        input = data.pt;\n+        output = new byte[data.ct.length + data.tag.length];\n+        System.arraycopy(data.ct, 0, output, 0, data.ct.length);\n+        System.arraycopy(data.tag, 0, output, data.ct.length,\n+            data.tag.length);\n+        if (!same) {\n+            System.out.println(\"different\");\n+            crypto(cipher, true, offset, input, output, data.aad);\n+        } else {\n+            System.out.println(\"same\");\n+            cryptoSameBuffer(cipher, true, offset, input, output, data.aad);\n+        }\n+    }\n+\n+    void decrypt(String algo, Data data, int offset) throws Exception {\n+        decrypt(algo, data, offset, false);\n+    }\n+\n+    void decrypt(String algo, Data data, int offset, boolean same)\n+        throws Exception {\n+        byte[] input, output;\n+\n+        System.out.print(\"\\t input len: \" + data.pt.length + \"  offset: \" +\n+            offset + \"  in-place: \");\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init(Cipher.DECRYPT_MODE, data.key,\n+            new GCMParameterSpec(data.tag.length * 8, data.iv));\n+        input = new byte[data.ct.length + data.tag.length];\n+        System.arraycopy(data.ct, 0, input, 0, data.ct.length);\n+        System.arraycopy(data.tag, 0, input, data.ct.length, data.tag.length);\n+        output = data.pt;\n+        if (!same) {\n+            System.out.println(\"different\");\n+            crypto(cipher, false, offset, input, output, data.aad);\n+        } else {\n+            System.out.println(\"same\");\n+            cryptoSameBuffer(cipher, false, offset, input, output, data.aad);\n+        }\n+    }\n+\n+    void crypto(Cipher cipher, boolean encrypt, int offset, byte[] input,\n+        byte[] output, byte[] aad) throws Exception {\n+        byte[] pt = new byte[input.length + offset];\n+        System.arraycopy(input, 0, pt, offset, input.length);\n+        int plen = input.length \/ ops.size(); \/\/ partial input length\n+        int theorticallen = plen - (plen % AESBLOCK); \/\/ output length\n+        int inofs = 0;\n+        int dataoffset = 0;\n+        int index = 0;\n+        int rlen = 0; \/\/ result length\n+\n+        cipher.updateAAD(aad);\n+\n+        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n+        for (dtype v : ops) {\n+            if (++index < ops.size()) {\n+                int olen = cipher.getOutputSize(plen) + offset; \/\/ output length\n+                if (plen > offset) {\n+                    inofs = offset;\n+                }\n+                switch (v) {\n+                    case BYTE -> {\n+                        byte[] out = new byte[olen];\n+                        rlen = cipher.update(pt, inofs, plen, out, offset);\n+                        ba.write(out, inofs, rlen);\n+                    }\n+                    case HEAP -> {\n+                        ByteBuffer b = ByteBuffer.allocate(plen + offset);\n+                        b.position(offset);\n+                        b.put(pt, dataoffset + inofs, plen);\n+                        b.flip();\n+                        b.position(offset);\n+                        ByteBuffer out = ByteBuffer.allocate(olen);\n+                        out.position(offset);\n+                        rlen = cipher.update(b, out);\n+                        ba.write(out.array(), inofs, rlen);\n+                    }\n+                    case DIRECT -> {\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + offset);\n+                        b.position(offset);\n+                        b.put(pt, dataoffset + inofs, plen);\n+                        b.flip();\n+                        b.position(offset);\n+                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n+                        out.position(offset);\n+                        rlen = cipher.update(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(offset);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (encrypt && rlen != theorticallen) {\n+                    throw new Exception(\"Wrong update return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + theorticallen);\n+                }\n+\n+                dataoffset += plen;\n+\n+            } else {\n+                plen = input.length - dataoffset;\n+                if (plen > offset) {\n+                    inofs = offset;\n+                }\n+                int olen = cipher.getOutputSize(plen) + offset;\n+                switch (v) {\n+                    case BYTE -> {\n+                        byte[] out = new byte[olen];\n+                        rlen = cipher.doFinal(pt, dataoffset + inofs,\n+                            plen, out, inofs);\n+                        ba.write(out, inofs, rlen);\n+                    }\n+                    case HEAP -> {\n+                        ByteBuffer b = ByteBuffer.allocate(plen + inofs);\n+                        b.limit(b.capacity());\n+                        b.position(inofs);\n+                        b.put(pt, dataoffset + inofs, plen);\n+                        b.flip();\n+                        b.position(inofs);\n+                        ByteBuffer out = ByteBuffer.allocate(olen);\n+                        out.limit(out.capacity());\n+                        out.position(inofs);\n+                        rlen = cipher.doFinal(b, out);\n+                        ba.write(out.array(), inofs, rlen);\n+                    }\n+                    case DIRECT -> {\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + inofs);\n+                        b.limit(b.capacity());\n+                        b.position(inofs);\n+                        b.put(pt, dataoffset + inofs, plen);\n+                        b.flip();\n+                        b.position(inofs);\n+                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n+                        out.limit(out.capacity());\n+                        out.position(inofs);\n+                        rlen = cipher.doFinal(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(inofs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (rlen != olen - offset) {\n+                    throw new Exception(\"Wrong doFinal return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + (olen - offset));\n+                }\n+\n+                byte[] ctresult = ba.toByteArray();\n+                if (ctresult.length != output.length ||\n+                    Arrays.compare(ctresult, output) != 0) {\n+                    throw new Exception(\"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult   (len=\" + ctresult.length + \"):\" +\n+                        String.format(\"%0\" + (ctresult.length << 1) + \"x\",\n+                            new BigInteger(1, ctresult)) +\n+                        \"\\nexpected (len=\" + output.length + \"):\" +\n+                    String.format(\"%0\" + (output.length << 1) + \"x\",\n+                        new BigInteger(1, output)));\n+                }\n+            }\n+        }\n+    }\n+\n+    void cryptoSameBuffer(Cipher cipher, boolean encrypt, int offset,\n+        byte[] input, byte[] output, byte[] aad) throws Exception {\n+        byte[] data =\n+            new byte[(encrypt ? output.length : input.length) + offset], out;\n+        ByteBuffer bbin = null, bbout = null;\n+        System.arraycopy(input, 0, data, offset, input.length);\n+        cipher.updateAAD(aad);\n+        int plen = input.length \/ ops.size(); \/\/ partial input length\n+        int theorticallen = plen - (plen % AESBLOCK); \/\/ output length\n+        int inofs = 0;\n+        int dataoffset = 0;\n+        int index = 0;\n+        int rlen = 0; \/\/ result length\n+        int len = 0;\n+\n+        switch (ops.get(0)) {\n+            case HEAP -> {\n+                bbin = ByteBuffer.wrap(data);\n+                bbin.position(offset);\n+                bbout = bbin.duplicate();\n+            }\n+            case DIRECT -> {\n+                bbin = ByteBuffer.allocateDirect(data.length);\n+                bbin.position(offset);\n+                bbout = bbin.duplicate();\n+                bbin.put(data, offset, input.length);\n+                bbin.flip();\n+                bbin.position(offset);\n+            }\n+        }\n+\n+        if (bbin != null) {\n+            if (encrypt) {\n+                bbin.limit(input.length + offset);\n+            } else {\n+                bbout.limit(output.length + offset);\n+            }\n+            bbout.position(offset);\n+        }\n+\n+        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n+        for (dtype v : ops) {\n+            if (++index < ops.size()) {\n+                if (plen > offset) {\n+                    inofs = offset;\n+                }\n+                switch (v) {\n+                    case BYTE -> {\n+                        rlen = cipher.update(data, inofs, plen, data, offset);\n+                    }\n+                    case HEAP, DIRECT -> {\n+                        theorticallen = bbin.remaining() -\n+                            (bbin.remaining() % AESBLOCK);\n+                        rlen = cipher.update(bbin, bbout);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (encrypt && rlen != theorticallen) {\n+                    throw new Exception(\"Wrong update return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + theorticallen);\n+                }\n+\n+                dataoffset += plen;\n+                len += rlen;\n+\n+            } else {\n+                plen = input.length - dataoffset;\n+                if (plen > offset) {\n+                    inofs = offset;\n+                }\n+                switch (v) {\n+                    case BYTE -> {\n+                        rlen = cipher.doFinal(data, dataoffset + inofs,\n+                            plen, data, len + inofs);\n+                        out = Arrays.copyOfRange(data, inofs,\n+                            len + rlen + inofs);\n+                    }\n+                    case HEAP, DIRECT -> {\n+                        rlen = cipher.doFinal(bbin, bbout);\n+                        bbout.flip();\n+                        out = new byte[bbout.remaining() - offset];\n+                        bbout.position(offset);\n+                        bbout.get(out);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+                len += rlen;\n+\n+                if (len != output.length ||\n+                    Arrays.compare(out, 0, len, output, 0,\n+                        output.length) != 0) {\n+                    throw new Exception(\"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult   (len=\" + len + \"):\" +\n+                        byteToHex(out) +\n+                        \"\\nexpected (len=\" + output.length + \"):\" +\n+                        String.format(\"%0\" + (output.length << 1) + \"x\",\n+                            new BigInteger(1, output)));\n+                }\n+            }\n+        }\n+    }\n+\n+    String byteToHex(byte[] barray) {\n+        StringBuilder s = new StringBuilder();\n+        for (byte b : barray) {\n+            s.append(String.format(\"%02x\", b));\n+        }\n+        return s.toString();\n+    }\n+\n+    public static void main (String args[]) throws Exception {\n+\n+        initTest();\n+\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE));\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE));\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP));\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP));\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT));\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.DIRECT), false);\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE), false);\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT), false);\n+    }\n+\n+    private static byte[] HexToBytes(String hexVal) {\n+        if (hexVal == null) {\n+            return new byte[0];\n+        }\n+        byte[] result = new byte[hexVal.length()\/2];\n+        for (int i = 0; i < result.length; i++) {\n+            String byteVal = hexVal.substring(2*i, 2*i +2);\n+            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n+        }\n+        return result;\n+    }\n+\n+    static void initTest() {\n+        byte[] in = new byte[256];\n+        byte[] inx = new byte[2075];\n+        Arrays.fill(in, (byte) 0);\n+        Arrays.fill(inx, (byte) 0);\n+\n+        datamap.put(\"AES\/GCM\/NoPadding\", List.of(\n+            new Data(\"AES\",\n+            \"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n+                \"49451da24bd6074509d3cebc2c0394c972e6934b45a1d91f3ce1d3ca69e19\" +\n+                \"4aa1958a7c21b6f21d530ce6d2cc5256a3f846b6f9d2f38df0102c4791e5\" +\n+                \"7df038f6e69085646007df999751e248e06c47245f4cd3b8004585a7470d\" +\n+                \"ee1690e9d2d63169a58d243c0b57b3e5b4a481a3e4e8c60007094ef3adea\" +\n+                \"2e8f05dd3a1396f\",\n+            \"d384305af2388699aa302f510913fed0f2cb63ba42efa8c5c9de2922a2ec\" +\n+                \"2fe87719dadf1eb0aef212b51e74c9c5b934104a43\",\n+            \"630cf18a91cc5a6481ac9eefd65c24b1a3c93396bd7294d6b8ba3239517\" +\n+                \"27666c947a21894a079ef061ee159c05beeb4\",\n+            \"f4c34e5fbe74c0297313268296cd561d59ccc95bbfcdfcdc71b0097dbd83\" +\n+                \"240446b28dc088abd42b0fc687f208190ff24c0548\",\n+            \"dbb93bbb56d0439cd09f620a57687f5d\"),\n+            new Data(\"AES\", \"11754cd72aec309bf52f7687212e8957\",\n+                \"3c819d9a9bed087615030b65\",\n+                (String)null, null, null,\n+                \"250327c674aaf477aef2675748cf6971\"),\n+            new Data(\"AES\", \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                (String)null, null, null,\n+                \"b6e6f197168f5049aeda32dafbdaeb\"),\n+            new Data(\"AES\", \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                in, null,\n+                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n+                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n+                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n+                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n+                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n+                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n+                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n+                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\",\n+                \"08b3593840d4ed005f5234ae062a5c\"),\n+            new Data(\"AES\", \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                inx, null,\n+                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n+                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n+                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n+                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n+                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n+                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n+                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n+                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\" +\n+                \"7364cb53ff6d4e88f928cf67ac70da127718a8a35542efbae9dd7567c818a074\" +\n+                \"9a0c74bd69014639f59768bc55056d1166ea5523e8c66f9d78d980beb8f0d83b\" +\n+                \"a9e2c5544b94dc3a1a4b6f0f95f897b010150e89ebcacf0daee3c2793d6501a0\" +\n+                \"b58b411de273dee987e8e8cf8bb29ef2e7f655b46b55fabf64c6a4295e0d080b\" +\n+                \"6a570ace90eb0fe0f5b5d878bdd90eddaa1150e4d5a6505b350aac814fe99615\" +\n+                \"317ecd0516a464c7904011ef5922409c0d65b1e43b69d7c3293a8f7d3e9fbee9\" +\n+                \"eb91ec0007a7d6f72e64deb675d459c5ba07dcfd58d08e6820b100465e6e04f0\" +\n+                \"663e310584a00d36d23699c1bffc6afa094c75184fc7cde7ad35909c0f49f2f3\" +\n+                \"fe1e6d745ab628d74ea56b757047de57ce18b4b3c71e8af31a6fac16189cb0a3\" +\n+                \"a97a1bea447042ce382fcf726560476d759c24d5c735525ea26a332c2094408e\" +\n+                \"671c7deb81d5505bbfd178f866a6f3a011b3cfdbe089b4957a790688028dfdf7\" +\n+                \"9a096b3853f9d0d6d3feef230c7f5f46ffbf7486ebdaca5804dc5bf9d202415e\" +\n+                \"e0d67b365c2f92a17ea740807e4f0b198b42b54f15faa9dff2c7c35d2cf8d72e\" +\n+                \"b8f8b18875a2e7b5c43d1e0aa5139c461e8153c7f632895aa46ffe2b134e6a0d\" +\n+                \"dfbf6a336e709adfe951bd52c4dfc7b07a15fb3888fc35b7e758922f87a104c4\" +\n+                \"563c5c7839cfe5a7edbdb97264a7c4ebc90367b10cbe09dbf2390767ad7afaa8\" +\n+                \"8fb46b39d3f55f216d2104e5cf040bf3d39b758bea28e2dbce576c808d17a8eb\" +\n+                \"e2fd183ef42a774e39119dff1f539efeb6ad15d889dfcb0d54d0d4d4cc03c8d9\" +\n+                \"aa6c9ebd157f5e7170183298d6a30ada8792dcf793d931e2a1eafccbc63c11c0\" +\n+                \"c5c5ed60837f30017d693ccb294df392a8066a0594a56954aea7b78a16e9a11f\" +\n+                \"4a8bc2104070a7319f5fab0d2c4ccad8ec5cd8f47c839179bfd54a7bf225d502\" +\n+                \"cd0a318752fe763e8c09eb88fa57fc5399ad1f797d0595c7b8afdd23f13603e9\" +\n+                \"6802192bb51433b7723f4e512bd4f799feb94b458e7f9792f5f9bd6733828f70\" +\n+                \"a6b7ffbbc0bb7575021f081ec2a0d37fecd7cda2daec9a3a9d9dfe1c8034cead\" +\n+                \"e4b56b581cc82bd5b74b2b30817967d9da33850336f171a4c68e2438e03f4b11\" +\n+                \"96da92f01b3b7aeab795180ccf40a4b090b1175a1fc0b67c95f93105c3aef00e\" +\n+                \"13d76cc402539192274fee703730cd0d1c5635257719cc96cacdbad00c6255e2\" +\n+                \"bd40c775b43ad09599e84f2c3205d75a6661ca3f151183be284b354ce21457d1\" +\n+                \"3ba65b9b2cdb81874bd14469c2008b3ddec78f7225ecc710cc70de7912ca6a6d\" +\n+                \"348168322ab59fdafcf5c833bfa0ad4046f4b6da90e9f263db7079af592eda07\" +\n+                \"5bf16c6b1a8346da9c292a48bf660860a4fc89eaef40bc132779938eca294569\" +\n+                \"787c740af2b5a8de7f5e10ac750d1e3d0ef3ed168ba408a676e10b8a20bd4be8\" +\n+                \"3e8336b45e54481726d73e1bd19f165a98e242aca0d8387f2dd22d02d74e23db\" +\n+                \"4cef9a523587413e0a44d7e3260019a34d3a6b38426ae9fa4655be338d721970\" +\n+                \"cb9fe76c073f26f9303093a033022cd2c62b2790bce633ba9026a1c93b6535f1\" +\n+                \"1882bf5880e511b9e1b0b7d8f23a993aae5fd275faac3a5b4ccaf7c06b0b266a\" +\n+                \"ee970a1e3a4cd7a41094f516960630534e692545b25a347c30e3f328bba4825f\" +\n+                \"ed754e5525d846131ecba7ca120a6aeabc7bab9f59c890c80b7e31f9bc741591\" +\n+                \"55d292433ce9558e104102f2cc63ee267c1c8333e841522707ea6d595cb802b9\" +\n+                \"61697da77bbc4cb404ea62570ab335ebffa2023730732ac5ddba1c3dbb5be408\" +\n+                \"3c50aea462c1ffa166d7cc3db4b742b747e81b452db2363e91374dee8c6b40f0\" +\n+                \"e7fbf50e60eaf5cc5649f6bb553aae772c185026ceb052af088c545330a1ffbf\" +\n+                \"50615b8c7247c6cd386afd7440654f4e15bcfae0c45442ec814fe88433a9d616\" +\n+                \"ee6cc3f163f0d3d325526d05f25d3b37ad5eeb3ca77248ad86c9042b16c65554\" +\n+                \"aebb6ad3e17b981492b13f42c5a5dc088e991da303e5a273fdbb8601aece4267\" +\n+                \"47b01f6cb972e6da1743a0d7866cf206e95f23c6f8e337c901b9cd34a9a1fbbe\" +\n+                \"1694f2c26b00dfa4d02c0d54540163e798fbdc9c25f30d6406f5b4c13f7ed619\" +\n+                \"34e350f4059c13aa5e973307a9e3058917cda96fdd082e9c629ccfb2a9f98d12\" +\n+                \"5c6e4703a7b0f348f5cdeb63cef2133d1c6c1a087591e0a2bca29d09c6565e66\" +\n+                \"e91042f83b0e74e60a5d57562c23e2fbcd6599c29d7c19e47cf625c2ce24bb8a\" +\n+                \"13f8e54041498437eec2cedd1e3d8e57a051baa962c0a62d70264d99c5ee716d\" +\n+                \"5c8b9078db08c8b2c5613f464198a7aff43f76c5b4612b46a4f1cd2a494386c5\" +\n+                \"7fd28f3d199f0ba8d8e39116cc7db16ce6188205ee49a9dce3d4fa32ea394919\" +\n+                \"f6e91ef58b84d00b99596b4306c2d9f432d917bb4ac73384c42ae12adb4920d8\" +\n+                \"c33a816febcb299dcddf3ec7a8eb6e04cdc90891c6e145bd9fc5f41dc4061a46\" +\n+                \"9feba38545b64ec8203f386ceef52785619e991d274ae80af7e54af535e0b011\" +\n+                \"5effdf847472992875e09398457604d04e0bb965db692c0cdcf11a\",\n+                \"687cc09c89298491deb51061d709af\")));\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":547,"deletions":0,"binary":false,"changes":547,"status":"added"}]}