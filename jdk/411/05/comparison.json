{"files":[{"patch":"@@ -28,4 +28,0 @@\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n@@ -33,0 +29,4 @@\n+import javax.crypto.CipherSpi;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.ShortBufferException;\n@@ -34,0 +34,9 @@\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -414,0 +423,1 @@\n+\n@@ -644,1 +654,0 @@\n-}\n@@ -646,0 +655,22 @@\n+    \/**\n+     * Finalize crypto operation with ByteBuffers\n+     *\n+     * @param input the input ByteBuffer\n+     * @param output the output ByteBuffer\n+     *\n+     * @return output length\n+     * @throws ShortBufferException\n+     * @throws IllegalBlockSizeException\n+     * @throws BadPaddingException\n+     *\/\n+    @Override\n+    protected int engineDoFinal(ByteBuffer input, ByteBuffer output)\n+        throws ShortBufferException, IllegalBlockSizeException,\n+        BadPaddingException {\n+        if (core.getMode() == CipherCore.GCM_MODE && !input.hasArray()) {\n+            return core.gcmDoFinal(input, output);\n+        } else {\n+            return super.engineDoFinal(input, output);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -725,2 +726,1 @@\n-        if ((output == null) ||\n-            ((output.length - outputOffset) < len)) {\n+        if (output == null || (output.length - outputOffset) < len) {\n@@ -920,1 +920,1 @@\n-        int offset = decrypting ? 0 : outputOffset; \/\/ 0 for decrypting\n+        int offset = outputOffset;\n@@ -923,1 +923,1 @@\n-        byte[] outWithPadding = null; \/\/ for decrypting only\n+        byte[] internalOutput = null; \/\/ for decrypting only\n@@ -937,3 +937,6 @@\n-            \/\/ create temporary output buffer so that only \"real\"\n-            \/\/ data bytes are passed to user's output buffer.\n-            outWithPadding = new byte[estOutSize];\n+            if (getMode() != GCM_MODE || outputCapacity < estOutSize) {\n+                \/\/ create temporary output buffer if the estimated size is larger\n+                \/\/ than the user-provided buffer.\n+                internalOutput = new byte[estOutSize];\n+                offset = 0;\n+            }\n@@ -941,1 +944,1 @@\n-        byte[] outBuffer = decrypting ? outWithPadding : output;\n+        byte[] outBuffer = (internalOutput != null) ? internalOutput : output;\n@@ -957,3 +960,5 @@\n-            System.arraycopy(outWithPadding, 0, output, outputOffset, outLen);\n-            \/\/ decrypt mode. Zero out output data that's not required\n-            Arrays.fill(outWithPadding, (byte) 0x00);\n+            if (internalOutput != null) {\n+                System.arraycopy(internalOutput, 0, output, outputOffset, outLen);\n+                \/\/ decrypt mode. Zero out output data that's not required\n+                Arrays.fill(internalOutput, (byte) 0x00);\n+            }\n@@ -973,1 +978,1 @@\n-    private int unpad(int outLen, byte[] outWithPadding)\n+    private int unpad(int outLen, int off, byte[] outWithPadding)\n@@ -975,1 +980,1 @@\n-        int padStart = padding.unpad(outWithPadding, 0, outLen);\n+        int padStart = padding.unpad(outWithPadding, off, outLen);\n@@ -981,2 +986,1 @@\n-        outLen = padStart;\n-        return outLen;\n+        return padStart - off;\n@@ -1058,1 +1062,1 @@\n-                len = unpad(len, output);\n+                len = unpad(len, outOfs, output);\n@@ -1228,0 +1232,23 @@\n+\n+    \/\/ This must only be used with GCM.\n+    \/\/ If some data has been buffered from an update call, operate on the buffer\n+    \/\/ then run doFinal.\n+    int gcmDoFinal(ByteBuffer src, ByteBuffer dst) throws ShortBufferException,\n+        IllegalBlockSizeException, BadPaddingException {\n+        int estOutSize = getOutputSizeByOperation(src.remaining(), true);\n+        if (estOutSize > dst.remaining()) {\n+            throw new ShortBufferException(\"output buffer too small\");\n+        }\n+\n+        if (decrypting) {\n+            if (buffered > 0) {\n+                cipher.decrypt(buffer, 0, buffered, new byte[0], 0);\n+            }\n+            return cipher.decryptFinal(src, dst);\n+        } else {\n+            if (buffered > 0) {\n+                ((GaloisCounterMode)cipher).encrypt(buffer, 0, buffered);\n+            }\n+            return cipher.encryptFinal(src, dst);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -245,0 +246,23 @@\n+\n+    \/*\n+     * ByteBuffer methods should not be accessed as CipherCore and AESCipher\n+     * copy the data to byte arrays.  These methods are to satisfy the compiler.\n+     *\/\n+    int encrypt(ByteBuffer src, ByteBuffer dst) {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    };\n+\n+    int decrypt(ByteBuffer src, ByteBuffer dst) {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    };\n+\n+    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, ShortBufferException {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    };\n+\n+    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, AEADBadTagException,\n+        ShortBufferException {\n+        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    private static final int MAX_LEN = 1024;\n+\n@@ -60,2 +63,3 @@\n-            throw new RuntimeException(\"length of initial counter block (\" + initialCounterBlk.length +\n-                                       \") not equal to AES_BLOCK_SIZE (\" + AES_BLOCK_SIZE + \")\");\n+            throw new RuntimeException(\"length of initial counter block (\" +\n+                initialCounterBlk.length + \") not equal to AES_BLOCK_SIZE (\" +\n+                AES_BLOCK_SIZE + \")\");\n@@ -115,0 +119,80 @@\n+    \/\/ input must be multiples of AES blocks, 128-bit, when calling update\n+    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        if (inLen - inOfs > in.length) {\n+            throw new RuntimeException(\"input length out of bound\");\n+        }\n+        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+            throw new RuntimeException(\"input length unsupported\");\n+        }\n+        \/\/ See GaloisCounterMode. decryptFinal(bytebuffer, bytebuffer) for\n+        \/\/ details on the check for 'dst' having enough space for the result.\n+\n+        long blocksLeft = blocksUntilRollover();\n+        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        if (numOfCompleteBlocks >= blocksLeft) {\n+            \/\/ Counter Mode encryption cannot be used because counter will\n+            \/\/ roll over incorrectly. Use GCM-specific code instead.\n+            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            for (int i = 0; i < numOfCompleteBlocks; i++) {\n+                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n+                    int index = (i * AES_BLOCK_SIZE + n);\n+                    dst.put((byte) ((in[inOfs + index] ^ encryptedCntr[n])));\n+                }\n+                GaloisCounterMode.increment32(counter);\n+            }\n+            return inLen;\n+        } else {\n+            int len = inLen - inLen % AES_BLOCK_SIZE;\n+            int processed = len;\n+            byte[] out = new byte[Math.min(MAX_LEN, len)];\n+            int offset = inOfs;\n+            while (processed > MAX_LEN) {\n+                encrypt(in, offset, MAX_LEN, out, 0);\n+                dst.put(out, 0, MAX_LEN);\n+                processed -= MAX_LEN;\n+                offset += MAX_LEN;\n+            }\n+            encrypt(in, offset, processed, out, 0);\n+            \/\/ If dst is less than blocksize, insert only what it can.  Extra\n+            \/\/ bytes would cause buffers with enough size to fail with a\n+            \/\/ short buffer\n+            dst.put(out, 0, Math.min(dst.remaining(), processed));\n+            return len;\n+        }\n+    }\n+\n+    \/\/ input operates on multiples of AES blocks, 128-bit, when calling update.\n+    \/\/ The remainder is left in the src buffer.\n+    int update(ByteBuffer src, ByteBuffer dst) {\n+        long blocksLeft = blocksUntilRollover();\n+        int numOfCompleteBlocks = src.remaining() \/ AES_BLOCK_SIZE;\n+        if (numOfCompleteBlocks >= blocksLeft) {\n+            \/\/ Counter Mode encryption cannot be used because counter will\n+            \/\/ roll over incorrectly. Use GCM-specific code instead.\n+            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            for (int i = 0; i < numOfCompleteBlocks; i++) {\n+                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n+                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                }\n+                GaloisCounterMode.increment32(counter);\n+            }\n+            return numOfCompleteBlocks * AES_BLOCK_SIZE;\n+        }\n+\n+        int len = src.remaining() - (src.remaining() % AES_BLOCK_SIZE);\n+        int processed = len;\n+        byte[] in = new byte[Math.min(MAX_LEN, len)];\n+        while (processed > MAX_LEN) {\n+            src.get(in, 0, MAX_LEN);\n+            encrypt(in, 0, MAX_LEN, in, 0);\n+            dst.put(in, 0, MAX_LEN);\n+            processed -= MAX_LEN;\n+        }\n+        src.get(in, 0, processed);\n+        encrypt(in, 0, processed, in, 0);\n+        dst.put(in, 0, processed);\n+        return len;\n+    }\n+\n@@ -117,1 +201,1 @@\n-                          int outOfs) throws IllegalBlockSizeException {\n+        int outOfs) throws IllegalBlockSizeException {\n@@ -133,1 +217,1 @@\n-                                     encryptedCntr[n]));\n+                                encryptedCntr[n]));\n@@ -142,0 +226,20 @@\n+\n+    \/\/ src can be arbitrary size when calling doFinal\n+    int doFinal(ByteBuffer src, ByteBuffer dst) {\n+        int len = src.remaining();\n+        int lastBlockSize = len % AES_BLOCK_SIZE;\n+        try {\n+            update(src, dst);\n+            if (lastBlockSize != 0) {\n+                \/\/ do the last partial block\n+                byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n+                for (int n = 0; n < lastBlockSize; n++) {\n+                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                }\n+            }\n+        } finally {\n+            reset();\n+        }\n+        return len;\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":109,"deletions":5,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.ByteBuffer;\n@@ -201,0 +202,32 @@\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    private static final int MAX_LEN = 1024;\n+\n+    \/\/ Will process as many blocks it can and will leave the remaining.\n+    int update(ByteBuffer src, int inLen) {\n+        inLen -= (inLen % AES_BLOCK_SIZE);\n+        if (inLen == 0) {\n+            return 0;\n+        }\n+\n+        int processed = inLen;\n+        byte[] in = new byte[Math.min(MAX_LEN, inLen)];\n+        while (processed > MAX_LEN ) {\n+            src.get(in, 0, MAX_LEN);\n+            update(in, 0 , MAX_LEN);\n+            processed -= MAX_LEN;\n+        }\n+        src.get(in, 0, processed);\n+        update(in, 0, processed);\n+        return inLen;\n+    }\n+\n+    void doLastBlock(ByteBuffer src, int inLen) {\n+        int processed = update(src, inLen);\n+        if (inLen == processed) {\n+            return;\n+        }\n+        byte[] block = new byte[AES_BLOCK_SIZE];\n+        src.get(block, 0, inLen - processed);\n+        update(block, 0, AES_BLOCK_SIZE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import java.util.Arrays;\n-import java.io.*;\n-import java.security.*;\n-import javax.crypto.*;\n-import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n+import sun.nio.ch.DirectBuffer;\n@@ -35,0 +31,12 @@\n+import javax.crypto.AEADBadTagException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.ShortBufferException;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.ProviderException;\n+\n+import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n+\n@@ -71,1 +79,1 @@\n-    \/\/ buffer for storing input in decryption, not used for encryption\n+    \/\/ buffer data for crypto operation\n@@ -74,0 +82,3 @@\n+    \/\/ Original dst buffer if there was an overlap situation\n+    private ByteBuffer originalDst = null;\n+\n@@ -180,2 +191,11 @@\n-    private static void checkDataLength(int processed, int len) {\n-        if (processed > MAX_BUF_SIZE - len) {\n+    \/**\n+     * Calculate if the given data lengths and the already processed data\n+     * exceeds the maximum allowed processed data by GCM.\n+     * @param lengths lengths of unprocessed data.\n+     *\/\n+    private void checkDataLength(int ... lengths) {\n+        int max = MAX_BUF_SIZE;\n+        for (int len : lengths) {\n+            max = Math.subtractExact(max, len);\n+        }\n+        if (processed > max) {\n@@ -429,0 +449,58 @@\n+    \/\/ Process en\/decryption all the way to the last block.  It takes both\n+    \/\/ For input it takes the ibuffer which is wrapped in 'buffer' and 'src'\n+    \/\/ from doFinal.\n+    void doLastBlock(ByteBuffer buffer, ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException {\n+\n+        if (buffer != null && buffer.remaining() > 0) {\n+            \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n+            processed += gctrPAndC.update(buffer, dst);\n+\n+            \/\/ Process the remainder in the buffer\n+            if (buffer.remaining() > 0) {\n+                \/\/ Copy the remainder of the buffer into the extra block\n+                byte[] block = new byte[AES_BLOCK_SIZE];\n+                int over = buffer.remaining();\n+                int len = over;  \/\/ how much is processed by in the extra block\n+                buffer.get(block, 0, over);\n+\n+                \/\/ if src is empty, update the final block and wait for later\n+                \/\/ to finalize operation\n+                if (src.remaining() > 0) {\n+                    \/\/ Fill out block with what is in data\n+                    if (src.remaining() > AES_BLOCK_SIZE - over) {\n+                        src.get(block, over, AES_BLOCK_SIZE - over);\n+                        len += AES_BLOCK_SIZE - over;\n+                    } else {\n+                        \/\/ If the remaining in buffer + data does not fill a\n+                        \/\/ block, complete the ghash operation\n+                        int l = src.remaining();\n+                        src.get(block, over, l);\n+                        len += l;\n+                    }\n+                }\n+                gctrPAndC.update(block, 0, AES_BLOCK_SIZE, dst);\n+                processed += len;\n+            }\n+        }\n+\n+        \/\/ en\/decrypt whatever remains in src.\n+        \/\/ If src has been consumed, this will be a no-op\n+        processed += gctrPAndC.doFinal(src, dst);\n+    }\n+\n+     \/*\n+     * This method is for CipherCore to insert the remainder of its buffer\n+     * into the ibuffer before a doFinal(ByteBuffer, ByteBuffer) operation\n+     *\/\n+    int encrypt(byte[] in, int inOfs, int len) {\n+        if (len > 0) {\n+            \/\/ store internally until encryptFinal\n+            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n+            if (ibuffer == null) {\n+                ibuffer = new ByteArrayOutputStream();\n+            }\n+            ibuffer.write(in, inOfs, len);\n+        }\n+        return len;\n+    }\n@@ -439,1 +517,1 @@\n-     * @param len the length of the input data\n+     * @param inLen the length of the input data\n@@ -442,2 +520,0 @@\n-     * @exception ProviderException if <code>len<\/code> is not\n-     * a multiple of the block size\n@@ -446,4 +522,4 @@\n-    int encrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n-        ArrayUtil.blockSizeCheck(len, blockSize);\n-\n-        checkDataLength(processed, len);\n+    int encrypt(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        checkDataLength(inLen, getBufferedLength());\n+        ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n+        ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n@@ -452,0 +528,18 @@\n+        \/\/ 'inLen' stores the length to use with buffer 'in'.\n+        \/\/ 'len' stores the length returned by the method.\n+        int len = inLen;\n+\n+        \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+        if (ibuffer != null && ibuffer.size() > 0) {\n+            byte[] buffer = ibuffer.toByteArray();\n+            \/\/ number of bytes not filling a block\n+            int remainder = ibuffer.size() % blockSize;\n+            \/\/ number of bytes along block boundary\n+            int blen = ibuffer.size() - remainder;\n+\n+            \/\/ If there is enough bytes in ibuffer for a block or more,\n+            \/\/ encrypt that first.\n+            if (blen > 0) {\n+                encryptBlocks(buffer, 0, blen, out, outOfs);\n+                outOfs += blen;\n+            }\n@@ -453,3 +547,42 @@\n-        if (len > 0) {\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs, len);\n+            \/\/ blen is now the offset for 'buffer'\n+\n+            \/\/ Construct and encrypt a block if there is enough 'buffer' and\n+            \/\/ 'in' to make one\n+            if ((inLen + remainder) >= blockSize) {\n+                byte[] block = new byte[blockSize];\n+\n+                System.arraycopy(buffer, blen, block, 0, remainder);\n+                int inLenUsed = blockSize - remainder;\n+                System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n+\n+                encryptBlocks(block, 0, blockSize, out, outOfs);\n+                inOfs += inLenUsed;\n+                inLen -= inLenUsed;\n+                len += (blockSize - inLenUsed);\n+                outOfs += blockSize;\n+                ibuffer.reset();\n+                \/\/ Code below will write the remainder from 'in' to ibuffer\n+            } else if (remainder > 0) {\n+                \/\/ If a block or more was encrypted from 'buffer' only, but the\n+                \/\/ rest of 'buffer' with 'in' could not construct a block, then\n+                \/\/ put the rest of 'buffer' back into ibuffer.\n+                ibuffer.reset();\n+                ibuffer.write(buffer, blen, remainder);\n+                \/\/ Code below will write the remainder from 'in' to ibuffer\n+            }\n+            \/\/ If blen == 0 and there was not enough to construct a block\n+            \/\/ from 'buffer' and 'in', then let the below code append 'in' to\n+            \/\/ the ibuffer.\n+        }\n+\n+        \/\/ Write any remaining bytes outside the blockSize into ibuffer.\n+        int remainder = inLen % blockSize;\n+        if (remainder > 0) {\n+            if (ibuffer == null) {\n+                ibuffer = new ByteArrayOutputStream(inLen % blockSize);\n+            }\n+            len -= remainder;\n+            inLen -= remainder;\n+            \/\/ remainder offset is based on original buffer length\n+            ibuffer.write(in, inOfs + inLen, remainder);\n+        }\n@@ -457,3 +590,3 @@\n-            gctrPAndC.update(in, inOfs, len, out, outOfs);\n-            processed += len;\n-            ghashAllToS.update(out, outOfs, len);\n+        \/\/ Encrypt the remaining blocks inside of 'in'\n+        if (inLen > 0) {\n+            encryptBlocks(in, inOfs, inLen, out, outOfs);\n@@ -465,0 +598,6 @@\n+    void encryptBlocks(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n+        gctrPAndC.update(in, inOfs, len, out, outOfs);\n+        processed += len;\n+        ghashAllToS.update(out, outOfs, len);\n+    }\n+\n@@ -477,4 +616,2 @@\n-        if (len > MAX_BUF_SIZE - tagLenBytes) {\n-            throw new ShortBufferException\n-                (\"Can't fit both data and tag into one buffer\");\n-        }\n+        checkDataLength(len, getBufferedLength(), tagLenBytes);\n+\n@@ -488,2 +625,0 @@\n-        checkDataLength(processed, len);\n-\n@@ -497,5 +632,3 @@\n-        byte[] lengthBlock =\n-            getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(lengthBlock);\n-        byte[] s = ghashAllToS.digest();\n-        byte[] sOut = new byte[s.length];\n+        byte[] block = getLengthBlock(sizeOfAAD, processed);\n+        ghashAllToS.update(block);\n+        block = ghashAllToS.digest();\n@@ -503,1 +636,34 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+\n+        System.arraycopy(block, 0, out, (outOfs + len), tagLenBytes);\n+        return (len + tagLenBytes);\n+    }\n+\n+    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, ShortBufferException {\n+        dst = overlapDetection(src, dst);\n+        int len = src.remaining();\n+        len += getBufferedLength();\n+\n+        \/\/ 'len' includes ibuffer data\n+        checkDataLength(len, tagLenBytes);\n+        dst.mark();\n+        if (dst.remaining() < len + tagLenBytes) {\n+            throw new ShortBufferException(\"Output buffer too small\");\n+        }\n+\n+        processAAD();\n+        if (len > 0) {\n+            doLastBlock((ibuffer == null || ibuffer.size() == 0) ?\n+                    null : ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n+            dst.reset();\n+            ghashAllToS.doLastBlock(dst, len);\n+        }\n+\n+        byte[] block = getLengthBlock(sizeOfAAD, processed);\n+        ghashAllToS.update(block);\n+        block = ghashAllToS.digest();\n+        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+        dst.put(block, 0, tagLenBytes);\n+        restoreDst(dst);\n@@ -505,1 +671,0 @@\n-        System.arraycopy(sOut, 0, out, (outOfs + len), tagLenBytes);\n@@ -527,4 +692,0 @@\n-        ArrayUtil.blockSizeCheck(len, blockSize);\n-\n-        checkDataLength(ibuffer.size(), len);\n-\n@@ -543,0 +704,13 @@\n+    int decrypt(ByteBuffer src, ByteBuffer dst) {\n+        if (src.remaining() > 0) {\n+            byte[] b = new byte[src.remaining()];\n+            src.get(b);\n+            try {\n+                ibuffer.write(b);\n+            } catch (IOException e) {\n+                throw new ProviderException(\"Unable to add remaining input to the buffer\", e);\n+            }\n+        }\n+        return 0;\n+    }\n+\n@@ -569,1 +743,1 @@\n-        checkDataLength(ibuffer.size(), (len - tagLenBytes));\n+        checkDataLength(getBufferedLength(), (len - tagLenBytes));\n@@ -573,1 +747,1 @@\n-                (ibuffer.size() + len) - tagLenBytes);\n+                (getBufferedLength() + len) - tagLenBytes);\n@@ -589,1 +763,1 @@\n-        if (in == out || ibuffer.size() > 0) {\n+        if (in == out || getBufferedLength() > 0) {\n@@ -605,6 +779,3 @@\n-        byte[] lengthBlock =\n-            getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(lengthBlock);\n-\n-        byte[] s = ghashAllToS.digest();\n-        byte[] sOut = new byte[s.length];\n+        byte[] block = getLengthBlock(sizeOfAAD, processed);\n+        ghashAllToS.update(block);\n+        block = ghashAllToS.digest();\n@@ -612,1 +783,1 @@\n-        gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n@@ -617,1 +788,1 @@\n-            mismatch |= tag[i] ^ sOut[i];\n+            mismatch |= tag[i] ^ block[i];\n@@ -627,0 +798,116 @@\n+    \/\/ Note: In-place operations do not need an intermediary copy because\n+    \/\/ the GHASH check was performed before the decryption.\n+    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n+        throws IllegalBlockSizeException, AEADBadTagException,\n+        ShortBufferException {\n+\n+        dst = overlapDetection(src, dst);\n+        \/\/ Length of the input\n+        ByteBuffer tag;\n+        ByteBuffer ct = src.duplicate();\n+\n+        ByteBuffer buffer = ((ibuffer == null || ibuffer.size() == 0) ? null :\n+            ByteBuffer.wrap(ibuffer.toByteArray()));\n+        int len;\n+\n+        if (ct.remaining() >= tagLenBytes) {\n+            tag = src.duplicate();\n+            tag.position(ct.limit() - tagLenBytes);\n+            ct.limit(ct.limit() - tagLenBytes);\n+            len = ct.remaining();\n+            if (buffer != null) {\n+                len += buffer.remaining();\n+            }\n+        } else if (buffer != null && ct.remaining() < tagLenBytes) {\n+            \/\/ It's unlikely the tag will be between the buffer and data\n+            tag = ByteBuffer.allocate(tagLenBytes);\n+            int limit = buffer.remaining() - (tagLenBytes - ct.remaining());\n+            buffer.mark();\n+            buffer.position(limit);\n+            \/\/ Read from \"new\" limit to buffer's end\n+            tag.put(buffer);\n+            \/\/ reset buffer to data only\n+            buffer.reset();\n+            buffer.limit(limit);\n+            tag.put(ct);\n+            tag.flip();\n+            \/\/ Limit is how much of the ibuffer has been chopped off.\n+            len = buffer.remaining();\n+        } else {\n+            throw new AEADBadTagException(\"Input too short - need tag\");\n+        }\n+\n+        \/\/ 'len' contains the length in ibuffer and src\n+        checkDataLength(len);\n+\n+        if (len > dst.remaining()) {\n+            throw new ShortBufferException(\"Output buffer too small\");\n+        }\n+\n+        processAAD();\n+        \/\/ Set the mark for a later reset. Either it will be zero, or the tag\n+        \/\/ buffer creation above will have consume some or all of it.\n+        ct.mark();\n+\n+        \/\/ If there is data stored in the buffer\n+        if (buffer != null && buffer.remaining() > 0) {\n+            ghashAllToS.update(buffer, buffer.remaining());\n+            \/\/ Process the overage\n+            if (buffer.remaining() > 0) {\n+                \/\/ Fill out block between two buffers\n+                if (ct.remaining() > 0) {\n+                    int over = buffer.remaining();\n+                    byte[] block = new byte[AES_BLOCK_SIZE];\n+                    \/\/ Copy the remainder of the buffer into the extra block\n+                    buffer.get(block, 0, over);\n+\n+                    \/\/ Fill out block with what is in data\n+                    if (ct.remaining() > AES_BLOCK_SIZE - over) {\n+                        ct.get(block, over, AES_BLOCK_SIZE - over);\n+                        ghashAllToS.update(block, 0, AES_BLOCK_SIZE);\n+                    } else {\n+                        \/\/ If the remaining in buffer + data does not fill a\n+                        \/\/ block, complete the ghash operation\n+                        int l = ct.remaining();\n+                        ct.get(block, over, l);\n+                        ghashAllToS.doLastBlock(ByteBuffer.wrap(block), over + l);\n+                    }\n+                } else {\n+                    \/\/ data is empty, so complete the ghash op with the\n+                    \/\/ remaining buffer\n+                    ghashAllToS.doLastBlock(buffer, buffer.remaining());\n+                }\n+            }\n+            \/\/ Prepare buffer for decryption\n+            buffer.flip();\n+        }\n+\n+        if (ct.remaining() > 0) {\n+            ghashAllToS.doLastBlock(ct, ct.remaining());\n+        }\n+        \/\/ Prepare buffer for decryption if available\n+        ct.reset();\n+\n+        byte[] block = getLengthBlock(sizeOfAAD, len);\n+        ghashAllToS.update(block);\n+        block = ghashAllToS.digest();\n+        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n+        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+\n+        \/\/ check entire authentication tag for time-consistency\n+        int mismatch = 0;\n+        for (int i = 0; i < tagLenBytes; i++) {\n+            mismatch |= tag.get() ^ block[i];\n+        }\n+\n+        if (mismatch != 0) {\n+            throw new AEADBadTagException(\"Tag mismatch!\");\n+        }\n+\n+        \/\/ Decrypt the all the input data and put it into dst\n+        doLastBlock(buffer, ct, dst);\n+        restoreDst(dst);\n+        \/\/ 'processed' from the gctr decryption operation, not ghash\n+        return processed;\n+    }\n+\n@@ -639,0 +926,90 @@\n+\n+    \/**\n+     * Check for overlap. If the src and dst buffers are using shared data and\n+     * if dst will overwrite src data before src can be processed.  If so, make\n+     * a copy to put the dst data in.\n+     *\/\n+    ByteBuffer overlapDetection(ByteBuffer src, ByteBuffer dst) {\n+        if (src.isDirect() && dst.isDirect()) {\n+            DirectBuffer dsrc = (DirectBuffer) src;\n+            DirectBuffer ddst = (DirectBuffer) dst;\n+\n+            \/\/ Get the current memory address for the given ByteBuffers\n+            long srcaddr = dsrc.address();\n+            long dstaddr = ddst.address();\n+\n+            \/\/ Find the lowest attachment that is the base memory address of the\n+            \/\/ shared memory for the src object\n+            while (dsrc.attachment() != null) {\n+                srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                dsrc = (DirectBuffer) dsrc.attachment();\n+            }\n+\n+            \/\/ Find the lowest attachment that is the base memory address of the\n+            \/\/ shared memory for the dst object\n+            while (ddst.attachment() != null) {\n+                dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                ddst = (DirectBuffer) ddst.attachment();\n+            }\n+\n+            \/\/ If the base addresses are not the same, there is no overlap\n+            if (srcaddr != dstaddr) {\n+                return dst;\n+            }\n+            \/\/ At this point we know these objects share the same memory.\n+            \/\/ This checks the starting position of the src and dst address for\n+            \/\/ overlap.\n+            \/\/ It uses the base address minus the passed object's address to get\n+            \/\/ the offset from the base address, then add the position() from\n+            \/\/ the passed object.  That gives up the true offset from the base\n+            \/\/ address.  As long as the src side is >= the dst side, we are not\n+            \/\/ in overlap.\n+            if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n+                ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                return dst;\n+            }\n+\n+        } else if (!src.isDirect() && !dst.isDirect()) {\n+            if (!src.isReadOnly()) {\n+                \/\/ If using the heap, check underlying byte[] address.\n+                if (!src.array().equals(dst.array()) ) {\n+                    return dst;\n+                }\n+\n+                \/\/ Position plus arrayOffset() will give us the true offset from\n+                \/\/ the underlying byte[] address.\n+                if (src.position() + src.arrayOffset() >=\n+                    dst.position() + dst.arrayOffset()) {\n+                    return dst;\n+                }\n+            }\n+        } else {\n+            \/\/ buffer types aren't the same\n+            return dst;\n+        }\n+\n+        \/\/ Create a copy\n+        ByteBuffer tmp = dst.duplicate();\n+        \/\/ We can use a heap buffer for internal use, save on alloc cost\n+        ByteBuffer bb = ByteBuffer.allocate(dst.remaining());\n+        tmp.limit(dst.limit());\n+        tmp.position(dst.position());\n+        bb.put(tmp);\n+        bb.flip();\n+        originalDst = dst;\n+        return bb;\n+    }\n+\n+    \/**\n+     * If originalDst exists, dst is an internal dst buffer, then copy the data\n+     * into the original dst buffer\n+     *\/\n+    void restoreDst(ByteBuffer dst) {\n+        if (originalDst == null) {\n+            return;\n+        }\n+\n+        dst.flip();\n+        originalDst.put(dst);\n+        originalDst = null;\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":426,"deletions":49,"binary":false,"changes":475,"status":"modified"},{"patch":"@@ -0,0 +1,851 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Use Cipher update and doFinal with a mixture of byte[], bytebuffer,\n+ * and offset while verifying return values.  Also using different and\n+ * in-place buffers.\n+ *\n+ * in-place is not tested with different buffer types as it is not a logical\n+ * scenario and is complicated by getOutputSize calculations.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+public class GCMBufferTest implements Cloneable {\n+\n+    \/\/ Data type for the operation\n+    enum dtype { BYTE, HEAP, DIRECT };\n+    \/\/ Data map\n+    static HashMap<String, List<Data>> datamap = new HashMap<>();\n+    \/\/ List of enum values for order of operation\n+    List<dtype> ops;\n+\n+    static final int AESBLOCK = 16;\n+    \/\/ The remaining input data length is inserted at the particular index\n+    \/\/ in sizes[] during execution.\n+    static final int REMAINDER = -1;\n+\n+    String algo;\n+    boolean same = true;\n+    int[] sizes;\n+    boolean incremental = false;\n+    \/\/ In some cases the theoretical check is too complicated to verify\n+    boolean theoreticalCheck;\n+    List<Data> dataSet;\n+    int inOfs = 0, outOfs = 0;\n+\n+    static class Data {\n+        int id;\n+        SecretKey key;\n+        byte[] iv;\n+        byte[] pt;\n+        byte[] aad;\n+        byte[] ct;\n+        byte[] tag;\n+\n+        Data(String keyalgo, int id, String key, String iv, byte[] pt, String aad,\n+            String ct, String tag) {\n+            this.id = id;\n+            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n+            this.iv = HexToBytes(iv);\n+            this.pt = pt;\n+            this.aad = HexToBytes(aad);\n+            this.ct = HexToBytes(ct);\n+            this.tag = HexToBytes(tag);\n+        }\n+\n+        Data(String keyalgo, int id, String key, String iv, String pt, String aad,\n+            String ct, String tag) {\n+            this(keyalgo, id, key, iv, HexToBytes(pt), aad, ct, tag);\n+        }\n+\n+        Data(String keyalgo, int id, String key, int ptlen) {\n+            this.id = id;\n+            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n+            iv = new byte[16];\n+            pt = new byte[ptlen];\n+            tag = new byte[12];\n+            aad = new byte[0];\n+            byte[] tct = null;\n+            try {\n+                SecureRandom r = new SecureRandom();\n+                r.nextBytes(iv);\n+                r.nextBytes(pt);\n+                Cipher c = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                c.init(Cipher.ENCRYPT_MODE, this.key,\n+                    new GCMParameterSpec(tag.length * 8, this.iv));\n+                tct = c.doFinal(pt);\n+            } catch (Exception e) {\n+                System.out.println(\"Error in generating data for length \" +\n+                    ptlen);\n+            }\n+            ct = new byte[ptlen];\n+            System.arraycopy(tct, 0, ct, 0, ct.length);\n+            System.arraycopy(tct, ct.length, tag, 0, tag.length);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Construct a test with an algorithm and a list of dtype.\n+     * @param algo Algorithm string\n+     * @param ops List of dtypes.  If only one dtype is specified, only a\n+     *            doFinal operation will occur.  If multiple dtypes are\n+     *            specified, the last is a doFinal, the others are updates.\n+     *\/\n+    GCMBufferTest(String algo, List<dtype> ops) {\n+        this.algo = algo;\n+        this.ops = ops;\n+        theoreticalCheck = true;\n+        dataSet = datamap.get(algo);\n+    }\n+\n+    public GCMBufferTest clone() throws CloneNotSupportedException{\n+        return (GCMBufferTest)super.clone();\n+    }\n+\n+    \/**\n+     * Define particular data sizes to be tested.  \"REMAINDER\", which has a\n+     * value of -1, can be used to insert the remaining input text length at\n+     * that index during execution.\n+     * @param sizes Data sizes for each dtype in the list.\n+     *\/\n+    GCMBufferTest dataSegments(int[] sizes) {\n+        this.sizes = sizes;\n+        return this;\n+    }\n+\n+    \/**\n+     * Do not perform in-place operations\n+     *\/\n+    GCMBufferTest differentBufferOnly() {\n+        this.same = false;\n+        return this;\n+    }\n+\n+    \/**\n+     * Enable incrementing through each data size available.  This can only be\n+     * used when the List has more than one dtype entry.\n+     *\/\n+    GCMBufferTest incrementalSegments() {\n+        this.incremental = true;\n+        return this;\n+    }\n+\n+    \/**\n+     * Specify a particular test dataset.\n+     *\n+     * @param id id value for the test data to used in this test.\n+     *\/\n+    GCMBufferTest dataSet(int id) throws Exception {\n+        for (Data d : datamap.get(algo)) {\n+            if (d.id == id) {\n+                dataSet = List.of(d);\n+                return this;\n+            }\n+        }\n+        throw new Exception(\"Unaeble to find dataSet id = \" + id);\n+    }\n+\n+    \/**\n+     * Set both input and output offsets to the same offset\n+     * @param offset value for inOfs and outOfs\n+     * @return\n+     *\/\n+    GCMBufferTest offset(int offset) {\n+        this.inOfs = offset;\n+        this.outOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the input offset\n+     * @param offset value for input offset\n+     * @return\n+     *\/\n+    GCMBufferTest inOfs(int offset) {\n+        this.inOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the output offset\n+     * @param offset value for output offset\n+     * @return\n+     *\/\n+    GCMBufferTest outOfs(int offset) {\n+        this.outOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Reverse recursive loop that starts at the end-1 index, going to 0, in\n+     * the size array to calculate all the possible sizes.\n+     * It returns the remaining data size not used in the loop.  This remainder\n+     * is used for the end index which is the doFinal op.\n+     *\/\n+    int inc(int index, int max, int total) {\n+        if (sizes[index] == max - total) {\n+            sizes[index + 1]++;\n+            total++;\n+            sizes[index] = 0;\n+        } else if (index == 0) {\n+            sizes[index]++;\n+        }\n+\n+        total += sizes[index];\n+        if (index > 0) {\n+            return inc(index - 1, max, total);\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Call recursive loop and take returned remainder value for last index\n+    boolean incrementSizes(int max) {\n+        sizes[ops.size() - 1] = max - inc(ops.size() - 2, max, 0);\n+        if (sizes[ops.size() - 2] == max) {\n+            \/\/ We are at the end, exit test loop\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void test() throws Exception {\n+        int i = 1;\n+        System.out.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n+        for (Data data : dataSet) {\n+\n+            \/\/ If incrementalSegments is enabled, run through that test only\n+            if (incremental) {\n+                if (ops.size() < 2) {\n+                    throw new Exception(\"To do incrementalSegments you must\" +\n+                        \"have more that 1 dtype in the list\");\n+                }\n+                sizes = new int[ops.size()];\n+\n+                while (incrementSizes(data.pt.length)) {\n+                    System.out.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    for (int v : sizes) {\n+                        System.out.print(v + \" \");\n+                    }\n+                    System.out.println(\"]\");\n+                    encrypt(data);\n+                }\n+                Arrays.fill(sizes, 0);\n+\n+                while (incrementSizes(data.ct.length + data.tag.length)) {\n+                    System.out.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    for (int v : sizes) {\n+                        System.out.print(v + \" \");\n+                    }\n+                    System.out.println(\"]\");\n+                    decrypt(data);\n+                }\n+\n+            } else {\n+                \/\/ Default test of 0 and 2 offset doing in place and different\n+                \/\/ i\/o buffers\n+                System.out.println(\"Encrypt:  Data Index: \" + i);\n+                encrypt(data);\n+\n+                System.out.println(\"Decrypt:  Data Index: \" + i);\n+                decrypt(data);\n+            }\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Setup data for encryption\n+    void encrypt(Data data) throws Exception {\n+        byte[] input, output;\n+\n+        input = data.pt;\n+        output = new byte[data.ct.length + data.tag.length];\n+        System.arraycopy(data.ct, 0, output, 0, data.ct.length);\n+        System.arraycopy(data.tag, 0, output, data.ct.length,\n+            data.tag.length);\n+\n+        \/\/ Test different input\/output buffers\n+        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n+        crypto(true, data, input, output);\n+\n+        \/\/ Test with in-place buffers\n+        if (same) {\n+            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: in-place\");\n+            cryptoSameBuffer(true, data, input, output);\n+        }\n+    }\n+\n+    \/\/ Setup data for decryption\n+    void decrypt(Data data) throws Exception {\n+        byte[] input, output;\n+\n+        input = new byte[data.ct.length + data.tag.length];\n+        System.arraycopy(data.ct, 0, input, 0, data.ct.length);\n+        System.arraycopy(data.tag, 0, input, data.ct.length, data.tag.length);\n+        output = data.pt;\n+\n+        \/\/ Test different input\/output buffers\n+        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in-place: different\");\n+        crypto(false, data, input, output);\n+\n+        \/\/ Test with in-place buffers\n+        if (same) {\n+            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in-place: same\");\n+            cryptoSameBuffer(false, data, input, output);\n+        }\n+    }\n+\n+    \/**\n+     * Perform cipher operation using different input and output buffers.\n+     *   This method allows mixing of data types (byte, heap, direct).\n+     *\/\n+     void crypto(boolean encrypt, Data d, byte[] input, byte[] output)\n+         throws Exception {\n+        byte[] pt = new byte[input.length + inOfs];\n+        System.arraycopy(input, 0, pt, inOfs, input.length);\n+         byte[] expectedOut = new byte[output.length + outOfs];\n+         System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n+        int plen = input.length \/ ops.size(); \/\/ partial input length\n+        int theoreticallen;\/\/ expected output length\n+        int dataoffset = 0; \/\/ offset of unconsumed data in pt\n+        int index = 0; \/\/ index of which op we are on\n+        int rlen; \/\/ result length\n+        int pbuflen = 0; \/\/ plen remaining in the GCM internal buffers\n+\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n+            d.key, new GCMParameterSpec(d.tag.length * 8, d.iv));\n+        cipher.updateAAD(d.aad);\n+\n+        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n+        ba.write(new byte[outOfs], 0, outOfs);\n+        for (dtype v : ops) {\n+            if (index < ops.size() - 1) {\n+                if (sizes != null && input.length > 0) {\n+                    if (sizes[index] == -1) {\n+                        plen = input.length - dataoffset;\n+                    } else {\n+                        if (sizes[index] > input.length) {\n+                            plen = input.length;\n+                        } else {\n+                            plen = sizes[index];\n+                        }\n+                    }\n+                }\n+\n+                int olen = cipher.getOutputSize(plen) + outOfs;\n+\n+                \/*\n+                 * The theoretical limit is the length of the data sent to\n+                 * update() + any data might be setting in CipherCore or GCM\n+                 * internal buffers % the block size.\n+                 *\/\n+                theoreticallen = (plen + pbuflen) - ((plen + pbuflen) % AESBLOCK);\n+\n+                \/\/ Update operations\n+                switch (v) {\n+                    case BYTE -> {\n+                        byte[] out = new byte[olen];\n+                        rlen = cipher.update(pt, dataoffset + inOfs, plen, out,\n+                            outOfs);\n+                        ba.write(out, outOfs, rlen);\n+                    }\n+                    case HEAP -> {\n+                        ByteBuffer b = ByteBuffer.allocate(plen + outOfs);\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(outOfs);\n+                        ByteBuffer out = ByteBuffer.allocate(olen);\n+                        out.position(outOfs);\n+                        rlen = cipher.update(b, out);\n+                        ba.write(out.array(), outOfs, rlen);\n+                    }\n+                    case DIRECT -> {\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + outOfs);\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(outOfs);\n+                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n+                        out.position(outOfs);\n+                        rlen = cipher.update(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(outOfs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (theoreticalCheck) {\n+                    pbuflen += plen - rlen;\n+                    if (encrypt && rlen != theoreticallen) {\n+                        throw new Exception(\"Wrong update return len (\" +\n+                            v.name() + \"):  \" + \"rlen=\" + rlen +\n+                            \", expected output len=\" + theoreticallen);\n+                    }\n+                }\n+\n+                dataoffset += plen;\n+                index++;\n+\n+            } else {\n+                \/\/ doFinal operation\n+                plen = input.length - dataoffset;\n+\n+                int olen = cipher.getOutputSize(plen) + outOfs;\n+                switch (v) {\n+                    case BYTE -> {\n+                        byte[] out = new byte[olen];\n+                        rlen = cipher.doFinal(pt, dataoffset + inOfs,\n+                            plen, out, outOfs);\n+                        ba.write(out, outOfs, rlen);\n+                    }\n+                    case HEAP -> {\n+                        ByteBuffer b = ByteBuffer.allocate(plen + inOfs);\n+                        b.limit(b.capacity());\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(inOfs);\n+                        ByteBuffer out = ByteBuffer.allocate(olen);\n+                        out.limit(out.capacity());\n+                        out.position(outOfs);\n+                        rlen = cipher.doFinal(b, out);\n+                        ba.write(out.array(), outOfs, rlen);\n+                    }\n+                    case DIRECT -> {\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + inOfs);\n+                        b.limit(b.capacity());\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n+                        b.flip();\n+                        b.position(inOfs);\n+                        ByteBuffer out = ByteBuffer.allocateDirect(olen);\n+                        out.limit(out.capacity());\n+                        out.position(outOfs);\n+                        rlen = cipher.doFinal(b, out);\n+                        byte[] o = new byte[rlen];\n+                        out.flip();\n+                        out.position(outOfs);\n+                        out.get(o, 0, rlen);\n+                        ba.write(o);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                if (theoreticalCheck && rlen != olen - outOfs) {\n+                    throw new Exception(\"Wrong doFinal return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + (olen - outOfs));\n+                }\n+\n+                \/\/ Verify results\n+                byte[] ctresult = ba.toByteArray();\n+                if (ctresult.length != expectedOut.length ||\n+                    Arrays.compare(ctresult, expectedOut) != 0) {\n+                    String s = \"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult   (len=\" + ctresult.length + \"):\" +\n+                        String.format(\"%0\" + (ctresult.length << 1) + \"x\",\n+                            new BigInteger(1, ctresult)) +\n+                        \"\\nexpected (len=\" + output.length + \"):\" +\n+                    String.format(\"%0\" + (output.length << 1) + \"x\",\n+                        new BigInteger(1, output));\n+                    System.err.println(s);\n+                    throw new Exception(s);\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Perform cipher operation using in-place buffers.  This method does not\n+     * allow mixing of data types (byte, heap, direct).\n+     *\n+     * Mixing data types makes no sense for in-place operations and would\n+     * greatly complicate the test code.\n+     *\/\n+    void cryptoSameBuffer(boolean encrypt, Data d, byte[] input, byte[] output) throws Exception {\n+\n+        byte[] data, out;\n+        if (encrypt) {\n+            data = new byte[output.length + Math.max(inOfs, outOfs)];\n+        } else {\n+            data = new byte[input.length + Math.max(inOfs, outOfs)];\n+        }\n+\n+        ByteBuffer bbin = null, bbout = null;\n+        System.arraycopy(input, 0, data, inOfs, input.length);\n+        byte[] expectedOut = new byte[output.length + outOfs];\n+        System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n+        int plen = input.length \/ ops.size(); \/\/ partial input length\n+        int theorticallen = plen - (plen % AESBLOCK); \/\/ output length\n+        int dataoffset = 0;\n+        int index = 0;\n+        int rlen = 0; \/\/ result length\n+        int len = 0;\n+\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n+            d.key, new GCMParameterSpec(d.tag.length * 8, d.iv));\n+        cipher.updateAAD(d.aad);\n+\n+        \/\/ Prepare data\n+        switch (ops.get(0)) {\n+            case HEAP -> {\n+                bbin = ByteBuffer.wrap(data);\n+                bbin.limit(input.length + inOfs);\n+                bbout = bbin.duplicate();\n+            }\n+            case DIRECT -> {\n+                bbin = ByteBuffer.allocateDirect(data.length);\n+                bbout = bbin.duplicate();\n+                bbin.put(data, 0, input.length + inOfs);\n+                bbin.flip();\n+            }\n+        }\n+\n+        \/\/ Set data limits for bytebuffers\n+        if (bbin != null) {\n+            bbin.position(inOfs);\n+            bbout.limit(output.length + outOfs);\n+            bbout.position(outOfs);\n+        }\n+\n+        \/\/ Iterate through each operation\n+        for (dtype v : ops) {\n+            if (index < ops.size() - 1) {\n+                switch (v) {\n+                    case BYTE -> {\n+                        rlen = cipher.update(data, dataoffset + inOfs, plen,\n+                            data, len + outOfs);\n+                    }\n+                    case HEAP, DIRECT -> {\n+                        theorticallen = bbin.remaining() -\n+                            (bbin.remaining() % AESBLOCK);\n+                        rlen = cipher.update(bbin, bbout);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+\n+                \/\/ Check that the theoretical return value matches the actual.\n+                if (theoreticalCheck && encrypt && rlen != theorticallen) {\n+                    throw new Exception(\"Wrong update return len (\" +\n+                        v.name() + \"):  \" + \"rlen=\" + rlen +\n+                        \", expected output len=\" + theorticallen);\n+                }\n+\n+                dataoffset += plen;\n+                len += rlen;\n+                index++;\n+\n+            } else {\n+                \/\/ Run doFinal op\n+                plen = input.length - dataoffset;\n+\n+                switch (v) {\n+                    case BYTE -> {\n+                        rlen = cipher.doFinal(data, dataoffset + inOfs,\n+                            plen, data, len + outOfs);\n+                        out = Arrays.copyOfRange(data, 0,len + rlen + outOfs);\n+                    }\n+                    case HEAP, DIRECT -> {\n+                        rlen = cipher.doFinal(bbin, bbout);\n+                        bbout.flip();\n+                        out = new byte[bbout.remaining()];\n+                        bbout.get(out);\n+                    }\n+                    default -> throw new Exception(\"Unknown op: \" + v.name());\n+                }\n+                len += rlen;\n+\n+                \/\/ Verify results\n+                if (len != output.length ||\n+                    Arrays.compare(out, 0, len, expectedOut, 0,\n+                        output.length) != 0) {\n+                    String s = \"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult (len=\" + len + \"):\\n\" +\n+                        byteToHex(out) +\n+                        \"\\nexpected (len=\" + output.length + \"):\\n\" +\n+                        String.format(\"%0\" + (output.length << 1) + \"x\",\n+                            new BigInteger(1, output));\n+                    System.err.println(s);\n+                    throw new Exception(s);\n+                }\n+            }\n+        }\n+    }\n+    static void offsetTests(GCMBufferTest t) throws Exception {\n+        t.clone().offset(2).test();\n+        t.clone().inOfs(2).test();\n+        \/\/ Test not designed for overlap situations\n+        t.clone().outOfs(2).differentBufferOnly().test();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        initTest();\n+        \/\/ Test single byte array\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)));\n+        \/\/ Test update-doFinal with byte arrays\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)));\n+        \/\/ Test update-update-doFinal with byte arrays\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n+\n+        \/\/ Test single heap bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)));\n+        \/\/ Test update-doFinal with heap bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP)));\n+        \/\/ Test update-update-doFinal with heap bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n+\n+        \/\/ Test single direct bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)));\n+        \/\/ Test update-doFinal with direct bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)));\n+        \/\/ Test update-update-doFinal with direct bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n+\n+        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n+        GCMBufferTest t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n+            new int[] { 1, 1, GCMBufferTest.REMAINDER});\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n+        \/\/ preset data sizes.\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n+            dataSegments(new int[] { 20, GCMBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n+        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n+        \/\/ byte array with preset data sizes.\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n+            differentBufferOnly().dataSet(5).\n+            dataSegments(new int[] { 5000, 1000, GCMBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n+\n+        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n+        \/\/ every data size combination for the Data set 0\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n+            dataSet(0).test();\n+        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n+        \/\/ every data size combination for the Data set 0\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            incrementalSegments().dataSet(0).test();\n+    }\n+\n+    private static byte[] HexToBytes(String hexVal) {\n+        if (hexVal == null) {\n+            return new byte[0];\n+        }\n+        byte[] result = new byte[hexVal.length()\/2];\n+        for (int i = 0; i < result.length; i++) {\n+            String byteVal = hexVal.substring(2*i, 2*i +2);\n+            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n+        }\n+        return result;\n+    }\n+\n+    private static String byteToHex(byte[] barray) {\n+        StringBuilder s = new StringBuilder();\n+        for (byte b : barray) {\n+            s.append(String.format(\"%02x\", b));\n+        }\n+        return s.toString();\n+    }\n+\n+    \/\/ Test data\n+    static void initTest() {\n+        datamap.put(\"AES\/GCM\/NoPadding\", List.of(\n+            \/\/ GCM KAT\n+            new Data(\"AES\", 0,\n+            \"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n+                \"49451da24bd6074509d3cebc2c0394c972e6934b45a1d91f3ce1d3ca69e19\" +\n+                \"4aa1958a7c21b6f21d530ce6d2cc5256a3f846b6f9d2f38df0102c4791e5\" +\n+                \"7df038f6e69085646007df999751e248e06c47245f4cd3b8004585a7470d\" +\n+                \"ee1690e9d2d63169a58d243c0b57b3e5b4a481a3e4e8c60007094ef3adea\" +\n+                \"2e8f05dd3a1396f\",\n+            \"d384305af2388699aa302f510913fed0f2cb63ba42efa8c5c9de2922a2ec\" +\n+                \"2fe87719dadf1eb0aef212b51e74c9c5b934104a43\",\n+            \"630cf18a91cc5a6481ac9eefd65c24b1a3c93396bd7294d6b8ba3239517\" +\n+                \"27666c947a21894a079ef061ee159c05beeb4\",\n+            \"f4c34e5fbe74c0297313268296cd561d59ccc95bbfcdfcdc71b0097dbd83\" +\n+                \"240446b28dc088abd42b0fc687f208190ff24c0548\",\n+            \"dbb93bbb56d0439cd09f620a57687f5d\"),\n+            \/\/ GCM KAT\n+            new Data(\"AES\", 1, \"11754cd72aec309bf52f7687212e8957\",\n+                \"3c819d9a9bed087615030b65\",\n+                (String)null, null, null,\n+                \"250327c674aaf477aef2675748cf6971\"),\n+            \/\/ GCM KAT\n+            new Data(\"AES\", 2, \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                (String)null, null, null,\n+                \"b6e6f197168f5049aeda32dafbdaeb\"),\n+            \/\/ zero'd test data\n+            new Data(\"AES\", 3, \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                new byte[256], null,\n+                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n+                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n+                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n+                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n+                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n+                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n+                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n+                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\",\n+                \"08b3593840d4ed005f5234ae062a5c\"),\n+            \/\/ Random test data\n+            new Data(\"AES\", 4, \"272f16edb81a7abbea887357a58c1917\",\n+                \"794ec588176c703d3d2a7a07\",\n+                new byte[2075], null,\n+                \"15b461672153270e8ba1e6789f7641c5411f3e642abda731b6086f535c216457\" +\n+                \"e87305bc59a1ff1f7e1e0bbdf302b75549b136606c67d7e5f71277aeca4bc670\" +\n+                \"07a98f78e0cfa002ed183e62f07893ad31fe67aad1bb37e15b957a14d145f14f\" +\n+                \"7483d041f2c3612ad5033155984470bdfc64d18df73c2745d92f28461bb09832\" +\n+                \"33524811321ba87d213692825815dd13f528dba601a3c319cac6be9b48686c23\" +\n+                \"a0ce23d5062916ea8827bbb243f585e446131489e951354c8ab24661f625c02e\" +\n+                \"15536c5bb602244e98993ff745f3e523399b2059f0e062d8933fad2366e7e147\" +\n+                \"510a931282bb0e3f635efe7bf05b1dd715f95f5858261b00735224256b6b3e80\" +\n+                \"7364cb53ff6d4e88f928cf67ac70da127718a8a35542efbae9dd7567c818a074\" +\n+                \"9a0c74bd69014639f59768bc55056d1166ea5523e8c66f9d78d980beb8f0d83b\" +\n+                \"a9e2c5544b94dc3a1a4b6f0f95f897b010150e89ebcacf0daee3c2793d6501a0\" +\n+                \"b58b411de273dee987e8e8cf8bb29ef2e7f655b46b55fabf64c6a4295e0d080b\" +\n+                \"6a570ace90eb0fe0f5b5d878bdd90eddaa1150e4d5a6505b350aac814fe99615\" +\n+                \"317ecd0516a464c7904011ef5922409c0d65b1e43b69d7c3293a8f7d3e9fbee9\" +\n+                \"eb91ec0007a7d6f72e64deb675d459c5ba07dcfd58d08e6820b100465e6e04f0\" +\n+                \"663e310584a00d36d23699c1bffc6afa094c75184fc7cde7ad35909c0f49f2f3\" +\n+                \"fe1e6d745ab628d74ea56b757047de57ce18b4b3c71e8af31a6fac16189cb0a3\" +\n+                \"a97a1bea447042ce382fcf726560476d759c24d5c735525ea26a332c2094408e\" +\n+                \"671c7deb81d5505bbfd178f866a6f3a011b3cfdbe089b4957a790688028dfdf7\" +\n+                \"9a096b3853f9d0d6d3feef230c7f5f46ffbf7486ebdaca5804dc5bf9d202415e\" +\n+                \"e0d67b365c2f92a17ea740807e4f0b198b42b54f15faa9dff2c7c35d2cf8d72e\" +\n+                \"b8f8b18875a2e7b5c43d1e0aa5139c461e8153c7f632895aa46ffe2b134e6a0d\" +\n+                \"dfbf6a336e709adfe951bd52c4dfc7b07a15fb3888fc35b7e758922f87a104c4\" +\n+                \"563c5c7839cfe5a7edbdb97264a7c4ebc90367b10cbe09dbf2390767ad7afaa8\" +\n+                \"8fb46b39d3f55f216d2104e5cf040bf3d39b758bea28e2dbce576c808d17a8eb\" +\n+                \"e2fd183ef42a774e39119dff1f539efeb6ad15d889dfcb0d54d0d4d4cc03c8d9\" +\n+                \"aa6c9ebd157f5e7170183298d6a30ada8792dcf793d931e2a1eafccbc63c11c0\" +\n+                \"c5c5ed60837f30017d693ccb294df392a8066a0594a56954aea7b78a16e9a11f\" +\n+                \"4a8bc2104070a7319f5fab0d2c4ccad8ec5cd8f47c839179bfd54a7bf225d502\" +\n+                \"cd0a318752fe763e8c09eb88fa57fc5399ad1f797d0595c7b8afdd23f13603e9\" +\n+                \"6802192bb51433b7723f4e512bd4f799feb94b458e7f9792f5f9bd6733828f70\" +\n+                \"a6b7ffbbc0bb7575021f081ec2a0d37fecd7cda2daec9a3a9d9dfe1c8034cead\" +\n+                \"e4b56b581cc82bd5b74b2b30817967d9da33850336f171a4c68e2438e03f4b11\" +\n+                \"96da92f01b3b7aeab795180ccf40a4b090b1175a1fc0b67c95f93105c3aef00e\" +\n+                \"13d76cc402539192274fee703730cd0d1c5635257719cc96cacdbad00c6255e2\" +\n+                \"bd40c775b43ad09599e84f2c3205d75a6661ca3f151183be284b354ce21457d1\" +\n+                \"3ba65b9b2cdb81874bd14469c2008b3ddec78f7225ecc710cc70de7912ca6a6d\" +\n+                \"348168322ab59fdafcf5c833bfa0ad4046f4b6da90e9f263db7079af592eda07\" +\n+                \"5bf16c6b1a8346da9c292a48bf660860a4fc89eaef40bc132779938eca294569\" +\n+                \"787c740af2b5a8de7f5e10ac750d1e3d0ef3ed168ba408a676e10b8a20bd4be8\" +\n+                \"3e8336b45e54481726d73e1bd19f165a98e242aca0d8387f2dd22d02d74e23db\" +\n+                \"4cef9a523587413e0a44d7e3260019a34d3a6b38426ae9fa4655be338d721970\" +\n+                \"cb9fe76c073f26f9303093a033022cd2c62b2790bce633ba9026a1c93b6535f1\" +\n+                \"1882bf5880e511b9e1b0b7d8f23a993aae5fd275faac3a5b4ccaf7c06b0b266a\" +\n+                \"ee970a1e3a4cd7a41094f516960630534e692545b25a347c30e3f328bba4825f\" +\n+                \"ed754e5525d846131ecba7ca120a6aeabc7bab9f59c890c80b7e31f9bc741591\" +\n+                \"55d292433ce9558e104102f2cc63ee267c1c8333e841522707ea6d595cb802b9\" +\n+                \"61697da77bbc4cb404ea62570ab335ebffa2023730732ac5ddba1c3dbb5be408\" +\n+                \"3c50aea462c1ffa166d7cc3db4b742b747e81b452db2363e91374dee8c6b40f0\" +\n+                \"e7fbf50e60eaf5cc5649f6bb553aae772c185026ceb052af088c545330a1ffbf\" +\n+                \"50615b8c7247c6cd386afd7440654f4e15bcfae0c45442ec814fe88433a9d616\" +\n+                \"ee6cc3f163f0d3d325526d05f25d3b37ad5eeb3ca77248ad86c9042b16c65554\" +\n+                \"aebb6ad3e17b981492b13f42c5a5dc088e991da303e5a273fdbb8601aece4267\" +\n+                \"47b01f6cb972e6da1743a0d7866cf206e95f23c6f8e337c901b9cd34a9a1fbbe\" +\n+                \"1694f2c26b00dfa4d02c0d54540163e798fbdc9c25f30d6406f5b4c13f7ed619\" +\n+                \"34e350f4059c13aa5e973307a9e3058917cda96fdd082e9c629ccfb2a9f98d12\" +\n+                \"5c6e4703a7b0f348f5cdeb63cef2133d1c6c1a087591e0a2bca29d09c6565e66\" +\n+                \"e91042f83b0e74e60a5d57562c23e2fbcd6599c29d7c19e47cf625c2ce24bb8a\" +\n+                \"13f8e54041498437eec2cedd1e3d8e57a051baa962c0a62d70264d99c5ee716d\" +\n+                \"5c8b9078db08c8b2c5613f464198a7aff43f76c5b4612b46a4f1cd2a494386c5\" +\n+                \"7fd28f3d199f0ba8d8e39116cc7db16ce6188205ee49a9dce3d4fa32ea394919\" +\n+                \"f6e91ef58b84d00b99596b4306c2d9f432d917bb4ac73384c42ae12adb4920d8\" +\n+                \"c33a816febcb299dcddf3ec7a8eb6e04cdc90891c6e145bd9fc5f41dc4061a46\" +\n+                \"9feba38545b64ec8203f386ceef52785619e991d274ae80af7e54af535e0b011\" +\n+                \"5effdf847472992875e09398457604d04e0bb965db692c0cdcf11a\",\n+                \"687cc09c89298491deb51061d709af\"),\n+            \/\/ Randomly generated data at the time of execution.\n+            new Data(\"AES\", 5, \"11754cd72aec309bf52f7687212e8957\", 12345)\n+            )\n+        );\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":851,"deletions":0,"binary":false,"changes":851,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Uses GCMBufferTest to run a long test with incrementing through\n+ * each byte in each byte array\n+ * @run main\/manual GCMIncrementByte4\n+ *\/\n+\n+public class GCMIncrementByte4 {\n+\n+    public static void main(String args[]) throws Exception {\n+        GCMBufferTest.initTest();\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(GCMBufferTest.dtype.BYTE, GCMBufferTest.dtype.BYTE,\n+                GCMBufferTest.dtype.BYTE)).incrementalSegments().dataSet(4).\n+            test();\n+\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementByte4.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Uses GCMBufferTest to run a long test with incrementing through\n+ * each byte in each direct bytebuffer\n+ * @run main\/manual GCMIncrementDirect4\n+ *\/\n+\n+public class GCMIncrementDirect4 {\n+\n+    public static void main(String args[]) throws Exception {\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(GCMBufferTest.dtype.DIRECT, GCMBufferTest.dtype.DIRECT,\n+                GCMBufferTest.dtype.DIRECT)).incrementalSegments().dataSet(4).\n+            test();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementDirect4.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+\n+\/*\n+ * @test\n+ * @summary This tests overlapping buffers using ByteBuffer.slice() with\n+ *  array-backed ByteBuffer, read only array-backed, ByteBuffer, and direct\n+ *  ByteBuffer.\n+ *\/\n+\n+\/*\n+ * This tests overlapping buffers created with ByteBuffer.slice().  That is\n+ * when the input and output ByteBuffers have shared memory (use the same\n+ * underlying buffer space, commonly used for in-place crypto).  The\n+ * complication is the Cipher object specifies that it must be copy-safe.  That\n+ * means the output buffer will not overwrite any input data that has not been\n+ * processed.  If the output buffer's position or offset is greater than the\n+ * input's overwriting will occur.\n+ *\/\n+\n+public class OverlapByteBuffer {\n+\n+    public static void main(String[] args) throws Exception {\n+        byte[] baseBuf = new byte[8192];\n+        ByteBuffer output, input, in;\n+        \/\/ Output offset from the baseBuf\n+        int outOfs;\n+\n+        for (int i = 0; i < 3; i++) {\n+            for (outOfs = -1; outOfs <= 1; outOfs++) {\n+\n+                SecretKeySpec key = new SecretKeySpec(new byte[16], \"AES\");\n+                GCMParameterSpec params =\n+                    new GCMParameterSpec(128, new byte[12]);\n+                Cipher cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                cipher.init(Cipher.ENCRYPT_MODE, key, params);\n+\n+                \/\/ Offset on the particular ByteBuffer (aka position())\n+                int inOfsInBuf = 1;\n+                int outOfsInBuf = inOfsInBuf + outOfs;\n+                int sliceLen = cipher.getOutputSize(baseBuf.length);\n+                int bufferSize = sliceLen + Math.max(inOfsInBuf, outOfsInBuf);\n+                byte[] buffer;\n+                \/\/ Create overlapping input and output buffers\n+                switch (i) {\n+                    case 0 -> {\n+                        buffer = new byte[bufferSize];\n+                        output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n+                            slice();\n+                        input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n+                            slice();\n+                        System.out.println(\"Using array-backed ByteBuffer\");\n+                        in = input.duplicate();\n+                    }\n+                    case 1 -> {\n+                        buffer = new byte[bufferSize];\n+                        output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n+                            slice();\n+                        input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n+                            slice();\n+\n+                        System.out.println(\"Using read-only array-backed \" + \"ByteBuffer\");\n+                        in = input.asReadOnlyBuffer();\n+                    }\n+                    case 2 -> {\n+                        System.out.println(\"Using direct ByteBuffer\");\n+                        ByteBuffer buf = ByteBuffer.allocateDirect(bufferSize);\n+                        output = buf.duplicate();\n+                        output.position(outOfsInBuf);\n+                        output.limit(sliceLen + outOfsInBuf);\n+                        output = output.slice();\n+\n+                        input = buf.duplicate();\n+                        input.position(inOfsInBuf);\n+                        input.limit(sliceLen + inOfsInBuf);\n+                        input = input.slice();\n+\n+                        in = input.duplicate();\n+                    }\n+                    default -> {\n+                        throw new Exception(\"Unknown index \" + i);\n+                    }\n+                }\n+\n+                \/\/ Copy data into shared buffer\n+                input.put(baseBuf);\n+                input.flip();\n+                in.limit(input.limit());\n+\n+                try {\n+                    int ctSize = cipher.doFinal(in, output);\n+\n+                    \/\/ Get ready to decrypt\n+                    byte[] tmp = new byte[ctSize];\n+                    output.flip();\n+                    output.get(tmp);\n+                    output.clear();\n+\n+                    input.clear();\n+                    input.put(tmp);\n+                    input.flip();\n+\n+                    in.clear();\n+                    in.limit(input.limit());\n+\n+                    cipher.init(Cipher.DECRYPT_MODE, key, params);\n+                    cipher.doFinal(in, output);\n+\n+                    output.flip();\n+                    System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n+                    System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n+                    ByteBuffer b = ByteBuffer.wrap(baseBuf);\n+                    if (b.compareTo(output) != 0) {\n+                        System.err.println(\n+                            \"\\nresult   (\" + output + \"):\\n\" +\n+                            byteToHex(output) +\n+                            \"\\nexpected (\" + b + \"):\\n\" +\n+                            byteToHex(b));\n+                        throw new Exception(\"Mismatch\");\n+                    }\n+                } catch (Exception e) {\n+                    throw new Exception(\"Error with base offset \" + outOfs, e);\n+                }\n+            }\n+        }\n+    }\n+        private static String byteToHex(ByteBuffer bb) {\n+        StringBuilder s = new StringBuilder();\n+        while (bb.remaining() > 0) {\n+            s.append(String.format(\"%02x\", bb.get()));\n+        }\n+        return s.toString();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/OverlapByteBuffer.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.test.lib.Convert;\n@@ -38,0 +39,1 @@\n+ * @library \/test\/lib\n@@ -258,0 +260,7 @@\n+            System.err.println(\n+                \"\\noutputText:   len = \" + outputText.length + \"  txtOffset = \" + txtOffset + \"\\n\" +\n+                jdk.test.lib.Convert.byteArrayToHexString(outputText) + \"\\n\" +\n+                \"text:  len = \" + text.length + \"  myoff = \" + myoff + \"\\n\" +\n+                jdk.test.lib.Convert.byteArrayToHexString(text) + \"\\n\" +\n+                    \"lenght \" + lenght);\n+            System.err.println(\"tlen = \" + params.getParameterSpec(GCMParameterSpec.class).getTLen() \/ 8);\n@@ -390,0 +399,2 @@\n+                System.err.println(\"i = \" + i + \"   A[setA] = \" + A[setA] +\n+                    \"   B[setB] = \" + B[setB]);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/SameBuffer.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.ByteBuffer;\n@@ -58,0 +59,1 @@\n+        int id;\n@@ -66,1 +68,1 @@\n-        TestVector(String key, String iv, String pt, String aad,\n+        TestVector(int id, String key, String iv, String pt, String aad,\n@@ -68,0 +70,1 @@\n+            this.id = id;\n@@ -74,1 +77,1 @@\n-            this.info = \"key=\" + key + \", iv=\" + iv + \", pt=\" + pt +\n+            this.info = \"id = \" + id + \", key=\" + key + \", iv=\" + iv + \", pt=\" + pt +\n@@ -78,0 +81,15 @@\n+        TestVector() {};\n+\n+        TestVector duplicate() {\n+            TestVector t = new TestVector();\n+            t.id = id;\n+            t.key = key;\n+            t.plainText = plainText;\n+            t.cipherText = cipherText;\n+            t.aad = aad;\n+            t.tag = tag;\n+            t.spec = spec;\n+            t.info = info;\n+            return t;\n+        }\n+\n@@ -83,0 +101,2 @@\n+    static boolean testFailed = false;\n+\n@@ -91,1 +111,1 @@\n-        new TestVector(\"11754cd72aec309bf52f7687212e8957\",\n+        new TestVector(1, \"11754cd72aec309bf52f7687212e8957\",\n@@ -95,1 +115,1 @@\n-        new TestVector(\"272f16edb81a7abbea887357a58c1917\",\n+        new TestVector(2, \"272f16edb81a7abbea887357a58c1917\",\n@@ -99,1 +119,1 @@\n-        new TestVector(\"81b6844aab6a568c4556a2eb7eae752f\",\n+        new TestVector(3, \"81b6844aab6a568c4556a2eb7eae752f\",\n@@ -103,1 +123,1 @@\n-        new TestVector(\"cde2f9a9b1a004165ef9dc981f18651b\",\n+        new TestVector(4, \"cde2f9a9b1a004165ef9dc981f18651b\",\n@@ -107,1 +127,1 @@\n-        new TestVector(\"b01e45cc3088aaba9fa43d81d481823f\",\n+        new TestVector(5, \"b01e45cc3088aaba9fa43d81d481823f\",\n@@ -113,1 +133,1 @@\n-        new TestVector(\"77be63708971c4e240d1cb79e8d77feb\",\n+        new TestVector(6, \"77be63708971c4e240d1cb79e8d77feb\",\n@@ -119,1 +139,1 @@\n-        new TestVector(\"da0b615656135194ba6d3c851099bc48\",\n+        new TestVector(7, \"da0b615656135194ba6d3c851099bc48\",\n@@ -125,1 +145,1 @@\n-        new TestVector(\"7e0986937a88eef894235aba4a2f43b2\",\n+        new TestVector(8, \"7e0986937a88eef894235aba4a2f43b2\",\n@@ -131,1 +151,1 @@\n-        new TestVector(\"c3db570d7f0c21e86b028f11465d1dc9\",\n+        new TestVector(9, \"c3db570d7f0c21e86b028f11465d1dc9\",\n@@ -137,1 +157,1 @@\n-        new TestVector(\"bea48ae4980d27f357611014d4486625\",\n+        new TestVector(10, \"bea48ae4980d27f357611014d4486625\",\n@@ -145,1 +165,1 @@\n-        new TestVector(\"2fb45e5b8f993a2bfebc4b15b533e0b4\",\n+        new TestVector(11, \"2fb45e5b8f993a2bfebc4b15b533e0b4\",\n@@ -151,1 +171,1 @@\n-        new TestVector(\"9bf406339fcef9675bbcf156aa1a0661\",\n+        new TestVector(12, \"9bf406339fcef9675bbcf156aa1a0661\",\n@@ -157,1 +177,1 @@\n-        new TestVector(\"a2e962fff70fd0f4d63be728b80556fc\",\n+        new TestVector(13, \"a2e962fff70fd0f4d63be728b80556fc\",\n@@ -163,1 +183,1 @@\n-        new TestVector(\"6bf4fdce82926dcdfc52616ed5f23695\",\n+        new TestVector(14, \"6bf4fdce82926dcdfc52616ed5f23695\",\n@@ -169,1 +189,1 @@\n-        new TestVector(\"4df7a13e43c3d7b66b1a72fac5ba398e\",\n+        new TestVector(15, \"4df7a13e43c3d7b66b1a72fac5ba398e\",\n@@ -176,1 +196,1 @@\n-        new TestVector(\"fe9bb47deb3a61e423c2231841cfd1fb\",\n+        new TestVector(16, \"fe9bb47deb3a61e423c2231841cfd1fb\",\n@@ -182,1 +202,1 @@\n-        new TestVector(\"7fddb57453c241d03efbed3ac44e371c\",\n+        new TestVector(17, \"7fddb57453c241d03efbed3ac44e371c\",\n@@ -188,1 +208,1 @@\n-        new TestVector(\"9971071059abc009e4f2bd69869db338\",\n+        new TestVector(18, \"9971071059abc009e4f2bd69869db338\",\n@@ -194,1 +214,1 @@\n-        new TestVector(\"594157ec4693202b030f33798b07176d\",\n+        new TestVector(19, \"594157ec4693202b030f33798b07176d\",\n@@ -203,1 +223,1 @@\n-        new TestVector(\"c939cc13397c1d37de6ae0e1cb7c423c\",\n+        new TestVector(20, \"c939cc13397c1d37de6ae0e1cb7c423c\",\n@@ -209,1 +229,1 @@\n-        new TestVector(\"d4a22488f8dd1d5c6c19a7d6ca17964c\",\n+        new TestVector(21, \"d4a22488f8dd1d5c6c19a7d6ca17964c\",\n@@ -215,1 +235,1 @@\n-        new TestVector(\"89850dd398e1f1e28443a33d40162664\",\n+        new TestVector(22, \"89850dd398e1f1e28443a33d40162664\",\n@@ -222,1 +242,1 @@\n-        new TestVector(\"bd7c5c63b7542b56a00ebe71336a1588\",\n+        new TestVector(23, \"bd7c5c63b7542b56a00ebe71336a1588\",\n@@ -230,1 +250,1 @@\n-        new TestVector(\"1672c3537afa82004c6b8a46f6f0d026\",\n+        new TestVector(24, \"1672c3537afa82004c6b8a46f6f0d026\",\n@@ -234,1 +254,1 @@\n-        new TestVector(\"d0f1f4defa1e8c08b4b26d576392027c\",\n+        new TestVector(25, \"d0f1f4defa1e8c08b4b26d576392027c\",\n@@ -240,1 +260,1 @@\n-        new TestVector(\"9f79239f0904eace50784b863e723f6b\",\n+        new TestVector(26, \"9f79239f0904eace50784b863e723f6b\",\n@@ -248,1 +268,1 @@\n-        new TestVector(\"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n+        new TestVector(27, \"141f1ce91989b07e7eb6ae1dbd81ea5e\",\n@@ -260,2 +280,1 @@\n-    public boolean execute(TestVector[] testValues) throws Exception {\n-        boolean testFailed = false;\n+    void executeArray(TestVector tv) throws Exception {\n@@ -263,32 +282,14 @@\n-        for (int i = 0; i < testValues.length; i++) {\n-            try {\n-                c.init(Cipher.ENCRYPT_MODE, testValues[i].key, testValues[i].spec);\n-                c.updateAAD(testValues[i].aad);\n-                byte[] ctPlusTag = c.doFinal(testValues[i].plainText);\n-\n-                c.init(Cipher.DECRYPT_MODE, testValues[i].key, testValues[i].spec);\n-                c.updateAAD(testValues[i].aad);\n-                byte[] pt = c.doFinal(ctPlusTag); \/\/ should fail if tag mismatched\n-\n-                \/\/ check encryption\/decryption results just to be sure\n-                if (!Arrays.equals(testValues[i].plainText, pt)) {\n-                    System.out.println(\"PlainText diff failed for test# \" + i);\n-                    testFailed = true;\n-                }\n-                int ctLen = testValues[i].cipherText.length;\n-                if (!Arrays.equals(testValues[i].cipherText,\n-                                   Arrays.copyOf(ctPlusTag, ctLen))) {\n-                    System.out.println(\"CipherText diff failed for test# \" + i);\n-                    testFailed = true;\n-                }\n-                int tagLen = testValues[i].tag.length;\n-                if (!Arrays.equals\n-                    (testValues[i].tag,\n-                     Arrays.copyOfRange(ctPlusTag, ctLen, ctLen+tagLen))) {\n-                    System.out.println(\"Tag diff failed for test# \" + i);\n-                    testFailed = true;\n-                }\n-            } catch (Exception ex) {\n-                \/\/ continue testing other test vectors\n-                System.out.println(\"Failed Test Vector: \" + testValues[i]);\n-                ex.printStackTrace();\n+        try {\n+            System.out.println(\"Test #\" + tv.id + \": byte[].\");\n+\n+            c.init(Cipher.ENCRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            byte[] ctPlusTag = c.doFinal(tv.plainText);\n+\n+            c.init(Cipher.DECRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            byte[] pt = c.doFinal(ctPlusTag); \/\/ should fail if tag mismatched\n+\n+            \/\/ check encryption\/decryption results just to be sure\n+            if (!Arrays.equals(tv.plainText, pt)) {\n+                System.out.println(\"PlainText diff failed for test# \" + tv.id);\n@@ -296,1 +297,0 @@\n-                continue;\n@@ -298,0 +298,18 @@\n+            int ctLen = tv.cipherText.length;\n+            if (!Arrays.equals(tv.cipherText,\n+                Arrays.copyOf(ctPlusTag, ctLen))) {\n+                System.out.println(\"CipherText diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+            int tagLen = tv.tag.length;\n+            if (!Arrays.equals\n+                (tv.tag,\n+                    Arrays.copyOfRange(ctPlusTag, ctLen, ctLen+tagLen))) {\n+                System.out.println(\"Tag diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+        } catch (Exception ex) {\n+            \/\/ continue testing other test vectors\n+            System.out.println(\"Failed Test Vector: \" + tv);\n+            ex.printStackTrace();\n+            testFailed = true;\n@@ -302,2 +320,80 @@\n-        \/\/ passed all tests...hooray!\n-        return true;\n+    }\n+\n+    void executeByteBuffer(TestVector tv, boolean direct, int offset) throws Exception {\n+        Cipher c = Cipher.getInstance(\"AES\/GCM\/NoPadding\", \"SunJCE\");\n+\n+        ByteBuffer src;\n+        ByteBuffer ctdst;\n+        ByteBuffer ptdst;\n+\n+        if (direct) {\n+            System.out.print(\"Test #\" + tv.id + \": ByteBuffer Direct.\");\n+            src = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n+            ctdst = ByteBuffer.allocateDirect(tv.cipherText.length + tv.tag.length + offset);\n+            ptdst = ByteBuffer.allocateDirect(tv.plainText.length + offset);\n+        } else {\n+            System.out.print(\"Test #\" + tv.id + \": ByteBuffer Heap.\");\n+            src = ByteBuffer.allocate(tv.plainText.length + offset);\n+            ctdst = ByteBuffer.allocate(tv.cipherText.length + tv.tag.length + offset);\n+            ptdst = ByteBuffer.allocate(tv.plainText.length + offset);\n+        }\n+\n+        byte[] plainText;\n+\n+        if (offset > 0) {\n+            System.out.println(\"  offset = \" + offset);\n+            plainText = new byte[tv.plainText.length + offset];\n+            System.arraycopy(tv.plainText, 0, plainText, offset,\n+                tv.plainText.length);\n+        } else {\n+            System.out.println();\n+            plainText = tv.plainText;\n+        }\n+\n+        src.put(plainText);\n+        src.position(offset);\n+        ctdst.position(offset);\n+        ctdst.mark();\n+        ptdst.position(offset);\n+        ptdst.mark();\n+\n+        try {\n+            c.init(Cipher.ENCRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            c.doFinal(src, ctdst);\n+\n+            ctdst.reset();\n+            ByteBuffer tag = ctdst.duplicate();\n+            tag.position(tag.limit() - tv.tag.length);\n+\n+            c.init(Cipher.DECRYPT_MODE, tv.key, tv.spec);\n+            c.updateAAD(tv.aad);\n+            c.doFinal(ctdst, ptdst); \/\/ should fail if tag mismatched\n+\n+            ptdst.reset();\n+            \/\/ check encryption\/decryption results just to be sure\n+            if (ptdst.compareTo(ByteBuffer.wrap(tv.plainText)) != 0) {\n+                System.out.println(\"\\t PlainText diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+\n+            ctdst.reset();\n+            ctdst.limit(ctdst.limit() - tv.tag.length);\n+            if (ctdst.compareTo(ByteBuffer.wrap(tv.cipherText)) != 0) {\n+                System.out.println(\"\\t CipherText diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+\n+            int mismatch = 0;\n+            for (int i = 0; i < tv.tag.length; i++) {\n+                mismatch |= tag.get() ^ tv.tag[i];\n+            }\n+            if (mismatch != 0) {\n+                System.out.println(\"\\t Tag diff failed for test# \" + tv.id);\n+                testFailed = true;\n+            }\n+        } catch (Exception ex) {\n+            \/\/ continue testing other test vectors\n+            System.out.println(\"\\t Failed Test Vector ( #\" + tv.id + \") : \" + tv);\n+            ex.printStackTrace();\n+        }\n@@ -308,2 +404,9 @@\n-        if (test.execute(testValues)) {\n-            System.out.println(\"Test Passed!\");\n+        for (TestVector tv : testValues) {\n+            test.executeArray(tv);\n+            test.executeByteBuffer(tv, false, 0);\n+            test.executeByteBuffer(tv, true, 0);\n+            test.executeByteBuffer(tv, false, 2);\n+            test.executeByteBuffer(tv, true, 2);\n+        }\n+        if (!testFailed) {\n+            System.out.println(\"Tests passed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestKATForGCM.java","additions":171,"deletions":68,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import java.security.AlgorithmParameters;\n+import java.util.Arrays;\n+\n+\n+\/*\n+ * @test\n+ * @summary Verify when decrypting over an existing buffer than padding does not\n+ * overwrite past what the plaintext length is.\n+ *\n+ *\/\n+\n+public class SameBufferOverwrite {\n+\n+    private SecretKey skey;\n+    private Cipher c;\n+    private int start = 17, end = 17;  \/\/ default\n+\n+    SameBufferOverwrite(String algo, String transformation)\n+        throws Exception {\n+\n+        KeyGenerator kg = KeyGenerator.getInstance(algo, \"SunJCE\");\n+        skey = kg.generateKey();\n+        c = Cipher.getInstance(transformation, \"SunJCE\");\n+    }\n+\n+    \/*\n+     * Run the test\n+     *\/\n+    void test() throws Exception {\n+        byte[] in = new byte[end + (c.getBlockSize() - (end % c.getBlockSize()))];\n+        Arrays.fill(in, (byte)8);\n+        int len = start;\n+        AlgorithmParameters params = null;\n+\n+        System.out.println(\"Testing transformation: \" + c.getAlgorithm() +\n+            \",  byte length from \" + start + \" to \" + end);\n+        while (end >= len) {\n+            \/\/ encrypt\n+            c.init(Cipher.ENCRYPT_MODE, skey, params);\n+            byte[] out = c.doFinal(in, 0, len);\n+            System.out.println(\"  enc = \" + byteToHex(out));\n+            System.out.println(\"  => enc \" + len + \" bytes, ret \" +\n+                (out == null ? \"null\" : (out.length + \" byte\")));\n+\n+            \/\/ decrypt\n+            params = c.getParameters();\n+            c.init(Cipher.DECRYPT_MODE, skey, params);\n+            int rLen = c.doFinal(out, 0, out.length, in);\n+            System.out.println(\"  dec = \" + byteToHex(in));\n+            System.out.println(\"  => dec \" + out.length + \" bytes, ret \" +\n+                rLen + \" byte\");\n+            \/\/ check if more than rLen bytes are written into 'in'\n+            for (int j = rLen; j < in.length; j++) {\n+                if (in[j] != (byte) 8) {\n+                    throw new Exception(\"Value check failed at index \" + j);\n+                }\n+            }\n+            System.out.println(\" Test Passed:  len = \" + len);\n+            len++;\n+\n+            \/\/ Because GCM doesn't allow params reuse\n+            if (c.getAlgorithm().contains(\"GCM\")) {\n+                params = null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Builder method for the test to run data lengths from the start value to\n+     * the end value.  To do one length, have start and end equal that number.\n+     * @param start starting data length\n+     * @param end ending data length\n+     *\/\n+    SameBufferOverwrite iterate(int start, int end) {\n+        this.start = start;\n+        this.end = end;\n+        return this;\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        new SameBufferOverwrite(\"AES\", \"AES\/GCM\/NoPadding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"AES\", \"AES\/CTR\/NoPadding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"AES\", \"AES\/CBC\/PKCS5Padding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"AES\", \"AES\/ECB\/PKCS5Padding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"DES\", \"DES\/CBC\/PKCS5Padding\").iterate(1, 17).\n+            test();\n+        new SameBufferOverwrite(\"DESede\", \"DESede\/CBC\/PKCS5Padding\").iterate(1, 17).\n+            test();\n+    }\n+\n+    private static String byteToHex(byte[] barray) {\n+        StringBuilder s = new StringBuilder();\n+        for (byte b : barray) {\n+            s.append(String.format(\"%02x\", b));\n+        }\n+        return s.toString();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/TextLength\/SameBufferOverwrite.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,8 @@\n- * @run main CipherByteBufferOverwriteTest 0 false\n- * @run main CipherByteBufferOverwriteTest 0 true\n- * @run main CipherByteBufferOverwriteTest 4 false\n- * @run main CipherByteBufferOverwriteTest 4 true\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 0 false\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 0 true\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 4 false\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 4 true\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 0 false\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 0 true\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 4 false\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 4 true\n@@ -35,0 +39,1 @@\n+import java.math.BigInteger;\n@@ -38,0 +43,1 @@\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -47,1 +53,1 @@\n-    private static final String TRANSFORMATION = \"AES\/CBC\/PKCS5Padding\";\n+    private static String transformation;\n@@ -56,2 +62,1 @@\n-    private static final AlgorithmParameterSpec PARAMS =\n-            new IvParameterSpec(new byte[16]);\n+    private static AlgorithmParameterSpec params;\n@@ -68,2 +73,3 @@\n-        int offset = Integer.parseInt(args[0]);\n-        boolean useRO = Boolean.parseBoolean(args[1]);\n+        transformation = args[0];\n+        int offset = Integer.parseInt(args[1]);\n+        boolean useRO = Boolean.parseBoolean(args[2]);\n@@ -71,0 +77,5 @@\n+        if (transformation.equalsIgnoreCase(\"AES\/GCM\/NoPadding\")) {\n+            params = new GCMParameterSpec(16 * 8, new byte[16]);\n+        } else {\n+            params = new IvParameterSpec(new byte[16]);\n+        }\n@@ -78,2 +89,2 @@\n-        Cipher c = Cipher.getInstance(TRANSFORMATION);\n-        c.init(Cipher.ENCRYPT_MODE, KEY, PARAMS);\n+        Cipher c = Cipher.getInstance(transformation);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, params);\n@@ -92,1 +103,0 @@\n-        System.out.println(\"\\tDIRECT: passed\");\n@@ -95,0 +105,1 @@\n+        System.out.println(\"\\tDIRECT: passed\");\n@@ -153,2 +164,2 @@\n-        Cipher c = Cipher.getInstance(TRANSFORMATION);\n-        c.init(Cipher.ENCRYPT_MODE, KEY, PARAMS);\n+        Cipher c = Cipher.getInstance(transformation);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, params);\n@@ -169,0 +180,7 @@\n+            System.err.println(\"Ciphertext mismatch:\" +\n+                \"\\nresult   (len=\" + finalCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (finalCT.length << 1) + \"x\",\n+                    new BigInteger(1, finalCT)) +\n+                \"\\nexpected (len=\" + expectedCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (expectedCT.length << 1) + \"x\",\n+                    new BigInteger(1, expectedCT)));\n@@ -175,2 +193,1 @@\n-\n-        c.init(Cipher.DECRYPT_MODE, KEY, PARAMS);\n+        c.init(Cipher.DECRYPT_MODE, KEY, params);\n@@ -187,0 +204,7 @@\n+            System.err.println(\"Ciphertext mismatch \" +\n+                \"):\\nresult   (len=\" + finalCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (finalCT.length << 1) + \"x\",\n+                    new BigInteger(1, finalCT)) +\n+                \"\\nexpected (len=\" + expectedCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (expectedCT.length << 1) + \"x\",\n+                    new BigInteger(1, expectedCT)));\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/CipherByteBufferOverwriteTest.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @run main\/othervm -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true CheckSessionContext\n@@ -37,0 +38,2 @@\n+import javax.net.ssl.SSLSession;\n+\n@@ -39,0 +42,7 @@\n+    static void toHex(byte[] id) {\n+        for (byte b : id) {\n+            System.out.printf(\"%02X \", b);\n+        }\n+        System.out.println();\n+    }\n+\n@@ -49,0 +59,11 @@\n+        SSLSession ss = server.getSession(client1);\n+        System.out.println(ss);\n+        byte[] id = ss.getId();\n+        System.out.print(\"id = \");\n+        toHex(id);\n+        System.out.println(\"ss.getSessionContext().getSession(id) = \" + ss.getSessionContext().getSession(id));\n+        if (ss.getSessionContext().getSession(id) != null) {\n+            id = ss.getSessionContext().getSession(id).getId();\n+            System.out.print(\"id = \");\n+            toHex(id);\n+        }\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}