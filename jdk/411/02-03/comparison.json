{"files":[{"patch":"@@ -655,7 +655,0 @@\n-    @Override\n-    protected int engineDoFinal(ByteBuffer input, ByteBuffer output)\n-            throws ShortBufferException, IllegalBlockSizeException,\n-            BadPaddingException {\n-        return bufferCrypt(input, output, false);\n-    }\n-\n@@ -663,2 +656,1 @@\n-     * Implementation for encryption using ByteBuffers. Used for both\n-     * engineUpdate() and engineDoFinal().\n+     * Finalize crypto operation with ByteBuffers\n@@ -666,2 +658,7 @@\n-     * This replaces CipherSpi.bufferCrypt to allow GCM to use ByteBuffers;\n-     * otherwise the two should be kept the same.\n+     * @param input the input ByteBuffer\n+     * @param output the output ByteBuffer\n+     *\n+     * @return output length\n+     * @throws ShortBufferException\n+     * @throws IllegalBlockSizeException\n+     * @throws BadPaddingException\n@@ -669,104 +666,8 @@\n-    private int bufferCrypt(ByteBuffer input, ByteBuffer output,\n-            boolean isUpdate) throws ShortBufferException,\n-            IllegalBlockSizeException, BadPaddingException {\n-        if ((input == null) || (output == null)) {\n-            throw new NullPointerException\n-                (\"Input and output buffers must not be null\");\n-        }\n-        int inPos = input.position();\n-        int inLimit = input.limit();\n-        int inLen = inLimit - inPos;\n-        if (isUpdate && (inLen == 0)) {\n-            return 0;\n-        }\n-        int outLenNeeded = engineGetOutputSize(inLen);\n-\n-        if (output.remaining() < outLenNeeded) {\n-            throw new ShortBufferException(\"Need at least \" + outLenNeeded\n-                + \" bytes of space in output buffer\");\n-        }\n-\n-        \/\/ detecting input and output buffer overlap may be tricky\n-        \/\/ we can only write directly into output buffer when we\n-        \/\/ are 100% sure it's safe to do so\n-\n-        boolean a1 = input.hasArray();\n-        boolean a2 = output.hasArray();\n-        int total = 0;\n-\n-        if (a1) { \/\/ input has an accessible byte[]\n-            byte[] inArray = input.array();\n-            int inOfs = input.arrayOffset() + inPos;\n-\n-            if (a2) { \/\/ output has an accessible byte[]\n-                byte[] outArray = output.array();\n-                int outPos = output.position();\n-                int outOfs = output.arrayOffset() + outPos;\n-\n-                \/\/ check array address and offsets and use temp output buffer\n-                \/\/ if output offset is larger than input offset and\n-                \/\/ falls within the range of input data\n-                boolean useTempOut = false;\n-                if (inArray == outArray &&\n-                    ((inOfs < outOfs) && (outOfs < inOfs + inLen))) {\n-                    useTempOut = true;\n-                    outArray = new byte[outLenNeeded];\n-                    outOfs = 0;\n-                }\n-                if (isUpdate) {\n-                    total = engineUpdate(inArray, inOfs, inLen, outArray, outOfs);\n-                } else {\n-                    total = engineDoFinal(inArray, inOfs, inLen, outArray, outOfs);\n-                }\n-                if (useTempOut) {\n-                    output.put(outArray, outOfs, total);\n-                } else {\n-                    \/\/ adjust output position manually\n-                    output.position(outPos + total);\n-                }\n-                \/\/ adjust input position manually\n-                input.position(inLimit);\n-            } else { \/\/ output does not have an accessible byte[]\n-                byte[] outArray;\n-                if (isUpdate) {\n-                    outArray = engineUpdate(inArray, inOfs, inLen);\n-                } else {\n-                    outArray = engineDoFinal(inArray, inOfs, inLen);\n-                }\n-                if (outArray != null && outArray.length != 0) {\n-                    output.put(outArray);\n-                    total = outArray.length;\n-                }\n-                \/\/ adjust input position manually\n-                input.position(inLimit);\n-            }\n-        } else { \/\/ input does not have an accessible byte[]\n-\n-            if (!isUpdate && core.getMode() == CipherCore.GCM_MODE) {\n-                    return core.gcmDoFinal(input, output);\n-            } else {\n-                \/\/ have to assume the worst, since we have no way of determine\n-                \/\/ if input and output overlaps or not\n-                byte[] tempOut = new byte[outLenNeeded];\n-                int outOfs = 0;\n-\n-                byte[] tempIn = new byte[Math.min(4096, inLen)];\n-                do {\n-                    int chunk = Math.min(inLen, tempIn.length);\n-                    if (chunk > 0) {\n-                        input.get(tempIn, 0, chunk);\n-                    }\n-                    int n;\n-                    if (isUpdate || (inLen > chunk)) {\n-                        n = engineUpdate(tempIn, 0, chunk, tempOut, outOfs);\n-                    } else {\n-                        n = engineDoFinal(tempIn, 0, chunk, tempOut, outOfs);\n-                    }\n-                    outOfs += n;\n-                    total += n;\n-                    inLen -= chunk;\n-                } while (inLen > 0);\n-                if (total > 0) {\n-                    output.put(tempOut, 0, total);\n-                }\n-            }\n+    @Override\n+    protected int engineDoFinal(ByteBuffer input, ByteBuffer output)\n+        throws ShortBufferException, IllegalBlockSizeException,\n+        BadPaddingException {\n+        if (core.getMode() == CipherCore.GCM_MODE && !input.hasArray()) {\n+            return core.gcmDoFinal(input, output);\n+        } else {\n+            return super.engineDoFinal(input, output);\n@@ -774,2 +675,0 @@\n-\n-        return total;\n@@ -778,1 +677,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":16,"deletions":118,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -726,2 +726,1 @@\n-        if (getMode() != GCM_MODE && (output == null ||\n-            ((output.length - outputOffset) < len))) {\n+        if (output == null || (output.length - outputOffset) < len) {\n@@ -935,1 +934,1 @@\n-            if (output.length - outputOffset < estOutSize) {\n+            if (outputCapacity < estOutSize) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -127,3 +127,2 @@\n-        if (dst.remaining() < inLen) {\n-            throw new RuntimeException(\"output buffer too small\");\n-        }\n+        \/\/ See GaloisCounterMode. decryptFinal(bytebuffer, bytebuffer) for\n+        \/\/ details on the check for 'dst' having enough space for the result.\n@@ -153,1 +152,1 @@\n-                dst.get(out, 0, MAX_LEN);\n+                dst.put(out, 0, MAX_LEN);\n@@ -158,1 +157,4 @@\n-            dst.put(out, 0, processed);\n+            \/\/ If dst is less than blocksize, insert only what it can.  Extra\n+            \/\/ bytes would cause buffers with enough size to fail with a\n+            \/\/ short buffer\n+            dst.put(out, 0, Math.min(dst.remaining(), processed));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+        inLen -= (inLen % AES_BLOCK_SIZE);\n@@ -211,1 +212,0 @@\n-        inLen -= (inLen % AES_BLOCK_SIZE);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -500,2 +500,0 @@\n-     * @exception ProviderException if <code>len<\/code> is not\n-     * a multiple of the block size\n@@ -504,2 +502,2 @@\n-    int encrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n-        checkDataLength(processed, len);\n+    int encrypt(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        checkDataLength(processed, inLen);\n@@ -508,2 +506,27 @@\n-        int remainder = len % blockSize;\n-        if ( remainder > 0) {\n+        \/\/ 'len' stores the length to use with buffer 'in'.\n+        \/\/ 'inLen' stores the length returned by the method.\n+        int len = inLen;\n+\n+        \/\/ if there is enough data in the ibuffer and 'in' construct a block\n+        \/\/ to encrypt\n+\n+        if (ibuffer != null && ibuffer.size() > 0 &&\n+            (inLen + ibuffer.size() >= blockSize)) {\n+            ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n+            ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n+            byte[] block = new byte[blockSize];\n+            int inLenUsed = constructBlock(ibuffer.toByteArray(), in, block);\n+            gctrPAndC.update(block, 0, blockSize, out, outOfs);\n+            processed += blockSize;\n+            ghashAllToS.update(out, outOfs, blockSize);\n+            inOfs += inLenUsed;\n+            inLen -= inLenUsed;\n+            len += (blockSize - inLenUsed);\n+            outOfs += blockSize;\n+            ibuffer.reset();\n+        }\n+\n+        \/\/ if there it not enough data in the ibuffer and 'in', then append\n+        \/\/ that to the ibuffer.\n+        int remainder = inLen % blockSize;\n+        if (remainder > 0) {\n@@ -511,1 +534,1 @@\n-                ibuffer = new ByteArrayOutputStream(len % blockSize);\n+                ibuffer = new ByteArrayOutputStream(inLen % blockSize);\n@@ -514,1 +537,3 @@\n-            ibuffer.write(in, len, remainder);\n+            inLen -= remainder;\n+            \/\/ remainder offset is based on original buffer length\n+            ibuffer.write(in, inOfs + inLen, remainder);\n@@ -516,0 +541,1 @@\n+\n@@ -517,2 +543,2 @@\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs, len);\n+            ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n+            ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n@@ -520,3 +546,3 @@\n-            gctrPAndC.update(in, inOfs, len, out, outOfs);\n-            processed += len;\n-            ghashAllToS.update(out, outOfs, len);\n+            gctrPAndC.update(in, inOfs, inLen, out, outOfs);\n+            processed += inLen;\n+            ghashAllToS.update(out, outOfs, inLen);\n@@ -528,0 +554,15 @@\n+    \/\/ Returns length of bytes taken from 'in' buffer\n+    int constructBlock(byte[] buffer, byte[] in, byte[] block) {\n+        int buflen = buffer.length;\n+        if (buflen >= blockSize) {\n+            System.arraycopy(buffer, 0, block, 0, blockSize);\n+            buflen -= block.length;\n+            return 0;\n+        } else {\n+            System.arraycopy(buffer, 0, block, 0, buflen);\n+            System.arraycopy(in, buflen, block, buflen,\n+                blockSize - buflen);\n+            return blockSize - buflen;\n+        }\n+    }\n+\n@@ -729,0 +770,10 @@\n+\n+        \/\/ Check that the dst buffer is large enough for the plaintext.  This\n+        \/\/ is done here as gctr requires extra bytes to complete a blockSize\n+        \/\/ The unnecessary extra bytes can cause buffers with enough size for\n+        \/\/ the data to fail with a short buffer exception\n+        if ((src.remaining() + ((ibuffer != null) ? ibuffer.size() : 0) -\n+            tagLenBytes) > dst.remaining()) {\n+            throw new RuntimeException(\"output buffer too small\");\n+        }\n+\n@@ -746,1 +797,0 @@\n-            ct.mark();\n@@ -770,2 +820,1 @@\n-        if ((ibuffer.size() + ct.remaining()) - tagLenBytes >\n-            dst.remaining()) {\n+        if (len > dst.remaining()) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":65,"deletions":16,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * scenerio and is complicated by getOutputSize calculations.\n+ * scenario and is complicated by getOutputSize calculations.\n@@ -42,0 +42,1 @@\n+import java.security.SecureRandom;\n@@ -47,0 +48,1 @@\n+\n@@ -49,0 +51,1 @@\n+    \/\/ Data map\n@@ -54,0 +57,11 @@\n+    \/\/ The remaining input data length is inserted at the particular index\n+    \/\/ in sizes[] during execution.\n+    static final int REMAINDER = -1;\n+\n+    String algo;\n+    boolean same = true;\n+    int[] sizes;\n+    boolean incremental = false;\n+    \/\/ In some cases the theoretical check is too complicated to verify\n+    boolean theoreticalCheck;\n+    List<Data> dataSet;\n@@ -56,0 +70,1 @@\n+        int id;\n@@ -63,1 +78,1 @@\n-        Data(String keyalgo, String key, String iv, byte[] pt, String aad,\n+        Data(String keyalgo, int id, String key, String iv, byte[] pt, String aad,\n@@ -65,0 +80,1 @@\n+            this.id = id;\n@@ -73,1 +89,1 @@\n-        Data(String keyalgo, String key, String iv, String pt, String aad,\n+        Data(String keyalgo, int id, String key, String iv, String pt, String aad,\n@@ -75,1 +91,2 @@\n-            this(keyalgo, key, iv, HexToBytes(pt), aad, ct, tag);\n+            this(keyalgo, id, key, iv, HexToBytes(pt), aad, ct, tag);\n+        }\n@@ -77,0 +94,23 @@\n+        Data(String keyalgo, int id, String key, int ptlen) {\n+            this.id = id;\n+            this.key = new SecretKeySpec(HexToBytes(key), keyalgo);\n+            iv = new byte[16];\n+            pt = new byte[ptlen];\n+            tag = new byte[12];\n+            aad = new byte[0];\n+            byte[] tct = null;\n+            try {\n+                SecureRandom r = new SecureRandom();\n+                r.nextBytes(iv);\n+                r.nextBytes(pt);\n+                Cipher c = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                c.init(Cipher.ENCRYPT_MODE, this.key,\n+                    new GCMParameterSpec(tag.length * 8, this.iv));\n+                tct = c.doFinal(pt);\n+            } catch (Exception e) {\n+                System.out.println(\"Error in generating data for length \" +\n+                    ptlen);\n+            }\n+            ct = new byte[ptlen];\n+            System.arraycopy(tct, 0, ct, 0, ct.length);\n+            System.arraycopy(tct, ct.length, tag, 0, tag.length);\n@@ -81,2 +121,9 @@\n-\n-    GCMBufferTest(String algo, List<dtype> ops, boolean same) throws Exception {\n+    \/**\n+     * Construct a test with an algorithm and a list of dtype.\n+     * @param algo Algorithm string\n+     * @param ops List of dtypes.  If only one dtype is specified, only a\n+     *            doFinal operation will occur.  If multiple dtypes are\n+     *            specified, the last is a doFinal, the others are updates.\n+     *\/\n+    GCMBufferTest(String algo, List<dtype> ops) {\n+        this.algo = algo;\n@@ -84,10 +131,22 @@\n-        int i = 1;\n-        System.out.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n-        for (Data data : datamap.get(algo)) {\n-            System.out.println(\"Encrypt:  Data Index: \" + i);\n-            encrypt(algo, data, 0);\n-            encrypt(algo, data, 2);\n-            if (same) {\n-                encrypt(algo, data, 0, true);\n-                encrypt(algo, data, 2, true);\n-            }\n+        theoreticalCheck = true;\n+        dataSet = datamap.get(algo);\n+    }\n+\n+    \/**\n+     * Define particular data sizes to be tested.  \"REMAINDER\", which has a\n+     * value of -1, can be used to insert the remaining input text length at\n+     * that index during execution.\n+     * @param sizes Data sizes for each dtype in the list.\n+     *\/\n+    GCMBufferTest dataSegments(int[] sizes) {\n+        this.sizes = sizes;\n+        return this;\n+    }\n+\n+    \/**\n+     * Do not perform in-place operations\n+     *\/\n+    GCMBufferTest differentBufferOnly() {\n+        this.same = false;\n+        return this;\n+    }\n@@ -95,6 +154,20 @@\n-            System.out.println(\"Decrypt:  Data Index: \" + i);\n-            decrypt(algo, data, 0);\n-            decrypt(algo, data, 2);\n-            if (same) {\n-                decrypt(algo, data, 0, true);\n-                decrypt(algo, data, 2, true);\n+    \/**\n+     * Enable incrementing through each data size available.  This can only be\n+     * used when the List has more than one dtype entry.\n+     *\/\n+    GCMBufferTest incrementalSegments() {\n+        this.incremental = true;\n+        \/\/this.theoreticalCheck = false;\n+        return this;\n+    }\n+\n+    \/**\n+     * Specify a particular test dataset.\n+     *\n+     * @param id id value for the test data to used in this test.\n+     *\/\n+    GCMBufferTest dataSet(int id) throws Exception {\n+        for (Data d : datamap.get(algo)) {\n+            if (d.id == id) {\n+                dataSet = List.of(d);\n+                return this;\n@@ -102,1 +175,0 @@\n-            i++;\n@@ -104,0 +176,1 @@\n+        throw new Exception(\"Unaeble to find dataSet id = \" + id);\n@@ -106,2 +179,20 @@\n-    GCMBufferTest(String algo, List<dtype> ops) throws Exception {\n-        this(algo, ops, true);\n+    \/**\n+     * Reverse recursive loop that starts at the end-1 index, going to 0, in\n+     * the size array to calculate all the possible sizes.\n+     * It returns the remaining data size not used in the loop.  This remainder\n+     * is used for the end index which is the doFinal op.\n+     *\/\n+    int inc(int index, int max, int total) {\n+        if (sizes[index] == max - total) {\n+            sizes[index + 1]++;\n+            total++;\n+            sizes[index] = 0;\n+        } else if (index == 0) {\n+            sizes[index]++;\n+        }\n+\n+        total += sizes[index];\n+        if (index > 0) {\n+            return inc(index - 1, max, total);\n+        }\n+        return total;\n@@ -110,2 +201,8 @@\n-    void encrypt(String algo, Data data, int offset) throws Exception {\n-        encrypt(algo, data, offset, false);\n+    \/\/ Call recursive loop and take returned remainder value for last index\n+    boolean incrementSizes(int max) {\n+        sizes[ops.size() - 1] = max - inc(ops.size() - 2, max, 0);\n+        if (sizes[ops.size() - 2] == max) {\n+            \/\/ We are at the end, exit test loop\n+            return false;\n+        }\n+        return true;\n@@ -114,2 +211,49 @@\n-    void encrypt(String algo, Data data, int offset, boolean same)\n-        throws Exception {\n+    void test() throws Exception {\n+        int i = 1;\n+        System.out.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n+        for (Data data : dataSet) {\n+\n+            \/\/ If incrementalSegments is enabled, run through that test only\n+            if (incremental) {\n+                if (ops.size() < 2) {\n+                    throw new Exception(\"To do incrementalSegments you must\" +\n+                        \"have more that 1 dtype in the list\");\n+                }\n+                sizes = new int[ops.size()];\n+\n+                while (incrementSizes(data.pt.length)) {\n+                    System.out.print(\"Encrypt:  Data Index: \" + i + \"\\tSizes[ \");\n+                    for (int v : sizes) {\n+                        System.out.print(v + \" \");\n+                    }\n+                    System.out.println(\"]\");\n+                    encrypt(data, 0);\n+                }\n+                Arrays.fill(sizes, 0);\n+\n+                while (incrementSizes(data.ct.length + data.tag.length)) {\n+                    System.out.print(\"Decrypt:  Data Index: \" + i + \"\\tSizes[ \");\n+                    for (int v : sizes) {\n+                        System.out.print(v + \" \");\n+                    }\n+                    System.out.println(\"]\");\n+                    decrypt(data, 0);\n+                }\n+\n+            } else {\n+                \/\/ Default test of 0 and 2 offset doing in place and different\n+                \/\/ i\/o buffers\n+                System.out.println(\"Encrypt:  Data Index: \" + i);\n+                encrypt(data, 0);\n+                encrypt(data, 2);\n+\n+                System.out.println(\"Decrypt:  Data Index: \" + i);\n+                decrypt(data, 0);\n+                decrypt(data, 2);\n+            }\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Setup data for encryption\n+    void encrypt(Data data, int offset) throws Exception {\n@@ -118,5 +262,0 @@\n-        System.out.print(\"\\t input len: \" + data.pt.length + \"  offset: \" +\n-            offset + \"  in-place: \");\n-        Cipher cipher = Cipher.getInstance(algo);\n-        cipher.init(Cipher.ENCRYPT_MODE, data.key, new GCMParameterSpec(\n-            data.tag.length * 8, data.iv));\n@@ -128,8 +267,0 @@\n-        if (!same) {\n-            System.out.println(\"different\");\n-            crypto(cipher, true, offset, input, output, data.aad);\n-        } else {\n-            System.out.println(\"same\");\n-            cryptoSameBuffer(cipher, true, offset, input, output, data.aad);\n-        }\n-    }\n@@ -137,2 +268,11 @@\n-    void decrypt(String algo, Data data, int offset) throws Exception {\n-        decrypt(algo, data, offset, false);\n+        \/\/ Test different input\/output buffers\n+        System.out.println(\"\\t input len: \" + input.length + \"  offset: \" +\n+            offset + \"  in\/out buffer: different\");\n+        crypto(true, data, offset, input, output);\n+\n+        \/\/ Test with in-place buffers\n+        if (same) {\n+            System.out.println(\"\\t input len: \" + input.length +\n+                \"  offset: \" + offset + \"  in\/out buffer: in-place\");\n+            cryptoSameBuffer(true, data, offset, input, output);\n+        }\n@@ -141,2 +281,2 @@\n-    void decrypt(String algo, Data data, int offset, boolean same)\n-        throws Exception {\n+    \/\/ Setup data for decryption\n+    void decrypt(Data data, int offset) throws Exception {\n@@ -145,5 +285,0 @@\n-        System.out.print(\"\\t input len: \" + data.pt.length + \"  offset: \" +\n-            offset + \"  in-place: \");\n-        Cipher cipher = Cipher.getInstance(algo);\n-        cipher.init(Cipher.DECRYPT_MODE, data.key,\n-            new GCMParameterSpec(data.tag.length * 8, data.iv));\n@@ -154,6 +289,10 @@\n-        if (!same) {\n-            System.out.println(\"different\");\n-            crypto(cipher, false, offset, input, output, data.aad);\n-        } else {\n-            System.out.println(\"same\");\n-            cryptoSameBuffer(cipher, false, offset, input, output, data.aad);\n+\n+        \/\/ Test different input\/output buffers\n+        System.out.println(\"\\t input len: \" + input.length + \"  offset: \"\n+            + offset + \"  in-place: different\");\n+\n+        \/\/ Test with in-place buffers\n+        if (same) {\n+            System.out.println(\"\\t input len: \" + input.length +\n+                \"  offset: \" + offset + \"  in-place: same\");\n+            cryptoSameBuffer(false, data, offset, input, output);\n@@ -163,2 +302,6 @@\n-    void crypto(Cipher cipher, boolean encrypt, int offset, byte[] input,\n-        byte[] output, byte[] aad) throws Exception {\n+    \/**\n+     * Perform cipher operation using different input and output buffers.\n+     *   This method allows mixing of data types (byte, heap, direct).\n+     *\/\n+     void crypto(boolean encrypt, Data d, int offset, byte[] input,\n+        byte[] output) throws Exception {\n@@ -168,5 +311,6 @@\n-        int theorticallen = plen - (plen % AESBLOCK); \/\/ output length\n-        int inofs = 0;\n-        int dataoffset = 0;\n-        int index = 0;\n-        int rlen = 0; \/\/ result length\n+        int theoreticallen;\/\/ expected output length\n+        int inofs = offset;\n+        int dataoffset = 0; \/\/ offset of unconsumed data in pt\n+        int index = 0; \/\/ index of which op we are on\n+        int rlen; \/\/ result length\n+        int pbuflen = 0; \/\/ plen remaining in the GCM internal buffers\n@@ -174,1 +318,4 @@\n-        cipher.updateAAD(aad);\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n+            d.key, new GCMParameterSpec(d.tag.length * 8, d.iv));\n+        cipher.updateAAD(d.aad);\n@@ -178,4 +325,11 @@\n-            if (++index < ops.size()) {\n-                int olen = cipher.getOutputSize(plen) + offset; \/\/ output length\n-                if (plen > offset) {\n-                    inofs = offset;\n+            if (index < ops.size() - 1) {\n+                if (sizes != null && input.length > 0) {\n+                    if (sizes[index] == -1) {\n+                        plen = input.length - dataoffset;\n+                    } else {\n+                        if (sizes[index] > input.length) {\n+                            plen = input.length;\n+                        } else {\n+                            plen = sizes[index];\n+                        }\n+                    }\n@@ -183,0 +337,11 @@\n+\n+                int olen = cipher.getOutputSize(plen) + offset;\n+\n+                \/*\n+                 * The theoretical limit is the length of the data sent to\n+                 * update() + any data might be setting in CipherCore or GCM\n+                 * internal buffers % the block size.\n+                 *\/\n+                theoreticallen = (plen + pbuflen) - ((plen + pbuflen) % AESBLOCK);\n+\n+                \/\/ Update operations\n@@ -186,1 +351,2 @@\n-                        rlen = cipher.update(pt, inofs, plen, out, offset);\n+                        rlen = cipher.update(pt, dataoffset + inofs, plen, out,\n+                            offset);\n@@ -218,4 +384,7 @@\n-                if (encrypt && rlen != theorticallen) {\n-                    throw new Exception(\"Wrong update return len (\" +\n-                        v.name() + \"):  \" + \"rlen=\" + rlen +\n-                        \", expected output len=\" + theorticallen);\n+                if (theoreticalCheck) {\n+                    pbuflen += plen - rlen;\n+                    if (encrypt && rlen != theoreticallen) {\n+                        throw new Exception(\"Wrong update return len (\" +\n+                            v.name() + \"):  \" + \"rlen=\" + rlen +\n+                            \", expected output len=\" + theoreticallen);\n+                    }\n@@ -225,0 +394,1 @@\n+                index++;\n@@ -227,0 +397,1 @@\n+                \/\/ doFinal operation\n@@ -228,3 +399,1 @@\n-                if (plen > offset) {\n-                    inofs = offset;\n-                }\n+\n@@ -272,1 +441,1 @@\n-                if (rlen != olen - offset) {\n+                if (theoreticalCheck && rlen != olen - offset) {\n@@ -278,0 +447,1 @@\n+                \/\/ Verify results\n@@ -293,2 +463,9 @@\n-    void cryptoSameBuffer(Cipher cipher, boolean encrypt, int offset,\n-        byte[] input, byte[] output, byte[] aad) throws Exception {\n+    \/**\n+     * Perform cipher operation using in-place buffers.  This method does not\n+     * allow mixing of data types (byte, heap, direct).\n+     *\n+     * Mixing data types makes no sense for in-place operations and would\n+     * greatly complicate the test code.\n+     *\/\n+    void cryptoSameBuffer(boolean encrypt, Data d, int offset,\n+        byte[] input, byte[] output) throws Exception {\n@@ -299,1 +476,0 @@\n-        cipher.updateAAD(aad);\n@@ -302,1 +478,0 @@\n-        int inofs = 0;\n@@ -308,0 +483,6 @@\n+        Cipher cipher = Cipher.getInstance(algo);\n+        cipher.init((encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),\n+            d.key, new GCMParameterSpec(d.tag.length * 8, d.iv));\n+        cipher.updateAAD(d.aad);\n+\n+        \/\/ Prepare data\n@@ -324,0 +505,1 @@\n+        \/\/ Set data limits for bytebuffers\n@@ -333,1 +515,1 @@\n-        ByteArrayOutputStream ba = new ByteArrayOutputStream();\n+        \/\/ Iterate through each operation\n@@ -335,4 +517,1 @@\n-            if (++index < ops.size()) {\n-                if (plen > offset) {\n-                    inofs = offset;\n-                }\n+            if (index < ops.size() - 1) {\n@@ -341,1 +520,2 @@\n-                        rlen = cipher.update(data, inofs, plen, data, offset);\n+                        rlen = cipher.update(data, dataoffset + offset, plen,\n+                            data, len + offset);\n@@ -351,1 +531,2 @@\n-                if (encrypt && rlen != theorticallen) {\n+                \/\/ Check that the theoretical return value matches the actual.\n+                if (theoreticalCheck && encrypt && rlen != theorticallen) {\n@@ -359,0 +540,1 @@\n+                index++;\n@@ -361,0 +543,1 @@\n+                \/\/ Run doFinal op\n@@ -362,3 +545,1 @@\n-                if (plen > offset) {\n-                    inofs = offset;\n-                }\n+\n@@ -367,4 +548,4 @@\n-                        rlen = cipher.doFinal(data, dataoffset + inofs,\n-                            plen, data, len + inofs);\n-                        out = Arrays.copyOfRange(data, inofs,\n-                            len + rlen + inofs);\n+                        rlen = cipher.doFinal(data, dataoffset + offset,\n+                            plen, data, len + offset);\n+                        out = Arrays.copyOfRange(data, offset,\n+                            len + rlen + offset);\n@@ -383,0 +564,1 @@\n+                \/\/ Verify results\n@@ -397,8 +579,0 @@\n-    String byteToHex(byte[] barray) {\n-        StringBuilder s = new StringBuilder();\n-        for (byte b : barray) {\n-            s.append(String.format(\"%02x\", b));\n-        }\n-        return s.toString();\n-    }\n-\n@@ -409,1 +583,33 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE));\n+        \/\/ Test single byte array\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)).test();\n+        \/\/ Test update-doFinal with byte arrays\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE)).test();\n+        \/\/ Test update-update-doFinal with byte arrays\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).test();\n+\n+        \/\/ Test single heap bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)).test();\n+        \/\/ Test update-doFinal with heap bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP)).test();\n+        \/\/ Test update-update-doFinal with heap bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)).test();\n+\n+        \/\/ Test single direct bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)).test();\n+        \/\/ Test update-doFinal with direct bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)).test();\n+        \/\/ Test update-update-doFinal with direct bytebuffer\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).test();\n+\n+        \/\/ Test update-update-doFinal with byte arrays and preset data sizes\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).dataSegments(\n+            new int[] { 1, 1, GCMBufferTest.REMAINDER}).test();\n+\n+        \/\/ Test update-doFinal with a byte array and a direct bytebuffer\n@@ -411,2 +617,2 @@\n-            List.of(dtype.BYTE, dtype.BYTE));\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP));\n+            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly().test();\n+        \/\/ Test update-doFinal with a byte array and heap and direct bytebuffer\n@@ -414,2 +620,3 @@\n-            List.of(dtype.HEAP, dtype.HEAP));\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT));\n+            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly()\n+            .test();\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array.\n@@ -417,1 +624,17 @@\n-            List.of(dtype.BYTE, dtype.DIRECT), false);\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().test();\n+\n+        \/\/ Test update-doFinal with a direct bytebuffer and a byte array with\n+        \/\/ preset data sizes.\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().\n+            dataSegments(new int[] { 20, GCMBufferTest.REMAINDER }).test();\n+        \/\/ Test update-update-doFinal with a direct and heap bytebuffer and a\n+        \/\/ byte array with preset data sizes.\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE, dtype.HEAP)).\n+            differentBufferOnly().dataSet(5).\n+            dataSegments(new int[] { 5000, 1000, GCMBufferTest.REMAINDER }).\n+            test();\n+\n+        \/\/ Test update-update-doFinal with byte arrays, incrementing through\n+        \/\/ every data size combination for the Data set 0\n@@ -419,1 +642,4 @@\n-            List.of(dtype.DIRECT, dtype.BYTE), false);\n+            List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)).incrementalSegments().\n+            dataSet(0).test();\n+        \/\/ Test update-update-doFinal with direct bytebuffers, incrementing through\n+        \/\/ every data size combination for the Data set 0\n@@ -421,1 +647,2 @@\n-            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT), false);\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            incrementalSegments().dataSet(0).test();\n@@ -436,5 +663,7 @@\n-    static void initTest() {\n-        byte[] in = new byte[256];\n-        byte[] inx = new byte[2075];\n-        Arrays.fill(in, (byte) 0);\n-        Arrays.fill(inx, (byte) 0);\n+    private static String byteToHex(byte[] barray) {\n+        StringBuilder s = new StringBuilder();\n+        for (byte b : barray) {\n+            s.append(String.format(\"%02x\", b));\n+        }\n+        return s.toString();\n+    }\n@@ -442,0 +671,2 @@\n+    \/\/ Test data\n+    static void initTest() {\n@@ -443,1 +674,2 @@\n-            new Data(\"AES\",\n+            \/\/ GCM KAT\n+            new Data(\"AES\", 0,\n@@ -457,1 +689,2 @@\n-            new Data(\"AES\", \"11754cd72aec309bf52f7687212e8957\",\n+            \/\/ GCM KAT\n+            new Data(\"AES\", 1, \"11754cd72aec309bf52f7687212e8957\",\n@@ -461,1 +694,2 @@\n-            new Data(\"AES\", \"272f16edb81a7abbea887357a58c1917\",\n+            \/\/ GCM KAT\n+            new Data(\"AES\", 2, \"272f16edb81a7abbea887357a58c1917\",\n@@ -465,1 +699,2 @@\n-            new Data(\"AES\", \"272f16edb81a7abbea887357a58c1917\",\n+            \/\/ zero'd test data\n+            new Data(\"AES\", 3, \"272f16edb81a7abbea887357a58c1917\",\n@@ -467,1 +702,1 @@\n-                in, null,\n+                new byte[256], null,\n@@ -477,1 +712,2 @@\n-            new Data(\"AES\", \"272f16edb81a7abbea887357a58c1917\",\n+            \/\/ Random test data\n+            new Data(\"AES\", 4, \"272f16edb81a7abbea887357a58c1917\",\n@@ -479,1 +715,1 @@\n-                inx, null,\n+                new byte[2075], null,\n@@ -545,1 +781,5 @@\n-                \"687cc09c89298491deb51061d709af\")));\n+                \"687cc09c89298491deb51061d709af\"),\n+            \/\/ Randomly generated data at the time of execution.\n+            new Data(\"AES\", 5, \"11754cd72aec309bf52f7687212e8957\", 12345)\n+            )\n+        );\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":365,"deletions":125,"binary":false,"changes":490,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Uses GCMBufferTest to run a long test with incrementing through\n+ * each byte in each byte array\n+ * @run main\/manual GCMIncrementByte4\n+ *\/\n+\n+public class GCMIncrementByte4 {\n+\n+    public static void main(String args[]) throws Exception {\n+        GCMBufferTest.initTest();\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(GCMBufferTest.dtype.BYTE, GCMBufferTest.dtype.BYTE,\n+                GCMBufferTest.dtype.BYTE)).incrementalSegments().dataSet(4).\n+            test();\n+\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementByte4.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Uses GCMBufferTest to run a long test with incrementing through\n+ * each byte in each direct bytebuffer\n+ * @run main\/manual GCMIncrementDirect4\n+ *\/\n+\n+public class GCMIncrementDirect4 {\n+\n+    public static void main(String args[]) throws Exception {\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(GCMBufferTest.dtype.DIRECT, GCMBufferTest.dtype.DIRECT,\n+                GCMBufferTest.dtype.DIRECT)).incrementalSegments().dataSet(4).\n+            test();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementDirect4.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}