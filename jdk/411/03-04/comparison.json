{"files":[{"patch":"@@ -936,0 +936,2 @@\n+            }\n+            if (getMode() != GCM_MODE || outputCapacity < estOutSize) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.security.util.ArrayUtil;\n+\n+import javax.crypto.AEADBadTagException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.ShortBufferException;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n@@ -29,3 +37,4 @@\n-import java.io.*;\n-import java.security.*;\n-import javax.crypto.*;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.ProviderException;\n+\n@@ -33,1 +42,0 @@\n-import sun.security.util.ArrayUtil;\n@@ -74,0 +82,3 @@\n+    \/\/ Original dst buffer if there was an overlap situation\n+    private ByteBuffer originalDst = null;\n+\n@@ -180,2 +191,11 @@\n-    private static void checkDataLength(int processed, int len) {\n-        if (processed > MAX_BUF_SIZE - len) {\n+    \/**\n+     * Calculate if the given data lengths and the already processed data\n+     * exceeds the maximum allowed processed data by GCM.\n+     * @param lengths lengths of unprocessed data.\n+     *\/\n+    private void checkDataLength(int ... lengths) {\n+        int max = MAX_BUF_SIZE;\n+        for (int len : lengths) {\n+            max = Math.subtractExact(max, len);\n+        }\n+        if (processed > max) {\n@@ -497,1 +517,1 @@\n-     * @param len the length of the input data\n+     * @param inLen the length of the input data\n@@ -503,1 +523,2 @@\n-        checkDataLength(processed, inLen);\n+        checkDataLength(inLen, getBufferedLength());\n+        ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n@@ -506,2 +527,2 @@\n-        \/\/ 'len' stores the length to use with buffer 'in'.\n-        \/\/ 'inLen' stores the length returned by the method.\n+        \/\/ 'inLen' stores the length to use with buffer 'in'.\n+        \/\/ 'len' stores the length returned by the method.\n@@ -510,2 +531,14 @@\n-        \/\/ if there is enough data in the ibuffer and 'in' construct a block\n-        \/\/ to encrypt\n+        \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+        if (ibuffer != null && ibuffer.size() > 0) {\n+            byte[] buffer = ibuffer.toByteArray();\n+            \/\/ number of bytes not filling a block\n+            int remainder = ibuffer.size() % blockSize;\n+            \/\/ number of bytes along block boundary\n+            int blen = ibuffer.size() - remainder;\n+\n+            \/\/ If there is enough bytes in ibuffer for a block or more,\n+            \/\/ encrypt that first.\n+            if (blen > 0) {\n+                encryptBlocks(buffer, 0, blen, out, outOfs);\n+                outOfs += blen;\n+            }\n@@ -513,14 +546,30 @@\n-        if (ibuffer != null && ibuffer.size() > 0 &&\n-            (inLen + ibuffer.size() >= blockSize)) {\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n-            byte[] block = new byte[blockSize];\n-            int inLenUsed = constructBlock(ibuffer.toByteArray(), in, block);\n-            gctrPAndC.update(block, 0, blockSize, out, outOfs);\n-            processed += blockSize;\n-            ghashAllToS.update(out, outOfs, blockSize);\n-            inOfs += inLenUsed;\n-            inLen -= inLenUsed;\n-            len += (blockSize - inLenUsed);\n-            outOfs += blockSize;\n-            ibuffer.reset();\n+            \/\/ blen is now the offset for 'buffer'\n+\n+            \/\/ Construct and encrypt a block if there is enough 'buffer' and\n+            \/\/ 'in' to make one\n+            if ((inLen + remainder) >= blockSize) {\n+                ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n+                byte[] block = new byte[blockSize];\n+\n+                System.arraycopy(buffer, blen, block, 0, remainder);\n+                int inLenUsed = blockSize - remainder;\n+                System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n+\n+                encryptBlocks(block, 0, blockSize, out, outOfs);\n+                inOfs += inLenUsed;\n+                inLen -= inLenUsed;\n+                len += (blockSize - inLenUsed);\n+                outOfs += blockSize;\n+                ibuffer.reset();\n+                \/\/ Code below will write the remainder from 'in' to ibuffer\n+            } else if (blen > 0) {\n+                \/\/ If a block or more was encrypted from 'buffer' only, but the\n+                \/\/ rest of 'buffer' with 'in' could not construct a block, then\n+                \/\/ put the rest if 'buffer' back into ibuffer.\n+                ibuffer.reset();\n+                ibuffer.write(buffer, blen, remainder);\n+                \/\/ Code below will write the remainder from 'in' to ibuffer\n+            }\n+            \/\/ If blen == 0 and there was not enough to construct a block\n+            \/\/ from 'buffer' and 'in', then let the below code append 'in' to\n+            \/\/ the ibuffer.\n@@ -529,2 +578,1 @@\n-        \/\/ if there it not enough data in the ibuffer and 'in', then append\n-        \/\/ that to the ibuffer.\n+        \/\/ Write any remaining bytes outside the blockSize into ibuffer.\n@@ -542,0 +590,1 @@\n+        \/\/ Encrypt the remaining blocks inside of 'in'\n@@ -543,1 +592,0 @@\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n@@ -545,4 +593,1 @@\n-\n-            gctrPAndC.update(in, inOfs, inLen, out, outOfs);\n-            processed += inLen;\n-            ghashAllToS.update(out, outOfs, inLen);\n+            encryptBlocks(in, inOfs, inLen, out, outOfs);\n@@ -554,13 +599,4 @@\n-    \/\/ Returns length of bytes taken from 'in' buffer\n-    int constructBlock(byte[] buffer, byte[] in, byte[] block) {\n-        int buflen = buffer.length;\n-        if (buflen >= blockSize) {\n-            System.arraycopy(buffer, 0, block, 0, blockSize);\n-            buflen -= block.length;\n-            return 0;\n-        } else {\n-            System.arraycopy(buffer, 0, block, 0, buflen);\n-            System.arraycopy(in, buflen, block, buflen,\n-                blockSize - buflen);\n-            return blockSize - buflen;\n-        }\n+    void encryptBlocks(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n+        gctrPAndC.update(in, inOfs, len, out, outOfs);\n+        processed += len;\n+        ghashAllToS.update(out, outOfs, len);\n@@ -581,1 +617,1 @@\n-        checkDataLength(processed, Math.addExact(len, tagLenBytes));\n+        checkDataLength(len, getBufferedLength(), tagLenBytes);\n@@ -609,0 +645,1 @@\n+        dst = overlapDetection(src, dst);\n@@ -610,5 +647,1 @@\n-        if (ibuffer != null) {\n-            len += ibuffer.size();\n-        }\n-\n-        checkDataLength(processed, Math.addExact(len, tagLenBytes));\n+        len += getBufferedLength();\n@@ -616,0 +649,2 @@\n+        \/\/ 'len' includes ibuffer data\n+        checkDataLength(len, tagLenBytes);\n@@ -635,0 +670,1 @@\n+        restoreDst(dst);\n@@ -657,2 +693,0 @@\n-        checkDataLength(ibuffer.size(), len);\n-\n@@ -710,1 +744,1 @@\n-        checkDataLength(ibuffer.size(), (len - tagLenBytes));\n+        checkDataLength(getBufferedLength(), (len - tagLenBytes));\n@@ -714,1 +748,1 @@\n-                (ibuffer.size() + len) - tagLenBytes);\n+                (getBufferedLength() + len) - tagLenBytes);\n@@ -730,1 +764,1 @@\n-        if (in == out || ibuffer.size() > 0) {\n+        if (in == out || getBufferedLength() > 0) {\n@@ -771,9 +805,1 @@\n-        \/\/ Check that the dst buffer is large enough for the plaintext.  This\n-        \/\/ is done here as gctr requires extra bytes to complete a blockSize\n-        \/\/ The unnecessary extra bytes can cause buffers with enough size for\n-        \/\/ the data to fail with a short buffer exception\n-        if ((src.remaining() + ((ibuffer != null) ? ibuffer.size() : 0) -\n-            tagLenBytes) > dst.remaining()) {\n-            throw new RuntimeException(\"output buffer too small\");\n-        }\n-\n+        dst = overlapDetection(src, dst);\n@@ -783,1 +809,0 @@\n-        ct.mark();\n@@ -816,3 +841,2 @@\n-        \/\/ do this check here can also catch the potential integer overflow\n-        \/\/ scenario for the subsequent output buffer capacity check.\n-        checkDataLength(0, len);\n+        \/\/ 'len' contains the length in ibuffer and src\n+        checkDataLength(len);\n@@ -825,0 +849,3 @@\n+        \/\/ Set the mark for a later reset. Either it will be zero, or the tag\n+        \/\/ buffer creation above will have consume some or all of it.\n+        ct.mark();\n@@ -861,2 +888,0 @@\n-            \/\/ Prepare buffer for decryption\n-            ct.reset();\n@@ -864,0 +889,3 @@\n+        \/\/ Prepare buffer for decryption if available\n+        ct.reset();\n+\n@@ -883,1 +911,1 @@\n-\n+        restoreDst(dst);\n@@ -900,0 +928,89 @@\n+\n+    \/**\n+     * Check for overlap. If the src and dst buffers are using shared data and\n+     * if dst will overwrite src data before src can be processed.  If so, make\n+     * a copy to put the dst data in.\n+     *\/\n+    ByteBuffer overlapDetection(ByteBuffer src, ByteBuffer dst) {\n+        if (src.isDirect() && dst.isDirect()) {\n+            DirectBuffer dsrc = (DirectBuffer) src;\n+            DirectBuffer ddst = (DirectBuffer) dst;\n+\n+            \/\/ Get the current memory address for the given ByteBuffers\n+            long srcaddr = dsrc.address();\n+            long dstaddr = ddst.address();\n+\n+            \/\/ Find the lowest attachment that is the base memory address of the\n+            \/\/ shared memory for the src object\n+            while (dsrc.attachment() != null) {\n+                srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                dsrc = (DirectBuffer) dsrc.attachment();\n+            }\n+\n+            \/\/ Find the lowest attachment that is the base memory address of the\n+            \/\/ shared memory for the dst object\n+            while (ddst.attachment() != null) {\n+                dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                ddst = (DirectBuffer) ddst.attachment();\n+            }\n+\n+            \/\/ If the base addresses are not the same, there is no overlap\n+            if (srcaddr != dstaddr) {\n+                return dst;\n+            }\n+            \/\/ At this point we know these objects share the same memory.\n+            \/\/ This checks the starting position of the src and dst address for\n+            \/\/ overlap.\n+            \/\/ It uses the base address minus the passed object's address to get\n+            \/\/ the offset from the base address, then add the position() from\n+            \/\/ the passed object.  That gives up the true offset from the base\n+            \/\/ address.  As long as the src side is >= the dst side, we are not\n+            \/\/ in overlap.\n+            if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n+                ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                return dst;\n+            }\n+\n+        } else if (!src.isDirect() && !dst.isDirect()) {\n+            if (!src.isReadOnly()) {\n+                \/\/ If using the heap, check underlying byte[] address.\n+                if (!src.array().equals(dst.array()) ) {\n+                    return dst;\n+                }\n+\n+                \/\/ Position plus arrayOffset() will give us the true offset from\n+                \/\/ the underlying byte[] address.\n+                if (src.position() + src.arrayOffset() >=\n+                    dst.position() + dst.arrayOffset()) {\n+                    return dst;\n+                }\n+            }\n+        } else {\n+            \/\/ buffer types aren't the same\n+            return dst;\n+        }\n+\n+        \/\/ Create a copy\n+        ByteBuffer tmp = dst.duplicate();\n+        \/\/ We can use a heap buffer for internal use, save on alloc cost\n+        ByteBuffer bb = ByteBuffer.allocate(dst.capacity());\n+        tmp.limit(dst.limit());\n+        tmp.position(dst.position());\n+        bb.put(tmp);\n+        bb.flip();\n+        originalDst = dst;\n+        return bb;\n+    }\n+\n+    \/**\n+     * If originalDst exists, dst is an internal dst buffer, then copy the data\n+     * into the original dst buffer\n+     *\/\n+    void restoreDst(ByteBuffer dst) {\n+        if (originalDst == null) {\n+            return;\n+        }\n+\n+        dst.flip();\n+        originalDst.put(dst);\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":190,"deletions":73,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- *\n@@ -47,1 +46,1 @@\n-public class GCMBufferTest {\n+public class GCMBufferTest implements Cloneable {\n@@ -68,0 +67,1 @@\n+    int inOfs = 0, outOfs = 0;\n@@ -135,0 +135,4 @@\n+    public GCMBufferTest clone() throws CloneNotSupportedException{\n+        return (GCMBufferTest)super.clone();\n+    }\n+\n@@ -160,1 +164,0 @@\n-        \/\/this.theoreticalCheck = false;\n@@ -179,0 +182,31 @@\n+    \/**\n+     * Set both input and output offsets to the same offset\n+     * @param offset value for inOfs and outOfs\n+     * @return\n+     *\/\n+    GCMBufferTest offset(int offset) {\n+        this.inOfs = offset;\n+        this.outOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the input offset\n+     * @param offset value for input offset\n+     * @return\n+     *\/\n+    GCMBufferTest inOfs(int offset) {\n+        this.inOfs = offset;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the output offset\n+     * @param offset value for output offset\n+     * @return\n+     *\/\n+    GCMBufferTest outOfs(int offset) {\n+        this.outOfs = offset;\n+        return this;\n+    }\n+\n@@ -225,1 +259,1 @@\n-                    System.out.print(\"Encrypt:  Data Index: \" + i + \"\\tSizes[ \");\n+                    System.out.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n@@ -230,1 +264,1 @@\n-                    encrypt(data, 0);\n+                    encrypt(data);\n@@ -235,1 +269,1 @@\n-                    System.out.print(\"Decrypt:  Data Index: \" + i + \"\\tSizes[ \");\n+                    System.out.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n@@ -240,1 +274,1 @@\n-                    decrypt(data, 0);\n+                    decrypt(data);\n@@ -247,2 +281,1 @@\n-                encrypt(data, 0);\n-                encrypt(data, 2);\n+                encrypt(data);\n@@ -251,2 +284,1 @@\n-                decrypt(data, 0);\n-                decrypt(data, 2);\n+                decrypt(data);\n@@ -259,1 +291,1 @@\n-    void encrypt(Data data, int offset) throws Exception {\n+    void encrypt(Data data) throws Exception {\n@@ -269,3 +301,3 @@\n-        System.out.println(\"\\t input len: \" + input.length + \"  offset: \" +\n-            offset + \"  in\/out buffer: different\");\n-        crypto(true, data, offset, input, output);\n+        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n+        crypto(true, data, input, output);\n@@ -275,3 +307,3 @@\n-            System.out.println(\"\\t input len: \" + input.length +\n-                \"  offset: \" + offset + \"  in\/out buffer: in-place\");\n-            cryptoSameBuffer(true, data, offset, input, output);\n+            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: in-place\");\n+            cryptoSameBuffer(true, data, input, output);\n@@ -282,1 +314,1 @@\n-    void decrypt(Data data, int offset) throws Exception {\n+    void decrypt(Data data) throws Exception {\n@@ -291,2 +323,3 @@\n-        System.out.println(\"\\t input len: \" + input.length + \"  offset: \"\n-            + offset + \"  in-place: different\");\n+        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in-place: different\");\n+        crypto(false, data, input, output);\n@@ -296,3 +329,3 @@\n-            System.out.println(\"\\t input len: \" + input.length +\n-                \"  offset: \" + offset + \"  in-place: same\");\n-            cryptoSameBuffer(false, data, offset, input, output);\n+            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in-place: same\");\n+            cryptoSameBuffer(false, data, input, output);\n@@ -306,4 +339,6 @@\n-     void crypto(boolean encrypt, Data d, int offset, byte[] input,\n-        byte[] output) throws Exception {\n-        byte[] pt = new byte[input.length + offset];\n-        System.arraycopy(input, 0, pt, offset, input.length);\n+     void crypto(boolean encrypt, Data d, byte[] input, byte[] output)\n+         throws Exception {\n+        byte[] pt = new byte[input.length + inOfs];\n+        System.arraycopy(input, 0, pt, inOfs, input.length);\n+         byte[] expectedOut = new byte[output.length + outOfs];\n+         System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n@@ -312,1 +347,0 @@\n-        int inofs = offset;\n@@ -324,0 +358,1 @@\n+        ba.write(new byte[outOfs], 0, outOfs);\n@@ -338,1 +373,1 @@\n-                int olen = cipher.getOutputSize(plen) + offset;\n+                int olen = cipher.getOutputSize(plen) + outOfs;\n@@ -351,3 +386,3 @@\n-                        rlen = cipher.update(pt, dataoffset + inofs, plen, out,\n-                            offset);\n-                        ba.write(out, inofs, rlen);\n+                        rlen = cipher.update(pt, dataoffset + inOfs, plen, out,\n+                            outOfs);\n+                        ba.write(out, outOfs, rlen);\n@@ -356,3 +391,3 @@\n-                        ByteBuffer b = ByteBuffer.allocate(plen + offset);\n-                        b.position(offset);\n-                        b.put(pt, dataoffset + inofs, plen);\n+                        ByteBuffer b = ByteBuffer.allocate(plen + outOfs);\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n@@ -360,1 +395,1 @@\n-                        b.position(offset);\n+                        b.position(outOfs);\n@@ -362,1 +397,1 @@\n-                        out.position(offset);\n+                        out.position(outOfs);\n@@ -364,1 +399,1 @@\n-                        ba.write(out.array(), inofs, rlen);\n+                        ba.write(out.array(), outOfs, rlen);\n@@ -367,3 +402,3 @@\n-                        ByteBuffer b = ByteBuffer.allocateDirect(plen + offset);\n-                        b.position(offset);\n-                        b.put(pt, dataoffset + inofs, plen);\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + outOfs);\n+                        b.position(outOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n@@ -371,1 +406,1 @@\n-                        b.position(offset);\n+                        b.position(outOfs);\n@@ -373,1 +408,1 @@\n-                        out.position(offset);\n+                        out.position(outOfs);\n@@ -377,1 +412,1 @@\n-                        out.position(offset);\n+                        out.position(outOfs);\n@@ -400,1 +435,1 @@\n-                int olen = cipher.getOutputSize(plen) + offset;\n+                int olen = cipher.getOutputSize(plen) + outOfs;\n@@ -404,3 +439,3 @@\n-                        rlen = cipher.doFinal(pt, dataoffset + inofs,\n-                            plen, out, inofs);\n-                        ba.write(out, inofs, rlen);\n+                        rlen = cipher.doFinal(pt, dataoffset + inOfs,\n+                            plen, out, outOfs);\n+                        ba.write(out, outOfs, rlen);\n@@ -409,1 +444,1 @@\n-                        ByteBuffer b = ByteBuffer.allocate(plen + inofs);\n+                        ByteBuffer b = ByteBuffer.allocate(plen + inOfs);\n@@ -411,2 +446,2 @@\n-                        b.position(inofs);\n-                        b.put(pt, dataoffset + inofs, plen);\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n@@ -414,1 +449,1 @@\n-                        b.position(inofs);\n+                        b.position(inOfs);\n@@ -417,1 +452,1 @@\n-                        out.position(inofs);\n+                        out.position(outOfs);\n@@ -419,1 +454,1 @@\n-                        ba.write(out.array(), inofs, rlen);\n+                        ba.write(out.array(), outOfs, rlen);\n@@ -422,1 +457,1 @@\n-                        ByteBuffer b = ByteBuffer.allocateDirect(plen + inofs);\n+                        ByteBuffer b = ByteBuffer.allocateDirect(plen + inOfs);\n@@ -424,2 +459,2 @@\n-                        b.position(inofs);\n-                        b.put(pt, dataoffset + inofs, plen);\n+                        b.position(inOfs);\n+                        b.put(pt, dataoffset + inOfs, plen);\n@@ -427,1 +462,1 @@\n-                        b.position(inofs);\n+                        b.position(inOfs);\n@@ -430,1 +465,1 @@\n-                        out.position(inofs);\n+                        out.position(outOfs);\n@@ -434,1 +469,1 @@\n-                        out.position(inofs);\n+                        out.position(outOfs);\n@@ -441,1 +476,1 @@\n-                if (theoreticalCheck && rlen != olen - offset) {\n+                if (theoreticalCheck && rlen != olen - outOfs) {\n@@ -444,1 +479,1 @@\n-                        \", expected output len=\" + (olen - offset));\n+                        \", expected output len=\" + (olen - outOfs));\n@@ -449,3 +484,3 @@\n-                if (ctresult.length != output.length ||\n-                    Arrays.compare(ctresult, output) != 0) {\n-                    throw new Exception(\"Ciphertext mismatch (\" + v.name() +\n+                if (ctresult.length != expectedOut.length ||\n+                    Arrays.compare(ctresult, expectedOut) != 0) {\n+                    String s = \"Ciphertext mismatch (\" + v.name() +\n@@ -457,1 +492,4 @@\n-                        new BigInteger(1, output)));\n+                        new BigInteger(1, output));\n+                    System.err.println(s);\n+                    throw new Exception(s);\n+\n@@ -470,4 +508,9 @@\n-    void cryptoSameBuffer(boolean encrypt, Data d, int offset,\n-        byte[] input, byte[] output) throws Exception {\n-        byte[] data =\n-            new byte[(encrypt ? output.length : input.length) + offset], out;\n+    void cryptoSameBuffer(boolean encrypt, Data d, byte[] input, byte[] output) throws Exception {\n+\n+        byte[] data, out;\n+        if (encrypt) {\n+            data = new byte[output.length + Math.max(inOfs, outOfs)];\n+        } else {\n+            data = new byte[input.length + Math.max(inOfs, outOfs)];\n+        }\n+\n@@ -475,1 +518,3 @@\n-        System.arraycopy(input, 0, data, offset, input.length);\n+        System.arraycopy(input, 0, data, inOfs, input.length);\n+        byte[] expectedOut = new byte[output.length + outOfs];\n+        System.arraycopy(output, 0, expectedOut, outOfs, output.length);\n@@ -492,1 +537,1 @@\n-                bbin.position(offset);\n+                bbin.limit(input.length + inOfs);\n@@ -497,1 +542,0 @@\n-                bbin.position(offset);\n@@ -499,1 +543,1 @@\n-                bbin.put(data, offset, input.length);\n+                bbin.put(data, 0, input.length + inOfs);\n@@ -501,1 +545,0 @@\n-                bbin.position(offset);\n@@ -507,6 +550,3 @@\n-            if (encrypt) {\n-                bbin.limit(input.length + offset);\n-            } else {\n-                bbout.limit(output.length + offset);\n-            }\n-            bbout.position(offset);\n+            bbin.position(inOfs);\n+            bbout.limit(output.length + outOfs);\n+            bbout.position(outOfs);\n@@ -520,2 +560,2 @@\n-                        rlen = cipher.update(data, dataoffset + offset, plen,\n-                            data, len + offset);\n+                        rlen = cipher.update(data, dataoffset + inOfs, plen,\n+                            data, len + outOfs);\n@@ -548,4 +588,3 @@\n-                        rlen = cipher.doFinal(data, dataoffset + offset,\n-                            plen, data, len + offset);\n-                        out = Arrays.copyOfRange(data, offset,\n-                            len + rlen + offset);\n+                        rlen = cipher.doFinal(data, dataoffset + inOfs,\n+                            plen, data, len + outOfs);\n+                        out = Arrays.copyOfRange(data, 0,len + rlen + outOfs);\n@@ -556,2 +595,1 @@\n-                        out = new byte[bbout.remaining() - offset];\n-                        bbout.position(offset);\n+                        out = new byte[bbout.remaining()];\n@@ -566,1 +604,1 @@\n-                    Arrays.compare(out, 0, len, output, 0,\n+                    Arrays.compare(out, 0, len, expectedOut, 0,\n@@ -568,2 +606,2 @@\n-                    throw new Exception(\"Ciphertext mismatch (\" + v.name() +\n-                        \"):\\nresult   (len=\" + len + \"):\" +\n+                    String s = \"Ciphertext mismatch (\" + v.name() +\n+                        \"):\\nresult (len=\" + len + \"):\\n\" +\n@@ -571,1 +609,1 @@\n-                        \"\\nexpected (len=\" + output.length + \"):\" +\n+                        \"\\nexpected (len=\" + output.length + \"):\\n\" +\n@@ -573,1 +611,3 @@\n-                            new BigInteger(1, output)));\n+                            new BigInteger(1, output));\n+                    System.err.println(s);\n+                    throw new Exception(s);\n@@ -578,0 +618,6 @@\n+    static void offsetTests(GCMBufferTest t) throws Exception {\n+        t.clone().offset(2).test();\n+        t.clone().inOfs(2).test();\n+        \/\/ Test not designed for overlap situations\n+        t.clone().outOfs(2).differentBufferOnly().test();\n+    }\n@@ -579,2 +625,1 @@\n-    public static void main (String args[]) throws Exception {\n-\n+    public static void main(String args[]) throws Exception {\n@@ -582,1 +627,0 @@\n-\n@@ -585,0 +629,1 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE)));\n@@ -586,2 +631,2 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.BYTE)).test();\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)).test();\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE)));\n@@ -591,0 +636,1 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.BYTE, dtype.BYTE, dtype.BYTE)));\n@@ -594,0 +640,1 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP)));\n@@ -597,0 +644,1 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP)));\n@@ -600,0 +648,1 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.HEAP, dtype.HEAP, dtype.HEAP)));\n@@ -603,0 +652,1 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\", List.of(dtype.DIRECT)));\n@@ -606,0 +656,2 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT)));\n@@ -609,0 +661,2 @@\n+        offsetTests(new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)));\n@@ -611,1 +665,1 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+        GCMBufferTest t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n@@ -613,1 +667,3 @@\n-            new int[] { 1, 1, GCMBufferTest.REMAINDER}).test();\n+            new int[] { 1, 1, GCMBufferTest.REMAINDER});\n+        t.clone().test();\n+        offsetTests(t.clone());\n@@ -616,2 +672,4 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly().test();\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n@@ -619,3 +677,4 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly()\n-            .test();\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.BYTE, dtype.HEAP, dtype.DIRECT)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n@@ -623,2 +682,4 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n-            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly().test();\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.BYTE)).differentBufferOnly();\n+        t.clone().test();\n+        offsetTests(t.clone());\n@@ -628,1 +689,1 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n@@ -630,1 +691,3 @@\n-            dataSegments(new int[] { 20, GCMBufferTest.REMAINDER }).test();\n+            dataSegments(new int[] { 20, GCMBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n@@ -633,1 +696,1 @@\n-        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n@@ -636,2 +699,3 @@\n-            dataSegments(new int[] { 5000, 1000, GCMBufferTest.REMAINDER }).\n-            test();\n+            dataSegments(new int[] { 5000, 1000, GCMBufferTest.REMAINDER });\n+        t.clone().test();\n+        offsetTests(t.clone());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":178,"deletions":114,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+\n+\/*\n+ * @test\n+ * @summary This tests overlapping buffers using ByteBuffer.slice() with\n+ *  array-backed ByteBuffer, read only array-backed, ByteBuffer, and direct\n+ *  ByteBuffer.\n+ *\/\n+\n+\/*\n+ * This tests overlapping buffers created with ByteBuffer.slice().  That is\n+ * when the input and output ByteBuffers have shared memory (use the same\n+ * underlying buffer space, commonly used for in-place crypto).  The\n+ * complication is the Cipher object specifies that it must be copy-safe.  That\n+ * means the output buffer will not overwrite any input data that has not been\n+ * processed.  If the output buffer's position or offset is greater than the\n+ * input's overwriting will occur.\n+ *\/\n+\n+public class OverlapByteBuffer {\n+\n+    public static void main(String[] args) throws Exception {\n+        byte[] baseBuf = new byte[8192];\n+        ByteBuffer output, input, in;\n+        \/\/ Output offset from the baseBuf\n+        int outOfs;\n+\n+        for (int i = 0; i < 3; i++) {\n+            for (outOfs = -1; outOfs <= 1; outOfs++) {\n+\n+                SecretKeySpec key = new SecretKeySpec(new byte[16], \"AES\");\n+                GCMParameterSpec params =\n+                    new GCMParameterSpec(128, new byte[12]);\n+                Cipher cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                cipher.init(Cipher.ENCRYPT_MODE, key, params);\n+\n+                \/\/ Offset on the particular ByteBuffer (aka position())\n+                int inOfsInBuf = 1;\n+                int outOfsInBuf = inOfsInBuf + outOfs;\n+                int sliceLen = cipher.getOutputSize(baseBuf.length);\n+                int bufferSize = sliceLen + Math.max(inOfsInBuf, outOfsInBuf);\n+                byte[] buffer;\n+                \/\/ Create overlapping input and output buffers\n+                switch (i) {\n+                    case 0 -> {\n+                        buffer = new byte[bufferSize];\n+                        output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n+                            slice();\n+                        input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n+                            slice();\n+                        System.out.println(\"Using array-backed ByteBuffer\");\n+                        in = input.duplicate();\n+                    }\n+                    case 1 -> {\n+                        buffer = new byte[bufferSize];\n+                        output = ByteBuffer.wrap(buffer, outOfsInBuf, sliceLen).\n+                            slice();\n+                        input = ByteBuffer.wrap(buffer, inOfsInBuf, sliceLen).\n+                            slice();\n+\n+                        System.out.println(\"Using read-only array-backed \" + \"ByteBuffer\");\n+                        in = input.asReadOnlyBuffer();\n+                    }\n+                    case 2 -> {\n+                        System.out.println(\"Using direct ByteBuffer\");\n+                        ByteBuffer buf = ByteBuffer.allocateDirect(bufferSize);\n+                        output = buf.duplicate();\n+                        output.position(outOfsInBuf);\n+                        output.limit(sliceLen + outOfsInBuf);\n+                        output = output.slice();\n+\n+                        input = buf.duplicate();\n+                        input.position(inOfsInBuf);\n+                        input.limit(sliceLen + inOfsInBuf);\n+                        input = input.slice();\n+\n+                        in = input.duplicate();\n+                    }\n+                    default -> {\n+                        throw new Exception(\"Unknown index \" + i);\n+                    }\n+                }\n+\n+                \/\/ Copy data into shared buffer\n+                input.put(baseBuf);\n+                input.flip();\n+                in.limit(input.limit());\n+\n+                try {\n+                    int ctSize = cipher.doFinal(in, output);\n+\n+                    \/\/ Get ready to decrypt\n+                    byte[] tmp = new byte[ctSize];\n+                    output.flip();\n+                    output.get(tmp);\n+                    output.clear();\n+\n+                    input.clear();\n+                    input.put(tmp);\n+                    input.flip();\n+\n+                    in.clear();\n+                    in.limit(input.limit());\n+\n+                    cipher.init(Cipher.DECRYPT_MODE, key, params);\n+                    cipher.doFinal(in, output);\n+\n+                    output.flip();\n+                    System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n+                    System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n+                    ByteBuffer b = ByteBuffer.wrap(baseBuf);\n+                    if (b.compareTo(output) != 0) {\n+                        System.err.println(\n+                            \"\\nresult   (\" + output + \"):\\n\" +\n+                            byteToHex(output) +\n+                            \"\\nexpected (\" + b + \"):\\n\" +\n+                            byteToHex(b));\n+                        throw new Exception(\"Mismatch\");\n+                    }\n+                } catch (Exception e) {\n+                    throw new Exception(\"Error with base offset \" + outOfs, e);\n+                }\n+            }\n+        }\n+    }\n+        private static String byteToHex(ByteBuffer bb) {\n+        StringBuilder s = new StringBuilder();\n+        while (bb.remaining() > 0) {\n+            s.append(String.format(\"%02x\", bb.get()));\n+        }\n+        return s.toString();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/OverlapByteBuffer.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import java.security.AlgorithmParameters;\n+import java.util.Arrays;\n+\n+\n+\/*\n+ * @test\n+ * @summary Verify when decrypting over an existing buffer than padding does not\n+ * overwrite past what the plaintext length is.\n+ *\n+ *\/\n+\n+public class SameBufferOverwrite {\n+\n+    private SecretKey skey;\n+    private Cipher c;\n+    private int start = 17, end = 17;  \/\/ default\n+\n+    SameBufferOverwrite(String algo, String transformation)\n+        throws Exception {\n+\n+        KeyGenerator kg = KeyGenerator.getInstance(algo, \"SunJCE\");\n+        skey = kg.generateKey();\n+        c = Cipher.getInstance(transformation, \"SunJCE\");\n+    }\n+\n+    \/*\n+     * Run the test\n+     *\/\n+    void test() throws Exception {\n+        byte[] in = new byte[end + (c.getBlockSize() - (end % c.getBlockSize()))];\n+        Arrays.fill(in, (byte)8);\n+        int len = start;\n+        AlgorithmParameters params = null;\n+\n+        System.out.println(\"Testing transformation: \" + c.getAlgorithm() +\n+            \",  byte length from \" + start + \" to \" + end);\n+        while (end >= len) {\n+            \/\/ encrypt\n+            c.init(Cipher.ENCRYPT_MODE, skey, params);\n+            byte[] out = c.doFinal(in, 0, len);\n+            System.out.println(\"  enc = \" + byteToHex(out));\n+            System.out.println(\"  => enc \" + len + \" bytes, ret \" +\n+                (out == null ? \"null\" : (out.length + \" byte\")));\n+\n+            \/\/ decrypt\n+            params = c.getParameters();\n+            c.init(Cipher.DECRYPT_MODE, skey, params);\n+            int rLen = c.doFinal(out, 0, out.length, in);\n+            System.out.println(\"  dec = \" + byteToHex(in));\n+            System.out.println(\"  => dec \" + out.length + \" bytes, ret \" +\n+                rLen + \" byte\");\n+            \/\/ check if more than rLen bytes are written into 'in'\n+            for (int j = rLen; j < in.length; j++) {\n+                if (in[j] != (byte) 8) {\n+                    throw new Exception(\"Value check failed at index \" + j);\n+                }\n+            }\n+            System.out.println(\" Test Passed:  len = \" + len);\n+            len++;\n+\n+            \/\/ Because GCM doesn't allow params reuse\n+            if (c.getAlgorithm().contains(\"GCM\")) {\n+                params = null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Builder method for the test to run data lengths from the start value to\n+     * the end value.  To do one length, have start and end equal that number.\n+     * @param start starting data length\n+     * @param end ending data length\n+     *\/\n+    SameBufferOverwrite iterate(int start, int end) {\n+        this.start = start;\n+        this.end = end;\n+        return this;\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        new SameBufferOverwrite(\"AES\", \"AES\/GCM\/NoPadding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"AES\", \"AES\/CTR\/NoPadding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"AES\", \"AES\/CBC\/PKCS5Padding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"AES\", \"AES\/ECB\/PKCS5Padding\").iterate(1, 25).\n+            test();\n+        new SameBufferOverwrite(\"DES\", \"DES\/CBC\/PKCS5Padding\").iterate(1, 17).\n+            test();\n+        new SameBufferOverwrite(\"DESede\", \"DESede\/CBC\/PKCS5Padding\").iterate(1, 17).\n+            test();\n+    }\n+\n+    private static String byteToHex(byte[] barray) {\n+        StringBuilder s = new StringBuilder();\n+        for (byte b : barray) {\n+            s.append(String.format(\"%02x\", b));\n+        }\n+        return s.toString();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/TextLength\/SameBufferOverwrite.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,8 @@\n- * @run main CipherByteBufferOverwriteTest 0 false\n- * @run main CipherByteBufferOverwriteTest 0 true\n- * @run main CipherByteBufferOverwriteTest 4 false\n- * @run main CipherByteBufferOverwriteTest 4 true\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 0 false\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 0 true\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 4 false\n+ * @run main CipherByteBufferOverwriteTest AES\/CBC\/PKCS5Padding 4 true\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 0 false\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 0 true\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 4 false\n+ * @run main CipherByteBufferOverwriteTest AES\/GCM\/NoPadding 4 true\n@@ -35,0 +39,1 @@\n+import java.math.BigInteger;\n@@ -38,0 +43,1 @@\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -47,1 +53,1 @@\n-    private static final String TRANSFORMATION = \"AES\/CBC\/PKCS5Padding\";\n+    private static String transformation;\n@@ -56,2 +62,1 @@\n-    private static final AlgorithmParameterSpec PARAMS =\n-            new IvParameterSpec(new byte[16]);\n+    private static AlgorithmParameterSpec params;\n@@ -68,2 +73,3 @@\n-        int offset = Integer.parseInt(args[0]);\n-        boolean useRO = Boolean.parseBoolean(args[1]);\n+        transformation = args[0];\n+        int offset = Integer.parseInt(args[1]);\n+        boolean useRO = Boolean.parseBoolean(args[2]);\n@@ -71,0 +77,5 @@\n+        if (transformation.equalsIgnoreCase(\"AES\/GCM\/NoPadding\")) {\n+            params = new GCMParameterSpec(16 * 8, new byte[16]);\n+        } else {\n+            params = new IvParameterSpec(new byte[16]);\n+        }\n@@ -78,2 +89,2 @@\n-        Cipher c = Cipher.getInstance(TRANSFORMATION);\n-        c.init(Cipher.ENCRYPT_MODE, KEY, PARAMS);\n+        Cipher c = Cipher.getInstance(transformation);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, params);\n@@ -153,2 +164,2 @@\n-        Cipher c = Cipher.getInstance(TRANSFORMATION);\n-        c.init(Cipher.ENCRYPT_MODE, KEY, PARAMS);\n+        Cipher c = Cipher.getInstance(transformation);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, params);\n@@ -169,0 +180,7 @@\n+            System.err.println(\"Ciphertext mismatch:\" +\n+                \"\\nresult   (len=\" + finalCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (finalCT.length << 1) + \"x\",\n+                    new BigInteger(1, finalCT)) +\n+                \"\\nexpected (len=\" + expectedCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (expectedCT.length << 1) + \"x\",\n+                    new BigInteger(1, expectedCT)));\n@@ -175,1 +193,1 @@\n-        c.init(Cipher.DECRYPT_MODE, KEY, PARAMS);\n+        c.init(Cipher.DECRYPT_MODE, KEY, params);\n@@ -186,0 +204,7 @@\n+            System.err.println(\"Ciphertext mismatch \" +\n+                \"):\\nresult   (len=\" + finalCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (finalCT.length << 1) + \"x\",\n+                    new BigInteger(1, finalCT)) +\n+                \"\\nexpected (len=\" + expectedCT.length + \"):\\n\" +\n+                String.format(\"%0\" + (expectedCT.length << 1) + \"x\",\n+                    new BigInteger(1, expectedCT)));\n","filename":"test\/jdk\/javax\/crypto\/CipherSpi\/CipherByteBufferOverwriteTest.java","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"}]}