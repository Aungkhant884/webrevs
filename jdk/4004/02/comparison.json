{"files":[{"patch":"@@ -1491,1 +1491,0 @@\n-            if (isStatic(env1)) staticOnly = true;\n@@ -1495,0 +1494,3 @@\n+                    if (staticOnly) {\n+                        return new StaticError(sym);\n+                    }\n@@ -1498,0 +1500,1 @@\n+            if (isStatic(env1)) staticOnly = true;\n@@ -1503,12 +1506,3 @@\n-                   (sym.flags() & STATIC) == 0 &&\n-                    sym.kind == VAR &&\n-                        \/\/ if it is a field\n-                        (sym.owner.kind == TYP ||\n-                        \/\/ or it is a local variable but it is not declared inside of the static local type\n-                        \/\/ then error\n-                        allowRecords &&\n-                        (sym.owner.kind == MTH) &&\n-                        env1 != env &&\n-                        !isInnerClassOfMethod(sym.owner, env.tree.hasTag(CLASSDEF) ?\n-                                ((JCClassDecl)env.tree).sym :\n-                                env.enclClass.sym)))\n+                        sym.kind == VAR &&\n+                        sym.owner.kind == TYP &&\n+                        (sym.flags() & STATIC) == 0)\n@@ -2316,2 +2310,2 @@\n-    Symbol findTypeVar(Env<AttrContext> currentEnv, Env<AttrContext> originalEnv, Name name, boolean staticOnly) {\n-        for (Symbol sym : currentEnv.info.scope.getSymbolsByName(name)) {\n+    Symbol findTypeVar(Env<AttrContext> env, Name name, boolean staticOnly) {\n+        for (Symbol sym : env.info.scope.getSymbolsByName(name)) {\n@@ -2319,10 +2313,6 @@\n-                if (staticOnly &&\n-                    sym.type.hasTag(TYPEVAR) &&\n-                    ((sym.owner.kind == TYP) ||\n-                    \/\/ are we trying to access a TypeVar defined in a method from a local static type: interface, enum or record?\n-                    allowRecords &&\n-                    (sym.owner.kind == MTH &&\n-                    currentEnv != originalEnv &&\n-                    !isInnerClassOfMethod(sym.owner, originalEnv.tree.hasTag(CLASSDEF) ?\n-                            ((JCClassDecl)originalEnv.tree).sym :\n-                            originalEnv.enclClass.sym)))) {\n+                if (sym.type.hasTag(TYPEVAR) &&\n+                        (staticOnly || (isStatic(env) && sym.owner.kind == TYP)))\n+                    \/\/ if staticOnly is set, it means that we have recursed through a static declaration,\n+                    \/\/ so type variable symbols should not be accessible. If staticOnly is unset, but\n+                    \/\/ we are in a static declaration (field or method), we should not allow type-variables\n+                    \/\/ defined in the enclosing class to \"leak\" into this context.\n@@ -2330,1 +2320,0 @@\n-                }\n@@ -2337,8 +2326,0 @@\n-    boolean isInnerClassOfMethod(Symbol msym, Symbol csym) {\n-        while (csym.owner != msym) {\n-            if (csym.isStatic()) return false;\n-            csym = csym.owner.enclClass();\n-        }\n-        return (csym.owner == msym && !csym.isStatic());\n-    }\n-\n@@ -2356,1 +2337,0 @@\n-            if (isStatic(env1)) staticOnly = true;\n@@ -2358,1 +2338,2 @@\n-            final Symbol tyvar = findTypeVar(env1, env, name, staticOnly);\n+            final Symbol tyvar = findTypeVar(env1, name, staticOnly);\n+            if (isStatic(env1)) staticOnly = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":17,"deletions":36,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -749,0 +749,5 @@\n+                record R() {\n+                    void test(U u) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n@@ -755,0 +760,7 @@\n+                \"\"\"\n+                record R() {\n+                    void test1() {\n+                        class X { void test2(U u) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -804,0 +816,5 @@\n+                interface I {\n+                    default void test(U u) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n@@ -810,0 +827,7 @@\n+                \"\"\"\n+                interface I {\n+                    default void test1() {\n+                        class X { void test2(U u) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -866,0 +890,6 @@\n+                enum E {\n+                    A;\n+                    void test(U u) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n@@ -873,0 +903,8 @@\n+                \"\"\"\n+                enum E {\n+                    A;\n+                    void test1() {\n+                        class X { void test2(U u) {} }\n+                    }\n+                }\n+                \"\"\",\n@@ -922,0 +960,5 @@\n+                static class SC {\n+                    void test(U u) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n@@ -927,0 +970,7 @@\n+                \"\"\",\n+                \"\"\"\n+                static class SC {\n+                    void test1() {\n+                        class X { void test2(U u) {} }\n+                    }\n+                }\n@@ -968,0 +1018,24 @@\n+\n+        \/\/ but still non-static declarations can't be accessed from a static method inside a local class\n+        for (String s : List.of(\n+                \"System.out.println(localVar)\",\n+                \"System.out.println(param)\",\n+                \"System.out.println(field)\",\n+                \"T t\",\n+                \"U u\"\n+        )) {\n+            assertFail(\"compiler.err.non-static.cant.be.ref\",\n+                    \"\"\"\n+                    class C<T> {\n+                        int field = 0;\n+                        <U> void foo(int param) {\n+                            int localVar = 1;\n+                            class Local {\n+                                static void m() {\n+                                    #S;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    \"\"\".replaceFirst(\"#S\", s));\n+        }\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"}]}