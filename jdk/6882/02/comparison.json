{"files":[{"patch":"@@ -1370,1 +1370,1 @@\n-  dominated_by( new_predicate_proj, iff, proj->_con != new_predicate_proj->_con );\n+  dominated_by( new_predicate_proj->as_IfProj(), iff, proj->_con != new_predicate_proj->_con );\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-            dominated_by(old_new[prev->_idx], n);\n+            dominated_by(old_new[prev->_idx]->as_IfProj(), n->as_If());\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  dominated_by(proj_true, unswitch_iff, false, false);\n+  dominated_by(proj_true->as_IfProj(), unswitch_iff, false, false);\n@@ -220,1 +220,1 @@\n-  dominated_by(proj_false, unswitch_iff_clone, false, false);\n+  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone, false, false);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1467,1 +1467,1 @@\n-  void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool exclude_loop_predicate = false);\n@@ -1470,1 +1470,1 @@\n-  Node *split_thru_region( Node *n, Node *region );\n+  RegionNode* split_thru_region(Node* n, Node* region);\n@@ -1475,1 +1475,1 @@\n-  void do_split_if( Node *iff );\n+  void do_split_if(Node *iff, RegionNode** new_false_region = NULL, RegionNode** new_true_region = NULL);\n@@ -1650,0 +1650,3 @@\n+  void push_pinned_nodes_thru_region(IfNode* dom_if, Node* region);\n+\n+  bool try_merge_identical_ifs(Node* n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-void PhaseIdealLoop::dominated_by( Node *prevdom, Node *iff, bool flip, bool exclude_loop_predicate ) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool exclude_loop_predicate) {\n@@ -236,1 +236,0 @@\n-  assert(iff->is_If(), \"must be\");\n@@ -266,1 +265,1 @@\n-  Node* dp = iff->as_If()->proj_out_or_null(pop == Op_IfTrue);\n+  Node* dp = iff->proj_out_or_null(pop == Op_IfTrue);\n@@ -275,1 +274,1 @@\n-  ProjNode* unc_proj = iff->as_If()->proj_out(1 - dp_proj->_con)->as_Proj();\n+  ProjNode* unc_proj = iff->proj_out(1 - dp_proj->_con)->as_Proj();\n@@ -1178,9 +1177,0 @@\n-  IfNode* n_if = n->as_If();\n-  if (n_if->proj_out(0)->outcnt() > 1 || n_if->proj_out(1)->outcnt() > 1) {\n-    \/\/ Removing the dominated If node by using the split-if optimization does not work if there are data dependencies.\n-    \/\/ Some data dependencies depend on its immediate dominator If node and should not be separated from it (e.g. null\n-    \/\/ checks, division by zero checks etc.). Bail out for now until data dependencies are correctly handled when\n-    \/\/ optimizing back-to-back ifs.\n-    return false;\n-  }\n-\n@@ -1362,22 +1352,1 @@\n-  if (identical_backtoback_ifs(n) && can_split_if(n->in(0))) {\n-    Node *n_ctrl = n->in(0);\n-    PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n->in(1));\n-    IfNode* dom_if = idom(n_ctrl)->as_If();\n-    Node* proj_true = dom_if->proj_out(1);\n-    Node* proj_false = dom_if->proj_out(0);\n-    Node* con_true = _igvn.makecon(TypeInt::ONE);\n-    Node* con_false = _igvn.makecon(TypeInt::ZERO);\n-\n-    for (uint i = 1; i < n_ctrl->req(); i++) {\n-      if (is_dominator(proj_true, n_ctrl->in(i))) {\n-        bolphi->init_req(i, con_true);\n-      } else {\n-        assert(is_dominator(proj_false, n_ctrl->in(i)), \"bad if\");\n-        bolphi->init_req(i, con_false);\n-      }\n-    }\n-    register_new_node(bolphi, n_ctrl);\n-    _igvn.replace_input_of(n, 1, bolphi);\n-\n-    \/\/ Now split the IF\n-    do_split_if(n);\n+  if (try_merge_identical_ifs(n)) {\n@@ -1419,1 +1388,1 @@\n-          dominated_by(prevdom, n, false, true);\n+          dominated_by(prevdom->as_IfProj(), n->as_If(), false, true);\n@@ -1444,0 +1413,112 @@\n+\/\/ Tranform:\n+\/\/\n+\/\/ if (some_condition) {\n+\/\/   \/\/ body 1\n+\/\/ } else {\n+\/\/   \/\/ body 2\n+\/\/ }\n+\/\/ if (some_condition) {\n+\/\/   \/\/ body 3\n+\/\/ } else {\n+\/\/   \/\/ body 4\n+\/\/ }\n+\/\/\n+\/\/ into:\n+\/\/\n+\/\/\n+\/\/ if (some_condition) {\n+\/\/   \/\/ body 1\n+\/\/   \/\/ body 3\n+\/\/ } else {\n+\/\/   \/\/ body 2\n+\/\/   \/\/ body 4\n+\/\/ }\n+bool PhaseIdealLoop::try_merge_identical_ifs(Node* n) {\n+  if (identical_backtoback_ifs(n) && can_split_if(n->in(0))) {\n+    Node *n_ctrl = n->in(0);\n+    IfNode* dom_if = idom(n_ctrl)->as_If();\n+    ProjNode* dom_proj_true = dom_if->proj_out(1);\n+    ProjNode* dom_proj_false = dom_if->proj_out(0);\n+\n+    \/\/ Now split the IF\n+    RegionNode* new_false_region;\n+    RegionNode* new_true_region;\n+    do_split_if(n, &new_false_region, &new_true_region);\n+    assert(new_false_region->req() == new_true_region->req(), \"\");\n+#ifdef ASSERT\n+    for (uint i = 1; i < new_false_region->req(); ++i) {\n+      assert(new_false_region->in(i)->in(0) == new_true_region->in(i)->in(0), \"unexpected shape following split if\");\n+      assert(i == new_false_region->req() - 1 || new_false_region->in(i)->in(0)->in(1) == new_false_region->in(i + 1)->in(0)->in(1), \"unexpected shape following split if\");\n+    }\n+#endif\n+    assert(new_false_region->in(1)->in(0)->in(1) == dom_if->in(1), \"dominating if and dominated if after split must share test\");\n+\n+    \/\/ We now have:\n+    \/\/ if (some_condition) {\n+    \/\/   \/\/ body 1\n+    \/\/   if (some_condition) {\n+    \/\/     body3: \/\/ new_true_region\n+    \/\/     \/\/ body3\n+    \/\/   } else {\n+    \/\/     goto body4;\n+    \/\/   }\n+    \/\/ } else {\n+    \/\/   \/\/ body 2\n+    \/\/  if (some_condition) {\n+    \/\/     goto body3;\n+    \/\/   } else {\n+    \/\/     body4:   \/\/ new_false_region\n+    \/\/     \/\/ body4;\n+    \/\/   }\n+    \/\/ }\n+    \/\/\n+\n+    \/\/ clone pinned nodes thru the resulting regions\n+    push_pinned_nodes_thru_region(dom_if, new_true_region);\n+    push_pinned_nodes_thru_region(dom_if, new_false_region);\n+\n+    \/\/ Optimize out the cloned ifs. Because pinned nodes were cloned, this also allows a CastPP that would be dependent\n+    \/\/ on a projection of n to have the dom_if as a control dependency. We don't want the CastPP to end up with an\n+    \/\/ unrelated control dependency.\n+    for (uint i = 1; i < new_false_region->req(); i++) {\n+      if (is_dominator(dom_proj_true, new_false_region->in(i))) {\n+        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+      } else {\n+        assert(is_dominator(dom_proj_false, new_false_region->in(i)), \"bad if\");\n+        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+      }\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void PhaseIdealLoop::push_pinned_nodes_thru_region(IfNode* dom_if, Node* region) {\n+  for (DUIterator i = region->outs(); region->has_out(i); i++) {\n+    Node* u = region->out(i);\n+    if (!has_ctrl(u) || u->is_Phi() || !u->depends_only_on_test() || !_igvn.no_dependent_zero_check(u)) {\n+      continue;\n+    }\n+    assert(u->in(0) == region, \"not a control dependent node?\");\n+    uint j = 1;\n+    for (; j < u->req(); ++j) {\n+      Node* in = u->in(j);\n+      if (!is_dominator(ctrl_or_self(in), dom_if)) {\n+        break;\n+      }\n+    }\n+    if (j == u->req()) {\n+      Node *phi = PhiNode::make_blank(region, u);\n+      for (uint k = 1; k < region->req(); ++k) {\n+        Node* clone = u->clone();\n+        clone->set_req(0, region->in(k));\n+        register_new_node(clone, region->in(k));\n+        phi->init_req(k, clone);\n+      }\n+      register_new_node(phi, region);\n+      _igvn.replace_node(u, phi);\n+      --i;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":117,"deletions":36,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -34,14 +34,14 @@\n-Node *PhaseIdealLoop::split_thru_region( Node *n, Node *region ) {\n-  uint wins = 0;\n-  assert( n->is_CFG(), \"\" );\n-  assert( region->is_Region(), \"\" );\n-  Node *r = new RegionNode( region->req() );\n-  IdealLoopTree *loop = get_loop( n );\n-  for( uint i = 1; i < region->req(); i++ ) {\n-    Node *x = n->clone();\n-    Node *in0 = n->in(0);\n-    if( in0->in(0) == region ) x->set_req( 0, in0->in(i) );\n-    for( uint j = 1; j < n->req(); j++ ) {\n-      Node *in = n->in(j);\n-      if( get_ctrl(in) == region )\n-        x->set_req( j, in->in(i) );\n+RegionNode* PhaseIdealLoop::split_thru_region(Node* n, Node* region) {\n+  assert(n->is_CFG(), \"\");\n+  assert(region->is_Region(), \"\");\n+  RegionNode* r = new RegionNode(region->req());\n+  IdealLoopTree* loop = get_loop(n);\n+  for (uint i = 1; i < region->req(); i++) {\n+    Node* x = n->clone();\n+    Node* in0 = n->in(0);\n+    if (in0->in(0) == region) x->set_req(0, in0->in(i));\n+    for (uint j = 1; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (get_ctrl(in) == region) {\n+        x->set_req(j, in->in(i));\n+      }\n@@ -59,1 +59,1 @@\n-  if( !loop->_child )\n+  if (!loop->_child) {\n@@ -61,0 +61,1 @@\n+  }\n@@ -436,1 +437,1 @@\n-void PhaseIdealLoop::do_split_if( Node *iff ) {\n+void PhaseIdealLoop::do_split_if(Node* iff, RegionNode** new_false_region, RegionNode** new_true_region) {\n@@ -499,1 +500,2 @@\n-  Node *new_false = NULL, *new_true = NULL;\n+  RegionNode* new_false = NULL;\n+  RegionNode* new_true = NULL;\n@@ -504,1 +506,1 @@\n-    Node *ifpx = split_thru_region( ifp, region );\n+    RegionNode* ifpx = split_thru_region(ifp, region);\n@@ -580,0 +582,7 @@\n+  if (new_false_region != NULL) {\n+    *new_false_region = new_false;\n+  }\n+  if (new_true_region != NULL) {\n+    *new_true_region = new_true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8278228\n+ * @summary C2: Improve identical back-to-back if elimination\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestBackToBackIfs\n+ *\/\n+\n+public class TestBackToBackIfs {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static private int int_field;\n+\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test(int a, int b) {\n+        if (a == b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (a == b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void test_runner() {\n+        test(42, 0x42);\n+        test(0x42, 0x42);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackIfs.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -116,0 +116,1 @@\n+    public static final String IF = START + \"If\\\\b\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}