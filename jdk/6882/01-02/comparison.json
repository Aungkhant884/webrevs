{"files":[{"patch":"@@ -1467,1 +1467,1 @@\n-  void dominated_by(IfProjNode *prevdom, IfNode *iff, bool flip = false, bool exclude_loop_predicate = false);\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool exclude_loop_predicate = false);\n@@ -1470,1 +1470,1 @@\n-  Node *split_thru_region( Node *n, Node *region );\n+  RegionNode* split_thru_region(Node* n, Node* region);\n@@ -1475,1 +1475,1 @@\n-  void do_split_if(Node *iff, Node** new_false_region = NULL, Node** new_true_region = NULL);\n+  void do_split_if(Node *iff, RegionNode** new_false_region = NULL, RegionNode** new_true_region = NULL);\n@@ -1651,0 +1651,2 @@\n+\n+  bool try_merge_identical_ifs(Node* n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-void PhaseIdealLoop::dominated_by(IfProjNode *prevdom, IfNode *iff, bool flip, bool exclude_loop_predicate) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool exclude_loop_predicate) {\n@@ -1352,35 +1352,1 @@\n-  if (identical_backtoback_ifs(n) && can_split_if(n->in(0))) {\n-    Node *n_ctrl = n->in(0);\n-    IfNode* dom_if = idom(n_ctrl)->as_If();\n-    ProjNode* dom_proj_true = dom_if->proj_out(1);\n-    ProjNode* dom_proj_false = dom_if->proj_out(0);\n-\n-    \/\/ Now split the IF\n-    Node* new_false;\n-    Node* new_true;\n-    do_split_if(n, &new_false, &new_true);\n-    assert(new_false->req() == new_true->req(), \"\");\n-#ifdef ASSERT\n-    for (uint i = 1; i < new_false->req(); ++i) {\n-      assert(new_false->in(i)->in(0) == new_true->in(i)->in(0), \"unexpected shape following split if\");\n-      assert(i == new_false->req() - 1 || new_false->in(i)->in(0)->in(1) == new_false->in(i+1)->in(0)->in(1), \"unexpected shape following split if\");\n-    }\n-#endif\n-    assert(new_false->in(1)->in(0)->in(1) == dom_if->in(1), \"\");\n-\n-    \/\/ clone pinned nodes thru the resulting regions\n-    push_pinned_nodes_thru_region(dom_if, new_true);\n-    push_pinned_nodes_thru_region(dom_if, new_false);\n-\n-    \/\/ Optimize out the cloned ifs. Because pinned nodes were cloned, this also allows a CastPP that would be dependent\n-    \/\/ on a projection of n to have the dom_if as a control dependency. We don't want the CastPP to end up with an\n-    \/\/ unrelated control dependency.\n-    for (uint i = 1; i < new_false->req(); i++) {\n-      if (is_dominator(dom_proj_true, new_false->in(i))) {\n-        dominated_by(dom_proj_true->as_IfProj(), new_false->in(i)->in(0)->as_If(), false, false);\n-      } else {\n-        assert(is_dominator(dom_proj_false, new_false->in(i)), \"bad if\");\n-        dominated_by(dom_proj_false->as_IfProj(), new_false->in(i)->in(0)->as_If(), false, false);\n-      }\n-    }\n-\n+  if (try_merge_identical_ifs(n)) {\n@@ -1447,0 +1413,83 @@\n+\/\/ Tranform:\n+\/\/\n+\/\/ if (some_condition) {\n+\/\/   \/\/ body 1\n+\/\/ } else {\n+\/\/   \/\/ body 2\n+\/\/ }\n+\/\/ if (some_condition) {\n+\/\/   \/\/ body 3\n+\/\/ } else {\n+\/\/   \/\/ body 4\n+\/\/ }\n+\/\/\n+\/\/ into:\n+\/\/\n+\/\/\n+\/\/ if (some_condition) {\n+\/\/   \/\/ body 1\n+\/\/   \/\/ body 3\n+\/\/ } else {\n+\/\/   \/\/ body 2\n+\/\/   \/\/ body 4\n+\/\/ }\n+bool PhaseIdealLoop::try_merge_identical_ifs(Node* n) {\n+  if (identical_backtoback_ifs(n) && can_split_if(n->in(0))) {\n+    Node *n_ctrl = n->in(0);\n+    IfNode* dom_if = idom(n_ctrl)->as_If();\n+    ProjNode* dom_proj_true = dom_if->proj_out(1);\n+    ProjNode* dom_proj_false = dom_if->proj_out(0);\n+\n+    \/\/ Now split the IF\n+    RegionNode* new_false_region;\n+    RegionNode* new_true_region;\n+    do_split_if(n, &new_false_region, &new_true_region);\n+    assert(new_false_region->req() == new_true_region->req(), \"\");\n+#ifdef ASSERT\n+    for (uint i = 1; i < new_false_region->req(); ++i) {\n+      assert(new_false_region->in(i)->in(0) == new_true_region->in(i)->in(0), \"unexpected shape following split if\");\n+      assert(i == new_false_region->req() - 1 || new_false_region->in(i)->in(0)->in(1) == new_false_region->in(i + 1)->in(0)->in(1), \"unexpected shape following split if\");\n+    }\n+#endif\n+    assert(new_false_region->in(1)->in(0)->in(1) == dom_if->in(1), \"dominating if and dominated if after split must share test\");\n+\n+    \/\/ We now have:\n+    \/\/ if (some_condition) {\n+    \/\/   \/\/ body 1\n+    \/\/   if (some_condition) {\n+    \/\/     body3: \/\/ new_true_region\n+    \/\/     \/\/ body3\n+    \/\/   } else {\n+    \/\/     goto body4;\n+    \/\/   }\n+    \/\/ } else {\n+    \/\/   \/\/ body 2\n+    \/\/  if (some_condition) {\n+    \/\/     goto body3;\n+    \/\/   } else {\n+    \/\/     body4:   \/\/ new_false_region\n+    \/\/     \/\/ body4;\n+    \/\/   }\n+    \/\/ }\n+    \/\/\n+\n+    \/\/ clone pinned nodes thru the resulting regions\n+    push_pinned_nodes_thru_region(dom_if, new_true_region);\n+    push_pinned_nodes_thru_region(dom_if, new_false_region);\n+\n+    \/\/ Optimize out the cloned ifs. Because pinned nodes were cloned, this also allows a CastPP that would be dependent\n+    \/\/ on a projection of n to have the dom_if as a control dependency. We don't want the CastPP to end up with an\n+    \/\/ unrelated control dependency.\n+    for (uint i = 1; i < new_false_region->req(); i++) {\n+      if (is_dominator(dom_proj_true, new_false_region->in(i))) {\n+        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+      } else {\n+        assert(is_dominator(dom_proj_false, new_false_region->in(i)), \"bad if\");\n+        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+      }\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":85,"deletions":36,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -34,14 +34,14 @@\n-Node *PhaseIdealLoop::split_thru_region( Node *n, Node *region ) {\n-  uint wins = 0;\n-  assert( n->is_CFG(), \"\" );\n-  assert( region->is_Region(), \"\" );\n-  Node *r = new RegionNode( region->req() );\n-  IdealLoopTree *loop = get_loop( n );\n-  for( uint i = 1; i < region->req(); i++ ) {\n-    Node *x = n->clone();\n-    Node *in0 = n->in(0);\n-    if( in0->in(0) == region ) x->set_req( 0, in0->in(i) );\n-    for( uint j = 1; j < n->req(); j++ ) {\n-      Node *in = n->in(j);\n-      if( get_ctrl(in) == region )\n-        x->set_req( j, in->in(i) );\n+RegionNode* PhaseIdealLoop::split_thru_region(Node* n, Node* region) {\n+  assert(n->is_CFG(), \"\");\n+  assert(region->is_Region(), \"\");\n+  RegionNode* r = new RegionNode(region->req());\n+  IdealLoopTree* loop = get_loop(n);\n+  for (uint i = 1; i < region->req(); i++) {\n+    Node* x = n->clone();\n+    Node* in0 = n->in(0);\n+    if (in0->in(0) == region) x->set_req(0, in0->in(i));\n+    for (uint j = 1; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (get_ctrl(in) == region) {\n+        x->set_req(j, in->in(i));\n+      }\n@@ -59,1 +59,1 @@\n-  if( !loop->_child )\n+  if (!loop->_child) {\n@@ -61,0 +61,1 @@\n+  }\n@@ -436,1 +437,1 @@\n-void PhaseIdealLoop::do_split_if(Node* iff, Node** new_false_region, Node** new_true_region) {\n+void PhaseIdealLoop::do_split_if(Node* iff, RegionNode** new_false_region, RegionNode** new_true_region) {\n@@ -499,1 +500,2 @@\n-  Node *new_false = NULL, *new_true = NULL;\n+  RegionNode* new_false = NULL;\n+  RegionNode* new_true = NULL;\n@@ -504,1 +506,1 @@\n-    Node *ifpx = split_thru_region( ifp, region );\n+    RegionNode* ifpx = split_thru_region(ifp, region);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"}]}