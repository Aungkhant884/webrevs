{"files":[{"patch":"@@ -1370,1 +1370,1 @@\n-  dominated_by( new_predicate_proj, iff, proj->_con != new_predicate_proj->_con );\n+  dominated_by( new_predicate_proj->as_IfProj(), iff, proj->_con != new_predicate_proj->_con );\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-            dominated_by(old_new[prev->_idx], n);\n+            dominated_by(old_new[prev->_idx]->as_IfProj(), n->as_If());\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  dominated_by(proj_true, unswitch_iff, false, false);\n+  dominated_by(proj_true->as_IfProj(), unswitch_iff, false, false);\n@@ -220,1 +220,1 @@\n-  dominated_by(proj_false, unswitch_iff_clone, false, false);\n+  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone, false, false);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1467,1 +1467,1 @@\n-  void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );\n+  void dominated_by(IfProjNode *prevdom, IfNode *iff, bool flip = false, bool exclude_loop_predicate = false);\n@@ -1475,1 +1475,1 @@\n-  void do_split_if( Node *iff );\n+  void do_split_if(Node *iff, Node** new_false_region = NULL, Node** new_true_region = NULL);\n@@ -1650,0 +1650,1 @@\n+  void push_pinned_nodes_thru_region(IfNode* dom_if, Node* region);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-void PhaseIdealLoop::dominated_by( Node *prevdom, Node *iff, bool flip, bool exclude_loop_predicate ) {\n+void PhaseIdealLoop::dominated_by(IfProjNode *prevdom, IfNode *iff, bool flip, bool exclude_loop_predicate) {\n@@ -236,1 +236,0 @@\n-  assert(iff->is_If(), \"must be\");\n@@ -266,1 +265,1 @@\n-  Node* dp = iff->as_If()->proj_out_or_null(pop == Op_IfTrue);\n+  Node* dp = iff->proj_out_or_null(pop == Op_IfTrue);\n@@ -275,1 +274,1 @@\n-  ProjNode* unc_proj = iff->as_If()->proj_out(1 - dp_proj->_con)->as_Proj();\n+  ProjNode* unc_proj = iff->proj_out(1 - dp_proj->_con)->as_Proj();\n@@ -1178,9 +1177,0 @@\n-  IfNode* n_if = n->as_If();\n-  if (n_if->proj_out(0)->outcnt() > 1 || n_if->proj_out(1)->outcnt() > 1) {\n-    \/\/ Removing the dominated If node by using the split-if optimization does not work if there are data dependencies.\n-    \/\/ Some data dependencies depend on its immediate dominator If node and should not be separated from it (e.g. null\n-    \/\/ checks, division by zero checks etc.). Bail out for now until data dependencies are correctly handled when\n-    \/\/ optimizing back-to-back ifs.\n-    return false;\n-  }\n-\n@@ -1364,1 +1354,0 @@\n-    PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n->in(1));\n@@ -1366,8 +1355,26 @@\n-    Node* proj_true = dom_if->proj_out(1);\n-    Node* proj_false = dom_if->proj_out(0);\n-    Node* con_true = _igvn.makecon(TypeInt::ONE);\n-    Node* con_false = _igvn.makecon(TypeInt::ZERO);\n-\n-    for (uint i = 1; i < n_ctrl->req(); i++) {\n-      if (is_dominator(proj_true, n_ctrl->in(i))) {\n-        bolphi->init_req(i, con_true);\n+    ProjNode* dom_proj_true = dom_if->proj_out(1);\n+    ProjNode* dom_proj_false = dom_if->proj_out(0);\n+\n+    \/\/ Now split the IF\n+    Node* new_false;\n+    Node* new_true;\n+    do_split_if(n, &new_false, &new_true);\n+    assert(new_false->req() == new_true->req(), \"\");\n+#ifdef ASSERT\n+    for (uint i = 1; i < new_false->req(); ++i) {\n+      assert(new_false->in(i)->in(0) == new_true->in(i)->in(0), \"unexpected shape following split if\");\n+      assert(i == new_false->req() - 1 || new_false->in(i)->in(0)->in(1) == new_false->in(i+1)->in(0)->in(1), \"unexpected shape following split if\");\n+    }\n+#endif\n+    assert(new_false->in(1)->in(0)->in(1) == dom_if->in(1), \"\");\n+\n+    \/\/ clone pinned nodes thru the resulting regions\n+    push_pinned_nodes_thru_region(dom_if, new_true);\n+    push_pinned_nodes_thru_region(dom_if, new_false);\n+\n+    \/\/ Optimize out the cloned ifs. Because pinned nodes were cloned, this also allows a CastPP that would be dependent\n+    \/\/ on a projection of n to have the dom_if as a control dependency. We don't want the CastPP to end up with an\n+    \/\/ unrelated control dependency.\n+    for (uint i = 1; i < new_false->req(); i++) {\n+      if (is_dominator(dom_proj_true, new_false->in(i))) {\n+        dominated_by(dom_proj_true->as_IfProj(), new_false->in(i)->in(0)->as_If(), false, false);\n@@ -1375,2 +1382,2 @@\n-        assert(is_dominator(proj_false, n_ctrl->in(i)), \"bad if\");\n-        bolphi->init_req(i, con_false);\n+        assert(is_dominator(dom_proj_false, new_false->in(i)), \"bad if\");\n+        dominated_by(dom_proj_false->as_IfProj(), new_false->in(i)->in(0)->as_If(), false, false);\n@@ -1379,2 +1386,0 @@\n-    register_new_node(bolphi, n_ctrl);\n-    _igvn.replace_input_of(n, 1, bolphi);\n@@ -1382,2 +1387,0 @@\n-    \/\/ Now split the IF\n-    do_split_if(n);\n@@ -1419,1 +1422,1 @@\n-          dominated_by(prevdom, n, false, true);\n+          dominated_by(prevdom->as_IfProj(), n->as_If(), false, true);\n@@ -1444,0 +1447,29 @@\n+void PhaseIdealLoop::push_pinned_nodes_thru_region(IfNode* dom_if, Node* region) {\n+  for (DUIterator i = region->outs(); region->has_out(i); i++) {\n+    Node* u = region->out(i);\n+    if (!has_ctrl(u) || u->is_Phi() || !u->depends_only_on_test() || !_igvn.no_dependent_zero_check(u)) {\n+      continue;\n+    }\n+    assert(u->in(0) == region, \"not a control dependent node?\");\n+    uint j = 1;\n+    for (; j < u->req(); ++j) {\n+      Node* in = u->in(j);\n+      if (!is_dominator(ctrl_or_self(in), dom_if)) {\n+        break;\n+      }\n+    }\n+    if (j == u->req()) {\n+      Node *phi = PhiNode::make_blank(region, u);\n+      for (uint k = 1; k < region->req(); ++k) {\n+        Node* clone = u->clone();\n+        clone->set_req(0, region->in(k));\n+        register_new_node(clone, region->in(k));\n+        phi->init_req(k, clone);\n+      }\n+      register_new_node(phi, region);\n+      _igvn.replace_node(u, phi);\n+      --i;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":61,"deletions":29,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-void PhaseIdealLoop::do_split_if( Node *iff ) {\n+void PhaseIdealLoop::do_split_if(Node* iff, Node** new_false_region, Node** new_true_region) {\n@@ -580,0 +580,7 @@\n+  if (new_false_region != NULL) {\n+    *new_false_region = new_false;\n+  }\n+  if (new_true_region != NULL) {\n+    *new_true_region = new_true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8278228\n+ * @summary C2: Improve identical back-to-back if elimination\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestBackToBackIfs\n+ *\/\n+\n+public class TestBackToBackIfs {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static private int int_field;\n+\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test(int a, int b) {\n+        if (a == b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (a == b) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void test_runner() {\n+        test(42, 0x42);\n+        test(0x42, 0x42);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackIfs.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -116,0 +116,1 @@\n+    public static final String IF = START + \"If\\\\b\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}