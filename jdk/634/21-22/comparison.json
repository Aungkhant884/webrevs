{"files":[{"patch":"@@ -31,16 +31,1 @@\n-#define __ _masm->\n-\n-struct VectorRegister {\n-  static const size_t VECTOR_MAX_WIDTH_BITS = 128;\n-  static const size_t VECTOR_MAX_WIDTH_BYTES = VECTOR_MAX_WIDTH_BITS \/ 8;\n-  static const size_t VECTOR_MAX_WIDTH_U64S = VECTOR_MAX_WIDTH_BITS \/ 64;\n-  static const size_t VECTOR_MAX_WIDTH_FLOATS = VECTOR_MAX_WIDTH_BITS \/ 32;\n-  static const size_t VECTOR_MAX_WIDTH_DOUBLES = VECTOR_MAX_WIDTH_BITS \/ 64;\n-\n-  union {\n-    uint8_t bits[VECTOR_MAX_WIDTH_BYTES];\n-    uint64_t u64[VECTOR_MAX_WIDTH_U64S];\n-    float f[VECTOR_MAX_WIDTH_FLOATS];\n-    double d[VECTOR_MAX_WIDTH_DOUBLES];\n-  };\n-};\n+constexpr size_t float_reg_size = 16; \/\/ bytes\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#define __ _masm->\n+\n@@ -76,1 +78,1 @@\n-    ssize_t offs = _layout->arguments_vector + i * sizeof(VectorRegister);\n+    ssize_t offs = _layout->arguments_vector + i * float_reg_size;\n@@ -102,1 +104,1 @@\n-    ssize_t offs = _layout->returns_vector + i * sizeof(VectorRegister);\n+    ssize_t offs = _layout->returns_vector + i * float_reg_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/universalNativeInvoker_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#define __ _masm->\n+\n@@ -66,1 +68,1 @@\n-    ssize_t offset = layout.arguments_vector + i * sizeof(VectorRegister);\n+    ssize_t offset = layout.arguments_vector + i * float_reg_size;\n@@ -87,1 +89,1 @@\n-    ssize_t offs = layout.returns_vector + i * sizeof(VectorRegister);\n+    ssize_t offs = layout.returns_vector + i * float_reg_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-#define X87_TYPE 2\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,16 +30,1 @@\n-#define __ _masm->\n-\n-struct VectorRegister {\n-  static const size_t VECTOR_MAX_WIDTH_BITS = 512; \/\/ AVX-512 (64-byte) vector types\n-  static const size_t VECTOR_MAX_WIDTH_BYTES = VECTOR_MAX_WIDTH_BITS \/ 8;\n-  static const size_t VECTOR_MAX_WIDTH_U64S = VECTOR_MAX_WIDTH_BITS \/ 64;\n-  static const size_t VECTOR_MAX_WIDTH_FLOATS = VECTOR_MAX_WIDTH_BITS \/ 32;\n-  static const size_t VECTOR_MAX_WIDTH_DOUBLES = VECTOR_MAX_WIDTH_BITS \/ 64;\n-\n-  union {\n-    uint8_t bits[VECTOR_MAX_WIDTH_BYTES];\n-    uint64_t u64[VECTOR_MAX_WIDTH_U64S];\n-    float f[VECTOR_MAX_WIDTH_FLOATS];\n-    double d[VECTOR_MAX_WIDTH_DOUBLES];\n-  };\n-};\n+constexpr size_t xmm_reg_size = 16; \/\/ size of XMM reg\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3465,4 +3465,4 @@\n-address SharedRuntime::make_native_invoker(address call_target,\n-                                           int shadow_space_bytes,\n-                                           const GrowableArray<VMReg>& input_registers,\n-                                           const GrowableArray<VMReg>& output_registers) {\n+BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n+                                               int shadow_space_bytes,\n+                                               const GrowableArray<VMReg>& input_registers,\n+                                               const GrowableArray<VMReg>& output_registers) {\n@@ -3478,1 +3478,1 @@\n-  return _invoke_native_blob->code_begin();\n+  return _invoke_native_blob;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#define __ _masm->\n+\n@@ -76,8 +78,2 @@\n-    size_t offs = _layout->arguments_vector + i * sizeof(VectorRegister);\n-    if (UseAVX >= 3) {\n-      __ evmovdqul(reg, Address(ctxt_reg, (int)offs), Assembler::AVX_512bit);\n-    } else if (UseAVX >= 1) {\n-      __ vmovdqu(reg, Address(ctxt_reg, (int)offs));\n-    } else {\n-      __ movdqu(reg, Address(ctxt_reg, (int)offs));\n-    }\n+    size_t offs = _layout->arguments_vector + i * xmm_reg_size;\n+    __ movdqu(reg, Address(ctxt_reg, (int)offs));\n@@ -118,8 +114,2 @@\n-    size_t offs = _layout->returns_vector + i * sizeof(VectorRegister);\n-    if (UseAVX >= 3) {\n-      __ evmovdqul(Address(ctxt_reg, (int)offs), reg, Assembler::AVX_512bit);\n-    } else if (UseAVX >= 1) {\n-      __ vmovdqu(Address(ctxt_reg, (int)offs), reg);\n-    } else {\n-      __ movdqu(Address(ctxt_reg, (int)offs), reg);\n-    }\n+    size_t offs = _layout->returns_vector + i * xmm_reg_size;\n+    __ movdqu(Address(ctxt_reg, (int)offs), reg);\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86.cpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#define __ _masm->\n+\n@@ -44,1 +46,1 @@\n-  int buffer_alignment = sizeof(VectorRegister);\n+  int buffer_alignment = xmm_reg_size;\n@@ -79,8 +81,2 @@\n-    size_t offs = buffer_offset + layout.arguments_vector + i * sizeof(VectorRegister);\n-    if (UseAVX >= 3) {\n-      __ evmovdqul(Address(rsp, (int)offs), reg, Assembler::AVX_512bit);\n-    } else if (UseAVX >= 1) {\n-      __ vmovdqu(Address(rsp, (int)offs), reg);\n-    } else {\n-      __ movdqu(Address(rsp, (int)offs), reg);\n-    }\n+    size_t offs = buffer_offset + layout.arguments_vector + i * xmm_reg_size;\n+    __ movdqu(Address(rsp, (int)offs), reg);\n@@ -124,8 +120,2 @@\n-    size_t offs = buffer_offset + layout.returns_vector + i * sizeof(VectorRegister);\n-    if (UseAVX >= 3) {\n-      __ evmovdqul(reg, Address(rsp, (int)offs), Assembler::AVX_512bit);\n-    } else if (UseAVX >= 1) {\n-      __ vmovdqu(reg, Address(rsp, (int)offs));\n-    } else {\n-      __ movdqu(reg, Address(rsp, (int)offs));\n-    }\n+    size_t offs = buffer_offset + layout.returns_vector + i * xmm_reg_size;\n+    __ movdqu(reg, Address(rsp, (int)offs));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86.cpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -973,2 +973,1 @@\n-                            address* native_stubs,\n-                            int num_stubs) {\n+                            const GrowableArrayView<BufferBlob*>& native_invokers) {\n@@ -1064,1 +1063,1 @@\n-                               native_stubs, num_stubs);\n+                               native_invokers);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -384,2 +384,1 @@\n-                       address*                  native_stubs = NULL,\n-                       int                       num_stubs = 0);\n+                       const GrowableArrayView<BufferBlob*>& native_invokers = GrowableArrayView<BufferBlob*>::EMPTY);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-    ptr->free_native_stubs();\n+    ptr->free_native_invokers();\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"utilities\/copy.hpp\"\n@@ -500,2 +501,1 @@\n-  address* native_stubs,\n-  int num_stubs\n+  const GrowableArrayView<BufferBlob*>& native_invokers\n@@ -523,0 +523,1 @@\n+      + align_up(native_invokers.data_size_in_bytes() , oopSize)\n@@ -539,2 +540,1 @@\n-            native_stubs,\n-            num_stubs\n+            native_invokers\n@@ -604,2 +604,1 @@\n-  _native_basic_lock_sp_offset(basic_lock_sp_offset),\n-  _native_stubs(NULL), _num_stubs(0)\n+  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n@@ -629,1 +628,2 @@\n-    _handler_table_offset    = _dependencies_offset;\n+    _native_invokers_offset     = _dependencies_offset;\n+    _handler_table_offset    = _native_invokers_offset;\n@@ -726,2 +726,1 @@\n-  address* native_stubs,\n-  int num_stubs\n+  const GrowableArrayView<BufferBlob*>& native_invokers\n@@ -737,2 +736,1 @@\n-  _native_basic_lock_sp_offset(in_ByteSize(-1)),\n-  _native_stubs(native_stubs), _num_stubs(num_stubs)\n+  _native_basic_lock_sp_offset(in_ByteSize(-1))\n@@ -805,1 +803,2 @@\n-    _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies->size_in_bytes (), oopSize);\n+    _native_invokers_offset  = _dependencies_offset  + align_up((int)dependencies->size_in_bytes(), oopSize);\n+    _handler_table_offset    = _native_invokers_offset + align_up(native_invokers.data_size_in_bytes(), oopSize);\n@@ -827,0 +826,4 @@\n+    if (native_invokers.is_nonempty()) { \/\/ can not get address of zero-length array\n+      \/\/ Copy native stubs\n+      memcpy(native_invokers_begin(), native_invokers.adr_at(0), native_invokers.data_size_in_bytes());\n+    }\n@@ -989,0 +992,4 @@\n+    if (printmethod && native_invokers_begin() < native_invokers_end()) {\n+      print_native_invokers();\n+      tty->print_cr(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \");\n+    }\n@@ -1049,8 +1056,3 @@\n-void nmethod::free_native_stubs() {\n-  if (_native_stubs != NULL) {\n-    for (int i = 0; i < _num_stubs; i++) {\n-      CodeBlob* cb = CodeCache::find_blob((char*)  _native_stubs[i]);\n-      assert(cb != NULL, \"Expected to find blob\");\n-      CodeCache::free(cb);\n-    }\n-    FREE_C_HEAP_ARRAY(address, _native_stubs);\n+void nmethod::free_native_invokers() {\n+  for (BufferBlob** it = native_invokers_begin(); it < native_invokers_end(); it++) {\n+    CodeCache::free(*it);\n@@ -2692,0 +2694,8 @@\n+void nmethod::print_native_invokers() {\n+  ResourceMark m;       \/\/ in case methods get printed via debugger\n+  tty->print_cr(\"Native invokers:\");\n+  for (BufferBlob** itt = native_invokers_begin(); itt < native_invokers_end(); itt++) {\n+    (*itt)->print_on(tty);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+  int _native_invokers_offset;\n@@ -285,3 +286,0 @@\n-  address* _native_stubs;\n-  int _num_stubs;\n-\n@@ -319,2 +317,1 @@\n-          address* native_stubs,\n-          int num_stubs\n+          const GrowableArrayView<BufferBlob*>& native_invokers\n@@ -369,2 +366,1 @@\n-                              address* native_stubs = NULL,\n-                              int num_stubs = 0\n+                              const GrowableArrayView<BufferBlob*>& native_invokers = GrowableArrayView<BufferBlob*>::EMPTY\n@@ -419,1 +415,3 @@\n-  address dependencies_end      () const          { return           header_begin() + _handler_table_offset ; }\n+  address dependencies_end      () const          { return           header_begin() + _native_invokers_offset ; }\n+  BufferBlob** native_invokers_begin() const         { return (BufferBlob**)(header_begin() + _native_invokers_offset) ; }\n+  BufferBlob** native_invokers_end  () const         { return (BufferBlob**)(header_begin() + _handler_table_offset); }\n@@ -535,1 +533,1 @@\n-  void free_native_stubs();\n+  void free_native_invokers();\n@@ -673,0 +671,1 @@\n+  void print_native_invokers();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1630,1 +1630,1 @@\n-                                 compiler, comp_level, NULL, 0,\n+                                 compiler, comp_level, GrowableArrayView<BufferBlob*>::EMPTY,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1141,9 +1141,3 @@\n-    case TypeFunc::Parms:\n-    default: {\n-      if(tf()->range()->field_at(proj->_con) == Type::HALF) {\n-        assert(_ret_regs.at(proj->_con - TypeFunc::Parms) == VMRegImpl::Bad(), \"Unexpected register for Type::HALF\");\n-        \/\/ 2nd half of doubles and longs\n-        return new MachProjNode(this,proj->_con, RegMask::Empty, (uint)OptoReg::Bad);\n-      }\n-\n-      const BasicType bt = tf()->range()->field_at(proj->_con)->basic_type();\n+    case TypeFunc::Parms: {\n+      const Type* field_at_con = tf()->range()->field_at(proj->_con);\n+      const BasicType bt = field_at_con->basic_type();\n@@ -1158,3 +1152,3 @@\n-      if( OptoReg::is_valid(regs.second()) )\n-        rm.Insert( regs.second() );\n-      return new MachProjNode(this,proj->_con,rm,tf()->range()->field_at(proj->_con)->ideal_reg());\n+      if(OptoReg::is_valid(regs.second()))\n+        rm.Insert(regs.second());\n+      return new MachProjNode(this, proj->_con, rm, field_at_con->ideal_reg());\n@@ -1162,0 +1156,8 @@\n+    case TypeFunc::Parms + 1: {\n+      assert(tf()->range()->field_at(proj->_con) == Type::HALF, \"Expected HALF\");\n+      assert(_ret_regs.at(proj->_con - TypeFunc::Parms) == VMRegImpl::Bad(), \"Unexpected register for Type::HALF\");\n+      \/\/ 2nd half of doubles and longs\n+      return new MachProjNode(this, proj->_con, RegMask::Empty, (uint) OptoReg::Bad);\n+    }\n+    default:\n+      ShouldNotReachHere();\n@@ -1166,0 +1168,11 @@\n+void CallNativeNode::print_regs(const GrowableArray<VMReg>& regs, outputStream* st) {\n+  st->print(\"{ \");\n+  for (int i = 0; i < regs.length(); i++) {\n+    regs.at(i)->print_on(st);\n+    if (i < regs.length() - 1) {\n+      st->print(\", \");\n+    }\n+  }\n+  st->print(\" } \");\n+}\n+\n@@ -1170,1 +1183,1 @@\n-  _arg_regs.print_on(st);\n+  print_regs(_arg_regs, st);\n@@ -1172,1 +1185,1 @@\n-  _ret_regs.print_on(st);\n+  print_regs(_ret_regs, st);\n@@ -1184,1 +1197,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -815,0 +815,1 @@\n+  friend class MachCallNativeNode;\n@@ -817,0 +818,1 @@\n+  static void print_regs(const GrowableArray<VMReg>& regs, outputStream* st);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-                  _native_stubs(comp_arena(), 1, 0, NULL),\n+                  _native_invokers(comp_arena(), 1, 0, NULL),\n@@ -836,1 +836,1 @@\n-    _native_stubs(),\n+    _native_invokers(),\n@@ -4702,2 +4702,2 @@\n-void Compile::add_native_stub(address stubAddress) {\n-  _native_stubs.append(stubAddress);\n+void Compile::add_native_invoker(BufferBlob* stub) {\n+  _native_invokers.append(stub);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-  GrowableArray<address>        _native_stubs;\n+  GrowableArray<BufferBlob*>    _native_invokers;\n@@ -939,1 +939,1 @@\n-  void add_native_stub(address stub);\n+  void add_native_invoker(BufferBlob* stub);\n@@ -941,1 +941,1 @@\n-  const GrowableArray<address>& native_stubs() const { return _native_stubs; }\n+  const GrowableArray<BufferBlob*>& native_invokers() const { return _native_invokers; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2584,1 +2584,1 @@\n-  const Type** arg_types = NEW_RESOURCE_ARRAY(const Type*, n_filtered_args);\n+  const Type** arg_types = TypeTuple::fields(n_filtered_args);\n@@ -2599,1 +2599,1 @@\n-      arg_types[vm_arg_pos] = type;\n+      arg_types[TypeFunc::Parms + vm_arg_pos] = type;\n@@ -2606,1 +2606,1 @@\n-  const Type** ret_types = NEW_RESOURCE_ARRAY(const Type*, n_returns);\n+  const Type** ret_types = TypeTuple::fields(n_returns);\n@@ -2618,1 +2618,1 @@\n-      ret_types[vm_ret_pos] = type;\n+      ret_types[TypeFunc::Parms + vm_ret_pos] = type;\n@@ -2623,2 +2623,2 @@\n-    TypeTuple::make_func(n_filtered_args, arg_types),\n-    TypeTuple::make_func(n_returns, ret_types)\n+    TypeTuple::make(TypeFunc::Parms + n_filtered_args, arg_types),\n+    TypeTuple::make(TypeFunc::Parms + n_returns, ret_types)\n@@ -2629,3 +2629,3 @@\n-    call_addr = SharedRuntime::make_native_invoker(call_addr,\n-                                                   nep->shadow_space(),\n-                                                   arg_regs, ret_regs);\n+    BufferBlob* invoker = SharedRuntime::make_native_invoker(call_addr,\n+                                                             nep->shadow_space(),\n+                                                             arg_regs, ret_regs);\n@@ -2636,1 +2636,2 @@\n-    C->add_native_stub(call_addr);\n+    C->add_native_invoker(invoker);\n+    call_addr = invoker->code_begin();\n@@ -2665,11 +2666,1 @@\n-    Node* current_value = NULL;\n-    for (uint vm_ret_pos = 0; vm_ret_pos < n_returns; vm_ret_pos++) {\n-      if (new_call_type->range()->field_at(TypeFunc::Parms + vm_ret_pos)  == Type::HALF) {\n-        \/\/ FIXME is this needed?\n-        gvn().transform(new ProjNode(call, TypeFunc::Parms + vm_ret_pos));\n-      } else {\n-        assert(current_value == NULL, \"Must not overwrite\");\n-        current_value = gvn().transform(new ProjNode(call, TypeFunc::Parms + vm_ret_pos));\n-      }\n-    }\n-    assert(current_value != NULL, \"Should not be null\");\n+    ret =  gvn().transform(new ProjNode(call, TypeFunc::Parms));\n@@ -2680,1 +2671,1 @@\n-        current_value = _gvn.transform(new AndINode(current_value, _gvn.intcon(0xFFFF)));\n+        ret = _gvn.transform(new AndINode(ret, _gvn.intcon(0xFFFF)));\n@@ -2683,1 +2674,1 @@\n-        current_value = sign_extend_byte(current_value);\n+        ret = sign_extend_byte(ret);\n@@ -2686,1 +2677,1 @@\n-        current_value = sign_extend_short(current_value);\n+        ret = sign_extend_short(ret);\n@@ -2691,1 +2682,0 @@\n-    ret = current_value;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -866,1 +866,3 @@\n-      \/\/ FIXME compute actual save policy based on nep->abi\n+      \/\/ We use the c reg save policy here since Panama\n+      \/\/ only supports the C ABI currently.\n+      \/\/ TODO compute actual save policy based on nep->abi\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-  _arg_regs.print_on(st);\n+  CallNativeNode::print_regs(_arg_regs, st);\n@@ -833,1 +833,1 @@\n-  _ret_regs.print_on(st);\n+  CallNativeNode::print_regs(_ret_regs, st);\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1016,0 +1016,1 @@\n+  void print_regs(const GrowableArray<VMReg>& regs, outputStream* st) const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1006,0 +1006,1 @@\n+  bool is_opt_native = false;\n@@ -1024,0 +1025,2 @@\n+    } else if (mcall->is_MachCallNative()) {\n+      is_opt_native = true;\n@@ -1144,1 +1147,0 @@\n-    bool is_opt_native = mach->is_MachCallNative();\n@@ -3394,10 +3396,0 @@\n-    address* native_stubs = NULL;\n-    int num_stubs = 0;\n-    if (!C->native_stubs().is_empty()) {\n-      num_stubs = C->native_stubs().length();\n-      native_stubs = NEW_C_HEAP_ARRAY(address, num_stubs, mtInternal);\n-      for (int i = 0; i < num_stubs; i++) {\n-        native_stubs[i] = C->native_stubs().at(i);\n-      }\n-    }\n-\n@@ -3417,2 +3409,1 @@\n-                                     native_stubs,\n-                                     num_stubs);\n+                                     C->native_invokers());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1996,8 +1996,0 @@\n-const TypeTuple *TypeTuple::make_func( uint arg_cnt, const Type **arg_fields ) {\n-  const Type** field_array = fields(arg_cnt);\n-  for (uint i = 0; i < arg_cnt; i++) {\n-    field_array[i + TypeFunc::Parms] = arg_fields[i];\n-  }\n-  return make(arg_cnt + TypeFunc::Parms, field_array);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -678,1 +678,0 @@\n-  static const TypeTuple *make_func(uint arg_cnt, const Type **arg_fields);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -30,1 +30,1 @@\n-#include \"classfile\/symbolTable.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -77,1 +77,0 @@\n-  Symbol* sym = SymbolTable::new_symbol(FOREIGN_ABI \"ProgrammableUpcallHandler\");\n@@ -79,0 +78,2 @@\n+  ResourceMark rm(THREAD);\n+  Symbol* sym = SymbolTable::new_symbol(FOREIGN_ABI \"ProgrammableUpcallHandler\");\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -516,4 +516,4 @@\n-  static address make_native_invoker(address call_target,\n-                                     int shadow_space_bytes,\n-                                     const GrowableArray<VMReg>& input_registers,\n-                                     const GrowableArray<VMReg>& output_registers);\n+  static BufferBlob* make_native_invoker(address call_target,\n+                                         int shadow_space_bytes,\n+                                         const GrowableArray<VMReg>& input_registers,\n+                                         const GrowableArray<VMReg>& output_registers);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -127,0 +127,2 @@\n+  const static GrowableArrayView EMPTY;\n+\n@@ -313,1 +315,5 @@\n-  void print() {\n+  size_t data_size_in_bytes() const {\n+    return _len * sizeof(E);\n+  }\n+\n+  void print() const {\n@@ -323,0 +329,3 @@\n+template<typename E>\n+const GrowableArrayView<E> GrowableArrayView<E>::EMPTY(nullptr, 0, 0);\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    private static final int VECTOR_REG_SIZE = 64; \/\/ sizeof(VectorRegister)\n+    private static final int VECTOR_REG_SIZE = 16; \/\/ size of XMM register\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}