{"files":[{"patch":"@@ -27,6 +27,0 @@\n-#include \"include\/jvm.h\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/arrayOop.inline.hpp\"\n-#include \"prims\/methodHandles.hpp\"\n@@ -34,22 +28,2 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-\n-static constexpr CodeBuffer::csize_t native_invoker_size = 1024;\n-\n-static void generate_invoke_native(MacroAssembler* _masm,\n-                                   const ABIDescriptor& abi,\n-                                   const BufferLayout& layout) {\n-  \/**\n-   * invoke_native_stub(struct ShuffleDowncallContext* ctxt) {\n-   *   rbx = ctxt;\n-   *\n-   *   stack = alloca(ctxt->arguments.stack_args_bytes);\n-   *\n-   *   load_all_registers();\n-   *   memcpy(stack, ctxt->arguments.stack_args, arguments.stack_args_bytes);\n-   *\n-   *   (*ctxt->arguments.next_pc)();\n-   *\n-   *   store_all_registers();\n-   * }\n-   *\/\n+#include \"memory\/resourceArea.hpp\"\n+#include \"code\/codeBlob.hpp\"\n@@ -57,0 +31,1 @@\n+void ProgrammableInvoker::Generator::generate() {\n@@ -77,1 +52,1 @@\n-  assert(abi._stack_alignment_bytes % 16 == 0, \"stack must be 16 byte aligned\");\n+  assert(_abi->_stack_alignment_bytes % 16 == 0, \"stack must be 16 byte aligned\");\n@@ -80,3 +55,3 @@\n-  __ ldr(Rstack_size, Address(Rctx, (int) layout.stack_args_bytes));\n-  __ add(rscratch2, Rstack_size, abi._stack_alignment_bytes - 1);\n-  __ andr(rscratch2, rscratch2, -abi._stack_alignment_bytes);\n+  __ ldr(Rstack_size, Address(Rctx, (int) _layout->stack_args_bytes));\n+  __ add(rscratch2, Rstack_size, _abi->_stack_alignment_bytes - 1);\n+  __ andr(rscratch2, rscratch2, -_abi->_stack_alignment_bytes);\n@@ -87,1 +62,1 @@\n-  __ ldr(Rsrc_ptr, Address(Rctx, (int) layout.stack_args));\n+  __ ldr(Rsrc_ptr, Address(Rctx, (int) _layout->stack_args));\n@@ -100,3 +75,3 @@\n-  for (int i = 0; i < abi._vector_argument_registers.length(); i++) {\n-    ssize_t offs = layout.arguments_vector + i * sizeof(VectorRegister);\n-    __ ldrq(abi._vector_argument_registers.at(i), Address(Rctx, offs));\n+  for (int i = 0; i < _abi->_vector_argument_registers.length(); i++) {\n+    ssize_t offs = _layout->arguments_vector + i * sizeof(VectorRegister);\n+    __ ldrq(_abi->_vector_argument_registers.at(i), Address(Rctx, offs));\n@@ -105,3 +80,3 @@\n-  for (int i = 0; i < abi._integer_argument_registers.length(); i++) {\n-    ssize_t offs = layout.arguments_integer + i * sizeof(uintptr_t);\n-    __ ldr(abi._integer_argument_registers.at(i), Address(Rctx, offs));\n+  for (int i = 0; i < _abi->_integer_argument_registers.length(); i++) {\n+    ssize_t offs = _layout->arguments_integer + i * sizeof(uintptr_t);\n+    __ ldr(_abi->_integer_argument_registers.at(i), Address(Rctx, offs));\n@@ -110,1 +85,1 @@\n-  assert(abi._shadow_space_bytes == 0, \"shadow space not supported on AArch64\");\n+  assert(_abi->_shadow_space_bytes == 0, \"shadow space not supported on AArch64\");\n@@ -114,1 +89,1 @@\n-  __ ldr(rscratch2, Address(Rctx, (int) layout.arguments_next_pc));\n+  __ ldr(rscratch2, Address(Rctx, (int) _layout->arguments_next_pc));\n@@ -121,3 +96,3 @@\n-  for (int i = 0; i < abi._integer_return_registers.length(); i++) {\n-    ssize_t offs = layout.returns_integer + i * sizeof(uintptr_t);\n-    __ str(abi._integer_return_registers.at(i), Address(Rctx, offs));\n+  for (int i = 0; i < _abi->_integer_return_registers.length(); i++) {\n+    ssize_t offs = _layout->returns_integer + i * sizeof(uintptr_t);\n+    __ str(_abi->_integer_return_registers.at(i), Address(Rctx, offs));\n@@ -126,3 +101,3 @@\n-  for (int i = 0; i < abi._vector_return_registers.length(); i++) {\n-    ssize_t offs = layout.returns_vector + i * sizeof(VectorRegister);\n-    __ strq(abi._vector_return_registers.at(i), Address(Rctx, offs));\n+  for (int i = 0; i < _abi->_vector_return_registers.length(); i++) {\n+    ssize_t offs = _layout->returns_vector + i * sizeof(VectorRegister);\n+    __ strq(_abi->_vector_return_registers.at(i), Address(Rctx, offs));\n@@ -137,16 +112,1 @@\n-class ProgrammableInvokerGenerator : public StubCodeGenerator {\n-private:\n-  const ABIDescriptor* _abi;\n-  const BufferLayout* _layout;\n-public:\n-  ProgrammableInvokerGenerator(CodeBuffer* code, const ABIDescriptor* abi, const BufferLayout* layout)\n-    : StubCodeGenerator(code, PrintMethodHandleStubs),\n-      _abi(abi),\n-      _layout(layout) {}\n-\n-  void generate() {\n-    generate_invoke_native(_masm, *_abi, *_layout);\n-  }\n-};\n-\n-jlong ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {\n+address ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {\n@@ -160,1 +120,1 @@\n-  ProgrammableInvokerGenerator g2(&code2, &abi, &layout);\n+  ProgrammableInvoker::Generator g2(&code2, &abi, &layout);\n@@ -164,1 +124,1 @@\n-  return (jlong) _invoke_native_blob->code_begin();\n+  return _invoke_native_blob->code_begin();\n","filename":"src\/hotspot\/cpu\/aarch64\/universalNativeInvoker_aarch64.cpp","additions":25,"deletions":65,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -27,7 +27,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"include\/jvm.h\"\n-#include \"jni.h\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n@@ -35,1 +28,0 @@\n-#include \"oops\/arrayOop.inline.hpp\"\n@@ -37,85 +29,0 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-\n-static constexpr CodeBuffer::csize_t upcall_stub_size = 1024;\n-\n-extern struct JavaVM_ main_vm;\n-\n-static struct {\n-  bool inited;\n-  struct {\n-    Klass* klass;\n-    Symbol* name;\n-    Symbol* sig;\n-  } upcall_method;  \/\/ jdk.internal.foreign.abi.UniversalUpcallHandler::invoke\n-} upcall_info;\n-\n-\/\/ FIXME: This should be initialized explicitly instead of lazily\/racily\n-static void upcall_init() {\n-#if 0\n-  fprintf(stderr, \"upcall_init()\\n\");\n-#endif\n-\n-  TRAPS = Thread::current();\n-  ResourceMark rm;\n-\n-  const char* cname = \"jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler\";\n-  const char* mname = \"invoke\";\n-  const char* mdesc = \"(Ljdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler;J)V\";\n-  Symbol* cname_sym = SymbolTable::new_symbol(cname, (int)strlen(cname));\n-  Symbol* mname_sym = SymbolTable::new_symbol(mname, (int)strlen(mname));\n-  Symbol* mdesc_sym = SymbolTable::new_symbol(mdesc, (int)strlen(mdesc));\n-\n-#if 0\n-  ::fprintf(stderr, \"cname_sym: %p\\n\", cname_sym);\n-  ::fprintf(stderr, \"mname_sym: %p\\n\", mname_sym);\n-  ::fprintf(stderr, \"mdesc_sym: %p\\n\", mdesc_sym);\n-#endif\n-\n-  Klass* k = SystemDictionary::resolve_or_null(cname_sym, THREAD);\n-#if 0\n-  ::fprintf(stderr, \"Klass: %p\\n\", k);\n-#endif\n-\n-  Method* method = k->lookup_method(mname_sym, mdesc_sym);\n-#if 0\n-  ::fprintf(stderr, \"Method: %p\\n\", method);\n-#endif\n-\n-  upcall_info.upcall_method.klass = k;\n-  upcall_info.upcall_method.name = mname_sym;\n-  upcall_info.upcall_method.sig = mdesc_sym;\n-\n-  upcall_info.inited = true;\n-}\n-\n-static void upcall_helper(jobject rec, address buff) {\n-  void *p_env = NULL;\n-\n-  Thread* thread = Thread::current_or_null();\n-  if (thread == NULL) {\n-    JavaVM_ *vm = (JavaVM *)(&main_vm);\n-    vm -> functions -> AttachCurrentThreadAsDaemon(vm, &p_env, NULL);\n-    thread = Thread::current();\n-  }\n-\n-  assert(thread->is_Java_thread(), \"really?\");\n-\n-  ThreadInVMfromNative __tiv((JavaThread *)thread);\n-\n-  if (!upcall_info.inited) {\n-    upcall_init();\n-  }\n-\n-  ResourceMark rm;\n-  JavaValue result(T_VOID);\n-  JavaCallArguments args(2); \/\/ long = 2 slots\n-\n-  args.push_jobject(rec);\n-  args.push_long((jlong) buff);\n-\n-  JavaCalls::call_static(&result, upcall_info.upcall_method.klass,\n-                         upcall_info.upcall_method.name, upcall_info.upcall_method.sig,\n-                         &args, thread);\n-}\n@@ -123,0 +30,5 @@\n+\/\/ 1. Create buffer according to layout\n+\/\/ 2. Load registers & stack args into buffer\n+\/\/ 3. Call upcall helper with upcall handler instance & buffer pointer (C++ ABI)\n+\/\/ 4. Load return value from buffer into foreign ABI registers\n+\/\/ 5. Return\n@@ -165,1 +77,1 @@\n-  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, upcall_helper));\n+  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, ProgrammableUpcallHandler::attach_thread_and_do_upcall));\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":6,"deletions":94,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -26,6 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"interpreter\/interpreter.hpp\"\n-#include \"interpreter\/interpreterRuntime.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"include\/jvm.h\"\n@@ -33,30 +27,2 @@\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"oops\/arrayOop.inline.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"prims\/methodHandles.hpp\"\n-\n-static constexpr CodeBuffer::csize_t native_invoker_size = 1024;\n-\n-void generate_invoke_native(MacroAssembler* _masm, const ABIDescriptor& abi, const BufferLayout& layout) {\n-\n-#if 0\n-  fprintf(stderr, \"generate_invoke_native()\\n\");\n-#endif\n-\n-  \/**\n-   * invoke_native_stub(struct ShuffleDowncallContext* ctxt) {\n-   *   rbx = ctxt;\n-   *\n-   *   stack = alloca(ctxt->arguments.stack_args_bytes);\n-   *\n-   *   load_all_registers();\n-   *   memcpy(stack, ctxt->arguments.stack_args, arguments.stack_args_bytes);\n-   *\n-   *   (*ctxt->arguments.next_pc)();\n-   *\n-   *   store_all_registers();\n-   * }\n-   *\/\n+#include \"memory\/resourceArea.hpp\"\n+#include \"code\/codeBlob.hpp\"\n@@ -64,0 +30,1 @@\n+void ProgrammableInvoker::Generator::generate() {\n@@ -73,1 +40,1 @@\n-    if (!abi.is_volatile_reg(used_reg)) {\n+    if (!_abi->is_volatile_reg(used_reg)) {\n@@ -87,1 +54,1 @@\n-  __ movptr(rcx, Address(ctxt_reg, (int) layout.stack_args_bytes));\n+  __ movptr(rcx, Address(ctxt_reg, (int) _layout->stack_args_bytes));\n@@ -89,1 +56,1 @@\n-  __ andptr(rsp, -abi._stack_alignment_bytes);\n+  __ andptr(rsp, -_abi->_stack_alignment_bytes);\n@@ -97,1 +64,1 @@\n-  __ movptr(rsi, Address(ctxt_reg, (int) layout.stack_args));\n+  __ movptr(rsi, Address(ctxt_reg, (int) _layout->stack_args));\n@@ -102,1 +69,1 @@\n-  for (int i = 0; i < abi._vector_argument_registers.length(); i++) {\n+  for (int i = 0; i < _abi->_vector_argument_registers.length(); i++) {\n@@ -108,2 +75,2 @@\n-    XMMRegister reg = abi._vector_argument_registers.at(i);\n-    size_t offs = layout.arguments_vector + i * sizeof(VectorRegister);\n+    XMMRegister reg = _abi->_vector_argument_registers.at(i);\n+    size_t offs = _layout->arguments_vector + i * sizeof(VectorRegister);\n@@ -119,3 +86,3 @@\n-  for (int i = 0; i < abi._integer_argument_registers.length(); i++) {\n-    size_t offs = layout.arguments_integer + i * sizeof(uintptr_t);\n-    __ movptr(abi._integer_argument_registers.at(i), Address(ctxt_reg, (int)offs));\n+  for (int i = 0; i < _abi->_integer_argument_registers.length(); i++) {\n+    size_t offs = _layout->arguments_integer + i * sizeof(uintptr_t);\n+    __ movptr(_abi->_integer_argument_registers.at(i), Address(ctxt_reg, (int)offs));\n@@ -124,1 +91,1 @@\n-  if (abi._shadow_space_bytes != 0) {\n+  if (_abi->_shadow_space_bytes != 0) {\n@@ -126,1 +93,1 @@\n-    __ subptr(rsp, abi._shadow_space_bytes);\n+    __ subptr(rsp, _abi->_shadow_space_bytes);\n@@ -131,1 +98,1 @@\n-  __ call(Address(ctxt_reg, (int) layout.arguments_next_pc));\n+  __ call(Address(ctxt_reg, (int) _layout->arguments_next_pc));\n@@ -133,1 +100,1 @@\n-  if (abi._shadow_space_bytes != 0) {\n+  if (_abi->_shadow_space_bytes != 0) {\n@@ -135,1 +102,1 @@\n-    __ addptr(rsp, abi._shadow_space_bytes);\n+    __ addptr(rsp, _abi->_shadow_space_bytes);\n@@ -139,3 +106,3 @@\n-  for (int i = 0; i < abi._integer_return_registers.length(); i++) {\n-    ssize_t offs = layout.returns_integer + i * sizeof(uintptr_t);\n-    __ movptr(Address(ctxt_reg, offs), abi._integer_return_registers.at(i));\n+  for (int i = 0; i < _abi->_integer_return_registers.length(); i++) {\n+    ssize_t offs = _layout->returns_integer + i * sizeof(uintptr_t);\n+    __ movptr(Address(ctxt_reg, offs), _abi->_integer_return_registers.at(i));\n@@ -144,1 +111,1 @@\n-  for (int i = 0; i < abi._vector_return_registers.length(); i++) {\n+  for (int i = 0; i < _abi->_vector_return_registers.length(); i++) {\n@@ -150,2 +117,2 @@\n-    XMMRegister reg = abi._vector_return_registers.at(i);\n-    size_t offs = layout.returns_vector + i * sizeof(VectorRegister);\n+    XMMRegister reg = _abi->_vector_return_registers.at(i);\n+    size_t offs = _layout->returns_vector + i * sizeof(VectorRegister);\n@@ -161,2 +128,2 @@\n-  for (size_t i = 0; i < abi._X87_return_registers_noof; i++) {\n-    size_t offs = layout.returns_x87 + i * (sizeof(long double));\n+  for (size_t i = 0; i < _abi->_X87_return_registers_noof; i++) {\n+    size_t offs = _layout->returns_x87 + i * (sizeof(long double));\n@@ -177,14 +144,1 @@\n-class ProgrammableInvokerGenerator : public StubCodeGenerator {\n-private:\n-  const ABIDescriptor* _abi;\n-  const BufferLayout* _layout;\n-public:\n-  ProgrammableInvokerGenerator(CodeBuffer* code, const ABIDescriptor* abi, const BufferLayout* layout)\n-   : StubCodeGenerator(code, PrintMethodHandleStubs), _abi(abi), _layout(layout) {}\n-\n-  void generate() {\n-      generate_invoke_native(_masm, *_abi, *_layout);\n-  }\n-};\n-\n-jlong ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {\n+address ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {\n@@ -198,1 +152,1 @@\n-  ProgrammableInvokerGenerator g2(&code2, &abi, &layout);\n+  ProgrammableInvoker::Generator g2(&code2, &abi, &layout);\n@@ -202,1 +156,1 @@\n-  return (jlong) _invoke_native_blob->code_begin();\n+  return _invoke_native_blob->code_begin();\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86.cpp","additions":29,"deletions":75,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"interpreter\/interpreter.hpp\"\n-#include \"interpreter\/interpreterRuntime.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n@@ -31,2 +27,0 @@\n-#include \"include\/jvm.h\"\n-#include \"jni.h\"\n@@ -34,87 +28,0 @@\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"oops\/arrayOop.inline.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-\n-static constexpr CodeBuffer::csize_t upcall_stub_size = 1024;\n-\n-extern struct JavaVM_ main_vm;\n-\n-static struct {\n-  bool inited;\n-  struct {\n-    Klass* klass;\n-    Symbol* name;\n-    Symbol* sig;\n-  } upcall_method;  \/\/ jdk.internal.foreign.abi.UniversalUpcallHandler::invoke\n-} upcall_info;\n-\n-\/\/ FIXME: This should be initialized explicitly instead of lazily\/racily\n-static void upcall_init() {\n-#if 0\n-  fprintf(stderr, \"upcall_init()\\n\");\n-#endif\n-\n-  TRAPS = Thread::current();\n-  ResourceMark rm;\n-\n-  const char* cname = \"jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler\";\n-  const char* mname = \"invoke\";\n-  const char* mdesc = \"(Ljdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler;J)V\";\n-  Symbol* cname_sym = SymbolTable::new_symbol(cname, (int)strlen(cname));\n-  Symbol* mname_sym = SymbolTable::new_symbol(mname, (int)strlen(mname));\n-  Symbol* mdesc_sym = SymbolTable::new_symbol(mdesc, (int)strlen(mdesc));\n-\n-#if 0\n-  ::fprintf(stderr, \"cname_sym: %p\\n\", cname_sym);\n-  ::fprintf(stderr, \"mname_sym: %p\\n\", mname_sym);\n-  ::fprintf(stderr, \"mdesc_sym: %p\\n\", mdesc_sym);\n-#endif\n-\n-  Klass* k = SystemDictionary::resolve_or_null(cname_sym, THREAD);\n-#if 0\n-  ::fprintf(stderr, \"Klass: %p\\n\", k);\n-#endif\n-\n-  Method* method = k->lookup_method(mname_sym, mdesc_sym);\n-#if 0\n-  ::fprintf(stderr, \"Method: %p\\n\", method);\n-#endif\n-\n-  upcall_info.upcall_method.klass = k;\n-  upcall_info.upcall_method.name = mname_sym;\n-  upcall_info.upcall_method.sig = mdesc_sym;\n-\n-  upcall_info.inited = true;\n-}\n-\n-static void upcall_helper(jobject rec, address buff) {\n-  void *p_env = NULL;\n-\n-  Thread* thread = Thread::current_or_null();\n-  if (thread == NULL) {\n-    JavaVM_ *vm = (JavaVM *)(&main_vm);\n-    vm -> functions -> AttachCurrentThreadAsDaemon(vm, &p_env, NULL);\n-    thread = Thread::current();\n-  }\n-\n-  assert(thread->is_Java_thread(), \"really?\");\n-\n-  ThreadInVMfromNative __tiv((JavaThread *)thread);\n-\n-  if (!upcall_info.inited) {\n-    upcall_init();\n-  }\n-\n-  ResourceMark rm;\n-  JavaValue result(T_VOID);\n-  JavaCallArguments args(2); \/\/ long = 2 slots\n-\n-  args.push_jobject(rec);\n-  args.push_long((jlong) buff);\n-\n-  JavaCalls::call_static(&result, upcall_info.upcall_method.klass, upcall_info.upcall_method.name, upcall_info.upcall_method.sig, &args, thread);\n-}\n@@ -122,0 +29,5 @@\n+\/\/ 1. Create buffer according to layout\n+\/\/ 2. Load registers & stack args into buffer\n+\/\/ 3. Call upcall helper with upcall handler instance & buffer pointer (C++ ABI)\n+\/\/ 4. Load return value from buffer into foreign ABI registers\n+\/\/ 5. Return\n@@ -198,1 +110,1 @@\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, upcall_helper)));\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::attach_thread_and_do_upcall)));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86.cpp","additions":6,"deletions":94,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"code\/codeBlob.hpp\"\n@@ -28,3 +27,0 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"runtime\/stubCodeGenerator.hpp\"\n-#include \"prims\/methodHandles.hpp\"\n@@ -32,1 +28,6 @@\n-void ProgrammableInvoker::invoke_native(ProgrammableStub stub, address buff, JavaThread* thread) {\n+ProgrammableInvoker::Generator::Generator(CodeBuffer* code, const ABIDescriptor* abi, const BufferLayout* layout)\n+  : StubCodeGenerator(code),\n+    _abi(abi),\n+    _layout(layout) {}\n+\n+void ProgrammableInvoker::invoke_native(Stub stub, address buff, JavaThread* thread) {\n@@ -45,1 +46,1 @@\n-  ProgrammableStub stub = (ProgrammableStub) adapter_stub;\n+  ProgrammableInvoker::Stub stub = (ProgrammableInvoker::Stub) adapter_stub;\n@@ -51,1 +52,1 @@\n-  return ProgrammableInvoker::generate_adapter(abi, layout);\n+  return (jlong) ProgrammableInvoker::generate_adapter(abi, layout);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,6 +27,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"include\/jvm.h\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"utilities\/macros.hpp\"\n+#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -35,7 +30,3 @@\n-#ifdef ZERO\n-# include \"entry_zero.hpp\"\n-#endif\n-\n-class MacroAssembler;\n-class Label;\n-class ShuffleRecipe;\n+class ProgrammableInvoker: AllStatic {\n+private:\n+  static constexpr CodeBuffer::csize_t native_invoker_size = 1024;\n@@ -43,1 +34,6 @@\n-typedef void (*ProgrammableStub)(address);\n+  class Generator : StubCodeGenerator {\n+  private:\n+    const ABIDescriptor* _abi;\n+    const BufferLayout* _layout;\n+  public:\n+    Generator(CodeBuffer* code, const ABIDescriptor* abi, const BufferLayout* layout);\n@@ -45,1 +41,2 @@\n-class ProgrammableInvoker: AllStatic {\n+    void generate();\n+  };\n@@ -47,2 +44,4 @@\n-  static void invoke_native(ProgrammableStub stub, address buff, JavaThread* thread);\n-  static jlong generate_adapter(jobject abi, jobject layout);\n+  using Stub = void(*)(address);\n+\n+  static void invoke_native(Stub stub, address buff, JavaThread* thread);\n+  static address generate_adapter(jobject abi, jobject layout);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.hpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,60 @@\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+\n+#define FOREIGN_ABI \"jdk\/internal\/foreign\/abi\/\"\n+\n+extern struct JavaVM_ main_vm;\n+\n+JNI_ENTRY(void, ProgrammableUpcallHandler::upcall_helper(JNIEnv* env, jobject rec, address buff))\n+  const UpcallMethod& upcall_method = instance().upcall_method;\n+\n+  ResourceMark rm(thread);\n+  JavaValue result(T_VOID);\n+  JavaCallArguments args(2); \/\/ long = 2 slots\n+\n+  args.push_jobject(rec);\n+  args.push_long((jlong) buff);\n+\n+  JavaCalls::call_static(&result, upcall_method.klass, upcall_method.name, upcall_method.sig, &args, thread);\n+JNI_END\n+\n+void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+  Thread* thread = Thread::current_or_null();\n+  bool should_detach = false;\n+  JNIEnv* p_env = nullptr;\n+  if (thread == nullptr) {\n+    JavaVM_ *vm = (JavaVM *)(&main_vm);\n+    vm->functions->AttachCurrentThread(vm, (void**) &p_env, nullptr);\n+    should_detach = true;\n+    thread = Thread::current();\n+  } else {\n+    p_env = thread->as_Java_thread()->jni_environment();\n+  }\n+\n+  upcall_helper(p_env, rec, buff);\n+\n+  if (should_detach) {\n+    JavaVM_ *vm = (JavaVM *)(&main_vm);\n+    vm->functions->DetachCurrentThread(vm);\n+  }\n+}\n+\n+const ProgrammableUpcallHandler& ProgrammableUpcallHandler::instance() {\n+  static ProgrammableUpcallHandler handler;\n+  return handler;\n+}\n+\n+ProgrammableUpcallHandler::ProgrammableUpcallHandler() {\n+  Symbol* sym = SymbolTable::new_symbol(FOREIGN_ABI \"ProgrammableUpcallHandler\");\n+  Thread* THREAD = Thread::current();\n+  Klass* k = SystemDictionary::resolve_or_null(sym, Handle(), Handle(), CATCH);\n+  k->initialize(CATCH);\n+\n+  upcall_method.klass = k;\n+  upcall_method.name = SymbolTable::new_symbol(\"invoke\");\n+  upcall_method.sig = SymbolTable::new_symbol(\"(L\" FOREIGN_ABI \"ProgrammableUpcallHandler;J)V\");\n+\n+  assert(upcall_method.klass->lookup_method(upcall_method.name, upcall_method.sig) != nullptr,\n+    \"Could not find upcall method: %s.%s%s\", upcall_method.klass->external_name(),\n+    upcall_method.name->as_C_string(), upcall_method.sig->as_C_string());\n+}\n@@ -37,3 +97,0 @@\n-#define LANG \"Ljava\/lang\/\"\n-\n-#define FOREIGN_ABI \"Ljdk\/internal\/foreign\/abi\"\n@@ -42,1 +99,1 @@\n-  {CC \"allocateUpcallStub\", CC \"(\" FOREIGN_ABI \"\/ABIDescriptor;\" FOREIGN_ABI \"\/BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateUpcallStub\", CC \"(L\" FOREIGN_ABI \"ABIDescriptor;L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -27,6 +27,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"include\/jvm.h\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"utilities\/macros.hpp\"\n@@ -35,1 +29,16 @@\n-class ProgrammableUpcallHandler : AllStatic {\n+class ProgrammableUpcallHandler {\n+private:\n+  static constexpr CodeBuffer::csize_t upcall_stub_size = 1024;\n+\n+  struct UpcallMethod {\n+    Klass* klass;\n+    Symbol* name;\n+    Symbol* sig;\n+  } upcall_method;\n+\n+  ProgrammableUpcallHandler();\n+\n+  static const ProgrammableUpcallHandler& instance();\n+\n+  static void upcall_helper(JNIEnv* env, jobject rec, address buff);\n+  static void attach_thread_and_do_upcall(jobject rec, address buff);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"}]}