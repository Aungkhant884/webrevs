{"files":[{"patch":"@@ -181,0 +181,7 @@\n+  \/\/ No need in interpreter entry for linkToNative for now.\n+  \/\/ Interpreter calls compiled entry through i2c.\n+  if (iid == vmIntrinsics::_linkToNative) {\n+    __ hlt(0);\n+    return NULL;\n+  }\n+\n@@ -275,1 +282,4 @@\n-  if (iid == vmIntrinsics::_invokeBasic) {\n+  if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {\n+    if (iid == vmIntrinsics::_linkToNative) {\n+      assert(for_compiler_entry, \"only compiler entry is supported\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-  } else if (iid == vmIntrinsics::_invokeBasic) {\n+  } else if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2632,1 +2632,4 @@\n-    if (call_addr == NULL) return NULL;\n+    if (call_addr == NULL) {\n+      C->record_failure(\"native invoker not implemented on this platform\");\n+      return NULL;\n+    }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"memory\/resourceArea.hpp\"\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-                        StorageClasses.INTEGER, layout);\n+                        StorageClasses.INTEGER, AArch64.C_POINTER);\n@@ -408,1 +408,2 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(\n+                        StorageClasses.INTEGER, AArch64.C_POINTER);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,0 +347,36 @@\n+\n+    @Test\n+    public void testStructStackSpill() {\n+        \/\/ A large (> 16 byte) struct argument that is spilled to the\n+        \/\/ stack should be passed as a pointer to a copy and occupy one\n+        \/\/ stack slot.\n+\n+        MemoryLayout struct = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n+            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(r0, long.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(r1, long.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}