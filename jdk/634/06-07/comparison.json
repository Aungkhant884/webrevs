{"files":[{"patch":"@@ -26,2 +26,4 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include CPU_HEADER(foreign_globals)\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreign_globals.inline.hpp\"\n@@ -39,2 +41,0 @@\n-#define FOREIGN_ABI \"jdk\/internal\/foreign\/abi\/\"\n-\n@@ -43,25 +43,0 @@\n-#define X87_TYPE 2\n-#define STACK_TYPE 3\n-\n-template<typename T, typename Func>\n-void loadArray(JNIEnv* env, jfieldID indexField, jobjectArray jarray,\n-               jint type_index, GrowableArray<T>& array, Func converter) {\n-  jobjectArray subarray = (jobjectArray) env->GetObjectArrayElement(jarray, type_index);\n-  jint subarray_length = env->GetArrayLength(subarray);\n-  for (jint i = 0; i < subarray_length; i++) {\n-    jobject storage = env->GetObjectArrayElement(subarray, i);\n-    jint index = env->GetIntField(storage, indexField);\n-    array.push(converter(index));\n-  }\n-}\n-\n-const ABIDescriptor parseABIDescriptor(JNIEnv* env, jobject jabi) {\n-  jclass jc_ABIDescriptor = env->FindClass(FOREIGN_ABI \"ABIDescriptor\");\n-  jfieldID jfID_inputStorage = env->GetFieldID(jc_ABIDescriptor, \"inputStorage\", \"[[L\" FOREIGN_ABI \"VMStorage;\");\n-  jfieldID jfID_outputStorage = env->GetFieldID(jc_ABIDescriptor, \"outputStorage\", \"[[L\" FOREIGN_ABI \"VMStorage;\");\n-  jfieldID jfID_volatileStorage = env->GetFieldID(jc_ABIDescriptor, \"volatileStorage\", \"[[L\" FOREIGN_ABI \"VMStorage;\");\n-  jfieldID jfID_stackAlignment = env->GetFieldID(jc_ABIDescriptor, \"stackAlignment\", \"I\");\n-  jfieldID jfID_shadowSpace = env->GetFieldID(jc_ABIDescriptor, \"shadowSpace\", \"I\");\n-\n-  jclass jc_VMStorage = env->FindClass(FOREIGN_ABI \"VMStorage\");\n-  jfieldID jfID_storageIndex = env->GetFieldID(jc_VMStorage, \"index\", \"I\");\n@@ -69,0 +44,2 @@\n+const ABIDescriptor ForeignGlobals::parseABIDescriptor_impl(jobject jabi) const {\n+  oop abi_oop = JNIHandles::resolve_non_null(jabi);\n@@ -71,3 +48,3 @@\n-  jobjectArray inputStorage = (jobjectArray) env->GetObjectField(jabi, jfID_inputStorage);\n-  loadArray(env, jfID_storageIndex, inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n-  loadArray(env, jfID_storageIndex, inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_FloatRegister);\n+  objArrayOop inputStorage = cast<objArrayOop>(abi_oop->obj_field(ABI.inputStorage_offset));\n+  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n+  loadArray(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_FloatRegister);\n@@ -75,3 +52,3 @@\n-  jobjectArray outputStorage = (jobjectArray) env->GetObjectField(jabi, jfID_outputStorage);\n-  loadArray(env, jfID_storageIndex, outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n-  loadArray(env, jfID_storageIndex, outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_FloatRegister);\n+  objArrayOop outputStorage = cast<objArrayOop>(abi_oop->obj_field(ABI.outputStorage_offset));\n+  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n+  loadArray(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_FloatRegister);\n@@ -79,3 +56,3 @@\n-  jobjectArray volatileStorage = (jobjectArray) env->GetObjectField(jabi, jfID_volatileStorage);\n-  loadArray(env, jfID_storageIndex, volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n-  loadArray(env, jfID_storageIndex, volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  objArrayOop volatileStorage = cast<objArrayOop>(abi_oop->obj_field(ABI.volatileStorage_offset));\n+  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n+  loadArray(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_FloatRegister);\n@@ -83,2 +60,2 @@\n-  abi._stack_alignment_bytes = env->GetIntField(jabi, jfID_stackAlignment);\n-  abi._shadow_space_bytes = env->GetIntField(jabi, jfID_shadowSpace);\n+  abi._stack_alignment_bytes = abi_oop->int_field(ABI.stackAlignment_offset);\n+  abi._shadow_space_bytes = abi_oop->int_field(ABI.shadowSpace_offset);\n@@ -89,14 +66,2 @@\n-const BufferLayout parseBufferLayout(JNIEnv* env, jobject jlayout) {\n-  jclass jc_BufferLayout = env->FindClass(FOREIGN_ABI \"BufferLayout\");\n-  jfieldID jfID_size = env->GetFieldID(jc_BufferLayout, \"size\", \"J\");\n-  jfieldID jfID_arguments_next_pc =\n-    env->GetFieldID(jc_BufferLayout, \"arguments_next_pc\", \"J\");\n-  jfieldID jfID_stack_args_bytes =\n-    env->GetFieldID(jc_BufferLayout, \"stack_args_bytes\", \"J\");\n-  jfieldID jfID_stack_args =\n-    env->GetFieldID(jc_BufferLayout, \"stack_args\", \"J\");\n-  jfieldID jfID_input_type_offsets =\n-    env->GetFieldID(jc_BufferLayout, \"input_type_offsets\", \"[J\");\n-  jfieldID jfID_output_type_offsets =\n-    env->GetFieldID(jc_BufferLayout, \"output_type_offsets\", \"[J\");\n-\n+const BufferLayout ForeignGlobals::parseBufferLayout_impl(jobject jlayout) const {\n+  oop layout_oop = JNIHandles::resolve_non_null(jlayout);\n@@ -105,19 +70,13 @@\n-  layout.stack_args_bytes = env->GetLongField(jlayout, jfID_stack_args_bytes);\n-  layout.stack_args = env->GetLongField(jlayout, jfID_stack_args);\n-  layout.arguments_next_pc = env->GetLongField(jlayout, jfID_arguments_next_pc);\n-\n-  jlongArray input_offsets =\n-    (jlongArray)env->GetObjectField(jlayout, jfID_input_type_offsets);\n-  jlong *input_offsets_prim = env->GetLongArrayElements(input_offsets, NULL);\n-  layout.arguments_integer = (size_t)input_offsets_prim[INTEGER_TYPE];\n-  layout.arguments_vector = (size_t)input_offsets_prim[VECTOR_TYPE];\n-  env->ReleaseLongArrayElements(input_offsets, input_offsets_prim, JNI_ABORT);\n-\n-  jlongArray output_offsets =\n-    (jlongArray)env->GetObjectField(jlayout, jfID_output_type_offsets);\n-  jlong *output_offsets_prim = env->GetLongArrayElements(output_offsets, NULL);\n-  layout.returns_integer = (size_t)output_offsets_prim[INTEGER_TYPE];\n-  layout.returns_vector = (size_t)output_offsets_prim[VECTOR_TYPE];\n-  env->ReleaseLongArrayElements(output_offsets, output_offsets_prim, JNI_ABORT);\n-\n-  layout.buffer_size = env->GetLongField(jlayout, jfID_size);\n+  layout.stack_args_bytes = layout_oop->long_field(BL.stack_args_bytes_offset);\n+  layout.stack_args = layout_oop->long_field(BL.stack_args_offset);\n+  layout.arguments_next_pc = layout_oop->long_field(BL.arguments_next_pc_offset);\n+\n+  typeArrayOop input_offsets = cast<typeArrayOop>(layout_oop->obj_field(BL.input_type_offsets_offset));\n+  layout.arguments_integer = (size_t) input_offsets->long_at(INTEGER_TYPE);\n+  layout.arguments_vector = (size_t) input_offsets->long_at(VECTOR_TYPE);\n+\n+  typeArrayOop output_offsets = cast<typeArrayOop>(layout_oop->obj_field(BL.output_type_offsets_offset));\n+  layout.returns_integer = (size_t) output_offsets->long_at(INTEGER_TYPE);\n+  layout.returns_vector = (size_t) output_offsets->long_at(VECTOR_TYPE);\n+\n+  layout.buffer_size = layout_oop->long_field(BL.size_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":32,"deletions":73,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n@@ -31,0 +28,3 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n@@ -75,3 +75,0 @@\n-const ABIDescriptor parseABIDescriptor(JNIEnv* env, jobject jabi);\n-const BufferLayout parseBufferLayout(JNIEnv* env, jobject jlayout);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -152,4 +152,3 @@\n-jlong ProgrammableInvoker::generate_adapter(JNIEnv* env, jobject jabi, jobject jlayout) {\n-  ResourceMark rm;\n-  const ABIDescriptor abi = parseABIDescriptor(env, jabi);\n-  const BufferLayout layout = parseBufferLayout(env, jlayout);\n+jlong ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {\n+  const ABIDescriptor abi = ForeignGlobals::parseABIDescriptor(jabi);\n+  const BufferLayout layout = ForeignGlobals::parseBufferLayout(jlayout);\n","filename":"src\/hotspot\/cpu\/aarch64\/universalNativeInvoker_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -187,3 +187,3 @@\n-jlong ProgrammableUpcallHandler::generate_upcall_stub(JNIEnv *env, jobject rec, jobject jabi, jobject jlayout) {\n-  const ABIDescriptor abi = parseABIDescriptor(env, jabi);\n-  const BufferLayout layout = parseBufferLayout(env, jlayout);\n+jlong ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n+  const ABIDescriptor abi = ForeignGlobals::parseABIDescriptor(jabi);\n+  const BufferLayout layout = ForeignGlobals::parseBufferLayout(jlayout);\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include CPU_HEADER(foreign_globals)\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreign_globals.inline.hpp\"\n@@ -38,2 +40,0 @@\n-#define FOREIGN_ABI \"jdk\/internal\/foreign\/abi\/\"\n-\n@@ -43,12 +43,0 @@\n-#define STACK_TYPE 3\n-\n-template<typename T, typename Func>\n-void loadArray(JNIEnv* env, jfieldID indexField, jobjectArray jarray, jint type_index, GrowableArray<T>& array, Func converter) {\n-    jobjectArray subarray = (jobjectArray) env->GetObjectArrayElement(jarray, type_index);\n-    jint subarray_length = env->GetArrayLength(subarray);\n-    for (jint i = 0; i < subarray_length; i++) {\n-        jobject storage = env->GetObjectArrayElement(subarray, i);\n-        jint index = env->GetIntField(storage, indexField);\n-        array.push(converter(index));\n-    }\n-}\n@@ -56,7 +44,3 @@\n-const ABIDescriptor parseABIDescriptor(JNIEnv* env, jobject jabi) {\n-    jclass jc_ABIDescriptor = env->FindClass(FOREIGN_ABI \"ABIDescriptor\");\n-    jfieldID jfID_inputStorage = env->GetFieldID(jc_ABIDescriptor, \"inputStorage\", \"[[L\" FOREIGN_ABI \"VMStorage;\");\n-    jfieldID jfID_outputStorage = env->GetFieldID(jc_ABIDescriptor, \"outputStorage\", \"[[L\" FOREIGN_ABI \"VMStorage;\");\n-    jfieldID jfID_volatileStorage = env->GetFieldID(jc_ABIDescriptor, \"volatileStorage\", \"[[L\" FOREIGN_ABI \"VMStorage;\");\n-    jfieldID jfID_stackAlignment = env->GetFieldID(jc_ABIDescriptor, \"stackAlignment\", \"I\");\n-    jfieldID jfID_shadowSpace = env->GetFieldID(jc_ABIDescriptor, \"shadowSpace\", \"I\");\n+const ABIDescriptor ForeignGlobals::parseABIDescriptor_impl(jobject jabi) const {\n+  oop abi_oop = JNIHandles::resolve_non_null(jabi);\n+  ABIDescriptor abi;\n@@ -64,2 +48,3 @@\n-    jclass jc_VMStorage = env->FindClass(FOREIGN_ABI \"VMStorage\");\n-    jfieldID jfID_storageIndex = env->GetFieldID(jc_VMStorage, \"index\", \"I\");\n+  objArrayOop inputStorage = cast<objArrayOop>(abi_oop->obj_field(ABI.inputStorage_offset));\n+  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n+  loadArray(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_XMMRegister);\n@@ -67,1 +52,5 @@\n-    ABIDescriptor abi;\n+  objArrayOop outputStorage = cast<objArrayOop>(abi_oop->obj_field(ABI.outputStorage_offset));\n+  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n+  loadArray(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = cast<objArrayOop>(outputStorage->obj_at(X87_TYPE));\n+  abi._X87_return_registers_noof = subarray->length();\n@@ -69,3 +58,3 @@\n-    jobjectArray inputStorage = (jobjectArray) env->GetObjectField(jabi, jfID_inputStorage);\n-    loadArray(env, jfID_storageIndex, inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n-    loadArray(env, jfID_storageIndex, inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_XMMRegister);\n+  objArrayOop volatileStorage = cast<objArrayOop>(abi_oop->obj_field(ABI.volatileStorage_offset));\n+  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n+  loadArray(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_XMMRegister);\n@@ -73,5 +62,2 @@\n-    jobjectArray outputStorage = (jobjectArray) env->GetObjectField(jabi, jfID_outputStorage);\n-    loadArray(env, jfID_storageIndex, outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n-    loadArray(env, jfID_storageIndex, outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_XMMRegister);\n-    jobjectArray subarray = (jobjectArray) env->GetObjectArrayElement(outputStorage, X87_TYPE);\n-    abi._X87_return_registers_noof = env->GetArrayLength(subarray);\n+  abi._stack_alignment_bytes = abi_oop->int_field(ABI.stackAlignment_offset);\n+  abi._shadow_space_bytes = abi_oop->int_field(ABI.shadowSpace_offset);\n@@ -79,3 +65,2 @@\n-    jobjectArray volatileStorage = (jobjectArray) env->GetObjectField(jabi, jfID_volatileStorage);\n-    loadArray(env, jfID_storageIndex, volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n-    loadArray(env, jfID_storageIndex, volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  return abi;\n+}\n@@ -83,2 +68,3 @@\n-    abi._stack_alignment_bytes = env->GetIntField(jabi, jfID_stackAlignment);\n-    abi._shadow_space_bytes = env->GetIntField(jabi, jfID_shadowSpace);\n+const BufferLayout ForeignGlobals::parseBufferLayout_impl(jobject jlayout) const {\n+  oop layout_oop = JNIHandles::resolve_non_null(jlayout);\n+  BufferLayout layout;\n@@ -86,2 +72,14 @@\n-    return abi;\n-}\n+  layout.stack_args_bytes = layout_oop->long_field(BL.stack_args_bytes_offset);\n+  layout.stack_args = layout_oop->long_field(BL.stack_args_offset);\n+  layout.arguments_next_pc = layout_oop->long_field(BL.arguments_next_pc_offset);\n+\n+  typeArrayOop input_offsets = cast<typeArrayOop>(layout_oop->obj_field(BL.input_type_offsets_offset));\n+  layout.arguments_integer = (size_t) input_offsets->long_at(INTEGER_TYPE);\n+  layout.arguments_vector = (size_t) input_offsets->long_at(VECTOR_TYPE);\n+\n+  typeArrayOop output_offsets = cast<typeArrayOop>(layout_oop->obj_field(BL.output_type_offsets_offset));\n+  layout.returns_integer = (size_t) output_offsets->long_at(INTEGER_TYPE);\n+  layout.returns_vector = (size_t) output_offsets->long_at(VECTOR_TYPE);\n+  layout.returns_x87 = (size_t) output_offsets->long_at(X87_TYPE);\n+\n+  layout.buffer_size = layout_oop->long_field(BL.size_offset);\n@@ -89,31 +87,1 @@\n-const BufferLayout parseBufferLayout(JNIEnv* env, jobject jlayout) {\n-    jclass jc_BufferLayout = env->FindClass(FOREIGN_ABI \"BufferLayout\");\n-    jfieldID jfID_size = env->GetFieldID(jc_BufferLayout, \"size\", \"J\");\n-    jfieldID jfID_arguments_next_pc = env->GetFieldID(jc_BufferLayout, \"arguments_next_pc\", \"J\");\n-    jfieldID jfID_stack_args_bytes = env->GetFieldID(jc_BufferLayout, \"stack_args_bytes\", \"J\");\n-    jfieldID jfID_stack_args = env->GetFieldID(jc_BufferLayout, \"stack_args\", \"J\");\n-    jfieldID jfID_input_type_offsets = env->GetFieldID(jc_BufferLayout, \"input_type_offsets\", \"[J\");\n-    jfieldID jfID_output_type_offsets = env->GetFieldID(jc_BufferLayout, \"output_type_offsets\", \"[J\");\n-\n-    BufferLayout layout;\n-\n-    layout.stack_args_bytes = env->GetLongField(jlayout, jfID_stack_args_bytes);\n-    layout.stack_args = env->GetLongField(jlayout, jfID_stack_args);\n-    layout.arguments_next_pc = env->GetLongField(jlayout, jfID_arguments_next_pc);\n-\n-    jlongArray input_offsets = (jlongArray) env->GetObjectField(jlayout, jfID_input_type_offsets);\n-    jlong* input_offsets_prim = env->GetLongArrayElements(input_offsets, NULL);\n-    layout.arguments_integer = (size_t) input_offsets_prim[INTEGER_TYPE];\n-    layout.arguments_vector = (size_t) input_offsets_prim[VECTOR_TYPE];\n-    env->ReleaseLongArrayElements(input_offsets, input_offsets_prim, JNI_ABORT);\n-\n-    jlongArray output_offsets = (jlongArray) env->GetObjectField(jlayout, jfID_output_type_offsets);\n-    jlong* output_offsets_prim = env->GetLongArrayElements(output_offsets, NULL);\n-    layout.returns_integer = (size_t) output_offsets_prim[INTEGER_TYPE];\n-    layout.returns_vector = (size_t) output_offsets_prim[VECTOR_TYPE];\n-    layout.returns_x87 = (size_t) output_offsets_prim[X87_TYPE];\n-    env->ReleaseLongArrayElements(output_offsets, output_offsets_prim, JNI_ABORT);\n-\n-    layout.buffer_size = env->GetLongField(jlayout, jfID_size);\n-\n-    return layout;\n+  return layout;\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":40,"deletions":72,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n@@ -30,0 +27,3 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n@@ -76,3 +76,0 @@\n-const ABIDescriptor parseABIDescriptor(JNIEnv* env, jobject jabi);\n-const BufferLayout parseBufferLayout(JNIEnv* env, jobject jlayout);\n-\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -190,4 +190,3 @@\n-jlong ProgrammableInvoker::generate_adapter(JNIEnv* env, jobject jabi, jobject jlayout) {\n-    ResourceMark rm;\n-    const ABIDescriptor abi = parseABIDescriptor(env, jabi);\n-    const BufferLayout layout = parseBufferLayout(env, jlayout);\n+jlong ProgrammableInvoker::generate_adapter(jobject jabi, jobject jlayout) {\n+  const ABIDescriptor abi = ForeignGlobals::parseABIDescriptor(jabi);\n+  const BufferLayout layout = ForeignGlobals::parseBufferLayout(jlayout);\n@@ -195,1 +194,1 @@\n-    BufferBlob* _invoke_native_blob = BufferBlob::create(\"invoke_native_blob\", native_invoker_size);\n+  BufferBlob* _invoke_native_blob = BufferBlob::create(\"invoke_native_blob\", native_invoker_size);\n@@ -197,4 +196,4 @@\n-    CodeBuffer code2(_invoke_native_blob);\n-    ProgrammableInvokerGenerator g2(&code2, &abi, &layout);\n-    g2.generate();\n-    code2.log_section_sizes(\"InvokeNativeBlob\");\n+  CodeBuffer code2(_invoke_native_blob);\n+  ProgrammableInvokerGenerator g2(&code2, &abi, &layout);\n+  g2.generate();\n+  code2.log_section_sizes(\"InvokeNativeBlob\");\n@@ -202,1 +201,1 @@\n-    return (jlong) _invoke_native_blob->code_begin();\n+  return (jlong) _invoke_native_blob->code_begin();\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -239,3 +239,3 @@\n-jlong ProgrammableUpcallHandler::generate_upcall_stub(JNIEnv *env, jobject rec, jobject jabi, jobject jlayout) {\n-  const ABIDescriptor abi = parseABIDescriptor(env, jabi);\n-  const BufferLayout layout = parseBufferLayout(env, jlayout);\n+jlong ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n+  const ABIDescriptor abi = ForeignGlobals::parseABIDescriptor(jabi);\n+  const BufferLayout layout = ForeignGlobals::parseBufferLayout(jlayout);\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"foreign_globals.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/fieldDescriptor.hpp\"\n+\n+#define FOREIGN_ABI \"jdk\/internal\/foreign\/abi\/\"\n+\n+int ForeignGlobals::field_offset(InstanceKlass* cls, const char* fieldname, Symbol* sigsym) {\n+  Symbol* fieldnamesym = SymbolTable::new_symbol(fieldname, (int)strlen(fieldname));\n+  fieldDescriptor fd;\n+  bool success = cls->find_field(fieldnamesym, sigsym, false, &fd);\n+  assert(success, \"Field not found\");\n+  return fd.offset();\n+}\n+\n+InstanceKlass* ForeignGlobals::find_InstanceKlass(const char* name, TRAPS) {\n+  Symbol* sym = SymbolTable::new_symbol(name, (int)strlen(name));\n+  Klass* k = SystemDictionary::resolve_or_null(sym, Handle(), Handle(), THREAD);\n+  assert(k != nullptr, \"Can not find class: %s\", name);\n+  return InstanceKlass::cast(k);\n+}\n+\n+const ForeignGlobals& ForeignGlobals::instance() {\n+  static ForeignGlobals globals; \/\/ thread-safe lazy init-once (since C++11)\n+  return globals;\n+}\n+\n+const ABIDescriptor ForeignGlobals::parseABIDescriptor(jobject jabi) {\n+  return instance().parseABIDescriptor_impl(jabi);\n+}\n+const BufferLayout ForeignGlobals::parseBufferLayout(jobject jlayout) {\n+  return instance().parseBufferLayout_impl(jlayout);\n+}\n+\n+ForeignGlobals::ForeignGlobals() {\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+\n+  \/\/ ABIDescriptor\n+  InstanceKlass* k_ABI = find_InstanceKlass(FOREIGN_ABI \"ABIDescriptor\", current_thread);\n+  const char* strVMSArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray, (int)strlen(strVMSArray));\n+  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArray);\n+  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArray);\n+  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArray);\n+  ABI.stackAlignment_offset = field_offset(k_ABI, \"stackAlignment\", vmSymbols::int_signature());\n+  ABI.shadowSpace_offset = field_offset(k_ABI, \"shadowSpace\", vmSymbols::int_signature());\n+\n+  \/\/ VMStorage\n+  InstanceKlass* k_VMS = find_InstanceKlass(FOREIGN_ABI \"VMStorage\", current_thread);\n+  VMS.index_offset = field_offset(k_VMS, \"index\", vmSymbols::int_signature());\n+\n+  \/\/ BufferLayout\n+  InstanceKlass* k_BL = find_InstanceKlass(FOREIGN_ABI \"BufferLayout\", current_thread);\n+  BL.size_offset = field_offset(k_BL, \"size\", vmSymbols::long_signature());\n+  BL.arguments_next_pc_offset = field_offset(k_BL, \"arguments_next_pc\", vmSymbols::long_signature());\n+  BL.stack_args_bytes_offset = field_offset(k_BL, \"stack_args_bytes\", vmSymbols::long_signature());\n+  BL.stack_args_offset = field_offset(k_BL, \"stack_args\", vmSymbols::long_signature());\n+  BL.input_type_offsets_offset = field_offset(k_BL, \"input_type_offsets\", vmSymbols::long_array_signature());\n+  BL.output_type_offsets_offset = field_offset(k_BL, \"output_type_offsets\", vmSymbols::long_array_signature());\n+}\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_FOREIGN_GLOBALS\n+#define SHARE_PRIMS_FOREIGN_GLOBALS\n+\n+#include CPU_HEADER(foreign_globals)\n+\n+class ForeignGlobals {\n+private:\n+  struct {\n+    int inputStorage_offset;\n+    int outputStorage_offset;\n+    int volatileStorage_offset;\n+    int stackAlignment_offset;\n+    int shadowSpace_offset;\n+  } ABI;\n+\n+  struct {\n+    int index_offset;\n+  } VMS;\n+\n+  struct {\n+    int size_offset;\n+    int arguments_next_pc_offset;\n+    int stack_args_bytes_offset;\n+    int stack_args_offset;\n+    int input_type_offsets_offset;\n+    int output_type_offsets_offset;\n+  } BL;\n+\n+  ForeignGlobals();\n+\n+  static const ForeignGlobals& instance();\n+\n+  template<typename R>\n+  static R cast(oop theOop);\n+\n+  template<typename T, typename Func>\n+  void loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) const;\n+\n+  int field_offset(InstanceKlass* cls, const char* fieldname, Symbol* sigsym);\n+  InstanceKlass* find_InstanceKlass(const char* name, TRAPS);\n+\n+  const ABIDescriptor parseABIDescriptor_impl(jobject jabi) const;\n+  const BufferLayout parseBufferLayout_impl(jobject jlayout) const;\n+public:\n+  static const ABIDescriptor parseABIDescriptor(jobject jabi);\n+  static const BufferLayout parseBufferLayout(jobject jlayout);\n+};\n+\n+#endif \/\/ SHARE_PRIMS_FOREIGN_GLOBALS\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_FOREIGN_GLOBALS_INLINE_HPP\n+#define SHARE_PRIMS_FOREIGN_GLOBALS_INLINE_HPP\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/foreign_globals.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+\n+template<typename T>\n+static bool check_type(oop theOop) {\n+  static_assert(false, \"No check_type specialization found for this type\");\n+}\n+template<>\n+static bool check_type<objArrayOop>(oop theOop) { return theOop->is_objArray(); }\n+template<>\n+static bool check_type<typeArrayOop>(oop theOop) { return theOop->is_typeArray(); }\n+\n+template<typename R>\n+R ForeignGlobals::cast(oop theOop) {\n+  assert(check_type<R>(theOop), \"Invalid cast\");\n+  return (R) theOop;\n+}\n+\n+template<typename T, typename Func>\n+void ForeignGlobals::loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) const {\n+  objArrayOop subarray = cast<objArrayOop>(jarray->obj_at(type_index));\n+  int subarray_length = subarray->length();\n+  for (int i = 0; i < subarray_length; i++) {\n+    oop storage = subarray->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    array.push(converter(index));\n+  }\n+}\n+\n+#endif \/\/ SHARE_PRIMS_FOREIGN_GLOBALS_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.inline.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -29,2 +29,1 @@\n-JVM_ENTRY(jlong, NEP_vmStorageToVMReg(JNIEnv* env, jclass _unused, jint type, jint index)) {\n-  ThreadToNativeFromVM ttnfvm(thread);\n+JVM_LEAF(jlong, NEP_vmStorageToVMReg(JNIEnv* env, jclass _unused, jint type, jint index))\n@@ -32,1 +31,0 @@\n-}\n@@ -42,9 +40,4 @@\n-JVM_ENTRY(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class)) {\n-  {\n-    ThreadToNativeFromVM ttnfv(thread);\n-\n-    int status = env->RegisterNatives(NEP_class, NEP_methods, sizeof(NEP_methods)\/sizeof(JNINativeMethod));\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n-              \"register jdk.internal.invoke.NativeEntryPoint natives\");\n-  }\n-}\n+JVM_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+  int status = env->RegisterNatives(NEP_class, NEP_methods, sizeof(NEP_methods)\/sizeof(JNINativeMethod));\n+  guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+            \"register jdk.internal.invoke.NativeEntryPoint natives\");\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-JVM_ENTRY(void, PI_invokeNative(JNIEnv* env, jclass _unused, jlong adapter_stub, jlong buff)) {\n+JVM_ENTRY(void, PI_invokeNative(JNIEnv* env, jclass _unused, jlong adapter_stub, jlong buff))\n@@ -48,1 +48,0 @@\n-}\n@@ -51,4 +50,2 @@\n-JVM_ENTRY(jlong, PI_generateAdapter(JNIEnv* env, jclass _unused, jobject abi, jobject layout)) {\n-  ThreadToNativeFromVM ttnfvm(thread);\n-  return ProgrammableInvoker::generate_adapter(env, abi, layout);\n-}\n+JVM_ENTRY(jlong, PI_generateAdapter(JNIEnv* env, jclass _unused, jobject abi, jobject layout))\n+  return ProgrammableInvoker::generate_adapter(abi, layout);\n@@ -59,2 +56,0 @@\n-#define LANG \"Ljava\/lang\/\"\n-\n@@ -64,2 +59,2 @@\n-  {CC \"invokeNative\",          CC \"(JJ)V\",           FN_PTR(PI_invokeNative)},\n-  {CC \"generateAdapter\",       CC \"(\" FOREIGN_ABI \"\/ABIDescriptor;\" FOREIGN_ABI \"\/BufferLayout;\" \")J\",           FN_PTR(PI_generateAdapter)}\n+  {CC \"invokeNative\",    CC \"(JJ)V\",                                                             FN_PTR(PI_invokeNative)   },\n+  {CC \"generateAdapter\", CC \"(\" FOREIGN_ABI \"\/ABIDescriptor;\" FOREIGN_ABI \"\/BufferLayout;\" \")J\", FN_PTR(PI_generateAdapter)}\n@@ -68,9 +63,4 @@\n-JVM_ENTRY(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class)) {\n-  {\n-    ThreadToNativeFromVM ttnfv(thread);\n-\n-    int status = env->RegisterNatives(PI_class, PI_methods, sizeof(PI_methods)\/sizeof(JNINativeMethod));\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n-              \"register jdk.internal.foreign.abi.programmable.ProgrammableInvoker natives\");\n-  }\n-}\n+JVM_LEAF(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+  int status = env->RegisterNatives(PI_class, PI_methods, sizeof(PI_methods)\/sizeof(JNINativeMethod));\n+  guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+            \"register jdk.internal.foreign.abi.programmable.ProgrammableInvoker natives\");\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.cpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include CPU_HEADER(foreign_globals)\n+#include \"prims\/foreign_globals.hpp\"\n@@ -48,1 +48,1 @@\n-  static jlong generate_adapter(JNIEnv* env, jobject abi, jobject layout);\n+  static jlong generate_adapter(jobject abi, jobject layout);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,3 +32,1 @@\n-  ThreadToNativeFromVM ttnfvm(thread);\n-\n-  return ProgrammableUpcallHandler::generate_upcall_stub(env, global_rec, abi, buffer_layout);\n+  return ProgrammableUpcallHandler::generate_upcall_stub(global_rec, abi, buffer_layout);\n@@ -50,9 +48,4 @@\n-JVM_ENTRY(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class)) {\n-  {\n-    ThreadToNativeFromVM ttnfv(thread);\n-\n-    int status = env->RegisterNatives(PUH_class, PUH_methods, sizeof(PUH_methods)\/sizeof(JNINativeMethod));\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n-              \"register jdk.internal.foreign.abi.ProgrammableUpcallHandler natives\");\n-  }\n-}\n+JVM_LEAF(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+  int status = env->RegisterNatives(PUH_class, PUH_methods, sizeof(PUH_methods)\/sizeof(JNINativeMethod));\n+  guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+            \"register jdk.internal.foreign.abi.ProgrammableUpcallHandler natives\");\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include CPU_HEADER(foreign_globals)\n+#include \"prims\/foreign_globals.hpp\"\n@@ -37,1 +37,1 @@\n-  static jlong generate_upcall_stub(JNIEnv *env, jobject rec, jobject abi, jobject buffer_layout);\n+  static jlong generate_upcall_stub(jobject rec, jobject abi, jobject buffer_layout);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,9 +57,4 @@\n-JVM_ENTRY(void, JVM_RegisterUpcallHandlerMethods(JNIEnv *env, jclass UH_class)) {\n-  {\n-    ThreadToNativeFromVM ttnfv(thread);\n-\n-    int status = env->RegisterNatives(UH_class, UH_methods, sizeof(UH_methods)\/sizeof(JNINativeMethod));\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n-              \"register jdk.internal.foreign.abi.UpcallStubs natives\");\n-  }\n-}\n+JVM_LEAF(void, JVM_RegisterUpcallHandlerMethods(JNIEnv *env, jclass UH_class))\n+  int status = env->RegisterNatives(UH_class, UH_methods, sizeof(UH_methods)\/sizeof(JNINativeMethod));\n+  guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+            \"register jdk.internal.foreign.abi.UpcallStubs natives\");\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"}]}