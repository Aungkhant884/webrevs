{"files":[{"patch":"@@ -469,1 +469,1 @@\n-  bool added = SystemDictionaryShared::add_unregistered_class(THREAD, k);\n+  bool added = SystemDictionaryShared::add_unregistered_class_for_static_archive(THREAD, k);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1168,2 +1168,2 @@\n-class LoadedUnregisteredClassesTable : public ResourceHashtable<\n-  Symbol*, bool,\n+class UnregisteredClassesTable : public ResourceHashtable<\n+  Symbol*, InstanceKlass*,\n@@ -1172,1 +1172,1 @@\n-  6661,                             \/\/ prime number\n+  15889, \/\/ prime number\n@@ -1175,1 +1175,1 @@\n-static LoadedUnregisteredClassesTable* _loaded_unregistered_classes = NULL;\n+static UnregisteredClassesTable* _unregistered_classes_table = NULL;\n@@ -1177,6 +1177,9 @@\n-bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* k) {\n-  \/\/ We don't allow duplicated unregistered classes of the same name.\n-  assert(DumpSharedSpaces, \"only when dumping\");\n-  Symbol* name = k->name();\n-  if (_loaded_unregistered_classes == NULL) {\n-    _loaded_unregistered_classes = new (ResourceObj::C_HEAP, mtClass)LoadedUnregisteredClassesTable();\n+bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* klass) {\n+  \/\/ We don't allow duplicated unregistered classes with the same name.\n+  \/\/ We only archive the first class with that name that succeeds putting\n+  \/\/ itself into the table.\n+  Arguments::assert_is_dumping_archive();\n+  MutexLocker ml(current, UnregisteredClassesTable_lock);\n+  Symbol* name = klass->name();\n+  if (_unregistered_classes_table == NULL) {\n+    _unregistered_classes_table = new (ResourceObj::C_HEAP, mtClass)UnregisteredClassesTable();\n@@ -1184,2 +1187,2 @@\n-  bool created = false;\n-  _loaded_unregistered_classes->put_if_absent(name, true, &created);\n+  bool created;\n+  InstanceKlass** v = _unregistered_classes_table->put_if_absent(name, klass, &created);\n@@ -1187,0 +1190,9 @@\n+    name->increment_refcount();\n+  }\n+  return (klass == *v);\n+}\n+\n+\/\/ true == class was successfully added; false == a duplicated class (with the same name) already exists.\n+bool SystemDictionaryShared::add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k) {\n+  assert(DumpSharedSpaces, \"only when dumping\");\n+  if (add_unregistered_class(current, k)) {\n@@ -1189,0 +1201,3 @@\n+    return true;\n+  } else {\n+    return false;\n@@ -1190,1 +1205,0 @@\n-  return created;\n@@ -1298,0 +1312,16 @@\n+void SystemDictionaryShared::handle_class_unloading(InstanceKlass* klass) {\n+  remove_dumptime_info(klass);\n+\n+  if (_unregistered_classes_table != NULL) {\n+    \/\/ Remove the class from _unregistered_classes_table: keep the entry but\n+    \/\/ set it to NULL. This ensure no classes with the same name can be\n+    \/\/ added again.\n+    MutexLocker ml(Thread::current(), UnregisteredClassesTable_lock);\n+    Symbol* name = klass->name();\n+    InstanceKlass** v = _unregistered_classes_table->get(name);\n+    if (v != NULL) {\n+      *v = NULL;\n+    }\n+  }\n+}\n+\n@@ -1479,0 +1509,42 @@\n+class UnregisteredClassesDuplicationChecker : StackObj {\n+  GrowableArray<InstanceKlass*> _list;\n+  Thread* _thread;\n+public:\n+  UnregisteredClassesDuplicationChecker() : _thread(Thread::current()) {}\n+\n+  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+    if (!SystemDictionaryShared::is_builtin(k)) {\n+      _list.append(k);\n+    }\n+    return true;  \/\/ keep on iterating\n+  }\n+\n+  static int compare_by_loader(InstanceKlass** a, InstanceKlass** b) {\n+    ClassLoaderData* loader_a = a[0]->class_loader_data();\n+    ClassLoaderData* loader_b = b[0]->class_loader_data();\n+\n+    if (loader_a != loader_b) {\n+      return intx(loader_a) - intx(loader_b);\n+    } else {\n+      return intx(a[0]) -intx(b[0]);\n+    }\n+  }\n+\n+  void mark_duplicated_classes() {\n+    \/\/ Two loaders may load two identical or similar hierarchies of classes. If we\n+    \/\/ check for duplication in random order, we may end up excluding important base classes\n+    \/\/ in both hierarchies, causing most of the classes to be excluded.\n+    \/\/ We sort the classes by their loaders. This way we're likely to archive\n+    \/\/ all classes in the one of the two hierarchies.\n+    _list.sort(compare_by_loader);\n+    for (int i = 0; i < _list.length(); i++) {\n+      InstanceKlass* k = _list.at(i);\n+      bool i_am_first = SystemDictionaryShared::add_unregistered_class(_thread, k);\n+      if (!i_am_first) {\n+        SystemDictionaryShared::warn_excluded(k, \"Duplicated unregistered class\");\n+        SystemDictionaryShared::set_excluded_locked(k);\n+      }\n+    }\n+  }\n+};\n+\n@@ -1490,0 +1562,10 @@\n+\n+  if (DynamicDumpSharedSpaces) {\n+    \/\/ Do this first -- if a base class is excluded due to duplication,\n+    \/\/ all of its subclasses will also be excluded by ExcludeDumpTimeSharedClasses\n+    ResourceMark rm;\n+    UnregisteredClassesDuplicationChecker dup_checker;\n+    _dumptime_table->iterate(&dup_checker);\n+    dup_checker.mark_duplicated_classes();\n+  }\n+\n@@ -1503,0 +1585,9 @@\n+void SystemDictionaryShared::set_excluded_locked(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeSharedClassInfo* info = find_or_allocate_info_for_locked(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":104,"deletions":13,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-  static bool warn_excluded(InstanceKlass* k, const char* reason);\n@@ -235,0 +234,1 @@\n+  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -268,1 +268,1 @@\n-  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n+  static bool add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k);\n@@ -273,1 +273,1 @@\n-  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n+  static void handle_class_unloading(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -325,0 +325,1 @@\n+  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n@@ -330,0 +331,2 @@\n+  static void set_excluded_locked(InstanceKlass* k);\n+  static bool warn_excluded(InstanceKlass* k, const char* reason);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -686,1 +686,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(this);\n+    SystemDictionaryShared::handle_class_unloading(this);\n@@ -2616,1 +2616,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(ik);\n+    SystemDictionaryShared::handle_class_unloading(ik);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+Mutex*   UnregisteredClassesTable_lock= NULL;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+extern Mutex*   UnregisteredClassesTable_lock;   \/\/ UnregisteredClassesTableTable\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Handling of duplicated classes in dynamic archive with custom loader\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build DuplicatedCustomApp CustomLoadee CustomLoadee2 CustomLoadee3 CustomLoadee3Child\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar DuplicatedCustomApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar custom.jar CustomLoadee\n+ *                  CustomLoadee2 CustomInterface2_ia CustomInterface2_ib\n+ *                  CustomLoadee3 CustomLoadee3Child\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar DuplicatedCustomTest\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class DuplicatedCustomTest extends DynamicArchiveTestBase {\n+    private static final String ARCHIVE_NAME = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(DuplicatedCustomTest::testDefaultBase);\n+    }\n+\n+    private static void testDefaultBase() throws Exception {\n+        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n+        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+        String customJarPath = ClassFileInstaller.getJarPath(\"custom.jar\");\n+        String mainAppClass = \"DuplicatedCustomApp\";\n+        String numberOfLoops = \"2\";\n+\n+        dump(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Written dynamic archive 0x\")\n+                      .shouldContain(\"Skipping CustomLoadee: Duplicated unregistered class\")\n+                      .shouldHaveExitValue(0);\n+                });\n+\n+        run(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds=debug\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"DuplicatedCustomApp source: shared objects file\")\n+                      .shouldContain(\"CustomLoadee source: shared objects file\")\n+                      .shouldHaveExitValue(0);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DuplicatedCustomTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import sun.hotspot.WhiteBox;\n+\n+public class DuplicatedCustomApp {\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static URLClassLoader loaders[];\n+\n+    \/\/ If DuplicatedCustomApp.class is loaded from JAR file, it means we are dumping the\n+    \/\/ dynamic archive.\n+    static boolean is_dynamic_dumping = !wb.isSharedClass(DuplicatedCustomApp.class);\n+    static boolean is_running_with_dynamic_archive = !is_dynamic_dumping;\n+\n+    public static void main(String args[]) throws Exception {\n+        String path = args[0];\n+        URL url = new File(path).toURI().toURL();\n+        URL[] urls = new URL[] {url};\n+        System.out.println(path);\n+        System.out.println(url);\n+\n+        int num_loops = 1;\n+        if (args.length > 1) {\n+            num_loops = Integer.parseInt(args[1]);\n+        }\n+        loaders = new URLClassLoader[num_loops];\n+        for (int i = 0; i < num_loops; i++) {\n+            loaders[i] = new URLClassLoader(urls);\n+        }\n+\n+        if (is_dynamic_dumping) {\n+            \/\/ Try to load the super interfaces of CustomLoadee2 in different orders\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 1) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ia\");\n+            }\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 2) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ib\");\n+            }\n+        }\n+\n+        for (int i = 0; i < num_loops; i++) {\n+            System.out.println(\"============================ LOOP = \" + i);\n+            URLClassLoader urlClassLoader = loaders[i];\n+            test(i, urlClassLoader, \"CustomLoadee\");\n+            test(i, urlClassLoader, \"CustomInterface2_ia\");\n+            test(i, urlClassLoader, \"CustomInterface2_ib\");\n+            test(i, urlClassLoader, \"CustomLoadee2\");\n+            test(i, urlClassLoader, \"CustomLoadee3\");\n+            test(i, urlClassLoader, \"CustomLoadee3Child\");\n+        }\n+    }\n+\n+    private static void test(int i, URLClassLoader urlClassLoader, String name) throws Exception {\n+        Class c = urlClassLoader.loadClass(name);\n+        try {\n+            c.newInstance(); \/\/ make sure the class is linked so it can be archived\n+        } catch (Throwable t) {}\n+        boolean is_shared = wb.isSharedClass(c);\n+\n+        System.out.println(\"Class = \" + c + \", loaded from \" + (is_shared ? \"CDS\" : \"Jar\"));\n+        System.out.println(\"Loader = \" + c.getClassLoader());\n+\n+        \/\/ [1] Check that CustomLoadee is defined by the correct loader\n+        if (c.getClassLoader() != urlClassLoader) {\n+            throw new RuntimeException(\"c.getClassLoader() == \" + c.getClassLoader() +\n+                                       \", expected == \" + urlClassLoader);\n+        }\n+\n+        if (is_running_with_dynamic_archive) {\n+            \/\/ There's only one copy of the shared class of <name> in the\n+            \/\/ CDS archive.\n+            if (i == 0) {\n+                \/\/ The first time we must be able to load it from CDS.\n+                if (!is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from CDS\");\n+                }\n+            } else {\n+                \/\/ All subsequent times, we must load this from JAR file.\n+                if (is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from JAR\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/DuplicatedCustomApp.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}