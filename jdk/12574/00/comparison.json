{"files":[{"patch":"@@ -65,0 +65,1 @@\n+import com.sun.tools.javac.util.ByteBuffer.UnderflowException;\n@@ -332,1 +333,6 @@\n-        char res = buf.getChar(bp);\n+        char res;\n+        try {\n+            res = buf.getChar(bp);\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -340,1 +346,5 @@\n-        return buf.getByte(bp++) & 0xFF;\n+        try {\n+            return buf.getByte(bp++) & 0xFF;\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -346,1 +356,6 @@\n-        int res = buf.getInt(bp);\n+        int res;\n+        try {\n+            res = buf.getInt(bp);\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -1485,1 +1500,6 @@\n-        int numParameters = buf.getByte(bp++) & 0xFF;\n+        int numParameters;\n+        try {\n+            numParameters = buf.getByte(bp++) & 0xFF;\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -1774,1 +1794,6 @@\n-        char c = (char) buf.getByte(bp++);\n+        char c;\n+        try {\n+            c = (char)buf.getByte(bp++);\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.util.ByteBuffer.UnderflowException;\n@@ -135,2 +136,7 @@\n-    char nextChar() {\n-        char res = buf.getChar(bp);\n+    char nextChar() throws BadClassFile {\n+        char res;\n+        try {\n+            res = buf.getChar(bp);\n+        } catch (UnderflowException e) {\n+            throw new BadClassFile(\"class file truncated at offset \" + e.getLength());\n+        }\n@@ -143,2 +149,7 @@\n-    int nextInt() {\n-        int res = buf.getInt(bp);\n+    int nextInt() throws BadClassFile {\n+        int res;\n+        try {\n+            res = buf.getInt(bp);\n+        } catch (UnderflowException e) {\n+            throw new BadClassFile(\"class file truncated at offset \" + e.getLength());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ModuleNameReader.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.tools.javac.util.ByteBuffer.UnderflowException;\n@@ -121,1 +122,1 @@\n-        return peekName(buf.getChar(pool.offset(index)), mapper);\n+        return peekItemName(index, mapper);\n@@ -128,1 +129,1 @@\n-        return peekName(buf.getChar(pool.offset(index)), mapper);\n+        return peekItemName(index, mapper);\n@@ -135,1 +136,10 @@\n-        return peekName(buf.getChar(pool.offset(index)), mapper);\n+        return peekItemName(index, mapper);\n+    }\n+\n+    private <Z> Z peekItemName(int index, NameMapper<Z> mapper) {\n+        try {\n+            index = buf.getChar(pool.offset(index));\n+        } catch (UnderflowException e) {\n+            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n+        return peekName(index, mapper);\n@@ -156,1 +166,5 @@\n-        return getUtf8(index, mapper);\n+        try {\n+            return getUtf8(index, mapper);\n+        } catch (UnderflowException e) {\n+            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -191,1 +205,1 @@\n-    private <Z> Z getUtf8(int index, NameMapper<Z> mapper) {\n+    private <Z> Z getUtf8(int index, NameMapper<Z> mapper) throws UnderflowException {\n@@ -204,1 +218,1 @@\n-    private Object resolve(ByteBuffer poolbuf, int tag, int offset) {\n+    private Object resolve(ByteBuffer poolbuf, int tag, int offset) throws UnderflowException {\n@@ -253,0 +267,8 @@\n+        try {\n+            return readPoolInternal(poolbuf, offset);\n+        } catch (UnderflowException e) {\n+            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n+    }\n+\n+    private int readPoolInternal(ByteBuffer poolbuf, int offset) throws UnderflowException {\n@@ -346,1 +368,6 @@\n-                P p = (P)resolve(poolbuf, tag(index), offset(index));\n+                P p;\n+                try {\n+                    p = (P)resolve(poolbuf, tag(index), offset(index));\n+                } catch (UnderflowException e) {\n+                    throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolReader.java","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2434,0 +2434,3 @@\n+compiler.misc.bad.class.truncated.at.offset=\\\n+    class file truncated at offset {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,5 @@\n-        while (currentLength < maxIndex + 1)\n+        if (currentLength == 0)\n+            currentLength++;                    \/\/ avoid infinite loop\n+        if (maxIndex == Integer.MAX_VALUE)\n+            maxIndex--;                         \/\/ avoid negative overflow\n+        while (currentLength < maxIndex + 1) {\n@@ -40,0 +44,5 @@\n+            if (currentLength < 0) {            \/\/ avoid negative overflow\n+                currentLength = maxIndex + 1;\n+                break;\n+            }\n+        }\n@@ -43,0 +52,9 @@\n+    \/**\n+     * Ensure the given array has length at least {@code maxIndex + 1}.\n+     *\n+     * @param array original array\n+     * @param maxIndex exclusive lower bound for desired length\n+     * @return possibly reallocated array of length at least {@code maxIndex + 1}\n+     * @throws NullPointerException if {@code array} is null\n+     * @throws IllegalArgumentException if {@code maxIndex} is negative\n+     *\/\n@@ -44,0 +62,2 @@\n+        if (maxIndex < 0)\n+            throw new IllegalArgumentException(\"maxIndex=\" + maxIndex);\n@@ -55,0 +75,9 @@\n+    \/**\n+     * Ensure the given array has length at least {@code maxIndex + 1}.\n+     *\n+     * @param array original array\n+     * @param maxIndex exclusive lower bound for desired length\n+     * @return possibly reallocated array of length at least {@code maxIndex + 1}\n+     * @throws NullPointerException if {@code array} is null\n+     * @throws IllegalArgumentException if {@code maxIndex} is negative\n+     *\/\n@@ -56,0 +85,2 @@\n+        if (maxIndex < 0)\n+            throw new IllegalArgumentException(\"maxIndex=\" + maxIndex);\n@@ -66,0 +97,9 @@\n+    \/**\n+     * Ensure the given array has length at least {@code maxIndex + 1}.\n+     *\n+     * @param array original array\n+     * @param maxIndex exclusive lower bound for desired length\n+     * @return possibly reallocated array of length at least {@code maxIndex + 1}\n+     * @throws NullPointerException if {@code array} is null\n+     * @throws IllegalArgumentException if {@code maxIndex} is negative\n+     *\/\n@@ -67,0 +107,2 @@\n+        if (maxIndex < 0)\n+            throw new IllegalArgumentException(\"maxIndex=\" + maxIndex);\n@@ -77,0 +119,9 @@\n+    \/**\n+     * Ensure the given array has length at least {@code maxIndex + 1}.\n+     *\n+     * @param array original array\n+     * @param maxIndex exclusive lower bound for desired length\n+     * @return possibly reallocated array of length at least {@code maxIndex + 1}\n+     * @throws NullPointerException if {@code array} is null\n+     * @throws IllegalArgumentException if {@code maxIndex} is negative\n+     *\/\n@@ -78,0 +129,2 @@\n+        if (maxIndex < 0)\n+            throw new IllegalArgumentException(\"maxIndex=\" + maxIndex);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/ArrayUtils.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-     \/** Append the content of a given input stream.\n+     \/** Append the content of a given input stream, and then close the stream.\n@@ -153,19 +153,21 @@\n-        try {\n-            int start = length;\n-            int initialSize = is.available();\n-            elems = ArrayUtils.ensureCapacity(elems, length + initialSize);\n-            int r = is.read(elems, start, initialSize);\n-            int bp = start;\n-            while (r != -1) {\n-                bp += r;\n-                elems = ArrayUtils.ensureCapacity(elems, bp);\n-                r = is.read(elems, bp, elems.length - bp);\n-            }\n-        } finally {\n-            try {\n-                is.close();\n-            } catch (IOException e) {\n-                \/* Ignore any errors, as this stream may have already\n-                 * thrown a related exception which is the one that\n-                 * should be reported.\n-                 *\/\n+        try (InputStream input = is) {\n+            while (true) {\n+\n+                \/\/ Read another chunk of data, using size hint from available().\n+                \/\/ If available() is accurate, the array size should be just right.\n+                int amountToRead = Math.max(input.available(), 64);\n+                elems = ArrayUtils.ensureCapacity(elems, length + amountToRead);\n+                int amountRead = input.read(elems, length, amountToRead);\n+                if (amountRead == -1)\n+                    break;\n+                length += amountRead;\n+\n+                \/\/ Check for the common case where input.available() returned the\n+                \/\/ entire remaining input; in that case, avoid an extra array extension.\n+                \/\/ Note we are guaranteed that elems.length >= length + 1 at this point.\n+                if (amountRead == amountToRead) {\n+                    int byt = input.read();\n+                    if (byt == -1)\n+                        break;\n+                    elems[length++] = (byte)byt;\n+                }\n@@ -177,0 +179,4 @@\n+     *\n+     * @param bp starting offset\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code bp} is negative\n@@ -178,1 +184,2 @@\n-    public int getInt(int bp) {\n+    public int getInt(int bp) throws UnderflowException {\n+        verifyRange(bp, 4);\n@@ -188,0 +195,4 @@\n+     *\n+     * @param bp starting offset\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code bp} is negative\n@@ -189,1 +200,2 @@\n-    public long getLong(int bp) {\n+    public long getLong(int bp) throws UnderflowException {\n+        verifyRange(bp, 8);\n@@ -200,0 +212,4 @@\n+     *\n+     * @param bp starting offset\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code bp} is negative\n@@ -201,1 +217,2 @@\n-    public float getFloat(int bp) {\n+    public float getFloat(int bp) throws UnderflowException {\n+        verifyRange(bp, 4);\n@@ -212,0 +229,4 @@\n+     *\n+     * @param bp starting offset\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code bp} is negative\n@@ -213,1 +234,2 @@\n-    public double getDouble(int bp) {\n+    public double getDouble(int bp) throws UnderflowException {\n+        verifyRange(bp, 8);\n@@ -224,0 +246,4 @@\n+     *\n+     * @param bp starting offset\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code bp} is negative\n@@ -225,1 +251,2 @@\n-    public char getChar(int bp) {\n+    public char getChar(int bp) throws UnderflowException {\n+        verifyRange(bp, 2);\n@@ -230,1 +257,8 @@\n-    public byte getByte(int bp) {\n+    \/** Extract a byte at position bp from elems.\n+     *\n+     * @param bp starting offset\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code bp} is negative\n+     *\/\n+    public byte getByte(int bp) throws UnderflowException {\n+        verifyRange(bp, 1);\n@@ -245,0 +279,35 @@\n+\n+    \/** Verify there are at least the specified number of bytes in this buffer at the specified offset.\n+     *\n+     * @param off starting offset\n+     * @param len required length\n+     * @throws UnderflowException if there is not enough data in this buffer\n+     * @throws IllegalArgumentException if {@code off} or {@code len} is negative\n+     *\/\n+    public void verifyRange(int off, int len) throws UnderflowException {\n+        if (off < 0 || len < 0)\n+            throw new IllegalArgumentException(\"off=\" + off + \", len=\" + len);\n+        if (off + len < 0 || off + len > length)\n+            throw new UnderflowException(length);\n+    }\n+\n+\/\/ UnderflowException\n+\n+    \/** Thrown when trying to read past the end of the buffer.\n+     *\/\n+    public static class UnderflowException extends Exception {\n+\n+        private static final long serialVersionUID = 0;\n+\n+        private final int length;\n+\n+        public UnderflowException(int length) {\n+            this.length = length;\n+        }\n+\n+        \/** Get the length of the buffer, which apparently is not long enough.\n+         *\/\n+        public int getLength() {\n+            return length;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/ByteBuffer.java","additions":95,"deletions":26,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302514\n+ * @summary Verify truncated class files are detected and reported as truncated\n+ *\/\n+\n+import com.sun.tools.javac.Main;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+\n+public class TruncatedClassFileTest {\n+\n+    \/\/ We want a bunch of stuff in this file to make the classfile complicated\n+    private static final String A_SOURCE = \"\"\"\n+        public class ClassA {\n+            public static final boolean z = true;\n+            public static final byte b = 7;\n+            public static final char c = '*';\n+            public static final short s = -12;\n+            public static final int i = 123;\n+            public static final float f = 123f;\n+            public static final long j = 0x1234567812345678L;\n+            public static final double d = Math.PI;\n+            public static final String str = new String(\"test123\");\n+            @SuppressWarnings(\"blah\")\n+            public ClassA() {\n+                new Thread();\n+            }\n+        }\n+    \"\"\";\n+\n+    \/\/ This file will get compiled against a trunctated version of A.class\n+    private static final String B_SOURCE = \"\"\"\n+        public class ClassB {\n+            public ClassB() {\n+                new ClassA();\n+            }\n+        }\n+    \"\"\";\n+\n+    private static final File A_SOURCE_FILE = new File(\"ClassA.java\");\n+    private static final File B_SOURCE_FILE = new File(\"ClassB.java\");\n+    private static final File A_CLASS_FILE = new File(\"ClassA.class\");\n+\n+    private static void createSourceFile(File file, String content) throws IOException {\n+        try (PrintStream output = new PrintStream(new FileOutputStream(file))) {\n+            output.println(content);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+\n+        \/\/ Create A.java and B.java\n+        createSourceFile(A_SOURCE_FILE, A_SOURCE);\n+        createSourceFile(B_SOURCE_FILE, B_SOURCE);\n+\n+        \/\/ Compile A.java\n+        createSourceFile(A_SOURCE_FILE, A_SOURCE);\n+        int ret = Main.compile(new String[] { A_SOURCE_FILE.toString() });\n+        if (ret != 0)\n+            throw new AssertionError(\"compilation of \" + A_SOURCE_FILE + \" failed\");\n+        A_SOURCE_FILE.delete();\n+\n+        \/\/ Read A.class\n+        final byte[] classfile = Files.readAllBytes(A_CLASS_FILE.toPath());\n+\n+        \/\/ Now compile B.java with truncated versions of A.class\n+        for (int length = 0; length < classfile.length; length++) {\n+\n+            \/\/ Write out truncated class file A.class\n+            try (FileOutputStream output = new FileOutputStream(A_CLASS_FILE)) {\n+                output.write(classfile, 0, length);\n+            }\n+\n+            \/\/ Try to compile file B.java\n+            final StringWriter diags = new StringWriter();\n+            final String[] params = new String[] {\n+                \"-classpath\",\n+                \".\",\n+                \"-XDrawDiagnostics\",\n+                B_SOURCE_FILE.toString()\n+            };\n+            ret = Main.compile(params, new PrintWriter(diags, true));\n+            if (ret == 0)\n+                throw new AssertionError(\"compilation with truncated class file (\" + length + \") succeeded?\");\n+            final String errmsg = \"compiler.misc.bad.class.truncated.at.offset: \" + length;\n+            if (!diags.toString().contains(errmsg))\n+                throw new AssertionError(\"error message not found for truncated class file (\" + length + \"): \" + diags);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/classreader\/TruncatedClassFileTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -48,0 +48,1 @@\n+compiler.misc.bad.class.truncated.at.offset             # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-                \"- compiler.err.cant.access: <error>.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.illegal.start.of.class.file))\",\n+                \"- compiler.err.cant.access: <error>.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.bad.class.truncated.at.offset: 0))\",\n","filename":"test\/langtools\/tools\/javac\/modules\/EdgeCases.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-                \"Test.java:1:57: compiler.err.cant.access: test.Broken, (compiler.misc.bad.class.file.header: Broken.class, (compiler.misc.class.file.wrong.class: java.lang.AutoCloseable))\",\n+                \"Test.java:1:57: compiler.err.cant.access: test.Broken, (compiler.misc.bad.class.file.header: Broken.class, (compiler.misc.bad.class.truncated.at.offset: 0))\",\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/completionfailure\/NoAbortForBadClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}