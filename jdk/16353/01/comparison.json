{"files":[{"patch":"@@ -819,1 +819,1 @@\n-  friend class SuperWord;\n+  friend class Vectorizer;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,3 +47,1 @@\n-  _phase(phase),\n-  _arena(phase->C->comp_arena()),\n-  _igvn(phase->_igvn),\n+  Vectorizer(phase),\n@@ -51,3 +49,0 @@\n-  _bb_idx(arena(), (int)(1.10 * phase->C->unique()), 0, 0), \/\/ node idx to index in bb\n-  _block(arena(), 8,  0, nullptr),                          \/\/ nodes in current block\n-  _data_entry(arena(), 8,  0, nullptr),                     \/\/ nodes with all inputs from outside\n@@ -60,3 +55,1 @@\n-  _dg(_arena),                                              \/\/ dependence graph\n-  _visited(arena()),                                        \/\/ visited node set\n-  _post_visited(arena()),                                   \/\/ post visited node set\n+  _dg(arena()),                                             \/\/ dependence graph\n@@ -65,3 +58,0 @@\n-  _stk(arena(), 8, 0, nullptr),                             \/\/ scratch stack of nodes\n-  _lpt(nullptr),                                            \/\/ loop tree node\n-  _lp(nullptr),                                             \/\/ CountedLoopNode\n@@ -69,2 +59,0 @@\n-  _bb(nullptr),                                             \/\/ basic block\n-  _iv(nullptr),                                             \/\/ induction var\n@@ -76,9 +64,1 @@\n-{\n-#ifndef PRODUCT\n-  _vector_loop_debug = 0;\n-  if (_phase->C->method() != nullptr) {\n-    _vector_loop_debug = phase->C->directive()->VectorizeDebugOption;\n-  }\n-\n-#endif\n-}\n+{}\n@@ -88,1 +68,1 @@\n-  assert(_phase->C->do_superword(), \"SuperWord option should be enabled\");\n+  assert(phase()->C->do_superword(), \"SuperWord option should be enabled\");\n@@ -102,5 +82,1 @@\n-  \/\/ Initialize simple data used by reduction marking early.\n-  set_lpt(lpt);\n-  set_lp(cl);\n-  \/\/ For now, define one block which is the entire loop body.\n-  set_bb(cl);\n+  initialize_loop_info(lpt);\n@@ -172,1 +148,1 @@\n-void SuperWord::unrolling_analysis(int &local_loop_unroll_factor) {\n+void SuperWord::unrolling_analysis(int& local_loop_unroll_factor) {\n@@ -175,1 +151,1 @@\n-  int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);\n+  int* ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);\n@@ -177,2 +153,1 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  Node *cl_exit = cl->loopexit_or_null();\n+  Node* cl_exit = cl()->loopexit_or_null();\n@@ -191,1 +166,1 @@\n-    if (n == cl->incr() ||\n+    if (n == cl()->incr() ||\n@@ -250,1 +225,1 @@\n-      Node* n_ctrl = _phase->get_ctrl(adr);\n+      Node* n_ctrl = phase()->get_ctrl(adr);\n@@ -253,1 +228,1 @@\n-      if (n_ctrl != nullptr && lpt()->is_member(_phase->get_loop(n_ctrl))) {\n+      if (n_ctrl != nullptr && lpt()->is_member(phase()->get_loop(n_ctrl))) {\n@@ -328,1 +303,1 @@\n-              if (!in->is_Mem() && in_bb(in) && in->bottom_type()->basic_type() == T_INT) {\n+              if (!in->is_Mem() && in_loopbody(in) && in->bottom_type()->basic_type() == T_INT) {\n@@ -332,1 +307,1 @@\n-                  if (!in_bb(use) && use->bottom_type()->basic_type() != bt) {\n+                  if (!in_loopbody(use) && use->bottom_type()->basic_type() != bt) {\n@@ -340,1 +315,1 @@\n-                  cl->mark_subword_loop();\n+                  cl()->mark_subword_loop();\n@@ -350,1 +325,1 @@\n-      cl->mark_passed_slp();\n+      cl()->mark_passed_slp();\n@@ -352,3 +327,3 @@\n-    cl->mark_was_slp();\n-    if (cl->is_main_loop()) {\n-      cl->set_slp_max_unroll(local_loop_unroll_factor);\n+    cl()->mark_was_slp();\n+    if (cl()->is_main_loop()) {\n+      cl()->set_slp_max_unroll(local_loop_unroll_factor);\n@@ -413,2 +388,2 @@\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    const Node* phi = lp()->fast_out(i);\n+  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n+    const Node* phi = cl()->fast_out(i);\n@@ -446,1 +421,1 @@\n-          [&](const Node* n) { return n->Opcode() == first->Opcode() && in_bb(n); },\n+          [&](const Node* n) { return n->Opcode() == first->Opcode() && in_loopbody(n); },\n@@ -465,1 +440,1 @@\n-        if (!in_bb(u)) {\n+        if (!in_loopbody(u)) {\n@@ -532,4 +507,4 @@\n-    _lpt->dump_head();\n-    _lpt->dump();\n-    for (uint i = 0; i < _lpt->_body.size(); i++) {\n-      _lpt->_body.at(i)->dump();\n+    lpt()->dump_head();\n+    lpt()->dump();\n+    for (uint i = 0; i < lpt()->_body.size(); i++) {\n+      lpt()->_body.at(i)->dump();\n@@ -540,2 +515,1 @@\n-  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n@@ -587,3 +561,3 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n-    if (n->is_Mem() && !n->is_LoadStore() && in_bb(n) &&\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    Node* n = _body_nodes.at(i);\n+    if (n->is_Mem() && !n->is_LoadStore() && in_loopbody(n) &&\n@@ -922,1 +896,1 @@\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  CountedLoopEndNode* pre_end = cl()->pre_loop_end();\n@@ -1054,2 +1028,1 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n@@ -1058,2 +1031,2 @@\n-  for (int i = 0; i < _block.length(); i++ ) {\n-    Node *n = _block.at(i);\n+  for (int i = 0; i < _body_nodes.length(); i++ ) {\n+    Node* n = _body_nodes.at(i);\n@@ -1153,1 +1126,1 @@\n-    assert(in_bb(n), \"must be in block\");\n+    assert(in_loopbody(n), \"must be in block\");\n@@ -1157,1 +1130,1 @@\n-        if (in_bb(out)) {\n+        if (in_loopbody(out)) {\n@@ -1165,1 +1138,1 @@\n-        if (out->is_MergeMem() && !in_bb(out)) {\n+        if (out->is_MergeMem() && !in_loopbody(out)) {\n@@ -1168,1 +1141,1 @@\n-        } else if (out->is_memory_phi() && !in_bb(out)) {\n+        } else if (out->is_memory_phi() && !in_loopbody(out)) {\n@@ -1239,1 +1212,1 @@\n-  if (!in_bb(s1)    || !in_bb(s2))    return false;\n+  if (!in_loopbody(s1) || !in_loopbody(s2)) return false;\n@@ -1320,3 +1293,3 @@\n-  visited_clear();\n-\n-  return independent_path(shallow, deep);\n+  ResourceMark rm;\n+  VectorSet visited;\n+  return independent_path(visited, shallow, deep);\n@@ -1341,1 +1314,1 @@\n-  visited_clear();\n+  VectorSet visited;\n@@ -1346,1 +1319,1 @@\n-    visited_set(n); \/\/ mark node\n+    visited.set(bb_idx(n)); \/\/ mark node\n@@ -1352,2 +1325,2 @@\n-      if (in_bb(pred) && depth(pred) >= min_d) {\n-        if (visited_test(pred)) { \/\/ marked as in p?\n+      if (in_loopbody(pred) && depth(pred) >= min_d) {\n+        if (visited.test(bb_idx(pred))) { \/\/ marked as in p?\n@@ -1410,1 +1383,1 @@\n-bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {\n+bool SuperWord::independent_path(VectorSet& visited, Node* shallow, Node* deep, uint dp) {\n@@ -1412,1 +1385,1 @@\n-  visited_set(deep);\n+  visited.set(bb_idx(deep));\n@@ -1417,1 +1390,1 @@\n-    if (in_bb(pred) && !visited_test(pred)) {\n+    if (in_loopbody(pred) && !visited.test(bb_idx(pred))) {\n@@ -1421,1 +1394,1 @@\n-      if (shal_depth < depth(pred) && !independent_path(shallow, pred, dp+1)) {\n+      if (shal_depth < depth(pred) && !independent_path(visited, shallow, pred, dp+1)) {\n@@ -1508,1 +1481,1 @@\n-    if (!in_bb(t1) || !in_bb(t2) || t1->is_Mem() || t2->is_Mem())  {\n+    if (!in_loopbody(t1) || !in_loopbody(t2) || t1->is_Mem() || t2->is_Mem()) {\n@@ -1549,1 +1522,1 @@\n-    if (!in_bb(t1) || t1->is_Mem()) {\n+    if (!in_loopbody(t1) || t1->is_Mem()) {\n@@ -1555,1 +1528,1 @@\n-      if (!in_bb(t2) || t2->is_Mem()) {\n+      if (!in_loopbody(t2) || t2->is_Mem()) {\n@@ -1559,1 +1532,1 @@\n-      if (t2->Opcode() == Op_AddI && t2 == _lp->as_CountedLoop()->incr()) continue; \/\/ don't mess with the iv\n+      if (t2->Opcode() == Op_AddI && t2 == cl()->as_CountedLoop()->incr()) continue; \/\/ don't mess with the iv\n@@ -1875,1 +1848,1 @@\n-      if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n+      if ((TraceSuperWord && Verbose) || Vectorizer::vector_loop_debug()) {\n@@ -1899,1 +1872,1 @@\n-        if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n+        if ((TraceSuperWord && Verbose) || Vectorizer::vector_loop_debug()) {\n@@ -2049,2 +2022,2 @@\n-                ((use->is_Phi() && use->in(0) == _lpt->_head) ||\n-                 (!_lpt->is_member(_phase->get_loop(_phase->ctrl_or_self(use))) && i == p->size()-1))) {\n+                ((use->is_Phi() && use->in(0) == lpt()->_head) ||\n+                 (!lpt()->is_member(phase()->get_loop(phase()->ctrl_or_self(use))) && i == p->size()-1))) {\n@@ -2122,1 +2095,1 @@\n-      assert(in_bb(n), \"only nodes in bb can be in packset\");\n+      assert(in_loopbody(n), \"only nodes in bb can be in packset\");\n@@ -2130,2 +2103,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    Node* n = _body_nodes.at(i);\n@@ -2174,1 +2147,1 @@\n-    if (!_slp->in_bb(n)) {\n+    if (!_slp->in_loopbody(n)) {\n@@ -2191,1 +2164,1 @@\n-    assert(_slp->in_bb(n), \"must be\");\n+    assert(_slp->in_loopbody(n), \"must be\");\n@@ -2418,1 +2391,1 @@\n-  int max_slices = _phase->C->num_alias_types();\n+  int max_slices = phase()->C->num_alias_types();\n@@ -2430,1 +2403,1 @@\n-    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n@@ -2443,1 +2416,1 @@\n-    int alias_idx = _phase->C->get_alias_index(n->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(n->adr_type());\n@@ -2449,1 +2422,1 @@\n-      assert(n->is_Load() && !in_bb(n->in(MemNode::Memory)),\n+      assert(n->is_Load() && !in_loopbody(n->in(MemNode::Memory)),\n@@ -2452,1 +2425,1 @@\n-      _igvn.replace_input_of(n, MemNode::Memory, current_state);\n+      igvn()->replace_input_of(n, MemNode::Memory, current_state);\n@@ -2465,1 +2438,1 @@\n-    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n@@ -2470,1 +2443,1 @@\n-    _igvn.replace_input_of(phi, 2, current_state);\n+    igvn()->replace_input_of(phi, 2, current_state);\n@@ -2480,1 +2453,1 @@\n-      if (!in_bb(use)) {\n+      if (!in_loopbody(use)) {\n@@ -2489,1 +2462,1 @@\n-          _igvn.replace_input_of(use, j, current_state);\n+          igvn()->replace_input_of(use, j, current_state);\n@@ -2504,3 +2477,2 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n-  Compile* C = _phase->C;\n+  assert(cl()->is_main_loop(), \"SLP should only work on main loops\");\n+  Compile* C = phase()->C;\n@@ -2530,2 +2502,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    Node* n = _body_nodes.at(i);\n@@ -2684,1 +2656,1 @@\n-        ConINode* bol_test_node  = _igvn.intcon((int)bol_test);\n+        ConINode* bol_test_node  = igvn()->intcon((int)bol_test);\n@@ -2688,3 +2660,3 @@\n-        _igvn.register_new_node_with_optimizer(mask);\n-        _phase->set_ctrl(mask, _phase->get_ctrl(p->at(0)));\n-        _igvn._worklist.push(mask);\n+        igvn()->register_new_node_with_optimizer(mask);\n+        phase()->set_ctrl(mask, phase()->get_ctrl(p->at(0)));\n+        igvn()->_worklist.push(mask);\n@@ -2763,2 +2735,2 @@\n-        _igvn.register_new_node_with_optimizer(longval);\n-        _phase->set_ctrl(longval, _phase->get_ctrl(first));\n+        igvn()->register_new_node_with_optimizer(longval);\n+        phase()->set_ctrl(longval, phase()->get_ctrl(first));\n@@ -2793,3 +2765,3 @@\n-      _block.at_put(i, vn);\n-      _igvn.register_new_node_with_optimizer(vn);\n-      _phase->set_ctrl(vn, _phase->get_ctrl(first));\n+      _body_nodes.at_put(i, vn);\n+      igvn()->register_new_node_with_optimizer(vn);\n+      phase()->set_ctrl(vn, phase()->get_ctrl(first));\n@@ -2798,1 +2770,1 @@\n-        _igvn.replace_node(pm, vn);\n+        igvn()->replace_node(pm, vn);\n@@ -2800,1 +2772,1 @@\n-      _igvn._worklist.push(vn);\n+      igvn()->_worklist.push(vn);\n@@ -2810,1 +2782,1 @@\n-  }\/\/for (int i = 0; i < _block.length(); i++)\n+  } \/\/ for (int i = 0; i < _body_nodes.length(); i++)\n@@ -2816,1 +2788,1 @@\n-    cl->mark_loop_vectorized();\n+    cl()->mark_loop_vectorized();\n@@ -2820,2 +2792,2 @@\n-    if (cl->has_passed_slp()) {\n-      uint slp_max_unroll_factor = cl->slp_max_unroll();\n+    if (cl()->has_passed_slp()) {\n+      uint slp_max_unroll_factor = cl()->slp_max_unroll();\n@@ -2827,1 +2799,1 @@\n-        cl->set_notpassed_slp();\n+        cl()->set_notpassed_slp();\n@@ -2831,1 +2803,1 @@\n-          cl->mark_do_unroll_only();\n+          cl()->mark_do_unroll_only();\n@@ -2846,1 +2818,0 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n@@ -2858,1 +2829,1 @@\n-    Node* vn = new PopulateIndexNode(iv(), _igvn.intcon(1), vt);\n+    Node* vn = new PopulateIndexNode(iv(), igvn()->intcon(1), vt);\n@@ -2860,2 +2831,2 @@\n-    _igvn.register_new_node_with_optimizer(vn);\n-    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    igvn()->register_new_node_with_optimizer(vn);\n+    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n@@ -2882,1 +2853,1 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          igvn()->register_new_node_with_optimizer(cnt);\n@@ -2887,1 +2858,1 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          igvn()->register_new_node_with_optimizer(cnt);\n@@ -2889,2 +2860,2 @@\n-          _igvn.register_new_node_with_optimizer(cnt);\n-          _phase->set_ctrl(cnt, _phase->get_ctrl(opd));\n+          igvn()->register_new_node_with_optimizer(cnt);\n+          phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n@@ -2899,2 +2870,2 @@\n-      _igvn.register_new_node_with_optimizer(cnt);\n-      _phase->set_ctrl(cnt, _phase->get_ctrl(opd));\n+      igvn()->register_new_node_with_optimizer(cnt);\n+      phase()->set_ctrl(cnt, phase()->get_ctrl(opd));\n@@ -2918,2 +2889,2 @@\n-         _igvn.register_new_node_with_optimizer(conv);\n-         _phase->set_ctrl(conv, _phase->get_ctrl(opd));\n+         igvn()->register_new_node_with_optimizer(conv);\n+         phase()->set_ctrl(conv, phase()->get_ctrl(opd));\n@@ -2927,2 +2898,2 @@\n-    _igvn.register_new_node_with_optimizer(vn);\n-    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    igvn()->register_new_node_with_optimizer(vn);\n+    phase()->set_ctrl(vn, phase()->get_ctrl(opd));\n@@ -2957,2 +2928,2 @@\n-  _igvn.register_new_node_with_optimizer(pk);\n-  _phase->set_ctrl(pk, _phase->get_ctrl(opd));\n+  igvn()->register_new_node_with_optimizer(pk);\n+  phase()->set_ctrl(pk, phase()->get_ctrl(opd));\n@@ -2998,1 +2969,1 @@\n-    _igvn.hash_delete(def);\n+    igvn()->hash_delete(def);\n@@ -3001,1 +2972,1 @@\n-    ConINode* def_pos_con = _igvn.intcon(def_pos)->as_ConI();\n+    ConINode* def_pos_con = igvn()->intcon(def_pos)->as_ConI();\n@@ -3003,4 +2974,4 @@\n-    _igvn.register_new_node_with_optimizer(ex);\n-    _phase->set_ctrl(ex, _phase->get_ctrl(def));\n-    _igvn.replace_input_of(use, idx, ex);\n-    _igvn._worklist.push(def);\n+    igvn()->register_new_node_with_optimizer(ex);\n+    phase()->set_ctrl(ex, phase()->get_ctrl(def));\n+    igvn()->replace_input_of(use, idx, ex);\n+    igvn()->_worklist.push(def);\n@@ -3093,5 +3064,1 @@\n-  Node* entry = bb();\n-\n-  assert(_stk.length() == 0,            \"stk is empty\");\n-  assert(_block.length() == 0,          \"block is empty\");\n-  assert(_data_entry.length() == 0,     \"data_entry is empty\");\n+  assert(_body_nodes.length() == 0,          \"block is empty\");\n@@ -3101,33 +3068,0 @@\n-  \/\/ Find non-control nodes with no inputs from within block,\n-  \/\/ create a temporary map from node _idx to bb_idx for use\n-  \/\/ by the visited and post_visited sets,\n-  \/\/ and count number of nodes in block.\n-  int bb_ct = 0;\n-  for (uint i = 0; i < lpt()->_body.size(); i++) {\n-    Node *n = lpt()->_body.at(i);\n-    set_bb_idx(n, i); \/\/ Create a temporary map\n-    if (in_bb(n)) {\n-      if (n->is_LoadStore() || n->is_MergeMem() ||\n-          (n->is_Proj() && !n->as_Proj()->is_CFG())) {\n-        \/\/ Bailout if the loop has LoadStore, MergeMem or data Proj\n-        \/\/ nodes. Superword optimization does not work with them.\n-        return false;\n-      }\n-      bb_ct++;\n-      if (!n->is_CFG()) {\n-        bool found = false;\n-        for (uint j = 0; j < n->req(); j++) {\n-          Node* def = n->in(j);\n-          if (def && in_bb(def)) {\n-            found = true;\n-            break;\n-          }\n-        }\n-        if (!found) {\n-          assert(n != entry, \"can't be entry\");\n-          _data_entry.push(n);\n-        }\n-      }\n-    }\n-  }\n-\n@@ -3135,3 +3069,3 @@\n-  for (DUIterator_Fast imax, i = lp()->fast_outs(imax); i < imax; i++) {\n-    Node *n = lp()->fast_out(i);\n-    if (in_bb(n) && n->is_memory_phi()) {\n+  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n+    Node* n = cl()->fast_out(i);\n+    if (in_loopbody(n) && n->is_memory_phi()) {\n@@ -3150,1 +3084,1 @@\n-  \/\/ Create an RPO list of nodes in block\n+  int data_node_cnt = collect_nodes_in_reverse_postorder();\n@@ -3152,15 +3086,0 @@\n-  visited_clear();\n-  post_visited_clear();\n-\n-  \/\/ Push all non-control nodes with no inputs from within block, then control entry\n-  for (int j = 0; j < _data_entry.length(); j++) {\n-    Node* n = _data_entry.at(j);\n-    visited_set(n);\n-    _stk.push(n);\n-  }\n-  visited_set(entry);\n-  _stk.push(entry);\n-\n-  \/\/ Do a depth first walk over out edges\n-  int rpo_idx = bb_ct - 1;\n-  int size;\n@@ -3168,30 +3087,8 @@\n-  while ((size = _stk.length()) > 0) {\n-    Node* n = _stk.top(); \/\/ Leave node on stack\n-    if (!visited_test_set(n)) {\n-      \/\/ forward arc in graph\n-    } else if (!post_visited_test(n)) {\n-      \/\/ cross or back arc\n-      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-        Node *use = n->fast_out(i);\n-        if (in_bb(use) && !visited_test(use) &&\n-            \/\/ Don't go around backedge\n-            (!use->is_Phi() || n == entry)) {\n-          if (is_marked_reduction(use)) {\n-            \/\/ First see if we can map the reduction on the given system we are on, then\n-            \/\/ make a data entry operation for each reduction we see.\n-            BasicType bt = use->bottom_type()->basic_type();\n-            if (ReductionNode::implemented(use->Opcode(), Matcher::superword_max_vector_size(bt), bt)) {\n-              reduction_uses++;\n-            }\n-          }\n-          _stk.push(use);\n-        }\n-      }\n-      if (_stk.length() == size) {\n-        \/\/ There were no additional uses, post visit node now\n-        _stk.pop(); \/\/ Remove node from stack\n-        assert(rpo_idx >= 0, \"\");\n-        _block.at_put_grow(rpo_idx, n);\n-        rpo_idx--;\n-        post_visited_set(n);\n-        assert(rpo_idx >= 0 || _stk.is_empty(), \"\");\n+  for (int j = 0; j < _body_nodes.length(); j++) {\n+    Node* n = _body_nodes.at(j);\n+    if (is_marked_reduction(n)) {\n+      \/\/ First see if we can map the reduction on the given system we are on, then\n+      \/\/ make a data entry operation for each reduction we see.\n+      BasicType bt = n->bottom_type()->basic_type();\n+      if (ReductionNode::implemented(n->Opcode(), Matcher::superword_max_vector_size(bt), bt)) {\n+        reduction_uses++;\n@@ -3199,2 +3096,0 @@\n-    } else {\n-      _stk.pop(); \/\/ Remove post-visited node from stack\n@@ -3202,9 +3097,1 @@\n-  }\/\/while\n-\n-  int ii_current = -1;\n-  unsigned int load_idx = (unsigned int)-1;\n-  \/\/ Create real map of block indices for nodes\n-  for (int j = 0; j < _block.length(); j++) {\n-    Node* n = _block.at(j);\n-    set_bb_idx(n, j);\n-  }\/\/for\n+  }\n@@ -3217,6 +3104,1 @@\n-    print_bb();\n-    tty->print_cr(\"\\ndata entry nodes: %s\", _data_entry.length() > 0 ? \"\" : \"NONE\");\n-    for (int m = 0; m < _data_entry.length(); m++) {\n-      tty->print(\"%3d \", m);\n-      _data_entry.at(m)->dump();\n-    }\n+    print_body_nodes();\n@@ -3230,2 +3112,2 @@\n-  assert(rpo_idx == -1 && bb_ct == _block.length(), \"all block members found\");\n-  return (_mem_slice_head.length() > 0) || (reduction_uses > 0) || (_data_entry.length() > 0);\n+\n+  return (_mem_slice_head.length() > 0) || (reduction_uses > 0) || (data_node_cnt > 0);\n@@ -3237,1 +3119,1 @@\n-  Node* last = _block.at(_block.length() - 1);\n+  Node* last = _body_nodes.at(_body_nodes.length() - 1);\n@@ -3246,2 +3128,2 @@\n-  for (int i = _block.length() - 1; i >= n_pos; i--) {\n-    _block.at_put_grow(i+1, _block.at(i));\n+  for (int i = _body_nodes.length() - 1; i >= n_pos; i--) {\n+    _body_nodes.at_put_grow(i+1, _body_nodes.at(i));\n@@ -3253,1 +3135,1 @@\n-  _block.at_put_grow(n_pos, n);\n+  _body_nodes.at_put_grow(n_pos, n);\n@@ -3255,3 +3137,3 @@\n-  \/\/ Adjust map from node->_idx to _block index\n-  for (int i = n_pos; i < _block.length(); i++) {\n-    set_bb_idx(_block.at(i), i);\n+  \/\/ Adjust map from node->_idx to _body_nodes index\n+  for (int i = n_pos; i < _body_nodes.length(); i++) {\n+    set_bb_idx(_body_nodes.at(i), i);\n@@ -3269,2 +3151,2 @@\n-    for (int i = 0; i < _block.length(); i++) {\n-      Node* n = _block.at(i);\n+    for (int i = 0; i < _body_nodes.length(); i++) {\n+      Node* n = _body_nodes.at(i);\n@@ -3276,1 +3158,1 @@\n-          if (in_bb(pred)) {\n+          if (in_loopbody(pred)) {\n@@ -3297,1 +3179,1 @@\n-      !in_bb(n->in(1))) {\n+      !in_loopbody(n->in(1))) {\n@@ -3300,1 +3182,1 @@\n-  assert(in_bb(n), \"must be in the bb\");\n+  assert(in_loopbody(n), \"must be in the bb\");\n@@ -3324,1 +3206,1 @@\n-    if (!in_bb(input)) continue;\n+    if (!in_loopbody(input)) continue;\n@@ -3332,1 +3214,1 @@\n-    if (!in_bb(output)) continue;\n+    if (!in_loopbody(output)) continue;\n@@ -3356,2 +3238,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    Node* n = _body_nodes.at(i);\n@@ -3363,2 +3245,2 @@\n-  for (int i = _block.length() - 1; i >= 0; i--) {\n-    Node* n = _block.at(i);\n+  for (int i = _body_nodes.length() - 1; i >= 0; i--) {\n+    Node* n = _body_nodes.at(i);\n@@ -3374,1 +3256,1 @@\n-        if (!in->is_Mem() && in_bb(in) && velt_type(in)->basic_type() == T_INT &&\n+        if (!in->is_Mem() && in_loopbody(in) && velt_type(in)->basic_type() == T_INT &&\n@@ -3379,1 +3261,1 @@\n-            if (!in_bb(use) || !same_velt_type(use, n)) {\n+            if (!in_loopbody(use) || !same_velt_type(use, n)) {\n@@ -3396,1 +3278,1 @@\n-              if (load->is_Load() && in_bb(load) && (velt_type(load)->basic_type() == T_INT)) {\n+              if (load->is_Load() && in_loopbody(load) && (velt_type(load)->basic_type() == T_INT)) {\n@@ -3412,2 +3294,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    Node* n = _body_nodes.at(i);\n@@ -3420,2 +3302,2 @@\n-      assert(in_bb(nn->in(1)) || in_bb(nn->in(2)), \"one of the inputs must be in the loop too\");\n-      if (in_bb(nn->in(1))) {\n+      assert(in_loopbody(nn->in(1)) || in_loopbody(nn->in(2)), \"one of the inputs must be in the loop too\");\n+      if (in_loopbody(nn->in(1))) {\n@@ -3430,2 +3312,2 @@\n-    for (int i = 0; i < _block.length(); i++) {\n-      Node* n = _block.at(i);\n+    for (int i = 0; i < _body_nodes.length(); i++) {\n+      Node* n = _body_nodes.at(i);\n@@ -3489,1 +3371,1 @@\n-  const Type* t = _igvn.type(n);\n+  const Type* t = igvn()->type(n);\n@@ -3509,1 +3391,1 @@\n-  return _phase->C->get_alias_index(mem_ref->adr_type()) == _phase->C->get_alias_index(best_align_to_mem_ref->adr_type());\n+  return phase()->C->get_alias_index(mem_ref->adr_type()) == phase()->C->get_alias_index(best_align_to_mem_ref->adr_type());\n@@ -3582,2 +3464,2 @@\n-  assert(lp()->is_main_loop(), \"\");\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  assert(cl()->is_main_loop(), \"\");\n+  CountedLoopEndNode* pre_end = cl()->pre_loop_end();\n@@ -3590,1 +3472,1 @@\n-  Node* pre_ctrl = lp()->pre_loop_head()->in(LoopNode::EntryControl);\n+  Node* pre_ctrl = cl()->pre_loop_head()->in(LoopNode::EntryControl);\n@@ -3595,1 +3477,1 @@\n-  assert(orig_limit != nullptr && _igvn.type(orig_limit) != Type::TOP, \"\");\n+  assert(orig_limit != nullptr && igvn()->type(orig_limit) != Type::TOP, \"\");\n@@ -3658,1 +3540,1 @@\n-  Node *offsn  = _igvn.intcon(offset);\n+  Node* offsn  = igvn()->intcon(offset);\n@@ -3660,1 +3542,1 @@\n-  Node *e = offsn;\n+  Node* e = offsn;\n@@ -3663,1 +3545,1 @@\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n+    Node* log2_elt = igvn()->intcon(exact_log2(elt_size));\n@@ -3665,1 +3547,1 @@\n-    if (_igvn.type(invar)->isa_long()) {\n+    if (igvn()->type(invar)->isa_long()) {\n@@ -3670,1 +3552,1 @@\n-      _igvn.register_new_node_with_optimizer(invar);\n+      igvn()->register_new_node_with_optimizer(invar);\n@@ -3673,2 +3555,2 @@\n-    _igvn.register_new_node_with_optimizer(aref);\n-    _phase->set_ctrl(aref, pre_ctrl);\n+    igvn()->register_new_node_with_optimizer(aref);\n+    phase()->set_ctrl(aref, pre_ctrl);\n@@ -3676,2 +3558,2 @@\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n+    igvn()->register_new_node_with_optimizer(e);\n+    phase()->set_ctrl(e, pre_ctrl);\n@@ -3682,1 +3564,1 @@\n-    _igvn.register_new_node_with_optimizer(xbase);\n+    igvn()->register_new_node_with_optimizer(xbase);\n@@ -3685,1 +3567,1 @@\n-    _igvn.register_new_node_with_optimizer(xbase);\n+    igvn()->register_new_node_with_optimizer(xbase);\n@@ -3687,1 +3569,1 @@\n-    Node* mask = _igvn.intcon(vw-1);\n+    Node* mask = igvn()->intcon(vw-1);\n@@ -3689,2 +3571,2 @@\n-    _igvn.register_new_node_with_optimizer(masked_xbase);\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n+    igvn()->register_new_node_with_optimizer(masked_xbase);\n+    Node* log2_elt = igvn()->intcon(exact_log2(elt_size));\n@@ -3692,2 +3574,2 @@\n-    _igvn.register_new_node_with_optimizer(bref);\n-    _phase->set_ctrl(bref, pre_ctrl);\n+    igvn()->register_new_node_with_optimizer(bref);\n+    phase()->set_ctrl(bref, pre_ctrl);\n@@ -3695,2 +3577,2 @@\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n+    igvn()->register_new_node_with_optimizer(e);\n+    phase()->set_ctrl(e, pre_ctrl);\n@@ -3705,2 +3587,2 @@\n-  _igvn.register_new_node_with_optimizer(e);\n-  _phase->set_ctrl(e, pre_ctrl);\n+  igvn()->register_new_node_with_optimizer(e);\n+  phase()->set_ctrl(e, pre_ctrl);\n@@ -3710,1 +3592,1 @@\n-    Node* va  = _igvn.intcon(v_align);\n+    Node* va  = igvn()->intcon(v_align);\n@@ -3712,2 +3594,2 @@\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n+    igvn()->register_new_node_with_optimizer(e);\n+    phase()->set_ctrl(e, pre_ctrl);\n@@ -3716,1 +3598,1 @@\n-  Node* va_msk = _igvn.intcon(v_align - 1);\n+  Node* va_msk = igvn()->intcon(v_align - 1);\n@@ -3718,2 +3600,2 @@\n-  _igvn.register_new_node_with_optimizer(N);\n-  _phase->set_ctrl(N, pre_ctrl);\n+  igvn()->register_new_node_with_optimizer(N);\n+  phase()->set_ctrl(N, pre_ctrl);\n@@ -3729,2 +3611,2 @@\n-  _igvn.register_new_node_with_optimizer(lim);\n-  _phase->set_ctrl(lim, pre_ctrl);\n+  igvn()->register_new_node_with_optimizer(lim);\n+  phase()->set_ctrl(lim, pre_ctrl);\n@@ -3734,3 +3616,3 @@\n-  _igvn.register_new_node_with_optimizer(constrained);\n-  _phase->set_ctrl(constrained, pre_ctrl);\n-  _igvn.replace_input_of(pre_opaq, 1, constrained);\n+  igvn()->register_new_node_with_optimizer(constrained);\n+  phase()->set_ctrl(constrained, pre_ctrl);\n+  igvn()->replace_input_of(pre_opaq, 1, constrained);\n@@ -3744,2 +3626,1 @@\n-  _block.clear();\n-  _data_entry.clear();\n+  _body_nodes.clear();\n@@ -3779,14 +3660,0 @@\n-\/\/------------------------------print_bb---------------------------\n-void SuperWord::print_bb() {\n-#ifndef PRODUCT\n-  tty->print_cr(\"\\nBlock\");\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n-    tty->print(\"%d \", i);\n-    if (n) {\n-      n->dump();\n-    }\n-  }\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":196,"deletions":329,"binary":false,"changes":525,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-class SuperWord : public ResourceObj {\n+class SuperWord : public Vectorizer {\n@@ -234,4 +234,0 @@\n-  PhaseIdealLoop* _phase;\n-  Arena*          _arena;\n-  PhaseIterGVN   &_igvn;\n-\n@@ -242,4 +238,0 @@\n-  GrowableArray<int> _bb_idx;            \/\/ Map from Node _idx to index within block\n-\n-  GrowableArray<Node*> _block;           \/\/ Nodes in current block\n-  GrowableArray<Node*> _data_entry;      \/\/ Nodes with all inputs from outside\n@@ -257,2 +249,0 @@\n-  VectorSet    _visited;       \/\/ Visited set\n-  VectorSet    _post_visited;  \/\/ Post-visited set\n@@ -261,1 +251,0 @@\n-  GrowableArray<Node*> _stk;   \/\/ Stack of nodes\n@@ -271,3 +260,0 @@\n-  PhaseIdealLoop* phase() const    { return _phase; }\n-  IdealLoopTree* lpt() const       { return _lpt; }\n-  PhiNode* iv() const              { return _iv; }\n@@ -276,9 +262,0 @@\n-\n-#ifndef PRODUCT\n-  bool     is_debug()              { return _vector_loop_debug > 0; }\n-  bool     is_trace_alignment()    { return (_vector_loop_debug & 2) > 0; }\n-  bool     is_trace_mem_slice()    { return (_vector_loop_debug & 4) > 0; }\n-  bool     is_trace_loop()         { return (_vector_loop_debug & 8) > 0; }\n-  bool     is_trace_adjacent()     { return (_vector_loop_debug & 16) > 0; }\n-  bool     is_trace_cmov()         { return (_vector_loop_debug & 32) > 0; }\n-#endif\n@@ -288,1 +265,0 @@\n-  const GrowableArray<Node*>&      block()   const { return _block; }\n@@ -291,2 +267,0 @@\n-  IdealLoopTree* _lpt;             \/\/ Current loop tree node\n-  CountedLoopNode* _lp;            \/\/ Current CountedLoopNode\n@@ -294,2 +268,0 @@\n-  Node*          _bb;              \/\/ Current basic block\n-  PhiNode*       _iv;              \/\/ Induction var\n@@ -301,16 +273,0 @@\n-#ifndef PRODUCT\n-  uintx          _vector_loop_debug; \/\/ provide more printing in debug mode\n-#endif\n-\n-  \/\/ Accessors\n-  Arena* arena()                   { return _arena; }\n-\n-  Node* bb()                       { return _bb; }\n-  void set_bb(Node* bb)            { _bb = bb; }\n-  void set_lpt(IdealLoopTree* lpt) { _lpt = lpt; }\n-  CountedLoopNode* lp() const      { return _lp; }\n-  void set_lp(CountedLoopNode* lp) {\n-    _lp = lp;\n-    _iv = lp->as_CountedLoop()->phi()->as_Phi();\n-  }\n-  int iv_stride() const            { return lp()->stride_con(); }\n@@ -330,6 +286,0 @@\n-  const Node* ctrl(const Node* n) const { return _phase->has_ctrl(n) ? _phase->get_ctrl(n) : n; }\n-\n-  \/\/ block accessors\n- public:\n-  bool in_bb(const Node* n) const  { return n != nullptr && n->outcnt() > 0 && ctrl(n) == _bb; }\n-  int  bb_idx(const Node* n) const { assert(in_bb(n), \"must be\"); return _bb_idx.at(n->_idx); }\n@@ -337,11 +287,0 @@\n-  void set_bb_idx(Node* n, int i)  { _bb_idx.at_put_grow(n->_idx, i); }\n-\n-  \/\/ visited set accessors\n-  void visited_clear()           { _visited.clear(); }\n-  void visited_set(Node* n)      { return _visited.set(bb_idx(n)); }\n-  int visited_test(Node* n)      { return _visited.test(bb_idx(n)); }\n-  int visited_test_set(Node* n)  { return _visited.test_set(bb_idx(n)); }\n-  void post_visited_clear()      { _post_visited.clear(); }\n-  void post_visited_set(Node* n) { return _post_visited.set(bb_idx(n)); }\n-  int post_visited_test(Node* n) { return _post_visited.test(bb_idx(n)); }\n-\n@@ -371,1 +310,1 @@\n-  Node_List* my_pack(Node* n)                 { return !in_bb(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n+  Node_List* my_pack(Node* n)                 { return !in_loopbody(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n@@ -481,1 +420,1 @@\n-  bool independent_path(Node* shallow, Node* deep, uint dp=0);\n+  bool independent_path(VectorSet& visited, Node* shallow, Node* deep, uint dp=0);\n@@ -557,1 +496,0 @@\n-  void print_bb();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":65,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+uintx Vectorizer::_vector_loop_debug = 0;\n@@ -38,0 +39,144 @@\n+Vectorizer::Vectorizer(PhaseIdealLoop* phase) :\n+  _phase(phase),\n+  _arena(phase->C->comp_arena()),\n+  _igvn(&phase->_igvn),\n+  _lpt(nullptr),\n+  _cl(nullptr),\n+  _iv(nullptr),\n+  _bb_idx(arena(), (int)(1.10 * phase->C->unique()), 0, 0),\n+  _body_nodes(arena(), 8, 0, nullptr)\n+{\n+#ifndef PRODUCT\n+  if (_phase->C->method() != nullptr) {\n+    _vector_loop_debug = phase->C->directive()->VectorizeDebugOption;\n+  }\n+#endif\n+};\n+\n+void Vectorizer::initialize_loop_info(IdealLoopTree* lpt) {\n+  set_lpt(lpt);\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  set_cl_and_iv(cl);\n+}\n+\n+\/\/ Collect loop nodes into a block with reverse postorder for convenience of\n+\/\/ future traversal. Do early bail out if unsupported node is found.\n+int Vectorizer::collect_nodes_in_reverse_postorder() {\n+  _bb_idx.clear();\n+  _body_nodes.clear();\n+\n+  ResourceMark rm;\n+  Node* entry = cl();\n+\n+  \/\/ Find non-control nodes with no inputs from within block,\n+  \/\/ create a temporary map from node _idx to bb_idx for use\n+  \/\/ by the visited and post_visited sets,\n+  \/\/ and count number of nodes in block.\n+  int node_cnt = 0;\n+  GrowableArray<Node*> data_entry(8, 0, nullptr);\n+  for (uint i = 0; i < lpt()->_body.size(); i++) {\n+    Node* n = lpt()->_body.at(i);\n+    set_bb_idx(n, i); \/\/ Create a temporary map\n+    if (in_loopbody(n)) {\n+      if (n->is_LoadStore() || n->is_MergeMem() ||\n+         (n->is_Proj() && !n->as_Proj()->is_CFG())) {\n+        \/\/ Bailout if the loop has LoadStore, MergeMem or data Proj\n+        \/\/ nodes. Superword optimization does not work with them.\n+        return false;\n+      }\n+      node_cnt++;\n+      if (!n->is_CFG()) {\n+        bool found = false;\n+        for (uint j = 0; j < n->req(); j++) {\n+          Node* def = n->in(j);\n+          if (def && in_loopbody(def)) {\n+            found = true;\n+            break;\n+          }\n+        }\n+        if (!found) {\n+          assert(n != entry, \"can't be entry\");\n+          data_entry.push(n);\n+        }\n+      }\n+    }\n+  }\n+\n+  VectorSet visited;\n+  VectorSet post_visited;\n+  GrowableArray<Node*> stk(node_cnt, 0, nullptr);\n+\n+  \/\/ Push all non-control nodes with no inputs from within block, then control entry\n+  for (int j = 0; j < data_entry.length(); j++) {\n+    Node* n = data_entry.at(j);\n+    visited.set(bb_idx(n));\n+    stk.push(n);\n+  }\n+  visited.set(bb_idx(entry));\n+  stk.push(entry);\n+\n+  \/\/ Do a depth first walk over out edges\n+  int rpo_idx = node_cnt - 1;\n+  int size;\n+  while ((size = stk.length()) > 0) {\n+    Node* n = stk.top(); \/\/ Leave node on stack\n+    if (!visited.test_set(bb_idx(n))) {\n+      \/\/ forward arc in graph\n+    } else if (!post_visited.test(bb_idx(n))) {\n+      \/\/ cross or back arc\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* use = n->fast_out(i);\n+        if (in_loopbody(use) && !visited.test(bb_idx(use)) &&\n+            \/\/ Don't go around backedge\n+            (!use->is_Phi() || n == entry)) {\n+          stk.push(use);\n+        }\n+      }\n+      if (stk.length() == size) {\n+        \/\/ There were no additional uses, post visit node now\n+        stk.pop(); \/\/ Remove node from stack\n+        assert(rpo_idx >= 0, \"The rpo_idx of the node can't be negative\");\n+        _body_nodes.at_put_grow(rpo_idx, n);\n+        rpo_idx--;\n+        post_visited.set(bb_idx(n));\n+        assert(rpo_idx >= 0 || stk.is_empty(),\n+               \"The rpo_idx of any node in stk can't be negative\");\n+      }\n+    } else {\n+      stk.pop(); \/\/ Remove post-visited node from stack\n+    }\n+  } \/\/ while\n+\n+  \/\/ Create real map of block indices for nodes\n+  for (int j = 0; j < _body_nodes.length(); j++) {\n+    Node* n = _body_nodes.at(j);\n+    set_bb_idx(n, j);\n+  } \/\/ for\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord) {\n+    tty->print_cr(\"\\ndata entry nodes: %s\", data_entry.length() > 0 ? \"\" : \"NONE\");\n+    for (int m = 0; m < data_entry.length(); m++) {\n+      tty->print(\"%3d \", m);\n+      data_entry.at(m)->dump();\n+    }\n+  }\n+#endif\n+\n+  assert(rpo_idx == -1 && node_cnt == _body_nodes.length(), \"all block members found\");\n+  return data_entry.length();\n+}\n+\n+void Vectorizer::print_body_nodes() {\n+#ifndef PRODUCT\n+  tty->print_cr(\"\\nBlock\");\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    Node* n = _body_nodes.at(i);\n+    tty->print(\"%d \", i);\n+    if (n) {\n+      n->dump();\n+    }\n+  }\n+#endif\n+}\n+\n@@ -48,1 +193,1 @@\n-  , _tracer((phase->C->directive()->VectorizeDebugOption & 2) > 0)\n+  , _tracer(Vectorizer::is_trace_alignment())\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":146,"deletions":1,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -34,0 +34,52 @@\n+class Vectorizer : public ResourceObj {\n+ private:\n+  PhaseIdealLoop*      _phase;\n+  Arena*               _arena;\n+  PhaseIterGVN*        _igvn;\n+  IdealLoopTree*       _lpt;               \/\/ Current Idealloop tree\n+  CountedLoopNode*     _cl;                \/\/ Current CountedLoopNode\n+  PhiNode*             _iv;                \/\/ Loop induction variable PhiNode\n+  GrowableArray<int>   _bb_idx;            \/\/ Map from node index to RPO index within block\n+#ifndef PRODUCT\n+  static uintx         _vector_loop_debug; \/\/ provide more printing in debug mode\n+#endif\n+\n+ protected:\n+  GrowableArray<Node*> _body_nodes;        \/\/ Nodes in current loop body with reverse postorder\n+\n+  Vectorizer(PhaseIdealLoop* phase);\n+\n+  void set_lpt(IdealLoopTree* lpt) { _lpt = lpt; }\n+  void set_cl_and_iv(CountedLoopNode* cl) {\n+    _cl = cl;\n+    _iv = cl->as_CountedLoop()->phi()->as_Phi();\n+  }\n+  void initialize_loop_info(IdealLoopTree* lpt);\n+\n+  PhaseIdealLoop* phase() const   { return _phase; }\n+  Arena* arena() const            { return _arena; }\n+  PhaseIterGVN* igvn() const      { return _igvn; }\n+  IdealLoopTree* lpt() const      { return _lpt; }\n+  CountedLoopNode* cl() const     { return _cl; }\n+  PhiNode* iv() const             { return _iv; }\n+  void set_bb_idx(Node* n, int i) { _bb_idx.at_put_grow(n->_idx, i); }\n+  int iv_stride() const           { return _cl->stride_con(); }\n+  const Node* ctrl(const Node* n) const { return _phase->has_ctrl(n) ? _phase->get_ctrl(n) : n; }\n+  int collect_nodes_in_reverse_postorder();\n+  void print_body_nodes();\n+\n+ public:\n+  bool in_loopbody(const Node* n) const { return n != nullptr && n->outcnt() > 0 && ctrl(n) == _cl; }\n+  int bb_idx(const Node* n) const { assert(in_loopbody(n), \"must be\"); return _bb_idx.at(n->_idx); }\n+  const GrowableArray<Node*> block() const { return _body_nodes; }\n+#ifndef PRODUCT\n+  static uintx vector_loop_debug() { return _vector_loop_debug; }\n+  static bool is_debug()           { return _vector_loop_debug > 0; }\n+  static bool is_trace_alignment() { return (_vector_loop_debug & 2) > 0; }\n+  static bool is_trace_mem_slice() { return (_vector_loop_debug & 4) > 0; }\n+  static bool is_trace_loop()      { return (_vector_loop_debug & 8) > 0; }\n+  static bool is_trace_adjacent()  { return (_vector_loop_debug & 16) > 0; }\n+  static bool is_trace_cmov()      { return (_vector_loop_debug & 32) > 0; }\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"}]}