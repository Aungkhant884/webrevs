{"files":[{"patch":"@@ -37,27 +37,0 @@\n-\/\/ Note: 'double' and 'long long' have 32-bits alignment on x86.\n-static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {\n-  \/\/ Use the expression (adr)&(~0xF) to provide 128-bits aligned address\n-  \/\/ of 128-bits operands for SSE instructions.\n-  jlong *operand = (jlong*)(((uintptr_t)adr)&((uintptr_t)(~0xF)));\n-  \/\/ Store the value to a 128-bits operand.\n-  operand[0] = lo;\n-  operand[1] = hi;\n-  return operand;\n-}\n-\n-\/\/ Buffer for 128-bits masks used by SSE instructions.\n-static jlong fp_signmask_pool[(4+1)*2]; \/\/ 4*128bits(data) + 128bits(alignment)\n-\n-\/\/ Static initialization during VM startup.\n-static jlong *float_signflip_pool  = double_quadword(&fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));\n-static jlong *double_signflip_pool = double_quadword(&fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));\n-\n-  \/\/ Float masks come from different places depending on platform.\n-#ifdef _LP64\n-  static address float_signflip()  { return StubRoutines::x86::float_sign_flip(); }\n-  static address double_signflip() { return StubRoutines::x86::double_sign_flip(); }\n-#else\n-  static address float_signflip()  { return (address)float_signflip_pool; }\n-  static address double_signflip() { return (address)double_signflip_pool; }\n-#endif\n-\n@@ -1103,1 +1076,1 @@\n-    xorps(dst, ExternalAddress(float_signflip()), scratch);\n+    xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scratch);\n@@ -1105,1 +1078,1 @@\n-    xorpd(dst, ExternalAddress(double_signflip()), scratch);\n+    xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scratch);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"}]}