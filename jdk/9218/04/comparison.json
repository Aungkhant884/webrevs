{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -56,1 +57,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -52,1 +53,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -42,1 +43,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/rdtsc_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/interpreterFrame_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/stack_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/stack_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/stubRoutines_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -67,1 +68,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -69,0 +69,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -58,1 +59,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -60,0 +60,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -60,1 +61,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -62,0 +62,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os\/posix\/threadCritical_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -64,1 +65,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os\/windows\/threadCritical_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/javaThread_aix_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/aix_ppc\/thread_aix_ppc.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_AIX_PPC_THREAD_AIX_PPC_HPP\n-#define OS_CPU_AIX_PPC_THREAD_AIX_PPC_HPP\n+#ifndef OS_CPU_AIX_PPC_JAVATHREAD_AIX_PPC_HPP\n+#define OS_CPU_AIX_PPC_JAVATHREAD_AIX_PPC_HPP\n@@ -44,1 +44,1 @@\n-#endif \/\/ OS_CPU_AIX_PPC_THREAD_AIX_PPC_HPP\n+#endif \/\/ OS_CPU_AIX_PPC_JAVATHREAD_AIX_PPC_HPP\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/javaThread_aix_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/aix_ppc\/thread_aix_ppc.hpp","status":"renamed"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/javaThread_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.cpp","status":"renamed"},{"patch":"@@ -27,2 +27,2 @@\n-#ifndef OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n-#define OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n+#ifndef OS_CPU_BSD_AARCH64_JAVATHREAD_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_JAVATHREAD_BSD_AARCH64_HPP\n@@ -55,1 +55,1 @@\n-#endif \/\/ OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n+#endif \/\/ OS_CPU_BSD_AARCH64_JAVATHREAD_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/javaThread_bsd_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.hpp","status":"renamed"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/javaThread_bsd_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/bsd_x86\/thread_bsd_x86.cpp","status":"renamed"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef OS_CPU_BSD_X86_THREAD_BSD_X86_HPP\n-#define OS_CPU_BSD_X86_THREAD_BSD_X86_HPP\n+#ifndef OS_CPU_BSD_X86_JAVATHREAD_BSD_X86_HPP\n+#define OS_CPU_BSD_X86_JAVATHREAD_BSD_X86_HPP\n@@ -49,1 +49,1 @@\n-#endif \/\/ OS_CPU_BSD_X86_THREAD_BSD_X86_HPP\n+#endif \/\/ OS_CPU_BSD_X86_JAVATHREAD_BSD_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/javaThread_bsd_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/bsd_x86\/thread_bsd_x86.hpp","status":"renamed"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/javaThread_bsd_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/bsd_zero\/thread_bsd_zero.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_BSD_ZERO_THREAD_BSD_ZERO_HPP\n-#define OS_CPU_BSD_ZERO_THREAD_BSD_ZERO_HPP\n+#ifndef OS_CPU_BSD_ZERO_JAVATHREAD_BSD_ZERO_HPP\n+#define OS_CPU_BSD_ZERO_JAVATHREAD_BSD_ZERO_HPP\n@@ -104,1 +104,1 @@\n-#endif \/\/ OS_CPU_BSD_ZERO_THREAD_BSD_ZERO_HPP\n+#endif \/\/ OS_CPU_BSD_ZERO_JAVATHREAD_BSD_ZERO_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/javaThread_bsd_zero.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/bsd_zero\/thread_bsd_zero.hpp","status":"renamed"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -52,1 +53,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/javaThread_linux_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/linux_aarch64\/thread_linux_aarch64.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_LINUX_AARCH64_THREAD_LINUX_AARCH64_HPP\n-#define OS_CPU_LINUX_AARCH64_THREAD_LINUX_AARCH64_HPP\n+#ifndef OS_CPU_LINUX_AARCH64_JAVATHREAD_LINUX_AARCH64_HPP\n+#define OS_CPU_LINUX_AARCH64_JAVATHREAD_LINUX_AARCH64_HPP\n@@ -52,1 +52,1 @@\n-#endif \/\/ OS_CPU_LINUX_AARCH64_THREAD_LINUX_AARCH64_HPP\n+#endif \/\/ OS_CPU_LINUX_AARCH64_JAVATHREAD_LINUX_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/javaThread_linux_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_aarch64\/thread_linux_aarch64.hpp","status":"renamed"},{"patch":"@@ -49,1 +49,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"src\/hotspot\/os_cpu\/linux_arm\/javaThread_linux_arm.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/os_cpu\/linux_arm\/thread_linux_arm.cpp","status":"renamed"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef OS_CPU_LINUX_ARM_THREAD_LINUX_ARM_HPP\n-#define OS_CPU_LINUX_ARM_THREAD_LINUX_ARM_HPP\n+#ifndef OS_CPU_LINUX_ARM_JAVATHREAD_LINUX_ARM_HPP\n+#define OS_CPU_LINUX_ARM_JAVATHREAD_LINUX_ARM_HPP\n@@ -65,1 +65,1 @@\n-#endif \/\/ OS_CPU_LINUX_ARM_THREAD_LINUX_ARM_HPP\n+#endif \/\/ OS_CPU_LINUX_ARM_JAVATHREAD_LINUX_ARM_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/javaThread_linux_arm.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_arm\/thread_linux_arm.hpp","status":"renamed"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/javaThread_linux_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/linux_ppc\/thread_linux_ppc.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_LINUX_PPC_THREAD_LINUX_PPC_HPP\n-#define OS_CPU_LINUX_PPC_THREAD_LINUX_PPC_HPP\n+#ifndef OS_CPU_LINUX_PPC_JAVATHREAD_LINUX_PPC_HPP\n+#define OS_CPU_LINUX_PPC_JAVATHREAD_LINUX_PPC_HPP\n@@ -44,1 +44,1 @@\n-#endif \/\/ OS_CPU_LINUX_PPC_THREAD_LINUX_PPC_HPP\n+#endif \/\/ OS_CPU_LINUX_PPC_JAVATHREAD_LINUX_PPC_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/javaThread_linux_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_ppc\/thread_linux_ppc.hpp","status":"renamed"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/javaThread_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/linux_riscv\/thread_linux_riscv.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_LINUX_RISCV_THREAD_LINUX_RISCV_HPP\n-#define OS_CPU_LINUX_RISCV_THREAD_LINUX_RISCV_HPP\n+#ifndef OS_CPU_LINUX_RISCV_JAVATHREAD_LINUX_RISCV_HPP\n+#define OS_CPU_LINUX_RISCV_JAVATHREAD_LINUX_RISCV_HPP\n@@ -48,1 +48,1 @@\n-#endif \/\/ OS_CPU_LINUX_RISCV_THREAD_LINUX_RISCV_HPP\n+#endif \/\/ OS_CPU_LINUX_RISCV_JAVATHREAD_LINUX_RISCV_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/javaThread_linux_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_riscv\/thread_linux_riscv.hpp","status":"renamed"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/javaThread_linux_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/linux_s390\/thread_linux_s390.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_LINUX_S390_THREAD_LINUX_S390_HPP\n-#define OS_CPU_LINUX_S390_THREAD_LINUX_S390_HPP\n+#ifndef OS_CPU_LINUX_S390_JAVATHREAD_LINUX_S390_HPP\n+#define OS_CPU_LINUX_S390_JAVATHREAD_LINUX_S390_HPP\n@@ -43,1 +43,1 @@\n-#endif \/\/ OS_CPU_LINUX_S390_THREAD_LINUX_S390_HPP\n+#endif \/\/ OS_CPU_LINUX_S390_JAVATHREAD_LINUX_S390_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/javaThread_linux_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_s390\/thread_linux_s390.hpp","status":"renamed"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -52,1 +53,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/javaThread_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/linux_x86\/thread_linux_x86.cpp","status":"renamed"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef OS_CPU_LINUX_X86_THREAD_LINUX_X86_HPP\n-#define OS_CPU_LINUX_X86_THREAD_LINUX_X86_HPP\n+#ifndef OS_CPU_LINUX_X86_JAVATHREAD_LINUX_X86_HPP\n+#define OS_CPU_LINUX_X86_JAVATHREAD_LINUX_X86_HPP\n@@ -48,1 +48,1 @@\n-#endif \/\/ OS_CPU_LINUX_X86_THREAD_LINUX_X86_HPP\n+#endif \/\/ OS_CPU_LINUX_X86_JAVATHREAD_LINUX_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/javaThread_linux_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_x86\/thread_linux_x86.hpp","status":"renamed"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -47,1 +48,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/javaThread_linux_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/linux_zero\/thread_linux_zero.cpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef OS_CPU_LINUX_ZERO_THREAD_LINUX_ZERO_HPP\n-#define OS_CPU_LINUX_ZERO_THREAD_LINUX_ZERO_HPP\n+#ifndef OS_CPU_LINUX_ZERO_JAVATHREAD_LINUX_ZERO_HPP\n+#define OS_CPU_LINUX_ZERO_JAVATHREAD_LINUX_ZERO_HPP\n@@ -105,1 +105,1 @@\n-#endif \/\/ OS_CPU_LINUX_ZERO_THREAD_LINUX_ZERO_HPP\n+#endif \/\/ OS_CPU_LINUX_ZERO_JAVATHREAD_LINUX_ZERO_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/javaThread_linux_zero.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/linux_zero\/thread_linux_zero.hpp","status":"renamed"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -47,1 +48,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/javaThread_windows_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_JAVATHREAD_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_JAVATHREAD_WINDOWS_AARCH64_HPP\n+\n+ private:\n+\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *aarch64_get_thread_helper() {\n+     return Thread::current();\n+  }\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_JAVATHREAD_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/javaThread_windows_aarch64.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -47,1 +48,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n-#define OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n-\n- private:\n-\n-  void pd_initialize() {\n-    _anchor.clear();\n-  }\n-\n-  frame pd_last_frame();\n-\n- public:\n-  static ByteSize last_Java_fp_offset()          {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n-  }\n-\n-  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n-    bool isInJava);\n-\n-  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n-private:\n-  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n-public:\n-\n-  static Thread *aarch64_get_thread_helper() {\n-     return Thread::current();\n-  }\n-\n-#endif \/\/ OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/javaThread_windows_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/os_cpu\/windows_x86\/thread_windows_x86.cpp","status":"renamed"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef OS_CPU_WINDOWS_X86_THREAD_WINDOWS_X86_HPP\n-#define OS_CPU_WINDOWS_X86_THREAD_WINDOWS_X86_HPP\n+#ifndef OS_CPU_WINDOWS_X86_JAVATHREAD_WINDOWS_X86_HPP\n+#define OS_CPU_WINDOWS_X86_JAVATHREAD_WINDOWS_X86_HPP\n@@ -57,1 +57,1 @@\n-#endif \/\/ OS_CPU_WINDOWS_X86_THREAD_WINDOWS_X86_HPP\n+#endif \/\/ OS_CPU_WINDOWS_X86_JAVATHREAD_WINDOWS_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/javaThread_windows_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/os_cpu\/windows_x86\/thread_windows_x86.hpp","status":"renamed"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -47,1 +48,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/cds\/classListWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-#include \"runtime\/reflection.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -74,0 +74,1 @@\n+#include \"runtime\/reflection.hpp\"\n@@ -76,1 +77,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -54,0 +53,2 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -42,1 +43,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -79,1 +80,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/metadataOnStackMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -58,1 +59,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -36,1 +38,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,1 +46,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HotCardCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -59,1 +60,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -57,1 +58,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -38,0 +38,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/stackChunkOop.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCBreakpoints.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/copyFailedInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcId.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+class FilteringClosure;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupStorageUse.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/taskTerminator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"memory\/iterator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -59,1 +60,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetAssembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zCPU.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zFuture.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -65,1 +66,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zThreadLocalAllocBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -47,1 +48,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -59,1 +60,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -39,1 +40,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/rootSetClosure.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleDescription.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/leakProfiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -47,1 +48,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCallTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -54,1 +55,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrRepository.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEvent.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrOptionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorageUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorageUtils.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAllocationTracer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrFlush.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrStackTraceMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrEpochQueue.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrJavaLog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSpinlockHelper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrThreadIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrThreadIterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/libadt\/dict.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/logging\/logMessageBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/memory\/resourceArea.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -73,1 +74,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -86,1 +87,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -58,1 +59,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jniCheck.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -88,1 +89,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,0 +33,3 @@\n+class MonitorInfo;\n+template <typename T> class GrowableArray;\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+# include \"runtime\/thread.inline.hpp\"\n+# include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -74,1 +75,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -76,0 +76,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -54,1 +55,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -40,1 +41,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -68,1 +69,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -54,1 +55,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -63,1 +64,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -54,1 +55,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -86,1 +87,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -83,1 +84,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -58,1 +59,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -40,0 +40,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -38,1 +39,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -72,1 +73,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,2031 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"cds\/dynamicArchive.hpp\"\n+#include \"ci\/ciEnv.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaThreadStatus.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/scopeDesc.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"gc\/shared\/tlab_globals.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"oops\/verifyOopClosure.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"prims\/jvmtiThreadState.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/handshake.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/threadStatisticalInfo.hpp\"\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n+#include \"runtime\/vframe_hp.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"services\/threadService.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/dtrace.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/preserveException.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#endif\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n+\/\/ Set by os layer.\n+size_t      JavaThread::_stack_size_at_create = 0;\n+\n+#ifdef DTRACE_ENABLED\n+\n+\/\/ Only bother with this argument setup if dtrace is available\n+\n+  #define HOTSPOT_THREAD_PROBE_start HOTSPOT_THREAD_START\n+  #define HOTSPOT_THREAD_PROBE_stop HOTSPOT_THREAD_STOP\n+\n+  #define DTRACE_THREAD_PROBE(probe, javathread)                           \\\n+    {                                                                      \\\n+      ResourceMark rm(this);                                               \\\n+      int len = 0;                                                         \\\n+      const char* name = (javathread)->name();                             \\\n+      len = strlen(name);                                                  \\\n+      HOTSPOT_THREAD_PROBE_##probe(\/* probe = start, stop *\/               \\\n+        (char *) name, len,                                                \\\n+        java_lang_Thread::thread_id((javathread)->threadObj()),            \\\n+        (uintptr_t) (javathread)->osthread()->thread_id(),                 \\\n+        java_lang_Thread::is_daemon((javathread)->threadObj()));           \\\n+    }\n+\n+#else \/\/  ndef DTRACE_ENABLED\n+\n+  #define DTRACE_THREAD_PROBE(probe, javathread)\n+\n+#endif \/\/ ndef DTRACE_ENABLED\n+\n+void JavaThread::smr_delete() {\n+  if (_on_thread_list) {\n+    ThreadsSMRSupport::smr_delete(this);\n+  } else {\n+    delete this;\n+  }\n+}\n+\n+\/\/ Initialized by VMThread at vm_global_init\n+OopStorage* JavaThread::_thread_oop_storage = NULL;\n+\n+OopStorage* JavaThread::thread_oop_storage() {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  return _thread_oop_storage;\n+}\n+\n+void JavaThread::set_threadOopHandles(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _threadObj   = OopHandle(_thread_oop_storage, p);\n+  _vthread     = OopHandle(_thread_oop_storage, p);\n+  _jvmti_vthread = OopHandle(_thread_oop_storage, NULL);\n+  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+}\n+\n+oop JavaThread::threadObj() const {\n+  return _threadObj.resolve();\n+}\n+\n+oop JavaThread::vthread() const {\n+  return _vthread.resolve();\n+}\n+\n+void JavaThread::set_vthread(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _vthread.replace(p);\n+}\n+\n+oop JavaThread::jvmti_vthread() const {\n+  return _jvmti_vthread.resolve();\n+}\n+\n+void JavaThread::set_jvmti_vthread(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _jvmti_vthread.replace(p);\n+}\n+\n+oop JavaThread::extentLocalCache() const {\n+  return _extentLocalCache.resolve();\n+}\n+\n+void JavaThread::set_extentLocalCache(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _extentLocalCache.replace(p);\n+}\n+\n+void JavaThread::allocate_threadObj(Handle thread_group, const char* thread_name,\n+                                    bool daemon, TRAPS) {\n+  assert(thread_group.not_null(), \"thread group should be specified\");\n+  assert(threadObj() == NULL, \"should only create Java thread object once\");\n+\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n+  assert(ik->is_initialized(), \"must be\");\n+  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n+\n+  \/\/ We are called from jni_AttachCurrentThread\/jni_AttachCurrentThreadAsDaemon.\n+  \/\/ We cannot use JavaCalls::construct_new_instance because the java.lang.Thread\n+  \/\/ constructor calls Thread.current(), which must be set here.\n+  java_lang_Thread::set_thread(thread_oop(), this);\n+  set_threadOopHandles(thread_oop());\n+\n+  JavaValue result(T_VOID);\n+  if (thread_name != NULL) {\n+    Handle name = java_lang_String::create_from_str(thread_name, CHECK);\n+    \/\/ Thread gets assigned specified name and null target\n+    JavaCalls::call_special(&result,\n+                            thread_oop,\n+                            ik,\n+                            vmSymbols::object_initializer_name(),\n+                            vmSymbols::threadgroup_string_void_signature(),\n+                            thread_group,\n+                            name,\n+                            THREAD);\n+  } else {\n+    \/\/ Thread gets assigned name \"Thread-nnn\" and null target\n+    \/\/ (java.lang.Thread doesn't have a constructor taking only a ThreadGroup argument)\n+    JavaCalls::call_special(&result,\n+                            thread_oop,\n+                            ik,\n+                            vmSymbols::object_initializer_name(),\n+                            vmSymbols::threadgroup_runnable_void_signature(),\n+                            thread_group,\n+                            Handle(),\n+                            THREAD);\n+  }\n+  os::set_priority(this, NormPriority);\n+\n+  if (daemon) {\n+    java_lang_Thread::set_daemon(thread_oop());\n+  }\n+}\n+\n+\/\/ ======= JavaThread ========\n+\n+#if INCLUDE_JVMCI\n+\n+jlong* JavaThread::_jvmci_old_thread_counters;\n+\n+bool jvmci_counters_include(JavaThread* thread) {\n+  return !JVMCICountersExcludeCompiler || !thread->is_Compiler_thread();\n+}\n+\n+void JavaThread::collect_counters(jlong* array, int length) {\n+  assert(length == JVMCICounterSize, \"wrong value\");\n+  for (int i = 0; i < length; i++) {\n+    array[i] = _jvmci_old_thread_counters[i];\n+  }\n+  for (JavaThread* tp : ThreadsListHandle()) {\n+    if (jvmci_counters_include(tp)) {\n+      for (int i = 0; i < length; i++) {\n+        array[i] += tp->_jvmci_counters[i];\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {\n+  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n+  if (new_counters == NULL) {\n+    return NULL;\n+  }\n+  if (old_counters == NULL) {\n+    old_counters = new_counters;\n+    memset(old_counters, 0, sizeof(jlong) * new_size);\n+  } else {\n+    for (int i = 0; i < MIN2((int) current_size, new_size); i++) {\n+      new_counters[i] = old_counters[i];\n+    }\n+    if (new_size > current_size) {\n+      memset(new_counters + current_size, 0, sizeof(jlong) * (new_size - current_size));\n+    }\n+    FREE_C_HEAP_ARRAY(jlong, old_counters);\n+  }\n+  return new_counters;\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+bool JavaThread::resize_counters(int current_size, int new_size) {\n+  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n+  if (new_counters == NULL) {\n+    return false;\n+  } else {\n+    _jvmci_counters = new_counters;\n+    return true;\n+  }\n+}\n+\n+class VM_JVMCIResizeCounters : public VM_Operation {\n+ private:\n+  int _new_size;\n+  bool _failed;\n+\n+ public:\n+  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n+  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n+  bool allow_nested_vm_operations() const        { return true; }\n+  void doit() {\n+    \/\/ Resize the old thread counters array\n+    jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n+    if (new_counters == NULL) {\n+      _failed = true;\n+      return;\n+    } else {\n+      JavaThread::_jvmci_old_thread_counters = new_counters;\n+    }\n+\n+    \/\/ Now resize each threads array\n+    for (JavaThread* tp : ThreadsListHandle()) {\n+      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {\n+        _failed = true;\n+        break;\n+      }\n+    }\n+    if (!_failed) {\n+      JVMCICounterSize = _new_size;\n+    }\n+  }\n+\n+  bool failed() { return _failed; }\n+};\n+\n+bool JavaThread::resize_all_jvmci_counters(int new_size) {\n+  VM_JVMCIResizeCounters op(new_size);\n+  VMThread::execute(&op);\n+  return !op.failed();\n+}\n+\n+#endif \/\/ INCLUDE_JVMCI\n+\n+#ifdef ASSERT\n+\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n+void JavaThread::check_possible_safepoint() {\n+  if (_no_safepoint_count > 0) {\n+    print_owned_locks();\n+    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n+  }\n+#ifdef CHECK_UNHANDLED_OOPS\n+  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n+  clear_unhandled_oops();\n+#endif \/\/ CHECK_UNHANDLED_OOPS\n+\n+  \/\/ Macos\/aarch64 should be in the right state for safepoint (e.g.\n+  \/\/ deoptimization needs WXWrite).  Crashes caused by the wrong state rarely\n+  \/\/ happens in practice, making such issues hard to find and reproduce.\n+#if defined(__APPLE__) && defined(AARCH64)\n+  if (AssertWXAtThreadSync) {\n+    assert_wx_state(WXWrite);\n+  }\n+#endif\n+}\n+\n+void JavaThread::check_for_valid_safepoint_state() {\n+  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n+  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n+  \/\/ are held.\n+  check_possible_safepoint();\n+\n+  if (thread_state() != _thread_in_vm) {\n+    fatal(\"LEAF method calling lock?\");\n+  }\n+\n+  if (GCALotAtAllSafepoints) {\n+    \/\/ We could enter a safepoint here and thus have a gc\n+    InterfaceSupport::check_gc_alot();\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+\/\/ A JavaThread is a normal Java thread\n+\n+JavaThread::JavaThread() :\n+  \/\/ Initialize fields\n+\n+  _in_asgct(false),\n+  _on_thread_list(false),\n+  DEBUG_ONLY(_java_call_counter(0) COMMA)\n+  _entry_point(nullptr),\n+  _deopt_mark(nullptr),\n+  _deopt_nmethod(nullptr),\n+  _vframe_array_head(nullptr),\n+  _vframe_array_last(nullptr),\n+  _jvmti_deferred_updates(nullptr),\n+  _callee_target(nullptr),\n+  _vm_result(nullptr),\n+  _vm_result_2(nullptr),\n+\n+  _current_pending_monitor(NULL),\n+  _current_pending_monitor_is_from_java(true),\n+  _current_waiting_monitor(NULL),\n+  _active_handles(NULL),\n+  _free_handle_block(NULL),\n+  _Stalled(0),\n+\n+  _monitor_chunks(nullptr),\n+\n+  _suspend_flags(0),\n+\n+  _thread_state(_thread_new),\n+  _saved_exception_pc(nullptr),\n+#ifdef ASSERT\n+  _no_safepoint_count(0),\n+  _visited_for_critical_count(false),\n+#endif\n+\n+  _terminated(_not_terminated),\n+  _in_deopt_handler(0),\n+  _doing_unsafe_access(false),\n+  _do_not_unlock_if_synchronized(false),\n+#if INCLUDE_JVMTI\n+  _carrier_thread_suspended(false),\n+  _is_in_VTMS_transition(false),\n+#ifdef ASSERT\n+  _is_VTMS_transition_disabler(false),\n+#endif\n+#endif\n+  _jni_attach_state(_not_attaching_via_jni),\n+#if INCLUDE_JVMCI\n+  _pending_deoptimization(-1),\n+  _pending_monitorenter(false),\n+  _pending_transfer_to_interpreter(false),\n+  _in_retryable_allocation(false),\n+  _pending_failed_speculation(0),\n+  _jvmci{nullptr},\n+  _libjvmci_runtime(nullptr),\n+  _jvmci_counters(nullptr),\n+  _jvmci_reserved0(0),\n+  _jvmci_reserved1(0),\n+  _jvmci_reserved_oop0(nullptr),\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  _exception_oop(oop()),\n+  _exception_pc(0),\n+  _exception_handler_pc(0),\n+  _is_method_handle_return(0),\n+\n+  _jni_active_critical(0),\n+  _pending_jni_exception_check_fn(nullptr),\n+  _depth_first_number(0),\n+\n+  \/\/ JVMTI PopFrame support\n+  _popframe_condition(popframe_inactive),\n+  _frames_to_pop_failed_realloc(0),\n+\n+  _cont_entry(nullptr),\n+  _cont_fastpath(0),\n+  _cont_fastpath_thread_state(1),\n+  _held_monitor_count(0),\n+\n+  _handshake(this),\n+\n+  _popframe_preserved_args(nullptr),\n+  _popframe_preserved_args_size(0),\n+\n+  _jvmti_thread_state(nullptr),\n+  _interp_only_mode(0),\n+  _should_post_on_exceptions_flag(JNI_FALSE),\n+  _thread_stat(new ThreadStatistics()),\n+\n+  _parker(),\n+\n+  _class_to_be_initialized(nullptr),\n+\n+  _SleepEvent(ParkEvent::Allocate(this))\n+{\n+  set_jni_functions(jni_functions());\n+\n+#if INCLUDE_JVMCI\n+  assert(_jvmci._implicit_exception_pc == nullptr, \"must be\");\n+  if (JVMCICounterSize > 0) {\n+    resize_counters(0, (int) JVMCICounterSize);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  \/\/ Setup safepoint state info for this thread\n+  ThreadSafepointState::create(this);\n+\n+  SafepointMechanism::initialize_header(this);\n+\n+  set_requires_cross_modify_fence(false);\n+\n+  pd_initialize();\n+  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n+}\n+\n+JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n+  if (is_attaching_via_jni) {\n+    _jni_attach_state = _attaching_via_jni;\n+  }\n+}\n+\n+\n+\/\/ interrupt support\n+\n+void JavaThread::interrupt() {\n+  \/\/ All callers should have 'this' thread protected by a\n+  \/\/ ThreadsListHandle so that it cannot terminate and deallocate\n+  \/\/ itself.\n+  debug_only(check_for_dangling_thread_pointer(this);)\n+\n+  \/\/ For Windows _interrupt_event\n+  WINDOWS_ONLY(osthread()->set_interrupted(true);)\n+\n+  \/\/ For Thread.sleep\n+  _SleepEvent->unpark();\n+\n+  \/\/ For JSR166 LockSupport.park\n+  parker()->unpark();\n+\n+  \/\/ For ObjectMonitor and JvmtiRawMonitor\n+  _ParkEvent->unpark();\n+}\n+\n+\n+bool JavaThread::is_interrupted(bool clear_interrupted) {\n+  debug_only(check_for_dangling_thread_pointer(this);)\n+\n+  if (_threadObj.peek() == NULL) {\n+    \/\/ If there is no j.l.Thread then it is impossible to have\n+    \/\/ been interrupted. We can find NULL during VM initialization\n+    \/\/ or when a JNI thread is still in the process of attaching.\n+    \/\/ In such cases this must be the current thread.\n+    assert(this == Thread::current(), \"invariant\");\n+    return false;\n+  }\n+\n+  bool interrupted = java_lang_Thread::interrupted(threadObj());\n+\n+  \/\/ NOTE that since there is no \"lock\" around the interrupt and\n+  \/\/ is_interrupted operations, there is the possibility that the\n+  \/\/ interrupted flag will be \"false\" but that the\n+  \/\/ low-level events will be in the signaled state. This is\n+  \/\/ intentional. The effect of this is that Object.wait() and\n+  \/\/ LockSupport.park() will appear to have a spurious wakeup, which\n+  \/\/ is allowed and not harmful, and the possibility is so rare that\n+  \/\/ it is not worth the added complexity to add yet another lock.\n+  \/\/ For the sleep event an explicit reset is performed on entry\n+  \/\/ to JavaThread::sleep, so there is no early return. It has also been\n+  \/\/ recommended not to put the interrupted flag into the \"event\"\n+  \/\/ structure because it hides the issue.\n+  \/\/ Also, because there is no lock, we must only clear the interrupt\n+  \/\/ state if we are going to report that we were interrupted; otherwise\n+  \/\/ an interrupt that happens just after we read the field would be lost.\n+  if (interrupted && clear_interrupted) {\n+    assert(this == Thread::current(), \"only the current thread can clear\");\n+    java_lang_Thread::set_interrupted(threadObj(), false);\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n+  }\n+\n+  return interrupted;\n+}\n+\n+void JavaThread::block_if_vm_exited() {\n+  if (_terminated == _vm_exited) {\n+    \/\/ _vm_exited is set at safepoint, and Threads_lock is never released\n+    \/\/ we will block here forever.\n+    \/\/ Here we can be doing a jump from a safe state to an unsafe state without\n+    \/\/ proper transition, but it happens after the final safepoint has begun.\n+    set_thread_state(_thread_in_vm);\n+    Threads_lock->lock();\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n+  _jni_attach_state = _not_attaching_via_jni;\n+  set_entry_point(entry_point);\n+  \/\/ Create the native thread itself.\n+  \/\/ %note runtime_23\n+  os::ThreadType thr_type = os::java_thread;\n+  thr_type = entry_point == &CompilerThread::thread_entry ? os::compiler_thread :\n+                                                            os::java_thread;\n+  os::create_thread(this, thr_type, stack_sz);\n+  \/\/ The _osthread may be NULL here because we ran out of memory (too many threads active).\n+  \/\/ We need to throw and OutOfMemoryError - however we cannot do this here because the caller\n+  \/\/ may hold a lock and all locks must be unlocked before throwing the exception (throwing\n+  \/\/ the exception consists of creating the exception object & initializing it, initialization\n+  \/\/ will leave the VM via a JavaCall and then all locks must be unlocked).\n+  \/\/\n+  \/\/ The thread is still suspended when we reach here. Thread must be explicit started\n+  \/\/ by creator! Furthermore, the thread must also explicitly be added to the Threads list\n+  \/\/ by calling Threads:add. The reason why this is not done here, is because the thread\n+  \/\/ object must be fully initialized (take a look at JVM_Start)\n+}\n+\n+JavaThread::~JavaThread() {\n+\n+  \/\/ Ask ServiceThread to release the threadObj OopHandle\n+  ServiceThread::add_oop_handle_release(_threadObj);\n+  ServiceThread::add_oop_handle_release(_vthread);\n+  ServiceThread::add_oop_handle_release(_jvmti_vthread);\n+\n+  \/\/ Return the sleep event to the free list\n+  ParkEvent::Release(_SleepEvent);\n+  _SleepEvent = NULL;\n+\n+  \/\/ Free any remaining  previous UnrollBlock\n+  vframeArray* old_array = vframe_array_last();\n+\n+  if (old_array != NULL) {\n+    Deoptimization::UnrollBlock* old_info = old_array->unroll_block();\n+    old_array->set_unroll_block(NULL);\n+    delete old_info;\n+    delete old_array;\n+  }\n+\n+  JvmtiDeferredUpdates* updates = deferred_updates();\n+  if (updates != NULL) {\n+    \/\/ This can only happen if thread is destroyed before deoptimization occurs.\n+    assert(updates->count() > 0, \"Updates holder not deleted\");\n+    \/\/ free deferred updates.\n+    delete updates;\n+    set_deferred_updates(NULL);\n+  }\n+\n+  \/\/ All Java related clean up happens in exit\n+  ThreadSafepointState::destroy(this);\n+  if (_thread_stat != NULL) delete _thread_stat;\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    FREE_C_HEAP_ARRAY(jlong, _jvmci_counters);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+}\n+\n+\n+\/\/ First JavaThread specific code executed by a new Java thread.\n+void JavaThread::pre_run() {\n+  \/\/ empty - see comments in run()\n+}\n+\n+\/\/ The main routine called by a new Java thread. This isn't overridden\n+\/\/ by subclasses, instead different subclasses define a different \"entry_point\"\n+\/\/ which defines the actual logic for that kind of thread.\n+void JavaThread::run() {\n+  \/\/ initialize thread-local alloc buffer related fields\n+  initialize_tlab();\n+\n+  _stack_overflow_state.create_stack_guard_pages();\n+\n+  cache_global_variables();\n+\n+  \/\/ Thread is now sufficiently initialized to be handled by the safepoint code as being\n+  \/\/ in the VM. Change thread state from _thread_new to _thread_in_vm\n+  assert(this->thread_state() == _thread_new, \"wrong thread state\");\n+  set_thread_state(_thread_in_vm);\n+\n+  \/\/ Before a thread is on the threads list it is always safe, so after leaving the\n+  \/\/ _thread_new we should emit a instruction barrier. The distance to modified code\n+  \/\/ from here is probably far enough, but this is consistent and safe.\n+  OrderAccess::cross_modify_fence();\n+\n+  assert(JavaThread::current() == this, \"sanity check\");\n+  assert(!Thread::current()->owns_locks(), \"sanity check\");\n+\n+  DTRACE_THREAD_PROBE(start, this);\n+\n+  \/\/ This operation might block. We call that after all safepoint checks for a new thread has\n+  \/\/ been completed.\n+  set_active_handles(JNIHandleBlock::allocate_block());\n+\n+  if (JvmtiExport::should_post_thread_life()) {\n+    JvmtiExport::post_thread_start(this);\n+\n+  }\n+\n+  \/\/ We call another function to do the rest so we are sure that the stack addresses used\n+  \/\/ from there will be lower than the stack base just computed.\n+  thread_main_inner();\n+}\n+\n+void JavaThread::thread_main_inner() {\n+  assert(JavaThread::current() == this, \"sanity check\");\n+  assert(_threadObj.peek() != NULL, \"just checking\");\n+\n+  \/\/ Execute thread entry point unless this thread has a pending exception\n+  \/\/ or has been stopped before starting.\n+  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n+  if (!this->has_pending_exception() &&\n+      !java_lang_Thread::is_stillborn(this->threadObj())) {\n+    {\n+      ResourceMark rm(this);\n+      this->set_native_thread_name(this->name());\n+    }\n+    HandleMark hm(this);\n+    this->entry_point()(this, this);\n+  }\n+\n+  DTRACE_THREAD_PROBE(stop, this);\n+\n+  \/\/ Cleanup is handled in post_run()\n+}\n+\n+\/\/ Shared teardown for all JavaThreads\n+void JavaThread::post_run() {\n+  this->exit(false);\n+  this->unregister_thread_stack_with_NMT();\n+  \/\/ Defer deletion to here to ensure 'this' is still referenceable in call_run\n+  \/\/ for any shared tear-down.\n+  this->smr_delete();\n+}\n+\n+static void ensure_join(JavaThread* thread) {\n+  \/\/ We do not need to grab the Threads_lock, since we are operating on ourself.\n+  Handle threadObj(thread, thread->threadObj());\n+  assert(threadObj.not_null(), \"java thread object must exist\");\n+  ObjectLocker lock(threadObj, thread);\n+  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  thread->clear_pending_exception();\n+  \/\/ Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.\n+  java_lang_Thread::set_thread_status(threadObj(), JavaThreadStatus::TERMINATED);\n+  \/\/ Clear the native thread instance - this makes isAlive return false and allows the join()\n+  \/\/ to complete once we've done the notify_all below\n+  java_lang_Thread::set_thread(threadObj(), NULL);\n+  lock.notify_all(thread);\n+  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  thread->clear_pending_exception();\n+}\n+\n+static bool is_daemon(oop threadObj) {\n+  return (threadObj != NULL && java_lang_Thread::is_daemon(threadObj));\n+}\n+\n+\/\/ For any new cleanup additions, please check to see if they need to be applied to\n+\/\/ cleanup_failed_attach_current_thread as well.\n+void JavaThread::exit(bool destroy_vm, ExitType exit_type) {\n+  assert(this == JavaThread::current(), \"thread consistency check\");\n+  assert(!is_exiting(), \"should not be exiting or terminated already\");\n+\n+  elapsedTimer _timer_exit_phase1;\n+  elapsedTimer _timer_exit_phase2;\n+  elapsedTimer _timer_exit_phase3;\n+  elapsedTimer _timer_exit_phase4;\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase1.start();\n+  }\n+\n+  HandleMark hm(this);\n+  Handle uncaught_exception(this, this->pending_exception());\n+  this->clear_pending_exception();\n+  Handle threadObj(this, this->threadObj());\n+  assert(threadObj.not_null(), \"Java thread object should be created\");\n+\n+  if (!destroy_vm) {\n+    if (uncaught_exception.not_null()) {\n+      EXCEPTION_MARK;\n+      \/\/ Call method Thread.dispatchUncaughtException().\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::dispatchUncaughtException_name(),\n+                              vmSymbols::throwable_void_signature(),\n+                              uncaught_exception,\n+                              THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        ResourceMark rm(this);\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"\\nException: %s thrown from the UncaughtExceptionHandler\"\n+                    \" in thread \\\"%s\\\"\\n\",\n+                    pending_exception()->klass()->external_name(),\n+                    name());\n+        CLEAR_PENDING_EXCEPTION;\n+      }\n+    }\n+\n+    if (!is_Compiler_thread()) {\n+      \/\/ We have finished executing user-defined Java code and now have to do the\n+      \/\/ implementation specific clean-up by calling Thread.exit(). We prevent any\n+      \/\/ asynchronous exceptions from being delivered while in Thread.exit()\n+      \/\/ to ensure the clean-up is not corrupted.\n+      NoAsyncExceptionDeliveryMark _no_async(this);\n+\n+      EXCEPTION_MARK;\n+      JavaValue result(T_VOID);\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::exit_method_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n+\n+    \/\/ notify JVMTI\n+    if (JvmtiExport::should_post_thread_life()) {\n+      JvmtiExport::post_thread_end(this);\n+    }\n+  } else {\n+    \/\/ before_exit() has already posted JVMTI THREAD_END events\n+  }\n+\n+  \/\/ Cleanup any pending async exception now since we cannot access oops after\n+  \/\/ BarrierSet::barrier_set()->on_thread_detach() has been executed.\n+  if (has_async_exception_condition()) {\n+    handshake_state()->clean_async_exception_operation();\n+  }\n+\n+  \/\/ The careful dance between thread suspension and exit is handled here.\n+  \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n+  \/\/ we can just put in the exiting state and it will be correctly handled.\n+  \/\/ Also, no more async exceptions will be added to the queue after this point.\n+  set_terminated(_thread_exiting);\n+  ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase1.stop();\n+    _timer_exit_phase2.start();\n+  }\n+\n+  \/\/ Capture daemon status before the thread is marked as terminated.\n+  bool daemon = is_daemon(threadObj());\n+\n+  \/\/ Notify waiters on thread object. This has to be done after exit() is called\n+  \/\/ on the thread (if the thread is the last thread in a daemon ThreadGroup the\n+  \/\/ group should have the destroyed bit set before waiters are notified).\n+  ensure_join(this);\n+  assert(!this->has_pending_exception(), \"ensure_join should have cleared\");\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase2.stop();\n+    _timer_exit_phase3.start();\n+  }\n+  \/\/ 6282335 JNI DetachCurrentThread spec states that all Java monitors\n+  \/\/ held by this thread must be released. The spec does not distinguish\n+  \/\/ between JNI-acquired and regular Java monitors. We can only see\n+  \/\/ regular Java monitors here if monitor enter-exit matching is broken.\n+  \/\/\n+  \/\/ ensure_join() ignores IllegalThreadStateExceptions, and so does\n+  \/\/ ObjectSynchronizer::release_monitors_owned_by_thread().\n+  if (exit_type == jni_detach) {\n+    \/\/ Sanity check even though JNI DetachCurrentThread() would have\n+    \/\/ returned JNI_ERR if there was a Java frame. JavaThread exit\n+    \/\/ should be done executing Java code by the time we get here.\n+    assert(!this->has_last_Java_frame(),\n+           \"should not have a Java frame when detaching or exiting\");\n+    ObjectSynchronizer::release_monitors_owned_by_thread(this);\n+    assert(!this->has_pending_exception(), \"release_monitors should have cleared\");\n+  }\n+\n+  assert(!Continuations::enabled() || this->held_monitor_count() == 0, \"held monitor count should be zero\");\n+\n+  \/\/ These things needs to be done while we are still a Java Thread. Make sure that thread\n+  \/\/ is in a consistent state, in case GC happens\n+  JFR_ONLY(Jfr::on_thread_exit(this);)\n+\n+  if (active_handles() != NULL) {\n+    JNIHandleBlock* block = active_handles();\n+    set_active_handles(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  if (free_handle_block() != NULL) {\n+    JNIHandleBlock* block = free_handle_block();\n+    set_free_handle_block(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  \/\/ These have to be removed while this is still a valid thread.\n+  _stack_overflow_state.remove_stack_guard_pages();\n+\n+  if (UseTLAB) {\n+    tlab().retire();\n+  }\n+\n+  if (JvmtiEnv::environments_might_exist()) {\n+    JvmtiExport::cleanup_thread(this);\n+  }\n+\n+  \/\/ We need to cache the thread name for logging purposes below as once\n+  \/\/ we have called on_thread_detach this thread must not access any oops.\n+  char* thread_name = NULL;\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    ResourceMark rm(this);\n+    thread_name = os::strdup(name());\n+  }\n+\n+  log_info(os, thread)(\"JavaThread %s (tid: \" UINTX_FORMAT \").\",\n+    exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n+    os::current_thread_id());\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase3.stop();\n+    _timer_exit_phase4.start();\n+  }\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    if (jvmci_counters_include(this)) {\n+      for (int i = 0; i < JVMCICounterSize; i++) {\n+        _jvmci_old_thread_counters[i] += _jvmci_counters[i];\n+      }\n+    }\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  \/\/ Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread.\n+  \/\/ We call BarrierSet::barrier_set()->on_thread_detach() here so no touching of oops after this point.\n+  Threads::remove(this, daemon);\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase4.stop();\n+    log_debug(os, thread, timer)(\"name='%s'\"\n+                                 \", exit-phase1=\" JLONG_FORMAT\n+                                 \", exit-phase2=\" JLONG_FORMAT\n+                                 \", exit-phase3=\" JLONG_FORMAT\n+                                 \", exit-phase4=\" JLONG_FORMAT,\n+                                 thread_name,\n+                                 _timer_exit_phase1.milliseconds(),\n+                                 _timer_exit_phase2.milliseconds(),\n+                                 _timer_exit_phase3.milliseconds(),\n+                                 _timer_exit_phase4.milliseconds());\n+    os::free(thread_name);\n+  }\n+}\n+\n+void JavaThread::cleanup_failed_attach_current_thread(bool is_daemon) {\n+  if (active_handles() != NULL) {\n+    JNIHandleBlock* block = active_handles();\n+    set_active_handles(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  if (free_handle_block() != NULL) {\n+    JNIHandleBlock* block = free_handle_block();\n+    set_free_handle_block(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  \/\/ These have to be removed while this is still a valid thread.\n+  _stack_overflow_state.remove_stack_guard_pages();\n+\n+  if (UseTLAB) {\n+    tlab().retire();\n+  }\n+\n+  Threads::remove(this, is_daemon);\n+  this->smr_delete();\n+}\n+\n+JavaThread* JavaThread::active() {\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    return JavaThread::cast(thread);\n+  } else {\n+    assert(thread->is_VM_thread(), \"this must be a vm thread\");\n+    VM_Operation* op = ((VMThread*) thread)->vm_operation();\n+    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n+    return ret;\n+  }\n+}\n+\n+bool JavaThread::is_lock_owned(address adr) const {\n+  if (Thread::is_lock_owned(adr)) return true;\n+\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    if (chunk->contains(adr)) return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool JavaThread::is_lock_owned_current(address adr) const {\n+  address stack_end = _stack_base - _stack_size;\n+  const ContinuationEntry* ce = vthread_continuation();\n+  address stack_base = ce != nullptr ? (address)ce->entry_sp() : _stack_base;\n+  if (stack_base > adr && adr >= stack_end) {\n+    return true;\n+  }\n+\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    if (chunk->contains(adr)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool JavaThread::is_lock_owned_carrier(address adr) const {\n+  assert(is_vthread_mounted(), \"\");\n+  address stack_end = _stack_base - _stack_size;\n+  address stack_base = (address)vthread_continuation()->entry_sp();\n+  return stack_base > adr && adr >= stack_end;\n+}\n+\n+oop JavaThread::exception_oop() const {\n+  return Atomic::load(&_exception_oop);\n+}\n+\n+void JavaThread::set_exception_oop(oop o) {\n+  Atomic::store(&_exception_oop, o);\n+}\n+\n+void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {\n+  chunk->set_next(monitor_chunks());\n+  set_monitor_chunks(chunk);\n+}\n+\n+void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {\n+  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n+  if (monitor_chunks() == chunk) {\n+    set_monitor_chunks(chunk->next());\n+  } else {\n+    MonitorChunk* prev = monitor_chunks();\n+    while (prev->next() != chunk) prev = prev->next();\n+    prev->set_next(chunk->next());\n+  }\n+}\n+\n+void JavaThread::handle_special_runtime_exit_condition() {\n+  if (is_obj_deopt_suspend()) {\n+    frame_anchor()->make_walkable();\n+    wait_for_object_deoptimization();\n+  }\n+  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n+}\n+\n+\n+\/\/ Asynchronous exceptions support\n+\/\/\n+void JavaThread::handle_async_exception(oop java_throwable) {\n+  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n+  assert(!is_at_poll_safepoint(), \"should have never called this method\");\n+\n+  if (has_last_Java_frame()) {\n+    frame f = last_frame();\n+    if (f.is_runtime_frame()) {\n+      \/\/ If the topmost frame is a runtime stub, then we are calling into\n+      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n+      \/\/ must deoptimize the caller before continuing, as the compiled exception\n+      \/\/ handler table may not be valid.\n+      RegisterMap reg_map(this, false);\n+      frame compiled_frame = f.sender(&reg_map);\n+      if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n+        Deoptimization::deoptimize(this, compiled_frame);\n+      }\n+    }\n+  }\n+\n+  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n+  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n+\n+    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+    set_pending_exception(java_throwable, __FILE__, __LINE__);\n+\n+    \/\/ Clear any extent-local bindings on ThreadDeath\n+    set_extentLocalCache(NULL);\n+    oop threadOop = threadObj();\n+    assert(threadOop != NULL, \"must be\");\n+    java_lang_Thread::clear_extentLocalBindings(threadOop);\n+\n+    LogTarget(Info, exceptions) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(lt);\n+      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+      if (has_last_Java_frame()) {\n+        frame f = last_frame();\n+        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n+      }\n+      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n+    }\n+  }\n+}\n+\n+void JavaThread::install_async_exception(AsyncExceptionHandshake* aeh) {\n+  \/\/ Do not throw asynchronous exceptions against the compiler thread\n+  \/\/ or if the thread is already exiting.\n+  if (!can_call_java() || is_exiting()) {\n+    delete aeh;\n+    return;\n+  }\n+\n+  \/\/ Don't install a new pending async exception if there is already\n+  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n+  \/\/ wait()\/sleep()\/park() and return.\n+  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n+    java_lang_Thread::set_interrupted(threadObj(), true);\n+    this->interrupt();\n+    delete aeh;\n+    return;\n+  }\n+\n+  oop exception = aeh->exception();\n+  Handshake::execute(aeh, this);  \/\/ Install asynchronous handshake\n+\n+  ResourceMark rm;\n+  if (log_is_enabled(Info, exceptions)) {\n+    log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n+                         InstanceKlass::cast(exception->klass())->external_name());\n+  }\n+  \/\/ for AbortVMOnException flag\n+  Exceptions::debug_check_abort(exception->klass()->external_name());\n+\n+  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n+  java_lang_Thread::set_interrupted(threadObj(), true);\n+  this->interrupt();\n+}\n+\n+class InstallAsyncExceptionHandshake : public HandshakeClosure {\n+  AsyncExceptionHandshake* _aeh;\n+public:\n+  InstallAsyncExceptionHandshake(AsyncExceptionHandshake* aeh) :\n+    HandshakeClosure(\"InstallAsyncException\"), _aeh(aeh) {}\n+  ~InstallAsyncExceptionHandshake() {\n+    \/\/ If InstallAsyncExceptionHandshake was never executed we need to clean up _aeh.\n+    delete _aeh;\n+  }\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = JavaThread::cast(thr);\n+    target->install_async_exception(_aeh);\n+    _aeh = nullptr;\n+  }\n+};\n+\n+void JavaThread::send_async_exception(JavaThread* target, oop java_throwable) {\n+  OopHandle e(Universe::vm_global(), java_throwable);\n+  InstallAsyncExceptionHandshake iaeh(new AsyncExceptionHandshake(e));\n+  Handshake::execute(&iaeh, target);\n+}\n+\n+#if INCLUDE_JVMTI\n+void JavaThread::set_is_in_VTMS_transition(bool val) {\n+  _is_in_VTMS_transition = val;\n+}\n+\n+#ifdef ASSERT\n+void JavaThread::set_is_VTMS_transition_disabler(bool val) {\n+  _is_VTMS_transition_disabler = val;\n+}\n+#endif\n+#endif\n+\n+\/\/ External suspension mechanism.\n+\/\/\n+\/\/ Guarantees on return (for a valid target thread):\n+\/\/   - Target thread will not execute any new bytecode.\n+\/\/   - Target thread will not enter any new monitors.\n+\/\/\n+bool JavaThread::java_suspend() {\n+#if INCLUDE_JVMTI\n+  \/\/ Suspending a JavaThread in VTMS transition or disabling VTMS transitions can cause deadlocks.\n+  assert(!is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n+  assert(!is_VTMS_transition_disabler(), \"no suspend allowed for VTMS transition disablers\");\n+#endif\n+\n+  guarantee(Thread::is_JavaThread_protected(\/* target *\/ this),\n+            \"target JavaThread is not protected in calling context.\");\n+  return this->handshake_state()->suspend();\n+}\n+\n+bool JavaThread::java_resume() {\n+  guarantee(Thread::is_JavaThread_protected_by_TLH(\/* target *\/ this),\n+            \"missing ThreadsListHandle in calling context.\");\n+  return this->handshake_state()->resume();\n+}\n+\n+\/\/ Wait for another thread to perform object reallocation and relocking on behalf of\n+\/\/ this thread. The current thread is required to change to _thread_blocked in order\n+\/\/ to be seen to be safepoint\/handshake safe whilst suspended and only after becoming\n+\/\/ handshake safe, the other thread can complete the handshake used to synchronize\n+\/\/ with this thread and then perform the reallocation and relocking.\n+\/\/ See EscapeBarrier::sync_and_suspend_*()\n+\n+void JavaThread::wait_for_object_deoptimization() {\n+  assert(!has_last_Java_frame() || frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(this == Thread::current(), \"invariant\");\n+\n+  bool spin_wait = os::is_MP();\n+  do {\n+    ThreadBlockInVM tbivm(this, true \/* allow_suspend *\/);\n+    \/\/ Wait for object deoptimization if requested.\n+    if (spin_wait) {\n+      \/\/ A single deoptimization is typically very short. Microbenchmarks\n+      \/\/ showed 5% better performance when spinning.\n+      const uint spin_limit = 10 * SpinYield::default_spin_limit;\n+      SpinYield spin(spin_limit);\n+      for (uint i = 0; is_obj_deopt_suspend() && i < spin_limit; i++) {\n+        spin.wait();\n+      }\n+      \/\/ Spin just once\n+      spin_wait = false;\n+    } else {\n+      MonitorLocker ml(this, EscapeBarrier_lock, Monitor::_no_safepoint_check_flag);\n+      if (is_obj_deopt_suspend()) {\n+        ml.wait();\n+      }\n+    }\n+    \/\/ A handshake for obj. deoptimization suspend could have been processed so\n+    \/\/ we must check after processing.\n+  } while (is_obj_deopt_suspend());\n+}\n+\n+#ifdef ASSERT\n+\/\/ Verify the JavaThread has not yet been published in the Threads::list, and\n+\/\/ hence doesn't need protection from concurrent access at this stage.\n+void JavaThread::verify_not_published() {\n+  \/\/ Cannot create a ThreadsListHandle here and check !tlh.includes(this)\n+  \/\/ since an unpublished JavaThread doesn't participate in the\n+  \/\/ Thread-SMR protocol for keeping a ThreadsList alive.\n+  assert(!on_thread_list(), \"JavaThread shouldn't have been published yet!\");\n+}\n+#endif\n+\n+\/\/ Slow path when the native==>Java barriers detect a safepoint\/handshake is\n+\/\/ pending, when _suspend_flags is non-zero or when we need to process a stack\n+\/\/ watermark. Also check for pending async exceptions (except unsafe access error).\n+\/\/ Note only the native==>Java barriers can call this function when thread state\n+\/\/ is _thread_in_native_trans.\n+void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {\n+  assert(thread->thread_state() == _thread_in_native_trans, \"wrong state\");\n+  assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native->Java transition\");\n+\n+  thread->set_thread_state(_thread_in_vm);\n+\n+  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n+  SafepointMechanism::process_if_requested_with_exit_check(thread, true \/* check asyncs *\/);\n+\n+  \/\/ After returning from native, it could be that the stack frames are not\n+  \/\/ yet safe to use. We catch such situations in the subsequent stack watermark\n+  \/\/ barrier, which will trap unsafe stack frames.\n+  StackWatermarkSet::before_unwind(thread);\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Deoptimization\n+\/\/ Function for testing deoptimization\n+void JavaThread::deoptimize() {\n+  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n+  bool deopt = false;           \/\/ Dump stack only if a deopt actually happens.\n+  bool only_at = strlen(DeoptimizeOnlyAt) > 0;\n+  \/\/ Iterate over all frames in the thread and deoptimize\n+  for (; !fst.is_done(); fst.next()) {\n+    if (fst.current()->can_be_deoptimized()) {\n+\n+      if (only_at) {\n+        \/\/ Deoptimize only at particular bcis.  DeoptimizeOnlyAt\n+        \/\/ consists of comma or carriage return separated numbers so\n+        \/\/ search for the current bci in that string.\n+        address pc = fst.current()->pc();\n+        nmethod* nm =  (nmethod*) fst.current()->cb();\n+        ScopeDesc* sd = nm->scope_desc_at(pc);\n+        char buffer[8];\n+        jio_snprintf(buffer, sizeof(buffer), \"%d\", sd->bci());\n+        size_t len = strlen(buffer);\n+        const char * found = strstr(DeoptimizeOnlyAt, buffer);\n+        while (found != NULL) {\n+          if ((found[len] == ',' || found[len] == '\\n' || found[len] == '\\0') &&\n+              (found == DeoptimizeOnlyAt || found[-1] == ',' || found[-1] == '\\n')) {\n+            \/\/ Check that the bci found is bracketed by terminators.\n+            break;\n+          }\n+          found = strstr(found + 1, buffer);\n+        }\n+        if (!found) {\n+          continue;\n+        }\n+      }\n+\n+      if (DebugDeoptimization && !deopt) {\n+        deopt = true; \/\/ One-time only print before deopt\n+        tty->print_cr(\"[BEFORE Deoptimization]\");\n+        trace_frames();\n+        trace_stack();\n+      }\n+      Deoptimization::deoptimize(this, *fst.current());\n+    }\n+  }\n+\n+  if (DebugDeoptimization && deopt) {\n+    tty->print_cr(\"[AFTER Deoptimization]\");\n+    trace_frames();\n+  }\n+}\n+\n+\n+\/\/ Make zombies\n+void JavaThread::make_zombies() {\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    if (fst.current()->can_be_deoptimized()) {\n+      \/\/ it is a Java nmethod\n+      nmethod* nm = CodeCache::find_nmethod(fst.current()->pc());\n+      nm->make_not_entrant();\n+    }\n+  }\n+}\n+#endif \/\/ PRODUCT\n+\n+\n+void JavaThread::deoptimize_marked_methods() {\n+  if (!has_last_Java_frame()) return;\n+  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n+  for (; !fst.is_done(); fst.next()) {\n+    if (fst.current()->should_be_deoptimized()) {\n+      Deoptimization::deoptimize(this, *fst.current());\n+    }\n+  }\n+}\n+\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%s, java_call_counter=%d\",\n+         has_last_Java_frame() ? \"true\" : \"false\", java_call_counter());\n+}\n+#endif\n+\n+\/\/ Push on a new block of JNI handles.\n+void JavaThread::push_jni_handle_block() {\n+  \/\/ Allocate a new block for JNI handles.\n+  \/\/ Inlined code from jni_PushLocalFrame()\n+  JNIHandleBlock* old_handles = active_handles();\n+  JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(this);\n+  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n+  new_handles->set_pop_frame_link(old_handles);  \/\/ make sure java handles get gc'd.\n+  set_active_handles(new_handles);\n+}\n+\n+\/\/ Pop off the current block of JNI handles.\n+void JavaThread::pop_jni_handle_block() {\n+  \/\/ Release our JNI handle block\n+  JNIHandleBlock* old_handles = active_handles();\n+  JNIHandleBlock* new_handles = old_handles->pop_frame_link();\n+  assert(new_handles != nullptr, \"should never set active handles to null\");\n+  set_active_handles(new_handles);\n+  old_handles->set_pop_frame_link(NULL);\n+  JNIHandleBlock::release_block(old_handles, this);\n+}\n+\n+void JavaThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  \/\/ Verify that the deferred card marks have been flushed.\n+  assert(deferred_card_mark().is_empty(), \"Should be empty during GC\");\n+\n+  \/\/ Traverse the GCHandles\n+  Thread::oops_do_no_frames(f, cf);\n+\n+  if (active_handles() != NULL) {\n+    active_handles()->oops_do(f);\n+  }\n+\n+  DEBUG_ONLY(verify_frame_info();)\n+\n+  if (has_last_Java_frame()) {\n+    \/\/ Traverse the monitor chunks\n+    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+      chunk->oops_do(f);\n+    }\n+  }\n+\n+  assert(vframe_array_head() == NULL, \"deopt in progress at a safepoint!\");\n+  \/\/ If we have deferred set_locals there might be oops waiting to be\n+  \/\/ written\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(this);\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      list->at(i)->oops_do(f);\n+    }\n+  }\n+\n+  \/\/ Traverse instance variables at the end since the GC may be moving things\n+  \/\/ around using this function\n+  f->do_oop((oop*) &_vm_result);\n+  f->do_oop((oop*) &_exception_oop);\n+#if INCLUDE_JVMCI\n+  f->do_oop((oop*) &_jvmci_reserved_oop0);\n+#endif\n+\n+  if (jvmti_thread_state() != NULL) {\n+    jvmti_thread_state()->oops_do(f, cf);\n+  }\n+}\n+\n+void JavaThread::oops_do_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  if (!has_last_Java_frame()) {\n+    return;\n+  }\n+  \/\/ Finish any pending lazy GC activity for the frames\n+  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n+  \/\/ Traverse the execution stack\n+  for (StackFrameStream fst(this, true \/* update *\/, false \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    fst.current()->oops_do(f, cf, fst.register_map());\n+  }\n+}\n+\n+#ifdef ASSERT\n+void JavaThread::verify_states_for_handshake() {\n+  \/\/ This checks that the thread has a correct frame state during a handshake.\n+  verify_frame_info();\n+}\n+#endif\n+\n+void JavaThread::nmethods_do(CodeBlobClosure* cf) {\n+  DEBUG_ONLY(verify_frame_info();)\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n+\n+  if (has_last_Java_frame()) {\n+    \/\/ Traverse the execution stack\n+    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+      fst.current()->nmethods_do(cf);\n+    }\n+  }\n+\n+  if (jvmti_thread_state() != NULL) {\n+    jvmti_thread_state()->nmethods_do(cf);\n+  }\n+}\n+\n+void JavaThread::metadata_do(MetadataClosure* f) {\n+  if (has_last_Java_frame()) {\n+    \/\/ Traverse the execution stack to call f() on the methods in the stack\n+    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+      fst.current()->metadata_do(f);\n+    }\n+  } else if (is_Compiler_thread()) {\n+    \/\/ need to walk ciMetadata in current compile tasks to keep alive.\n+    CompilerThread* ct = (CompilerThread*)this;\n+    if (ct->env() != NULL) {\n+      ct->env()->metadata_do(f);\n+    }\n+    CompileTask* task = ct->task();\n+    if (task != NULL) {\n+      task->metadata_do(f);\n+    }\n+  }\n+}\n+\n+\/\/ Printing\n+const char* _get_thread_state_name(JavaThreadState _thread_state) {\n+  switch (_thread_state) {\n+  case _thread_uninitialized:     return \"_thread_uninitialized\";\n+  case _thread_new:               return \"_thread_new\";\n+  case _thread_new_trans:         return \"_thread_new_trans\";\n+  case _thread_in_native:         return \"_thread_in_native\";\n+  case _thread_in_native_trans:   return \"_thread_in_native_trans\";\n+  case _thread_in_vm:             return \"_thread_in_vm\";\n+  case _thread_in_vm_trans:       return \"_thread_in_vm_trans\";\n+  case _thread_in_Java:           return \"_thread_in_Java\";\n+  case _thread_in_Java_trans:     return \"_thread_in_Java_trans\";\n+  case _thread_blocked:           return \"_thread_blocked\";\n+  case _thread_blocked_trans:     return \"_thread_blocked_trans\";\n+  default:                        return \"unknown thread state\";\n+  }\n+}\n+\n+void JavaThread::print_thread_state_on(outputStream *st) const {\n+  st->print_cr(\"   JavaThread state: %s\", _get_thread_state_name(_thread_state));\n+}\n+\n+const char* JavaThread::thread_state_name() const {\n+  return _get_thread_state_name(_thread_state);\n+}\n+\n+\/\/ Called by Threads::print() for VM_PrintThreads operation\n+void JavaThread::print_on(outputStream *st, bool print_extended_info) const {\n+  st->print_raw(\"\\\"\");\n+  st->print_raw(name());\n+  st->print_raw(\"\\\" \");\n+  oop thread_oop = threadObj();\n+  if (thread_oop != NULL) {\n+    st->print(\"#\" INT64_FORMAT \" [%ld] \", (int64_t)java_lang_Thread::thread_id(thread_oop), (long) osthread()->thread_id());\n+    if (java_lang_Thread::is_daemon(thread_oop))  st->print(\"daemon \");\n+    st->print(\"prio=%d \", java_lang_Thread::priority(thread_oop));\n+  }\n+  Thread::print_on(st, print_extended_info);\n+  \/\/ print guess for valid stack memory region (assume 4K pages); helps lock debugging\n+  st->print_cr(\"[\" INTPTR_FORMAT \"]\", (intptr_t)last_Java_sp() & ~right_n_bits(12));\n+  if (thread_oop != NULL) {\n+    if (is_vthread_mounted()) {\n+      oop vt = vthread();\n+      assert(vt != NULL, \"\");\n+      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n+    } else {\n+      st->print_cr(\"   java.lang.Thread.State: %s\", java_lang_Thread::thread_status_name(thread_oop));\n+    }\n+  }\n+#ifndef PRODUCT\n+  _safepoint_state->print_on(st);\n+#endif \/\/ PRODUCT\n+  if (is_Compiler_thread()) {\n+    CompileTask *task = ((CompilerThread*)this)->task();\n+    if (task != NULL) {\n+      st->print(\"   Compiling: \");\n+      task->print(st, NULL, true, false);\n+    } else {\n+      st->print(\"   No compile task\");\n+    }\n+    st->cr();\n+  }\n+}\n+\n+void JavaThread::print() const { print_on(tty); }\n+\n+void JavaThread::print_name_on_error(outputStream* st, char *buf, int buflen) const {\n+  st->print(\"%s\", get_thread_name_string(buf, buflen));\n+}\n+\n+\/\/ Called by fatal error handler. The difference between this and\n+\/\/ JavaThread::print() is that we can't grab lock or allocate memory.\n+void JavaThread::print_on_error(outputStream* st, char *buf, int buflen) const {\n+  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n+  oop thread_obj = threadObj();\n+  if (thread_obj != NULL) {\n+    if (java_lang_Thread::is_daemon(thread_obj)) st->print(\" daemon\");\n+  }\n+  st->print(\" [\");\n+  st->print(\"%s\", _get_thread_state_name(_thread_state));\n+  if (osthread()) {\n+    st->print(\", id=%d\", osthread()->thread_id());\n+  }\n+  st->print(\", stack(\" PTR_FORMAT \",\" PTR_FORMAT \")\",\n+            p2i(stack_end()), p2i(stack_base()));\n+  st->print(\"]\");\n+\n+  ThreadsSMRSupport::print_info_on(this, st);\n+  return;\n+}\n+\n+\n+\/\/ Verification\n+\n+void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n+  \/\/ ignore if there is no stack\n+  if (!has_last_Java_frame()) return;\n+  \/\/ traverse the stack frames. Starts from top frame.\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    frame* fr = fst.current();\n+    f(fr, fst.register_map());\n+  }\n+}\n+\n+static void frame_verify(frame* f, const RegisterMap *map) { f->verify(map); }\n+\n+void JavaThread::verify() {\n+  \/\/ Verify oops in the thread.\n+  oops_do(&VerifyOopClosure::verify_oop, NULL);\n+\n+  \/\/ Verify the stack frames.\n+  frames_do(frame_verify);\n+}\n+\n+\/\/ CR 6300358 (sub-CR 2137150)\n+\/\/ Most callers of this method assume that it can't return NULL but a\n+\/\/ thread may not have a name whilst it is in the process of attaching to\n+\/\/ the VM - see CR 6412693, and there are places where a JavaThread can be\n+\/\/ seen prior to having its threadObj set (e.g., JNI attaching threads and\n+\/\/ if vm exit occurs during initialization). These cases can all be accounted\n+\/\/ for such that this method never returns NULL.\n+const char* JavaThread::name() const  {\n+  if (Thread::is_JavaThread_protected(\/* target *\/ this)) {\n+    \/\/ The target JavaThread is protected so get_thread_name_string() is safe:\n+    return get_thread_name_string();\n+  }\n+\n+  \/\/ The target JavaThread is not protected so we return the default:\n+  return Thread::name();\n+}\n+\n+\/\/ Returns a non-NULL representation of this thread's name, or a suitable\n+\/\/ descriptive string if there is no set name.\n+const char* JavaThread::get_thread_name_string(char* buf, int buflen) const {\n+  const char* name_str;\n+  oop thread_obj = threadObj();\n+  if (thread_obj != NULL) {\n+    oop name = java_lang_Thread::name(thread_obj);\n+    if (name != NULL) {\n+      if (buf == NULL) {\n+        name_str = java_lang_String::as_utf8_string(name);\n+      } else {\n+        name_str = java_lang_String::as_utf8_string(name, buf, buflen);\n+      }\n+    } else if (is_attaching_via_jni()) { \/\/ workaround for 6412693 - see 6404306\n+      name_str = \"<no-name - thread is attaching>\";\n+    } else {\n+      name_str = \"<un-named>\";\n+    }\n+  } else {\n+    name_str = Thread::name();\n+  }\n+  assert(name_str != NULL, \"unexpected NULL thread name\");\n+  return name_str;\n+}\n+\n+\/\/ Helper to extract the name from the thread oop for logging.\n+const char* JavaThread::name_for(oop thread_obj) {\n+  assert(thread_obj != NULL, \"precondition\");\n+  oop name = java_lang_Thread::name(thread_obj);\n+  const char* name_str;\n+  if (name != NULL) {\n+    name_str = java_lang_String::as_utf8_string(name);\n+  } else {\n+    name_str = \"<un-named>\";\n+  }\n+  return name_str;\n+}\n+\n+void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {\n+\n+  assert(Threads_lock->owner() == Thread::current(), \"must have threads lock\");\n+  assert(NoPriority <= prio && prio <= MaxPriority, \"sanity check\");\n+  \/\/ Link Java Thread object <-> C++ Thread\n+\n+  \/\/ Get the C++ thread object (an oop) from the JNI handle (a jthread)\n+  \/\/ and put it into a new Handle.  The Handle \"thread_oop\" can then\n+  \/\/ be used to pass the C++ thread object to other methods.\n+\n+  \/\/ Set the Java level thread object (jthread) field of the\n+  \/\/ new thread (a JavaThread *) to C++ thread object using the\n+  \/\/ \"thread_oop\" handle.\n+\n+  \/\/ Set the thread field (a JavaThread *) of the\n+  \/\/ oop representing the java_lang_Thread to the new thread (a JavaThread *).\n+\n+  Handle thread_oop(Thread::current(),\n+                    JNIHandles::resolve_non_null(jni_thread));\n+  assert(InstanceKlass::cast(thread_oop->klass())->is_linked(),\n+         \"must be initialized\");\n+  set_threadOopHandles(thread_oop());\n+  java_lang_Thread::set_thread(thread_oop(), this);\n+\n+  if (prio == NoPriority) {\n+    prio = java_lang_Thread::priority(thread_oop());\n+    assert(prio != NoPriority, \"A valid priority should be present\");\n+  }\n+\n+  \/\/ Push the Java priority down to the native thread; needs Threads_lock\n+  Thread::set_priority(this, prio);\n+\n+  \/\/ Add the new thread to the Threads list and set it in motion.\n+  \/\/ We must have threads lock in order to call Threads::add.\n+  \/\/ It is crucial that we do not block before the thread is\n+  \/\/ added to the Threads list for if a GC happens, then the java_thread oop\n+  \/\/ will not be visited by GC.\n+  Threads::add(this);\n+}\n+\n+oop JavaThread::current_park_blocker() {\n+  \/\/ Support for JSR-166 locks\n+  oop thread_oop = threadObj();\n+  if (thread_oop != NULL) {\n+    return java_lang_Thread::park_blocker(thread_oop);\n+  }\n+  return NULL;\n+}\n+\n+\n+void JavaThread::print_stack_on(outputStream* st) {\n+  if (!has_last_Java_frame()) return;\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  RegisterMap reg_map(this, true, true);\n+  vframe* start_vf = platform_thread_last_java_vframe(&reg_map);\n+  int count = 0;\n+  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+    if (f->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(f);\n+      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());\n+\n+      \/\/ Print out lock information\n+      if (JavaMonitorsInStackTrace) {\n+        jvf->print_lock_info_on(st, count);\n+      }\n+    } else {\n+      \/\/ Ignore non-Java frames\n+    }\n+\n+    \/\/ Bail-out case for too deep stacks if MaxJavaStackTraceDepth > 0\n+    count++;\n+    if (MaxJavaStackTraceDepth > 0 && MaxJavaStackTraceDepth == count) return;\n+  }\n+}\n+\n+#if INCLUDE_JVMTI\n+\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n+JvmtiThreadState* JavaThread::rebind_to_jvmti_thread_state_of(oop thread_oop) {\n+  set_jvmti_vthread(thread_oop);\n+\n+  \/\/ unbind current JvmtiThreadState from JavaThread\n+  JvmtiThreadState::unbind_from(jvmti_thread_state(), this);\n+\n+  \/\/ bind new JvmtiThreadState to JavaThread\n+  JvmtiThreadState::bind_to(java_lang_Thread::jvmti_thread_state(thread_oop), this);\n+\n+  return jvmti_thread_state();\n+}\n+#endif\n+\n+\/\/ JVMTI PopFrame support\n+void JavaThread::popframe_preserve_args(ByteSize size_in_bytes, void* start) {\n+  assert(_popframe_preserved_args == NULL, \"should not wipe out old PopFrame preserved arguments\");\n+  if (in_bytes(size_in_bytes) != 0) {\n+    _popframe_preserved_args = NEW_C_HEAP_ARRAY(char, in_bytes(size_in_bytes), mtThread);\n+    _popframe_preserved_args_size = in_bytes(size_in_bytes);\n+    Copy::conjoint_jbytes(start, _popframe_preserved_args, _popframe_preserved_args_size);\n+  }\n+}\n+\n+void* JavaThread::popframe_preserved_args() {\n+  return _popframe_preserved_args;\n+}\n+\n+ByteSize JavaThread::popframe_preserved_args_size() {\n+  return in_ByteSize(_popframe_preserved_args_size);\n+}\n+\n+WordSize JavaThread::popframe_preserved_args_size_in_words() {\n+  int sz = in_bytes(popframe_preserved_args_size());\n+  assert(sz % wordSize == 0, \"argument size must be multiple of wordSize\");\n+  return in_WordSize(sz \/ wordSize);\n+}\n+\n+void JavaThread::popframe_free_preserved_args() {\n+  assert(_popframe_preserved_args != NULL, \"should not free PopFrame preserved arguments twice\");\n+  FREE_C_HEAP_ARRAY(char, (char*)_popframe_preserved_args);\n+  _popframe_preserved_args = NULL;\n+  _popframe_preserved_args_size = 0;\n+}\n+\n+#ifndef PRODUCT\n+\n+void JavaThread::trace_frames() {\n+  tty->print_cr(\"[Describe stack]\");\n+  int frame_no = 1;\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    tty->print(\"  %d. \", frame_no++);\n+    fst.current()->print_value_on(tty, this);\n+    tty->cr();\n+  }\n+}\n+\n+class PrintAndVerifyOopClosure: public OopClosure {\n+ protected:\n+  template <class T> inline void do_oop_work(T* p) {\n+    oop obj = RawAccess<>::oop_load(p);\n+    if (obj == NULL) return;\n+    tty->print(INTPTR_FORMAT \": \", p2i(p));\n+    if (oopDesc::is_oop_or_null(obj)) {\n+      if (obj->is_objArray()) {\n+        tty->print_cr(\"valid objArray: \" INTPTR_FORMAT, p2i(obj));\n+      } else {\n+        obj->print();\n+      }\n+    } else {\n+      tty->print_cr(\"invalid oop: \" INTPTR_FORMAT, p2i(obj));\n+    }\n+    tty->cr();\n+  }\n+ public:\n+  virtual void do_oop(oop* p) { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)  { do_oop_work(p); }\n+};\n+\n+#ifdef ASSERT\n+\/\/ Print or validate the layout of stack frames\n+void JavaThread::print_frame_layout(int depth, bool validate_only) {\n+  ResourceMark rm;\n+  PreserveExceptionMark pm(this);\n+  FrameValues values;\n+  int frame_no = 0;\n+  for (StackFrameStream fst(this, true, true, true); !fst.is_done(); fst.next()) {\n+    fst.current()->describe(values, ++frame_no, fst.register_map());\n+    if (depth == frame_no) break;\n+  }\n+  Continuation::describe(values);\n+  if (validate_only) {\n+    values.validate();\n+  } else {\n+    tty->print_cr(\"[Describe stack layout]\");\n+    values.print(this);\n+  }\n+}\n+#endif\n+\n+void JavaThread::trace_stack_from(vframe* start_vf) {\n+  ResourceMark rm;\n+  int vframe_no = 1;\n+  for (vframe* f = start_vf; f; f = f->sender()) {\n+    if (f->is_java_frame()) {\n+      javaVFrame::cast(f)->print_activation(vframe_no++);\n+    } else {\n+      f->print();\n+    }\n+    if (vframe_no > StackPrintLimit) {\n+      tty->print_cr(\"...<more frames>...\");\n+      return;\n+    }\n+  }\n+}\n+\n+\n+void JavaThread::trace_stack() {\n+  if (!has_last_Java_frame()) return;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+  RegisterMap reg_map(this, true, true);\n+  trace_stack_from(last_java_vframe(&reg_map));\n+}\n+\n+\n+#endif \/\/ PRODUCT\n+\n+void JavaThread::inc_held_monitor_count() {\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  _held_monitor_count++;\n+}\n+\n+void JavaThread::dec_held_monitor_count() {\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  assert(_held_monitor_count > 0, \"\");\n+  _held_monitor_count--;\n+}\n+\n+frame JavaThread::vthread_last_frame() {\n+  assert (is_vthread_mounted(), \"Virtual thread not mounted\");\n+  return last_frame();\n+}\n+\n+frame JavaThread::carrier_last_frame(RegisterMap* reg_map) {\n+  const ContinuationEntry* entry = vthread_continuation();\n+  guarantee (entry != NULL, \"Not a carrier thread\");\n+  frame f = entry->to_frame();\n+  if (reg_map->process_frames()) {\n+    entry->flush_stack_processing(this);\n+  }\n+  entry->update_register_map(reg_map);\n+  return f.sender(reg_map);\n+}\n+\n+frame JavaThread::platform_thread_last_frame(RegisterMap* reg_map) {\n+  return is_vthread_mounted() ? carrier_last_frame(reg_map) : last_frame();\n+}\n+\n+javaVFrame* JavaThread::last_java_vframe(const frame f, RegisterMap *reg_map) {\n+  assert(reg_map != NULL, \"a map must be given\");\n+  for (vframe* vf = vframe::new_vframe(&f, reg_map, this); vf; vf = vf->sender()) {\n+    if (vf->is_java_frame()) return javaVFrame::cast(vf);\n+  }\n+  return NULL;\n+}\n+\n+oop JavaThread::get_continuation() const {\n+  assert(threadObj() != nullptr, \"must be set\");\n+  return java_lang_Thread::continuation(threadObj());\n+}\n+\n+Klass* JavaThread::security_get_caller_class(int depth) {\n+  ResetNoHandleMark rnhm;\n+  HandleMark hm(Thread::current());\n+\n+  vframeStream vfst(this);\n+  vfst.security_get_caller_frame(depth);\n+  if (!vfst.at_end()) {\n+    return vfst.method()->method_holder();\n+  }\n+  return NULL;\n+}\n+\n+\/\/ java.lang.Thread.sleep support\n+\/\/ Returns true if sleep time elapsed as expected, and false\n+\/\/ if the thread was interrupted.\n+bool JavaThread::sleep(jlong millis) {\n+  assert(this == Thread::current(),  \"thread consistency check\");\n+\n+  ParkEvent * const slp = this->_SleepEvent;\n+  \/\/ Because there can be races with thread interruption sending an unpark()\n+  \/\/ to the event, we explicitly reset it here to avoid an immediate return.\n+  \/\/ The actual interrupt state will be checked before we park().\n+  slp->reset();\n+  \/\/ Thread interruption establishes a happens-before ordering in the\n+  \/\/ Java Memory Model, so we need to ensure we synchronize with the\n+  \/\/ interrupt state.\n+  OrderAccess::fence();\n+\n+  jlong prevtime = os::javaTimeNanos();\n+\n+  for (;;) {\n+    \/\/ interruption has precedence over timing out\n+    if (this->is_interrupted(true)) {\n+      return false;\n+    }\n+\n+    if (millis <= 0) {\n+      return true;\n+    }\n+\n+    {\n+      ThreadBlockInVM tbivm(this);\n+      OSThreadWaitState osts(this->osthread(), false \/* not Object.wait() *\/);\n+      slp->park(millis);\n+    }\n+\n+    \/\/ Update elapsed time tracking\n+    jlong newtime = os::javaTimeNanos();\n+    if (newtime - prevtime < 0) {\n+      \/\/ time moving backwards, should only happen if no monotonic clock\n+      \/\/ not a guarantee() because JVM should not abort on kernel\/glibc bugs\n+      assert(false,\n+             \"unexpected time moving backwards detected in JavaThread::sleep()\");\n+    } else {\n+      millis -= (newtime - prevtime) \/ NANOSECS_PER_MILLISEC;\n+    }\n+    prevtime = newtime;\n+  }\n+}\n+\n+\/\/ Last thread running calls java.lang.Shutdown.shutdown()\n+void JavaThread::invoke_shutdown_hooks() {\n+  HandleMark hm(this);\n+\n+  \/\/ We could get here with a pending exception, if so clear it now or\n+  \/\/ it will cause MetaspaceShared::link_shared_classes to\n+  \/\/ fail for dynamic dump.\n+  if (this->has_pending_exception()) {\n+    this->clear_pending_exception();\n+  }\n+\n+#if INCLUDE_CDS\n+  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n+  \/\/ Same operation is being done in JVM_BeforeHalt for handling the\n+  \/\/ case where the application calls System.exit().\n+  if (DynamicArchive::should_dump_at_vm_exit()) {\n+    DynamicArchive::prepare_for_dump_at_exit();\n+  }\n+#endif\n+\n+  EXCEPTION_MARK;\n+  Klass* shutdown_klass =\n+    SystemDictionary::resolve_or_null(vmSymbols::java_lang_Shutdown(),\n+                                      THREAD);\n+  if (shutdown_klass != NULL) {\n+    \/\/ SystemDictionary::resolve_or_null will return null if there was\n+    \/\/ an exception.  If we cannot load the Shutdown class, just don't\n+    \/\/ call Shutdown.shutdown() at all.  This will mean the shutdown hooks\n+    \/\/ won't be run.  Note that if a shutdown hook was registered,\n+    \/\/ the Shutdown class would have already been loaded\n+    \/\/ (Runtime.addShutdownHook will load it).\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result,\n+                           shutdown_klass,\n+                           vmSymbols::shutdown_name(),\n+                           vmSymbols::void_method_signature(),\n+                           THREAD);\n+  }\n+  CLEAR_PENDING_EXCEPTION;\n+}\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n+\n+\/\/ Helper function to create the java.lang.Thread object for a\n+\/\/ VM-internal thread. The thread will have the given name, and be\n+\/\/ a member of the \"system\" ThreadGroup.\n+Handle JavaThread::create_system_thread_object(const char* name,\n+                                               bool is_visible, TRAPS) {\n+  Handle string = java_lang_String::create_from_str(name, CHECK_NH);\n+\n+  \/\/ Initialize thread_oop to put it into the system threadGroup.\n+  \/\/ This is done by calling the Thread(ThreadGroup group, String name) constructor.\n+  Handle thread_group(THREAD, Universe::system_thread_group());\n+  Handle thread_oop =\n+    JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n+                                      vmSymbols::threadgroup_string_void_signature(),\n+                                      thread_group,\n+                                      string,\n+                                      CHECK_NH);\n+\n+  return thread_oop;\n+}\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n+\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadOopHandles(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2031,"deletions":0,"binary":false,"changes":2031,"status":"added"},{"patch":"@@ -0,0 +1,1179 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_JAVATHREAD_HPP\n+#define SHARE_RUNTIME_JAVATHREAD_HPP\n+\n+#include \"jni.h\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/oopHandle.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/handshake.hpp\"\n+#include \"runtime\/javaFrameAnchor.hpp\"\n+#include \"runtime\/park.hpp\"\n+#include \"runtime\/safepointMechanism.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n+#include \"runtime\/stackOverflow.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadHeapSampler.hpp\"\n+#include \"runtime\/threadStatisticalInfo.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_JFR\n+#include \"jfr\/support\/jfrThreadExtension.hpp\"\n+#endif\n+\n+class AsyncExceptionHandshake;\n+class ContinuationEntry;\n+class DeoptResourceMark;\n+class JNIHandleBlock;\n+class JVMCIRuntime;\n+\n+class JvmtiDeferredUpdates;\n+class JvmtiSampledObjectAllocEventCollector;\n+class JvmtiThreadState;\n+\n+class Metadata;\n+class OopStorage;\n+class OSThread;\n+\n+class ThreadsList;\n+class ThreadSafepointState;\n+class ThreadStatistics;\n+\n+class vframeArray;\n+class vframe;\n+class javaVFrame;\n+\n+class JavaThread;\n+typedef void (*ThreadFunction)(JavaThread*, TRAPS);\n+\n+class JavaThread: public Thread {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+  friend class WhiteBox;\n+  friend class ThreadsSMRSupport; \/\/ to access _threadObj for exiting_threads_oops_do\n+  friend class HandshakeState;\n+  friend class Continuation;\n+  friend class Threads;\n+ private:\n+  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n+  bool           _on_thread_list;                \/\/ Is set when this JavaThread is added to the Threads list\n+  OopHandle      _threadObj;                     \/\/ The Java level thread object\n+  OopHandle      _vthread; \/\/ the value returned by Thread.currentThread(): the virtual thread, if mounted, otherwise _threadObj\n+  OopHandle      _jvmti_vthread;\n+  OopHandle      _extentLocalCache;\n+\n+  static OopStorage* _thread_oop_storage;\n+\n+#ifdef ASSERT\n+ private:\n+  int _java_call_counter;\n+\n+ public:\n+  int  java_call_counter()                       { return _java_call_counter; }\n+  void inc_java_call_counter()                   { _java_call_counter++; }\n+  void dec_java_call_counter() {\n+    assert(_java_call_counter > 0, \"Invalid nesting of JavaCallWrapper\");\n+    _java_call_counter--;\n+  }\n+ private:  \/\/ restore original namespace restriction\n+#endif  \/\/ ifdef ASSERT\n+\n+  JavaFrameAnchor _anchor;                       \/\/ Encapsulation of current java frame and it state\n+\n+  ThreadFunction _entry_point;\n+\n+  JNIEnv        _jni_environment;\n+\n+  \/\/ Deopt support\n+  DeoptResourceMark*  _deopt_mark;               \/\/ Holds special ResourceMark for deoptimization\n+\n+  CompiledMethod*       _deopt_nmethod;         \/\/ CompiledMethod that is currently being deoptimized\n+  vframeArray*  _vframe_array_head;              \/\/ Holds the heap of the active vframeArrays\n+  vframeArray*  _vframe_array_last;              \/\/ Holds last vFrameArray we popped\n+  \/\/ Holds updates by JVMTI agents for compiled frames that cannot be performed immediately. They\n+  \/\/ will be carried out as soon as possible which, in most cases, is just before deoptimization of\n+  \/\/ the frame, when control returns to it.\n+  JvmtiDeferredUpdates* _jvmti_deferred_updates;\n+\n+  \/\/ Handshake value for fixing 6243940. We need a place for the i2c\n+  \/\/ adapter to store the callee Method*. This value is NEVER live\n+  \/\/ across a gc point so it does NOT have to be gc'd\n+  \/\/ The handshake is open ended since we can't be certain that it will\n+  \/\/ be NULLed. This is because we rarely ever see the race and end up\n+  \/\/ in handle_wrong_method which is the backend of the handshake. See\n+  \/\/ code in i2c adapters and handle_wrong_method.\n+\n+  Method*       _callee_target;\n+\n+  \/\/ Used to pass back results to the interpreter or generated code running Java code.\n+  oop           _vm_result;    \/\/ oop result is GC-preserved\n+  Metadata*     _vm_result_2;  \/\/ non-oop result\n+\n+  \/\/ See ReduceInitialCardMarks: this holds the precise space interval of\n+  \/\/ the most recent slow path allocation for which compiled code has\n+  \/\/ elided card-marks for performance along the fast-path.\n+  MemRegion     _deferred_card_mark;\n+\n+  ObjectMonitor* volatile _current_pending_monitor;     \/\/ ObjectMonitor this thread is waiting to lock\n+  bool           _current_pending_monitor_is_from_java; \/\/ locking is from Java code\n+  ObjectMonitor* volatile _current_waiting_monitor;     \/\/ ObjectMonitor on which this thread called Object.wait()\n+\n+  \/\/ Active_handles points to a block of handles\n+  JNIHandleBlock* _active_handles;\n+\n+  \/\/ One-element thread local free list\n+  JNIHandleBlock* _free_handle_block;\n+\n+ public:\n+  volatile intptr_t _Stalled;\n+\n+  \/\/ For tracking the heavyweight monitor the thread is pending on.\n+  ObjectMonitor* current_pending_monitor() {\n+    \/\/ Use Atomic::load() to prevent data race between concurrent modification and\n+    \/\/ concurrent readers, e.g. ThreadService::get_current_contended_monitor().\n+    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n+    return Atomic::load(&_current_pending_monitor);\n+  }\n+  void set_current_pending_monitor(ObjectMonitor* monitor) {\n+    Atomic::store(&_current_pending_monitor, monitor);\n+  }\n+  void set_current_pending_monitor_is_from_java(bool from_java) {\n+    _current_pending_monitor_is_from_java = from_java;\n+  }\n+  bool current_pending_monitor_is_from_java() {\n+    return _current_pending_monitor_is_from_java;\n+  }\n+  ObjectMonitor* current_waiting_monitor() {\n+    \/\/ See the comment in current_pending_monitor() above.\n+    return Atomic::load(&_current_waiting_monitor);\n+  }\n+  void set_current_waiting_monitor(ObjectMonitor* monitor) {\n+    Atomic::store(&_current_waiting_monitor, monitor);\n+  }\n+\n+  \/\/ JNI handle support\n+  JNIHandleBlock* active_handles() const         { return _active_handles; }\n+  void set_active_handles(JNIHandleBlock* block) { _active_handles = block; }\n+  JNIHandleBlock* free_handle_block() const      { return _free_handle_block; }\n+  void set_free_handle_block(JNIHandleBlock* block) { _free_handle_block = block; }\n+\n+  void push_jni_handle_block();\n+  void pop_jni_handle_block();\n+\n+ private:\n+  MonitorChunk* _monitor_chunks;              \/\/ Contains the off stack monitors\n+                                              \/\/ allocated during deoptimization\n+                                              \/\/ and by JNI_MonitorEnter\/Exit\n+\n+  enum SuspendFlags {\n+    \/\/ NOTE: avoid using the sign-bit as cc generates different test code\n+    \/\/       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n+    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n+  };\n+\n+  \/\/ various suspension related flags - atomically updated\n+  volatile uint32_t _suspend_flags;\n+\n+  inline void set_suspend_flag(SuspendFlags f);\n+  inline void clear_suspend_flag(SuspendFlags f);\n+\n+ public:\n+  inline void set_trace_flag();\n+  inline void clear_trace_flag();\n+  inline void set_obj_deopt_flag();\n+  inline void clear_obj_deopt_flag();\n+  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n+  bool is_obj_deopt_suspend()  { return (_suspend_flags & _obj_deopt) != 0; }\n+\n+  \/\/ Asynchronous exception support\n+ private:\n+  friend class InstallAsyncExceptionHandshake;\n+  friend class AsyncExceptionHandshake;\n+  friend class HandshakeState;\n+\n+  void install_async_exception(AsyncExceptionHandshake* aec = NULL);\n+  void handle_async_exception(oop java_throwable);\n+ public:\n+  bool has_async_exception_condition(bool ThreadDeath_only = false);\n+  inline void set_pending_unsafe_access_error();\n+  static void send_async_exception(JavaThread* jt, oop java_throwable);\n+\n+  class NoAsyncExceptionDeliveryMark : public StackObj {\n+    friend JavaThread;\n+    JavaThread *_target;\n+    inline NoAsyncExceptionDeliveryMark(JavaThread *t);\n+    inline ~NoAsyncExceptionDeliveryMark();\n+  };\n+\n+  \/\/ Safepoint support\n+ public:                                                        \/\/ Expose _thread_state for SafeFetchInt()\n+  volatile JavaThreadState _thread_state;\n+ private:\n+  SafepointMechanism::ThreadData _poll_data;\n+  ThreadSafepointState*          _safepoint_state;              \/\/ Holds information about a thread during a safepoint\n+  address                        _saved_exception_pc;           \/\/ Saved pc of instruction where last implicit exception happened\n+  NOT_PRODUCT(bool               _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n+#ifdef ASSERT\n+  \/\/ Debug support for checking if code allows safepoints or not.\n+  \/\/ Safepoints in the VM can happen because of allocation, invoking a VM operation, or blocking on\n+  \/\/ mutex, or blocking on an object synchronizer (Java locking).\n+  \/\/ If _no_safepoint_count is non-zero, then an assertion failure will happen in any of\n+  \/\/ the above cases. The class NoSafepointVerifier is used to set this counter.\n+  int _no_safepoint_count;                             \/\/ If 0, thread allow a safepoint to happen\n+\n+ public:\n+  void inc_no_safepoint_count() { _no_safepoint_count++; }\n+  void dec_no_safepoint_count() { _no_safepoint_count--; }\n+#endif \/\/ ASSERT\n+ public:\n+  \/\/ These functions check conditions before possibly going to a safepoint.\n+  \/\/ including NoSafepointVerifier.\n+  void check_for_valid_safepoint_state() NOT_DEBUG_RETURN;\n+  void check_possible_safepoint()        NOT_DEBUG_RETURN;\n+\n+#ifdef ASSERT\n+ private:\n+  volatile uint64_t _visited_for_critical_count;\n+\n+ public:\n+  void set_visited_for_critical_count(uint64_t safepoint_id) {\n+    assert(_visited_for_critical_count == 0, \"Must be reset before set\");\n+    assert((safepoint_id & 0x1) == 1, \"Must be odd\");\n+    _visited_for_critical_count = safepoint_id;\n+  }\n+  void reset_visited_for_critical_count(uint64_t safepoint_id) {\n+    assert(_visited_for_critical_count == safepoint_id, \"Was not visited\");\n+    _visited_for_critical_count = 0;\n+  }\n+  bool was_visited_for_critical_count(uint64_t safepoint_id) const {\n+    return _visited_for_critical_count == safepoint_id;\n+  }\n+#endif \/\/ ASSERT\n+\n+  \/\/ JavaThread termination support\n+ public:\n+  enum TerminatedTypes {\n+    _not_terminated = 0xDEAD - 2,\n+    _thread_exiting,                             \/\/ JavaThread::exit() has been called for this thread\n+    _thread_terminated,                          \/\/ JavaThread is removed from thread list\n+    _vm_exited                                   \/\/ JavaThread is still executing native code, but VM is terminated\n+                                                 \/\/ only VM_Exit can set _vm_exited\n+  };\n+\n+ private:\n+  \/\/ In general a JavaThread's _terminated field transitions as follows:\n+  \/\/\n+  \/\/   _not_terminated => _thread_exiting => _thread_terminated\n+  \/\/\n+  \/\/ _vm_exited is a special value to cover the case of a JavaThread\n+  \/\/ executing native code after the VM itself is terminated.\n+  volatile TerminatedTypes _terminated;\n+\n+  jint                  _in_deopt_handler;       \/\/ count of deoptimization\n+                                                 \/\/ handlers thread is in\n+  volatile bool         _doing_unsafe_access;    \/\/ Thread may fault due to unsafe access\n+  bool                  _do_not_unlock_if_synchronized;  \/\/ Do not unlock the receiver of a synchronized method (since it was\n+                                                         \/\/ never locked) when throwing an exception. Used by interpreter only.\n+#if INCLUDE_JVMTI\n+  volatile bool         _carrier_thread_suspended;       \/\/ Carrier thread is externally suspended\n+  bool                  _is_in_VTMS_transition;          \/\/ thread is in virtual thread mount state transition\n+#ifdef ASSERT\n+  bool                  _is_VTMS_transition_disabler;    \/\/ thread currently disabled VTMS transitions\n+#endif\n+#endif\n+\n+  \/\/ JNI attach states:\n+  enum JNIAttachStates {\n+    _not_attaching_via_jni = 1,  \/\/ thread is not attaching via JNI\n+    _attaching_via_jni,          \/\/ thread is attaching via JNI\n+    _attached_via_jni            \/\/ thread has attached via JNI\n+  };\n+\n+  \/\/ A regular JavaThread's _jni_attach_state is _not_attaching_via_jni.\n+  \/\/ A native thread that is attaching via JNI starts with a value\n+  \/\/ of _attaching_via_jni and transitions to _attached_via_jni.\n+  volatile JNIAttachStates _jni_attach_state;\n+\n+\n+#if INCLUDE_JVMCI\n+  \/\/ The _pending_* fields below are used to communicate extra information\n+  \/\/ from an uncommon trap in JVMCI compiled code to the uncommon trap handler.\n+\n+  \/\/ Communicates the DeoptReason and DeoptAction of the uncommon trap\n+  int       _pending_deoptimization;\n+\n+  \/\/ Specifies whether the uncommon trap is to bci 0 of a synchronized method\n+  \/\/ before the monitor has been acquired.\n+  bool      _pending_monitorenter;\n+\n+  \/\/ Specifies if the DeoptReason for the last uncommon trap was Reason_transfer_to_interpreter\n+  bool      _pending_transfer_to_interpreter;\n+\n+  \/\/ True if in a runtime call from compiled code that will deoptimize\n+  \/\/ and re-execute a failed heap allocation in the interpreter.\n+  bool      _in_retryable_allocation;\n+\n+  \/\/ An id of a speculation that JVMCI compiled code can use to further describe and\n+  \/\/ uniquely identify the speculative optimization guarded by an uncommon trap.\n+  \/\/ See JVMCINMethodData::SPECULATION_LENGTH_BITS for further details.\n+  jlong     _pending_failed_speculation;\n+\n+  \/\/ These fields are mutually exclusive in terms of live ranges.\n+  union {\n+    \/\/ Communicates the pc at which the most recent implicit exception occurred\n+    \/\/ from the signal handler to a deoptimization stub.\n+    address   _implicit_exception_pc;\n+\n+    \/\/ Communicates an alternative call target to an i2c stub from a JavaCall .\n+    address   _alternate_call_target;\n+  } _jvmci;\n+\n+  \/\/ The JVMCIRuntime in a JVMCI shared library\n+  JVMCIRuntime* _libjvmci_runtime;\n+\n+  \/\/ Support for high precision, thread sensitive counters in JVMCI compiled code.\n+  jlong*    _jvmci_counters;\n+\n+  \/\/ Fast thread locals for use by JVMCI\n+  jlong      _jvmci_reserved0;\n+  jlong      _jvmci_reserved1;\n+  oop        _jvmci_reserved_oop0;\n+\n+ public:\n+  static jlong* _jvmci_old_thread_counters;\n+  static void collect_counters(jlong* array, int length);\n+\n+  bool resize_counters(int current_size, int new_size);\n+\n+  static bool resize_all_jvmci_counters(int new_size);\n+\n+  void set_jvmci_reserved_oop0(oop value) {\n+    _jvmci_reserved_oop0 = value;\n+  }\n+\n+  oop get_jvmci_reserved_oop0() {\n+    return _jvmci_reserved_oop0;\n+  }\n+\n+  void set_jvmci_reserved0(jlong value) {\n+    _jvmci_reserved0 = value;\n+  }\n+\n+  jlong get_jvmci_reserved0() {\n+    return _jvmci_reserved0;\n+  }\n+\n+  void set_jvmci_reserved1(jlong value) {\n+    _jvmci_reserved1 = value;\n+  }\n+\n+  jlong get_jvmci_reserved1() {\n+    return _jvmci_reserved1;\n+  }\n+\n+ private:\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  StackOverflow    _stack_overflow_state;\n+\n+  \/\/ Compiler exception handling (NOTE: The _exception_oop is *NOT* the same as _pending_exception. It is\n+  \/\/ used to temp. parsing values into and out of the runtime system during exception handling for compiled\n+  \/\/ code)\n+  volatile oop     _exception_oop;               \/\/ Exception thrown in compiled code\n+  volatile address _exception_pc;                \/\/ PC where exception happened\n+  volatile address _exception_handler_pc;        \/\/ PC for handler of exception\n+  volatile int     _is_method_handle_return;     \/\/ true (== 1) if the current exception PC is a MethodHandle call site.\n+\n+ private:\n+  \/\/ support for JNI critical regions\n+  jint    _jni_active_critical;                  \/\/ count of entries into JNI critical region\n+\n+  \/\/ Checked JNI: function name requires exception check\n+  char* _pending_jni_exception_check_fn;\n+\n+  \/\/ For deadlock detection.\n+  int _depth_first_number;\n+\n+  \/\/ JVMTI PopFrame support\n+  \/\/ This is set to popframe_pending to signal that top Java frame should be popped immediately\n+  int _popframe_condition;\n+\n+  \/\/ If reallocation of scalar replaced objects fails, we throw OOM\n+  \/\/ and during exception propagation, pop the top\n+  \/\/ _frames_to_pop_failed_realloc frames, the ones that reference\n+  \/\/ failed reallocations.\n+  int _frames_to_pop_failed_realloc;\n+\n+  ContinuationEntry* _cont_entry;\n+  intptr_t* _cont_fastpath; \/\/ the sp of the oldest known interpreted\/call_stub frame inside the\n+                            \/\/ continuation that we know about\n+  int _cont_fastpath_thread_state; \/\/ whether global thread state allows continuation fastpath (JVMTI)\n+  int _held_monitor_count;  \/\/ used by continuations for fast lock detection\n+private:\n+\n+  friend class VMThread;\n+  friend class ThreadWaitTransition;\n+  friend class VM_Exit;\n+\n+  \/\/ Stack watermark barriers.\n+  StackWatermarks _stack_watermarks;\n+\n+ public:\n+  inline StackWatermarks* stack_watermarks() { return &_stack_watermarks; }\n+\n+ public:\n+  jlong _extentLocal_hash_table_shift;\n+\n+  void allocate_extentLocal_hash_table(int count);\n+\n+ public:\n+  \/\/ Constructor\n+  JavaThread();                            \/\/ delegating constructor\n+  JavaThread(bool is_attaching_via_jni);   \/\/ for main thread and JNI attached threads\n+  JavaThread(ThreadFunction entry_point, size_t stack_size = 0);\n+  ~JavaThread();\n+\n+#ifdef ASSERT\n+  \/\/ verify this JavaThread hasn't be published in the Threads::list yet\n+  void verify_not_published();\n+#endif \/\/ ASSERT\n+\n+  StackOverflow* stack_overflow_state() { return &_stack_overflow_state; }\n+\n+  \/\/JNI functiontable getter\/setter for JVMTI jni function table interception API.\n+  void set_jni_functions(struct JNINativeInterface_* functionTable) {\n+    _jni_environment.functions = functionTable;\n+  }\n+  struct JNINativeInterface_* get_jni_functions() {\n+    return (struct JNINativeInterface_ *)_jni_environment.functions;\n+  }\n+\n+  \/\/ This function is called at thread creation to allow\n+  \/\/ platform specific thread variables to be initialized.\n+  void cache_global_variables();\n+\n+  \/\/ Executes Shutdown.shutdown()\n+  void invoke_shutdown_hooks();\n+\n+  \/\/ Cleanup on thread exit\n+  enum ExitType {\n+    normal_exit,\n+    jni_detach\n+  };\n+  void exit(bool destroy_vm, ExitType exit_type = normal_exit);\n+\n+  void cleanup_failed_attach_current_thread(bool is_daemon);\n+\n+  \/\/ Testers\n+  virtual bool is_Java_thread() const            { return true;  }\n+  virtual bool can_call_java() const             { return true; }\n+\n+  virtual bool is_active_Java_thread() const {\n+    return on_thread_list() && !is_terminated();\n+  }\n+\n+  \/\/ Thread oop. threadObj() can be NULL for initial JavaThread\n+  \/\/ (or for threads attached via JNI)\n+  oop threadObj() const;\n+  void set_threadOopHandles(oop p);\n+  oop vthread() const;\n+  void set_vthread(oop p);\n+  oop extentLocalCache() const;\n+  void set_extentLocalCache(oop p);\n+  oop jvmti_vthread() const;\n+  void set_jvmti_vthread(oop p);\n+\n+  \/\/ Prepare thread and add to priority queue.  If a priority is\n+  \/\/ not specified, use the priority of the thread object. Threads_lock\n+  \/\/ must be held while this function is called.\n+  void prepare(jobject jni_thread, ThreadPriority prio=NoPriority);\n+\n+  void set_saved_exception_pc(address pc)        { _saved_exception_pc = pc; }\n+  address saved_exception_pc()                   { return _saved_exception_pc; }\n+\n+  ThreadFunction entry_point() const             { return _entry_point; }\n+\n+  \/\/ Allocates a new Java level thread object for this thread. thread_name may be NULL.\n+  void allocate_threadObj(Handle thread_group, const char* thread_name, bool daemon, TRAPS);\n+\n+  \/\/ Last frame anchor routines\n+\n+  JavaFrameAnchor* frame_anchor(void)            { return &_anchor; }\n+\n+  \/\/ last_Java_sp\n+  bool has_last_Java_frame() const               { return _anchor.has_last_Java_frame(); }\n+  intptr_t* last_Java_sp() const                 { return _anchor.last_Java_sp(); }\n+\n+  \/\/ last_Java_pc\n+\n+  address last_Java_pc(void)                     { return _anchor.last_Java_pc(); }\n+\n+  \/\/ Safepoint support\n+  inline JavaThreadState thread_state() const;\n+  inline void set_thread_state(JavaThreadState s);\n+  inline void set_thread_state_fence(JavaThreadState s);  \/\/ fence after setting thread state\n+  inline ThreadSafepointState* safepoint_state() const;\n+  inline void set_safepoint_state(ThreadSafepointState* state);\n+  inline bool is_at_poll_safepoint();\n+\n+  \/\/ JavaThread termination and lifecycle support:\n+  void smr_delete();\n+  bool on_thread_list() const { return _on_thread_list; }\n+  void set_on_thread_list() { _on_thread_list = true; }\n+\n+  \/\/ thread has called JavaThread::exit() or is terminated\n+  bool is_exiting() const;\n+  \/\/ thread is terminated (no longer on the threads list); we compare\n+  \/\/ against the two non-terminated values so that a freed JavaThread\n+  \/\/ will also be considered terminated.\n+  bool check_is_terminated(TerminatedTypes l_terminated) const {\n+    return l_terminated != _not_terminated && l_terminated != _thread_exiting;\n+  }\n+  bool is_terminated() const;\n+  void set_terminated(TerminatedTypes t);\n+\n+  void block_if_vm_exited();\n+\n+  bool doing_unsafe_access()                     { return _doing_unsafe_access; }\n+  void set_doing_unsafe_access(bool val)         { _doing_unsafe_access = val; }\n+\n+  bool do_not_unlock_if_synchronized()             { return _do_not_unlock_if_synchronized; }\n+  void set_do_not_unlock_if_synchronized(bool val) { _do_not_unlock_if_synchronized = val; }\n+\n+  SafepointMechanism::ThreadData* poll_data() { return &_poll_data; }\n+\n+  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n+\n+  \/\/ Continuation support\n+  oop get_continuation() const;\n+  ContinuationEntry* last_continuation() const { return _cont_entry; }\n+  void set_cont_fastpath(intptr_t* x)          { _cont_fastpath = x; }\n+  void push_cont_fastpath(intptr_t* sp)        { if (sp > _cont_fastpath) _cont_fastpath = sp; }\n+  void set_cont_fastpath_thread_state(bool x)  { _cont_fastpath_thread_state = (int)x; }\n+  intptr_t* raw_cont_fastpath() const          { return _cont_fastpath; }\n+  bool cont_fastpath() const                   { return _cont_fastpath == NULL && _cont_fastpath_thread_state != 0; }\n+  bool cont_fastpath_thread_state() const      { return _cont_fastpath_thread_state != 0; }\n+\n+  int held_monitor_count()        { return _held_monitor_count; }\n+  void reset_held_monitor_count() { _held_monitor_count = 0; }\n+  void inc_held_monitor_count();\n+  void dec_held_monitor_count();\n+\n+  inline bool is_vthread_mounted() const;\n+  inline const ContinuationEntry* vthread_continuation() const;\n+\n+ private:\n+  DEBUG_ONLY(void verify_frame_info();)\n+\n+  \/\/ Support for thread handshake operations\n+  HandshakeState _handshake;\n+ public:\n+  HandshakeState* handshake_state() { return &_handshake; }\n+\n+  \/\/ A JavaThread can always safely operate on it self and other threads\n+  \/\/ can do it safely if they are the active handshaker.\n+  bool is_handshake_safe_for(Thread* th) const {\n+    return _handshake.active_handshaker() == th || this == th;\n+  }\n+\n+  \/\/ Suspend\/resume support for JavaThread\n+  \/\/ higher-level suspension\/resume logic called by the public APIs\n+  bool java_suspend();\n+  bool java_resume();\n+  bool is_suspended()     { return _handshake.is_suspended(); }\n+\n+  \/\/ Check for async exception in addition to safepoint.\n+  static void check_special_condition_for_native_trans(JavaThread *thread);\n+\n+  \/\/ Synchronize with another thread that is deoptimizing objects of the\n+  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n+  void wait_for_object_deoptimization();\n+\n+#if INCLUDE_JVMTI\n+  inline void set_carrier_thread_suspended();\n+  inline void clear_carrier_thread_suspended();\n+\n+  bool is_carrier_thread_suspended() const {\n+    return _carrier_thread_suspended;\n+  }\n+\n+  bool is_in_VTMS_transition() const             { return _is_in_VTMS_transition; }\n+  void set_is_in_VTMS_transition(bool val);\n+#ifdef ASSERT\n+  bool is_VTMS_transition_disabler() const       { return _is_VTMS_transition_disabler; }\n+  void set_is_VTMS_transition_disabler(bool val);\n+#endif\n+#endif\n+\n+  \/\/ Support for object deoptimization and JFR suspension\n+  void handle_special_runtime_exit_condition();\n+  bool has_special_runtime_exit_condition() {\n+    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+  }\n+\n+  \/\/ Fast-locking support\n+  bool is_lock_owned(address adr) const;\n+  bool is_lock_owned_current(address adr) const; \/\/ virtual if mounted, otherwise whole thread\n+  bool is_lock_owned_carrier(address adr) const;\n+\n+  \/\/ Accessors for vframe array top\n+  \/\/ The linked list of vframe arrays are sorted on sp. This means when we\n+  \/\/ unpack the head must contain the vframe array to unpack.\n+  void set_vframe_array_head(vframeArray* value) { _vframe_array_head = value; }\n+  vframeArray* vframe_array_head() const         { return _vframe_array_head;  }\n+\n+  \/\/ Side structure for deferring update of java frame locals until deopt occurs\n+  JvmtiDeferredUpdates* deferred_updates() const      { return _jvmti_deferred_updates; }\n+  void set_deferred_updates(JvmtiDeferredUpdates* du) { _jvmti_deferred_updates = du; }\n+\n+  \/\/ These only really exist to make debugging deopt problems simpler\n+\n+  void set_vframe_array_last(vframeArray* value) { _vframe_array_last = value; }\n+  vframeArray* vframe_array_last() const         { return _vframe_array_last;  }\n+\n+  \/\/ The special resourceMark used during deoptimization\n+\n+  void set_deopt_mark(DeoptResourceMark* value)  { _deopt_mark = value; }\n+  DeoptResourceMark* deopt_mark(void)            { return _deopt_mark; }\n+\n+  void set_deopt_compiled_method(CompiledMethod* nm)  { _deopt_nmethod = nm; }\n+  CompiledMethod* deopt_compiled_method()        { return _deopt_nmethod; }\n+\n+  Method*    callee_target() const               { return _callee_target; }\n+  void set_callee_target  (Method* x)          { _callee_target   = x; }\n+\n+  \/\/ Oop results of vm runtime calls\n+  oop  vm_result() const                         { return _vm_result; }\n+  void set_vm_result  (oop x)                    { _vm_result   = x; }\n+\n+  Metadata*    vm_result_2() const               { return _vm_result_2; }\n+  void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }\n+\n+  MemRegion deferred_card_mark() const           { return _deferred_card_mark; }\n+  void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }\n+\n+#if INCLUDE_JVMCI\n+  int  pending_deoptimization() const             { return _pending_deoptimization; }\n+  jlong pending_failed_speculation() const        { return _pending_failed_speculation; }\n+  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n+  void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }\n+  void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }\n+  void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }\n+  void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }\n+  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, \"must be\"); _jvmci._alternate_call_target = a; }\n+  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, \"must be\"); _jvmci._implicit_exception_pc = a; }\n+\n+  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n+  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n+\n+  JVMCIRuntime* libjvmci_runtime() const          { return _libjvmci_runtime; }\n+  void set_libjvmci_runtime(JVMCIRuntime* rt) {\n+    assert((_libjvmci_runtime == nullptr && rt != nullptr) || (_libjvmci_runtime != nullptr && rt == nullptr), \"must be\");\n+    _libjvmci_runtime = rt;\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  \/\/ Exception handling for compiled methods\n+  oop      exception_oop() const;\n+  address  exception_pc() const                  { return _exception_pc; }\n+  address  exception_handler_pc() const          { return _exception_handler_pc; }\n+  bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }\n+\n+  void set_exception_oop(oop o);\n+  void set_exception_pc(address a)               { _exception_pc = a; }\n+  void set_exception_handler_pc(address a)       { _exception_handler_pc = a; }\n+  void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }\n+\n+  void clear_exception_oop_and_pc() {\n+    set_exception_oop(NULL);\n+    set_exception_pc(NULL);\n+  }\n+\n+  \/\/ Check if address is in the usable part of the stack (excludes protected\n+  \/\/ guard pages). Can be applied to any thread and is an approximation for\n+  \/\/ using is_in_live_stack when the query has to happen from another thread.\n+  bool is_in_usable_stack(address adr) const {\n+    return is_in_stack_range_incl(adr, _stack_overflow_state.stack_reserved_zone_base());\n+  }\n+\n+  \/\/ Misc. accessors\/mutators\n+  void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }\n+  void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }\n+  bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }\n+\n+  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n+\n+  \/\/ For assembly stub generation\n+  static ByteSize threadObj_offset()             { return byte_offset_of(JavaThread, _threadObj); }\n+  static ByteSize vthread_offset()               { return byte_offset_of(JavaThread, _vthread); }\n+  static ByteSize jni_environment_offset()       { return byte_offset_of(JavaThread, _jni_environment); }\n+  static ByteSize pending_jni_exception_check_fn_offset() {\n+    return byte_offset_of(JavaThread, _pending_jni_exception_check_fn);\n+  }\n+  static ByteSize last_Java_sp_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_sp_offset();\n+  }\n+  static ByteSize last_Java_pc_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_pc_offset();\n+  }\n+  static ByteSize frame_anchor_offset() {\n+    return byte_offset_of(JavaThread, _anchor);\n+  }\n+  static ByteSize callee_target_offset()         { return byte_offset_of(JavaThread, _callee_target); }\n+  static ByteSize vm_result_offset()             { return byte_offset_of(JavaThread, _vm_result); }\n+  static ByteSize vm_result_2_offset()           { return byte_offset_of(JavaThread, _vm_result_2); }\n+  static ByteSize thread_state_offset()          { return byte_offset_of(JavaThread, _thread_state); }\n+  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n+  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n+  static ByteSize saved_exception_pc_offset()    { return byte_offset_of(JavaThread, _saved_exception_pc); }\n+  static ByteSize osthread_offset()              { return byte_offset_of(JavaThread, _osthread); }\n+#if INCLUDE_JVMCI\n+  static ByteSize pending_deoptimization_offset() { return byte_offset_of(JavaThread, _pending_deoptimization); }\n+  static ByteSize pending_monitorenter_offset()  { return byte_offset_of(JavaThread, _pending_monitorenter); }\n+  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n+  static ByteSize jvmci_alternate_call_target_offset() { return byte_offset_of(JavaThread, _jvmci._alternate_call_target); }\n+  static ByteSize jvmci_implicit_exception_pc_offset() { return byte_offset_of(JavaThread, _jvmci._implicit_exception_pc); }\n+  static ByteSize jvmci_counters_offset()        { return byte_offset_of(JavaThread, _jvmci_counters); }\n+#endif \/\/ INCLUDE_JVMCI\n+  static ByteSize exception_oop_offset()         { return byte_offset_of(JavaThread, _exception_oop); }\n+  static ByteSize exception_pc_offset()          { return byte_offset_of(JavaThread, _exception_pc); }\n+  static ByteSize exception_handler_pc_offset()  { return byte_offset_of(JavaThread, _exception_handler_pc); }\n+  static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }\n+\n+  static ByteSize active_handles_offset()        { return byte_offset_of(JavaThread, _active_handles); }\n+\n+  \/\/ StackOverflow offsets\n+  static ByteSize stack_overflow_limit_offset()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._stack_overflow_limit);\n+  }\n+  static ByteSize stack_guard_state_offset()     {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._stack_guard_state);\n+  }\n+  static ByteSize reserved_stack_activation_offset() {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._reserved_stack_activation);\n+  }\n+  static ByteSize shadow_zone_safe_limit()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_safe_limit);\n+  }\n+  static ByteSize shadow_zone_growth_watermark()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_growth_watermark);\n+  }\n+\n+  static ByteSize suspend_flags_offset()         { return byte_offset_of(JavaThread, _suspend_flags); }\n+\n+  static ByteSize do_not_unlock_if_synchronized_offset() { return byte_offset_of(JavaThread, _do_not_unlock_if_synchronized); }\n+  static ByteSize should_post_on_exceptions_flag_offset() {\n+    return byte_offset_of(JavaThread, _should_post_on_exceptions_flag);\n+  }\n+  static ByteSize doing_unsafe_access_offset() { return byte_offset_of(JavaThread, _doing_unsafe_access); }\n+  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n+\n+  static ByteSize cont_entry_offset()         { return byte_offset_of(JavaThread, _cont_entry); }\n+  static ByteSize cont_fastpath_offset()      { return byte_offset_of(JavaThread, _cont_fastpath); }\n+  static ByteSize held_monitor_count_offset() { return byte_offset_of(JavaThread, _held_monitor_count); }\n+\n+  \/\/ Returns the jni environment for this thread\n+  JNIEnv* jni_environment()                      { return &_jni_environment; }\n+\n+  \/\/ Returns the current thread as indicated by the given JNIEnv.\n+  \/\/ We don't assert it is Thread::current here as that is done at the\n+  \/\/ external JNI entry points where the JNIEnv is passed into the VM.\n+  static JavaThread* thread_from_jni_environment(JNIEnv* env) {\n+    JavaThread* current = (JavaThread*)((intptr_t)env - in_bytes(jni_environment_offset()));\n+    \/\/ We can't normally get here in a thread that has completed its\n+    \/\/ execution and so \"is_terminated\", except when the call is from\n+    \/\/ AsyncGetCallTrace, which can be triggered by a signal at any point in\n+    \/\/ a thread's lifecycle. A thread is also considered terminated if the VM\n+    \/\/ has exited, so we have to check this and block in case this is a daemon\n+    \/\/ thread returning to the VM (the JNI DirectBuffer entry points rely on\n+    \/\/ this).\n+    if (current->is_terminated()) {\n+      current->block_if_vm_exited();\n+    }\n+    return current;\n+  }\n+\n+  \/\/ JNI critical regions. These can nest.\n+  bool in_critical()    { return _jni_active_critical > 0; }\n+  bool in_last_critical()  { return _jni_active_critical == 1; }\n+  inline void enter_critical();\n+  void exit_critical() {\n+    assert(Thread::current() == this, \"this must be current thread\");\n+    _jni_active_critical--;\n+    assert(_jni_active_critical >= 0, \"JNI critical nesting problem?\");\n+  }\n+\n+  \/\/ Checked JNI: is the programmer required to check for exceptions, if so specify\n+  \/\/ which function name. Returning to a Java frame should implicitly clear the\n+  \/\/ pending check, this is done for Native->Java transitions (i.e. user JNI code).\n+  \/\/ VM->Java transitions are not cleared, it is expected that JNI code enclosed\n+  \/\/ within ThreadToNativeFromVM makes proper exception checks (i.e. VM internal).\n+  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != NULL; }\n+  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = NULL; }\n+  const char* get_pending_jni_exception_check() const { return _pending_jni_exception_check_fn; }\n+  void set_pending_jni_exception_check(const char* fn_name) { _pending_jni_exception_check_fn = (char*) fn_name; }\n+\n+  \/\/ For deadlock detection\n+  int depth_first_number() { return _depth_first_number; }\n+  void set_depth_first_number(int dfn) { _depth_first_number = dfn; }\n+\n+ private:\n+  void set_monitor_chunks(MonitorChunk* monitor_chunks) { _monitor_chunks = monitor_chunks; }\n+\n+ public:\n+  MonitorChunk* monitor_chunks() const           { return _monitor_chunks; }\n+  void add_monitor_chunk(MonitorChunk* chunk);\n+  void remove_monitor_chunk(MonitorChunk* chunk);\n+  bool in_deopt_handler() const                  { return _in_deopt_handler > 0; }\n+  void inc_in_deopt_handler()                    { _in_deopt_handler++; }\n+  void dec_in_deopt_handler() {\n+    assert(_in_deopt_handler > 0, \"mismatched deopt nesting\");\n+    if (_in_deopt_handler > 0) { \/\/ robustness\n+      _in_deopt_handler--;\n+    }\n+  }\n+\n+ private:\n+  void set_entry_point(ThreadFunction entry_point) { _entry_point = entry_point; }\n+\n+  \/\/ factor out low-level mechanics for use in both normal and error cases\n+  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+\n+ public:\n+\n+  \/\/ Frame iteration; calls the function f for all frames on the stack\n+  void frames_do(void f(frame*, const RegisterMap*));\n+\n+  \/\/ Memory operations\n+  void oops_do_frames(OopClosure* f, CodeBlobClosure* cf);\n+  void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n+\n+  \/\/ Sweeper operations\n+  virtual void nmethods_do(CodeBlobClosure* cf);\n+\n+  \/\/ RedefineClasses Support\n+  void metadata_do(MetadataClosure* f);\n+\n+  \/\/ Debug method asserting thread states are correct during a handshake operation.\n+  DEBUG_ONLY(void verify_states_for_handshake();)\n+\n+  \/\/ Misc. operations\n+  const char* name() const;\n+  const char* type_name() const { return \"JavaThread\"; }\n+  static const char* name_for(oop thread_obj);\n+\n+  void print_on(outputStream* st, bool print_extended_info) const;\n+  void print_on(outputStream* st) const { print_on(st, false); }\n+  void print() const;\n+  void print_thread_state_on(outputStream*) const;\n+  const char* thread_state_name() const;\n+  void print_on_error(outputStream* st, char* buf, int buflen) const;\n+  void print_name_on_error(outputStream* st, char* buf, int buflen) const;\n+  void verify();\n+\n+  \/\/ Accessing frames\n+  frame last_frame() {\n+    _anchor.make_walkable();\n+    return pd_last_frame();\n+  }\n+  javaVFrame* last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(last_frame(), reg_map); }\n+\n+  frame carrier_last_frame(RegisterMap* reg_map);\n+  javaVFrame* carrier_last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(carrier_last_frame(reg_map), reg_map); }\n+\n+  frame vthread_last_frame();\n+  javaVFrame* vthread_last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(vthread_last_frame(), reg_map); }\n+\n+  frame platform_thread_last_frame(RegisterMap* reg_map);\n+  javaVFrame*  platform_thread_last_java_vframe(RegisterMap* reg_map) {\n+    return last_java_vframe(platform_thread_last_frame(reg_map), reg_map);\n+  }\n+\n+  javaVFrame* last_java_vframe(const frame f, RegisterMap* reg_map);\n+\n+  \/\/ Returns method at 'depth' java or native frames down the stack\n+  \/\/ Used for security checks\n+  Klass* security_get_caller_class(int depth);\n+\n+  \/\/ Print stack trace in external format\n+  void print_stack_on(outputStream* st);\n+  void print_stack() { print_stack_on(tty); }\n+\n+  \/\/ Print stack traces in various internal formats\n+  void trace_stack()                             PRODUCT_RETURN;\n+  void trace_stack_from(vframe* start_vf)        PRODUCT_RETURN;\n+  void trace_frames()                            PRODUCT_RETURN;\n+\n+  \/\/ Print an annotated view of the stack frames\n+  void print_frame_layout(int depth = 0, bool validate_only = false) NOT_DEBUG_RETURN;\n+  void validate_frame_layout() {\n+    print_frame_layout(0, true);\n+  }\n+\n+  \/\/ Function for testing deoptimization\n+  void deoptimize();\n+  void make_zombies();\n+\n+  void deoptimize_marked_methods();\n+\n+ public:\n+  \/\/ Returns the running thread as a JavaThread\n+  static JavaThread* current() {\n+    return JavaThread::cast(Thread::current());\n+  }\n+\n+  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n+  static inline JavaThread* current_or_null();\n+\n+  \/\/ Casts\n+  static JavaThread* cast(Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to JavaThread\");\n+    return static_cast<JavaThread*>(t);\n+  }\n+\n+  static const JavaThread* cast(const Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to const JavaThread\");\n+    return static_cast<const JavaThread*>(t);\n+  }\n+\n+  \/\/ Returns the active Java thread.  Do not use this if you know you are calling\n+  \/\/ from a JavaThread, as it's slower than JavaThread::current.  If called from\n+  \/\/ the VMThread, it also returns the JavaThread that instigated the VMThread's\n+  \/\/ operation.  You may not want that either.\n+  static JavaThread* active();\n+\n+ protected:\n+  virtual void pre_run();\n+  virtual void run();\n+  void thread_main_inner();\n+  virtual void post_run();\n+\n+ public:\n+  \/\/ Thread local information maintained by JVMTI.\n+  void set_jvmti_thread_state(JvmtiThreadState *value)                           { _jvmti_thread_state = value; }\n+  \/\/ A JvmtiThreadState is lazily allocated. This jvmti_thread_state()\n+  \/\/ getter is used to get this JavaThread's JvmtiThreadState if it has\n+  \/\/ one which means NULL can be returned. JvmtiThreadState::state_for()\n+  \/\/ is used to get the specified JavaThread's JvmtiThreadState if it has\n+  \/\/ one or it allocates a new JvmtiThreadState for the JavaThread and\n+  \/\/ returns it. JvmtiThreadState::state_for() will return NULL only if\n+  \/\/ the specified JavaThread is exiting.\n+  JvmtiThreadState *jvmti_thread_state() const                                   { return _jvmti_thread_state; }\n+  static ByteSize jvmti_thread_state_offset()                                    { return byte_offset_of(JavaThread, _jvmti_thread_state); }\n+\n+#if INCLUDE_JVMTI\n+  \/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n+  JvmtiThreadState *rebind_to_jvmti_thread_state_of(oop thread_oop);\n+#endif\n+\n+  \/\/ JVMTI PopFrame support\n+  \/\/ Setting and clearing popframe_condition\n+  \/\/ All of these enumerated values are bits. popframe_pending\n+  \/\/ indicates that a PopFrame() has been requested and not yet been\n+  \/\/ completed. popframe_processing indicates that that PopFrame() is in\n+  \/\/ the process of being completed. popframe_force_deopt_reexecution_bit\n+  \/\/ indicates that special handling is required when returning to a\n+  \/\/ deoptimized caller.\n+  enum PopCondition {\n+    popframe_inactive                      = 0x00,\n+    popframe_pending_bit                   = 0x01,\n+    popframe_processing_bit                = 0x02,\n+    popframe_force_deopt_reexecution_bit   = 0x04\n+  };\n+  PopCondition popframe_condition()                   { return (PopCondition) _popframe_condition; }\n+  void set_popframe_condition(PopCondition c)         { _popframe_condition = c; }\n+  void set_popframe_condition_bit(PopCondition c)     { _popframe_condition |= c; }\n+  void clear_popframe_condition()                     { _popframe_condition = popframe_inactive; }\n+  static ByteSize popframe_condition_offset()         { return byte_offset_of(JavaThread, _popframe_condition); }\n+  bool has_pending_popframe()                         { return (popframe_condition() & popframe_pending_bit) != 0; }\n+  bool popframe_forcing_deopt_reexecution()           { return (popframe_condition() & popframe_force_deopt_reexecution_bit) != 0; }\n+  void clear_popframe_forcing_deopt_reexecution()     { _popframe_condition &= ~popframe_force_deopt_reexecution_bit; }\n+\n+  bool pop_frame_in_process(void)                     { return ((_popframe_condition & popframe_processing_bit) != 0); }\n+  void set_pop_frame_in_process(void)                 { _popframe_condition |= popframe_processing_bit; }\n+  void clr_pop_frame_in_process(void)                 { _popframe_condition &= ~popframe_processing_bit; }\n+\n+  int frames_to_pop_failed_realloc() const            { return _frames_to_pop_failed_realloc; }\n+  void set_frames_to_pop_failed_realloc(int nb)       { _frames_to_pop_failed_realloc = nb; }\n+  void dec_frames_to_pop_failed_realloc()             { _frames_to_pop_failed_realloc--; }\n+\n+ private:\n+  \/\/ Saved incoming arguments to popped frame.\n+  \/\/ Used only when popped interpreted frame returns to deoptimized frame.\n+  void*    _popframe_preserved_args;\n+  int      _popframe_preserved_args_size;\n+\n+ public:\n+  void  popframe_preserve_args(ByteSize size_in_bytes, void* start);\n+  void* popframe_preserved_args();\n+  ByteSize popframe_preserved_args_size();\n+  WordSize popframe_preserved_args_size_in_words();\n+  void  popframe_free_preserved_args();\n+\n+\n+ private:\n+  JvmtiThreadState *_jvmti_thread_state;\n+\n+  \/\/ Used by the interpreter in fullspeed mode for frame pop, method\n+  \/\/ entry, method exit and single stepping support. This field is\n+  \/\/ only set to non-zero at a safepoint or using a direct handshake\n+  \/\/ (see EnterInterpOnlyModeClosure).\n+  \/\/ It can be set to zero asynchronously to this threads execution (i.e., without\n+  \/\/ safepoint\/handshake or a lock) so we have to be very careful.\n+  \/\/ Accesses by other threads are synchronized using JvmtiThreadState_lock though.\n+  int               _interp_only_mode;\n+\n+ public:\n+  \/\/ used by the interpreter for fullspeed debugging support (see above)\n+  static ByteSize interp_only_mode_offset() { return byte_offset_of(JavaThread, _interp_only_mode); }\n+  bool is_interp_only_mode()                { return (_interp_only_mode != 0); }\n+  int get_interp_only_mode()                { return _interp_only_mode; }\n+  int set_interp_only_mode(int val)         { return _interp_only_mode = val; }\n+  void increment_interp_only_mode()         { ++_interp_only_mode; }\n+  void decrement_interp_only_mode()         { --_interp_only_mode; }\n+\n+  \/\/ support for cached flag that indicates whether exceptions need to be posted for this thread\n+  \/\/ if this is false, we can avoid deoptimizing when events are thrown\n+  \/\/ this gets set to reflect whether jvmtiExport::post_exception_throw would actually do anything\n+ private:\n+  int    _should_post_on_exceptions_flag;\n+\n+ public:\n+  int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }\n+  void  set_should_post_on_exceptions_flag(int val)  { _should_post_on_exceptions_flag = val; }\n+\n+ private:\n+  ThreadStatistics *_thread_stat;\n+\n+ public:\n+  ThreadStatistics* get_thread_stat() const    { return _thread_stat; }\n+\n+  \/\/ Return a blocker object for which this thread is blocked parking.\n+  oop current_park_blocker();\n+\n+ private:\n+  static size_t _stack_size_at_create;\n+\n+ public:\n+  static inline size_t stack_size_at_create(void) {\n+    return _stack_size_at_create;\n+  }\n+  static inline void set_stack_size_at_create(size_t value) {\n+    _stack_size_at_create = value;\n+  }\n+\n+  \/\/ Machine dependent stuff\n+#include OS_CPU_HEADER(javaThread)\n+\n+  \/\/ JSR166 per-thread parker\n+ private:\n+  Parker _parker;\n+ public:\n+  Parker* parker() { return &_parker; }\n+\n+ public:\n+  \/\/ clearing\/querying jni attach status\n+  bool is_attaching_via_jni() const { return _jni_attach_state == _attaching_via_jni; }\n+  bool has_attached_via_jni() const { return is_attaching_via_jni() || _jni_attach_state == _attached_via_jni; }\n+  inline void set_done_attaching_via_jni();\n+\n+  \/\/ Stack dump assistance:\n+  \/\/ Track the class we want to initialize but for which we have to wait\n+  \/\/ on its init_lock() because it is already being initialized.\n+  void set_class_to_be_initialized(InstanceKlass* k);\n+  InstanceKlass* class_to_be_initialized() const;\n+\n+private:\n+  InstanceKlass* _class_to_be_initialized;\n+\n+  \/\/ java.lang.Thread.sleep support\n+  ParkEvent * _SleepEvent;\n+public:\n+  bool sleep(jlong millis);\n+\n+  \/\/ java.lang.Thread interruption support\n+  void interrupt();\n+  bool is_interrupted(bool clear_interrupted);\n+\n+  static OopStorage* thread_oop_storage();\n+\n+  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n+\n+  \/\/ Helper function to create the java.lang.Thread object for a\n+  \/\/ VM-internal thread. The thread will have the given name, be\n+  \/\/ part of the System ThreadGroup and if is_visible is true will be\n+  \/\/ discoverable via the system ThreadGroup.\n+  static Handle create_system_thread_object(const char* name, bool is_visible, TRAPS);\n+\n+  \/\/ Helper function to start a VM-internal daemon thread.\n+  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n+  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                    Handle thread_oop, ThreadPriority prio);\n+\n+  \/\/ Helper function to do vm_exit_on_initialization for osthread\n+  \/\/ resource allocation failure.\n+  static void vm_exit_on_osthread_failure(JavaThread* thread);\n+\n+  \/\/ AsyncGetCallTrace support\n+  inline bool in_asgct(void) {return _in_asgct;}\n+  inline void set_in_asgct(bool value) {_in_asgct = value;}\n+};\n+\n+inline JavaThread* JavaThread::current_or_null() {\n+  Thread* current = Thread::current_or_null();\n+  return current != nullptr ? JavaThread::cast(current) : nullptr;\n+}\n+\n+class UnlockFlagSaver {\n+  private:\n+    JavaThread* _thread;\n+    bool _do_not_unlock;\n+  public:\n+    UnlockFlagSaver(JavaThread* t) {\n+      _thread = t;\n+      _do_not_unlock = t->do_not_unlock_if_synchronized();\n+      t->set_do_not_unlock_if_synchronized(false);\n+    }\n+    ~UnlockFlagSaver() {\n+      _thread->set_do_not_unlock_if_synchronized(_do_not_unlock);\n+    }\n+};\n+\n+class JNIHandleMark : public StackObj {\n+  JavaThread* _thread;\n+ public:\n+  JNIHandleMark(JavaThread* thread) : _thread(thread) {\n+    thread->push_jni_handle_block();\n+  }\n+  ~JNIHandleMark() { _thread->pop_jni_handle_block(); }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_JAVATHREAD_HPP\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1179,"deletions":0,"binary":false,"changes":1179,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_JAVATHREAD_INLINE_HPP\n+#define SHARE_RUNTIME_JAVATHREAD_INLINE_HPP\n+\n+#include \"runtime\/javaThread.hpp\"\n+\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"gc\/shared\/tlab_globals.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+\n+inline void JavaThread::set_suspend_flag(SuspendFlags f) {\n+  uint32_t flags;\n+  do {\n+    flags = _suspend_flags;\n+  }\n+  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags | f)) != flags);\n+}\n+inline void JavaThread::clear_suspend_flag(SuspendFlags f) {\n+  uint32_t flags;\n+  do {\n+    flags = _suspend_flags;\n+  }\n+  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags & ~f)) != flags);\n+}\n+\n+inline void JavaThread::set_trace_flag() {\n+  set_suspend_flag(_trace_flag);\n+}\n+inline void JavaThread::clear_trace_flag() {\n+  clear_suspend_flag(_trace_flag);\n+}\n+inline void JavaThread::set_obj_deopt_flag() {\n+  set_suspend_flag(_obj_deopt);\n+}\n+inline void JavaThread::clear_obj_deopt_flag() {\n+  clear_suspend_flag(_obj_deopt);\n+}\n+\n+#if INCLUDE_JVMTI\n+inline void JavaThread::set_carrier_thread_suspended() {\n+  _carrier_thread_suspended = true;\n+}\n+inline void JavaThread::clear_carrier_thread_suspended() {\n+  _carrier_thread_suspended = false;\n+}\n+#endif\n+\n+class AsyncExceptionHandshake : public AsyncHandshakeClosure {\n+  OopHandle _exception;\n+  bool _is_ThreadDeath;\n+ public:\n+  AsyncExceptionHandshake(OopHandle& o, const char* name = \"AsyncExceptionHandshake\")\n+  : AsyncHandshakeClosure(name), _exception(o) {\n+    _is_ThreadDeath = exception()->is_a(vmClasses::ThreadDeath_klass());\n+  }\n+\n+  ~AsyncExceptionHandshake() {\n+    assert(!_exception.is_empty(), \"invariant\");\n+    _exception.release(Universe::vm_global());\n+  }\n+\n+  void do_thread(Thread* thr) {\n+    JavaThread* self = JavaThread::cast(thr);\n+    assert(self == JavaThread::current(), \"must be\");\n+\n+    self->handle_async_exception(exception());\n+  }\n+  oop exception() {\n+    assert(!_exception.is_empty(), \"invariant\");\n+    return _exception.resolve();\n+  }\n+  bool is_async_exception()   { return true; }\n+  bool is_ThreadDeath()       { return _is_ThreadDeath; }\n+};\n+\n+class UnsafeAccessErrorHandshake : public AsyncHandshakeClosure {\n+ public:\n+  UnsafeAccessErrorHandshake() : AsyncHandshakeClosure(\"UnsafeAccessErrorHandshake\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* self = JavaThread::cast(thr);\n+    assert(self == JavaThread::current(), \"must be\");\n+\n+    self->handshake_state()->handle_unsafe_access_error();\n+  }\n+  bool is_async_exception()   { return true; }\n+};\n+\n+inline void JavaThread::set_pending_unsafe_access_error() {\n+  if (!has_async_exception_condition()) {\n+    Handshake::execute(new UnsafeAccessErrorHandshake(), this);\n+  }\n+}\n+\n+inline bool JavaThread::has_async_exception_condition(bool ThreadDeath_only) {\n+  return handshake_state()->has_async_exception_operation(ThreadDeath_only);\n+}\n+\n+inline JavaThread::NoAsyncExceptionDeliveryMark::NoAsyncExceptionDeliveryMark(JavaThread *t) : _target(t) {\n+  assert(!_target->handshake_state()->async_exceptions_blocked(), \"Nesting is not supported\");\n+  _target->handshake_state()->set_async_exceptions_blocked(true);\n+}\n+inline JavaThread::NoAsyncExceptionDeliveryMark::~NoAsyncExceptionDeliveryMark() {\n+  _target->handshake_state()->set_async_exceptions_blocked(false);\n+}\n+\n+inline JavaThreadState JavaThread::thread_state() const    {\n+#if defined(PPC64) || defined (AARCH64) || defined(RISCV64)\n+  \/\/ Use membars when accessing volatile _thread_state. See\n+  \/\/ Threads::create_vm() for size checks.\n+  return (JavaThreadState) Atomic::load_acquire((volatile jint*)&_thread_state);\n+#else\n+  return _thread_state;\n+#endif\n+}\n+\n+inline void JavaThread::set_thread_state(JavaThreadState s) {\n+  assert(current_or_null() == NULL || current_or_null() == this,\n+         \"state change should only be called by the current thread\");\n+#if defined(PPC64) || defined (AARCH64) || defined(RISCV64)\n+  \/\/ Use membars when accessing volatile _thread_state. See\n+  \/\/ Threads::create_vm() for size checks.\n+  Atomic::release_store((volatile jint*)&_thread_state, (jint)s);\n+#else\n+  _thread_state = s;\n+#endif\n+}\n+\n+inline void JavaThread::set_thread_state_fence(JavaThreadState s) {\n+  set_thread_state(s);\n+  OrderAccess::fence();\n+}\n+\n+ThreadSafepointState* JavaThread::safepoint_state() const  {\n+  return _safepoint_state;\n+}\n+\n+void JavaThread::set_safepoint_state(ThreadSafepointState *state) {\n+  _safepoint_state = state;\n+}\n+\n+bool JavaThread::is_at_poll_safepoint() {\n+  return _safepoint_state->is_at_poll_safepoint();\n+}\n+\n+bool JavaThread::is_vthread_mounted() const {\n+  return vthread_continuation() != nullptr;\n+}\n+\n+const ContinuationEntry* JavaThread::vthread_continuation() const {\n+  for (ContinuationEntry* c = last_continuation(); c != nullptr; c = c->parent()) {\n+    if (c->is_virtual_thread())\n+      return c;\n+  }\n+  return nullptr;\n+}\n+\n+void JavaThread::enter_critical() {\n+  assert(Thread::current() == this ||\n+         (Thread::current()->is_VM_thread() &&\n+         SafepointSynchronize::is_synchronizing()),\n+         \"this must be current thread or synchronizing\");\n+  _jni_active_critical++;\n+}\n+\n+inline void JavaThread::set_done_attaching_via_jni() {\n+  _jni_attach_state = _attached_via_jni;\n+  OrderAccess::fence();\n+}\n+\n+inline bool JavaThread::is_exiting() const {\n+  \/\/ Use load-acquire so that setting of _terminated by\n+  \/\/ JavaThread::exit() is seen more quickly.\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  return l_terminated == _thread_exiting || check_is_terminated(l_terminated);\n+}\n+\n+inline bool JavaThread::is_terminated() const {\n+  \/\/ Use load-acquire so that setting of _terminated by\n+  \/\/ JavaThread::exit() is seen more quickly.\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  return check_is_terminated(l_terminated);\n+}\n+\n+inline void JavaThread::set_terminated(TerminatedTypes t) {\n+  \/\/ use release-store so the setting of _terminated is seen more quickly\n+  Atomic::release_store(&_terminated, t);\n+}\n+\n+\/\/ Allow tracking of class initialization monitor use\n+inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {\n+  assert((k == NULL && _class_to_be_initialized != NULL) ||\n+         (k != NULL && _class_to_be_initialized == NULL), \"incorrect usage\");\n+  assert(this == Thread::current(), \"Only the current thread can set this field\");\n+  _class_to_be_initialized = k;\n+}\n+\n+inline InstanceKlass* JavaThread::class_to_be_initialized() const {\n+  return _class_to_be_initialized;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_JAVATHREAD_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -34,1 +36,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -59,1 +60,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -52,1 +53,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -66,1 +67,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepointVerifiers.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/semaphore.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -52,1 +53,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"cds\/dynamicArchive.hpp\"\n-#include \"cds\/metaspaceShared.hpp\"\n-#include \"classfile\/classLoader.hpp\"\n@@ -33,8 +30,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"code\/scopeDesc.hpp\"\n-#include \"compiler\/compileBroker.hpp\"\n-#include \"compiler\/compileTask.hpp\"\n-#include \"compiler\/compilerThread.hpp\"\n@@ -42,12 +31,0 @@\n-#include \"gc\/shared\/barrierSetNMethod.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/gcId.hpp\"\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n-#include \"gc\/shared\/oopStorage.hpp\"\n-#include \"gc\/shared\/oopStorageSet.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/tlab_globals.hpp\"\n-#include \"interpreter\/interpreter.hpp\"\n-#include \"interpreter\/linkResolver.hpp\"\n-#include \"interpreter\/oopMapCache.hpp\"\n@@ -57,3 +34,0 @@\n-#include \"logging\/logAsyncWriter.hpp\"\n-#include \"logging\/logConfiguration.hpp\"\n-#include \"logging\/logStream.hpp\"\n@@ -62,1 +36,0 @@\n-#include \"memory\/oopFactory.hpp\"\n@@ -64,5 +37,0 @@\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n@@ -70,9 +38,0 @@\n-#include \"oops\/oopHandle.inline.hpp\"\n-#include \"oops\/symbol.hpp\"\n-#include \"oops\/typeArrayOop.inline.hpp\"\n-#include \"oops\/verifyOopClosure.hpp\"\n-#include \"prims\/jvm_misc.hpp\"\n-#include \"prims\/jvmtiDeferredUpdates.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"prims\/jvmtiThreadState.inline.hpp\"\n-#include \"runtime\/arguments.hpp\"\n@@ -80,7 +39,0 @@\n-#include \"runtime\/continuation.hpp\"\n-#include \"runtime\/continuationEntry.inline.hpp\"\n-#include \"runtime\/continuationHelper.inline.hpp\"\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n@@ -88,9 +40,1 @@\n-#include \"runtime\/handshake.hpp\"\n-#include \"runtime\/init.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"runtime\/jniPeriodicChecker.hpp\"\n-#include \"runtime\/monitorDeflationThread.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -98,1 +42,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -103,7 +46,0 @@\n-#include \"runtime\/safepointVerifiers.hpp\"\n-#include \"runtime\/serviceThread.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"runtime\/stackFrameStream.inline.hpp\"\n-#include \"runtime\/stackWatermarkSet.hpp\"\n-#include \"runtime\/statSampler.hpp\"\n-#include \"runtime\/task.hpp\"\n@@ -111,1 +47,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -113,12 +48,0 @@\n-#include \"runtime\/threadStatisticalInfo.hpp\"\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n-#include \"runtime\/timer.hpp\"\n-#include \"runtime\/timerTrace.hpp\"\n-#include \"runtime\/vframe.inline.hpp\"\n-#include \"runtime\/vframeArray.hpp\"\n-#include \"runtime\/vframe_hp.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"runtime\/vmOperations.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-#include \"services\/attachListener.hpp\"\n-#include \"services\/management.hpp\"\n@@ -126,6 +49,0 @@\n-#include \"services\/threadService.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/defaultStream.hpp\"\n-#include \"utilities\/dtrace.hpp\"\n-#include \"utilities\/events.hpp\"\n@@ -133,1 +50,0 @@\n-#include \"utilities\/preserveException.hpp\"\n@@ -135,15 +51,0 @@\n-#include \"utilities\/vmError.hpp\"\n-#if INCLUDE_JVMCI\n-#include \"jvmci\/jvmci.hpp\"\n-#include \"jvmci\/jvmciEnv.hpp\"\n-#endif\n-#ifdef COMPILER1\n-#include \"c1\/c1_Compiler.hpp\"\n-#endif\n-#ifdef COMPILER2\n-#include \"opto\/c2compiler.hpp\"\n-#include \"opto\/idealGraphPrinter.hpp\"\n-#endif\n-#if INCLUDE_RTM_OPT\n-#include \"runtime\/rtmLocking.hpp\"\n-#endif\n@@ -154,29 +55,0 @@\n-\/\/ Initialization after module runtime initialization\n-void universe_post_module_init();  \/\/ must happen after call_initPhase2\n-\n-#ifdef DTRACE_ENABLED\n-\n-\/\/ Only bother with this argument setup if dtrace is available\n-\n-  #define HOTSPOT_THREAD_PROBE_start HOTSPOT_THREAD_START\n-  #define HOTSPOT_THREAD_PROBE_stop HOTSPOT_THREAD_STOP\n-\n-  #define DTRACE_THREAD_PROBE(probe, javathread)                           \\\n-    {                                                                      \\\n-      ResourceMark rm(this);                                               \\\n-      int len = 0;                                                         \\\n-      const char* name = (javathread)->name();                             \\\n-      len = strlen(name);                                                  \\\n-      HOTSPOT_THREAD_PROBE_##probe(\/* probe = start, stop *\/               \\\n-        (char *) name, len,                                                \\\n-        java_lang_Thread::thread_id((javathread)->threadObj()),            \\\n-        (uintptr_t) (javathread)->osthread()->thread_id(),                 \\\n-        java_lang_Thread::is_daemon((javathread)->threadObj()));           \\\n-    }\n-\n-#else \/\/  ndef DTRACE_ENABLED\n-\n-  #define DTRACE_THREAD_PROBE(probe, javathread)\n-\n-#endif \/\/ ndef DTRACE_ENABLED\n-\n@@ -198,8 +70,0 @@\n-void JavaThread::smr_delete() {\n-  if (_on_thread_list) {\n-    ThreadsSMRSupport::smr_delete(this);\n-  } else {\n-    delete this;\n-  }\n-}\n-\n@@ -691,815 +555,0 @@\n-static void initialize_class(Symbol* class_name, TRAPS) {\n-  Klass* klass = SystemDictionary::resolve_or_fail(class_name, true, CHECK);\n-  InstanceKlass::cast(klass)->initialize(CHECK);\n-}\n-\n-\n-\/\/ Creates the initial ThreadGroup\n-static Handle create_initial_thread_group(TRAPS) {\n-  Handle system_instance = JavaCalls::construct_new_instance(\n-                            vmClasses::ThreadGroup_klass(),\n-                            vmSymbols::void_method_signature(),\n-                            CHECK_NH);\n-  Universe::set_system_thread_group(system_instance());\n-\n-  Handle string = java_lang_String::create_from_str(\"main\", CHECK_NH);\n-  Handle main_instance = JavaCalls::construct_new_instance(\n-                            vmClasses::ThreadGroup_klass(),\n-                            vmSymbols::threadgroup_string_void_signature(),\n-                            system_instance,\n-                            string,\n-                            CHECK_NH);\n-  return main_instance;\n-}\n-\n-\/\/ Creates the initial Thread, and sets it to running.\n-static void create_initial_thread(Handle thread_group, JavaThread* thread,\n-                                 TRAPS) {\n-  InstanceKlass* ik = vmClasses::Thread_klass();\n-  assert(ik->is_initialized(), \"must be\");\n-  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n-\n-  \/\/ Cannot use JavaCalls::construct_new_instance because the java.lang.Thread\n-  \/\/ constructor calls Thread.current(), which must be set here for the\n-  \/\/ initial thread.\n-  java_lang_Thread::set_thread(thread_oop(), thread);\n-  thread->set_threadOopHandles(thread_oop());\n-\n-  Handle string = java_lang_String::create_from_str(\"main\", CHECK);\n-\n-  JavaValue result(T_VOID);\n-  JavaCalls::call_special(&result, thread_oop,\n-                          ik,\n-                          vmSymbols::object_initializer_name(),\n-                          vmSymbols::threadgroup_string_void_signature(),\n-                          thread_group,\n-                          string,\n-                          CHECK);\n-\n-  \/\/ Set thread status to running since main thread has\n-  \/\/ been started and running.\n-  java_lang_Thread::set_thread_status(thread_oop(),\n-                                      JavaThreadStatus::RUNNABLE);\n-}\n-\n-\/\/ Extract version and vendor specific information from\n-\/\/ java.lang.VersionProps fields.\n-\/\/ Returned char* is allocated in the thread's resource area\n-\/\/ so must be copied for permanency.\n-static const char* get_java_version_info(InstanceKlass* ik,\n-                                         Symbol* field_name) {\n-  fieldDescriptor fd;\n-  bool found = ik != NULL &&\n-               ik->find_local_field(field_name,\n-                                    vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop);\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ General purpose hook into Java code, run once when the VM is initialized.\n-\/\/ The Java library method itself may be changed independently from the VM.\n-static void call_postVMInitHook(TRAPS) {\n-  Klass* klass = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_PostVMInitHook(), THREAD);\n-  if (klass != NULL) {\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_static(&result, klass, vmSymbols::run_method_name(),\n-                           vmSymbols::void_method_signature(),\n-                           CHECK);\n-  }\n-}\n-\n-\/\/ Initialized by VMThread at vm_global_init\n-static OopStorage* _thread_oop_storage = NULL;\n-\n-OopStorage* JavaThread::thread_oop_storage() {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  return _thread_oop_storage;\n-}\n-\n-void JavaThread::set_threadOopHandles(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _threadObj   = OopHandle(_thread_oop_storage, p);\n-  _vthread     = OopHandle(_thread_oop_storage, p);\n-  _jvmti_vthread = OopHandle(_thread_oop_storage, NULL);\n-  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n-}\n-\n-oop JavaThread::threadObj() const {\n-  return _threadObj.resolve();\n-}\n-\n-oop JavaThread::vthread() const {\n-  return _vthread.resolve();\n-}\n-\n-void JavaThread::set_vthread(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _vthread.replace(p);\n-}\n-\n-oop JavaThread::jvmti_vthread() const {\n-  return _jvmti_vthread.resolve();\n-}\n-\n-void JavaThread::set_jvmti_vthread(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _jvmti_vthread.replace(p);\n-}\n-\n-oop JavaThread::extentLocalCache() const {\n-  return _extentLocalCache.resolve();\n-}\n-\n-void JavaThread::set_extentLocalCache(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _extentLocalCache.replace(p);\n-}\n-\n-void JavaThread::allocate_threadObj(Handle thread_group, const char* thread_name,\n-                                    bool daemon, TRAPS) {\n-  assert(thread_group.not_null(), \"thread group should be specified\");\n-  assert(threadObj() == NULL, \"should only create Java thread object once\");\n-\n-  InstanceKlass* ik = vmClasses::Thread_klass();\n-  assert(ik->is_initialized(), \"must be\");\n-  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n-\n-  \/\/ We are called from jni_AttachCurrentThread\/jni_AttachCurrentThreadAsDaemon.\n-  \/\/ We cannot use JavaCalls::construct_new_instance because the java.lang.Thread\n-  \/\/ constructor calls Thread.current(), which must be set here.\n-  java_lang_Thread::set_thread(thread_oop(), this);\n-  set_threadOopHandles(thread_oop());\n-\n-  JavaValue result(T_VOID);\n-  if (thread_name != NULL) {\n-    Handle name = java_lang_String::create_from_str(thread_name, CHECK);\n-    \/\/ Thread gets assigned specified name and null target\n-    JavaCalls::call_special(&result,\n-                            thread_oop,\n-                            ik,\n-                            vmSymbols::object_initializer_name(),\n-                            vmSymbols::threadgroup_string_void_signature(),\n-                            thread_group,\n-                            name,\n-                            THREAD);\n-  } else {\n-    \/\/ Thread gets assigned name \"Thread-nnn\" and null target\n-    \/\/ (java.lang.Thread doesn't have a constructor taking only a ThreadGroup argument)\n-    JavaCalls::call_special(&result,\n-                            thread_oop,\n-                            ik,\n-                            vmSymbols::object_initializer_name(),\n-                            vmSymbols::threadgroup_runnable_void_signature(),\n-                            thread_group,\n-                            Handle(),\n-                            THREAD);\n-  }\n-  os::set_priority(this, NormPriority);\n-\n-  if (daemon) {\n-    java_lang_Thread::set_daemon(thread_oop());\n-  }\n-}\n-\n-\/\/ ======= JavaThread ========\n-\n-#if INCLUDE_JVMCI\n-\n-jlong* JavaThread::_jvmci_old_thread_counters;\n-\n-bool jvmci_counters_include(JavaThread* thread) {\n-  return !JVMCICountersExcludeCompiler || !thread->is_Compiler_thread();\n-}\n-\n-void JavaThread::collect_counters(jlong* array, int length) {\n-  assert(length == JVMCICounterSize, \"wrong value\");\n-  for (int i = 0; i < length; i++) {\n-    array[i] = _jvmci_old_thread_counters[i];\n-  }\n-  for (JavaThread* tp : ThreadsListHandle()) {\n-    if (jvmci_counters_include(tp)) {\n-      for (int i = 0; i < length; i++) {\n-        array[i] += tp->_jvmci_counters[i];\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Attempt to enlarge the array for per thread counters.\n-jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {\n-  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n-  if (new_counters == NULL) {\n-    return NULL;\n-  }\n-  if (old_counters == NULL) {\n-    old_counters = new_counters;\n-    memset(old_counters, 0, sizeof(jlong) * new_size);\n-  } else {\n-    for (int i = 0; i < MIN2((int) current_size, new_size); i++) {\n-      new_counters[i] = old_counters[i];\n-    }\n-    if (new_size > current_size) {\n-      memset(new_counters + current_size, 0, sizeof(jlong) * (new_size - current_size));\n-    }\n-    FREE_C_HEAP_ARRAY(jlong, old_counters);\n-  }\n-  return new_counters;\n-}\n-\n-\/\/ Attempt to enlarge the array for per thread counters.\n-bool JavaThread::resize_counters(int current_size, int new_size) {\n-  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n-  if (new_counters == NULL) {\n-    return false;\n-  } else {\n-    _jvmci_counters = new_counters;\n-    return true;\n-  }\n-}\n-\n-class VM_JVMCIResizeCounters : public VM_Operation {\n- private:\n-  int _new_size;\n-  bool _failed;\n-\n- public:\n-  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n-  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n-  bool allow_nested_vm_operations() const        { return true; }\n-  void doit() {\n-    \/\/ Resize the old thread counters array\n-    jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n-    if (new_counters == NULL) {\n-      _failed = true;\n-      return;\n-    } else {\n-      JavaThread::_jvmci_old_thread_counters = new_counters;\n-    }\n-\n-    \/\/ Now resize each threads array\n-    for (JavaThread* tp : ThreadsListHandle()) {\n-      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {\n-        _failed = true;\n-        break;\n-      }\n-    }\n-    if (!_failed) {\n-      JVMCICounterSize = _new_size;\n-    }\n-  }\n-\n-  bool failed() { return _failed; }\n-};\n-\n-bool JavaThread::resize_all_jvmci_counters(int new_size) {\n-  VM_JVMCIResizeCounters op(new_size);\n-  VMThread::execute(&op);\n-  return !op.failed();\n-}\n-\n-#endif \/\/ INCLUDE_JVMCI\n-\n-#ifdef ASSERT\n-\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n-void JavaThread::check_possible_safepoint() {\n-  if (_no_safepoint_count > 0) {\n-    print_owned_locks();\n-    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n-  }\n-#ifdef CHECK_UNHANDLED_OOPS\n-  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n-  clear_unhandled_oops();\n-#endif \/\/ CHECK_UNHANDLED_OOPS\n-\n-  \/\/ Macos\/aarch64 should be in the right state for safepoint (e.g.\n-  \/\/ deoptimization needs WXWrite).  Crashes caused by the wrong state rarely\n-  \/\/ happens in practice, making such issues hard to find and reproduce.\n-#if defined(__APPLE__) && defined(AARCH64)\n-  if (AssertWXAtThreadSync) {\n-    assert_wx_state(WXWrite);\n-  }\n-#endif\n-}\n-\n-void JavaThread::check_for_valid_safepoint_state() {\n-  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n-  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n-  \/\/ are held.\n-  check_possible_safepoint();\n-\n-  if (thread_state() != _thread_in_vm) {\n-    fatal(\"LEAF method calling lock?\");\n-  }\n-\n-  if (GCALotAtAllSafepoints) {\n-    \/\/ We could enter a safepoint here and thus have a gc\n-    InterfaceSupport::check_gc_alot();\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n-\/\/ A JavaThread is a normal Java thread\n-\n-JavaThread::JavaThread() :\n-  \/\/ Initialize fields\n-\n-  _in_asgct(false),\n-  _on_thread_list(false),\n-  DEBUG_ONLY(_java_call_counter(0) COMMA)\n-  _entry_point(nullptr),\n-  _deopt_mark(nullptr),\n-  _deopt_nmethod(nullptr),\n-  _vframe_array_head(nullptr),\n-  _vframe_array_last(nullptr),\n-  _jvmti_deferred_updates(nullptr),\n-  _callee_target(nullptr),\n-  _vm_result(nullptr),\n-  _vm_result_2(nullptr),\n-\n-  _current_pending_monitor(NULL),\n-  _current_pending_monitor_is_from_java(true),\n-  _current_waiting_monitor(NULL),\n-  _active_handles(NULL),\n-  _free_handle_block(NULL),\n-  _Stalled(0),\n-\n-  _monitor_chunks(nullptr),\n-\n-  _suspend_flags(0),\n-\n-  _thread_state(_thread_new),\n-  _saved_exception_pc(nullptr),\n-#ifdef ASSERT\n-  _no_safepoint_count(0),\n-  _visited_for_critical_count(false),\n-#endif\n-\n-  _terminated(_not_terminated),\n-  _in_deopt_handler(0),\n-  _doing_unsafe_access(false),\n-  _do_not_unlock_if_synchronized(false),\n-#if INCLUDE_JVMTI\n-  _carrier_thread_suspended(false),\n-  _is_in_VTMS_transition(false),\n-#ifdef ASSERT\n-  _is_VTMS_transition_disabler(false),\n-#endif\n-#endif\n-  _jni_attach_state(_not_attaching_via_jni),\n-#if INCLUDE_JVMCI\n-  _pending_deoptimization(-1),\n-  _pending_monitorenter(false),\n-  _pending_transfer_to_interpreter(false),\n-  _in_retryable_allocation(false),\n-  _pending_failed_speculation(0),\n-  _jvmci{nullptr},\n-  _libjvmci_runtime(nullptr),\n-  _jvmci_counters(nullptr),\n-  _jvmci_reserved0(0),\n-  _jvmci_reserved1(0),\n-  _jvmci_reserved_oop0(nullptr),\n-#endif \/\/ INCLUDE_JVMCI\n-\n-  _exception_oop(oop()),\n-  _exception_pc(0),\n-  _exception_handler_pc(0),\n-  _is_method_handle_return(0),\n-\n-  _jni_active_critical(0),\n-  _pending_jni_exception_check_fn(nullptr),\n-  _depth_first_number(0),\n-\n-  \/\/ JVMTI PopFrame support\n-  _popframe_condition(popframe_inactive),\n-  _frames_to_pop_failed_realloc(0),\n-\n-  _cont_entry(nullptr),\n-  _cont_fastpath(0),\n-  _cont_fastpath_thread_state(1),\n-  _held_monitor_count(0),\n-\n-  _handshake(this),\n-\n-  _popframe_preserved_args(nullptr),\n-  _popframe_preserved_args_size(0),\n-\n-  _jvmti_thread_state(nullptr),\n-  _interp_only_mode(0),\n-  _should_post_on_exceptions_flag(JNI_FALSE),\n-  _thread_stat(new ThreadStatistics()),\n-\n-  _parker(),\n-\n-  _class_to_be_initialized(nullptr),\n-\n-  _SleepEvent(ParkEvent::Allocate(this))\n-{\n-  set_jni_functions(jni_functions());\n-\n-#if INCLUDE_JVMCI\n-  assert(_jvmci._implicit_exception_pc == nullptr, \"must be\");\n-  if (JVMCICounterSize > 0) {\n-    resize_counters(0, (int) JVMCICounterSize);\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n-\n-  \/\/ Setup safepoint state info for this thread\n-  ThreadSafepointState::create(this);\n-\n-  SafepointMechanism::initialize_header(this);\n-\n-  set_requires_cross_modify_fence(false);\n-\n-  pd_initialize();\n-  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n-}\n-\n-JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n-  if (is_attaching_via_jni) {\n-    _jni_attach_state = _attaching_via_jni;\n-  }\n-}\n-\n-\n-\/\/ interrupt support\n-\n-void JavaThread::interrupt() {\n-  \/\/ All callers should have 'this' thread protected by a\n-  \/\/ ThreadsListHandle so that it cannot terminate and deallocate\n-  \/\/ itself.\n-  debug_only(check_for_dangling_thread_pointer(this);)\n-\n-  \/\/ For Windows _interrupt_event\n-  WINDOWS_ONLY(osthread()->set_interrupted(true);)\n-\n-  \/\/ For Thread.sleep\n-  _SleepEvent->unpark();\n-\n-  \/\/ For JSR166 LockSupport.park\n-  parker()->unpark();\n-\n-  \/\/ For ObjectMonitor and JvmtiRawMonitor\n-  _ParkEvent->unpark();\n-}\n-\n-\n-bool JavaThread::is_interrupted(bool clear_interrupted) {\n-  debug_only(check_for_dangling_thread_pointer(this);)\n-\n-  if (_threadObj.peek() == NULL) {\n-    \/\/ If there is no j.l.Thread then it is impossible to have\n-    \/\/ been interrupted. We can find NULL during VM initialization\n-    \/\/ or when a JNI thread is still in the process of attaching.\n-    \/\/ In such cases this must be the current thread.\n-    assert(this == Thread::current(), \"invariant\");\n-    return false;\n-  }\n-\n-  bool interrupted = java_lang_Thread::interrupted(threadObj());\n-\n-  \/\/ NOTE that since there is no \"lock\" around the interrupt and\n-  \/\/ is_interrupted operations, there is the possibility that the\n-  \/\/ interrupted flag will be \"false\" but that the\n-  \/\/ low-level events will be in the signaled state. This is\n-  \/\/ intentional. The effect of this is that Object.wait() and\n-  \/\/ LockSupport.park() will appear to have a spurious wakeup, which\n-  \/\/ is allowed and not harmful, and the possibility is so rare that\n-  \/\/ it is not worth the added complexity to add yet another lock.\n-  \/\/ For the sleep event an explicit reset is performed on entry\n-  \/\/ to JavaThread::sleep, so there is no early return. It has also been\n-  \/\/ recommended not to put the interrupted flag into the \"event\"\n-  \/\/ structure because it hides the issue.\n-  \/\/ Also, because there is no lock, we must only clear the interrupt\n-  \/\/ state if we are going to report that we were interrupted; otherwise\n-  \/\/ an interrupt that happens just after we read the field would be lost.\n-  if (interrupted && clear_interrupted) {\n-    assert(this == Thread::current(), \"only the current thread can clear\");\n-    java_lang_Thread::set_interrupted(threadObj(), false);\n-    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n-  }\n-\n-  return interrupted;\n-}\n-\n-void JavaThread::block_if_vm_exited() {\n-  if (_terminated == _vm_exited) {\n-    \/\/ _vm_exited is set at safepoint, and Threads_lock is never released\n-    \/\/ we will block here forever.\n-    \/\/ Here we can be doing a jump from a safe state to an unsafe state without\n-    \/\/ proper transition, but it happens after the final safepoint has begun.\n-    set_thread_state(_thread_in_vm);\n-    Threads_lock->lock();\n-    ShouldNotReachHere();\n-  }\n-}\n-\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n-  _jni_attach_state = _not_attaching_via_jni;\n-  set_entry_point(entry_point);\n-  \/\/ Create the native thread itself.\n-  \/\/ %note runtime_23\n-  os::ThreadType thr_type = os::java_thread;\n-  thr_type = entry_point == &CompilerThread::thread_entry ? os::compiler_thread :\n-                                                            os::java_thread;\n-  os::create_thread(this, thr_type, stack_sz);\n-  \/\/ The _osthread may be NULL here because we ran out of memory (too many threads active).\n-  \/\/ We need to throw and OutOfMemoryError - however we cannot do this here because the caller\n-  \/\/ may hold a lock and all locks must be unlocked before throwing the exception (throwing\n-  \/\/ the exception consists of creating the exception object & initializing it, initialization\n-  \/\/ will leave the VM via a JavaCall and then all locks must be unlocked).\n-  \/\/\n-  \/\/ The thread is still suspended when we reach here. Thread must be explicit started\n-  \/\/ by creator! Furthermore, the thread must also explicitly be added to the Threads list\n-  \/\/ by calling Threads:add. The reason why this is not done here, is because the thread\n-  \/\/ object must be fully initialized (take a look at JVM_Start)\n-}\n-\n-JavaThread::~JavaThread() {\n-\n-  \/\/ Ask ServiceThread to release the threadObj OopHandle\n-  ServiceThread::add_oop_handle_release(_threadObj);\n-  ServiceThread::add_oop_handle_release(_vthread);\n-  ServiceThread::add_oop_handle_release(_jvmti_vthread);\n-\n-  \/\/ Return the sleep event to the free list\n-  ParkEvent::Release(_SleepEvent);\n-  _SleepEvent = NULL;\n-\n-  \/\/ Free any remaining  previous UnrollBlock\n-  vframeArray* old_array = vframe_array_last();\n-\n-  if (old_array != NULL) {\n-    Deoptimization::UnrollBlock* old_info = old_array->unroll_block();\n-    old_array->set_unroll_block(NULL);\n-    delete old_info;\n-    delete old_array;\n-  }\n-\n-  JvmtiDeferredUpdates* updates = deferred_updates();\n-  if (updates != NULL) {\n-    \/\/ This can only happen if thread is destroyed before deoptimization occurs.\n-    assert(updates->count() > 0, \"Updates holder not deleted\");\n-    \/\/ free deferred updates.\n-    delete updates;\n-    set_deferred_updates(NULL);\n-  }\n-\n-  \/\/ All Java related clean up happens in exit\n-  ThreadSafepointState::destroy(this);\n-  if (_thread_stat != NULL) delete _thread_stat;\n-\n-#if INCLUDE_JVMCI\n-  if (JVMCICounterSize > 0) {\n-    FREE_C_HEAP_ARRAY(jlong, _jvmci_counters);\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n-}\n-\n-\n-\/\/ First JavaThread specific code executed by a new Java thread.\n-void JavaThread::pre_run() {\n-  \/\/ empty - see comments in run()\n-}\n-\n-\/\/ The main routine called by a new Java thread. This isn't overridden\n-\/\/ by subclasses, instead different subclasses define a different \"entry_point\"\n-\/\/ which defines the actual logic for that kind of thread.\n-void JavaThread::run() {\n-  \/\/ initialize thread-local alloc buffer related fields\n-  initialize_tlab();\n-\n-  _stack_overflow_state.create_stack_guard_pages();\n-\n-  cache_global_variables();\n-\n-  \/\/ Thread is now sufficiently initialized to be handled by the safepoint code as being\n-  \/\/ in the VM. Change thread state from _thread_new to _thread_in_vm\n-  assert(this->thread_state() == _thread_new, \"wrong thread state\");\n-  set_thread_state(_thread_in_vm);\n-\n-  \/\/ Before a thread is on the threads list it is always safe, so after leaving the\n-  \/\/ _thread_new we should emit a instruction barrier. The distance to modified code\n-  \/\/ from here is probably far enough, but this is consistent and safe.\n-  OrderAccess::cross_modify_fence();\n-\n-  assert(JavaThread::current() == this, \"sanity check\");\n-  assert(!Thread::current()->owns_locks(), \"sanity check\");\n-\n-  DTRACE_THREAD_PROBE(start, this);\n-\n-  \/\/ This operation might block. We call that after all safepoint checks for a new thread has\n-  \/\/ been completed.\n-  set_active_handles(JNIHandleBlock::allocate_block());\n-\n-  if (JvmtiExport::should_post_thread_life()) {\n-    JvmtiExport::post_thread_start(this);\n-\n-  }\n-\n-  \/\/ We call another function to do the rest so we are sure that the stack addresses used\n-  \/\/ from there will be lower than the stack base just computed.\n-  thread_main_inner();\n-}\n-\n-void JavaThread::thread_main_inner() {\n-  assert(JavaThread::current() == this, \"sanity check\");\n-  assert(_threadObj.peek() != NULL, \"just checking\");\n-\n-  \/\/ Execute thread entry point unless this thread has a pending exception\n-  \/\/ or has been stopped before starting.\n-  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n-  if (!this->has_pending_exception() &&\n-      !java_lang_Thread::is_stillborn(this->threadObj())) {\n-    {\n-      ResourceMark rm(this);\n-      this->set_native_thread_name(this->name());\n-    }\n-    HandleMark hm(this);\n-    this->entry_point()(this, this);\n-  }\n-\n-  DTRACE_THREAD_PROBE(stop, this);\n-\n-  \/\/ Cleanup is handled in post_run()\n-}\n-\n-\/\/ Shared teardown for all JavaThreads\n-void JavaThread::post_run() {\n-  this->exit(false);\n-  this->unregister_thread_stack_with_NMT();\n-  \/\/ Defer deletion to here to ensure 'this' is still referenceable in call_run\n-  \/\/ for any shared tear-down.\n-  this->smr_delete();\n-}\n-\n-static void ensure_join(JavaThread* thread) {\n-  \/\/ We do not need to grab the Threads_lock, since we are operating on ourself.\n-  Handle threadObj(thread, thread->threadObj());\n-  assert(threadObj.not_null(), \"java thread object must exist\");\n-  ObjectLocker lock(threadObj, thread);\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n-  thread->clear_pending_exception();\n-  \/\/ Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.\n-  java_lang_Thread::set_thread_status(threadObj(), JavaThreadStatus::TERMINATED);\n-  \/\/ Clear the native thread instance - this makes isAlive return false and allows the join()\n-  \/\/ to complete once we've done the notify_all below\n-  java_lang_Thread::set_thread(threadObj(), NULL);\n-  lock.notify_all(thread);\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n-  thread->clear_pending_exception();\n-}\n-\n-static bool is_daemon(oop threadObj) {\n-  return (threadObj != NULL && java_lang_Thread::is_daemon(threadObj));\n-}\n-\n-\/\/ For any new cleanup additions, please check to see if they need to be applied to\n-\/\/ cleanup_failed_attach_current_thread as well.\n-void JavaThread::exit(bool destroy_vm, ExitType exit_type) {\n-  assert(this == JavaThread::current(), \"thread consistency check\");\n-  assert(!is_exiting(), \"should not be exiting or terminated already\");\n-\n-  elapsedTimer _timer_exit_phase1;\n-  elapsedTimer _timer_exit_phase2;\n-  elapsedTimer _timer_exit_phase3;\n-  elapsedTimer _timer_exit_phase4;\n-\n-  if (log_is_enabled(Debug, os, thread, timer)) {\n-    _timer_exit_phase1.start();\n-  }\n-\n-  HandleMark hm(this);\n-  Handle uncaught_exception(this, this->pending_exception());\n-  this->clear_pending_exception();\n-  Handle threadObj(this, this->threadObj());\n-  assert(threadObj.not_null(), \"Java thread object should be created\");\n-\n-  if (!destroy_vm) {\n-    if (uncaught_exception.not_null()) {\n-      EXCEPTION_MARK;\n-      \/\/ Call method Thread.dispatchUncaughtException().\n-      Klass* thread_klass = vmClasses::Thread_klass();\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_virtual(&result,\n-                              threadObj, thread_klass,\n-                              vmSymbols::dispatchUncaughtException_name(),\n-                              vmSymbols::throwable_void_signature(),\n-                              uncaught_exception,\n-                              THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        ResourceMark rm(this);\n-        jio_fprintf(defaultStream::error_stream(),\n-                    \"\\nException: %s thrown from the UncaughtExceptionHandler\"\n-                    \" in thread \\\"%s\\\"\\n\",\n-                    pending_exception()->klass()->external_name(),\n-                    name());\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n-    }\n-\n-    if (!is_Compiler_thread()) {\n-      \/\/ We have finished executing user-defined Java code and now have to do the\n-      \/\/ implementation specific clean-up by calling Thread.exit(). We prevent any\n-      \/\/ asynchronous exceptions from being delivered while in Thread.exit()\n-      \/\/ to ensure the clean-up is not corrupted.\n-      NoAsyncExceptionDeliveryMark _no_async(this);\n-\n-      EXCEPTION_MARK;\n-      JavaValue result(T_VOID);\n-      Klass* thread_klass = vmClasses::Thread_klass();\n-      JavaCalls::call_virtual(&result,\n-                              threadObj, thread_klass,\n-                              vmSymbols::exit_method_name(),\n-                              vmSymbols::void_method_signature(),\n-                              THREAD);\n-      CLEAR_PENDING_EXCEPTION;\n-    }\n-\n-    \/\/ notify JVMTI\n-    if (JvmtiExport::should_post_thread_life()) {\n-      JvmtiExport::post_thread_end(this);\n-    }\n-  } else {\n-    \/\/ before_exit() has already posted JVMTI THREAD_END events\n-  }\n-\n-  \/\/ Cleanup any pending async exception now since we cannot access oops after\n-  \/\/ BarrierSet::barrier_set()->on_thread_detach() has been executed.\n-  if (has_async_exception_condition()) {\n-    handshake_state()->clean_async_exception_operation();\n-  }\n-\n-  \/\/ The careful dance between thread suspension and exit is handled here.\n-  \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n-  \/\/ we can just put in the exiting state and it will be correctly handled.\n-  \/\/ Also, no more async exceptions will be added to the queue after this point.\n-  set_terminated(_thread_exiting);\n-  ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n-\n-  if (log_is_enabled(Debug, os, thread, timer)) {\n-    _timer_exit_phase1.stop();\n-    _timer_exit_phase2.start();\n-  }\n-\n-  \/\/ Capture daemon status before the thread is marked as terminated.\n-  bool daemon = is_daemon(threadObj());\n-\n-  \/\/ Notify waiters on thread object. This has to be done after exit() is called\n-  \/\/ on the thread (if the thread is the last thread in a daemon ThreadGroup the\n-  \/\/ group should have the destroyed bit set before waiters are notified).\n-  ensure_join(this);\n-  assert(!this->has_pending_exception(), \"ensure_join should have cleared\");\n-\n-  if (log_is_enabled(Debug, os, thread, timer)) {\n-    _timer_exit_phase2.stop();\n-    _timer_exit_phase3.start();\n-  }\n-  \/\/ 6282335 JNI DetachCurrentThread spec states that all Java monitors\n-  \/\/ held by this thread must be released. The spec does not distinguish\n-  \/\/ between JNI-acquired and regular Java monitors. We can only see\n-  \/\/ regular Java monitors here if monitor enter-exit matching is broken.\n-  \/\/\n-  \/\/ ensure_join() ignores IllegalThreadStateExceptions, and so does\n-  \/\/ ObjectSynchronizer::release_monitors_owned_by_thread().\n-  if (exit_type == jni_detach) {\n-    \/\/ Sanity check even though JNI DetachCurrentThread() would have\n-    \/\/ returned JNI_ERR if there was a Java frame. JavaThread exit\n-    \/\/ should be done executing Java code by the time we get here.\n-    assert(!this->has_last_Java_frame(),\n-           \"should not have a Java frame when detaching or exiting\");\n-    ObjectSynchronizer::release_monitors_owned_by_thread(this);\n-    assert(!this->has_pending_exception(), \"release_monitors should have cleared\");\n-  }\n-\n-  assert(!Continuations::enabled() || this->held_monitor_count() == 0, \"held monitor count should be zero\");\n-\n-  \/\/ These things needs to be done while we are still a Java Thread. Make sure that thread\n-  \/\/ is in a consistent state, in case GC happens\n-  JFR_ONLY(Jfr::on_thread_exit(this);)\n-\n-  if (active_handles() != NULL) {\n-    JNIHandleBlock* block = active_handles();\n-    set_active_handles(NULL);\n-    JNIHandleBlock::release_block(block);\n-  }\n-\n-  if (free_handle_block() != NULL) {\n-    JNIHandleBlock* block = free_handle_block();\n-    set_free_handle_block(NULL);\n-    JNIHandleBlock::release_block(block);\n-  }\n-\n-  \/\/ These have to be removed while this is still a valid thread.\n-  _stack_overflow_state.remove_stack_guard_pages();\n-\n-  if (UseTLAB) {\n-    tlab().retire();\n-  }\n@@ -1507,3 +556,11 @@\n-  if (JvmtiEnv::environments_might_exist()) {\n-    JvmtiExport::cleanup_thread(this);\n-  }\n+\/\/ Ad-hoc mutual exclusion primitives: SpinLock\n+\/\/\n+\/\/ We employ SpinLocks _only for low-contention, fixed-length\n+\/\/ short-duration critical sections where we're concerned\n+\/\/ about native mutex_t or HotSpot Mutex:: latency.\n+\/\/\n+\/\/ TODO-FIXME: ListLock should be of type SpinLock.\n+\/\/ We should make this a 1st-class type, integrated into the lock\n+\/\/ hierarchy as leaf-locks.  Critically, the SpinLock structure\n+\/\/ should have sufficient padding to avoid false-sharing and excessive\n+\/\/ cache-coherency traffic.\n@@ -1511,7 +568,0 @@\n-  \/\/ We need to cache the thread name for logging purposes below as once\n-  \/\/ we have called on_thread_detach this thread must not access any oops.\n-  char* thread_name = NULL;\n-  if (log_is_enabled(Debug, os, thread, timer)) {\n-    ResourceMark rm(this);\n-    thread_name = os::strdup(name());\n-  }\n@@ -1519,3 +569,1 @@\n-  log_info(os, thread)(\"JavaThread %s (tid: \" UINTX_FORMAT \").\",\n-    exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n-    os::current_thread_id());\n+typedef volatile int SpinLockT;\n@@ -1523,3 +571,3 @@\n-  if (log_is_enabled(Debug, os, thread, timer)) {\n-    _timer_exit_phase3.stop();\n-    _timer_exit_phase4.start();\n+void Thread::SpinAcquire(volatile int * adr, const char * LockName) {\n+  if (Atomic::cmpxchg(adr, 0, 1) == 0) {\n+    return;   \/\/ normal fast-path return\n@@ -1528,5 +576,15 @@\n-#if INCLUDE_JVMCI\n-  if (JVMCICounterSize > 0) {\n-    if (jvmci_counters_include(this)) {\n-      for (int i = 0; i < JVMCICounterSize; i++) {\n-        _jvmci_old_thread_counters[i] += _jvmci_counters[i];\n+  \/\/ Slow-path : We've encountered contention -- Spin\/Yield\/Block strategy.\n+  int ctr = 0;\n+  int Yields = 0;\n+  for (;;) {\n+    while (*adr != 0) {\n+      ++ctr;\n+      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n+        if (Yields > 5) {\n+          os::naked_short_sleep(1);\n+        } else {\n+          os::naked_yield();\n+          ++Yields;\n+        }\n+      } else {\n+        SpinPause();\n@@ -1535,2443 +593,1 @@\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n-\n-  \/\/ Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread.\n-  \/\/ We call BarrierSet::barrier_set()->on_thread_detach() here so no touching of oops after this point.\n-  Threads::remove(this, daemon);\n-\n-  if (log_is_enabled(Debug, os, thread, timer)) {\n-    _timer_exit_phase4.stop();\n-    log_debug(os, thread, timer)(\"name='%s'\"\n-                                 \", exit-phase1=\" JLONG_FORMAT\n-                                 \", exit-phase2=\" JLONG_FORMAT\n-                                 \", exit-phase3=\" JLONG_FORMAT\n-                                 \", exit-phase4=\" JLONG_FORMAT,\n-                                 thread_name,\n-                                 _timer_exit_phase1.milliseconds(),\n-                                 _timer_exit_phase2.milliseconds(),\n-                                 _timer_exit_phase3.milliseconds(),\n-                                 _timer_exit_phase4.milliseconds());\n-    os::free(thread_name);\n-  }\n-}\n-\n-void JavaThread::cleanup_failed_attach_current_thread(bool is_daemon) {\n-  if (active_handles() != NULL) {\n-    JNIHandleBlock* block = active_handles();\n-    set_active_handles(NULL);\n-    JNIHandleBlock::release_block(block);\n-  }\n-\n-  if (free_handle_block() != NULL) {\n-    JNIHandleBlock* block = free_handle_block();\n-    set_free_handle_block(NULL);\n-    JNIHandleBlock::release_block(block);\n-  }\n-\n-  \/\/ These have to be removed while this is still a valid thread.\n-  _stack_overflow_state.remove_stack_guard_pages();\n-\n-  if (UseTLAB) {\n-    tlab().retire();\n-  }\n-\n-  Threads::remove(this, is_daemon);\n-  this->smr_delete();\n-}\n-\n-JavaThread* JavaThread::active() {\n-  Thread* thread = Thread::current();\n-  if (thread->is_Java_thread()) {\n-    return JavaThread::cast(thread);\n-  } else {\n-    assert(thread->is_VM_thread(), \"this must be a vm thread\");\n-    VM_Operation* op = ((VMThread*) thread)->vm_operation();\n-    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n-    return ret;\n-  }\n-}\n-\n-bool JavaThread::is_lock_owned(address adr) const {\n-  if (Thread::is_lock_owned(adr)) return true;\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) return true;\n-  }\n-\n-  return false;\n-}\n-\n-bool JavaThread::is_lock_owned_current(address adr) const {\n-  address stack_end = _stack_base - _stack_size;\n-  const ContinuationEntry* ce = vthread_continuation();\n-  address stack_base = ce != nullptr ? (address)ce->entry_sp() : _stack_base;\n-  if (stack_base > adr && adr >= stack_end) {\n-    return true;\n-  }\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-}\n-\n-bool JavaThread::is_lock_owned_carrier(address adr) const {\n-  assert(is_vthread_mounted(), \"\");\n-  address stack_end = _stack_base - _stack_size;\n-  address stack_base = (address)vthread_continuation()->entry_sp();\n-  return stack_base > adr && adr >= stack_end;\n-}\n-\n-oop JavaThread::exception_oop() const {\n-  return Atomic::load(&_exception_oop);\n-}\n-\n-void JavaThread::set_exception_oop(oop o) {\n-  Atomic::store(&_exception_oop, o);\n-}\n-\n-void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {\n-  chunk->set_next(monitor_chunks());\n-  set_monitor_chunks(chunk);\n-}\n-\n-void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {\n-  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n-  if (monitor_chunks() == chunk) {\n-    set_monitor_chunks(chunk->next());\n-  } else {\n-    MonitorChunk* prev = monitor_chunks();\n-    while (prev->next() != chunk) prev = prev->next();\n-    prev->set_next(chunk->next());\n-  }\n-}\n-\n-void JavaThread::handle_special_runtime_exit_condition() {\n-  if (is_obj_deopt_suspend()) {\n-    frame_anchor()->make_walkable();\n-    wait_for_object_deoptimization();\n-  }\n-  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n-}\n-\n-\n-\/\/ Asynchronous exceptions support\n-\/\/\n-void JavaThread::handle_async_exception(oop java_throwable) {\n-  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n-  assert(!is_at_poll_safepoint(), \"should have never called this method\");\n-\n-  if (has_last_Java_frame()) {\n-    frame f = last_frame();\n-    if (f.is_runtime_frame()) {\n-      \/\/ If the topmost frame is a runtime stub, then we are calling into\n-      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n-      \/\/ must deoptimize the caller before continuing, as the compiled exception\n-      \/\/ handler table may not be valid.\n-      RegisterMap reg_map(this, false);\n-      frame compiled_frame = f.sender(&reg_map);\n-      if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n-        Deoptimization::deoptimize(this, compiled_frame);\n-      }\n-    }\n-  }\n-\n-  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n-  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n-\n-    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n-    set_pending_exception(java_throwable, __FILE__, __LINE__);\n-\n-    \/\/ Clear any extent-local bindings on ThreadDeath\n-    set_extentLocalCache(NULL);\n-    oop threadOop = threadObj();\n-    assert(threadOop != NULL, \"must be\");\n-    java_lang_Thread::clear_extentLocalBindings(threadOop);\n-\n-    LogTarget(Info, exceptions) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n-      }\n-      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n-    }\n-  }\n-}\n-\n-void JavaThread::install_async_exception(AsyncExceptionHandshake* aeh) {\n-  \/\/ Do not throw asynchronous exceptions against the compiler thread\n-  \/\/ or if the thread is already exiting.\n-  if (!can_call_java() || is_exiting()) {\n-    delete aeh;\n-    return;\n-  }\n-\n-  \/\/ Don't install a new pending async exception if there is already\n-  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n-  \/\/ wait()\/sleep()\/park() and return.\n-  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n-    java_lang_Thread::set_interrupted(threadObj(), true);\n-    this->interrupt();\n-    delete aeh;\n-    return;\n-  }\n-\n-  oop exception = aeh->exception();\n-  Handshake::execute(aeh, this);  \/\/ Install asynchronous handshake\n-\n-  ResourceMark rm;\n-  if (log_is_enabled(Info, exceptions)) {\n-    log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n-                         InstanceKlass::cast(exception->klass())->external_name());\n-  }\n-  \/\/ for AbortVMOnException flag\n-  Exceptions::debug_check_abort(exception->klass()->external_name());\n-\n-  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n-  java_lang_Thread::set_interrupted(threadObj(), true);\n-  this->interrupt();\n-}\n-\n-class InstallAsyncExceptionHandshake : public HandshakeClosure {\n-  AsyncExceptionHandshake* _aeh;\n-public:\n-  InstallAsyncExceptionHandshake(AsyncExceptionHandshake* aeh) :\n-    HandshakeClosure(\"InstallAsyncException\"), _aeh(aeh) {}\n-  ~InstallAsyncExceptionHandshake() {\n-    \/\/ If InstallAsyncExceptionHandshake was never executed we need to clean up _aeh.\n-    delete _aeh;\n-  }\n-  void do_thread(Thread* thr) {\n-    JavaThread* target = JavaThread::cast(thr);\n-    target->install_async_exception(_aeh);\n-    _aeh = nullptr;\n-  }\n-};\n-\n-void JavaThread::send_async_exception(JavaThread* target, oop java_throwable) {\n-  OopHandle e(Universe::vm_global(), java_throwable);\n-  InstallAsyncExceptionHandshake iaeh(new AsyncExceptionHandshake(e));\n-  Handshake::execute(&iaeh, target);\n-}\n-\n-#if INCLUDE_JVMTI\n-void JavaThread::set_is_in_VTMS_transition(bool val) {\n-  _is_in_VTMS_transition = val;\n-}\n-\n-#ifdef ASSERT\n-void JavaThread::set_is_VTMS_transition_disabler(bool val) {\n-  _is_VTMS_transition_disabler = val;\n-}\n-#endif\n-#endif\n-\n-\/\/ External suspension mechanism.\n-\/\/\n-\/\/ Guarantees on return (for a valid target thread):\n-\/\/   - Target thread will not execute any new bytecode.\n-\/\/   - Target thread will not enter any new monitors.\n-\/\/\n-bool JavaThread::java_suspend() {\n-#if INCLUDE_JVMTI\n-  \/\/ Suspending a JavaThread in VTMS transition or disabling VTMS transitions can cause deadlocks.\n-  assert(!is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n-  assert(!is_VTMS_transition_disabler(), \"no suspend allowed for VTMS transition disablers\");\n-#endif\n-\n-  guarantee(Thread::is_JavaThread_protected(\/* target *\/ this),\n-            \"target JavaThread is not protected in calling context.\");\n-  return this->handshake_state()->suspend();\n-}\n-\n-bool JavaThread::java_resume() {\n-  guarantee(Thread::is_JavaThread_protected_by_TLH(\/* target *\/ this),\n-            \"missing ThreadsListHandle in calling context.\");\n-  return this->handshake_state()->resume();\n-}\n-\n-\/\/ Wait for another thread to perform object reallocation and relocking on behalf of\n-\/\/ this thread. The current thread is required to change to _thread_blocked in order\n-\/\/ to be seen to be safepoint\/handshake safe whilst suspended and only after becoming\n-\/\/ handshake safe, the other thread can complete the handshake used to synchronize\n-\/\/ with this thread and then perform the reallocation and relocking.\n-\/\/ See EscapeBarrier::sync_and_suspend_*()\n-\n-void JavaThread::wait_for_object_deoptimization() {\n-  assert(!has_last_Java_frame() || frame_anchor()->walkable(), \"should have walkable stack\");\n-  assert(this == Thread::current(), \"invariant\");\n-\n-  bool spin_wait = os::is_MP();\n-  do {\n-    ThreadBlockInVM tbivm(this, true \/* allow_suspend *\/);\n-    \/\/ Wait for object deoptimization if requested.\n-    if (spin_wait) {\n-      \/\/ A single deoptimization is typically very short. Microbenchmarks\n-      \/\/ showed 5% better performance when spinning.\n-      const uint spin_limit = 10 * SpinYield::default_spin_limit;\n-      SpinYield spin(spin_limit);\n-      for (uint i = 0; is_obj_deopt_suspend() && i < spin_limit; i++) {\n-        spin.wait();\n-      }\n-      \/\/ Spin just once\n-      spin_wait = false;\n-    } else {\n-      MonitorLocker ml(this, EscapeBarrier_lock, Monitor::_no_safepoint_check_flag);\n-      if (is_obj_deopt_suspend()) {\n-        ml.wait();\n-      }\n-    }\n-    \/\/ A handshake for obj. deoptimization suspend could have been processed so\n-    \/\/ we must check after processing.\n-  } while (is_obj_deopt_suspend());\n-}\n-\n-#ifdef ASSERT\n-\/\/ Verify the JavaThread has not yet been published in the Threads::list, and\n-\/\/ hence doesn't need protection from concurrent access at this stage.\n-void JavaThread::verify_not_published() {\n-  \/\/ Cannot create a ThreadsListHandle here and check !tlh.includes(this)\n-  \/\/ since an unpublished JavaThread doesn't participate in the\n-  \/\/ Thread-SMR protocol for keeping a ThreadsList alive.\n-  assert(!on_thread_list(), \"JavaThread shouldn't have been published yet!\");\n-}\n-#endif\n-\n-\/\/ Slow path when the native==>Java barriers detect a safepoint\/handshake is\n-\/\/ pending, when _suspend_flags is non-zero or when we need to process a stack\n-\/\/ watermark. Also check for pending async exceptions (except unsafe access error).\n-\/\/ Note only the native==>Java barriers can call this function when thread state\n-\/\/ is _thread_in_native_trans.\n-void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {\n-  assert(thread->thread_state() == _thread_in_native_trans, \"wrong state\");\n-  assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native->Java transition\");\n-\n-  thread->set_thread_state(_thread_in_vm);\n-\n-  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n-  SafepointMechanism::process_if_requested_with_exit_check(thread, true \/* check asyncs *\/);\n-\n-  \/\/ After returning from native, it could be that the stack frames are not\n-  \/\/ yet safe to use. We catch such situations in the subsequent stack watermark\n-  \/\/ barrier, which will trap unsafe stack frames.\n-  StackWatermarkSet::before_unwind(thread);\n-}\n-\n-#ifndef PRODUCT\n-\/\/ Deoptimization\n-\/\/ Function for testing deoptimization\n-void JavaThread::deoptimize() {\n-  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n-  bool deopt = false;           \/\/ Dump stack only if a deopt actually happens.\n-  bool only_at = strlen(DeoptimizeOnlyAt) > 0;\n-  \/\/ Iterate over all frames in the thread and deoptimize\n-  for (; !fst.is_done(); fst.next()) {\n-    if (fst.current()->can_be_deoptimized()) {\n-\n-      if (only_at) {\n-        \/\/ Deoptimize only at particular bcis.  DeoptimizeOnlyAt\n-        \/\/ consists of comma or carriage return separated numbers so\n-        \/\/ search for the current bci in that string.\n-        address pc = fst.current()->pc();\n-        nmethod* nm =  (nmethod*) fst.current()->cb();\n-        ScopeDesc* sd = nm->scope_desc_at(pc);\n-        char buffer[8];\n-        jio_snprintf(buffer, sizeof(buffer), \"%d\", sd->bci());\n-        size_t len = strlen(buffer);\n-        const char * found = strstr(DeoptimizeOnlyAt, buffer);\n-        while (found != NULL) {\n-          if ((found[len] == ',' || found[len] == '\\n' || found[len] == '\\0') &&\n-              (found == DeoptimizeOnlyAt || found[-1] == ',' || found[-1] == '\\n')) {\n-            \/\/ Check that the bci found is bracketed by terminators.\n-            break;\n-          }\n-          found = strstr(found + 1, buffer);\n-        }\n-        if (!found) {\n-          continue;\n-        }\n-      }\n-\n-      if (DebugDeoptimization && !deopt) {\n-        deopt = true; \/\/ One-time only print before deopt\n-        tty->print_cr(\"[BEFORE Deoptimization]\");\n-        trace_frames();\n-        trace_stack();\n-      }\n-      Deoptimization::deoptimize(this, *fst.current());\n-    }\n-  }\n-\n-  if (DebugDeoptimization && deopt) {\n-    tty->print_cr(\"[AFTER Deoptimization]\");\n-    trace_frames();\n-  }\n-}\n-\n-\n-\/\/ Make zombies\n-void JavaThread::make_zombies() {\n-  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n-    if (fst.current()->can_be_deoptimized()) {\n-      \/\/ it is a Java nmethod\n-      nmethod* nm = CodeCache::find_nmethod(fst.current()->pc());\n-      nm->make_not_entrant();\n-    }\n-  }\n-}\n-#endif \/\/ PRODUCT\n-\n-\n-void JavaThread::deoptimize_marked_methods() {\n-  if (!has_last_Java_frame()) return;\n-  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n-  for (; !fst.is_done(); fst.next()) {\n-    if (fst.current()->should_be_deoptimized()) {\n-      Deoptimization::deoptimize(this, *fst.current());\n-    }\n-  }\n-}\n-\n-#ifdef ASSERT\n-void JavaThread::verify_frame_info() {\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%s, java_call_counter=%d\",\n-         has_last_Java_frame() ? \"true\" : \"false\", java_call_counter());\n-}\n-#endif\n-\n-\/\/ Push on a new block of JNI handles.\n-void JavaThread::push_jni_handle_block() {\n-  \/\/ Allocate a new block for JNI handles.\n-  \/\/ Inlined code from jni_PushLocalFrame()\n-  JNIHandleBlock* old_handles = active_handles();\n-  JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(this);\n-  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n-  new_handles->set_pop_frame_link(old_handles);  \/\/ make sure java handles get gc'd.\n-  set_active_handles(new_handles);\n-}\n-\n-\/\/ Pop off the current block of JNI handles.\n-void JavaThread::pop_jni_handle_block() {\n-  \/\/ Release our JNI handle block\n-  JNIHandleBlock* old_handles = active_handles();\n-  JNIHandleBlock* new_handles = old_handles->pop_frame_link();\n-  assert(new_handles != nullptr, \"should never set active handles to null\");\n-  set_active_handles(new_handles);\n-  old_handles->set_pop_frame_link(NULL);\n-  JNIHandleBlock::release_block(old_handles, this);\n-}\n-\n-void JavaThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n-  \/\/ Verify that the deferred card marks have been flushed.\n-  assert(deferred_card_mark().is_empty(), \"Should be empty during GC\");\n-\n-  \/\/ Traverse the GCHandles\n-  Thread::oops_do_no_frames(f, cf);\n-\n-  if (active_handles() != NULL) {\n-    active_handles()->oops_do(f);\n-  }\n-\n-  DEBUG_ONLY(verify_frame_info();)\n-\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the monitor chunks\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-      chunk->oops_do(f);\n-    }\n-  }\n-\n-  assert(vframe_array_head() == NULL, \"deopt in progress at a safepoint!\");\n-  \/\/ If we have deferred set_locals there might be oops waiting to be\n-  \/\/ written\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(this);\n-  if (list != NULL) {\n-    for (int i = 0; i < list->length(); i++) {\n-      list->at(i)->oops_do(f);\n-    }\n-  }\n-\n-  \/\/ Traverse instance variables at the end since the GC may be moving things\n-  \/\/ around using this function\n-  f->do_oop((oop*) &_vm_result);\n-  f->do_oop((oop*) &_exception_oop);\n-#if INCLUDE_JVMCI\n-  f->do_oop((oop*) &_jvmci_reserved_oop0);\n-#endif\n-\n-  if (jvmti_thread_state() != NULL) {\n-    jvmti_thread_state()->oops_do(f, cf);\n-  }\n-}\n-\n-void JavaThread::oops_do_frames(OopClosure* f, CodeBlobClosure* cf) {\n-  if (!has_last_Java_frame()) {\n-    return;\n-  }\n-  \/\/ Finish any pending lazy GC activity for the frames\n-  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n-  \/\/ Traverse the execution stack\n-  for (StackFrameStream fst(this, true \/* update *\/, false \/* process_frames *\/); !fst.is_done(); fst.next()) {\n-    fst.current()->oops_do(f, cf, fst.register_map());\n-  }\n-}\n-\n-#ifdef ASSERT\n-void JavaThread::verify_states_for_handshake() {\n-  \/\/ This checks that the thread has a correct frame state during a handshake.\n-  verify_frame_info();\n-}\n-#endif\n-\n-void JavaThread::nmethods_do(CodeBlobClosure* cf) {\n-  DEBUG_ONLY(verify_frame_info();)\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n-\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the execution stack\n-    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n-      fst.current()->nmethods_do(cf);\n-    }\n-  }\n-\n-  if (jvmti_thread_state() != NULL) {\n-    jvmti_thread_state()->nmethods_do(cf);\n-  }\n-}\n-\n-void JavaThread::metadata_do(MetadataClosure* f) {\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the execution stack to call f() on the methods in the stack\n-    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n-      fst.current()->metadata_do(f);\n-    }\n-  } else if (is_Compiler_thread()) {\n-    \/\/ need to walk ciMetadata in current compile tasks to keep alive.\n-    CompilerThread* ct = (CompilerThread*)this;\n-    if (ct->env() != NULL) {\n-      ct->env()->metadata_do(f);\n-    }\n-    CompileTask* task = ct->task();\n-    if (task != NULL) {\n-      task->metadata_do(f);\n-    }\n-  }\n-}\n-\n-\/\/ Printing\n-const char* _get_thread_state_name(JavaThreadState _thread_state) {\n-  switch (_thread_state) {\n-  case _thread_uninitialized:     return \"_thread_uninitialized\";\n-  case _thread_new:               return \"_thread_new\";\n-  case _thread_new_trans:         return \"_thread_new_trans\";\n-  case _thread_in_native:         return \"_thread_in_native\";\n-  case _thread_in_native_trans:   return \"_thread_in_native_trans\";\n-  case _thread_in_vm:             return \"_thread_in_vm\";\n-  case _thread_in_vm_trans:       return \"_thread_in_vm_trans\";\n-  case _thread_in_Java:           return \"_thread_in_Java\";\n-  case _thread_in_Java_trans:     return \"_thread_in_Java_trans\";\n-  case _thread_blocked:           return \"_thread_blocked\";\n-  case _thread_blocked_trans:     return \"_thread_blocked_trans\";\n-  default:                        return \"unknown thread state\";\n-  }\n-}\n-\n-void JavaThread::print_thread_state_on(outputStream *st) const {\n-  st->print_cr(\"   JavaThread state: %s\", _get_thread_state_name(_thread_state));\n-}\n-\n-const char* JavaThread::thread_state_name() const {\n-  return _get_thread_state_name(_thread_state);\n-}\n-\n-\/\/ Called by Threads::print() for VM_PrintThreads operation\n-void JavaThread::print_on(outputStream *st, bool print_extended_info) const {\n-  st->print_raw(\"\\\"\");\n-  st->print_raw(name());\n-  st->print_raw(\"\\\" \");\n-  oop thread_oop = threadObj();\n-  if (thread_oop != NULL) {\n-    st->print(\"#\" INT64_FORMAT \" [%ld] \", (int64_t)java_lang_Thread::thread_id(thread_oop), (long) osthread()->thread_id());\n-    if (java_lang_Thread::is_daemon(thread_oop))  st->print(\"daemon \");\n-    st->print(\"prio=%d \", java_lang_Thread::priority(thread_oop));\n-  }\n-  Thread::print_on(st, print_extended_info);\n-  \/\/ print guess for valid stack memory region (assume 4K pages); helps lock debugging\n-  st->print_cr(\"[\" INTPTR_FORMAT \"]\", (intptr_t)last_Java_sp() & ~right_n_bits(12));\n-  if (thread_oop != NULL) {\n-    if (is_vthread_mounted()) {\n-      oop vt = vthread();\n-      assert(vt != NULL, \"\");\n-      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n-    } else {\n-      st->print_cr(\"   java.lang.Thread.State: %s\", java_lang_Thread::thread_status_name(thread_oop));\n-    }\n-  }\n-#ifndef PRODUCT\n-  _safepoint_state->print_on(st);\n-#endif \/\/ PRODUCT\n-  if (is_Compiler_thread()) {\n-    CompileTask *task = ((CompilerThread*)this)->task();\n-    if (task != NULL) {\n-      st->print(\"   Compiling: \");\n-      task->print(st, NULL, true, false);\n-    } else {\n-      st->print(\"   No compile task\");\n-    }\n-    st->cr();\n-  }\n-}\n-\n-void JavaThread::print() const { print_on(tty); }\n-\n-void JavaThread::print_name_on_error(outputStream* st, char *buf, int buflen) const {\n-  st->print(\"%s\", get_thread_name_string(buf, buflen));\n-}\n-\n-\/\/ Called by fatal error handler. The difference between this and\n-\/\/ JavaThread::print() is that we can't grab lock or allocate memory.\n-void JavaThread::print_on_error(outputStream* st, char *buf, int buflen) const {\n-  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n-  oop thread_obj = threadObj();\n-  if (thread_obj != NULL) {\n-    if (java_lang_Thread::is_daemon(thread_obj)) st->print(\" daemon\");\n-  }\n-  st->print(\" [\");\n-  st->print(\"%s\", _get_thread_state_name(_thread_state));\n-  if (osthread()) {\n-    st->print(\", id=%d\", osthread()->thread_id());\n-  }\n-  st->print(\", stack(\" PTR_FORMAT \",\" PTR_FORMAT \")\",\n-            p2i(stack_end()), p2i(stack_base()));\n-  st->print(\"]\");\n-\n-  ThreadsSMRSupport::print_info_on(this, st);\n-  return;\n-}\n-\n-\n-\/\/ Verification\n-\n-void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n-  \/\/ ignore if there is no stack\n-  if (!has_last_Java_frame()) return;\n-  \/\/ traverse the stack frames. Starts from top frame.\n-  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n-    frame* fr = fst.current();\n-    f(fr, fst.register_map());\n-  }\n-}\n-\n-static void frame_verify(frame* f, const RegisterMap *map) { f->verify(map); }\n-\n-void JavaThread::verify() {\n-  \/\/ Verify oops in the thread.\n-  oops_do(&VerifyOopClosure::verify_oop, NULL);\n-\n-  \/\/ Verify the stack frames.\n-  frames_do(frame_verify);\n-}\n-\n-\/\/ CR 6300358 (sub-CR 2137150)\n-\/\/ Most callers of this method assume that it can't return NULL but a\n-\/\/ thread may not have a name whilst it is in the process of attaching to\n-\/\/ the VM - see CR 6412693, and there are places where a JavaThread can be\n-\/\/ seen prior to having its threadObj set (e.g., JNI attaching threads and\n-\/\/ if vm exit occurs during initialization). These cases can all be accounted\n-\/\/ for such that this method never returns NULL.\n-const char* JavaThread::name() const  {\n-  if (Thread::is_JavaThread_protected(\/* target *\/ this)) {\n-    \/\/ The target JavaThread is protected so get_thread_name_string() is safe:\n-    return get_thread_name_string();\n-  }\n-\n-  \/\/ The target JavaThread is not protected so we return the default:\n-  return Thread::name();\n-}\n-\n-\/\/ Returns a non-NULL representation of this thread's name, or a suitable\n-\/\/ descriptive string if there is no set name.\n-const char* JavaThread::get_thread_name_string(char* buf, int buflen) const {\n-  const char* name_str;\n-  oop thread_obj = threadObj();\n-  if (thread_obj != NULL) {\n-    oop name = java_lang_Thread::name(thread_obj);\n-    if (name != NULL) {\n-      if (buf == NULL) {\n-        name_str = java_lang_String::as_utf8_string(name);\n-      } else {\n-        name_str = java_lang_String::as_utf8_string(name, buf, buflen);\n-      }\n-    } else if (is_attaching_via_jni()) { \/\/ workaround for 6412693 - see 6404306\n-      name_str = \"<no-name - thread is attaching>\";\n-    } else {\n-      name_str = \"<un-named>\";\n-    }\n-  } else {\n-    name_str = Thread::name();\n-  }\n-  assert(name_str != NULL, \"unexpected NULL thread name\");\n-  return name_str;\n-}\n-\n-\/\/ Helper to extract the name from the thread oop for logging.\n-const char* JavaThread::name_for(oop thread_obj) {\n-  assert(thread_obj != NULL, \"precondition\");\n-  oop name = java_lang_Thread::name(thread_obj);\n-  const char* name_str;\n-  if (name != NULL) {\n-    name_str = java_lang_String::as_utf8_string(name);\n-  } else {\n-    name_str = \"<un-named>\";\n-  }\n-  return name_str;\n-}\n-\n-void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {\n-\n-  assert(Threads_lock->owner() == Thread::current(), \"must have threads lock\");\n-  assert(NoPriority <= prio && prio <= MaxPriority, \"sanity check\");\n-  \/\/ Link Java Thread object <-> C++ Thread\n-\n-  \/\/ Get the C++ thread object (an oop) from the JNI handle (a jthread)\n-  \/\/ and put it into a new Handle.  The Handle \"thread_oop\" can then\n-  \/\/ be used to pass the C++ thread object to other methods.\n-\n-  \/\/ Set the Java level thread object (jthread) field of the\n-  \/\/ new thread (a JavaThread *) to C++ thread object using the\n-  \/\/ \"thread_oop\" handle.\n-\n-  \/\/ Set the thread field (a JavaThread *) of the\n-  \/\/ oop representing the java_lang_Thread to the new thread (a JavaThread *).\n-\n-  Handle thread_oop(Thread::current(),\n-                    JNIHandles::resolve_non_null(jni_thread));\n-  assert(InstanceKlass::cast(thread_oop->klass())->is_linked(),\n-         \"must be initialized\");\n-  set_threadOopHandles(thread_oop());\n-  java_lang_Thread::set_thread(thread_oop(), this);\n-\n-  if (prio == NoPriority) {\n-    prio = java_lang_Thread::priority(thread_oop());\n-    assert(prio != NoPriority, \"A valid priority should be present\");\n-  }\n-\n-  \/\/ Push the Java priority down to the native thread; needs Threads_lock\n-  Thread::set_priority(this, prio);\n-\n-  \/\/ Add the new thread to the Threads list and set it in motion.\n-  \/\/ We must have threads lock in order to call Threads::add.\n-  \/\/ It is crucial that we do not block before the thread is\n-  \/\/ added to the Threads list for if a GC happens, then the java_thread oop\n-  \/\/ will not be visited by GC.\n-  Threads::add(this);\n-}\n-\n-oop JavaThread::current_park_blocker() {\n-  \/\/ Support for JSR-166 locks\n-  oop thread_oop = threadObj();\n-  if (thread_oop != NULL) {\n-    return java_lang_Thread::park_blocker(thread_oop);\n-  }\n-  return NULL;\n-}\n-\n-\n-void JavaThread::print_stack_on(outputStream* st) {\n-  if (!has_last_Java_frame()) return;\n-\n-  Thread* current_thread = Thread::current();\n-  ResourceMark rm(current_thread);\n-  HandleMark hm(current_thread);\n-\n-  RegisterMap reg_map(this, true, true);\n-  vframe* start_vf = platform_thread_last_java_vframe(&reg_map);\n-  int count = 0;\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n-    if (f->is_java_frame()) {\n-      javaVFrame* jvf = javaVFrame::cast(f);\n-      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());\n-\n-      \/\/ Print out lock information\n-      if (JavaMonitorsInStackTrace) {\n-        jvf->print_lock_info_on(st, count);\n-      }\n-    } else {\n-      \/\/ Ignore non-Java frames\n-    }\n-\n-    \/\/ Bail-out case for too deep stacks if MaxJavaStackTraceDepth > 0\n-    count++;\n-    if (MaxJavaStackTraceDepth > 0 && MaxJavaStackTraceDepth == count) return;\n-  }\n-}\n-\n-#if INCLUDE_JVMTI\n-\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n-JvmtiThreadState* JavaThread::rebind_to_jvmti_thread_state_of(oop thread_oop) {\n-  set_jvmti_vthread(thread_oop);\n-\n-  \/\/ unbind current JvmtiThreadState from JavaThread\n-  JvmtiThreadState::unbind_from(jvmti_thread_state(), this);\n-\n-  \/\/ bind new JvmtiThreadState to JavaThread\n-  JvmtiThreadState::bind_to(java_lang_Thread::jvmti_thread_state(thread_oop), this);\n-\n-  return jvmti_thread_state();\n-}\n-#endif\n-\n-\/\/ JVMTI PopFrame support\n-void JavaThread::popframe_preserve_args(ByteSize size_in_bytes, void* start) {\n-  assert(_popframe_preserved_args == NULL, \"should not wipe out old PopFrame preserved arguments\");\n-  if (in_bytes(size_in_bytes) != 0) {\n-    _popframe_preserved_args = NEW_C_HEAP_ARRAY(char, in_bytes(size_in_bytes), mtThread);\n-    _popframe_preserved_args_size = in_bytes(size_in_bytes);\n-    Copy::conjoint_jbytes(start, _popframe_preserved_args, _popframe_preserved_args_size);\n-  }\n-}\n-\n-void* JavaThread::popframe_preserved_args() {\n-  return _popframe_preserved_args;\n-}\n-\n-ByteSize JavaThread::popframe_preserved_args_size() {\n-  return in_ByteSize(_popframe_preserved_args_size);\n-}\n-\n-WordSize JavaThread::popframe_preserved_args_size_in_words() {\n-  int sz = in_bytes(popframe_preserved_args_size());\n-  assert(sz % wordSize == 0, \"argument size must be multiple of wordSize\");\n-  return in_WordSize(sz \/ wordSize);\n-}\n-\n-void JavaThread::popframe_free_preserved_args() {\n-  assert(_popframe_preserved_args != NULL, \"should not free PopFrame preserved arguments twice\");\n-  FREE_C_HEAP_ARRAY(char, (char*)_popframe_preserved_args);\n-  _popframe_preserved_args = NULL;\n-  _popframe_preserved_args_size = 0;\n-}\n-\n-#ifndef PRODUCT\n-\n-void JavaThread::trace_frames() {\n-  tty->print_cr(\"[Describe stack]\");\n-  int frame_no = 1;\n-  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n-    tty->print(\"  %d. \", frame_no++);\n-    fst.current()->print_value_on(tty, this);\n-    tty->cr();\n-  }\n-}\n-\n-class PrintAndVerifyOopClosure: public OopClosure {\n- protected:\n-  template <class T> inline void do_oop_work(T* p) {\n-    oop obj = RawAccess<>::oop_load(p);\n-    if (obj == NULL) return;\n-    tty->print(INTPTR_FORMAT \": \", p2i(p));\n-    if (oopDesc::is_oop_or_null(obj)) {\n-      if (obj->is_objArray()) {\n-        tty->print_cr(\"valid objArray: \" INTPTR_FORMAT, p2i(obj));\n-      } else {\n-        obj->print();\n-      }\n-    } else {\n-      tty->print_cr(\"invalid oop: \" INTPTR_FORMAT, p2i(obj));\n-    }\n-    tty->cr();\n-  }\n- public:\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)  { do_oop_work(p); }\n-};\n-\n-#ifdef ASSERT\n-\/\/ Print or validate the layout of stack frames\n-void JavaThread::print_frame_layout(int depth, bool validate_only) {\n-  ResourceMark rm;\n-  PreserveExceptionMark pm(this);\n-  FrameValues values;\n-  int frame_no = 0;\n-  for (StackFrameStream fst(this, true, true, true); !fst.is_done(); fst.next()) {\n-    fst.current()->describe(values, ++frame_no, fst.register_map());\n-    if (depth == frame_no) break;\n-  }\n-  Continuation::describe(values);\n-  if (validate_only) {\n-    values.validate();\n-  } else {\n-    tty->print_cr(\"[Describe stack layout]\");\n-    values.print(this);\n-  }\n-}\n-#endif\n-\n-void JavaThread::trace_stack_from(vframe* start_vf) {\n-  ResourceMark rm;\n-  int vframe_no = 1;\n-  for (vframe* f = start_vf; f; f = f->sender()) {\n-    if (f->is_java_frame()) {\n-      javaVFrame::cast(f)->print_activation(vframe_no++);\n-    } else {\n-      f->print();\n-    }\n-    if (vframe_no > StackPrintLimit) {\n-      tty->print_cr(\"...<more frames>...\");\n-      return;\n-    }\n-  }\n-}\n-\n-\n-void JavaThread::trace_stack() {\n-  if (!has_last_Java_frame()) return;\n-  Thread* current_thread = Thread::current();\n-  ResourceMark rm(current_thread);\n-  HandleMark hm(current_thread);\n-  RegisterMap reg_map(this, true, true);\n-  trace_stack_from(last_java_vframe(&reg_map));\n-}\n-\n-\n-#endif \/\/ PRODUCT\n-\n-void JavaThread::inc_held_monitor_count() {\n-  if (!Continuations::enabled()) {\n-    return;\n-  }\n-  _held_monitor_count++;\n-}\n-\n-void JavaThread::dec_held_monitor_count() {\n-  if (!Continuations::enabled()) {\n-    return;\n-  }\n-  assert(_held_monitor_count > 0, \"\");\n-  _held_monitor_count--;\n-}\n-\n-frame JavaThread::vthread_last_frame() {\n-  assert (is_vthread_mounted(), \"Virtual thread not mounted\");\n-  return last_frame();\n-}\n-\n-frame JavaThread::carrier_last_frame(RegisterMap* reg_map) {\n-  const ContinuationEntry* entry = vthread_continuation();\n-  guarantee (entry != NULL, \"Not a carrier thread\");\n-  frame f = entry->to_frame();\n-  if (reg_map->process_frames()) {\n-    entry->flush_stack_processing(this);\n-  }\n-  entry->update_register_map(reg_map);\n-  return f.sender(reg_map);\n-}\n-\n-frame JavaThread::platform_thread_last_frame(RegisterMap* reg_map) {\n-  return is_vthread_mounted() ? carrier_last_frame(reg_map) : last_frame();\n-}\n-\n-javaVFrame* JavaThread::last_java_vframe(const frame f, RegisterMap *reg_map) {\n-  assert(reg_map != NULL, \"a map must be given\");\n-  for (vframe* vf = vframe::new_vframe(&f, reg_map, this); vf; vf = vf->sender()) {\n-    if (vf->is_java_frame()) return javaVFrame::cast(vf);\n-  }\n-  return NULL;\n-}\n-\n-oop JavaThread::get_continuation() const {\n-  assert(threadObj() != nullptr, \"must be set\");\n-  return java_lang_Thread::continuation(threadObj());\n-}\n-\n-Klass* JavaThread::security_get_caller_class(int depth) {\n-  ResetNoHandleMark rnhm;\n-  HandleMark hm(Thread::current());\n-\n-  vframeStream vfst(this);\n-  vfst.security_get_caller_frame(depth);\n-  if (!vfst.at_end()) {\n-    return vfst.method()->method_holder();\n-  }\n-  return NULL;\n-}\n-\n-\/\/ java.lang.Thread.sleep support\n-\/\/ Returns true if sleep time elapsed as expected, and false\n-\/\/ if the thread was interrupted.\n-bool JavaThread::sleep(jlong millis) {\n-  assert(this == Thread::current(),  \"thread consistency check\");\n-\n-  ParkEvent * const slp = this->_SleepEvent;\n-  \/\/ Because there can be races with thread interruption sending an unpark()\n-  \/\/ to the event, we explicitly reset it here to avoid an immediate return.\n-  \/\/ The actual interrupt state will be checked before we park().\n-  slp->reset();\n-  \/\/ Thread interruption establishes a happens-before ordering in the\n-  \/\/ Java Memory Model, so we need to ensure we synchronize with the\n-  \/\/ interrupt state.\n-  OrderAccess::fence();\n-\n-  jlong prevtime = os::javaTimeNanos();\n-\n-  for (;;) {\n-    \/\/ interruption has precedence over timing out\n-    if (this->is_interrupted(true)) {\n-      return false;\n-    }\n-\n-    if (millis <= 0) {\n-      return true;\n-    }\n-\n-    {\n-      ThreadBlockInVM tbivm(this);\n-      OSThreadWaitState osts(this->osthread(), false \/* not Object.wait() *\/);\n-      slp->park(millis);\n-    }\n-\n-    \/\/ Update elapsed time tracking\n-    jlong newtime = os::javaTimeNanos();\n-    if (newtime - prevtime < 0) {\n-      \/\/ time moving backwards, should only happen if no monotonic clock\n-      \/\/ not a guarantee() because JVM should not abort on kernel\/glibc bugs\n-      assert(false,\n-             \"unexpected time moving backwards detected in JavaThread::sleep()\");\n-    } else {\n-      millis -= (newtime - prevtime) \/ NANOSECS_PER_MILLISEC;\n-    }\n-    prevtime = newtime;\n-  }\n-}\n-\n-\n-\/\/ ======= Threads ========\n-\n-\/\/ The Threads class links together all active threads, and provides\n-\/\/ operations over all threads. It is protected by the Threads_lock,\n-\/\/ which is also used in other global contexts like safepointing.\n-\/\/ ThreadsListHandles are used to safely perform operations on one\n-\/\/ or more threads without the risk of the thread exiting during the\n-\/\/ operation.\n-\/\/\n-\/\/ Note: The Threads_lock is currently more widely used than we\n-\/\/ would like. We are actively migrating Threads_lock uses to other\n-\/\/ mechanisms in order to reduce Threads_lock contention.\n-\n-int         Threads::_number_of_threads = 0;\n-int         Threads::_number_of_non_daemon_threads = 0;\n-int         Threads::_return_code = 0;\n-uintx       Threads::_thread_claim_token = 1; \/\/ Never zero.\n-size_t      JavaThread::_stack_size_at_create = 0;\n-\n-#ifdef ASSERT\n-bool        Threads::_vm_complete = false;\n-#endif\n-\n-\/\/ All NonJavaThreads (i.e., every non-JavaThread in the system).\n-void Threads::non_java_threads_do(ThreadClosure* tc) {\n-  NoSafepointVerifier nsv;\n-  for (NonJavaThread::Iterator njti; !njti.end(); njti.step()) {\n-    tc->do_thread(njti.current());\n-  }\n-}\n-\n-\/\/ All JavaThreads\n-#define ALL_JAVA_THREADS(X) \\\n-  for (JavaThread* X : *ThreadsSMRSupport::get_java_thread_list())\n-\n-\/\/ All JavaThreads\n-void Threads::java_threads_do(ThreadClosure* tc) {\n-  assert_locked_or_safepoint(Threads_lock);\n-  \/\/ ALL_JAVA_THREADS iterates through all JavaThreads.\n-  ALL_JAVA_THREADS(p) {\n-    tc->do_thread(p);\n-  }\n-}\n-\n-void Threads::java_threads_and_vm_thread_do(ThreadClosure* tc) {\n-  assert_locked_or_safepoint(Threads_lock);\n-  java_threads_do(tc);\n-  tc->do_thread(VMThread::vm_thread());\n-}\n-\n-\/\/ All JavaThreads + all non-JavaThreads (i.e., every thread in the system).\n-void Threads::threads_do(ThreadClosure* tc) {\n-  assert_locked_or_safepoint(Threads_lock);\n-  java_threads_do(tc);\n-  non_java_threads_do(tc);\n-}\n-\n-void Threads::possibly_parallel_threads_do(bool is_par, ThreadClosure* tc) {\n-  uintx claim_token = Threads::thread_claim_token();\n-  ALL_JAVA_THREADS(p) {\n-    if (p->claim_threads_do(is_par, claim_token)) {\n-      tc->do_thread(p);\n-    }\n-  }\n-  VMThread* vmt = VMThread::vm_thread();\n-  if (vmt->claim_threads_do(is_par, claim_token)) {\n-    tc->do_thread(vmt);\n-  }\n-}\n-\n-\/\/ The system initialization in the library has three phases.\n-\/\/\n-\/\/ Phase 1: java.lang.System class initialization\n-\/\/     java.lang.System is a primordial class loaded and initialized\n-\/\/     by the VM early during startup.  java.lang.System.<clinit>\n-\/\/     only does registerNatives and keeps the rest of the class\n-\/\/     initialization work later until thread initialization completes.\n-\/\/\n-\/\/     System.initPhase1 initializes the system properties, the static\n-\/\/     fields in, out, and err. Set up java signal handlers, OS-specific\n-\/\/     system settings, and thread group of the main thread.\n-static void call_initPhase1(TRAPS) {\n-  Klass* klass = vmClasses::System_klass();\n-  JavaValue result(T_VOID);\n-  JavaCalls::call_static(&result, klass, vmSymbols::initPhase1_name(),\n-                                         vmSymbols::void_method_signature(), CHECK);\n-}\n-\n-\/\/ Phase 2. Module system initialization\n-\/\/     This will initialize the module system.  Only java.base classes\n-\/\/     can be loaded until phase 2 completes.\n-\/\/\n-\/\/     Call System.initPhase2 after the compiler initialization and jsr292\n-\/\/     classes get initialized because module initialization runs a lot of java\n-\/\/     code, that for performance reasons, should be compiled.  Also, this will\n-\/\/     enable the startup code to use lambda and other language features in this\n-\/\/     phase and onward.\n-\/\/\n-\/\/     After phase 2, The VM will begin search classes from -Xbootclasspath\/a.\n-static void call_initPhase2(TRAPS) {\n-  TraceTime timer(\"Initialize module system\", TRACETIME_LOG(Info, startuptime));\n-\n-  Klass* klass = vmClasses::System_klass();\n-\n-  JavaValue result(T_INT);\n-  JavaCallArguments args;\n-  args.push_int(DisplayVMOutputToStderr);\n-  args.push_int(log_is_enabled(Debug, init)); \/\/ print stack trace if exception thrown\n-  JavaCalls::call_static(&result, klass, vmSymbols::initPhase2_name(),\n-                                         vmSymbols::boolean_boolean_int_signature(), &args, CHECK);\n-  if (result.get_jint() != JNI_OK) {\n-    vm_exit_during_initialization(); \/\/ no message or exception\n-  }\n-\n-  universe_post_module_init();\n-}\n-\n-\/\/ Phase 3. final setup - set security manager, system class loader and TCCL\n-\/\/\n-\/\/     This will instantiate and set the security manager, set the system class\n-\/\/     loader as well as the thread context class loader.  The security manager\n-\/\/     and system class loader may be a custom class loaded from -Xbootclasspath\/a,\n-\/\/     other modules or the application's classpath.\n-static void call_initPhase3(TRAPS) {\n-  Klass* klass = vmClasses::System_klass();\n-  JavaValue result(T_VOID);\n-  JavaCalls::call_static(&result, klass, vmSymbols::initPhase3_name(),\n-                                         vmSymbols::void_method_signature(), CHECK);\n-}\n-\n-void Threads::initialize_java_lang_classes(JavaThread* main_thread, TRAPS) {\n-  TraceTime timer(\"Initialize java.lang classes\", TRACETIME_LOG(Info, startuptime));\n-\n-  if (EagerXrunInit && Arguments::init_libraries_at_startup()) {\n-    create_vm_init_libraries();\n-  }\n-\n-  initialize_class(vmSymbols::java_lang_String(), CHECK);\n-\n-  \/\/ Inject CompactStrings value after the static initializers for String ran.\n-  java_lang_String::set_compact_strings(CompactStrings);\n-\n-  \/\/ Initialize java_lang.System (needed before creating the thread)\n-  initialize_class(vmSymbols::java_lang_System(), CHECK);\n-  \/\/ The VM creates & returns objects of this class. Make sure it's initialized.\n-  initialize_class(vmSymbols::java_lang_Class(), CHECK);\n-  initialize_class(vmSymbols::java_lang_ThreadGroup(), CHECK);\n-  Handle thread_group = create_initial_thread_group(CHECK);\n-  Universe::set_main_thread_group(thread_group());\n-  initialize_class(vmSymbols::java_lang_Thread(), CHECK);\n-  create_initial_thread(thread_group, main_thread, CHECK);\n-\n-  \/\/ The VM creates objects of this class.\n-  initialize_class(vmSymbols::java_lang_Module(), CHECK);\n-\n-#ifdef ASSERT\n-  InstanceKlass *k = vmClasses::UnsafeConstants_klass();\n-  assert(k->is_not_initialized(), \"UnsafeConstants should not already be initialized\");\n-#endif\n-\n-  \/\/ initialize the hardware-specific constants needed by Unsafe\n-  initialize_class(vmSymbols::jdk_internal_misc_UnsafeConstants(), CHECK);\n-  jdk_internal_misc_UnsafeConstants::set_unsafe_constants();\n-\n-  \/\/ The VM preresolves methods to these classes. Make sure that they get initialized\n-  initialize_class(vmSymbols::java_lang_reflect_Method(), CHECK);\n-  initialize_class(vmSymbols::java_lang_ref_Finalizer(), CHECK);\n-\n-  \/\/ Phase 1 of the system initialization in the library, java.lang.System class initialization\n-  call_initPhase1(CHECK);\n-\n-  \/\/ Get the Java runtime name, version, and vendor info after java.lang.System is initialized.\n-  \/\/ Some values are actually configure-time constants but some can be set via the jlink tool and\n-  \/\/ so must be read dynamically. We treat them all the same.\n-  InstanceKlass* ik = SystemDictionary::find_instance_klass(vmSymbols::java_lang_VersionProps(),\n-                                                            Handle(), Handle());\n-  {\n-    ResourceMark rm(main_thread);\n-    JDK_Version::set_java_version(get_java_version_info(ik, vmSymbols::java_version_name()));\n-\n-    JDK_Version::set_runtime_name(get_java_version_info(ik, vmSymbols::java_runtime_name_name()));\n-\n-    JDK_Version::set_runtime_version(get_java_version_info(ik, vmSymbols::java_runtime_version_name()));\n-\n-    JDK_Version::set_runtime_vendor_version(get_java_version_info(ik, vmSymbols::java_runtime_vendor_version_name()));\n-\n-    JDK_Version::set_runtime_vendor_vm_bug_url(get_java_version_info(ik, vmSymbols::java_runtime_vendor_vm_bug_url_name()));\n-  }\n-\n-  \/\/ an instance of OutOfMemory exception has been allocated earlier\n-  initialize_class(vmSymbols::java_lang_OutOfMemoryError(), CHECK);\n-  initialize_class(vmSymbols::java_lang_NullPointerException(), CHECK);\n-  initialize_class(vmSymbols::java_lang_ClassCastException(), CHECK);\n-  initialize_class(vmSymbols::java_lang_ArrayStoreException(), CHECK);\n-  initialize_class(vmSymbols::java_lang_ArithmeticException(), CHECK);\n-  initialize_class(vmSymbols::java_lang_StackOverflowError(), CHECK);\n-  initialize_class(vmSymbols::java_lang_IllegalMonitorStateException(), CHECK);\n-  initialize_class(vmSymbols::java_lang_IllegalArgumentException(), CHECK);\n-}\n-\n-void Threads::initialize_jsr292_core_classes(TRAPS) {\n-  TraceTime timer(\"Initialize java.lang.invoke classes\", TRACETIME_LOG(Info, startuptime));\n-\n-  initialize_class(vmSymbols::java_lang_invoke_MethodHandle(), CHECK);\n-  initialize_class(vmSymbols::java_lang_invoke_ResolvedMethodName(), CHECK);\n-  initialize_class(vmSymbols::java_lang_invoke_MemberName(), CHECK);\n-  initialize_class(vmSymbols::java_lang_invoke_MethodHandleNatives(), CHECK);\n-}\n-\n-jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {\n-  extern void JDK_Version_init();\n-\n-  \/\/ Preinitialize version info.\n-  VM_Version::early_initialize();\n-\n-  \/\/ Check version\n-  if (!is_supported_jni_version(args->version)) return JNI_EVERSION;\n-\n-  \/\/ Initialize library-based TLS\n-  ThreadLocalStorage::init();\n-\n-  \/\/ Initialize the output stream module\n-  ostream_init();\n-\n-  \/\/ Process java launcher properties.\n-  Arguments::process_sun_java_launcher_properties(args);\n-\n-  \/\/ Initialize the os module\n-  os::init();\n-\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n-\n-  \/\/ Record VM creation timing statistics\n-  TraceVmCreationTime create_vm_timer;\n-  create_vm_timer.start();\n-\n-  \/\/ Initialize system properties.\n-  Arguments::init_system_properties();\n-\n-  \/\/ So that JDK version can be used as a discriminator when parsing arguments\n-  JDK_Version_init();\n-\n-  \/\/ Update\/Initialize System properties after JDK version number is known\n-  Arguments::init_version_specific_system_properties();\n-\n-  \/\/ Make sure to initialize log configuration *before* parsing arguments\n-  LogConfiguration::initialize(create_vm_timer.begin_time());\n-\n-  \/\/ Parse arguments\n-  \/\/ Note: this internally calls os::init_container_support()\n-  jint parse_result = Arguments::parse(args);\n-  if (parse_result != JNI_OK) return parse_result;\n-\n-  \/\/ Initialize NMT right after argument parsing to keep the pre-NMT-init window small.\n-  MemTracker::initialize();\n-\n-  os::init_before_ergo();\n-\n-  jint ergo_result = Arguments::apply_ergo();\n-  if (ergo_result != JNI_OK) return ergo_result;\n-\n-  \/\/ Final check of all ranges after ergonomics which may change values.\n-  if (!JVMFlagLimit::check_all_ranges()) {\n-    return JNI_EINVAL;\n-  }\n-\n-  \/\/ Final check of all 'AfterErgo' constraints after ergonomics which may change values.\n-  bool constraint_result = JVMFlagLimit::check_all_constraints(JVMFlagConstraintPhase::AfterErgo);\n-  if (!constraint_result) {\n-    return JNI_EINVAL;\n-  }\n-\n-  if (PauseAtStartup) {\n-    os::pause();\n-  }\n-\n-  HOTSPOT_VM_INIT_BEGIN();\n-\n-  \/\/ Timing (must come after argument parsing)\n-  TraceTime timer(\"Create VM\", TRACETIME_LOG(Info, startuptime));\n-\n-  \/\/ Initialize the os module after parsing the args\n-  jint os_init_2_result = os::init_2();\n-  if (os_init_2_result != JNI_OK) return os_init_2_result;\n-\n-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n-  \/\/ Initialize assert poison page mechanism.\n-  if (ShowRegistersOnAssert) {\n-    initialize_assert_poison();\n-  }\n-#endif \/\/ CAN_SHOW_REGISTERS_ON_ASSERT\n-\n-  SafepointMechanism::initialize();\n-\n-  jint adjust_after_os_result = Arguments::adjust_after_os();\n-  if (adjust_after_os_result != JNI_OK) return adjust_after_os_result;\n-\n-  \/\/ Initialize output stream logging\n-  ostream_init_log();\n-\n-  \/\/ Convert -Xrun to -agentlib: if there is no JVM_OnLoad\n-  \/\/ Must be before create_vm_init_agents()\n-  if (Arguments::init_libraries_at_startup()) {\n-    convert_vm_init_libraries_to_agents();\n-  }\n-\n-  \/\/ Launch -agentlib\/-agentpath and converted -Xrun agents\n-  if (Arguments::init_agents_at_startup()) {\n-    create_vm_init_agents();\n-  }\n-\n-  \/\/ Initialize Threads state\n-  _number_of_threads = 0;\n-  _number_of_non_daemon_threads = 0;\n-\n-  \/\/ Initialize global data structures and create system classes in heap\n-  vm_init_globals();\n-\n-#if INCLUDE_JVMCI\n-  if (JVMCICounterSize > 0) {\n-    JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtJVMCI);\n-    memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);\n-  } else {\n-    JavaThread::_jvmci_old_thread_counters = NULL;\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n-\n-  \/\/ Initialize OopStorage for threadObj\n-  _thread_oop_storage = OopStorageSet::create_strong(\"Thread OopStorage\", mtThread);\n-\n-  \/\/ Attach the main thread to this os thread\n-  JavaThread* main_thread = new JavaThread();\n-  main_thread->set_thread_state(_thread_in_vm);\n-  main_thread->initialize_thread_current();\n-  \/\/ must do this before set_active_handles\n-  main_thread->record_stack_base_and_size();\n-  main_thread->register_thread_stack_with_NMT();\n-  main_thread->set_active_handles(JNIHandleBlock::allocate_block());\n-  MACOS_AARCH64_ONLY(main_thread->init_wx());\n-\n-  if (!main_thread->set_as_starting_thread()) {\n-    vm_shutdown_during_initialization(\n-                                      \"Failed necessary internal allocation. Out of swap space\");\n-    main_thread->smr_delete();\n-    *canTryAgain = false; \/\/ don't let caller call JNI_CreateJavaVM again\n-    return JNI_ENOMEM;\n-  }\n-\n-  \/\/ Enable guard page *after* os::create_main_thread(), otherwise it would\n-  \/\/ crash Linux VM, see notes in os_linux.cpp.\n-  main_thread->stack_overflow_state()->create_stack_guard_pages();\n-\n-  \/\/ Initialize Java-Level synchronization subsystem\n-  ObjectMonitor::Initialize();\n-  ObjectSynchronizer::initialize();\n-\n-  \/\/ Initialize global modules\n-  jint status = init_globals();\n-  if (status != JNI_OK) {\n-    main_thread->smr_delete();\n-    *canTryAgain = false; \/\/ don't let caller call JNI_CreateJavaVM again\n-    return status;\n-  }\n-\n-  JFR_ONLY(Jfr::on_create_vm_1();)\n-\n-  \/\/ Should be done after the heap is fully created\n-  main_thread->cache_global_variables();\n-\n-  { MutexLocker mu(Threads_lock);\n-    Threads::add(main_thread);\n-  }\n-\n-  \/\/ Any JVMTI raw monitors entered in onload will transition into\n-  \/\/ real raw monitor. VM is setup enough here for raw monitor enter.\n-  JvmtiExport::transition_pending_onload_raw_monitors();\n-\n-  \/\/ Create the VMThread\n-  { TraceTime timer(\"Start VMThread\", TRACETIME_LOG(Info, startuptime));\n-\n-    VMThread::create();\n-    VMThread* vmthread = VMThread::vm_thread();\n-\n-    if (!os::create_thread(vmthread, os::vm_thread)) {\n-      vm_exit_during_initialization(\"Cannot create VM thread. \"\n-                                    \"Out of system resources.\");\n-    }\n-\n-    \/\/ Wait for the VM thread to become ready, and VMThread::run to initialize\n-    \/\/ Monitors can have spurious returns, must always check another state flag\n-    {\n-      MonitorLocker ml(Notify_lock);\n-      os::start_thread(vmthread);\n-      while (!vmthread->is_running()) {\n-        ml.wait();\n-      }\n-    }\n-  }\n-\n-  assert(Universe::is_fully_initialized(), \"not initialized\");\n-  if (VerifyDuringStartup) {\n-    \/\/ Make sure we're starting with a clean slate.\n-    VM_Verify verify_op;\n-    VMThread::execute(&verify_op);\n-  }\n-\n-  \/\/ We need this to update the java.vm.info property in case any flags used\n-  \/\/ to initially define it have been changed. This is needed for both CDS\n-  \/\/ since UseSharedSpaces may be changed after java.vm.info\n-  \/\/ is initially computed. See Abstract_VM_Version::vm_info_string().\n-  \/\/ This update must happen before we initialize the java classes, but\n-  \/\/ after any initialization logic that might modify the flags.\n-  Arguments::update_vm_info_property(VM_Version::vm_info_string());\n-\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-  HandleMark hm(THREAD);\n-\n-  \/\/ Always call even when there are not JVMTI environments yet, since environments\n-  \/\/ may be attached late and JVMTI must track phases of VM execution\n-  JvmtiExport::enter_early_start_phase();\n-\n-  \/\/ Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.\n-  JvmtiExport::post_early_vm_start();\n-\n-  initialize_java_lang_classes(main_thread, CHECK_JNI_ERR);\n-\n-  quicken_jni_functions();\n-\n-  \/\/ No more stub generation allowed after that point.\n-  StubCodeDesc::freeze();\n-\n-  \/\/ Set flag that basic initialization has completed. Used by exceptions and various\n-  \/\/ debug stuff, that does not work until all basic classes have been initialized.\n-  set_init_completed();\n-\n-  LogConfiguration::post_initialize();\n-  Metaspace::post_initialize();\n-\n-  HOTSPOT_VM_INIT_END();\n-\n-  \/\/ record VM initialization completion time\n-#if INCLUDE_MANAGEMENT\n-  Management::record_vm_init_completed();\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n-  \/\/ Signal Dispatcher needs to be started before VMInit event is posted\n-  os::initialize_jdk_signal_support(CHECK_JNI_ERR);\n-\n-  \/\/ Start Attach Listener if +StartAttachListener or it can't be started lazily\n-  if (!DisableAttachMechanism) {\n-    AttachListener::vm_start();\n-    if (StartAttachListener || AttachListener::init_at_startup()) {\n-      AttachListener::init();\n-    }\n-  }\n-\n-  \/\/ Launch -Xrun agents\n-  \/\/ Must be done in the JVMTI live phase so that for backward compatibility the JDWP\n-  \/\/ back-end can launch with -Xdebug -Xrunjdwp.\n-  if (!EagerXrunInit && Arguments::init_libraries_at_startup()) {\n-    create_vm_init_libraries();\n-  }\n-\n-  Chunk::start_chunk_pool_cleaner_task();\n-\n-  \/\/ Start the service thread\n-  \/\/ The service thread enqueues JVMTI deferred events and does various hashtable\n-  \/\/ and other cleanups.  Needs to start before the compilers start posting events.\n-  ServiceThread::initialize();\n-\n-  \/\/ Start the monitor deflation thread:\n-  MonitorDeflationThread::initialize();\n-\n-  \/\/ initialize compiler(s)\n-#if defined(COMPILER1) || COMPILER2_OR_JVMCI\n-#if INCLUDE_JVMCI\n-  bool force_JVMCI_intialization = false;\n-  if (EnableJVMCI) {\n-    \/\/ Initialize JVMCI eagerly when it is explicitly requested.\n-    \/\/ Or when JVMCILibDumpJNIConfig or JVMCIPrintProperties is enabled.\n-    force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;\n-\n-    if (!force_JVMCI_intialization) {\n-      \/\/ 8145270: Force initialization of JVMCI runtime otherwise requests for blocking\n-      \/\/ compilations via JVMCI will not actually block until JVMCI is initialized.\n-      force_JVMCI_intialization = UseJVMCICompiler && (!UseInterpreter || !BackgroundCompilation);\n-    }\n-  }\n-#endif\n-  CompileBroker::compilation_init_phase1(CHECK_JNI_ERR);\n-  \/\/ Postpone completion of compiler initialization to after JVMCI\n-  \/\/ is initialized to avoid timeouts of blocking compilations.\n-  if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) {\n-    CompileBroker::compilation_init_phase2();\n-  }\n-#endif\n-\n-  \/\/ Pre-initialize some JSR292 core classes to avoid deadlock during class loading.\n-  \/\/ It is done after compilers are initialized, because otherwise compilations of\n-  \/\/ signature polymorphic MH intrinsics can be missed\n-  \/\/ (see SystemDictionary::find_method_handle_intrinsic).\n-  initialize_jsr292_core_classes(CHECK_JNI_ERR);\n-\n-  \/\/ This will initialize the module system.  Only java.base classes can be\n-  \/\/ loaded until phase 2 completes\n-  call_initPhase2(CHECK_JNI_ERR);\n-\n-  JFR_ONLY(Jfr::on_create_vm_2();)\n-\n-  \/\/ Always call even when there are not JVMTI environments yet, since environments\n-  \/\/ may be attached late and JVMTI must track phases of VM execution\n-  JvmtiExport::enter_start_phase();\n-\n-  \/\/ Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.\n-  JvmtiExport::post_vm_start();\n-\n-  \/\/ Final system initialization including security manager and system class loader\n-  call_initPhase3(CHECK_JNI_ERR);\n-\n-  \/\/ cache the system and platform class loaders\n-  SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);\n-\n-#if INCLUDE_CDS\n-  \/\/ capture the module path info from the ModuleEntryTable\n-  ClassLoader::initialize_module_path(THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n-    vm_exit_during_initialization(\"ClassLoader::initialize_module_path() failed unexpectedly\");\n-  }\n-#endif\n-\n-#if INCLUDE_JVMCI\n-  if (force_JVMCI_intialization) {\n-    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n-    CompileBroker::compilation_init_phase2();\n-  }\n-#endif\n-\n-  \/\/ Always call even when there are not JVMTI environments yet, since environments\n-  \/\/ may be attached late and JVMTI must track phases of VM execution\n-  JvmtiExport::enter_live_phase();\n-\n-  \/\/ Make perfmemory accessible\n-  PerfMemory::set_accessible(true);\n-\n-  \/\/ Notify JVMTI agents that VM initialization is complete - nop if no agents.\n-  JvmtiExport::post_vm_initialized();\n-\n-  JFR_ONLY(Jfr::on_create_vm_3();)\n-\n-#if INCLUDE_MANAGEMENT\n-  Management::initialize(THREAD);\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ management agent fails to start possibly due to\n-    \/\/ configuration problem and is responsible for printing\n-    \/\/ stack trace if appropriate. Simply exit VM.\n-    vm_exit(1);\n-  }\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n-  StatSampler::engage();\n-  if (CheckJNICalls)                  JniPeriodicChecker::engage();\n-\n-#if INCLUDE_RTM_OPT\n-  RTMLockingCounters::init();\n-#endif\n-\n-  call_postVMInitHook(THREAD);\n-  \/\/ The Java side of PostVMInitHook.run must deal with all\n-  \/\/ exceptions and provide means of diagnosis.\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-\n-  {\n-    MutexLocker ml(PeriodicTask_lock);\n-    \/\/ Make sure the WatcherThread can be started by WatcherThread::start()\n-    \/\/ or by dynamic enrollment.\n-    WatcherThread::make_startable();\n-    \/\/ Start up the WatcherThread if there are any periodic tasks\n-    \/\/ NOTE:  All PeriodicTasks should be registered by now. If they\n-    \/\/   aren't, late joiners might appear to start slowly (we might\n-    \/\/   take a while to process their first tick).\n-    if (PeriodicTask::num_tasks() > 0) {\n-      WatcherThread::start();\n-    }\n-  }\n-\n-  create_vm_timer.end();\n-#ifdef ASSERT\n-  _vm_complete = true;\n-#endif\n-\n-  if (DumpSharedSpaces) {\n-    MetaspaceShared::preload_and_dump();\n-    ShouldNotReachHere();\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-\/\/ type for the Agent_OnLoad and JVM_OnLoad entry points\n-extern \"C\" {\n-  typedef jint (JNICALL *OnLoadEntry_t)(JavaVM *, char *, void *);\n-}\n-\/\/ Find a command line agent library and return its entry point for\n-\/\/         -agentlib:  -agentpath:   -Xrun\n-\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n-static OnLoadEntry_t lookup_on_load(AgentLibrary* agent,\n-                                    const char *on_load_symbols[],\n-                                    size_t num_symbol_entries) {\n-  OnLoadEntry_t on_load_entry = NULL;\n-  void *library = NULL;\n-\n-  if (!agent->valid()) {\n-    char buffer[JVM_MAXPATHLEN];\n-    char ebuf[1024] = \"\";\n-    const char *name = agent->name();\n-    const char *msg = \"Could not find agent library \";\n-\n-    \/\/ First check to see if agent is statically linked into executable\n-    if (os::find_builtin_agent(agent, on_load_symbols, num_symbol_entries)) {\n-      library = agent->os_lib();\n-    } else if (agent->is_absolute_path()) {\n-      library = os::dll_load(name, ebuf, sizeof ebuf);\n-      if (library == NULL) {\n-        const char *sub_msg = \" in absolute path, with error: \";\n-        size_t len = strlen(msg) + strlen(name) + strlen(sub_msg) + strlen(ebuf) + 1;\n-        char *buf = NEW_C_HEAP_ARRAY(char, len, mtThread);\n-        jio_snprintf(buf, len, \"%s%s%s%s\", msg, name, sub_msg, ebuf);\n-        \/\/ If we can't find the agent, exit.\n-        vm_exit_during_initialization(buf, NULL);\n-        FREE_C_HEAP_ARRAY(char, buf);\n-      }\n-    } else {\n-      \/\/ Try to load the agent from the standard dll directory\n-      if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),\n-                             name)) {\n-        library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-      }\n-      if (library == NULL) { \/\/ Try the library path directory.\n-        if (os::dll_build_name(buffer, sizeof(buffer), name)) {\n-          library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-        }\n-        if (library == NULL) {\n-          const char *sub_msg = \" on the library path, with error: \";\n-          const char *sub_msg2 = \"\\nModule java.instrument may be missing from runtime image.\";\n-\n-          size_t len = strlen(msg) + strlen(name) + strlen(sub_msg) +\n-                       strlen(ebuf) + strlen(sub_msg2) + 1;\n-          char *buf = NEW_C_HEAP_ARRAY(char, len, mtThread);\n-          if (!agent->is_instrument_lib()) {\n-            jio_snprintf(buf, len, \"%s%s%s%s\", msg, name, sub_msg, ebuf);\n-          } else {\n-            jio_snprintf(buf, len, \"%s%s%s%s%s\", msg, name, sub_msg, ebuf, sub_msg2);\n-          }\n-          \/\/ If we can't find the agent, exit.\n-          vm_exit_during_initialization(buf, NULL);\n-          FREE_C_HEAP_ARRAY(char, buf);\n-        }\n-      }\n-    }\n-    agent->set_os_lib(library);\n-    agent->set_valid();\n-  }\n-\n-  \/\/ Find the OnLoad function.\n-  on_load_entry =\n-    CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent,\n-                                                          false,\n-                                                          on_load_symbols,\n-                                                          num_symbol_entries));\n-  return on_load_entry;\n-}\n-\n-\/\/ Find the JVM_OnLoad entry point\n-static OnLoadEntry_t lookup_jvm_on_load(AgentLibrary* agent) {\n-  const char *on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n-  return lookup_on_load(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-\/\/ Find the Agent_OnLoad entry point\n-static OnLoadEntry_t lookup_agent_on_load(AgentLibrary* agent) {\n-  const char *on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n-  return lookup_on_load(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-\/\/ For backwards compatibility with -Xrun\n-\/\/ Convert libraries with no JVM_OnLoad, but which have Agent_OnLoad to be\n-\/\/ treated like -agentpath:\n-\/\/ Must be called before agent libraries are created\n-void Threads::convert_vm_init_libraries_to_agents() {\n-  AgentLibrary* agent;\n-  AgentLibrary* next;\n-\n-  for (agent = Arguments::libraries(); agent != NULL; agent = next) {\n-    next = agent->next();  \/\/ cache the next agent now as this agent may get moved off this list\n-    OnLoadEntry_t on_load_entry = lookup_jvm_on_load(agent);\n-\n-    \/\/ If there is an JVM_OnLoad function it will get called later,\n-    \/\/ otherwise see if there is an Agent_OnLoad\n-    if (on_load_entry == NULL) {\n-      on_load_entry = lookup_agent_on_load(agent);\n-      if (on_load_entry != NULL) {\n-        \/\/ switch it to the agent list -- so that Agent_OnLoad will be called,\n-        \/\/ JVM_OnLoad won't be attempted and Agent_OnUnload will\n-        Arguments::convert_library_to_agent(agent);\n-      } else {\n-        vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", agent->name());\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Create agents for -agentlib:  -agentpath:  and converted -Xrun\n-\/\/ Invokes Agent_OnLoad\n-\/\/ Called very early -- before JavaThreads exist\n-void Threads::create_vm_init_agents() {\n-  extern struct JavaVM_ main_vm;\n-  AgentLibrary* agent;\n-\n-  JvmtiExport::enter_onload_phase();\n-\n-  for (agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n-    \/\/ CDS dumping does not support native JVMTI agent.\n-    \/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n-    if (Arguments::is_dumping_archive()) {\n-      if(!agent->is_instrument_lib()) {\n-        vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n-      } else if (!AllowArchivingWithJavaAgent) {\n-        vm_exit_during_cds_dumping(\n-          \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n-      }\n-    }\n-\n-    OnLoadEntry_t  on_load_entry = lookup_agent_on_load(agent);\n-\n-    if (on_load_entry != NULL) {\n-      \/\/ Invoke the Agent_OnLoad function\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n-      if (err != JNI_OK) {\n-        vm_exit_during_initialization(\"agent library failed to init\", agent->name());\n-      }\n-    } else {\n-      vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n-    }\n-  }\n-\n-  JvmtiExport::enter_primordial_phase();\n-}\n-\n-extern \"C\" {\n-  typedef void (JNICALL *Agent_OnUnload_t)(JavaVM *);\n-}\n-\n-void Threads::shutdown_vm_agents() {\n-  \/\/ Send any Agent_OnUnload notifications\n-  const char *on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n-  size_t num_symbol_entries = ARRAY_SIZE(on_unload_symbols);\n-  extern struct JavaVM_ main_vm;\n-  for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n-\n-    \/\/ Find the Agent_OnUnload function.\n-    Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n-                                                   os::find_agent_function(agent,\n-                                                   false,\n-                                                   on_unload_symbols,\n-                                                   num_symbol_entries));\n-\n-    \/\/ Invoke the Agent_OnUnload function\n-    if (unload_entry != NULL) {\n-      JavaThread* thread = JavaThread::current();\n-      ThreadToNativeFromVM ttn(thread);\n-      HandleMark hm(thread);\n-      (*unload_entry)(&main_vm);\n-    }\n-  }\n-}\n-\n-\/\/ Called for after the VM is initialized for -Xrun libraries which have not been converted to agent libraries\n-\/\/ Invokes JVM_OnLoad\n-void Threads::create_vm_init_libraries() {\n-  extern struct JavaVM_ main_vm;\n-  AgentLibrary* agent;\n-\n-  for (agent = Arguments::libraries(); agent != NULL; agent = agent->next()) {\n-    OnLoadEntry_t on_load_entry = lookup_jvm_on_load(agent);\n-\n-    if (on_load_entry != NULL) {\n-      \/\/ Invoke the JVM_OnLoad function\n-      JavaThread* thread = JavaThread::current();\n-      ThreadToNativeFromVM ttn(thread);\n-      HandleMark hm(thread);\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n-      if (err != JNI_OK) {\n-        vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n-      }\n-    } else {\n-      vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n-    }\n-  }\n-}\n-\n-\n-\/\/ Last thread running calls java.lang.Shutdown.shutdown()\n-void JavaThread::invoke_shutdown_hooks() {\n-  HandleMark hm(this);\n-\n-  \/\/ We could get here with a pending exception, if so clear it now or\n-  \/\/ it will cause MetaspaceShared::link_shared_classes to\n-  \/\/ fail for dynamic dump.\n-  if (this->has_pending_exception()) {\n-    this->clear_pending_exception();\n-  }\n-\n-#if INCLUDE_CDS\n-  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n-  \/\/ Same operation is being done in JVM_BeforeHalt for handling the\n-  \/\/ case where the application calls System.exit().\n-  if (DynamicArchive::should_dump_at_vm_exit()) {\n-    DynamicArchive::prepare_for_dump_at_exit();\n-  }\n-#endif\n-\n-  EXCEPTION_MARK;\n-  Klass* shutdown_klass =\n-    SystemDictionary::resolve_or_null(vmSymbols::java_lang_Shutdown(),\n-                                      THREAD);\n-  if (shutdown_klass != NULL) {\n-    \/\/ SystemDictionary::resolve_or_null will return null if there was\n-    \/\/ an exception.  If we cannot load the Shutdown class, just don't\n-    \/\/ call Shutdown.shutdown() at all.  This will mean the shutdown hooks\n-    \/\/ won't be run.  Note that if a shutdown hook was registered,\n-    \/\/ the Shutdown class would have already been loaded\n-    \/\/ (Runtime.addShutdownHook will load it).\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_static(&result,\n-                           shutdown_klass,\n-                           vmSymbols::shutdown_name(),\n-                           vmSymbols::void_method_signature(),\n-                           THREAD);\n-  }\n-  CLEAR_PENDING_EXCEPTION;\n-}\n-\n-\/\/ Threads::destroy_vm() is normally called from jni_DestroyJavaVM() when\n-\/\/ the program falls off the end of main(). Another VM exit path is through\n-\/\/ vm_exit() when the program calls System.exit() to return a value or when\n-\/\/ there is a serious error in VM. The two shutdown paths are not exactly\n-\/\/ the same, but they share Shutdown.shutdown() at Java level and before_exit()\n-\/\/ and VM_Exit op at VM level.\n-\/\/\n-\/\/ Shutdown sequence:\n-\/\/   + Shutdown native memory tracking if it is on\n-\/\/   + Wait until we are the last non-daemon thread to execute\n-\/\/     <-- every thing is still working at this moment -->\n-\/\/   + Call java.lang.Shutdown.shutdown(), which will invoke Java level\n-\/\/        shutdown hooks\n-\/\/   + Call before_exit(), prepare for VM exit\n-\/\/      > run VM level shutdown hooks (they are registered through JVM_OnExit(),\n-\/\/        currently the only user of this mechanism is File.deleteOnExit())\n-\/\/      > stop StatSampler, watcher thread,\n-\/\/        post thread end and vm death events to JVMTI,\n-\/\/        stop signal thread\n-\/\/   + Call JavaThread::exit(), it will:\n-\/\/      > release JNI handle blocks, remove stack guard pages\n-\/\/      > remove this thread from Threads list\n-\/\/     <-- no more Java code from this thread after this point -->\n-\/\/   + Stop VM thread, it will bring the remaining VM to a safepoint and stop\n-\/\/     the compiler threads at safepoint\n-\/\/     <-- do not use anything that could get blocked by Safepoint -->\n-\/\/   + Disable tracing at JNI\/JVM barriers\n-\/\/   + Set _vm_exited flag for threads that are still running native code\n-\/\/   + Call exit_globals()\n-\/\/      > deletes tty\n-\/\/      > deletes PerfMemory resources\n-\/\/   + Delete this thread\n-\/\/   + Return to caller\n-\n-void Threads::destroy_vm() {\n-  JavaThread* thread = JavaThread::current();\n-\n-#ifdef ASSERT\n-  _vm_complete = false;\n-#endif\n-  \/\/ Wait until we are the last non-daemon thread to execute\n-  {\n-    MonitorLocker nu(Threads_lock);\n-    while (Threads::number_of_non_daemon_threads() > 1)\n-      \/\/ This wait should make safepoint checks, wait without a timeout.\n-      nu.wait(0);\n-  }\n-\n-  EventShutdown e;\n-  if (e.should_commit()) {\n-    e.set_reason(\"No remaining non-daemon Java threads\");\n-    e.commit();\n-  }\n-\n-  \/\/ Hang forever on exit if we are reporting an error.\n-  if (ShowMessageBoxOnError && VMError::is_error_reported()) {\n-    os::infinite_sleep();\n-  }\n-  os::wait_for_keypress_at_exit();\n-\n-  \/\/ run Java level shutdown hooks\n-  thread->invoke_shutdown_hooks();\n-\n-  before_exit(thread);\n-\n-  thread->exit(true);\n-\n-  \/\/ We are no longer on the main thread list but could still be in a\n-  \/\/ secondary list where another thread may try to interact with us.\n-  \/\/ So wait until all such interactions are complete before we bring\n-  \/\/ the VM to the termination safepoint. Normally this would be done\n-  \/\/ using thread->smr_delete() below where we delete the thread, but\n-  \/\/ we can't call that after the termination safepoint is active as\n-  \/\/ we will deadlock on the Threads_lock. Once all interactions are\n-  \/\/ complete it is safe to directly delete the thread at any time.\n-  ThreadsSMRSupport::wait_until_not_protected(thread);\n-\n-  \/\/ Stop VM thread.\n-  {\n-    \/\/ 4945125 The vm thread comes to a safepoint during exit.\n-    \/\/ GC vm_operations can get caught at the safepoint, and the\n-    \/\/ heap is unparseable if they are caught. Grab the Heap_lock\n-    \/\/ to prevent this. The GC vm_operations will not be able to\n-    \/\/ queue until after the vm thread is dead. After this point,\n-    \/\/ we'll never emerge out of the safepoint before the VM exits.\n-    \/\/ Assert that the thread is terminated so that acquiring the\n-    \/\/ Heap_lock doesn't cause the terminated thread to participate in\n-    \/\/ the safepoint protocol.\n-\n-    assert(thread->is_terminated(), \"must be terminated here\");\n-    MutexLocker ml(Heap_lock);\n-\n-    VMThread::wait_for_vm_thread_exit();\n-    assert(SafepointSynchronize::is_at_safepoint(), \"VM thread should exit at Safepoint\");\n-    VMThread::destroy();\n-  }\n-\n-  \/\/ Now, all Java threads are gone except daemon threads. Daemon threads\n-  \/\/ running Java code or in VM are stopped by the Safepoint. However,\n-  \/\/ daemon threads executing native code are still running.  But they\n-  \/\/ will be stopped at native=>Java\/VM barriers. Note that we can't\n-  \/\/ simply kill or suspend them, as it is inherently deadlock-prone.\n-\n-  VM_Exit::set_vm_exited();\n-\n-  \/\/ Clean up ideal graph printers after the VMThread has started\n-  \/\/ the final safepoint which will block all the Compiler threads.\n-  \/\/ Note that this Thread has already logically exited so the\n-  \/\/ clean_up() function's use of a JavaThreadIteratorWithHandle\n-  \/\/ would be a problem except set_vm_exited() has remembered the\n-  \/\/ shutdown thread which is granted a policy exception.\n-#if defined(COMPILER2) && !defined(PRODUCT)\n-  IdealGraphPrinter::clean_up();\n-#endif\n-\n-  notify_vm_shutdown();\n-\n-  \/\/ exit_globals() will delete tty\n-  exit_globals();\n-\n-  \/\/ Deleting the shutdown thread here is safe. See comment on\n-  \/\/ wait_until_not_protected() above.\n-  delete thread;\n-\n-#if INCLUDE_JVMCI\n-  if (JVMCICounterSize > 0) {\n-    FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);\n-  }\n-#endif\n-\n-  LogConfiguration::finalize();\n-}\n-\n-\n-jboolean Threads::is_supported_jni_version_including_1_1(jint version) {\n-  if (version == JNI_VERSION_1_1) return JNI_TRUE;\n-  return is_supported_jni_version(version);\n-}\n-\n-\n-jboolean Threads::is_supported_jni_version(jint version) {\n-  if (version == JNI_VERSION_1_2) return JNI_TRUE;\n-  if (version == JNI_VERSION_1_4) return JNI_TRUE;\n-  if (version == JNI_VERSION_1_6) return JNI_TRUE;\n-  if (version == JNI_VERSION_1_8) return JNI_TRUE;\n-  if (version == JNI_VERSION_9) return JNI_TRUE;\n-  if (version == JNI_VERSION_10) return JNI_TRUE;\n-  if (version == JNI_VERSION_19) return JNI_TRUE;\n-  return JNI_FALSE;\n-}\n-\n-\n-void Threads::add(JavaThread* p, bool force_daemon) {\n-  \/\/ The threads lock must be owned at this point\n-  assert(Threads_lock->owned_by_self(), \"must have threads lock\");\n-\n-  BarrierSet::barrier_set()->on_thread_attach(p);\n-\n-  \/\/ Once a JavaThread is added to the Threads list, smr_delete() has\n-  \/\/ to be used to delete it. Otherwise we can just delete it directly.\n-  p->set_on_thread_list();\n-\n-  _number_of_threads++;\n-  oop threadObj = p->threadObj();\n-  bool daemon = true;\n-  \/\/ Bootstrapping problem: threadObj can be null for initial\n-  \/\/ JavaThread (or for threads attached via JNI)\n-  if ((!force_daemon) && !is_daemon((threadObj))) {\n-    _number_of_non_daemon_threads++;\n-    daemon = false;\n-  }\n-\n-  ThreadService::add_thread(p, daemon);\n-\n-  \/\/ Maintain fast thread list\n-  ThreadsSMRSupport::add_thread(p);\n-\n-  \/\/ Increase the ObjectMonitor ceiling for the new thread.\n-  ObjectSynchronizer::inc_in_use_list_ceiling();\n-\n-  \/\/ Possible GC point.\n-  Events::log(p, \"Thread added: \" INTPTR_FORMAT, p2i(p));\n-\n-  \/\/ Make new thread known to active EscapeBarrier\n-  EscapeBarrier::thread_added(p);\n-}\n-\n-void Threads::remove(JavaThread* p, bool is_daemon) {\n-  \/\/ Extra scope needed for Thread_lock, so we can check\n-  \/\/ that we do not remove thread without safepoint code notice\n-  { MonitorLocker ml(Threads_lock);\n-\n-    \/\/ BarrierSet state must be destroyed after the last thread transition\n-    \/\/ before the thread terminates. Thread transitions result in calls to\n-    \/\/ StackWatermarkSet::on_safepoint(), which performs GC processing,\n-    \/\/ requiring the GC state to be alive.\n-    BarrierSet::barrier_set()->on_thread_detach(p);\n-\n-    assert(ThreadsSMRSupport::get_java_thread_list()->includes(p), \"p must be present\");\n-\n-    \/\/ Maintain fast thread list\n-    ThreadsSMRSupport::remove_thread(p);\n-\n-    _number_of_threads--;\n-    if (!is_daemon) {\n-      _number_of_non_daemon_threads--;\n-\n-      \/\/ Only one thread left, do a notify on the Threads_lock so a thread waiting\n-      \/\/ on destroy_vm will wake up.\n-      if (number_of_non_daemon_threads() == 1) {\n-        ml.notify_all();\n-      }\n-    }\n-    ThreadService::remove_thread(p, is_daemon);\n-\n-    \/\/ Make sure that safepoint code disregard this thread. This is needed since\n-    \/\/ the thread might mess around with locks after this point. This can cause it\n-    \/\/ to do callbacks into the safepoint code. However, the safepoint code is not aware\n-    \/\/ of this thread since it is removed from the queue.\n-    p->set_terminated(JavaThread::_thread_terminated);\n-\n-    \/\/ Notify threads waiting in EscapeBarriers\n-    EscapeBarrier::thread_removed(p);\n-  } \/\/ unlock Threads_lock\n-\n-  \/\/ Reduce the ObjectMonitor ceiling for the exiting thread.\n-  ObjectSynchronizer::dec_in_use_list_ceiling();\n-\n-  \/\/ Since Events::log uses a lock, we grab it outside the Threads_lock\n-  Events::log(p, \"Thread exited: \" INTPTR_FORMAT, p2i(p));\n-}\n-\n-\/\/ Operations on the Threads list for GC.  These are not explicitly locked,\n-\/\/ but the garbage collector must provide a safe context for them to run.\n-\/\/ In particular, these things should never be called when the Threads_lock\n-\/\/ is held by some other thread. (Note: the Safepoint abstraction also\n-\/\/ uses the Threads_lock to guarantee this property. It also makes sure that\n-\/\/ all threads gets blocked when exiting or starting).\n-\n-void Threads::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n-  ALL_JAVA_THREADS(p) {\n-    p->oops_do(f, cf);\n-  }\n-  VMThread::vm_thread()->oops_do(f, cf);\n-}\n-\n-void Threads::change_thread_claim_token() {\n-  if (++_thread_claim_token == 0) {\n-    \/\/ On overflow of the token counter, there is a risk of future\n-    \/\/ collisions between a new global token value and a stale token\n-    \/\/ for a thread, because not all iterations visit all threads.\n-    \/\/ (Though it's pretty much a theoretical concern for non-trivial\n-    \/\/ token counter sizes.)  To deal with the possibility, reset all\n-    \/\/ the thread tokens to zero on global token overflow.\n-    struct ResetClaims : public ThreadClosure {\n-      virtual void do_thread(Thread* t) {\n-        t->claim_threads_do(false, 0);\n-      }\n-    } reset_claims;\n-    Threads::threads_do(&reset_claims);\n-    \/\/ On overflow, update the global token to non-zero, to\n-    \/\/ avoid the special \"never claimed\" initial thread value.\n-    _thread_claim_token = 1;\n-  }\n-}\n-\n-#ifdef ASSERT\n-void assert_thread_claimed(const char* kind, Thread* t, uintx expected) {\n-  const uintx token = t->threads_do_token();\n-  assert(token == expected,\n-         \"%s \" PTR_FORMAT \" has incorrect value \" UINTX_FORMAT \" != \"\n-         UINTX_FORMAT, kind, p2i(t), token, expected);\n-}\n-\n-void Threads::assert_all_threads_claimed() {\n-  ALL_JAVA_THREADS(p) {\n-    assert_thread_claimed(\"Thread\", p, _thread_claim_token);\n-  }\n-  assert_thread_claimed(\"VMThread\", VMThread::vm_thread(), _thread_claim_token);\n-}\n-#endif \/\/ ASSERT\n-\n-class ParallelOopsDoThreadClosure : public ThreadClosure {\n-private:\n-  OopClosure* _f;\n-  CodeBlobClosure* _cf;\n-public:\n-  ParallelOopsDoThreadClosure(OopClosure* f, CodeBlobClosure* cf) : _f(f), _cf(cf) {}\n-  void do_thread(Thread* t) {\n-    t->oops_do(_f, _cf);\n-  }\n-};\n-\n-void Threads::possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf) {\n-  ParallelOopsDoThreadClosure tc(f, cf);\n-  possibly_parallel_threads_do(is_par, &tc);\n-}\n-\n-void Threads::metadata_do(MetadataClosure* f) {\n-  ALL_JAVA_THREADS(p) {\n-    p->metadata_do(f);\n-  }\n-}\n-\n-class ThreadHandlesClosure : public ThreadClosure {\n-  void (*_f)(Metadata*);\n- public:\n-  ThreadHandlesClosure(void f(Metadata*)) : _f(f) {}\n-  virtual void do_thread(Thread* thread) {\n-    thread->metadata_handles_do(_f);\n-  }\n-};\n-\n-void Threads::metadata_handles_do(void f(Metadata*)) {\n-  \/\/ Only walk the Handles in Thread.\n-  ThreadHandlesClosure handles_closure(f);\n-  threads_do(&handles_closure);\n-}\n-\n-\/\/ Get count Java threads that are waiting to enter the specified monitor.\n-GrowableArray<JavaThread*>* Threads::get_pending_threads(ThreadsList * t_list,\n-                                                         int count,\n-                                                         address monitor) {\n-  GrowableArray<JavaThread*>* result = new GrowableArray<JavaThread*>(count);\n-\n-  int i = 0;\n-  for (JavaThread* p : *t_list) {\n-    if (!p->can_call_java()) continue;\n-\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    address pending = (address)p->current_pending_monitor();\n-    if (pending == monitor) {             \/\/ found a match\n-      if (i < count) result->append(p);   \/\/ save the first count matches\n-      i++;\n-    }\n-  }\n-\n-  return result;\n-}\n-\n-\n-JavaThread *Threads::owning_thread_from_monitor_owner(ThreadsList * t_list,\n-                                                      address owner) {\n-  \/\/ NULL owner means not locked so we can skip the search\n-  if (owner == NULL) return NULL;\n-\n-  for (JavaThread* p : *t_list) {\n-    \/\/ first, see if owner is the address of a Java thread\n-    if (owner == (address)p) return p;\n-  }\n-\n-  \/\/ Cannot assert on lack of success here since this function may be\n-  \/\/ used by code that is trying to report useful problem information\n-  \/\/ like deadlock detection.\n-  if (UseHeavyMonitors) return NULL;\n-\n-  \/\/ If we didn't find a matching Java thread and we didn't force use of\n-  \/\/ heavyweight monitors, then the owner is the stack address of the\n-  \/\/ Lock Word in the owning Java thread's stack.\n-  \/\/\n-  JavaThread* the_owner = NULL;\n-  for (JavaThread* q : *t_list) {\n-    if (q->is_lock_owned(owner)) {\n-      the_owner = q;\n-      break;\n-    }\n-  }\n-\n-  \/\/ cannot assert on lack of success here; see above comment\n-  return the_owner;\n-}\n-\n-class PrintOnClosure : public ThreadClosure {\n-private:\n-  outputStream* _st;\n-\n-public:\n-  PrintOnClosure(outputStream* st) :\n-      _st(st) {}\n-\n-  virtual void do_thread(Thread* thread) {\n-    if (thread != NULL) {\n-      thread->print_on(_st);\n-      _st->cr();\n-    }\n-  }\n-};\n-\n-\/\/ Threads::print_on() is called at safepoint by VM_PrintThreads operation.\n-void Threads::print_on(outputStream* st, bool print_stacks,\n-                       bool internal_format, bool print_concurrent_locks,\n-                       bool print_extended_info) {\n-  char buf[32];\n-  st->print_raw_cr(os::local_time_string(buf, sizeof(buf)));\n-\n-  st->print_cr(\"Full thread dump %s (%s %s):\",\n-               VM_Version::vm_name(),\n-               VM_Version::vm_release(),\n-               VM_Version::vm_info_string());\n-  st->cr();\n-\n-#if INCLUDE_SERVICES\n-  \/\/ Dump concurrent locks\n-  ConcurrentLocksDump concurrent_locks;\n-  if (print_concurrent_locks) {\n-    concurrent_locks.dump_at_safepoint();\n-  }\n-#endif \/\/ INCLUDE_SERVICES\n-\n-  ThreadsSMRSupport::print_info_on(st);\n-  st->cr();\n-\n-  ALL_JAVA_THREADS(p) {\n-    ResourceMark rm;\n-    p->print_on(st, print_extended_info);\n-    if (print_stacks) {\n-      if (internal_format) {\n-        p->trace_stack();\n-      } else {\n-        p->print_stack_on(st);\n-      }\n-    }\n-    st->cr();\n-#if INCLUDE_SERVICES\n-    if (print_concurrent_locks) {\n-      concurrent_locks.print_locks_on(p, st);\n-    }\n-#endif \/\/ INCLUDE_SERVICES\n-  }\n-\n-  PrintOnClosure cl(st);\n-  cl.do_thread(VMThread::vm_thread());\n-  Universe::heap()->gc_threads_do(&cl);\n-  if (StringDedup::is_enabled()) {\n-    StringDedup::threads_do(&cl);\n-  }\n-  cl.do_thread(WatcherThread::watcher_thread());\n-  cl.do_thread(AsyncLogWriter::instance());\n-\n-  st->flush();\n-}\n-\n-void Threads::print_on_error(Thread* this_thread, outputStream* st, Thread* current, char* buf,\n-                             int buflen, bool* found_current) {\n-  if (this_thread != NULL) {\n-    bool is_current = (current == this_thread);\n-    *found_current = *found_current || is_current;\n-    st->print(\"%s\", is_current ? \"=>\" : \"  \");\n-\n-    st->print(PTR_FORMAT, p2i(this_thread));\n-    st->print(\" \");\n-    this_thread->print_on_error(st, buf, buflen);\n-    st->cr();\n-  }\n-}\n-\n-class PrintOnErrorClosure : public ThreadClosure {\n-  outputStream* _st;\n-  Thread* _current;\n-  char* _buf;\n-  int _buflen;\n-  bool* _found_current;\n- public:\n-  PrintOnErrorClosure(outputStream* st, Thread* current, char* buf,\n-                      int buflen, bool* found_current) :\n-   _st(st), _current(current), _buf(buf), _buflen(buflen), _found_current(found_current) {}\n-\n-  virtual void do_thread(Thread* thread) {\n-    Threads::print_on_error(thread, _st, _current, _buf, _buflen, _found_current);\n-  }\n-};\n-\n-\/\/ Threads::print_on_error() is called by fatal error handler. It's possible\n-\/\/ that VM is not at safepoint and\/or current thread is inside signal handler.\n-\/\/ Don't print stack trace, as the stack may not be walkable. Don't allocate\n-\/\/ memory (even in resource area), it might deadlock the error handler.\n-void Threads::print_on_error(outputStream* st, Thread* current, char* buf,\n-                             int buflen) {\n-  ThreadsSMRSupport::print_info_on(st);\n-  st->cr();\n-\n-  bool found_current = false;\n-  st->print_cr(\"Java Threads: ( => current thread )\");\n-  ALL_JAVA_THREADS(thread) {\n-    print_on_error(thread, st, current, buf, buflen, &found_current);\n-  }\n-  st->cr();\n-\n-  st->print_cr(\"Other Threads:\");\n-  print_on_error(VMThread::vm_thread(), st, current, buf, buflen, &found_current);\n-  print_on_error(WatcherThread::watcher_thread(), st, current, buf, buflen, &found_current);\n-  print_on_error(AsyncLogWriter::instance(), st, current, buf, buflen, &found_current);\n-\n-  if (Universe::heap() != NULL) {\n-    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n-    Universe::heap()->gc_threads_do(&print_closure);\n-  }\n-\n-  if (StringDedup::is_enabled()) {\n-    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n-    StringDedup::threads_do(&print_closure);\n-  }\n-\n-  if (!found_current) {\n-    st->cr();\n-    st->print(\"=>\" PTR_FORMAT \" (exited) \", p2i(current));\n-    current->print_on_error(st, buf, buflen);\n-    st->cr();\n-  }\n-  st->cr();\n-\n-  st->print_cr(\"Threads with active compile tasks:\");\n-  print_threads_compiling(st, buf, buflen);\n-}\n-\n-void Threads::print_threads_compiling(outputStream* st, char* buf, int buflen, bool short_form) {\n-  ALL_JAVA_THREADS(thread) {\n-    if (thread->is_Compiler_thread()) {\n-      CompilerThread* ct = (CompilerThread*) thread;\n-\n-      \/\/ Keep task in local variable for NULL check.\n-      \/\/ ct->_task might be set to NULL by concurring compiler thread\n-      \/\/ because it completed the compilation. The task is never freed,\n-      \/\/ though, just returned to a free list.\n-      CompileTask* task = ct->task();\n-      if (task != NULL) {\n-        thread->print_name_on_error(st, buf, buflen);\n-        st->print(\"  \");\n-        task->print(st, NULL, short_form, true);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Ad-hoc mutual exclusion primitives: SpinLock\n-\/\/\n-\/\/ We employ SpinLocks _only for low-contention, fixed-length\n-\/\/ short-duration critical sections where we're concerned\n-\/\/ about native mutex_t or HotSpot Mutex:: latency.\n-\/\/\n-\/\/ TODO-FIXME: ListLock should be of type SpinLock.\n-\/\/ We should make this a 1st-class type, integrated into the lock\n-\/\/ hierarchy as leaf-locks.  Critically, the SpinLock structure\n-\/\/ should have sufficient padding to avoid false-sharing and excessive\n-\/\/ cache-coherency traffic.\n-\n-\n-typedef volatile int SpinLockT;\n-\n-void Thread::SpinAcquire(volatile int * adr, const char * LockName) {\n-  if (Atomic::cmpxchg(adr, 0, 1) == 0) {\n-    return;   \/\/ normal fast-path return\n-  }\n-\n-  \/\/ Slow-path : We've encountered contention -- Spin\/Yield\/Block strategy.\n-  int ctr = 0;\n-  int Yields = 0;\n-  for (;;) {\n-    while (*adr != 0) {\n-      ++ctr;\n-      if ((ctr & 0xFFF) == 0 || !os::is_MP()) {\n-        if (Yields > 5) {\n-          os::naked_short_sleep(1);\n-        } else {\n-          os::naked_yield();\n-          ++Yields;\n-        }\n-      } else {\n-        SpinPause();\n-      }\n-    }\n-    if (Atomic::cmpxchg(adr, 0, 1) == 0) return;\n+    if (Atomic::cmpxchg(adr, 0, 1) == 0) return;\n@@ -3996,76 +612,0 @@\n-\n-\n-void Threads::verify() {\n-  ALL_JAVA_THREADS(p) {\n-    p->verify();\n-  }\n-  VMThread* thread = VMThread::vm_thread();\n-  if (thread != NULL) thread->verify();\n-}\n-\n-#ifndef PRODUCT\n-void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n-   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n-}\n-#endif\n-\n-\/\/ Helper function to create the java.lang.Thread object for a\n-\/\/ VM-internal thread. The thread will have the given name, and be\n-\/\/ a member of the \"system\" ThreadGroup.\n-Handle JavaThread::create_system_thread_object(const char* name,\n-                                               bool is_visible, TRAPS) {\n-  Handle string = java_lang_String::create_from_str(name, CHECK_NH);\n-\n-  \/\/ Initialize thread_oop to put it into the system threadGroup.\n-  \/\/ This is done by calling the Thread(ThreadGroup group, String name) constructor.\n-  Handle thread_group(THREAD, Universe::system_thread_group());\n-  Handle thread_oop =\n-    JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n-                                      vmSymbols::threadgroup_string_void_signature(),\n-                                      thread_group,\n-                                      string,\n-                                      CHECK_NH);\n-\n-  return thread_oop;\n-}\n-\n-\/\/ Starts the target JavaThread as a daemon of the given priority, and\n-\/\/ bound to the given java.lang.Thread instance.\n-\/\/ The Threads_lock is held for the duration.\n-void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n-                                       Handle thread_oop, ThreadPriority prio) {\n-\n-  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n-\n-  MutexLocker mu(current, Threads_lock);\n-\n-  \/\/ Initialize the fields of the thread_oop first.\n-\n-  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n-\n-  if (prio != NoPriority) {\n-    java_lang_Thread::set_priority(thread_oop(), prio);\n-    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n-    \/\/ else all threads should call it themselves when they first run.\n-  }\n-\n-  java_lang_Thread::set_daemon(thread_oop());\n-\n-  \/\/ Now bind the thread_oop to the target JavaThread.\n-  target->set_threadOopHandles(thread_oop());\n-\n-  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n-  Thread::start(target);\n-}\n-\n-void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n-  \/\/ At this point it may be possible that no osthread was created for the\n-  \/\/ JavaThread due to lack of resources. However, since this must work\n-  \/\/ for critical system threads just check and abort if this fails.\n-  if (thread->osthread() == nullptr) {\n-    \/\/ This isn't really an OOM condition, but historically this is what\n-    \/\/ we report.\n-    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                  os::native_thread_creation_failed_msg());\n-  }\n-}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":32,"deletions":3492,"binary":false,"changes":3524,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopHandle.hpp\"\n-#include \"runtime\/frame.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -37,3 +35,0 @@\n-#include \"runtime\/handshake.hpp\"\n-#include \"runtime\/javaFrameAnchor.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -41,4 +36,0 @@\n-#include \"runtime\/park.hpp\"\n-#include \"runtime\/safepointMechanism.hpp\"\n-#include \"runtime\/stackWatermarkSet.hpp\"\n-#include \"runtime\/stackOverflow.hpp\"\n@@ -49,2 +40,0 @@\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n@@ -57,24 +46,2 @@\n-class SafeThreadsListPtr;\n-class ThreadSafepointState;\n-class ThreadsList;\n-class ThreadsSMRSupport;\n-\n-class JNIHandleBlock;\n-class JvmtiRawMonitor;\n-class JvmtiSampledObjectAllocEventCollector;\n-class JvmtiThreadState;\n-class JvmtiVMObjectAllocEventCollector;\n-class OSThread;\n-class ThreadStatistics;\n-class ConcurrentLocksDump;\n-class MonitorInfo;\n-class AsyncExceptionHandshake;\n-\n-class vframeArray;\n-class vframe;\n-class javaVFrame;\n-\n-class DeoptResourceMark;\n-class JvmtiDeferredUpdates;\n-\n-class ThreadClosure;\n+class HandleArea;\n+class HandleMark;\n@@ -82,3 +49,1 @@\n-\n-class JVMCIRuntime;\n-\n+class JvmtiRawMonitor;\n@@ -86,0 +51,2 @@\n+class OSThread;\n+class ParkEvent;\n@@ -87,0 +54,4 @@\n+class SafeThreadsListPtr;\n+class ThreadClosure;\n+class ThreadsList;\n+class ThreadsSMRSupport;\n@@ -88,3 +59,2 @@\n-class OopStorage;\n-\n-class ContinuationEntry;\n+class OopClosure;\n+class CodeBlobClosure;\n@@ -698,1209 +668,0 @@\n-class CompilerThread;\n-\n-typedef void (*ThreadFunction)(JavaThread*, TRAPS);\n-\n-class JavaThread: public Thread {\n-  friend class VMStructs;\n-  friend class JVMCIVMStructs;\n-  friend class WhiteBox;\n-  friend class ThreadsSMRSupport; \/\/ to access _threadObj for exiting_threads_oops_do\n-  friend class HandshakeState;\n-  friend class Continuation;\n- private:\n-  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n-  bool           _on_thread_list;                \/\/ Is set when this JavaThread is added to the Threads list\n-  OopHandle      _threadObj;                     \/\/ The Java level thread object\n-  OopHandle      _vthread; \/\/ the value returned by Thread.currentThread(): the virtual thread, if mounted, otherwise _threadObj\n-  OopHandle      _jvmti_vthread;\n-  OopHandle      _extentLocalCache;\n-\n-#ifdef ASSERT\n- private:\n-  int _java_call_counter;\n-\n- public:\n-  int  java_call_counter()                       { return _java_call_counter; }\n-  void inc_java_call_counter()                   { _java_call_counter++; }\n-  void dec_java_call_counter() {\n-    assert(_java_call_counter > 0, \"Invalid nesting of JavaCallWrapper\");\n-    _java_call_counter--;\n-  }\n- private:  \/\/ restore original namespace restriction\n-#endif  \/\/ ifdef ASSERT\n-\n-  JavaFrameAnchor _anchor;                       \/\/ Encapsulation of current java frame and it state\n-\n-  ThreadFunction _entry_point;\n-\n-  JNIEnv        _jni_environment;\n-\n-  \/\/ Deopt support\n-  DeoptResourceMark*  _deopt_mark;               \/\/ Holds special ResourceMark for deoptimization\n-\n-  CompiledMethod*       _deopt_nmethod;         \/\/ CompiledMethod that is currently being deoptimized\n-  vframeArray*  _vframe_array_head;              \/\/ Holds the heap of the active vframeArrays\n-  vframeArray*  _vframe_array_last;              \/\/ Holds last vFrameArray we popped\n-  \/\/ Holds updates by JVMTI agents for compiled frames that cannot be performed immediately. They\n-  \/\/ will be carried out as soon as possible which, in most cases, is just before deoptimization of\n-  \/\/ the frame, when control returns to it.\n-  JvmtiDeferredUpdates* _jvmti_deferred_updates;\n-\n-  \/\/ Handshake value for fixing 6243940. We need a place for the i2c\n-  \/\/ adapter to store the callee Method*. This value is NEVER live\n-  \/\/ across a gc point so it does NOT have to be gc'd\n-  \/\/ The handshake is open ended since we can't be certain that it will\n-  \/\/ be NULLed. This is because we rarely ever see the race and end up\n-  \/\/ in handle_wrong_method which is the backend of the handshake. See\n-  \/\/ code in i2c adapters and handle_wrong_method.\n-\n-  Method*       _callee_target;\n-\n-  \/\/ Used to pass back results to the interpreter or generated code running Java code.\n-  oop           _vm_result;    \/\/ oop result is GC-preserved\n-  Metadata*     _vm_result_2;  \/\/ non-oop result\n-\n-  \/\/ See ReduceInitialCardMarks: this holds the precise space interval of\n-  \/\/ the most recent slow path allocation for which compiled code has\n-  \/\/ elided card-marks for performance along the fast-path.\n-  MemRegion     _deferred_card_mark;\n-\n-  ObjectMonitor* volatile _current_pending_monitor;     \/\/ ObjectMonitor this thread is waiting to lock\n-  bool           _current_pending_monitor_is_from_java; \/\/ locking is from Java code\n-  ObjectMonitor* volatile _current_waiting_monitor;     \/\/ ObjectMonitor on which this thread called Object.wait()\n-\n-  \/\/ Active_handles points to a block of handles\n-  JNIHandleBlock* _active_handles;\n-\n-  \/\/ One-element thread local free list\n-  JNIHandleBlock* _free_handle_block;\n-\n- public:\n-  volatile intptr_t _Stalled;\n-\n-  \/\/ For tracking the heavyweight monitor the thread is pending on.\n-  ObjectMonitor* current_pending_monitor() {\n-    \/\/ Use Atomic::load() to prevent data race between concurrent modification and\n-    \/\/ concurrent readers, e.g. ThreadService::get_current_contended_monitor().\n-    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n-    return Atomic::load(&_current_pending_monitor);\n-  }\n-  void set_current_pending_monitor(ObjectMonitor* monitor) {\n-    Atomic::store(&_current_pending_monitor, monitor);\n-  }\n-  void set_current_pending_monitor_is_from_java(bool from_java) {\n-    _current_pending_monitor_is_from_java = from_java;\n-  }\n-  bool current_pending_monitor_is_from_java() {\n-    return _current_pending_monitor_is_from_java;\n-  }\n-  ObjectMonitor* current_waiting_monitor() {\n-    \/\/ See the comment in current_pending_monitor() above.\n-    return Atomic::load(&_current_waiting_monitor);\n-  }\n-  void set_current_waiting_monitor(ObjectMonitor* monitor) {\n-    Atomic::store(&_current_waiting_monitor, monitor);\n-  }\n-\n-  \/\/ JNI handle support\n-  JNIHandleBlock* active_handles() const         { return _active_handles; }\n-  void set_active_handles(JNIHandleBlock* block) { _active_handles = block; }\n-  JNIHandleBlock* free_handle_block() const      { return _free_handle_block; }\n-  void set_free_handle_block(JNIHandleBlock* block) { _free_handle_block = block; }\n-\n-  void push_jni_handle_block();\n-  void pop_jni_handle_block();\n-\n- private:\n-  MonitorChunk* _monitor_chunks;              \/\/ Contains the off stack monitors\n-                                              \/\/ allocated during deoptimization\n-                                              \/\/ and by JNI_MonitorEnter\/Exit\n-\n-  enum SuspendFlags {\n-    \/\/ NOTE: avoid using the sign-bit as cc generates different test code\n-    \/\/       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n-    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n-  };\n-\n-  \/\/ various suspension related flags - atomically updated\n-  volatile uint32_t _suspend_flags;\n-\n-  inline void set_suspend_flag(SuspendFlags f);\n-  inline void clear_suspend_flag(SuspendFlags f);\n-\n- public:\n-  inline void set_trace_flag();\n-  inline void clear_trace_flag();\n-  inline void set_obj_deopt_flag();\n-  inline void clear_obj_deopt_flag();\n-  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n-  bool is_obj_deopt_suspend()  { return (_suspend_flags & _obj_deopt) != 0; }\n-\n-  \/\/ Asynchronous exception support\n- private:\n-  friend class InstallAsyncExceptionHandshake;\n-  friend class AsyncExceptionHandshake;\n-  friend class HandshakeState;\n-\n-  void install_async_exception(AsyncExceptionHandshake* aec = NULL);\n-  void handle_async_exception(oop java_throwable);\n- public:\n-  bool has_async_exception_condition(bool ThreadDeath_only = false);\n-  inline void set_pending_unsafe_access_error();\n-  static void send_async_exception(JavaThread* jt, oop java_throwable);\n-\n-  class NoAsyncExceptionDeliveryMark : public StackObj {\n-    friend JavaThread;\n-    JavaThread *_target;\n-    inline NoAsyncExceptionDeliveryMark(JavaThread *t);\n-    inline ~NoAsyncExceptionDeliveryMark();\n-  };\n-\n-  \/\/ Safepoint support\n- public:                                                        \/\/ Expose _thread_state for SafeFetchInt()\n-  volatile JavaThreadState _thread_state;\n- private:\n-  SafepointMechanism::ThreadData _poll_data;\n-  ThreadSafepointState*          _safepoint_state;              \/\/ Holds information about a thread during a safepoint\n-  address                        _saved_exception_pc;           \/\/ Saved pc of instruction where last implicit exception happened\n-  NOT_PRODUCT(bool               _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n-#ifdef ASSERT\n-  \/\/ Debug support for checking if code allows safepoints or not.\n-  \/\/ Safepoints in the VM can happen because of allocation, invoking a VM operation, or blocking on\n-  \/\/ mutex, or blocking on an object synchronizer (Java locking).\n-  \/\/ If _no_safepoint_count is non-zero, then an assertion failure will happen in any of\n-  \/\/ the above cases. The class NoSafepointVerifier is used to set this counter.\n-  int _no_safepoint_count;                             \/\/ If 0, thread allow a safepoint to happen\n-\n- public:\n-  void inc_no_safepoint_count() { _no_safepoint_count++; }\n-  void dec_no_safepoint_count() { _no_safepoint_count--; }\n-#endif \/\/ ASSERT\n- public:\n-  \/\/ These functions check conditions before possibly going to a safepoint.\n-  \/\/ including NoSafepointVerifier.\n-  void check_for_valid_safepoint_state() NOT_DEBUG_RETURN;\n-  void check_possible_safepoint()        NOT_DEBUG_RETURN;\n-\n-#ifdef ASSERT\n- private:\n-  volatile uint64_t _visited_for_critical_count;\n-\n- public:\n-  void set_visited_for_critical_count(uint64_t safepoint_id) {\n-    assert(_visited_for_critical_count == 0, \"Must be reset before set\");\n-    assert((safepoint_id & 0x1) == 1, \"Must be odd\");\n-    _visited_for_critical_count = safepoint_id;\n-  }\n-  void reset_visited_for_critical_count(uint64_t safepoint_id) {\n-    assert(_visited_for_critical_count == safepoint_id, \"Was not visited\");\n-    _visited_for_critical_count = 0;\n-  }\n-  bool was_visited_for_critical_count(uint64_t safepoint_id) const {\n-    return _visited_for_critical_count == safepoint_id;\n-  }\n-#endif \/\/ ASSERT\n-\n-  \/\/ JavaThread termination support\n- public:\n-  enum TerminatedTypes {\n-    _not_terminated = 0xDEAD - 2,\n-    _thread_exiting,                             \/\/ JavaThread::exit() has been called for this thread\n-    _thread_terminated,                          \/\/ JavaThread is removed from thread list\n-    _vm_exited                                   \/\/ JavaThread is still executing native code, but VM is terminated\n-                                                 \/\/ only VM_Exit can set _vm_exited\n-  };\n-\n- private:\n-  \/\/ In general a JavaThread's _terminated field transitions as follows:\n-  \/\/\n-  \/\/   _not_terminated => _thread_exiting => _thread_terminated\n-  \/\/\n-  \/\/ _vm_exited is a special value to cover the case of a JavaThread\n-  \/\/ executing native code after the VM itself is terminated.\n-  volatile TerminatedTypes _terminated;\n-\n-  jint                  _in_deopt_handler;       \/\/ count of deoptimization\n-                                                 \/\/ handlers thread is in\n-  volatile bool         _doing_unsafe_access;    \/\/ Thread may fault due to unsafe access\n-  bool                  _do_not_unlock_if_synchronized;  \/\/ Do not unlock the receiver of a synchronized method (since it was\n-                                                         \/\/ never locked) when throwing an exception. Used by interpreter only.\n-#if INCLUDE_JVMTI\n-  volatile bool         _carrier_thread_suspended;       \/\/ Carrier thread is externally suspended\n-  bool                  _is_in_VTMS_transition;          \/\/ thread is in virtual thread mount state transition\n-#ifdef ASSERT\n-  bool                  _is_VTMS_transition_disabler;    \/\/ thread currently disabled VTMS transitions\n-#endif\n-#endif\n-\n-  \/\/ JNI attach states:\n-  enum JNIAttachStates {\n-    _not_attaching_via_jni = 1,  \/\/ thread is not attaching via JNI\n-    _attaching_via_jni,          \/\/ thread is attaching via JNI\n-    _attached_via_jni            \/\/ thread has attached via JNI\n-  };\n-\n-  \/\/ A regular JavaThread's _jni_attach_state is _not_attaching_via_jni.\n-  \/\/ A native thread that is attaching via JNI starts with a value\n-  \/\/ of _attaching_via_jni and transitions to _attached_via_jni.\n-  volatile JNIAttachStates _jni_attach_state;\n-\n-\n-#if INCLUDE_JVMCI\n-  \/\/ The _pending_* fields below are used to communicate extra information\n-  \/\/ from an uncommon trap in JVMCI compiled code to the uncommon trap handler.\n-\n-  \/\/ Communicates the DeoptReason and DeoptAction of the uncommon trap\n-  int       _pending_deoptimization;\n-\n-  \/\/ Specifies whether the uncommon trap is to bci 0 of a synchronized method\n-  \/\/ before the monitor has been acquired.\n-  bool      _pending_monitorenter;\n-\n-  \/\/ Specifies if the DeoptReason for the last uncommon trap was Reason_transfer_to_interpreter\n-  bool      _pending_transfer_to_interpreter;\n-\n-  \/\/ True if in a runtime call from compiled code that will deoptimize\n-  \/\/ and re-execute a failed heap allocation in the interpreter.\n-  bool      _in_retryable_allocation;\n-\n-  \/\/ An id of a speculation that JVMCI compiled code can use to further describe and\n-  \/\/ uniquely identify the speculative optimization guarded by an uncommon trap.\n-  \/\/ See JVMCINMethodData::SPECULATION_LENGTH_BITS for further details.\n-  jlong     _pending_failed_speculation;\n-\n-  \/\/ These fields are mutually exclusive in terms of live ranges.\n-  union {\n-    \/\/ Communicates the pc at which the most recent implicit exception occurred\n-    \/\/ from the signal handler to a deoptimization stub.\n-    address   _implicit_exception_pc;\n-\n-    \/\/ Communicates an alternative call target to an i2c stub from a JavaCall .\n-    address   _alternate_call_target;\n-  } _jvmci;\n-\n-  \/\/ The JVMCIRuntime in a JVMCI shared library\n-  JVMCIRuntime* _libjvmci_runtime;\n-\n-  \/\/ Support for high precision, thread sensitive counters in JVMCI compiled code.\n-  jlong*    _jvmci_counters;\n-\n-  \/\/ Fast thread locals for use by JVMCI\n-  jlong      _jvmci_reserved0;\n-  jlong      _jvmci_reserved1;\n-  oop        _jvmci_reserved_oop0;\n-\n- public:\n-  static jlong* _jvmci_old_thread_counters;\n-  static void collect_counters(jlong* array, int length);\n-\n-  bool resize_counters(int current_size, int new_size);\n-\n-  static bool resize_all_jvmci_counters(int new_size);\n-\n-  void set_jvmci_reserved_oop0(oop value) {\n-    _jvmci_reserved_oop0 = value;\n-  }\n-\n-  oop get_jvmci_reserved_oop0() {\n-    return _jvmci_reserved_oop0;\n-  }\n-\n-  void set_jvmci_reserved0(jlong value) {\n-    _jvmci_reserved0 = value;\n-  }\n-\n-  jlong get_jvmci_reserved0() {\n-    return _jvmci_reserved0;\n-  }\n-\n-  void set_jvmci_reserved1(jlong value) {\n-    _jvmci_reserved1 = value;\n-  }\n-\n-  jlong get_jvmci_reserved1() {\n-    return _jvmci_reserved1;\n-  }\n-\n- private:\n-#endif \/\/ INCLUDE_JVMCI\n-\n-  StackOverflow    _stack_overflow_state;\n-\n-  \/\/ Compiler exception handling (NOTE: The _exception_oop is *NOT* the same as _pending_exception. It is\n-  \/\/ used to temp. parsing values into and out of the runtime system during exception handling for compiled\n-  \/\/ code)\n-  volatile oop     _exception_oop;               \/\/ Exception thrown in compiled code\n-  volatile address _exception_pc;                \/\/ PC where exception happened\n-  volatile address _exception_handler_pc;        \/\/ PC for handler of exception\n-  volatile int     _is_method_handle_return;     \/\/ true (== 1) if the current exception PC is a MethodHandle call site.\n-\n- private:\n-  \/\/ support for JNI critical regions\n-  jint    _jni_active_critical;                  \/\/ count of entries into JNI critical region\n-\n-  \/\/ Checked JNI: function name requires exception check\n-  char* _pending_jni_exception_check_fn;\n-\n-  \/\/ For deadlock detection.\n-  int _depth_first_number;\n-\n-  \/\/ JVMTI PopFrame support\n-  \/\/ This is set to popframe_pending to signal that top Java frame should be popped immediately\n-  int _popframe_condition;\n-\n-  \/\/ If reallocation of scalar replaced objects fails, we throw OOM\n-  \/\/ and during exception propagation, pop the top\n-  \/\/ _frames_to_pop_failed_realloc frames, the ones that reference\n-  \/\/ failed reallocations.\n-  int _frames_to_pop_failed_realloc;\n-\n-  ContinuationEntry* _cont_entry;\n-  intptr_t* _cont_fastpath; \/\/ the sp of the oldest known interpreted\/call_stub frame inside the\n-                            \/\/ continuation that we know about\n-  int _cont_fastpath_thread_state; \/\/ whether global thread state allows continuation fastpath (JVMTI)\n-  int _held_monitor_count;  \/\/ used by continuations for fast lock detection\n-private:\n-\n-  friend class VMThread;\n-  friend class ThreadWaitTransition;\n-  friend class VM_Exit;\n-\n-  \/\/ Stack watermark barriers.\n-  StackWatermarks _stack_watermarks;\n-\n- public:\n-  inline StackWatermarks* stack_watermarks() { return &_stack_watermarks; }\n-\n- public:\n-  jlong _extentLocal_hash_table_shift;\n-\n-  void allocate_extentLocal_hash_table(int count);\n-\n- public:\n-  \/\/ Constructor\n-  JavaThread();                            \/\/ delegating constructor\n-  JavaThread(bool is_attaching_via_jni);   \/\/ for main thread and JNI attached threads\n-  JavaThread(ThreadFunction entry_point, size_t stack_size = 0);\n-  ~JavaThread();\n-\n-#ifdef ASSERT\n-  \/\/ verify this JavaThread hasn't be published in the Threads::list yet\n-  void verify_not_published();\n-#endif \/\/ ASSERT\n-\n-  StackOverflow* stack_overflow_state() { return &_stack_overflow_state; }\n-\n-  \/\/JNI functiontable getter\/setter for JVMTI jni function table interception API.\n-  void set_jni_functions(struct JNINativeInterface_* functionTable) {\n-    _jni_environment.functions = functionTable;\n-  }\n-  struct JNINativeInterface_* get_jni_functions() {\n-    return (struct JNINativeInterface_ *)_jni_environment.functions;\n-  }\n-\n-  \/\/ This function is called at thread creation to allow\n-  \/\/ platform specific thread variables to be initialized.\n-  void cache_global_variables();\n-\n-  \/\/ Executes Shutdown.shutdown()\n-  void invoke_shutdown_hooks();\n-\n-  \/\/ Cleanup on thread exit\n-  enum ExitType {\n-    normal_exit,\n-    jni_detach\n-  };\n-  void exit(bool destroy_vm, ExitType exit_type = normal_exit);\n-\n-  void cleanup_failed_attach_current_thread(bool is_daemon);\n-\n-  \/\/ Testers\n-  virtual bool is_Java_thread() const            { return true;  }\n-  virtual bool can_call_java() const             { return true; }\n-\n-  virtual bool is_active_Java_thread() const {\n-    return on_thread_list() && !is_terminated();\n-  }\n-\n-  \/\/ Thread oop. threadObj() can be NULL for initial JavaThread\n-  \/\/ (or for threads attached via JNI)\n-  oop threadObj() const;\n-  void set_threadOopHandles(oop p);\n-  oop vthread() const;\n-  void set_vthread(oop p);\n-  oop extentLocalCache() const;\n-  void set_extentLocalCache(oop p);\n-  oop jvmti_vthread() const;\n-  void set_jvmti_vthread(oop p);\n-\n-  \/\/ Prepare thread and add to priority queue.  If a priority is\n-  \/\/ not specified, use the priority of the thread object. Threads_lock\n-  \/\/ must be held while this function is called.\n-  void prepare(jobject jni_thread, ThreadPriority prio=NoPriority);\n-\n-  void set_saved_exception_pc(address pc)        { _saved_exception_pc = pc; }\n-  address saved_exception_pc()                   { return _saved_exception_pc; }\n-\n-  ThreadFunction entry_point() const             { return _entry_point; }\n-\n-  \/\/ Allocates a new Java level thread object for this thread. thread_name may be NULL.\n-  void allocate_threadObj(Handle thread_group, const char* thread_name, bool daemon, TRAPS);\n-\n-  \/\/ Last frame anchor routines\n-\n-  JavaFrameAnchor* frame_anchor(void)            { return &_anchor; }\n-\n-  \/\/ last_Java_sp\n-  bool has_last_Java_frame() const               { return _anchor.has_last_Java_frame(); }\n-  intptr_t* last_Java_sp() const                 { return _anchor.last_Java_sp(); }\n-\n-  \/\/ last_Java_pc\n-\n-  address last_Java_pc(void)                     { return _anchor.last_Java_pc(); }\n-\n-  \/\/ Safepoint support\n-  inline JavaThreadState thread_state() const;\n-  inline void set_thread_state(JavaThreadState s);\n-  inline void set_thread_state_fence(JavaThreadState s);  \/\/ fence after setting thread state\n-  inline ThreadSafepointState* safepoint_state() const;\n-  inline void set_safepoint_state(ThreadSafepointState* state);\n-  inline bool is_at_poll_safepoint();\n-\n-  \/\/ JavaThread termination and lifecycle support:\n-  void smr_delete();\n-  bool on_thread_list() const { return _on_thread_list; }\n-  void set_on_thread_list() { _on_thread_list = true; }\n-\n-  \/\/ thread has called JavaThread::exit() or is terminated\n-  bool is_exiting() const;\n-  \/\/ thread is terminated (no longer on the threads list); we compare\n-  \/\/ against the two non-terminated values so that a freed JavaThread\n-  \/\/ will also be considered terminated.\n-  bool check_is_terminated(TerminatedTypes l_terminated) const {\n-    return l_terminated != _not_terminated && l_terminated != _thread_exiting;\n-  }\n-  bool is_terminated() const;\n-  void set_terminated(TerminatedTypes t);\n-\n-  void block_if_vm_exited();\n-\n-  bool doing_unsafe_access()                     { return _doing_unsafe_access; }\n-  void set_doing_unsafe_access(bool val)         { _doing_unsafe_access = val; }\n-\n-  bool do_not_unlock_if_synchronized()             { return _do_not_unlock_if_synchronized; }\n-  void set_do_not_unlock_if_synchronized(bool val) { _do_not_unlock_if_synchronized = val; }\n-\n-  SafepointMechanism::ThreadData* poll_data() { return &_poll_data; }\n-\n-  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n-\n-  \/\/ Continuation support\n-  oop get_continuation() const;\n-  ContinuationEntry* last_continuation() const { return _cont_entry; }\n-  void set_cont_fastpath(intptr_t* x)          { _cont_fastpath = x; }\n-  void push_cont_fastpath(intptr_t* sp)        { if (sp > _cont_fastpath) _cont_fastpath = sp; }\n-  void set_cont_fastpath_thread_state(bool x)  { _cont_fastpath_thread_state = (int)x; }\n-  intptr_t* raw_cont_fastpath() const          { return _cont_fastpath; }\n-  bool cont_fastpath() const                   { return _cont_fastpath == NULL && _cont_fastpath_thread_state != 0; }\n-  bool cont_fastpath_thread_state() const      { return _cont_fastpath_thread_state != 0; }\n-\n-  int held_monitor_count()        { return _held_monitor_count; }\n-  void reset_held_monitor_count() { _held_monitor_count = 0; }\n-  void inc_held_monitor_count();\n-  void dec_held_monitor_count();\n-\n-  inline bool is_vthread_mounted() const;\n-  inline const ContinuationEntry* vthread_continuation() const;\n-\n- private:\n-  DEBUG_ONLY(void verify_frame_info();)\n-\n-  \/\/ Support for thread handshake operations\n-  HandshakeState _handshake;\n- public:\n-  HandshakeState* handshake_state() { return &_handshake; }\n-\n-  \/\/ A JavaThread can always safely operate on it self and other threads\n-  \/\/ can do it safely if they are the active handshaker.\n-  bool is_handshake_safe_for(Thread* th) const {\n-    return _handshake.active_handshaker() == th || this == th;\n-  }\n-\n-  \/\/ Suspend\/resume support for JavaThread\n-  \/\/ higher-level suspension\/resume logic called by the public APIs\n-  bool java_suspend();\n-  bool java_resume();\n-  bool is_suspended()     { return _handshake.is_suspended(); }\n-\n-  \/\/ Check for async exception in addition to safepoint.\n-  static void check_special_condition_for_native_trans(JavaThread *thread);\n-\n-  \/\/ Synchronize with another thread that is deoptimizing objects of the\n-  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n-  void wait_for_object_deoptimization();\n-\n-#if INCLUDE_JVMTI\n-  inline void set_carrier_thread_suspended();\n-  inline void clear_carrier_thread_suspended();\n-\n-  bool is_carrier_thread_suspended() const {\n-    return _carrier_thread_suspended;\n-  }\n-\n-  bool is_in_VTMS_transition() const             { return _is_in_VTMS_transition; }\n-  void set_is_in_VTMS_transition(bool val);\n-#ifdef ASSERT\n-  bool is_VTMS_transition_disabler() const       { return _is_VTMS_transition_disabler; }\n-  void set_is_VTMS_transition_disabler(bool val);\n-#endif\n-#endif\n-\n-  \/\/ Support for object deoptimization and JFR suspension\n-  void handle_special_runtime_exit_condition();\n-  bool has_special_runtime_exit_condition() {\n-    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n-  }\n-\n-  \/\/ Fast-locking support\n-  bool is_lock_owned(address adr) const;\n-  bool is_lock_owned_current(address adr) const; \/\/ virtual if mounted, otherwise whole thread\n-  bool is_lock_owned_carrier(address adr) const;\n-\n-  \/\/ Accessors for vframe array top\n-  \/\/ The linked list of vframe arrays are sorted on sp. This means when we\n-  \/\/ unpack the head must contain the vframe array to unpack.\n-  void set_vframe_array_head(vframeArray* value) { _vframe_array_head = value; }\n-  vframeArray* vframe_array_head() const         { return _vframe_array_head;  }\n-\n-  \/\/ Side structure for deferring update of java frame locals until deopt occurs\n-  JvmtiDeferredUpdates* deferred_updates() const      { return _jvmti_deferred_updates; }\n-  void set_deferred_updates(JvmtiDeferredUpdates* du) { _jvmti_deferred_updates = du; }\n-\n-  \/\/ These only really exist to make debugging deopt problems simpler\n-\n-  void set_vframe_array_last(vframeArray* value) { _vframe_array_last = value; }\n-  vframeArray* vframe_array_last() const         { return _vframe_array_last;  }\n-\n-  \/\/ The special resourceMark used during deoptimization\n-\n-  void set_deopt_mark(DeoptResourceMark* value)  { _deopt_mark = value; }\n-  DeoptResourceMark* deopt_mark(void)            { return _deopt_mark; }\n-\n-  void set_deopt_compiled_method(CompiledMethod* nm)  { _deopt_nmethod = nm; }\n-  CompiledMethod* deopt_compiled_method()        { return _deopt_nmethod; }\n-\n-  Method*    callee_target() const               { return _callee_target; }\n-  void set_callee_target  (Method* x)          { _callee_target   = x; }\n-\n-  \/\/ Oop results of vm runtime calls\n-  oop  vm_result() const                         { return _vm_result; }\n-  void set_vm_result  (oop x)                    { _vm_result   = x; }\n-\n-  Metadata*    vm_result_2() const               { return _vm_result_2; }\n-  void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }\n-\n-  MemRegion deferred_card_mark() const           { return _deferred_card_mark; }\n-  void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }\n-\n-#if INCLUDE_JVMCI\n-  int  pending_deoptimization() const             { return _pending_deoptimization; }\n-  jlong pending_failed_speculation() const        { return _pending_failed_speculation; }\n-  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n-  void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }\n-  void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }\n-  void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }\n-  void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }\n-  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, \"must be\"); _jvmci._alternate_call_target = a; }\n-  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, \"must be\"); _jvmci._implicit_exception_pc = a; }\n-\n-  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n-  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n-\n-  JVMCIRuntime* libjvmci_runtime() const          { return _libjvmci_runtime; }\n-  void set_libjvmci_runtime(JVMCIRuntime* rt) {\n-    assert((_libjvmci_runtime == nullptr && rt != nullptr) || (_libjvmci_runtime != nullptr && rt == nullptr), \"must be\");\n-    _libjvmci_runtime = rt;\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n-\n-  \/\/ Exception handling for compiled methods\n-  oop      exception_oop() const;\n-  address  exception_pc() const                  { return _exception_pc; }\n-  address  exception_handler_pc() const          { return _exception_handler_pc; }\n-  bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }\n-\n-  void set_exception_oop(oop o);\n-  void set_exception_pc(address a)               { _exception_pc = a; }\n-  void set_exception_handler_pc(address a)       { _exception_handler_pc = a; }\n-  void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }\n-\n-  void clear_exception_oop_and_pc() {\n-    set_exception_oop(NULL);\n-    set_exception_pc(NULL);\n-  }\n-\n-  \/\/ Check if address is in the usable part of the stack (excludes protected\n-  \/\/ guard pages). Can be applied to any thread and is an approximation for\n-  \/\/ using is_in_live_stack when the query has to happen from another thread.\n-  bool is_in_usable_stack(address adr) const {\n-    return is_in_stack_range_incl(adr, _stack_overflow_state.stack_reserved_zone_base());\n-  }\n-\n-  \/\/ Misc. accessors\/mutators\n-  void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }\n-  void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }\n-  bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }\n-\n-  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n-\n-  \/\/ For assembly stub generation\n-  static ByteSize threadObj_offset()             { return byte_offset_of(JavaThread, _threadObj); }\n-  static ByteSize vthread_offset()               { return byte_offset_of(JavaThread, _vthread); }\n-  static ByteSize jni_environment_offset()       { return byte_offset_of(JavaThread, _jni_environment); }\n-  static ByteSize pending_jni_exception_check_fn_offset() {\n-    return byte_offset_of(JavaThread, _pending_jni_exception_check_fn);\n-  }\n-  static ByteSize last_Java_sp_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_sp_offset();\n-  }\n-  static ByteSize last_Java_pc_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_pc_offset();\n-  }\n-  static ByteSize frame_anchor_offset() {\n-    return byte_offset_of(JavaThread, _anchor);\n-  }\n-  static ByteSize callee_target_offset()         { return byte_offset_of(JavaThread, _callee_target); }\n-  static ByteSize vm_result_offset()             { return byte_offset_of(JavaThread, _vm_result); }\n-  static ByteSize vm_result_2_offset()           { return byte_offset_of(JavaThread, _vm_result_2); }\n-  static ByteSize thread_state_offset()          { return byte_offset_of(JavaThread, _thread_state); }\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n-  static ByteSize saved_exception_pc_offset()    { return byte_offset_of(JavaThread, _saved_exception_pc); }\n-  static ByteSize osthread_offset()              { return byte_offset_of(JavaThread, _osthread); }\n-#if INCLUDE_JVMCI\n-  static ByteSize pending_deoptimization_offset() { return byte_offset_of(JavaThread, _pending_deoptimization); }\n-  static ByteSize pending_monitorenter_offset()  { return byte_offset_of(JavaThread, _pending_monitorenter); }\n-  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n-  static ByteSize jvmci_alternate_call_target_offset() { return byte_offset_of(JavaThread, _jvmci._alternate_call_target); }\n-  static ByteSize jvmci_implicit_exception_pc_offset() { return byte_offset_of(JavaThread, _jvmci._implicit_exception_pc); }\n-  static ByteSize jvmci_counters_offset()        { return byte_offset_of(JavaThread, _jvmci_counters); }\n-#endif \/\/ INCLUDE_JVMCI\n-  static ByteSize exception_oop_offset()         { return byte_offset_of(JavaThread, _exception_oop); }\n-  static ByteSize exception_pc_offset()          { return byte_offset_of(JavaThread, _exception_pc); }\n-  static ByteSize exception_handler_pc_offset()  { return byte_offset_of(JavaThread, _exception_handler_pc); }\n-  static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }\n-\n-  static ByteSize active_handles_offset()        { return byte_offset_of(JavaThread, _active_handles); }\n-\n-  \/\/ StackOverflow offsets\n-  static ByteSize stack_overflow_limit_offset()  {\n-    return byte_offset_of(JavaThread, _stack_overflow_state._stack_overflow_limit);\n-  }\n-  static ByteSize stack_guard_state_offset()     {\n-    return byte_offset_of(JavaThread, _stack_overflow_state._stack_guard_state);\n-  }\n-  static ByteSize reserved_stack_activation_offset() {\n-    return byte_offset_of(JavaThread, _stack_overflow_state._reserved_stack_activation);\n-  }\n-  static ByteSize shadow_zone_safe_limit()  {\n-    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_safe_limit);\n-  }\n-  static ByteSize shadow_zone_growth_watermark()  {\n-    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_growth_watermark);\n-  }\n-\n-  static ByteSize suspend_flags_offset()         { return byte_offset_of(JavaThread, _suspend_flags); }\n-\n-  static ByteSize do_not_unlock_if_synchronized_offset() { return byte_offset_of(JavaThread, _do_not_unlock_if_synchronized); }\n-  static ByteSize should_post_on_exceptions_flag_offset() {\n-    return byte_offset_of(JavaThread, _should_post_on_exceptions_flag);\n-  }\n-  static ByteSize doing_unsafe_access_offset() { return byte_offset_of(JavaThread, _doing_unsafe_access); }\n-  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n-\n-  static ByteSize cont_entry_offset()         { return byte_offset_of(JavaThread, _cont_entry); }\n-  static ByteSize cont_fastpath_offset()      { return byte_offset_of(JavaThread, _cont_fastpath); }\n-  static ByteSize held_monitor_count_offset() { return byte_offset_of(JavaThread, _held_monitor_count); }\n-\n-  \/\/ Returns the jni environment for this thread\n-  JNIEnv* jni_environment()                      { return &_jni_environment; }\n-\n-  \/\/ Returns the current thread as indicated by the given JNIEnv.\n-  \/\/ We don't assert it is Thread::current here as that is done at the\n-  \/\/ external JNI entry points where the JNIEnv is passed into the VM.\n-  static JavaThread* thread_from_jni_environment(JNIEnv* env) {\n-    JavaThread* current = (JavaThread*)((intptr_t)env - in_bytes(jni_environment_offset()));\n-    \/\/ We can't normally get here in a thread that has completed its\n-    \/\/ execution and so \"is_terminated\", except when the call is from\n-    \/\/ AsyncGetCallTrace, which can be triggered by a signal at any point in\n-    \/\/ a thread's lifecycle. A thread is also considered terminated if the VM\n-    \/\/ has exited, so we have to check this and block in case this is a daemon\n-    \/\/ thread returning to the VM (the JNI DirectBuffer entry points rely on\n-    \/\/ this).\n-    if (current->is_terminated()) {\n-      current->block_if_vm_exited();\n-    }\n-    return current;\n-  }\n-\n-  \/\/ JNI critical regions. These can nest.\n-  bool in_critical()    { return _jni_active_critical > 0; }\n-  bool in_last_critical()  { return _jni_active_critical == 1; }\n-  inline void enter_critical();\n-  void exit_critical() {\n-    assert(Thread::current() == this, \"this must be current thread\");\n-    _jni_active_critical--;\n-    assert(_jni_active_critical >= 0, \"JNI critical nesting problem?\");\n-  }\n-\n-  \/\/ Checked JNI: is the programmer required to check for exceptions, if so specify\n-  \/\/ which function name. Returning to a Java frame should implicitly clear the\n-  \/\/ pending check, this is done for Native->Java transitions (i.e. user JNI code).\n-  \/\/ VM->Java transitions are not cleared, it is expected that JNI code enclosed\n-  \/\/ within ThreadToNativeFromVM makes proper exception checks (i.e. VM internal).\n-  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != NULL; }\n-  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = NULL; }\n-  const char* get_pending_jni_exception_check() const { return _pending_jni_exception_check_fn; }\n-  void set_pending_jni_exception_check(const char* fn_name) { _pending_jni_exception_check_fn = (char*) fn_name; }\n-\n-  \/\/ For deadlock detection\n-  int depth_first_number() { return _depth_first_number; }\n-  void set_depth_first_number(int dfn) { _depth_first_number = dfn; }\n-\n- private:\n-  void set_monitor_chunks(MonitorChunk* monitor_chunks) { _monitor_chunks = monitor_chunks; }\n-\n- public:\n-  MonitorChunk* monitor_chunks() const           { return _monitor_chunks; }\n-  void add_monitor_chunk(MonitorChunk* chunk);\n-  void remove_monitor_chunk(MonitorChunk* chunk);\n-  bool in_deopt_handler() const                  { return _in_deopt_handler > 0; }\n-  void inc_in_deopt_handler()                    { _in_deopt_handler++; }\n-  void dec_in_deopt_handler() {\n-    assert(_in_deopt_handler > 0, \"mismatched deopt nesting\");\n-    if (_in_deopt_handler > 0) { \/\/ robustness\n-      _in_deopt_handler--;\n-    }\n-  }\n-\n- private:\n-  void set_entry_point(ThreadFunction entry_point) { _entry_point = entry_point; }\n-\n-  \/\/ factor out low-level mechanics for use in both normal and error cases\n-  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n-\n- public:\n-\n-  \/\/ Frame iteration; calls the function f for all frames on the stack\n-  void frames_do(void f(frame*, const RegisterMap*));\n-\n-  \/\/ Memory operations\n-  void oops_do_frames(OopClosure* f, CodeBlobClosure* cf);\n-  void oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf);\n-\n-  \/\/ Sweeper operations\n-  virtual void nmethods_do(CodeBlobClosure* cf);\n-\n-  \/\/ RedefineClasses Support\n-  void metadata_do(MetadataClosure* f);\n-\n-  \/\/ Debug method asserting thread states are correct during a handshake operation.\n-  DEBUG_ONLY(void verify_states_for_handshake();)\n-\n-  \/\/ Misc. operations\n-  const char* name() const;\n-  const char* type_name() const { return \"JavaThread\"; }\n-  static const char* name_for(oop thread_obj);\n-\n-  void print_on(outputStream* st, bool print_extended_info) const;\n-  void print_on(outputStream* st) const { print_on(st, false); }\n-  void print() const;\n-  void print_thread_state_on(outputStream*) const;\n-  const char* thread_state_name() const;\n-  void print_on_error(outputStream* st, char* buf, int buflen) const;\n-  void print_name_on_error(outputStream* st, char* buf, int buflen) const;\n-  void verify();\n-\n-  \/\/ Accessing frames\n-  frame last_frame() {\n-    _anchor.make_walkable();\n-    return pd_last_frame();\n-  }\n-  javaVFrame* last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(last_frame(), reg_map); }\n-\n-  frame carrier_last_frame(RegisterMap* reg_map);\n-  javaVFrame* carrier_last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(carrier_last_frame(reg_map), reg_map); }\n-\n-  frame vthread_last_frame();\n-  javaVFrame* vthread_last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(vthread_last_frame(), reg_map); }\n-\n-  frame platform_thread_last_frame(RegisterMap* reg_map);\n-  javaVFrame*  platform_thread_last_java_vframe(RegisterMap* reg_map) {\n-    return last_java_vframe(platform_thread_last_frame(reg_map), reg_map);\n-  }\n-\n-  javaVFrame* last_java_vframe(const frame f, RegisterMap* reg_map);\n-\n-  \/\/ Returns method at 'depth' java or native frames down the stack\n-  \/\/ Used for security checks\n-  Klass* security_get_caller_class(int depth);\n-\n-  \/\/ Print stack trace in external format\n-  void print_stack_on(outputStream* st);\n-  void print_stack() { print_stack_on(tty); }\n-\n-  \/\/ Print stack traces in various internal formats\n-  void trace_stack()                             PRODUCT_RETURN;\n-  void trace_stack_from(vframe* start_vf)        PRODUCT_RETURN;\n-  void trace_frames()                            PRODUCT_RETURN;\n-\n-  \/\/ Print an annotated view of the stack frames\n-  void print_frame_layout(int depth = 0, bool validate_only = false) NOT_DEBUG_RETURN;\n-  void validate_frame_layout() {\n-    print_frame_layout(0, true);\n-  }\n-\n-  \/\/ Function for testing deoptimization\n-  void deoptimize();\n-  void make_zombies();\n-\n-  void deoptimize_marked_methods();\n-\n- public:\n-  \/\/ Returns the running thread as a JavaThread\n-  static JavaThread* current() {\n-    return JavaThread::cast(Thread::current());\n-  }\n-\n-  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n-  static inline JavaThread* current_or_null();\n-\n-  \/\/ Casts\n-  static JavaThread* cast(Thread* t) {\n-    assert(t->is_Java_thread(), \"incorrect cast to JavaThread\");\n-    return static_cast<JavaThread*>(t);\n-  }\n-\n-  static const JavaThread* cast(const Thread* t) {\n-    assert(t->is_Java_thread(), \"incorrect cast to const JavaThread\");\n-    return static_cast<const JavaThread*>(t);\n-  }\n-\n-  \/\/ Returns the active Java thread.  Do not use this if you know you are calling\n-  \/\/ from a JavaThread, as it's slower than JavaThread::current.  If called from\n-  \/\/ the VMThread, it also returns the JavaThread that instigated the VMThread's\n-  \/\/ operation.  You may not want that either.\n-  static JavaThread* active();\n-\n- protected:\n-  virtual void pre_run();\n-  virtual void run();\n-  void thread_main_inner();\n-  virtual void post_run();\n-\n- public:\n-  \/\/ Thread local information maintained by JVMTI.\n-  void set_jvmti_thread_state(JvmtiThreadState *value)                           { _jvmti_thread_state = value; }\n-  \/\/ A JvmtiThreadState is lazily allocated. This jvmti_thread_state()\n-  \/\/ getter is used to get this JavaThread's JvmtiThreadState if it has\n-  \/\/ one which means NULL can be returned. JvmtiThreadState::state_for()\n-  \/\/ is used to get the specified JavaThread's JvmtiThreadState if it has\n-  \/\/ one or it allocates a new JvmtiThreadState for the JavaThread and\n-  \/\/ returns it. JvmtiThreadState::state_for() will return NULL only if\n-  \/\/ the specified JavaThread is exiting.\n-  JvmtiThreadState *jvmti_thread_state() const                                   { return _jvmti_thread_state; }\n-  static ByteSize jvmti_thread_state_offset()                                    { return byte_offset_of(JavaThread, _jvmti_thread_state); }\n-\n-#if INCLUDE_JVMTI\n-  \/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n-  JvmtiThreadState *rebind_to_jvmti_thread_state_of(oop thread_oop);\n-#endif\n-\n-  \/\/ JVMTI PopFrame support\n-  \/\/ Setting and clearing popframe_condition\n-  \/\/ All of these enumerated values are bits. popframe_pending\n-  \/\/ indicates that a PopFrame() has been requested and not yet been\n-  \/\/ completed. popframe_processing indicates that that PopFrame() is in\n-  \/\/ the process of being completed. popframe_force_deopt_reexecution_bit\n-  \/\/ indicates that special handling is required when returning to a\n-  \/\/ deoptimized caller.\n-  enum PopCondition {\n-    popframe_inactive                      = 0x00,\n-    popframe_pending_bit                   = 0x01,\n-    popframe_processing_bit                = 0x02,\n-    popframe_force_deopt_reexecution_bit   = 0x04\n-  };\n-  PopCondition popframe_condition()                   { return (PopCondition) _popframe_condition; }\n-  void set_popframe_condition(PopCondition c)         { _popframe_condition = c; }\n-  void set_popframe_condition_bit(PopCondition c)     { _popframe_condition |= c; }\n-  void clear_popframe_condition()                     { _popframe_condition = popframe_inactive; }\n-  static ByteSize popframe_condition_offset()         { return byte_offset_of(JavaThread, _popframe_condition); }\n-  bool has_pending_popframe()                         { return (popframe_condition() & popframe_pending_bit) != 0; }\n-  bool popframe_forcing_deopt_reexecution()           { return (popframe_condition() & popframe_force_deopt_reexecution_bit) != 0; }\n-  void clear_popframe_forcing_deopt_reexecution()     { _popframe_condition &= ~popframe_force_deopt_reexecution_bit; }\n-\n-  bool pop_frame_in_process(void)                     { return ((_popframe_condition & popframe_processing_bit) != 0); }\n-  void set_pop_frame_in_process(void)                 { _popframe_condition |= popframe_processing_bit; }\n-  void clr_pop_frame_in_process(void)                 { _popframe_condition &= ~popframe_processing_bit; }\n-\n-  int frames_to_pop_failed_realloc() const            { return _frames_to_pop_failed_realloc; }\n-  void set_frames_to_pop_failed_realloc(int nb)       { _frames_to_pop_failed_realloc = nb; }\n-  void dec_frames_to_pop_failed_realloc()             { _frames_to_pop_failed_realloc--; }\n-\n- private:\n-  \/\/ Saved incoming arguments to popped frame.\n-  \/\/ Used only when popped interpreted frame returns to deoptimized frame.\n-  void*    _popframe_preserved_args;\n-  int      _popframe_preserved_args_size;\n-\n- public:\n-  void  popframe_preserve_args(ByteSize size_in_bytes, void* start);\n-  void* popframe_preserved_args();\n-  ByteSize popframe_preserved_args_size();\n-  WordSize popframe_preserved_args_size_in_words();\n-  void  popframe_free_preserved_args();\n-\n-\n- private:\n-  JvmtiThreadState *_jvmti_thread_state;\n-\n-  \/\/ Used by the interpreter in fullspeed mode for frame pop, method\n-  \/\/ entry, method exit and single stepping support. This field is\n-  \/\/ only set to non-zero at a safepoint or using a direct handshake\n-  \/\/ (see EnterInterpOnlyModeClosure).\n-  \/\/ It can be set to zero asynchronously to this threads execution (i.e., without\n-  \/\/ safepoint\/handshake or a lock) so we have to be very careful.\n-  \/\/ Accesses by other threads are synchronized using JvmtiThreadState_lock though.\n-  int               _interp_only_mode;\n-\n- public:\n-  \/\/ used by the interpreter for fullspeed debugging support (see above)\n-  static ByteSize interp_only_mode_offset() { return byte_offset_of(JavaThread, _interp_only_mode); }\n-  bool is_interp_only_mode()                { return (_interp_only_mode != 0); }\n-  int get_interp_only_mode()                { return _interp_only_mode; }\n-  int set_interp_only_mode(int val)         { return _interp_only_mode = val; }\n-  void increment_interp_only_mode()         { ++_interp_only_mode; }\n-  void decrement_interp_only_mode()         { --_interp_only_mode; }\n-\n-  \/\/ support for cached flag that indicates whether exceptions need to be posted for this thread\n-  \/\/ if this is false, we can avoid deoptimizing when events are thrown\n-  \/\/ this gets set to reflect whether jvmtiExport::post_exception_throw would actually do anything\n- private:\n-  int    _should_post_on_exceptions_flag;\n-\n- public:\n-  int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }\n-  void  set_should_post_on_exceptions_flag(int val)  { _should_post_on_exceptions_flag = val; }\n-\n- private:\n-  ThreadStatistics *_thread_stat;\n-\n- public:\n-  ThreadStatistics* get_thread_stat() const    { return _thread_stat; }\n-\n-  \/\/ Return a blocker object for which this thread is blocked parking.\n-  oop current_park_blocker();\n-\n- private:\n-  static size_t _stack_size_at_create;\n-\n- public:\n-  static inline size_t stack_size_at_create(void) {\n-    return _stack_size_at_create;\n-  }\n-  static inline void set_stack_size_at_create(size_t value) {\n-    _stack_size_at_create = value;\n-  }\n-\n-  \/\/ Machine dependent stuff\n-#include OS_CPU_HEADER(thread)\n-\n-  \/\/ JSR166 per-thread parker\n- private:\n-  Parker _parker;\n- public:\n-  Parker* parker() { return &_parker; }\n-\n- public:\n-  \/\/ clearing\/querying jni attach status\n-  bool is_attaching_via_jni() const { return _jni_attach_state == _attaching_via_jni; }\n-  bool has_attached_via_jni() const { return is_attaching_via_jni() || _jni_attach_state == _attached_via_jni; }\n-  inline void set_done_attaching_via_jni();\n-\n-  \/\/ Stack dump assistance:\n-  \/\/ Track the class we want to initialize but for which we have to wait\n-  \/\/ on its init_lock() because it is already being initialized.\n-  void set_class_to_be_initialized(InstanceKlass* k);\n-  InstanceKlass* class_to_be_initialized() const;\n-\n-private:\n-  InstanceKlass* _class_to_be_initialized;\n-\n-  \/\/ java.lang.Thread.sleep support\n-  ParkEvent * _SleepEvent;\n-public:\n-  bool sleep(jlong millis);\n-\n-  \/\/ java.lang.Thread interruption support\n-  void interrupt();\n-  bool is_interrupted(bool clear_interrupted);\n-\n-  static OopStorage* thread_oop_storage();\n-\n-  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n-\n-  \/\/ Helper function to create the java.lang.Thread object for a\n-  \/\/ VM-internal thread. The thread will have the given name, be\n-  \/\/ part of the System ThreadGroup and if is_visible is true will be\n-  \/\/ discoverable via the system ThreadGroup.\n-  static Handle create_system_thread_object(const char* name, bool is_visible, TRAPS);\n-\n-  \/\/ Helper function to start a VM-internal daemon thread.\n-  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n-  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n-                                    Handle thread_oop, ThreadPriority prio);\n-\n-  \/\/ Helper function to do vm_exit_on_initialization for osthread\n-  \/\/ resource allocation failure.\n-  static void vm_exit_on_osthread_failure(JavaThread* thread);\n-\n-  \/\/ AsyncGetCallTrace support\n-  inline bool in_asgct(void) {return _in_asgct;}\n-  inline void set_in_asgct(bool value) {_in_asgct = value;}\n-};\n-\n-inline JavaThread* JavaThread::current_or_null() {\n-  Thread* current = Thread::current_or_null();\n-  return current != nullptr ? JavaThread::cast(current) : nullptr;\n-}\n-\n-\/\/ The active thread queue. It also keeps track of the current used\n-\/\/ thread priorities.\n-class Threads: AllStatic {\n-  friend class VMStructs;\n- private:\n-  static int         _number_of_threads;\n-  static int         _number_of_non_daemon_threads;\n-  static int         _return_code;\n-  static uintx       _thread_claim_token;\n-#ifdef ASSERT\n-  static bool        _vm_complete;\n-#endif\n-\n-  static void initialize_java_lang_classes(JavaThread* main_thread, TRAPS);\n-  static void initialize_jsr292_core_classes(TRAPS);\n-\n- public:\n-  \/\/ Thread management\n-  \/\/ force_daemon is a concession to JNI, where we may need to add a\n-  \/\/ thread to the thread list before allocating its thread object\n-  static void add(JavaThread* p, bool force_daemon = false);\n-  static void remove(JavaThread* p, bool is_daemon);\n-  static void non_java_threads_do(ThreadClosure* tc);\n-  static void java_threads_do(ThreadClosure* tc);\n-  static void java_threads_and_vm_thread_do(ThreadClosure* tc);\n-  static void threads_do(ThreadClosure* tc);\n-  static void possibly_parallel_threads_do(bool is_par, ThreadClosure* tc);\n-\n-  \/\/ Initializes the vm and creates the vm thread\n-  static jint create_vm(JavaVMInitArgs* args, bool* canTryAgain);\n-  static void convert_vm_init_libraries_to_agents();\n-  static void create_vm_init_libraries();\n-  static void create_vm_init_agents();\n-  static void shutdown_vm_agents();\n-  static void destroy_vm();\n-  \/\/ Supported VM versions via JNI\n-  \/\/ Includes JNI_VERSION_1_1\n-  static jboolean is_supported_jni_version_including_1_1(jint version);\n-  \/\/ Does not include JNI_VERSION_1_1\n-  static jboolean is_supported_jni_version(jint version);\n-\n-  \/\/ The \"thread claim token\" provides a way for threads to be claimed\n-  \/\/ by parallel worker tasks.\n-  \/\/\n-  \/\/ Each thread contains a \"token\" field. A task will claim the\n-  \/\/ thread only if its token is different from the global token,\n-  \/\/ which is updated by calling change_thread_claim_token().  When\n-  \/\/ a thread is claimed, it's token is set to the global token value\n-  \/\/ so other threads in the same iteration pass won't claim it.\n-  \/\/\n-  \/\/ For this to work change_thread_claim_token() needs to be called\n-  \/\/ exactly once in sequential code before starting parallel tasks\n-  \/\/ that should claim threads.\n-  \/\/\n-  \/\/ New threads get their token set to 0 and change_thread_claim_token()\n-  \/\/ never sets the global token to 0.\n-  static uintx thread_claim_token() { return _thread_claim_token; }\n-  static void change_thread_claim_token();\n-  static void assert_all_threads_claimed() NOT_DEBUG_RETURN;\n-\n-  \/\/ Apply \"f->do_oop\" to all root oops in all threads.\n-  \/\/ This version may only be called by sequential code.\n-  static void oops_do(OopClosure* f, CodeBlobClosure* cf);\n-  \/\/ This version may be called by sequential or parallel code.\n-  static void possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf);\n-\n-  \/\/ RedefineClasses support\n-  static void metadata_do(MetadataClosure* f);\n-  static void metadata_handles_do(void f(Metadata*));\n-\n-#ifdef ASSERT\n-  static bool is_vm_complete() { return _vm_complete; }\n-#endif \/\/ ASSERT\n-\n-  \/\/ Verification\n-  static void verify();\n-  static void print_on(outputStream* st, bool print_stacks, bool internal_format, bool print_concurrent_locks, bool print_extended_info);\n-  static void print(bool print_stacks, bool internal_format) {\n-    \/\/ this function is only used by debug.cpp\n-    print_on(tty, print_stacks, internal_format, false \/* no concurrent lock printed *\/, false \/* simple format *\/);\n-  }\n-  static void print_on_error(outputStream* st, Thread* current, char* buf, int buflen);\n-  static void print_on_error(Thread* this_thread, outputStream* st, Thread* current, char* buf,\n-                             int buflen, bool* found_current);\n-  static void print_threads_compiling(outputStream* st, char* buf, int buflen, bool short_form = false);\n-\n-  \/\/ Get Java threads that are waiting to enter a monitor.\n-  static GrowableArray<JavaThread*>* get_pending_threads(ThreadsList * t_list,\n-                                                         int count, address monitor);\n-\n-  \/\/ Get owning Java thread from the monitor's owner field.\n-  static JavaThread *owning_thread_from_monitor_owner(ThreadsList * t_list,\n-                                                      address owner);\n-\n-  \/\/ Number of threads on the active threads list\n-  static int number_of_threads()                 { return _number_of_threads; }\n-  \/\/ Number of non-daemon threads on the active threads list\n-  static int number_of_non_daemon_threads()      { return _number_of_non_daemon_threads; }\n-\n-  \/\/ Deoptimizes all frames tied to marked nmethods\n-  static void deoptimized_wrt_marked_nmethods();\n-\n-  struct Test;                  \/\/ For private gtest access.\n-};\n-\n-class UnlockFlagSaver {\n-  private:\n-    JavaThread* _thread;\n-    bool _do_not_unlock;\n-  public:\n-    UnlockFlagSaver(JavaThread* t) {\n-      _thread = t;\n-      _do_not_unlock = t->do_not_unlock_if_synchronized();\n-      t->set_do_not_unlock_if_synchronized(false);\n-    }\n-    ~UnlockFlagSaver() {\n-      _thread->set_do_not_unlock_if_synchronized(_do_not_unlock);\n-    }\n-};\n-\n-class JNIHandleMark : public StackObj {\n-  JavaThread* _thread;\n- public:\n-  JNIHandleMark(JavaThread* thread) : _thread(thread) {\n-    thread->push_jni_handle_block();\n-  }\n-  ~JNIHandleMark() { _thread->pop_jni_handle_block(); }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":12,"deletions":1251,"binary":false,"changes":1263,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n@@ -33,3 +32,0 @@\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oopHandle.inline.hpp\"\n@@ -37,5 +33,0 @@\n-#include \"runtime\/continuation.hpp\"\n-#include \"runtime\/continuationEntry.inline.hpp\"\n-#include \"runtime\/nonJavaThread.hpp\"\n-#include \"runtime\/orderAccess.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n@@ -103,190 +94,0 @@\n-inline void JavaThread::set_suspend_flag(SuspendFlags f) {\n-  uint32_t flags;\n-  do {\n-    flags = _suspend_flags;\n-  }\n-  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags | f)) != flags);\n-}\n-inline void JavaThread::clear_suspend_flag(SuspendFlags f) {\n-  uint32_t flags;\n-  do {\n-    flags = _suspend_flags;\n-  }\n-  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags & ~f)) != flags);\n-}\n-\n-inline void JavaThread::set_trace_flag() {\n-  set_suspend_flag(_trace_flag);\n-}\n-inline void JavaThread::clear_trace_flag() {\n-  clear_suspend_flag(_trace_flag);\n-}\n-inline void JavaThread::set_obj_deopt_flag() {\n-  set_suspend_flag(_obj_deopt);\n-}\n-inline void JavaThread::clear_obj_deopt_flag() {\n-  clear_suspend_flag(_obj_deopt);\n-}\n-\n-#if INCLUDE_JVMTI\n-inline void JavaThread::set_carrier_thread_suspended() {\n-  _carrier_thread_suspended = true;\n-}\n-inline void JavaThread::clear_carrier_thread_suspended() {\n-  _carrier_thread_suspended = false;\n-}\n-#endif\n-\n-class AsyncExceptionHandshake : public AsyncHandshakeClosure {\n-  OopHandle _exception;\n-  bool _is_ThreadDeath;\n- public:\n-  AsyncExceptionHandshake(OopHandle& o, const char* name = \"AsyncExceptionHandshake\")\n-  : AsyncHandshakeClosure(name), _exception(o) {\n-    _is_ThreadDeath = exception()->is_a(vmClasses::ThreadDeath_klass());\n-  }\n-\n-  ~AsyncExceptionHandshake() {\n-    assert(!_exception.is_empty(), \"invariant\");\n-    _exception.release(Universe::vm_global());\n-  }\n-\n-  void do_thread(Thread* thr) {\n-    JavaThread* self = JavaThread::cast(thr);\n-    assert(self == JavaThread::current(), \"must be\");\n-\n-    self->handle_async_exception(exception());\n-  }\n-  oop exception() {\n-    assert(!_exception.is_empty(), \"invariant\");\n-    return _exception.resolve();\n-  }\n-  bool is_async_exception()   { return true; }\n-  bool is_ThreadDeath()       { return _is_ThreadDeath; }\n-};\n-\n-class UnsafeAccessErrorHandshake : public AsyncHandshakeClosure {\n- public:\n-  UnsafeAccessErrorHandshake() : AsyncHandshakeClosure(\"UnsafeAccessErrorHandshake\") {}\n-  void do_thread(Thread* thr) {\n-    JavaThread* self = JavaThread::cast(thr);\n-    assert(self == JavaThread::current(), \"must be\");\n-\n-    self->handshake_state()->handle_unsafe_access_error();\n-  }\n-  bool is_async_exception()   { return true; }\n-};\n-\n-inline void JavaThread::set_pending_unsafe_access_error() {\n-  if (!has_async_exception_condition()) {\n-    Handshake::execute(new UnsafeAccessErrorHandshake(), this);\n-  }\n-}\n-\n-inline bool JavaThread::has_async_exception_condition(bool ThreadDeath_only) {\n-  return handshake_state()->has_async_exception_operation(ThreadDeath_only);\n-}\n-\n-inline JavaThread::NoAsyncExceptionDeliveryMark::NoAsyncExceptionDeliveryMark(JavaThread *t) : _target(t) {\n-  assert(!_target->handshake_state()->async_exceptions_blocked(), \"Nesting is not supported\");\n-  _target->handshake_state()->set_async_exceptions_blocked(true);\n-}\n-inline JavaThread::NoAsyncExceptionDeliveryMark::~NoAsyncExceptionDeliveryMark() {\n-  _target->handshake_state()->set_async_exceptions_blocked(false);\n-}\n-\n-inline JavaThreadState JavaThread::thread_state() const    {\n-#if defined(PPC64) || defined (AARCH64) || defined(RISCV64)\n-  \/\/ Use membars when accessing volatile _thread_state. See\n-  \/\/ Threads::create_vm() for size checks.\n-  return (JavaThreadState) Atomic::load_acquire((volatile jint*)&_thread_state);\n-#else\n-  return _thread_state;\n-#endif\n-}\n-\n-inline void JavaThread::set_thread_state(JavaThreadState s) {\n-  assert(current_or_null() == NULL || current_or_null() == this,\n-         \"state change should only be called by the current thread\");\n-#if defined(PPC64) || defined (AARCH64) || defined(RISCV64)\n-  \/\/ Use membars when accessing volatile _thread_state. See\n-  \/\/ Threads::create_vm() for size checks.\n-  Atomic::release_store((volatile jint*)&_thread_state, (jint)s);\n-#else\n-  _thread_state = s;\n-#endif\n-}\n-\n-inline void JavaThread::set_thread_state_fence(JavaThreadState s) {\n-  set_thread_state(s);\n-  OrderAccess::fence();\n-}\n-\n-ThreadSafepointState* JavaThread::safepoint_state() const  {\n-  return _safepoint_state;\n-}\n-\n-void JavaThread::set_safepoint_state(ThreadSafepointState *state) {\n-  _safepoint_state = state;\n-}\n-\n-bool JavaThread::is_at_poll_safepoint() {\n-  return _safepoint_state->is_at_poll_safepoint();\n-}\n-\n-bool JavaThread::is_vthread_mounted() const {\n-  return vthread_continuation() != nullptr;\n-}\n-\n-const ContinuationEntry* JavaThread::vthread_continuation() const {\n-  for (ContinuationEntry* c = last_continuation(); c != nullptr; c = c->parent()) {\n-    if (c->is_virtual_thread())\n-      return c;\n-  }\n-  return nullptr;\n-}\n-\n-void JavaThread::enter_critical() {\n-  assert(Thread::current() == this ||\n-         (Thread::current()->is_VM_thread() &&\n-         SafepointSynchronize::is_synchronizing()),\n-         \"this must be current thread or synchronizing\");\n-  _jni_active_critical++;\n-}\n-\n-inline void JavaThread::set_done_attaching_via_jni() {\n-  _jni_attach_state = _attached_via_jni;\n-  OrderAccess::fence();\n-}\n-\n-inline bool JavaThread::is_exiting() const {\n-  \/\/ Use load-acquire so that setting of _terminated by\n-  \/\/ JavaThread::exit() is seen more quickly.\n-  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n-  return l_terminated == _thread_exiting || check_is_terminated(l_terminated);\n-}\n-\n-inline bool JavaThread::is_terminated() const {\n-  \/\/ Use load-acquire so that setting of _terminated by\n-  \/\/ JavaThread::exit() is seen more quickly.\n-  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n-  return check_is_terminated(l_terminated);\n-}\n-\n-inline void JavaThread::set_terminated(TerminatedTypes t) {\n-  \/\/ use release-store so the setting of _terminated is seen more quickly\n-  Atomic::release_store(&_terminated, t);\n-}\n-\n-\/\/ Allow tracking of class initialization monitor use\n-inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {\n-  assert((k == NULL && _class_to_be_initialized != NULL) ||\n-         (k != NULL && _class_to_be_initialized == NULL), \"incorrect usage\");\n-  assert(this == Thread::current(), \"Only the current thread can set this field\");\n-  _class_to_be_initialized = k;\n-}\n-\n-inline InstanceKlass* JavaThread::class_to_be_initialized() const {\n-  return _class_to_be_initialized;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":1,"deletions":200,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1545 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaThreadStatus.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/jniPeriodicChecker.hpp\"\n+#include \"runtime\/monitorDeflationThread.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/statSampler.hpp\"\n+#include \"runtime\/stubCodeGenerator.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#include \"services\/management.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/threadService.hpp\"\n+#include \"utilities\/dtrace.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/idealGraphPrinter.hpp\"\n+#endif\n+#if INCLUDE_RTM_OPT\n+#include \"runtime\/rtmLocking.hpp\"\n+#endif\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n+\/\/ Initialization after module runtime initialization\n+void universe_post_module_init();  \/\/ must happen after call_initPhase2\n+\n+\n+static void initialize_class(Symbol* class_name, TRAPS) {\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name, true, CHECK);\n+  InstanceKlass::cast(klass)->initialize(CHECK);\n+}\n+\n+\n+\/\/ Creates the initial ThreadGroup\n+static Handle create_initial_thread_group(TRAPS) {\n+  Handle system_instance = JavaCalls::construct_new_instance(\n+                            vmClasses::ThreadGroup_klass(),\n+                            vmSymbols::void_method_signature(),\n+                            CHECK_NH);\n+  Universe::set_system_thread_group(system_instance());\n+\n+  Handle string = java_lang_String::create_from_str(\"main\", CHECK_NH);\n+  Handle main_instance = JavaCalls::construct_new_instance(\n+                            vmClasses::ThreadGroup_klass(),\n+                            vmSymbols::threadgroup_string_void_signature(),\n+                            system_instance,\n+                            string,\n+                            CHECK_NH);\n+  return main_instance;\n+}\n+\n+\/\/ Creates the initial Thread, and sets it to running.\n+static void create_initial_thread(Handle thread_group, JavaThread* thread,\n+                                 TRAPS) {\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n+  assert(ik->is_initialized(), \"must be\");\n+  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n+\n+  \/\/ Cannot use JavaCalls::construct_new_instance because the java.lang.Thread\n+  \/\/ constructor calls Thread.current(), which must be set here for the\n+  \/\/ initial thread.\n+  java_lang_Thread::set_thread(thread_oop(), thread);\n+  thread->set_threadOopHandles(thread_oop());\n+\n+  Handle string = java_lang_String::create_from_str(\"main\", CHECK);\n+\n+  JavaValue result(T_VOID);\n+  JavaCalls::call_special(&result, thread_oop,\n+                          ik,\n+                          vmSymbols::object_initializer_name(),\n+                          vmSymbols::threadgroup_string_void_signature(),\n+                          thread_group,\n+                          string,\n+                          CHECK);\n+\n+  \/\/ Set thread status to running since main thread has\n+  \/\/ been started and running.\n+  java_lang_Thread::set_thread_status(thread_oop(),\n+                                      JavaThreadStatus::RUNNABLE);\n+}\n+\n+\/\/ Extract version and vendor specific information from\n+\/\/ java.lang.VersionProps fields.\n+\/\/ Returned char* is allocated in the thread's resource area\n+\/\/ so must be copied for permanency.\n+static const char* get_java_version_info(InstanceKlass* ik,\n+                                         Symbol* field_name) {\n+  fieldDescriptor fd;\n+  bool found = ik != NULL &&\n+               ik->find_local_field(field_name,\n+                                    vmSymbols::string_signature(), &fd);\n+  if (found) {\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n+    if (name_oop == NULL) {\n+      return NULL;\n+    }\n+    const char* name = java_lang_String::as_utf8_string(name_oop);\n+    return name;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+\/\/ ======= Threads ========\n+\n+\/\/ The Threads class links together all active threads, and provides\n+\/\/ operations over all threads. It is protected by the Threads_lock,\n+\/\/ which is also used in other global contexts like safepointing.\n+\/\/ ThreadsListHandles are used to safely perform operations on one\n+\/\/ or more threads without the risk of the thread exiting during the\n+\/\/ operation.\n+\/\/\n+\/\/ Note: The Threads_lock is currently more widely used than we\n+\/\/ would like. We are actively migrating Threads_lock uses to other\n+\/\/ mechanisms in order to reduce Threads_lock contention.\n+\n+int         Threads::_number_of_threads = 0;\n+int         Threads::_number_of_non_daemon_threads = 0;\n+int         Threads::_return_code = 0;\n+uintx       Threads::_thread_claim_token = 1; \/\/ Never zero.\n+\n+#ifdef ASSERT\n+bool        Threads::_vm_complete = false;\n+#endif\n+\n+\/\/ General purpose hook into Java code, run once when the VM is initialized.\n+\/\/ The Java library method itself may be changed independently from the VM.\n+static void call_postVMInitHook(TRAPS) {\n+  Klass* klass = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_PostVMInitHook(), THREAD);\n+  if (klass != NULL) {\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result, klass, vmSymbols::run_method_name(),\n+                           vmSymbols::void_method_signature(),\n+                           CHECK);\n+  }\n+}\n+\n+\/\/ All NonJavaThreads (i.e., every non-JavaThread in the system).\n+void Threads::non_java_threads_do(ThreadClosure* tc) {\n+  NoSafepointVerifier nsv;\n+  for (NonJavaThread::Iterator njti; !njti.end(); njti.step()) {\n+    tc->do_thread(njti.current());\n+  }\n+}\n+\n+\/\/ All JavaThreads\n+#define ALL_JAVA_THREADS(X) \\\n+  for (JavaThread* X : *ThreadsSMRSupport::get_java_thread_list())\n+\n+\/\/ All JavaThreads\n+void Threads::java_threads_do(ThreadClosure* tc) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  \/\/ ALL_JAVA_THREADS iterates through all JavaThreads.\n+  ALL_JAVA_THREADS(p) {\n+    tc->do_thread(p);\n+  }\n+}\n+\n+void Threads::java_threads_and_vm_thread_do(ThreadClosure* tc) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  java_threads_do(tc);\n+  tc->do_thread(VMThread::vm_thread());\n+}\n+\n+\/\/ All JavaThreads + all non-JavaThreads (i.e., every thread in the system).\n+void Threads::threads_do(ThreadClosure* tc) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  java_threads_do(tc);\n+  non_java_threads_do(tc);\n+}\n+\n+void Threads::possibly_parallel_threads_do(bool is_par, ThreadClosure* tc) {\n+  uintx claim_token = Threads::thread_claim_token();\n+  ALL_JAVA_THREADS(p) {\n+    if (p->claim_threads_do(is_par, claim_token)) {\n+      tc->do_thread(p);\n+    }\n+  }\n+  VMThread* vmt = VMThread::vm_thread();\n+  if (vmt->claim_threads_do(is_par, claim_token)) {\n+    tc->do_thread(vmt);\n+  }\n+}\n+\n+\/\/ The system initialization in the library has three phases.\n+\/\/\n+\/\/ Phase 1: java.lang.System class initialization\n+\/\/     java.lang.System is a primordial class loaded and initialized\n+\/\/     by the VM early during startup.  java.lang.System.<clinit>\n+\/\/     only does registerNatives and keeps the rest of the class\n+\/\/     initialization work later until thread initialization completes.\n+\/\/\n+\/\/     System.initPhase1 initializes the system properties, the static\n+\/\/     fields in, out, and err. Set up java signal handlers, OS-specific\n+\/\/     system settings, and thread group of the main thread.\n+static void call_initPhase1(TRAPS) {\n+  Klass* klass = vmClasses::System_klass();\n+  JavaValue result(T_VOID);\n+  JavaCalls::call_static(&result, klass, vmSymbols::initPhase1_name(),\n+                                         vmSymbols::void_method_signature(), CHECK);\n+}\n+\n+\/\/ Phase 2. Module system initialization\n+\/\/     This will initialize the module system.  Only java.base classes\n+\/\/     can be loaded until phase 2 completes.\n+\/\/\n+\/\/     Call System.initPhase2 after the compiler initialization and jsr292\n+\/\/     classes get initialized because module initialization runs a lot of java\n+\/\/     code, that for performance reasons, should be compiled.  Also, this will\n+\/\/     enable the startup code to use lambda and other language features in this\n+\/\/     phase and onward.\n+\/\/\n+\/\/     After phase 2, The VM will begin search classes from -Xbootclasspath\/a.\n+static void call_initPhase2(TRAPS) {\n+  TraceTime timer(\"Initialize module system\", TRACETIME_LOG(Info, startuptime));\n+\n+  Klass* klass = vmClasses::System_klass();\n+\n+  JavaValue result(T_INT);\n+  JavaCallArguments args;\n+  args.push_int(DisplayVMOutputToStderr);\n+  args.push_int(log_is_enabled(Debug, init)); \/\/ print stack trace if exception thrown\n+  JavaCalls::call_static(&result, klass, vmSymbols::initPhase2_name(),\n+                                         vmSymbols::boolean_boolean_int_signature(), &args, CHECK);\n+  if (result.get_jint() != JNI_OK) {\n+    vm_exit_during_initialization(); \/\/ no message or exception\n+  }\n+\n+  universe_post_module_init();\n+}\n+\n+\/\/ Phase 3. final setup - set security manager, system class loader and TCCL\n+\/\/\n+\/\/     This will instantiate and set the security manager, set the system class\n+\/\/     loader as well as the thread context class loader.  The security manager\n+\/\/     and system class loader may be a custom class loaded from -Xbootclasspath\/a,\n+\/\/     other modules or the application's classpath.\n+static void call_initPhase3(TRAPS) {\n+  Klass* klass = vmClasses::System_klass();\n+  JavaValue result(T_VOID);\n+  JavaCalls::call_static(&result, klass, vmSymbols::initPhase3_name(),\n+                                         vmSymbols::void_method_signature(), CHECK);\n+}\n+\n+void Threads::initialize_java_lang_classes(JavaThread* main_thread, TRAPS) {\n+  TraceTime timer(\"Initialize java.lang classes\", TRACETIME_LOG(Info, startuptime));\n+\n+  if (EagerXrunInit && Arguments::init_libraries_at_startup()) {\n+    create_vm_init_libraries();\n+  }\n+\n+  initialize_class(vmSymbols::java_lang_String(), CHECK);\n+\n+  \/\/ Inject CompactStrings value after the static initializers for String ran.\n+  java_lang_String::set_compact_strings(CompactStrings);\n+\n+  \/\/ Initialize java_lang.System (needed before creating the thread)\n+  initialize_class(vmSymbols::java_lang_System(), CHECK);\n+  \/\/ The VM creates & returns objects of this class. Make sure it's initialized.\n+  initialize_class(vmSymbols::java_lang_Class(), CHECK);\n+  initialize_class(vmSymbols::java_lang_ThreadGroup(), CHECK);\n+  Handle thread_group = create_initial_thread_group(CHECK);\n+  Universe::set_main_thread_group(thread_group());\n+  initialize_class(vmSymbols::java_lang_Thread(), CHECK);\n+  create_initial_thread(thread_group, main_thread, CHECK);\n+\n+  \/\/ The VM creates objects of this class.\n+  initialize_class(vmSymbols::java_lang_Module(), CHECK);\n+\n+#ifdef ASSERT\n+  InstanceKlass *k = vmClasses::UnsafeConstants_klass();\n+  assert(k->is_not_initialized(), \"UnsafeConstants should not already be initialized\");\n+#endif\n+\n+  \/\/ initialize the hardware-specific constants needed by Unsafe\n+  initialize_class(vmSymbols::jdk_internal_misc_UnsafeConstants(), CHECK);\n+  jdk_internal_misc_UnsafeConstants::set_unsafe_constants();\n+\n+  \/\/ The VM preresolves methods to these classes. Make sure that they get initialized\n+  initialize_class(vmSymbols::java_lang_reflect_Method(), CHECK);\n+  initialize_class(vmSymbols::java_lang_ref_Finalizer(), CHECK);\n+\n+  \/\/ Phase 1 of the system initialization in the library, java.lang.System class initialization\n+  call_initPhase1(CHECK);\n+\n+  \/\/ Get the Java runtime name, version, and vendor info after java.lang.System is initialized.\n+  \/\/ Some values are actually configure-time constants but some can be set via the jlink tool and\n+  \/\/ so must be read dynamically. We treat them all the same.\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(vmSymbols::java_lang_VersionProps(),\n+                                                            Handle(), Handle());\n+  {\n+    ResourceMark rm(main_thread);\n+    JDK_Version::set_java_version(get_java_version_info(ik, vmSymbols::java_version_name()));\n+\n+    JDK_Version::set_runtime_name(get_java_version_info(ik, vmSymbols::java_runtime_name_name()));\n+\n+    JDK_Version::set_runtime_version(get_java_version_info(ik, vmSymbols::java_runtime_version_name()));\n+\n+    JDK_Version::set_runtime_vendor_version(get_java_version_info(ik, vmSymbols::java_runtime_vendor_version_name()));\n+\n+    JDK_Version::set_runtime_vendor_vm_bug_url(get_java_version_info(ik, vmSymbols::java_runtime_vendor_vm_bug_url_name()));\n+  }\n+\n+  \/\/ an instance of OutOfMemory exception has been allocated earlier\n+  initialize_class(vmSymbols::java_lang_OutOfMemoryError(), CHECK);\n+  initialize_class(vmSymbols::java_lang_NullPointerException(), CHECK);\n+  initialize_class(vmSymbols::java_lang_ClassCastException(), CHECK);\n+  initialize_class(vmSymbols::java_lang_ArrayStoreException(), CHECK);\n+  initialize_class(vmSymbols::java_lang_ArithmeticException(), CHECK);\n+  initialize_class(vmSymbols::java_lang_StackOverflowError(), CHECK);\n+  initialize_class(vmSymbols::java_lang_IllegalMonitorStateException(), CHECK);\n+  initialize_class(vmSymbols::java_lang_IllegalArgumentException(), CHECK);\n+}\n+\n+void Threads::initialize_jsr292_core_classes(TRAPS) {\n+  TraceTime timer(\"Initialize java.lang.invoke classes\", TRACETIME_LOG(Info, startuptime));\n+\n+  initialize_class(vmSymbols::java_lang_invoke_MethodHandle(), CHECK);\n+  initialize_class(vmSymbols::java_lang_invoke_ResolvedMethodName(), CHECK);\n+  initialize_class(vmSymbols::java_lang_invoke_MemberName(), CHECK);\n+  initialize_class(vmSymbols::java_lang_invoke_MethodHandleNatives(), CHECK);\n+}\n+\n+jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {\n+  extern void JDK_Version_init();\n+\n+  \/\/ Preinitialize version info.\n+  VM_Version::early_initialize();\n+\n+  \/\/ Check version\n+  if (!is_supported_jni_version(args->version)) return JNI_EVERSION;\n+\n+  \/\/ Initialize library-based TLS\n+  ThreadLocalStorage::init();\n+\n+  \/\/ Initialize the output stream module\n+  ostream_init();\n+\n+  \/\/ Process java launcher properties.\n+  Arguments::process_sun_java_launcher_properties(args);\n+\n+  \/\/ Initialize the os module\n+  os::init();\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n+  \/\/ Record VM creation timing statistics\n+  TraceVmCreationTime create_vm_timer;\n+  create_vm_timer.start();\n+\n+  \/\/ Initialize system properties.\n+  Arguments::init_system_properties();\n+\n+  \/\/ So that JDK version can be used as a discriminator when parsing arguments\n+  JDK_Version_init();\n+\n+  \/\/ Update\/Initialize System properties after JDK version number is known\n+  Arguments::init_version_specific_system_properties();\n+\n+  \/\/ Make sure to initialize log configuration *before* parsing arguments\n+  LogConfiguration::initialize(create_vm_timer.begin_time());\n+\n+  \/\/ Parse arguments\n+  \/\/ Note: this internally calls os::init_container_support()\n+  jint parse_result = Arguments::parse(args);\n+  if (parse_result != JNI_OK) return parse_result;\n+\n+  \/\/ Initialize NMT right after argument parsing to keep the pre-NMT-init window small.\n+  MemTracker::initialize();\n+\n+  os::init_before_ergo();\n+\n+  jint ergo_result = Arguments::apply_ergo();\n+  if (ergo_result != JNI_OK) return ergo_result;\n+\n+  \/\/ Final check of all ranges after ergonomics which may change values.\n+  if (!JVMFlagLimit::check_all_ranges()) {\n+    return JNI_EINVAL;\n+  }\n+\n+  \/\/ Final check of all 'AfterErgo' constraints after ergonomics which may change values.\n+  bool constraint_result = JVMFlagLimit::check_all_constraints(JVMFlagConstraintPhase::AfterErgo);\n+  if (!constraint_result) {\n+    return JNI_EINVAL;\n+  }\n+\n+  if (PauseAtStartup) {\n+    os::pause();\n+  }\n+\n+  HOTSPOT_VM_INIT_BEGIN();\n+\n+  \/\/ Timing (must come after argument parsing)\n+  TraceTime timer(\"Create VM\", TRACETIME_LOG(Info, startuptime));\n+\n+  \/\/ Initialize the os module after parsing the args\n+  jint os_init_2_result = os::init_2();\n+  if (os_init_2_result != JNI_OK) return os_init_2_result;\n+\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  \/\/ Initialize assert poison page mechanism.\n+  if (ShowRegistersOnAssert) {\n+    initialize_assert_poison();\n+  }\n+#endif \/\/ CAN_SHOW_REGISTERS_ON_ASSERT\n+\n+  SafepointMechanism::initialize();\n+\n+  jint adjust_after_os_result = Arguments::adjust_after_os();\n+  if (adjust_after_os_result != JNI_OK) return adjust_after_os_result;\n+\n+  \/\/ Initialize output stream logging\n+  ostream_init_log();\n+\n+  \/\/ Convert -Xrun to -agentlib: if there is no JVM_OnLoad\n+  \/\/ Must be before create_vm_init_agents()\n+  if (Arguments::init_libraries_at_startup()) {\n+    convert_vm_init_libraries_to_agents();\n+  }\n+\n+  \/\/ Launch -agentlib\/-agentpath and converted -Xrun agents\n+  if (Arguments::init_agents_at_startup()) {\n+    create_vm_init_agents();\n+  }\n+\n+  \/\/ Initialize Threads state\n+  _number_of_threads = 0;\n+  _number_of_non_daemon_threads = 0;\n+\n+  \/\/ Initialize global data structures and create system classes in heap\n+  vm_init_globals();\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtJVMCI);\n+    memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);\n+  } else {\n+    JavaThread::_jvmci_old_thread_counters = NULL;\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  \/\/ Initialize OopStorage for threadObj\n+  JavaThread::_thread_oop_storage = OopStorageSet::create_strong(\"Thread OopStorage\", mtThread);\n+\n+  \/\/ Attach the main thread to this os thread\n+  JavaThread* main_thread = new JavaThread();\n+  main_thread->set_thread_state(_thread_in_vm);\n+  main_thread->initialize_thread_current();\n+  \/\/ must do this before set_active_handles\n+  main_thread->record_stack_base_and_size();\n+  main_thread->register_thread_stack_with_NMT();\n+  main_thread->set_active_handles(JNIHandleBlock::allocate_block());\n+  MACOS_AARCH64_ONLY(main_thread->init_wx());\n+\n+  if (!main_thread->set_as_starting_thread()) {\n+    vm_shutdown_during_initialization(\n+                                      \"Failed necessary internal allocation. Out of swap space\");\n+    main_thread->smr_delete();\n+    *canTryAgain = false; \/\/ don't let caller call JNI_CreateJavaVM again\n+    return JNI_ENOMEM;\n+  }\n+\n+  \/\/ Enable guard page *after* os::create_main_thread(), otherwise it would\n+  \/\/ crash Linux VM, see notes in os_linux.cpp.\n+  main_thread->stack_overflow_state()->create_stack_guard_pages();\n+\n+  \/\/ Initialize Java-Level synchronization subsystem\n+  ObjectMonitor::Initialize();\n+  ObjectSynchronizer::initialize();\n+\n+  \/\/ Initialize global modules\n+  jint status = init_globals();\n+  if (status != JNI_OK) {\n+    main_thread->smr_delete();\n+    *canTryAgain = false; \/\/ don't let caller call JNI_CreateJavaVM again\n+    return status;\n+  }\n+\n+  JFR_ONLY(Jfr::on_create_vm_1();)\n+\n+  \/\/ Should be done after the heap is fully created\n+  main_thread->cache_global_variables();\n+\n+  { MutexLocker mu(Threads_lock);\n+    Threads::add(main_thread);\n+  }\n+\n+  \/\/ Any JVMTI raw monitors entered in onload will transition into\n+  \/\/ real raw monitor. VM is setup enough here for raw monitor enter.\n+  JvmtiExport::transition_pending_onload_raw_monitors();\n+\n+  \/\/ Create the VMThread\n+  { TraceTime timer(\"Start VMThread\", TRACETIME_LOG(Info, startuptime));\n+\n+    VMThread::create();\n+    VMThread* vmthread = VMThread::vm_thread();\n+\n+    if (!os::create_thread(vmthread, os::vm_thread)) {\n+      vm_exit_during_initialization(\"Cannot create VM thread. \"\n+                                    \"Out of system resources.\");\n+    }\n+\n+    \/\/ Wait for the VM thread to become ready, and VMThread::run to initialize\n+    \/\/ Monitors can have spurious returns, must always check another state flag\n+    {\n+      MonitorLocker ml(Notify_lock);\n+      os::start_thread(vmthread);\n+      while (!vmthread->is_running()) {\n+        ml.wait();\n+      }\n+    }\n+  }\n+\n+  assert(Universe::is_fully_initialized(), \"not initialized\");\n+  if (VerifyDuringStartup) {\n+    \/\/ Make sure we're starting with a clean slate.\n+    VM_Verify verify_op;\n+    VMThread::execute(&verify_op);\n+  }\n+\n+  \/\/ We need this to update the java.vm.info property in case any flags used\n+  \/\/ to initially define it have been changed. This is needed for both CDS\n+  \/\/ since UseSharedSpaces may be changed after java.vm.info\n+  \/\/ is initially computed. See Abstract_VM_Version::vm_info_string().\n+  \/\/ This update must happen before we initialize the java classes, but\n+  \/\/ after any initialization logic that might modify the flags.\n+  Arguments::update_vm_info_property(VM_Version::vm_info_string());\n+\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+  HandleMark hm(THREAD);\n+\n+  \/\/ Always call even when there are not JVMTI environments yet, since environments\n+  \/\/ may be attached late and JVMTI must track phases of VM execution\n+  JvmtiExport::enter_early_start_phase();\n+\n+  \/\/ Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.\n+  JvmtiExport::post_early_vm_start();\n+\n+  initialize_java_lang_classes(main_thread, CHECK_JNI_ERR);\n+\n+  quicken_jni_functions();\n+\n+  \/\/ No more stub generation allowed after that point.\n+  StubCodeDesc::freeze();\n+\n+  \/\/ Set flag that basic initialization has completed. Used by exceptions and various\n+  \/\/ debug stuff, that does not work until all basic classes have been initialized.\n+  set_init_completed();\n+\n+  LogConfiguration::post_initialize();\n+  Metaspace::post_initialize();\n+\n+  HOTSPOT_VM_INIT_END();\n+\n+  \/\/ record VM initialization completion time\n+#if INCLUDE_MANAGEMENT\n+  Management::record_vm_init_completed();\n+#endif \/\/ INCLUDE_MANAGEMENT\n+\n+  \/\/ Signal Dispatcher needs to be started before VMInit event is posted\n+  os::initialize_jdk_signal_support(CHECK_JNI_ERR);\n+\n+  \/\/ Start Attach Listener if +StartAttachListener or it can't be started lazily\n+  if (!DisableAttachMechanism) {\n+    AttachListener::vm_start();\n+    if (StartAttachListener || AttachListener::init_at_startup()) {\n+      AttachListener::init();\n+    }\n+  }\n+\n+  \/\/ Launch -Xrun agents\n+  \/\/ Must be done in the JVMTI live phase so that for backward compatibility the JDWP\n+  \/\/ back-end can launch with -Xdebug -Xrunjdwp.\n+  if (!EagerXrunInit && Arguments::init_libraries_at_startup()) {\n+    create_vm_init_libraries();\n+  }\n+\n+  Chunk::start_chunk_pool_cleaner_task();\n+\n+  \/\/ Start the service thread\n+  \/\/ The service thread enqueues JVMTI deferred events and does various hashtable\n+  \/\/ and other cleanups.  Needs to start before the compilers start posting events.\n+  ServiceThread::initialize();\n+\n+  \/\/ Start the monitor deflation thread:\n+  MonitorDeflationThread::initialize();\n+\n+  \/\/ initialize compiler(s)\n+#if defined(COMPILER1) || COMPILER2_OR_JVMCI\n+#if INCLUDE_JVMCI\n+  bool force_JVMCI_intialization = false;\n+  if (EnableJVMCI) {\n+    \/\/ Initialize JVMCI eagerly when it is explicitly requested.\n+    \/\/ Or when JVMCILibDumpJNIConfig or JVMCIPrintProperties is enabled.\n+    force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;\n+\n+    if (!force_JVMCI_intialization) {\n+      \/\/ 8145270: Force initialization of JVMCI runtime otherwise requests for blocking\n+      \/\/ compilations via JVMCI will not actually block until JVMCI is initialized.\n+      force_JVMCI_intialization = UseJVMCICompiler && (!UseInterpreter || !BackgroundCompilation);\n+    }\n+  }\n+#endif\n+  CompileBroker::compilation_init_phase1(CHECK_JNI_ERR);\n+  \/\/ Postpone completion of compiler initialization to after JVMCI\n+  \/\/ is initialized to avoid timeouts of blocking compilations.\n+  if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) {\n+    CompileBroker::compilation_init_phase2();\n+  }\n+#endif\n+\n+  \/\/ Pre-initialize some JSR292 core classes to avoid deadlock during class loading.\n+  \/\/ It is done after compilers are initialized, because otherwise compilations of\n+  \/\/ signature polymorphic MH intrinsics can be missed\n+  \/\/ (see SystemDictionary::find_method_handle_intrinsic).\n+  initialize_jsr292_core_classes(CHECK_JNI_ERR);\n+\n+  \/\/ This will initialize the module system.  Only java.base classes can be\n+  \/\/ loaded until phase 2 completes\n+  call_initPhase2(CHECK_JNI_ERR);\n+\n+  JFR_ONLY(Jfr::on_create_vm_2();)\n+\n+  \/\/ Always call even when there are not JVMTI environments yet, since environments\n+  \/\/ may be attached late and JVMTI must track phases of VM execution\n+  JvmtiExport::enter_start_phase();\n+\n+  \/\/ Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.\n+  JvmtiExport::post_vm_start();\n+\n+  \/\/ Final system initialization including security manager and system class loader\n+  call_initPhase3(CHECK_JNI_ERR);\n+\n+  \/\/ cache the system and platform class loaders\n+  SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);\n+\n+#if INCLUDE_CDS\n+  \/\/ capture the module path info from the ModuleEntryTable\n+  ClassLoader::initialize_module_path(THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n+    vm_exit_during_initialization(\"ClassLoader::initialize_module_path() failed unexpectedly\");\n+  }\n+#endif\n+\n+#if INCLUDE_JVMCI\n+  if (force_JVMCI_intialization) {\n+    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n+    CompileBroker::compilation_init_phase2();\n+  }\n+#endif\n+\n+  \/\/ Always call even when there are not JVMTI environments yet, since environments\n+  \/\/ may be attached late and JVMTI must track phases of VM execution\n+  JvmtiExport::enter_live_phase();\n+\n+  \/\/ Make perfmemory accessible\n+  PerfMemory::set_accessible(true);\n+\n+  \/\/ Notify JVMTI agents that VM initialization is complete - nop if no agents.\n+  JvmtiExport::post_vm_initialized();\n+\n+  JFR_ONLY(Jfr::on_create_vm_3();)\n+\n+#if INCLUDE_MANAGEMENT\n+  Management::initialize(THREAD);\n+\n+  if (HAS_PENDING_EXCEPTION) {\n+    \/\/ management agent fails to start possibly due to\n+    \/\/ configuration problem and is responsible for printing\n+    \/\/ stack trace if appropriate. Simply exit VM.\n+    vm_exit(1);\n+  }\n+#endif \/\/ INCLUDE_MANAGEMENT\n+\n+  StatSampler::engage();\n+  if (CheckJNICalls)                  JniPeriodicChecker::engage();\n+\n+#if INCLUDE_RTM_OPT\n+  RTMLockingCounters::init();\n+#endif\n+\n+  call_postVMInitHook(THREAD);\n+  \/\/ The Java side of PostVMInitHook.run must deal with all\n+  \/\/ exceptions and provide means of diagnosis.\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+  }\n+\n+  {\n+    MutexLocker ml(PeriodicTask_lock);\n+    \/\/ Make sure the WatcherThread can be started by WatcherThread::start()\n+    \/\/ or by dynamic enrollment.\n+    WatcherThread::make_startable();\n+    \/\/ Start up the WatcherThread if there are any periodic tasks\n+    \/\/ NOTE:  All PeriodicTasks should be registered by now. If they\n+    \/\/   aren't, late joiners might appear to start slowly (we might\n+    \/\/   take a while to process their first tick).\n+    if (PeriodicTask::num_tasks() > 0) {\n+      WatcherThread::start();\n+    }\n+  }\n+\n+  create_vm_timer.end();\n+#ifdef ASSERT\n+  _vm_complete = true;\n+#endif\n+\n+  if (DumpSharedSpaces) {\n+    MetaspaceShared::preload_and_dump();\n+    ShouldNotReachHere();\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+\/\/ type for the Agent_OnLoad and JVM_OnLoad entry points\n+extern \"C\" {\n+  typedef jint (JNICALL *OnLoadEntry_t)(JavaVM *, char *, void *);\n+}\n+\/\/ Find a command line agent library and return its entry point for\n+\/\/         -agentlib:  -agentpath:   -Xrun\n+\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n+static OnLoadEntry_t lookup_on_load(AgentLibrary* agent,\n+                                    const char *on_load_symbols[],\n+                                    size_t num_symbol_entries) {\n+  OnLoadEntry_t on_load_entry = NULL;\n+  void *library = NULL;\n+\n+  if (!agent->valid()) {\n+    char buffer[JVM_MAXPATHLEN];\n+    char ebuf[1024] = \"\";\n+    const char *name = agent->name();\n+    const char *msg = \"Could not find agent library \";\n+\n+    \/\/ First check to see if agent is statically linked into executable\n+    if (os::find_builtin_agent(agent, on_load_symbols, num_symbol_entries)) {\n+      library = agent->os_lib();\n+    } else if (agent->is_absolute_path()) {\n+      library = os::dll_load(name, ebuf, sizeof ebuf);\n+      if (library == NULL) {\n+        const char *sub_msg = \" in absolute path, with error: \";\n+        size_t len = strlen(msg) + strlen(name) + strlen(sub_msg) + strlen(ebuf) + 1;\n+        char *buf = NEW_C_HEAP_ARRAY(char, len, mtThread);\n+        jio_snprintf(buf, len, \"%s%s%s%s\", msg, name, sub_msg, ebuf);\n+        \/\/ If we can't find the agent, exit.\n+        vm_exit_during_initialization(buf, NULL);\n+        FREE_C_HEAP_ARRAY(char, buf);\n+      }\n+    } else {\n+      \/\/ Try to load the agent from the standard dll directory\n+      if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),\n+                             name)) {\n+        library = os::dll_load(buffer, ebuf, sizeof ebuf);\n+      }\n+      if (library == NULL) { \/\/ Try the library path directory.\n+        if (os::dll_build_name(buffer, sizeof(buffer), name)) {\n+          library = os::dll_load(buffer, ebuf, sizeof ebuf);\n+        }\n+        if (library == NULL) {\n+          const char *sub_msg = \" on the library path, with error: \";\n+          const char *sub_msg2 = \"\\nModule java.instrument may be missing from runtime image.\";\n+\n+          size_t len = strlen(msg) + strlen(name) + strlen(sub_msg) +\n+                       strlen(ebuf) + strlen(sub_msg2) + 1;\n+          char *buf = NEW_C_HEAP_ARRAY(char, len, mtThread);\n+          if (!agent->is_instrument_lib()) {\n+            jio_snprintf(buf, len, \"%s%s%s%s\", msg, name, sub_msg, ebuf);\n+          } else {\n+            jio_snprintf(buf, len, \"%s%s%s%s%s\", msg, name, sub_msg, ebuf, sub_msg2);\n+          }\n+          \/\/ If we can't find the agent, exit.\n+          vm_exit_during_initialization(buf, NULL);\n+          FREE_C_HEAP_ARRAY(char, buf);\n+        }\n+      }\n+    }\n+    agent->set_os_lib(library);\n+    agent->set_valid();\n+  }\n+\n+  \/\/ Find the OnLoad function.\n+  on_load_entry =\n+    CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent,\n+                                                          false,\n+                                                          on_load_symbols,\n+                                                          num_symbol_entries));\n+  return on_load_entry;\n+}\n+\n+\/\/ Find the JVM_OnLoad entry point\n+static OnLoadEntry_t lookup_jvm_on_load(AgentLibrary* agent) {\n+  const char *on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n+  return lookup_on_load(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+\/\/ Find the Agent_OnLoad entry point\n+static OnLoadEntry_t lookup_agent_on_load(AgentLibrary* agent) {\n+  const char *on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n+  return lookup_on_load(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+\/\/ For backwards compatibility with -Xrun\n+\/\/ Convert libraries with no JVM_OnLoad, but which have Agent_OnLoad to be\n+\/\/ treated like -agentpath:\n+\/\/ Must be called before agent libraries are created\n+void Threads::convert_vm_init_libraries_to_agents() {\n+  AgentLibrary* agent;\n+  AgentLibrary* next;\n+\n+  for (agent = Arguments::libraries(); agent != NULL; agent = next) {\n+    next = agent->next();  \/\/ cache the next agent now as this agent may get moved off this list\n+    OnLoadEntry_t on_load_entry = lookup_jvm_on_load(agent);\n+\n+    \/\/ If there is an JVM_OnLoad function it will get called later,\n+    \/\/ otherwise see if there is an Agent_OnLoad\n+    if (on_load_entry == NULL) {\n+      on_load_entry = lookup_agent_on_load(agent);\n+      if (on_load_entry != NULL) {\n+        \/\/ switch it to the agent list -- so that Agent_OnLoad will be called,\n+        \/\/ JVM_OnLoad won't be attempted and Agent_OnUnload will\n+        Arguments::convert_library_to_agent(agent);\n+      } else {\n+        vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", agent->name());\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Create agents for -agentlib:  -agentpath:  and converted -Xrun\n+\/\/ Invokes Agent_OnLoad\n+\/\/ Called very early -- before JavaThreads exist\n+void Threads::create_vm_init_agents() {\n+  extern struct JavaVM_ main_vm;\n+  AgentLibrary* agent;\n+\n+  JvmtiExport::enter_onload_phase();\n+\n+  for (agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n+    \/\/ CDS dumping does not support native JVMTI agent.\n+    \/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n+    if (Arguments::is_dumping_archive()) {\n+      if(!agent->is_instrument_lib()) {\n+        vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n+      } else if (!AllowArchivingWithJavaAgent) {\n+        vm_exit_during_cds_dumping(\n+          \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n+      }\n+    }\n+\n+    OnLoadEntry_t  on_load_entry = lookup_agent_on_load(agent);\n+\n+    if (on_load_entry != NULL) {\n+      \/\/ Invoke the Agent_OnLoad function\n+      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n+      if (err != JNI_OK) {\n+        vm_exit_during_initialization(\"agent library failed to init\", agent->name());\n+      }\n+    } else {\n+      vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n+    }\n+  }\n+\n+  JvmtiExport::enter_primordial_phase();\n+}\n+\n+extern \"C\" {\n+  typedef void (JNICALL *Agent_OnUnload_t)(JavaVM *);\n+}\n+\n+void Threads::shutdown_vm_agents() {\n+  \/\/ Send any Agent_OnUnload notifications\n+  const char *on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n+  size_t num_symbol_entries = ARRAY_SIZE(on_unload_symbols);\n+  extern struct JavaVM_ main_vm;\n+  for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n+\n+    \/\/ Find the Agent_OnUnload function.\n+    Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n+                                                   os::find_agent_function(agent,\n+                                                   false,\n+                                                   on_unload_symbols,\n+                                                   num_symbol_entries));\n+\n+    \/\/ Invoke the Agent_OnUnload function\n+    if (unload_entry != NULL) {\n+      JavaThread* thread = JavaThread::current();\n+      ThreadToNativeFromVM ttn(thread);\n+      HandleMark hm(thread);\n+      (*unload_entry)(&main_vm);\n+    }\n+  }\n+}\n+\n+\/\/ Called for after the VM is initialized for -Xrun libraries which have not been converted to agent libraries\n+\/\/ Invokes JVM_OnLoad\n+void Threads::create_vm_init_libraries() {\n+  extern struct JavaVM_ main_vm;\n+  AgentLibrary* agent;\n+\n+  for (agent = Arguments::libraries(); agent != NULL; agent = agent->next()) {\n+    OnLoadEntry_t on_load_entry = lookup_jvm_on_load(agent);\n+\n+    if (on_load_entry != NULL) {\n+      \/\/ Invoke the JVM_OnLoad function\n+      JavaThread* thread = JavaThread::current();\n+      ThreadToNativeFromVM ttn(thread);\n+      HandleMark hm(thread);\n+      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n+      if (err != JNI_OK) {\n+        vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n+      }\n+    } else {\n+      vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n+    }\n+  }\n+}\n+\n+\/\/ Threads::destroy_vm() is normally called from jni_DestroyJavaVM() when\n+\/\/ the program falls off the end of main(). Another VM exit path is through\n+\/\/ vm_exit() when the program calls System.exit() to return a value or when\n+\/\/ there is a serious error in VM. The two shutdown paths are not exactly\n+\/\/ the same, but they share Shutdown.shutdown() at Java level and before_exit()\n+\/\/ and VM_Exit op at VM level.\n+\/\/\n+\/\/ Shutdown sequence:\n+\/\/   + Shutdown native memory tracking if it is on\n+\/\/   + Wait until we are the last non-daemon thread to execute\n+\/\/     <-- every thing is still working at this moment -->\n+\/\/   + Call java.lang.Shutdown.shutdown(), which will invoke Java level\n+\/\/        shutdown hooks\n+\/\/   + Call before_exit(), prepare for VM exit\n+\/\/      > run VM level shutdown hooks (they are registered through JVM_OnExit(),\n+\/\/        currently the only user of this mechanism is File.deleteOnExit())\n+\/\/      > stop StatSampler, watcher thread,\n+\/\/        post thread end and vm death events to JVMTI,\n+\/\/        stop signal thread\n+\/\/   + Call JavaThread::exit(), it will:\n+\/\/      > release JNI handle blocks, remove stack guard pages\n+\/\/      > remove this thread from Threads list\n+\/\/     <-- no more Java code from this thread after this point -->\n+\/\/   + Stop VM thread, it will bring the remaining VM to a safepoint and stop\n+\/\/     the compiler threads at safepoint\n+\/\/     <-- do not use anything that could get blocked by Safepoint -->\n+\/\/   + Disable tracing at JNI\/JVM barriers\n+\/\/   + Set _vm_exited flag for threads that are still running native code\n+\/\/   + Call exit_globals()\n+\/\/      > deletes tty\n+\/\/      > deletes PerfMemory resources\n+\/\/   + Delete this thread\n+\/\/   + Return to caller\n+\n+void Threads::destroy_vm() {\n+  JavaThread* thread = JavaThread::current();\n+\n+#ifdef ASSERT\n+  _vm_complete = false;\n+#endif\n+  \/\/ Wait until we are the last non-daemon thread to execute\n+  {\n+    MonitorLocker nu(Threads_lock);\n+    while (Threads::number_of_non_daemon_threads() > 1)\n+      \/\/ This wait should make safepoint checks, wait without a timeout.\n+      nu.wait(0);\n+  }\n+\n+  EventShutdown e;\n+  if (e.should_commit()) {\n+    e.set_reason(\"No remaining non-daemon Java threads\");\n+    e.commit();\n+  }\n+\n+  \/\/ Hang forever on exit if we are reporting an error.\n+  if (ShowMessageBoxOnError && VMError::is_error_reported()) {\n+    os::infinite_sleep();\n+  }\n+  os::wait_for_keypress_at_exit();\n+\n+  \/\/ run Java level shutdown hooks\n+  thread->invoke_shutdown_hooks();\n+\n+  before_exit(thread);\n+\n+  thread->exit(true);\n+\n+  \/\/ We are no longer on the main thread list but could still be in a\n+  \/\/ secondary list where another thread may try to interact with us.\n+  \/\/ So wait until all such interactions are complete before we bring\n+  \/\/ the VM to the termination safepoint. Normally this would be done\n+  \/\/ using thread->smr_delete() below where we delete the thread, but\n+  \/\/ we can't call that after the termination safepoint is active as\n+  \/\/ we will deadlock on the Threads_lock. Once all interactions are\n+  \/\/ complete it is safe to directly delete the thread at any time.\n+  ThreadsSMRSupport::wait_until_not_protected(thread);\n+\n+  \/\/ Stop VM thread.\n+  {\n+    \/\/ 4945125 The vm thread comes to a safepoint during exit.\n+    \/\/ GC vm_operations can get caught at the safepoint, and the\n+    \/\/ heap is unparseable if they are caught. Grab the Heap_lock\n+    \/\/ to prevent this. The GC vm_operations will not be able to\n+    \/\/ queue until after the vm thread is dead. After this point,\n+    \/\/ we'll never emerge out of the safepoint before the VM exits.\n+    \/\/ Assert that the thread is terminated so that acquiring the\n+    \/\/ Heap_lock doesn't cause the terminated thread to participate in\n+    \/\/ the safepoint protocol.\n+\n+    assert(thread->is_terminated(), \"must be terminated here\");\n+    MutexLocker ml(Heap_lock);\n+\n+    VMThread::wait_for_vm_thread_exit();\n+    assert(SafepointSynchronize::is_at_safepoint(), \"VM thread should exit at Safepoint\");\n+    VMThread::destroy();\n+  }\n+\n+  \/\/ Now, all Java threads are gone except daemon threads. Daemon threads\n+  \/\/ running Java code or in VM are stopped by the Safepoint. However,\n+  \/\/ daemon threads executing native code are still running.  But they\n+  \/\/ will be stopped at native=>Java\/VM barriers. Note that we can't\n+  \/\/ simply kill or suspend them, as it is inherently deadlock-prone.\n+\n+  VM_Exit::set_vm_exited();\n+\n+  \/\/ Clean up ideal graph printers after the VMThread has started\n+  \/\/ the final safepoint which will block all the Compiler threads.\n+  \/\/ Note that this Thread has already logically exited so the\n+  \/\/ clean_up() function's use of a JavaThreadIteratorWithHandle\n+  \/\/ would be a problem except set_vm_exited() has remembered the\n+  \/\/ shutdown thread which is granted a policy exception.\n+#if defined(COMPILER2) && !defined(PRODUCT)\n+  IdealGraphPrinter::clean_up();\n+#endif\n+\n+  notify_vm_shutdown();\n+\n+  \/\/ exit_globals() will delete tty\n+  exit_globals();\n+\n+  \/\/ Deleting the shutdown thread here is safe. See comment on\n+  \/\/ wait_until_not_protected() above.\n+  delete thread;\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);\n+  }\n+#endif\n+\n+  LogConfiguration::finalize();\n+}\n+\n+\n+jboolean Threads::is_supported_jni_version_including_1_1(jint version) {\n+  if (version == JNI_VERSION_1_1) return JNI_TRUE;\n+  return is_supported_jni_version(version);\n+}\n+\n+\n+jboolean Threads::is_supported_jni_version(jint version) {\n+  if (version == JNI_VERSION_1_2) return JNI_TRUE;\n+  if (version == JNI_VERSION_1_4) return JNI_TRUE;\n+  if (version == JNI_VERSION_1_6) return JNI_TRUE;\n+  if (version == JNI_VERSION_1_8) return JNI_TRUE;\n+  if (version == JNI_VERSION_9) return JNI_TRUE;\n+  if (version == JNI_VERSION_10) return JNI_TRUE;\n+  if (version == JNI_VERSION_19) return JNI_TRUE;\n+  return JNI_FALSE;\n+}\n+\n+void Threads::add(JavaThread* p, bool force_daemon) {\n+  \/\/ The threads lock must be owned at this point\n+  assert(Threads_lock->owned_by_self(), \"must have threads lock\");\n+\n+  BarrierSet::barrier_set()->on_thread_attach(p);\n+\n+  \/\/ Once a JavaThread is added to the Threads list, smr_delete() has\n+  \/\/ to be used to delete it. Otherwise we can just delete it directly.\n+  p->set_on_thread_list();\n+\n+  _number_of_threads++;\n+  oop threadObj = p->threadObj();\n+  bool daemon = true;\n+  \/\/ Bootstrapping problem: threadObj can be null for initial\n+  \/\/ JavaThread (or for threads attached via JNI)\n+  if (!force_daemon &&\n+      (threadObj == nullptr || !java_lang_Thread::is_daemon(threadObj))) {\n+    _number_of_non_daemon_threads++;\n+    daemon = false;\n+  }\n+\n+  ThreadService::add_thread(p, daemon);\n+\n+  \/\/ Maintain fast thread list\n+  ThreadsSMRSupport::add_thread(p);\n+\n+  \/\/ Increase the ObjectMonitor ceiling for the new thread.\n+  ObjectSynchronizer::inc_in_use_list_ceiling();\n+\n+  \/\/ Possible GC point.\n+  Events::log(p, \"Thread added: \" INTPTR_FORMAT, p2i(p));\n+\n+  \/\/ Make new thread known to active EscapeBarrier\n+  EscapeBarrier::thread_added(p);\n+}\n+\n+void Threads::remove(JavaThread* p, bool is_daemon) {\n+  \/\/ Extra scope needed for Thread_lock, so we can check\n+  \/\/ that we do not remove thread without safepoint code notice\n+  { MonitorLocker ml(Threads_lock);\n+\n+    \/\/ BarrierSet state must be destroyed after the last thread transition\n+    \/\/ before the thread terminates. Thread transitions result in calls to\n+    \/\/ StackWatermarkSet::on_safepoint(), which performs GC processing,\n+    \/\/ requiring the GC state to be alive.\n+    BarrierSet::barrier_set()->on_thread_detach(p);\n+\n+    assert(ThreadsSMRSupport::get_java_thread_list()->includes(p), \"p must be present\");\n+\n+    \/\/ Maintain fast thread list\n+    ThreadsSMRSupport::remove_thread(p);\n+\n+    _number_of_threads--;\n+    if (!is_daemon) {\n+      _number_of_non_daemon_threads--;\n+\n+      \/\/ Only one thread left, do a notify on the Threads_lock so a thread waiting\n+      \/\/ on destroy_vm will wake up.\n+      if (number_of_non_daemon_threads() == 1) {\n+        ml.notify_all();\n+      }\n+    }\n+    ThreadService::remove_thread(p, is_daemon);\n+\n+    \/\/ Make sure that safepoint code disregard this thread. This is needed since\n+    \/\/ the thread might mess around with locks after this point. This can cause it\n+    \/\/ to do callbacks into the safepoint code. However, the safepoint code is not aware\n+    \/\/ of this thread since it is removed from the queue.\n+    p->set_terminated(JavaThread::_thread_terminated);\n+\n+    \/\/ Notify threads waiting in EscapeBarriers\n+    EscapeBarrier::thread_removed(p);\n+  } \/\/ unlock Threads_lock\n+\n+  \/\/ Reduce the ObjectMonitor ceiling for the exiting thread.\n+  ObjectSynchronizer::dec_in_use_list_ceiling();\n+\n+  \/\/ Since Events::log uses a lock, we grab it outside the Threads_lock\n+  Events::log(p, \"Thread exited: \" INTPTR_FORMAT, p2i(p));\n+}\n+\n+\/\/ Operations on the Threads list for GC.  These are not explicitly locked,\n+\/\/ but the garbage collector must provide a safe context for them to run.\n+\/\/ In particular, these things should never be called when the Threads_lock\n+\/\/ is held by some other thread. (Note: the Safepoint abstraction also\n+\/\/ uses the Threads_lock to guarantee this property. It also makes sure that\n+\/\/ all threads gets blocked when exiting or starting).\n+\n+void Threads::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  ALL_JAVA_THREADS(p) {\n+    p->oops_do(f, cf);\n+  }\n+  VMThread::vm_thread()->oops_do(f, cf);\n+}\n+\n+void Threads::change_thread_claim_token() {\n+  if (++_thread_claim_token == 0) {\n+    \/\/ On overflow of the token counter, there is a risk of future\n+    \/\/ collisions between a new global token value and a stale token\n+    \/\/ for a thread, because not all iterations visit all threads.\n+    \/\/ (Though it's pretty much a theoretical concern for non-trivial\n+    \/\/ token counter sizes.)  To deal with the possibility, reset all\n+    \/\/ the thread tokens to zero on global token overflow.\n+    struct ResetClaims : public ThreadClosure {\n+      virtual void do_thread(Thread* t) {\n+        t->claim_threads_do(false, 0);\n+      }\n+    } reset_claims;\n+    Threads::threads_do(&reset_claims);\n+    \/\/ On overflow, update the global token to non-zero, to\n+    \/\/ avoid the special \"never claimed\" initial thread value.\n+    _thread_claim_token = 1;\n+  }\n+}\n+\n+#ifdef ASSERT\n+void assert_thread_claimed(const char* kind, Thread* t, uintx expected) {\n+  const uintx token = t->threads_do_token();\n+  assert(token == expected,\n+         \"%s \" PTR_FORMAT \" has incorrect value \" UINTX_FORMAT \" != \"\n+         UINTX_FORMAT, kind, p2i(t), token, expected);\n+}\n+\n+void Threads::assert_all_threads_claimed() {\n+  ALL_JAVA_THREADS(p) {\n+    assert_thread_claimed(\"Thread\", p, _thread_claim_token);\n+  }\n+  assert_thread_claimed(\"VMThread\", VMThread::vm_thread(), _thread_claim_token);\n+}\n+#endif \/\/ ASSERT\n+\n+class ParallelOopsDoThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* _f;\n+  CodeBlobClosure* _cf;\n+public:\n+  ParallelOopsDoThreadClosure(OopClosure* f, CodeBlobClosure* cf) : _f(f), _cf(cf) {}\n+  void do_thread(Thread* t) {\n+    t->oops_do(_f, _cf);\n+  }\n+};\n+\n+void Threads::possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf) {\n+  ParallelOopsDoThreadClosure tc(f, cf);\n+  possibly_parallel_threads_do(is_par, &tc);\n+}\n+\n+void Threads::metadata_do(MetadataClosure* f) {\n+  ALL_JAVA_THREADS(p) {\n+    p->metadata_do(f);\n+  }\n+}\n+\n+class ThreadHandlesClosure : public ThreadClosure {\n+  void (*_f)(Metadata*);\n+ public:\n+  ThreadHandlesClosure(void f(Metadata*)) : _f(f) {}\n+  virtual void do_thread(Thread* thread) {\n+    thread->metadata_handles_do(_f);\n+  }\n+};\n+\n+void Threads::metadata_handles_do(void f(Metadata*)) {\n+  \/\/ Only walk the Handles in Thread.\n+  ThreadHandlesClosure handles_closure(f);\n+  threads_do(&handles_closure);\n+}\n+\n+\/\/ Get count Java threads that are waiting to enter the specified monitor.\n+GrowableArray<JavaThread*>* Threads::get_pending_threads(ThreadsList * t_list,\n+                                                         int count,\n+                                                         address monitor) {\n+  GrowableArray<JavaThread*>* result = new GrowableArray<JavaThread*>(count);\n+\n+  int i = 0;\n+  for (JavaThread* p : *t_list) {\n+    if (!p->can_call_java()) continue;\n+\n+    \/\/ The first stage of async deflation does not affect any field\n+    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n+    address pending = (address)p->current_pending_monitor();\n+    if (pending == monitor) {             \/\/ found a match\n+      if (i < count) result->append(p);   \/\/ save the first count matches\n+      i++;\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+\n+JavaThread *Threads::owning_thread_from_monitor_owner(ThreadsList * t_list,\n+                                                      address owner) {\n+  \/\/ NULL owner means not locked so we can skip the search\n+  if (owner == NULL) return NULL;\n+\n+  for (JavaThread* p : *t_list) {\n+    \/\/ first, see if owner is the address of a Java thread\n+    if (owner == (address)p) return p;\n+  }\n+\n+  \/\/ Cannot assert on lack of success here since this function may be\n+  \/\/ used by code that is trying to report useful problem information\n+  \/\/ like deadlock detection.\n+  if (UseHeavyMonitors) return NULL;\n+\n+  \/\/ If we didn't find a matching Java thread and we didn't force use of\n+  \/\/ heavyweight monitors, then the owner is the stack address of the\n+  \/\/ Lock Word in the owning Java thread's stack.\n+  \/\/\n+  JavaThread* the_owner = NULL;\n+  for (JavaThread* q : *t_list) {\n+    if (q->is_lock_owned(owner)) {\n+      the_owner = q;\n+      break;\n+    }\n+  }\n+\n+  \/\/ cannot assert on lack of success here; see above comment\n+  return the_owner;\n+}\n+\n+class PrintOnClosure : public ThreadClosure {\n+private:\n+  outputStream* _st;\n+\n+public:\n+  PrintOnClosure(outputStream* st) :\n+      _st(st) {}\n+\n+  virtual void do_thread(Thread* thread) {\n+    if (thread != NULL) {\n+      thread->print_on(_st);\n+      _st->cr();\n+    }\n+  }\n+};\n+\n+\/\/ Threads::print_on() is called at safepoint by VM_PrintThreads operation.\n+void Threads::print_on(outputStream* st, bool print_stacks,\n+                       bool internal_format, bool print_concurrent_locks,\n+                       bool print_extended_info) {\n+  char buf[32];\n+  st->print_raw_cr(os::local_time_string(buf, sizeof(buf)));\n+\n+  st->print_cr(\"Full thread dump %s (%s %s):\",\n+               VM_Version::vm_name(),\n+               VM_Version::vm_release(),\n+               VM_Version::vm_info_string());\n+  st->cr();\n+\n+#if INCLUDE_SERVICES\n+  \/\/ Dump concurrent locks\n+  ConcurrentLocksDump concurrent_locks;\n+  if (print_concurrent_locks) {\n+    concurrent_locks.dump_at_safepoint();\n+  }\n+#endif \/\/ INCLUDE_SERVICES\n+\n+  ThreadsSMRSupport::print_info_on(st);\n+  st->cr();\n+\n+  ALL_JAVA_THREADS(p) {\n+    ResourceMark rm;\n+    p->print_on(st, print_extended_info);\n+    if (print_stacks) {\n+      if (internal_format) {\n+        p->trace_stack();\n+      } else {\n+        p->print_stack_on(st);\n+      }\n+    }\n+    st->cr();\n+#if INCLUDE_SERVICES\n+    if (print_concurrent_locks) {\n+      concurrent_locks.print_locks_on(p, st);\n+    }\n+#endif \/\/ INCLUDE_SERVICES\n+  }\n+\n+  PrintOnClosure cl(st);\n+  cl.do_thread(VMThread::vm_thread());\n+  Universe::heap()->gc_threads_do(&cl);\n+  if (StringDedup::is_enabled()) {\n+    StringDedup::threads_do(&cl);\n+  }\n+  cl.do_thread(WatcherThread::watcher_thread());\n+  cl.do_thread(AsyncLogWriter::instance());\n+\n+  st->flush();\n+}\n+\n+void Threads::print_on_error(Thread* this_thread, outputStream* st, Thread* current, char* buf,\n+                             int buflen, bool* found_current) {\n+  if (this_thread != NULL) {\n+    bool is_current = (current == this_thread);\n+    *found_current = *found_current || is_current;\n+    st->print(\"%s\", is_current ? \"=>\" : \"  \");\n+\n+    st->print(PTR_FORMAT, p2i(this_thread));\n+    st->print(\" \");\n+    this_thread->print_on_error(st, buf, buflen);\n+    st->cr();\n+  }\n+}\n+\n+class PrintOnErrorClosure : public ThreadClosure {\n+  outputStream* _st;\n+  Thread* _current;\n+  char* _buf;\n+  int _buflen;\n+  bool* _found_current;\n+ public:\n+  PrintOnErrorClosure(outputStream* st, Thread* current, char* buf,\n+                      int buflen, bool* found_current) :\n+   _st(st), _current(current), _buf(buf), _buflen(buflen), _found_current(found_current) {}\n+\n+  virtual void do_thread(Thread* thread) {\n+    Threads::print_on_error(thread, _st, _current, _buf, _buflen, _found_current);\n+  }\n+};\n+\n+\/\/ Threads::print_on_error() is called by fatal error handler. It's possible\n+\/\/ that VM is not at safepoint and\/or current thread is inside signal handler.\n+\/\/ Don't print stack trace, as the stack may not be walkable. Don't allocate\n+\/\/ memory (even in resource area), it might deadlock the error handler.\n+void Threads::print_on_error(outputStream* st, Thread* current, char* buf,\n+                             int buflen) {\n+  ThreadsSMRSupport::print_info_on(st);\n+  st->cr();\n+\n+  bool found_current = false;\n+  st->print_cr(\"Java Threads: ( => current thread )\");\n+  ALL_JAVA_THREADS(thread) {\n+    print_on_error(thread, st, current, buf, buflen, &found_current);\n+  }\n+  st->cr();\n+\n+  st->print_cr(\"Other Threads:\");\n+  print_on_error(VMThread::vm_thread(), st, current, buf, buflen, &found_current);\n+  print_on_error(WatcherThread::watcher_thread(), st, current, buf, buflen, &found_current);\n+  print_on_error(AsyncLogWriter::instance(), st, current, buf, buflen, &found_current);\n+\n+  if (Universe::heap() != NULL) {\n+    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n+    Universe::heap()->gc_threads_do(&print_closure);\n+  }\n+\n+  if (StringDedup::is_enabled()) {\n+    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n+    StringDedup::threads_do(&print_closure);\n+  }\n+\n+  if (!found_current) {\n+    st->cr();\n+    st->print(\"=>\" PTR_FORMAT \" (exited) \", p2i(current));\n+    current->print_on_error(st, buf, buflen);\n+    st->cr();\n+  }\n+  st->cr();\n+\n+  st->print_cr(\"Threads with active compile tasks:\");\n+  print_threads_compiling(st, buf, buflen);\n+}\n+\n+void Threads::print_threads_compiling(outputStream* st, char* buf, int buflen, bool short_form) {\n+  ALL_JAVA_THREADS(thread) {\n+    if (thread->is_Compiler_thread()) {\n+      CompilerThread* ct = (CompilerThread*) thread;\n+\n+      \/\/ Keep task in local variable for NULL check.\n+      \/\/ ct->_task might be set to NULL by concurring compiler thread\n+      \/\/ because it completed the compilation. The task is never freed,\n+      \/\/ though, just returned to a free list.\n+      CompileTask* task = ct->task();\n+      if (task != NULL) {\n+        thread->print_name_on_error(st, buf, buflen);\n+        st->print(\"  \");\n+        task->print(st, NULL, short_form, true);\n+      }\n+    }\n+  }\n+}\n+\n+void Threads::verify() {\n+  ALL_JAVA_THREADS(p) {\n+    p->verify();\n+  }\n+  VMThread* thread = VMThread::vm_thread();\n+  if (thread != NULL) thread->verify();\n+}\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1545,"deletions":0,"binary":false,"changes":1545,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_THREADS_HPP\n+#define SHARE_RUNTIME_THREADS_HPP\n+\n+#include \"jni.h\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class JavaThread;\n+class Metadata;\n+class Thread;\n+class ThreadClosure;\n+class ThreadsList;\n+class outputStream;\n+\n+class CodeBlobClosure;\n+class MetadataClosure;\n+class OopClosure;\n+\n+\/\/ The active thread queue. It also keeps track of the current used\n+\/\/ thread priorities.\n+class Threads: AllStatic {\n+  friend class VMStructs;\n+ private:\n+  static int         _number_of_threads;\n+  static int         _number_of_non_daemon_threads;\n+  static int         _return_code;\n+  static uintx       _thread_claim_token;\n+#ifdef ASSERT\n+  static bool        _vm_complete;\n+#endif\n+\n+  static void initialize_java_lang_classes(JavaThread* main_thread, TRAPS);\n+  static void initialize_jsr292_core_classes(TRAPS);\n+\n+ public:\n+  \/\/ Thread management\n+  \/\/ force_daemon is a concession to JNI, where we may need to add a\n+  \/\/ thread to the thread list before allocating its thread object\n+  static void add(JavaThread* p, bool force_daemon = false);\n+  static void remove(JavaThread* p, bool is_daemon);\n+  static void non_java_threads_do(ThreadClosure* tc);\n+  static void java_threads_do(ThreadClosure* tc);\n+  static void java_threads_and_vm_thread_do(ThreadClosure* tc);\n+  static void threads_do(ThreadClosure* tc);\n+  static void possibly_parallel_threads_do(bool is_par, ThreadClosure* tc);\n+\n+  \/\/ Initializes the vm and creates the vm thread\n+  static jint create_vm(JavaVMInitArgs* args, bool* canTryAgain);\n+  static void convert_vm_init_libraries_to_agents();\n+  static void create_vm_init_libraries();\n+  static void create_vm_init_agents();\n+  static void shutdown_vm_agents();\n+  static void destroy_vm();\n+  \/\/ Supported VM versions via JNI\n+  \/\/ Includes JNI_VERSION_1_1\n+  static jboolean is_supported_jni_version_including_1_1(jint version);\n+  \/\/ Does not include JNI_VERSION_1_1\n+  static jboolean is_supported_jni_version(jint version);\n+\n+  \/\/ The \"thread claim token\" provides a way for threads to be claimed\n+  \/\/ by parallel worker tasks.\n+  \/\/\n+  \/\/ Each thread contains a \"token\" field. A task will claim the\n+  \/\/ thread only if its token is different from the global token,\n+  \/\/ which is updated by calling change_thread_claim_token().  When\n+  \/\/ a thread is claimed, it's token is set to the global token value\n+  \/\/ so other threads in the same iteration pass won't claim it.\n+  \/\/\n+  \/\/ For this to work change_thread_claim_token() needs to be called\n+  \/\/ exactly once in sequential code before starting parallel tasks\n+  \/\/ that should claim threads.\n+  \/\/\n+  \/\/ New threads get their token set to 0 and change_thread_claim_token()\n+  \/\/ never sets the global token to 0.\n+  static uintx thread_claim_token() { return _thread_claim_token; }\n+  static void change_thread_claim_token();\n+  static void assert_all_threads_claimed() NOT_DEBUG_RETURN;\n+\n+  \/\/ Apply \"f->do_oop\" to all root oops in all threads.\n+  \/\/ This version may only be called by sequential code.\n+  static void oops_do(OopClosure* f, CodeBlobClosure* cf);\n+  \/\/ This version may be called by sequential or parallel code.\n+  static void possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf);\n+\n+  \/\/ RedefineClasses support\n+  static void metadata_do(MetadataClosure* f);\n+  static void metadata_handles_do(void f(Metadata*));\n+\n+#ifdef ASSERT\n+  static bool is_vm_complete() { return _vm_complete; }\n+#endif \/\/ ASSERT\n+\n+  \/\/ Verification\n+  static void verify();\n+  static void print_on(outputStream* st, bool print_stacks, bool internal_format, bool print_concurrent_locks, bool print_extended_info);\n+  static void print(bool print_stacks, bool internal_format) {\n+    \/\/ this function is only used by debug.cpp\n+    print_on(tty, print_stacks, internal_format, false \/* no concurrent lock printed *\/, false \/* simple format *\/);\n+  }\n+  static void print_on_error(outputStream* st, Thread* current, char* buf, int buflen);\n+  static void print_on_error(Thread* this_thread, outputStream* st, Thread* current, char* buf,\n+                             int buflen, bool* found_current);\n+  static void print_threads_compiling(outputStream* st, char* buf, int buflen, bool short_form = false);\n+\n+  \/\/ Get Java threads that are waiting to enter a monitor.\n+  static GrowableArray<JavaThread*>* get_pending_threads(ThreadsList * t_list,\n+                                                         int count, address monitor);\n+\n+  \/\/ Get owning Java thread from the monitor's owner field.\n+  static JavaThread *owning_thread_from_monitor_owner(ThreadsList * t_list,\n+                                                      address owner);\n+\n+  \/\/ Number of threads on the active threads list\n+  static int number_of_threads()                 { return _number_of_threads; }\n+  \/\/ Number of non-daemon threads on the active threads list\n+  static int number_of_non_daemon_threads()      { return _number_of_non_daemon_threads; }\n+\n+  \/\/ Deoptimizes all frames tied to marked nmethods\n+  static void deoptimized_wrt_marked_nmethods();\n+\n+  struct Test;                  \/\/ For private gtest access.\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_THREADS_HPP\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -52,1 +53,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+class MonitorInfo;\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -47,1 +48,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -104,1 +105,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -51,1 +52,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/services\/memBaseline.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -47,1 +48,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepoint.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -51,1 +52,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/growableArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -50,1 +51,1 @@\n-#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"test\/hotspot\/gtest\/code\/test_dependencyContext.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/threads.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -29,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_threads.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/thread.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n","filename":"test\/hotspot\/gtest\/utilities\/test_metaspaceClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}