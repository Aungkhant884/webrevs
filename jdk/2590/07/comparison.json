{"files":[{"patch":"@@ -3179,0 +3179,13 @@\n+\/\/ Int Immediate: power of 2, positive\n+operand immI_bitmask()\n+%{\n+  predicate((n->get_int() != 0)\n+            && ((n->get_int() & 0xc0000000) == 0)\n+            && is_power_of_2(n->get_int() + 1));\n+  match(ConI);\n+\n+  op_cost(20);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -9156,0 +9169,16 @@\n+\/\/ Can skip int2long conversions after AND with small bitmask\n+instruct convI2LAndI_reg_immIbitmask(rRegL dst, rRegI src, immI_bitmask mask, rRegI tmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  ins_cost(125);\n+  effect(TEMP tmp, KILL cr);\n+  match(Set dst (ConvI2L (AndI src mask)));\n+  format %{ \"bzhiq $dst, $src, $mask \\t# using $tmp as TEMP, int & immI_bitmask -> long\" %}\n+  ins_encode %{\n+    assert(VM_Version::supports_bmi2(), \"required\");\n+    __ movl($tmp$$Register, exact_log2($mask$$constant + 1));\n+    __ bzhiq($dst$$Register, $src$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Support BMI2 instructions on x86\/x64\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *      -XX:CompileCommand=compileonly,compiler.codegen.BMI2$BMITests::*\n+ *      compiler.codegen.BMI2\n+ *\/\n+\n+package compiler.codegen;\n+\n+public class BMI2 {\n+    private final static int ITERATIONS = 30000;\n+\n+    \/\/ match(Set dst (ConvI2L (AndI src1 mask))) \/\/ Using 0\n+    public static void testZeroBzhiI2L() {\n+        int ix = 0;\n+\n+        for (int i = 0; i <= 15; i++) {\n+            long z = BMITests.bzhiI2L(ix, i);\n+\n+                for (int i2 = 0; i2 < ITERATIONS; i2++) {\n+                    long ii = BMITests.bzhiI2L(ix, i);\n+                    if (ii != z) {\n+                        throw new Error(returnBzhiI2LErrMessage (z, ii));\n+                    }\n+                }\n+        }\n+    }\n+\n+    \/\/ match(Set dst (ConvI2L (AndI src1 mask))) \/\/ Using 1\n+    public static void testOneBzhiI2L() {\n+        int ix = 1;\n+\n+        for (int i = 0; i <= 15; i++) {\n+            long z = BMITests.bzhiI2L(ix, i);\n+\n+                for (int i2 = 0; i2 < ITERATIONS; i2++) {\n+                    long ii = BMITests.bzhiI2L(ix, i);\n+                    if (ii != z) {\n+                        throw new Error(returnBzhiI2LErrMessage (z, ii));\n+                    }\n+                }\n+        }\n+    }\n+\n+    private static String returnBzhiI2LErrMessage (long value, long value2) {\n+        return \"bzhi I2L with register failed, uncompiled result: \" + value + \" does not match compiled result: \" + value2;\n+    }\n+\n+    static class BMITests {\n+\n+        static long bzhiI2L(int src1, int src2) {\n+\n+            switch(src2) {\n+                case 0:\n+                    return (long)(src1 & 0x1);\n+                case 1:\n+                    return (long)(src1 & 0x3);\n+                case 2:\n+                    return (long)(src1 & 0x7);\n+                case 3:\n+                    return (long)(src1 & 0xF);\n+                case 4:\n+                    return (long)(src1 & 0x1F);\n+                case 5:\n+                    return (long)(src1 & 0x3F);\n+                case 6:\n+                    return (long)(src1 & 0x7F);\n+                case 7:\n+                    return (long)(src1 & 0xFF);\n+                case 8:\n+                    return (long)(src1 & 0x1FF);\n+                case 9:\n+                    return (long)(src1 & 0x3FF);\n+                case 10:\n+                    return (long)(src1 & 0x7FF);\n+                case 11:\n+                    return (long)(src1 & 0xFFF);\n+                case 12:\n+                    return (long)(src1 & 0x1FFF);\n+                case 13:\n+                    return (long)(src1 & 0x3FFF);\n+                case 14:\n+                    return (long)(src1 & 0x7FFF);\n+                case 15:\n+                    return (long)(src1 & 0xFFFF);\n+                default:\n+                    return (long)(src1 & 0xFFFF);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        testZeroBzhiI2L();\n+        testOneBzhiI2L();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/BMI2.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -221,0 +221,1 @@\n+            runUnaryIntToLongRegTest(expr, iterations, rng);\n@@ -309,0 +310,19 @@\n+        public static void runUnaryIntToLongRegTest(Expr expr, int iterations,\n+                                                    Random rng) {\n+            if (!(expr.isUnaryArgumentSupported()\n+                  && expr.isIntToLongExprSupported())) {\n+                return;\n+            }\n+\n+            for (int value : getIntBitShifts()) {\n+                log(\"UnaryIntToLongReg(0X%x) -> 0X%x\",\n+                    value, expr.intToLongExpr(value));\n+            }\n+\n+            for (int i = 0; i < iterations; i++) {\n+                int value = rng.nextInt();\n+                log(\"UnaryIntToLongReg(0X%x) -> 0X%x\",\n+                    value, expr.intToLongExpr(value));\n+            }\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/BMITestRunner.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    public boolean isIntToLongExprSupported() {\n+        return false;\n+    }\n+\n@@ -116,0 +120,4 @@\n+    public long intToLongExpr(int reg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n@@ -161,0 +169,7 @@\n+    public static class BMIUnaryIntToLongExpr extends BMIUnaryExpr {\n+        public boolean isIntToLongExprSupported() {\n+            return true;\n+        }\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/Expr.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary Verify that results of computations are the same w\/\n+ *          and w\/o usage of BZHI instruction\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI compiler.intrinsics.bmi.TestBzhiI2L\n+ *\/\n+\n+package compiler.intrinsics.bmi;\n+\n+import sun.hotspot.cpuinfo.CPUInfo;\n+\n+public class TestBzhiI2L {\n+\n+    public static void main(String args[]) throws Throwable {\n+        if (!CPUInfo.hasFeature(\"bmi2\")) {\n+            System.out.println(\"INFO: CPU does not support bmi2 feature, test SKIPPED\" );\n+            return;\n+        }\n+\n+        BMITestRunner.runTests(BzhiI2LExpr.class, args,\n+                               \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                               \"-XX:+UseBMI2Instructions\");\n+        BMITestRunner.runTests(BzhiI2LCommutativeExpr.class, args,\n+                               \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                               \"-XX:+UseBMI2Instructions\");\n+    }\n+\n+    public static class BzhiI2LExpr extends Expr.BMIUnaryIntToLongExpr {\n+\n+        public long intToLongExpr(int src1) {\n+            int value = src1;\n+            long returnValue = 0L;\n+\n+            for(int i = 0; i < 10000; ++i) {\n+                returnValue =\n+                (long)(value & 0x1)    ^ (long)(value & 0x3)    ^ (long)(value & 0x7)    ^ (long)(value & 0xF)   ^\n+                (long)(value & 0x1F)   ^ (long)(value & 0x3F)   ^ (long)(value & 0x7F)   ^ (long)(value & 0xFF)  ^\n+                (long)(value & 0x1FF)  ^ (long)(value & 0x3FF)  ^ (long)(value & 0x7FF)  ^ (long)(value & 0xFFF) ^\n+                (long)(value & 0x1FFF) ^ (long)(value & 0x3FFF) ^ (long)(value & 0x7FFF) ^ (long)(value & 0xFFFF);\n+            }\n+            return returnValue;\n+        }\n+    }\n+\n+    public static class BzhiI2LCommutativeExpr extends Expr.BMIUnaryIntToLongExpr {\n+\n+        public long intToLongExpr(int src1) {\n+            int value = src1;\n+            long returnValue = 0L;\n+\n+            for(int i = 0; i < 10000; ++i) {\n+                returnValue =\n+                (long)(value & 0x1)    ^ (long)(value & 0x3)    ^ (long)(value & 0x7)    ^ (long)(value & 0xF)   ^\n+                (long)(value & 0x1F)   ^ (long)(value & 0x3F)   ^ (long)(value & 0x7F)   ^ (long)(value & 0xFF)  ^\n+                (long)(value & 0x1FF)  ^ (long)(value & 0x3FF)  ^ (long)(value & 0x7FF)  ^ (long)(value & 0xFFF) ^\n+                (long)(value & 0x1FFF) ^ (long)(value & 0x3FFF) ^ (long)(value & 0x7FFF) ^ (long)(value & 0xFFFF);\n+            }\n+            return returnValue;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/TestBzhiI2L.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -54,1 +54,6 @@\n-        BmiTestCase bmiTestCase = (BmiTestCase) testCase;\n+        BmiTestCase bmiTestCase;\n+        if (((BmiTestCase) testCase).getTestCaseX64()) {\n+            bmiTestCase = (BmiTestCase_x64) testCase;\n+        } else {\n+            bmiTestCase = (BmiTestCase) testCase;\n+        }\n@@ -108,0 +113,1 @@\n+        final byte[] matchInstrPattern = (((BmiTestCase) testCase).getTestCaseX64()) ? ((BmiTestCase_x64) testCase).getInstrPattern_x64() : ((BmiTestCase) testCase).getInstrPattern();\n@@ -109,1 +115,2 @@\n-            throw new AssertionError(testCase.name() + \"CPU instructions expected not found: \" + Utils.toHexString(nativeCode));\n+            throw new AssertionError(testCase.name() + \" \" + \"CPU instructions expected not found in nativeCode: \" + Utils.toHexString(nativeCode) + \" ---- Expected instrPattern: \" +\n+            Utils.toHexString(matchInstrPattern));\n@@ -111,1 +118,2 @@\n-            System.out.println(\"CPU instructions found, PASSED\");\n+            System.out.println(\"CPU instructions found, PASSED, nativeCode: \" + Utils.toHexString(nativeCode) + \" ---- Expected instrPattern: \" +\n+            Utils.toHexString(matchInstrPattern));\n@@ -120,0 +128,2 @@\n+        protected String cpuFlag = \"bmi1\";\n+        protected String vmFlag = \"UseBMI1Instructions\";\n@@ -145,0 +155,4 @@\n+        public byte[] getInstrPattern() {\n+            return instrPattern;\n+        }\n+\n@@ -180,1 +194,1 @@\n-            return \"bmi1\";\n+            return cpuFlag;\n@@ -184,1 +198,5 @@\n-            return \"UseBMI1Instructions\";\n+            return vmFlag;\n+        }\n+\n+        protected boolean getTestCaseX64() {\n+            return false;\n@@ -196,0 +214,8 @@\n+        public byte[] getInstrPattern_x64() {\n+            return instrPattern_x64;\n+        }\n+\n+        protected boolean getTestCaseX64() {\n+            return true;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BmiIntrinsicBase.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.flavor == \"server\" & !vm.emulatedClient & !vm.graal.enabled\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+AbortVMOnCompilationFailure\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UseBMI2Instructions\n+ *      compiler.intrinsics.bmi.verifycode.BzhiTestI2L\n+ *\/\n+\n+package compiler.intrinsics.bmi.verifycode;\n+\n+import compiler.intrinsics.bmi.TestBzhiI2L;\n+\n+import java.lang.reflect.Method;\n+\n+public class BzhiTestI2L extends BmiIntrinsicBase.BmiTestCase_x64 {\n+\n+    protected BzhiTestI2L(Method method) {\n+        super(method);\n+\n+        cpuFlag = \"bmi2\";\n+        vmFlag = \"UseBMI2Instructions\";\n+        isLongOperation = true;\n+\n+        \/\/ from intel manual VEX.LZ.0F38.W1 F5 \/r\n+        instrMask = new byte[]{\n+            (byte) 0xFF,\n+            (byte) 0x1F,\n+            (byte) 0x80,\n+            (byte) 0xFF};\n+        instrPattern = new byte[]{\n+            (byte) 0xC4,    \/\/ prefix for 3-byte VEX instruction\n+            (byte) 0x02,    \/\/ 00010 implied 0F 38 leading opcode bytes\n+            (byte) 0x80,\n+            (byte) 0xF5};\n+\n+        instrMask_x64 = new byte[]{\n+            (byte) 0xFF,\n+            (byte) 0x7F,\n+            (byte) 0xFF,\n+            (byte) 0xFF};\n+        instrPattern_x64 = new byte[]{\n+            (byte) 0xC4,    \/\/ prefix for 3-byte VEX instruction\n+            (byte) 0x62,    \/\/ 00010 implied 0F 38 leading opcode bytes\n+            (byte) 0xA8,\n+            (byte) 0xF5};\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BmiIntrinsicBase.verifyTestCase(BzhiTestI2L::new, TestBzhiI2L.BzhiI2LExpr.class.getDeclaredMethods());\n+        BmiIntrinsicBase.verifyTestCase(BzhiTestI2L::new, TestBzhiI2L.BzhiI2LCommutativeExpr.class.getDeclaredMethods());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BzhiTestI2L.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}