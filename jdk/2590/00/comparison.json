{"files":[{"patch":"@@ -9197,0 +9197,7 @@\n+void Assembler::bzhi(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2094,0 +2094,1 @@\n+  void bzhi(Register dst, Register src1, Register src2);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3179,0 +3179,13 @@\n+\/\/ Int Immediate: power of 2, positive\n+operand immI_bitmask()\n+%{\n+  predicate((n->get_int() != 0)\n+            && ((n->get_int() & 0xc0000000) == 0)\n+            && is_power_of_2(n->get_int() + 1));\n+  match(ConI);\n+\n+  op_cost(20);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -9156,0 +9169,16 @@\n+\/\/ Can skip int2long conversions after AND with small bitmask\n+instruct convI2LAndI_reg_immIbitmask(rRegL dst, rRegI src, immI_bitmask mask, rRegI tmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  ins_cost(125);\n+  effect(TEMP tmp, KILL cr);\n+  match(Set dst (ConvI2L (AndI src mask)));\n+  format %{ \"bzhi $dst, $src, $mask \\t# using $tmp as TEMP, int & immI_bitmask -> long\" %}\n+  ins_encode %{\n+    assert(VM_Version::supports_bmi2(), \"required\");\n+    __ movl($tmp$$Register, exact_log2($mask$$constant + 1));\n+    __ bzhi($dst$$Register, $src$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}