{"files":[{"patch":"@@ -33,0 +33,3 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"logging\/logMessage.hpp\"\n@@ -34,0 +37,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -131,1 +135,1 @@\n-static void print_pending_exception(outputStream* output, oop throwable) {\n+static void handle_pending_exception(outputStream* output, bool startup, oop throwable) {\n@@ -135,4 +139,10 @@\n-\n-  if (msg != NULL) {\n-    char* text = java_lang_String::as_utf8_string(msg);\n-    output->print_raw_cr(text);\n+  if (msg == NULL) {\n+    return;\n+  }\n+  char* text = java_lang_String::as_utf8_string(msg);\n+  if (text != NULL) {\n+    if (startup) {\n+      log_error(jfr,startup)(\"%s\", text);\n+    } else {\n+      output->print_cr(\"%s\", text);\n+    }\n@@ -142,3 +152,12 @@\n-static void print_message(outputStream* output, const char* message) {\n-  if (message != NULL) {\n-    output->print_raw(message);\n+static void print_message(outputStream* output, oop content, TRAPS) {\n+  objArrayOop lines = objArrayOop(content);\n+  assert(lines != NULL, \"invariant\");\n+  assert(lines->is_array(), \"must be array\");\n+  const int length = lines->length();\n+  for (int i = 0; i < length; ++i) {\n+    const char* text = JfrJavaSupport::c_str(lines->obj_at(i), THREAD);\n+    if (text == NULL) {\n+      \/\/ An oome has been thrown and is pending.\n+      break;\n+    }\n+    output->print_cr(\"%s\", text);\n@@ -148,0 +167,16 @@\n+static void log(oop content, TRAPS) {\n+    LogMessage(jfr,startup) msg;\n+    objArrayOop lines = objArrayOop(content);\n+    assert(lines != NULL, \"invariant\");\n+    assert(lines->is_array(), \"must be array\");\n+    const int length = lines->length();\n+    for (int i = 0; i < length; ++i) {\n+      const char* text = JfrJavaSupport::c_str(lines->obj_at(i), THREAD);\n+      if (text == NULL) {\n+        \/\/ An oome has been thrown and is pending.\n+        break;\n+      }\n+      msg.info(\"%s\", text);\n+    }\n+}\n+\n@@ -154,0 +189,1 @@\n+  const bool startup = DCmd_Source_Internal == source;\n@@ -155,1 +191,1 @@\n-    print_pending_exception(output, PENDING_EXCEPTION);\n+    handle_pending_exception(output, startup, PENDING_EXCEPTION);\n@@ -157,1 +193,1 @@\n-    if (DCmd_Source_Internal != source) {\n+    if (!startup) {\n@@ -165,3 +201,14 @@\n-  if (result != NULL) {\n-    const char* result_chars = java_lang_String::as_utf8_string(result);\n-    print_message(output, result_chars);\n+  if (startup) {\n+    if (log_is_enabled(Warning, jfr, startup))  {\n+      \/\/ if warning is set, assume user hasn't configured log level\n+      \/\/ Log to Info and reset to Warning. This way user can disable\n+      \/\/ default output by setting -Xlog:jfr+startup=error\/off\n+      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(jfr, startup));\n+      log(result, THREAD);\n+      LogConfiguration::configure_stdout(LogLevel::Warning, true, LOG_TAGS(jfr, startup));\n+    } else {\n+      log(result, THREAD);\n+    }\n+  } else {\n+      \/\/ Print output for jcmd or MXBean\n+      print_message(output, result, THREAD);\n@@ -264,1 +311,1 @@\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Boolean;)Ljava\/lang\/String;\";\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n@@ -330,1 +377,1 @@\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/Boolean;)Ljava\/lang\/String;\";\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n@@ -474,1 +521,1 @@\n-    \"Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Boolean;Ljava\/lang\/Boolean;)Ljava\/lang\/String;\";\n+    \"Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Boolean;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n@@ -544,1 +591,1 @@\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\";\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\";\n@@ -657,1 +704,1 @@\n-    \"Ljava\/lang\/Long;Ljava\/lang\/Boolean;)Ljava\/lang\/String;\";\n+    \"Ljava\/lang\/Long;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":65,"deletions":18,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-const char* JfrJavaSupport::c_str(jstring string, Thread* t) {\n+const char* JfrJavaSupport::c_str(oop string, Thread* t) {\n@@ -493,6 +493,2 @@\n-  if (string == NULL) {\n-    return NULL;\n-  }\n-  const char* temp = NULL;\n-  const oop java_string = resolve_non_null(string);\n-  const typeArrayOop value = java_lang_String::value(java_string);\n+  char* resource_copy = NULL;\n+  const typeArrayOop value = java_lang_String::value(string);\n@@ -500,5 +496,5 @@\n-    const size_t length = java_lang_String::utf8_length(java_string, value);\n-    temp = NEW_RESOURCE_ARRAY_IN_THREAD(t, const char, (length + 1));\n-    if (temp == NULL) {\n-       JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate thread local native memory\", t);\n-       return NULL;\n+    const int length = java_lang_String::utf8_length(string, value);\n+    resource_copy = NEW_RESOURCE_ARRAY_IN_THREAD(t, char, (length + 1));\n+    if (resource_copy == NULL) {\n+      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate thread local native memory\", t);\n+      return NULL;\n@@ -506,2 +502,2 @@\n-    assert(temp != NULL, \"invariant\");\n-    java_lang_String::as_utf8_string(java_string, value, const_cast<char*>(temp), (int) length + 1);\n+    assert(resource_copy != NULL, \"invariant\");\n+    java_lang_String::as_utf8_string(string, value, resource_copy, length + 1);\n@@ -509,1 +505,7 @@\n-  return temp;\n+  return resource_copy;\n+}\n+\n+\/\/ caller needs ResourceMark\n+const char* JfrJavaSupport::c_str(jstring string, Thread* t) {\n+  DEBUG_ONLY(check_java_thread_in_vm(t));\n+  return string != NULL ? c_str(resolve_non_null(string), t) : NULL;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  static const char* c_str(oop string, Thread* t);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+  LOG_TAG(startup) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n@@ -53,7 +51,2 @@\n-    private final StringWriter result;\n-    private final PrintWriter log;\n-\n-    protected AbstractDCmd() {\n-        result = new StringWriter();\n-        log = new PrintWriter(result);\n-    }\n+    private final StringBuilder currentLine = new StringBuilder(80);\n+    private final List<String> lines = new ArrayList<>();\n@@ -65,2 +58,2 @@\n-    public final String getResult() {\n-        return result.toString();\n+    public final String[] getResult() {\n+        return lines.toArray(new String[lines.size()]);\n@@ -139,1 +132,2 @@\n-        log.println();\n+        lines.add(currentLine.toString());\n+        currentLine.setLength(0);\n@@ -143,1 +137,1 @@\n-        log.print(s);\n+        currentLine.append(s);\n@@ -147,1 +141,1 @@\n-        log.printf(s, args);\n+        currentLine.append(String.format(s, args));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    public String execute(String recordingText, Boolean verbose) throws DCmdException {\n+    public String[] execute(String recordingText, Boolean verbose) throws DCmdException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public String execute\n+    public String[] execute\n@@ -180,1 +180,1 @@\n-            return \"\";\n+            return new String[0];\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    public String execute(String name, String filename, Long maxAge, Long maxSize, String begin, String end, Boolean pathToGcRoots) throws DCmdException {\n+    public String[] execute(String name, String filename, Long maxAge, Long maxSize, String begin, String end, Boolean pathToGcRoots) throws DCmdException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    public String execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Long flush, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {\n+    public String[] execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Long flush, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    public String execute(String name, String filename) throws DCmdException {\n+    public String[] execute(String name, String filename) throws DCmdException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        ModulePathAndCP.run(\"-XX:StartFlightRecording=dumponexit=true\", \"-Xlog:cds+jvmti=debug\");\n+        ModulePathAndCP.run(\"-XX:StartFlightRecording=dumponexit=true\", \"-Xlog:cds+jvmti=debug,jfr+startup=off\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP_JFR.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private static final String NEW_LINE = System.getProperty(\"line.separator\");\n+    private static final String NEW_LINE = \"\\n\";\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/JcmdAsserts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.startupargs;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main jdk.jfr.startupargs.TestStartupMessage\n+ *\/\n+public class TestStartupMessage {\n+\n+    public static class TestMessage {\n+        public static void main(String[] args) throws Exception {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+         startJfrJvm(\"-Xlog:jfr+startup=off\")\n+             .shouldNotContain(\"[jfr,startup\")\n+             .shouldNotContain(\"Started recording\")\n+             .shouldNotContain(\"Use jcmd\");\n+\n+         startJfrJvm(\"-Xlog:jfr+startup=error\")\n+             .shouldNotContain(\"[jfr,startup\")\n+             .shouldNotContain(\"Started recording\")\n+             .shouldNotContain(\"Use jcmd\");\n+\n+         \/\/ Known limitation.\n+         \/\/ Can't turn off log with -Xlog:jfr+startup=warning\n+\n+         startJfrJvm()\n+             .shouldContain(\"[info][jfr,startup\")\n+             .shouldContain(\"Started recording\")\n+             .shouldContain(\"Use jcmd\");\n+\n+         startJfrJvm(\"-Xlog:jfr+startup=info\")\n+             .shouldContain(\"[info][jfr,startup\")\n+             .shouldContain(\"Started recording\")\n+             .shouldContain(\"Use jcmd\");\n+    }\n+\n+    private static OutputAnalyzer startJfrJvm(String... args) throws Exception {\n+        List<String> commands = new ArrayList<>(Arrays.asList(args));\n+        commands.add(\"-XX:StartFlightRecording\");\n+        commands.add(TestMessage.class.getName());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(commands);\n+        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n+        out.shouldHaveExitValue(0);\n+        return out;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartupMessage.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}