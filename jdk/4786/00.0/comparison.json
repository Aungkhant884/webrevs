{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +36,1 @@\n-    _instance->_lock.wait();\n+    _instance->_lock.lock();\n@@ -39,1 +40,1 @@\n-    _instance->_lock.signal();\n+    _instance->_lock.unlock();\n@@ -54,1 +55,2 @@\n-  _sem.signal();\n+  _data_available = true;\n+  _lock.notify();\n@@ -78,1 +80,1 @@\n-  : _lock(1), _sem(0), _flush_sem(0),\n+  : _flush_sem(0), _lock(), _data_available(false),\n@@ -128,0 +130,1 @@\n+    _data_available = false;\n@@ -155,3 +158,8 @@\n-    \/\/ The value of a semphore cannot be negative. Therefore, the current thread falls asleep\n-    \/\/ when its value is zero. It will be waken up when new messages are enqueued.\n-    _sem.wait();\n+    {\n+      AsyncLogLocker locker;\n+\n+      while (!_data_available) {\n+        _lock.wait(0\/* no timeout *\/);\n+      }\n+    }\n+\n@@ -201,1 +209,2 @@\n-      _instance->_sem.signal();\n+      _instance->_data_available = true;\n+      _instance->_lock.notify();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -144,6 +144,3 @@\n-  \/\/ _lock(1) denotes a critional region.\n-  Semaphore _lock;\n-  \/\/ _sem is a semaphore whose value denotes how many messages have been enqueued.\n-  \/\/ It decreases in AsyncLogWriter::run()\n-  Semaphore _sem;\n-\n+  \/\/ Can't use a Monitor here as we need a low-level API that can be used without Thread::current().\n+  os::PlatformMonitor _lock;\n+  bool _data_available;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3138,1 +3138,4 @@\n-    rmonitor->raw_enter(Thread::current());\n+    Thread* thread = Thread::current();\n+    \/\/ 8266889: raw_enter changes Java thread state, needs WXWrite\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));\n+    rmonitor->raw_enter(thread);\n@@ -3170,0 +3173,2 @@\n+  \/\/ 8266889: raw_wait changes Java thread state, needs WXWrite\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}