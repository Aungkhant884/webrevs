{"files":[{"patch":"@@ -47,1 +47,1 @@\n-    uint32_t* counter = _stats.add_if_absent(msg.output(), 0, &p_created);\n+    uint32_t* counter = _stats.put_if_absent(msg.output(), 0, &p_created);\n@@ -82,1 +82,1 @@\n-    _stats(17 \/*table_size*\/) {\n+    _stats() {\n@@ -98,1 +98,1 @@\n-  bool do_entry(LogFileOutput* output, uint32_t* counter) {\n+  bool do_entry(LogFileOutput* output, uint32_t& counter) {\n@@ -101,1 +101,1 @@\n-    if (*counter > 0) {\n+    if (counter > 0) {\n@@ -104,1 +104,1 @@\n-      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", counter);\n@@ -107,1 +107,1 @@\n-      *counter = 0;\n+      counter = 0;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -111,1 +111,7 @@\n-typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n+typedef ResourceHashtable<LogFileOutput*,\n+                          uint32_t,\n+                          primitive_hash<LogFileOutput*>,\n+                          primitive_equals<LogFileOutput*>,\n+                          17, \/*table_size*\/\n+                          ResourceObj::C_HEAP,\n+                          mtLogging> AsyncLogMap;\n@@ -158,2 +164,2 @@\n-  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n-  bool is_Named_thread() const override { return true; }\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n+  const char* type_name() const override { return \"AsyncLogWriter\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1329,3 +1329,1 @@\n-  {\n-    MutexLocker mu(current_thread, Threads_lock); \/\/ grab Threads_lock\n-    JvmtiAgentThread *new_thread = new JvmtiAgentThread(this, proc, arg);\n+  JvmtiAgentThread* new_thread = new JvmtiAgentThread(this, proc, arg);\n@@ -1334,12 +1332,7 @@\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory.\n-    if (new_thread == NULL || new_thread->osthread() == NULL) {\n-      if (new_thread != NULL) {\n-        new_thread->smr_delete();\n-      }\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-\n-    java_lang_Thread::set_thread(thread_hndl(), new_thread);\n-    java_lang_Thread::set_priority(thread_hndl(), (ThreadPriority)priority);\n-    java_lang_Thread::set_daemon(thread_hndl());\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources.\n+  if (new_thread->osthread() == NULL) {\n+    \/\/ The new thread is not known to Thread-SMR yet so we can just delete.\n+    delete new_thread;\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n@@ -1347,4 +1340,2 @@\n-    new_thread->set_threadObj(thread_hndl());\n-    Threads::add(new_thread);\n-    Thread::start(new_thread);\n-  } \/\/ unlock Threads_lock\n+  JavaThread::start_internal_daemon(current_thread, new_thread, thread_hndl,\n+                                    (ThreadPriority)priority);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"}]}