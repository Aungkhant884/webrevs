{"files":[{"patch":"@@ -208,1 +208,0 @@\n-JVM_StopThread\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1645,1 +1645,0 @@\n-int java_lang_Thread_FieldHolder::_stillborn_offset;\n@@ -1653,1 +1652,0 @@\n-  macro(_stillborn_offset,     k, \"stillborn\",                bool_signature,        false); \\\n@@ -1686,8 +1684,0 @@\n-bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {\n-  return holder->bool_field(_stillborn_offset) != 0;\n-}\n-\n-void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {\n-  holder->bool_field_put(_stillborn_offset, true);\n-}\n-\n@@ -1857,15 +1847,0 @@\n-bool java_lang_Thread::is_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_stillborn(holder);\n-}\n-\n-\n-\/\/ We never have reason to turn the stillborn bit off\n-void java_lang_Thread::set_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_stillborn(holder);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -382,3 +382,0 @@\n-  \/\/ Stillborn\n-  static bool is_stillborn(oop java_thread);\n-  static void set_stillborn(oop java_thread);\n@@ -437,1 +434,0 @@\n-  static int _stillborn_offset;\n@@ -453,3 +449,0 @@\n-  static bool is_stillborn(oop holder);\n-  static void set_stillborn(oop holder);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n@@ -200,1 +199,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  template(java_lang_ThreadDeath,                     \"java\/lang\/ThreadDeath\")                    \\\n@@ -397,1 +396,0 @@\n-  template(stillborn_name,                            \"stillborn\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,3 +269,0 @@\n-JNIEXPORT void JNICALL\n-JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -779,5 +779,1 @@\n-  if (!exception->is_a(vmClasses::ThreadDeath_klass())) {\n-    exception = get_preinitialized_exception(\n-                       vmClasses::IllegalMonitorStateException_klass(),\n-                       CATCH);\n-  }\n+  exception = get_preinitialized_exception(vmClasses::IllegalMonitorStateException_klass(), CATCH);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1583,4 +1583,1 @@\n-    if (exception->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n-    } else {\n-      java_lang_Throwable::print_stack_trace(exception, tty);\n+    java_lang_Throwable::print_stack_trace(exception, tty);\n@@ -1588,3 +1585,2 @@\n-      \/\/ Clear and ignore any exceptions raised during printing\n-      CLEAR_PENDING_EXCEPTION;\n-    }\n+    \/\/ Clear and ignore any exceptions raised during printing\n+    CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -578,2 +578,20 @@\n-    if (ex->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n+    jio_fprintf(defaultStream::error_stream(), \"Exception \");\n+    if (thread != NULL && thread->threadObj() != NULL) {\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"in thread \\\"%s\\\" \", thread->name());\n+    }\n+    if (ex->is_a(vmClasses::Throwable_klass())) {\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_virtual(&result,\n+                              ex,\n+                              vmClasses::Throwable_klass(),\n+                              vmSymbols::printStackTrace_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      \/\/ If an exception is thrown in the call it gets thrown away. Not much\n+      \/\/ we can do with it. The native code that calls this, does not check\n+      \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n+      \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n+      \/\/ is expected.\n+      CLEAR_PENDING_EXCEPTION;\n@@ -581,26 +599,4 @@\n-      jio_fprintf(defaultStream::error_stream(), \"Exception \");\n-      if (thread != NULL && thread->threadObj() != NULL) {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \"in thread \\\"%s\\\" \", thread->name());\n-      }\n-      if (ex->is_a(vmClasses::Throwable_klass())) {\n-        JavaValue result(T_VOID);\n-        JavaCalls::call_virtual(&result,\n-                                ex,\n-                                vmClasses::Throwable_klass(),\n-                                vmSymbols::printStackTrace_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        \/\/ If an exception is thrown in the call it gets thrown away. Not much\n-        \/\/ we can do with it. The native code that calls this, does not check\n-        \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n-        \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n-        \/\/ is expected.\n-        CLEAR_PENDING_EXCEPTION;\n-      } else {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \". Uncaught exception of type %s.\",\n-        ex->klass()->external_name());\n-      }\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \". Uncaught exception of type %s.\",\n+                  ex->klass()->external_name());\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2929,3 +2929,0 @@\n-      \/\/ We could also check the stillborn flag to see if this thread was already stopped, but\n-      \/\/ for historical reasons we let the thread detect that itself when it starts running\n-\n@@ -2984,39 +2981,0 @@\n-\/\/ JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints\n-\/\/ before the quasi-asynchronous exception is delivered.  This is a little obtrusive,\n-\/\/ but is thought to be reliable and simple. In the case, where the receiver is the\n-\/\/ same thread as the sender, no VM_Operation is needed.\n-JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))\n-  ThreadsListHandle tlh(thread);\n-  oop java_throwable = JNIHandles::resolve(throwable);\n-  if (java_throwable == NULL) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n-  }\n-  oop java_thread = NULL;\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, &java_thread);\n-  Events::log_exception(thread,\n-                        \"JVM_StopThread thread JavaThread \" INTPTR_FORMAT \" as oop \" INTPTR_FORMAT \" [exception \" INTPTR_FORMAT \"]\",\n-                        p2i(receiver), p2i(java_thread), p2i(throwable));\n-\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread.\n-    if (thread == receiver) {\n-      \/\/ Exception is getting thrown at self so no VM_Operation needed.\n-      THROW_OOP(java_throwable);\n-    } else {\n-      \/\/ Use a VM_Operation to throw the exception.\n-      JavaThread::send_async_exception(receiver, java_throwable);\n-    }\n-  } else {\n-    \/\/ Either:\n-    \/\/ - target thread has not been started before being stopped, or\n-    \/\/ - target thread already terminated\n-    \/\/ We could read the threadStatus to determine which case it is\n-    \/\/ but that is overkill as it doesn't matter. We must set the\n-    \/\/ stillborn flag for the first case, and if the thread has already\n-    \/\/ exited setting this flag has no effect.\n-    java_lang_Thread::set_stillborn(java_thread);\n-  }\n-JVM_END\n-\n-\n@@ -3096,1 +3054,1 @@\n-      \/\/ An asynchronous exception (e.g., ThreadDeathException) could have been thrown on\n+      \/\/ An asynchronous exception could have been thrown on\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  bool is_ThreadDeath()            { return _handshake_cl->is_ThreadDeath(); }\n@@ -448,3 +447,0 @@\n-static bool is_ThreadDeath_filter(HandshakeOperation* op) {\n-  return op->is_ThreadDeath();\n-}\n@@ -506,1 +502,1 @@\n-bool HandshakeState::has_async_exception_operation(bool ThreadDeath_only) {\n+bool HandshakeState::has_async_exception_operation() {\n@@ -509,5 +505,1 @@\n-  if (!ThreadDeath_only) {\n-    return _queue.peek(async_exception_filter) != NULL;\n-  } else {\n-    return _queue.peek(is_ThreadDeath_filter) != NULL;\n-  }\n+  return _queue.peek(async_exception_filter) != NULL;\n@@ -517,1 +509,1 @@\n-  while (has_async_exception_operation(\/* ThreadDeath_only *\/ false)) {\n+  while (has_async_exception_operation()) {\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  virtual bool is_ThreadDeath()                    { return false; }\n@@ -135,1 +134,1 @@\n-  bool has_async_exception_operation(bool ThreadDeath_only);\n+  bool has_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -690,5 +690,3 @@\n-  \/\/ Execute thread entry point unless this thread has a pending exception\n-  \/\/ or has been stopped before starting.\n-  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n-  if (!this->has_pending_exception() &&\n-      !java_lang_Thread::is_stillborn(this->threadObj())) {\n+  \/\/ Execute thread entry point unless this thread has a pending exception.\n+  \/\/ Note: Due to JVMTI StopThread we can have pending exceptions already!\n+  if (!this->has_pending_exception()) {\n@@ -722,2 +720,0 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n-  thread->clear_pending_exception();\n@@ -730,1 +726,1 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  \/\/ Ignore pending exception, since we are exiting anyway\n@@ -1070,22 +1066,17 @@\n-  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n-  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n-\n-    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n-    set_pending_exception(java_throwable, __FILE__, __LINE__);\n-\n-    \/\/ Clear any extent-local bindings on ThreadDeath\n-    set_extentLocalCache(NULL);\n-    oop threadOop = threadObj();\n-    assert(threadOop != NULL, \"must be\");\n-    java_lang_Thread::clear_extentLocalBindings(threadOop);\n-\n-    LogTarget(Info, exceptions) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n-      }\n-      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n+  \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+  set_pending_exception(java_throwable, __FILE__, __LINE__);\n+\n+  \/\/ Clear any extent-local bindings\n+  set_extentLocalCache(NULL);\n+  oop threadOop = threadObj();\n+  assert(threadOop != NULL, \"must be\");\n+  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+\n+  LogTarget(Info, exceptions) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+    if (has_last_Java_frame()) {\n+      frame f = last_frame();\n+      ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n@@ -1093,0 +1084,1 @@\n+    ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n@@ -1104,10 +1096,0 @@\n-  \/\/ Don't install a new pending async exception if there is already\n-  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n-  \/\/ wait()\/sleep()\/park() and return.\n-  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n-    java_lang_Thread::set_interrupted(threadObj(), true);\n-    this->interrupt();\n-    delete aeh;\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":22,"deletions":40,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-  bool has_async_exception_condition(bool ThreadDeath_only = false);\n+  bool has_async_exception_condition();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool _is_ThreadDeath;\n@@ -85,3 +84,1 @@\n-  : AsyncHandshakeClosure(name), _exception(o) {\n-    _is_ThreadDeath = exception()->is_a(vmClasses::ThreadDeath_klass());\n-  }\n+  : AsyncHandshakeClosure(name), _exception(o) { }\n@@ -111,1 +108,0 @@\n-  bool is_ThreadDeath()       { return _is_ThreadDeath; }\n@@ -132,2 +128,2 @@\n-inline bool JavaThread::has_async_exception_condition(bool ThreadDeath_only) {\n-  return handshake_state()->has_async_exception_operation(ThreadDeath_only);\n+inline bool JavaThread::has_async_exception_condition() {\n+  return handshake_state()->has_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,2 +77,1 @@\n-  if (!_pending_exception->is_a(vmClasses::ThreadDeath_klass()) &&\n-      (_pending_exception->klass() != vmClasses::InternalError_klass() ||\n+  if ((_pending_exception->klass() != vmClasses::InternalError_klass() ||\n@@ -430,1 +429,1 @@\n-      \/\/ of linkage error, or say ThreadDeath\/OutOfMemoryError\n+      \/\/ of linkage error, or say OutOfMemoryError\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError and j.l.ThreadDeath.\n+\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError.\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -250,1 +250,0 @@\n-        boolean stillborn;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}