{"files":[{"patch":"@@ -208,1 +208,0 @@\n-JVM_StopThread\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1645,1 +1645,0 @@\n-int java_lang_Thread_FieldHolder::_stillborn_offset;\n@@ -1653,1 +1652,0 @@\n-  macro(_stillborn_offset,     k, \"stillborn\",                bool_signature,        false); \\\n@@ -1686,8 +1684,0 @@\n-bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {\n-  return holder->bool_field(_stillborn_offset) != 0;\n-}\n-\n-void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {\n-  holder->bool_field_put(_stillborn_offset, true);\n-}\n-\n@@ -1857,15 +1847,0 @@\n-bool java_lang_Thread::is_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_stillborn(holder);\n-}\n-\n-\n-\/\/ We never have reason to turn the stillborn bit off\n-void java_lang_Thread::set_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_stillborn(holder);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -382,3 +382,0 @@\n-  \/\/ Stillborn\n-  static bool is_stillborn(oop java_thread);\n-  static void set_stillborn(oop java_thread);\n@@ -437,1 +434,0 @@\n-  static int _stillborn_offset;\n@@ -453,3 +449,0 @@\n-  static bool is_stillborn(oop holder);\n-  static void set_stillborn(oop holder);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n@@ -200,1 +199,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  template(java_lang_ThreadDeath,                     \"java\/lang\/ThreadDeath\")                    \\\n@@ -397,1 +396,0 @@\n-  template(stillborn_name,                            \"stillborn\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,3 +269,0 @@\n-JNIEXPORT void JNICALL\n-JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -779,5 +779,1 @@\n-  if (!exception->is_a(vmClasses::ThreadDeath_klass())) {\n-    exception = get_preinitialized_exception(\n-                       vmClasses::IllegalMonitorStateException_klass(),\n-                       CATCH);\n-  }\n+  exception = get_preinitialized_exception(vmClasses::IllegalMonitorStateException_klass(), CATCH);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1571,4 +1571,1 @@\n-    if (exception->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n-    } else {\n-      java_lang_Throwable::print_stack_trace(exception, tty);\n+    java_lang_Throwable::print_stack_trace(exception, tty);\n@@ -1576,3 +1573,2 @@\n-      \/\/ Clear and ignore any exceptions raised during printing\n-      CLEAR_PENDING_EXCEPTION;\n-    }\n+    \/\/ Clear and ignore any exceptions raised during printing\n+    CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -578,2 +578,20 @@\n-    if (ex->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n+    jio_fprintf(defaultStream::error_stream(), \"Exception \");\n+    if (thread != NULL && thread->threadObj() != NULL) {\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"in thread \\\"%s\\\" \", thread->name());\n+    }\n+    if (ex->is_a(vmClasses::Throwable_klass())) {\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_virtual(&result,\n+                              ex,\n+                              vmClasses::Throwable_klass(),\n+                              vmSymbols::printStackTrace_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      \/\/ If an exception is thrown in the call it gets thrown away. Not much\n+      \/\/ we can do with it. The native code that calls this, does not check\n+      \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n+      \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n+      \/\/ is expected.\n+      CLEAR_PENDING_EXCEPTION;\n@@ -581,26 +599,4 @@\n-      jio_fprintf(defaultStream::error_stream(), \"Exception \");\n-      if (thread != NULL && thread->threadObj() != NULL) {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \"in thread \\\"%s\\\" \", thread->name());\n-      }\n-      if (ex->is_a(vmClasses::Throwable_klass())) {\n-        JavaValue result(T_VOID);\n-        JavaCalls::call_virtual(&result,\n-                                ex,\n-                                vmClasses::Throwable_klass(),\n-                                vmSymbols::printStackTrace_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        \/\/ If an exception is thrown in the call it gets thrown away. Not much\n-        \/\/ we can do with it. The native code that calls this, does not check\n-        \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n-        \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n-        \/\/ is expected.\n-        CLEAR_PENDING_EXCEPTION;\n-      } else {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \". Uncaught exception of type %s.\",\n-        ex->klass()->external_name());\n-      }\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \". Uncaught exception of type %s.\",\n+                  ex->klass()->external_name());\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2929,3 +2929,0 @@\n-      \/\/ We could also check the stillborn flag to see if this thread was already stopped, but\n-      \/\/ for historical reasons we let the thread detect that itself when it starts running\n-\n@@ -2984,39 +2981,0 @@\n-\/\/ JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints\n-\/\/ before the quasi-asynchronous exception is delivered.  This is a little obtrusive,\n-\/\/ but is thought to be reliable and simple. In the case, where the receiver is the\n-\/\/ same thread as the sender, no VM_Operation is needed.\n-JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))\n-  ThreadsListHandle tlh(thread);\n-  oop java_throwable = JNIHandles::resolve(throwable);\n-  if (java_throwable == NULL) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n-  }\n-  oop java_thread = NULL;\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, &java_thread);\n-  Events::log_exception(thread,\n-                        \"JVM_StopThread thread JavaThread \" INTPTR_FORMAT \" as oop \" INTPTR_FORMAT \" [exception \" INTPTR_FORMAT \"]\",\n-                        p2i(receiver), p2i(java_thread), p2i(throwable));\n-\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread.\n-    if (thread == receiver) {\n-      \/\/ Exception is getting thrown at self so no VM_Operation needed.\n-      THROW_OOP(java_throwable);\n-    } else {\n-      \/\/ Use a VM_Operation to throw the exception.\n-      JavaThread::send_async_exception(receiver, java_throwable);\n-    }\n-  } else {\n-    \/\/ Either:\n-    \/\/ - target thread has not been started before being stopped, or\n-    \/\/ - target thread already terminated\n-    \/\/ We could read the threadStatus to determine which case it is\n-    \/\/ but that is overkill as it doesn't matter. We must set the\n-    \/\/ stillborn flag for the first case, and if the thread has already\n-    \/\/ exited setting this flag has no effect.\n-    java_lang_Thread::set_stillborn(java_thread);\n-  }\n-JVM_END\n-\n-\n@@ -3096,1 +3054,1 @@\n-      \/\/ An asynchronous exception (e.g., ThreadDeathException) could have been thrown on\n+      \/\/ An asynchronous exception could have been thrown on\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  bool is_ThreadDeath()            { return _handshake_cl->is_ThreadDeath(); }\n@@ -448,3 +447,0 @@\n-static bool is_ThreadDeath_filter(HandshakeOperation* op) {\n-  return op->is_ThreadDeath();\n-}\n@@ -506,1 +502,1 @@\n-bool HandshakeState::has_async_exception_operation(bool ThreadDeath_only) {\n+bool HandshakeState::has_async_exception_operation() {\n@@ -509,5 +505,1 @@\n-  if (!ThreadDeath_only) {\n-    return _queue.peek(async_exception_filter) != NULL;\n-  } else {\n-    return _queue.peek(is_ThreadDeath_filter) != NULL;\n-  }\n+  return _queue.peek(async_exception_filter) != NULL;\n@@ -517,1 +509,1 @@\n-  while (has_async_exception_operation(\/* ThreadDeath_only *\/ false)) {\n+  while (has_async_exception_operation()) {\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  virtual bool is_ThreadDeath()                    { return false; }\n@@ -135,1 +134,1 @@\n-  bool has_async_exception_operation(bool ThreadDeath_only);\n+  bool has_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -690,5 +690,3 @@\n-  \/\/ Execute thread entry point unless this thread has a pending exception\n-  \/\/ or has been stopped before starting.\n-  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n-  if (!this->has_pending_exception() &&\n-      !java_lang_Thread::is_stillborn(this->threadObj())) {\n+  \/\/ Execute thread entry point unless this thread has a pending exception.\n+  \/\/ Note: Due to JVMTI StopThread we can have pending exceptions already!\n+  if (!this->has_pending_exception()) {\n@@ -722,2 +720,0 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n-  thread->clear_pending_exception();\n@@ -730,1 +726,1 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  \/\/ Ignore pending exception, since we are exiting anyway\n@@ -1070,22 +1066,17 @@\n-  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n-  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n-\n-    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n-    set_pending_exception(java_throwable, __FILE__, __LINE__);\n-\n-    \/\/ Clear any extent-local bindings on ThreadDeath\n-    set_extentLocalCache(NULL);\n-    oop threadOop = threadObj();\n-    assert(threadOop != NULL, \"must be\");\n-    java_lang_Thread::clear_extentLocalBindings(threadOop);\n-\n-    LogTarget(Info, exceptions) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n-      }\n-      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n+  \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+  set_pending_exception(java_throwable, __FILE__, __LINE__);\n+\n+  \/\/ Clear any extent-local bindings\n+  set_extentLocalCache(NULL);\n+  oop threadOop = threadObj();\n+  assert(threadOop != NULL, \"must be\");\n+  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+\n+  LogTarget(Info, exceptions) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+    if (has_last_Java_frame()) {\n+      frame f = last_frame();\n+      ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n@@ -1093,0 +1084,1 @@\n+    ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n@@ -1104,10 +1096,0 @@\n-  \/\/ Don't install a new pending async exception if there is already\n-  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n-  \/\/ wait()\/sleep()\/park() and return.\n-  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n-    java_lang_Thread::set_interrupted(threadObj(), true);\n-    this->interrupt();\n-    delete aeh;\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":22,"deletions":40,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-  bool has_async_exception_condition(bool ThreadDeath_only = false);\n+  bool has_async_exception_condition();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool _is_ThreadDeath;\n@@ -85,3 +84,1 @@\n-  : AsyncHandshakeClosure(name), _exception(o) {\n-    _is_ThreadDeath = exception()->is_a(vmClasses::ThreadDeath_klass());\n-  }\n+  : AsyncHandshakeClosure(name), _exception(o) { }\n@@ -111,1 +108,0 @@\n-  bool is_ThreadDeath()       { return _is_ThreadDeath; }\n@@ -132,2 +128,2 @@\n-inline bool JavaThread::has_async_exception_condition(bool ThreadDeath_only) {\n-  return handshake_state()->has_async_exception_operation(ThreadDeath_only);\n+inline bool JavaThread::has_async_exception_condition() {\n+  return handshake_state()->has_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,2 +77,1 @@\n-  if (!_pending_exception->is_a(vmClasses::ThreadDeath_klass()) &&\n-      (_pending_exception->klass() != vmClasses::InternalError_klass() ||\n+  if ((_pending_exception->klass() != vmClasses::InternalError_klass() ||\n@@ -430,1 +429,1 @@\n-      \/\/ of linkage error, or say ThreadDeath\/OutOfMemoryError\n+      \/\/ of linkage error, or say OutOfMemoryError\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError and j.l.ThreadDeath.\n+\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError.\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,7 +193,0 @@\n-                   \/\/ evaluate possible precedence of flushException over closeException\n-                   if ((flushException instanceof ThreadDeath) &&\n-                       !(closeException instanceof ThreadDeath)) {\n-                       flushException.addSuppressed(closeException);\n-                       throw (ThreadDeath) flushException;\n-                   }\n-\n@@ -203,1 +196,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilterOutputStream.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2433,2 +2433,0 @@\n-                    ThreadDeath t = null;\n-                    boolean reset = false;\n@@ -2453,13 +2451,4 @@\n-                        do {\n-                            try {\n-                                curContext.setUsed();\n-                                if (oldContext!= null)\n-                                    oldContext.check();\n-                                curContext = oldContext;\n-                                reset = true;\n-                            } catch (ThreadDeath x) {\n-                                t = x;  \/\/ defer until reset is true\n-                            }\n-                        } while (!reset);\n-                        if (t != null)\n-                            throw t;\n+                        curContext.setUsed();\n+                        if (oldContext!= null)\n+                            oldContext.check();\n+                        curContext = oldContext;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n- * The {@code ThreadDeath} error, though a \"normal\" condition,\n- * is also a subclass of {@code Error} because most applications\n- * should not try to catch it.\n@@ -45,1 +42,0 @@\n- * @see     java.lang.ThreadDeath\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Error.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,10 +182,0 @@\n- *   <th scope=\"row\">stopThread<\/th>\n- *   <td>Stopping of threads via calls to the Thread {@code stop}\n- * method<\/td>\n- *   <td>This allows code to stop any thread in the system provided that it is\n- * already granted permission to access that thread.\n- * This poses as a threat, because that code may corrupt the system by\n- * killing existing threads.<\/td>\n- * <\/tr>\n- *\n- * <tr>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/RuntimePermission.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -132,3 +132,1 @@\n-                if (t instanceof ThreadDeath td) {\n-                    throw td;\n-                }\n+                \/\/ ignore\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Shutdown.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,1 +250,0 @@\n-        boolean stillborn;\n@@ -1632,35 +1631,1 @@\n-     * Forces the thread to stop executing.\n-     * <p>\n-     * If there is a security manager installed, its {@code checkAccess}\n-     * method is called with {@code this}\n-     * as its argument. This may result in a\n-     * {@code SecurityException} being raised (in the current thread).\n-     * <p>\n-     * If this thread is different from the current thread (that is, the current\n-     * thread is trying to stop a thread other than itself), the\n-     * security manager's {@code checkPermission} method (with a\n-     * {@code RuntimePermission(\"stopThread\")} argument) is called in\n-     * addition.\n-     * Again, this may result in throwing a\n-     * {@code SecurityException} (in the current thread).\n-     * <p>\n-     * The thread represented by this thread is forced to stop whatever\n-     * it is doing abnormally and to throw a newly created\n-     * {@code ThreadDeath} object as an exception.\n-     * <p>\n-     * It is permitted to stop a thread that has not yet been started.\n-     * If the thread is eventually started, it immediately terminates.\n-     * <p>\n-     * An application should not normally try to catch\n-     * {@code ThreadDeath} unless it must do some extraordinary\n-     * cleanup operation (note that the throwing of\n-     * {@code ThreadDeath} causes {@code finally} clauses of\n-     * {@code try} statements to be executed before the thread\n-     * officially terminates).  If a {@code catch} clause catches a\n-     * {@code ThreadDeath} object, it is important to rethrow the\n-     * object so that the thread actually terminates.\n-     * <p>\n-     * The top-level error handler that reacts to otherwise uncaught\n-     * exceptions does not print out a message or otherwise notify the\n-     * application if the uncaught exception is an instance of\n-     * {@code ThreadDeath}.\n+     * Throws {@code UnsupportedOperationException}.\n@@ -1668,13 +1633,7 @@\n-     * @throws     SecurityException  if the current thread cannot\n-     *             modify this thread.\n-     * @throws     UnsupportedOperationException if invoked on a virtual thread\n-     * @see        #interrupt()\n-     * @see        #checkAccess()\n-     * @see        ThreadDeath\n-     * @see        ThreadGroup#uncaughtException(Thread,Throwable)\n-     * @see        SecurityManager#checkAccess(Thread)\n-     * @see        SecurityManager#checkPermission\n-     * @deprecated This method is inherently unsafe.  Stopping a thread with\n-     *       Thread.stop causes it to unlock all of the monitors that it\n-     *       has locked (as a natural consequence of the unchecked\n-     *       {@code ThreadDeath} exception propagating up the stack).  If\n+     * @throws  UnsupportedOperationException always\n+     *\n+     * @deprecated This method was originally specified to \"stop\" a victim\n+     *       thread by causing the victim thread to throw a {@link ThreadDeath}.\n+     *       It was inherently unsafe. Stopping a thread caused it to unlock\n+     *       all of the monitors that it had locked (as a natural consequence\n+     *       of the {@code ThreadDeath} exception propagating up the stack). If\n@@ -1682,3 +1641,3 @@\n-     *       an inconsistent state, the damaged objects become visible to\n-     *       other threads, potentially resulting in arbitrary behavior.  Many\n-     *       uses of {@code stop} should be replaced by code that simply\n+     *       an inconsistent state, the damaged objects became visible to\n+     *       other threads, potentially resulting in arbitrary behavior.\n+     *       Usages of {@code stop} should be replaced by code that simply\n@@ -1698,20 +1657,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            checkAccess();\n-            if (this != Thread.currentThread()) {\n-                security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);\n-            }\n-        }\n-\n-        if (isVirtual())\n-            throw new UnsupportedOperationException();\n-\n-        \/\/ A zero status value corresponds to \"NEW\", it can't change to\n-        \/\/ not-NEW because we hold the lock.\n-        if (holder.threadStatus != 0) {\n-            resume(); \/\/ Wake up thread if it was suspended; no-op otherwise\n-        }\n-\n-        \/\/ The VM can handle all thread states\n-        stop0(new ThreadDeath());\n+        throw new UnsupportedOperationException();\n@@ -3097,1 +3037,0 @@\n-    private native void stop0(Object o);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":12,"deletions":73,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * An instance of {@code ThreadDeath} is thrown in the victim thread\n- * when the (deprecated) {@link Thread#stop()} method is invoked.\n+ * An instance of {@code ThreadDeath} was originally specified to be thrown\n+ * by a victim thread when \"stopped\" with {@link Thread#stop()}.\n@@ -32,13 +32,6 @@\n- * <p>An application should catch instances of this class only if it\n- * must clean up after being terminated asynchronously.  If\n- * {@code ThreadDeath} is caught by a method, it is important that it\n- * be rethrown so that the thread actually dies.\n- *\n- * <p>The {@linkplain ThreadGroup#uncaughtException top-level error\n- * handler} does not print out a message if {@code ThreadDeath} is\n- * never caught.\n- *\n- * <p>The class {@code ThreadDeath} is specifically a subclass of\n- * {@code Error} rather than {@code Exception}, even though it is a\n- * \"normal occurrence\", because many applications catch all\n- * occurrences of {@code Exception} and then discard the exception.\n+ * @deprecated {@link Thread#stop()} was originally specified to \"stop\" a victim\n+ *      thread by causing the victim thread to throw a {@code ThreadDeath}. It\n+ *      was inherently unsafe and deprecated in an early JDK release. The ability\n+ *      to \"stop\" a thread with {@code Thread.stop} has been removed and the\n+ *      {@code Thread.stop} method changed to throw an exception. Consequently,\n+ *      {@code ThreadDeath} is also deprecated, for removal.\n@@ -48,1 +41,1 @@\n-\n+@Deprecated(since=\"20\", forRemoval=true)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadDeath.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -677,6 +677,3 @@\n-     * <li>Otherwise, this method determines if the {@code Throwable}\n-     *     argument is an instance of {@link ThreadDeath}. If so, nothing\n-     *     special is done. Otherwise, a message containing the\n-     *     thread's name, as returned from the thread's {@link\n-     *     Thread#getName getName} method, and a stack backtrace,\n-     *     using the {@code Throwable}'s {@link\n+     * <li>Otherwise, a message containing the thread's name, as returned\n+     *     from the thread's {@link Thread#getName getName} method, and a\n+     *     stack backtrace, using the {@code Throwable}'s {@link\n@@ -702,3 +699,2 @@\n-            } else if (!(e instanceof ThreadDeath)) {\n-                System.err.print(\"Exception in thread \\\"\"\n-                                 + t.getName() + \"\\\" \");\n+            } else {\n+                System.err.print(\"Exception in thread \\\"\" + t.getName() + \"\\\" \");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,5 @@\n-<h2>Why is <code>Thread.stop<\/code> deprecated?<\/h2>\n-<p>Because it is inherently unsafe. Stopping a thread causes it to\n-unlock all the monitors that it has locked. (The monitors are\n-unlocked as the <code>ThreadDeath<\/code> exception propagates up\n+<h2>Why is <code>Thread.stop<\/code> deprecated and the ability to\n+stop a thread removed?<\/h2>\n+<p>Because it was inherently unsafe. Stopping a thread caused it to\n+unlock all the monitors that it had locked. (The monitors were\n+unlocked as the <code>ThreadDeath<\/code> exception propagated up\n@@ -39,1 +40,1 @@\n-monitors were in an inconsistent state, other threads may now view\n+monitors were in an inconsistent state, other threads may have viewed\n@@ -44,2 +45,2 @@\n-<code>ThreadDeath<\/code> kills threads silently; thus, the user has\n-no warning that his program may be corrupted. The corruption can\n+<code>ThreadDeath<\/code> killed threads silently; thus, the user had\n+no warning that their program may be corrupted. The corruption could\n@@ -49,2 +50,2 @@\n-<h2>Couldn't I just catch the <code>ThreadDeath<\/code> exception\n-and fix the damaged object?<\/h2>\n+<h2>Couldn't I have just caught <code>ThreadDeath<\/code> and fixed\n+the damaged object?<\/h2>\n@@ -55,1 +56,1 @@\n-<li>A thread can throw a <code>ThreadDeath<\/code> exception\n+<li>A thread could throw a <code>ThreadDeath<\/code> exception\n@@ -58,1 +59,1 @@\n-<li>A thread can throw a second <code>ThreadDeath<\/code> exception\n+<li>A thread could throw a second <code>ThreadDeath<\/code> exception\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-            \/\/ method is inaccessible, or say ThreadDeath\/OutOfMemoryError\n+            \/\/ method is inaccessible, or say OutOfMemoryError\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-            \/\/ method is inaccessible, or say ThreadDeath\/OutOfMemoryError\n+            \/\/ method is inaccessible, or say OutOfMemoryError\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/CallSite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,4 +127,0 @@\n-    \/\/ java.lang.Thread\n-    public static final RuntimePermission STOP_THREAD_PERMISSION =\n-       new RuntimePermission(\"stopThread\");\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityConstants.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-    {\"stop0\",            \"(\" OBJ \")V\", (void *)&JVM_StopThread},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,5 +170,0 @@\n-            } catch (ThreadDeath td) {\n-                \/\/XXX: if there isn't native code on the stack, the VM just\n-                \/\/kills the thread right away. Do we expect to catch it\n-                \/\/nevertheless?\n-                break;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWToolkit.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,4 +205,0 @@\n-        catch (ThreadDeath death) {\n-            doDispatch = false;\n-            throw death;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/EventDispatchThread.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -201,7 +201,0 @@\n-        }\n-        catch (ThreadDeath td) {\n-            \/\/ Mark all the timers we contain as not being queued.\n-            for (DelayedTimer delayedTimer : queue) {\n-                delayedTimer.getTimer().cancelEvent();\n-            }\n-            throw td;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TimerQueue.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2389,5 +2389,0 @@\n-        } catch (ThreadDeath e) {\n-            errorContext();\n-            error(\"terminated\");\n-            e.printStackTrace();\n-            throw e;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/parser\/Parser.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -730,3 +730,0 @@\n-            } catch (ThreadDeath td) {\n-                XBaseWindow.ungrabInput();\n-                return;\n@@ -1997,2 +1994,0 @@\n-                } catch (ThreadDeath td) {\n-                    throw td;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2669,2 +2669,0 @@\n-            } catch (ThreadDeath death) {\n-                throw death;\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/LogManager.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1033,1 +1033,1 @@\n-             catch (VirtualMachineError | ThreadDeath vme) {\n+             catch (VirtualMachineError vme) {\n@@ -1049,1 +1049,1 @@\n-            catch (VirtualMachineError | ThreadDeath vme) {\n+            catch (VirtualMachineError vme) {\n@@ -1065,1 +1065,1 @@\n-            catch (VirtualMachineError | ThreadDeath vme) {\n+            catch (VirtualMachineError vme) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/serialize\/DOMSerializerImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,4 +264,0 @@\n-                        if (t instanceof ThreadDeath) {\n-                            ThreadDeath td = (ThreadDeath)t;\n-                            throw td;\n-                        }\n","filename":"src\/jdk.attach\/share\/classes\/com\/sun\/tools\/attach\/spi\/AttachProvider.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,3 +78,0 @@\n-            if (t instanceof ThreadDeath) {\n-                throw (ThreadDeath)t;\n-            }\n@@ -104,3 +101,1 @@\n-                if (t instanceof ThreadDeath) {\n-                    throw (ThreadDeath)t;\n-                }\n+                \/\/ ignore\n@@ -141,4 +136,0 @@\n-            if (t instanceof ThreadDeath) {\n-                ThreadDeath td = (ThreadDeath)t;\n-                throw td;\n-            }\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotAttachProvider.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,6 +102,1 @@\n-            } catch (ThreadDeath x) {\n-                throw x;\n-            } catch (Exception x) {\n-                System.err.println(x);\n-                continue;\n-            } catch (Error x) {\n+            } catch (Exception | Error x) {\n@@ -131,6 +126,1 @@\n-            } catch (ThreadDeath x) {\n-                throw x;\n-            } catch (Exception x) {\n-                System.err.println(x);\n-                continue;\n-            } catch (Error x) {\n+            } catch (Exception | Error x) {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineManagerImpl.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-    @SuppressWarnings(\"serial\")             \/\/ serialVersionUID intentionally omitted\n+    @SuppressWarnings({\"serial\", \"removal\"})       \/\/ serialVersionUID intentionally omitted\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8289610\n+ * @summary Test Thread.stop throws UnsupportedOperationException\n+ * @run testng StopTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class StopTest {\n+\n+    \/**\n+     * Test stop on the current thread.\n+     *\/\n+    @Test\n+    public void testCurrentThread() {\n+        var thread = Thread.currentThread();\n+        assertThrows(UnsupportedOperationException.class, thread::stop);\n+    }\n+\n+    \/**\n+     * Test stop on an unstarted thread.\n+     *\/\n+    @Test\n+    public void testUnstartedThread() {\n+        Thread thread = new Thread(() -> { });\n+        assertThrows(UnsupportedOperationException.class, thread::stop);\n+        assertTrue(thread.getState() == Thread.State.NEW);\n+    }\n+\n+    \/**\n+     * Test stop on a thread spinning in a loop.\n+     *\/\n+    @Test\n+    public void testRunnableThread() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        Thread thread = new Thread(() -> {\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        thread.start();\n+        try {\n+            assertThrows(UnsupportedOperationException.class, thread::stop);\n+\n+            \/\/ thread should not terminate\n+            boolean terminated = thread.join(Duration.ofMillis(500));\n+            assertFalse(terminated);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test stop on a thread that is parked.\n+     *\/\n+    @Test\n+    public void testWaitingThread() throws Exception {\n+        Thread thread = new Thread(LockSupport::park);\n+        thread.start();\n+        try {\n+            \/\/ wait for thread to park\n+            while ((thread.getState() != Thread.State.WAITING)) {\n+                Thread.sleep(10);\n+            }\n+            assertThrows(UnsupportedOperationException.class, thread::stop);\n+            assertTrue(thread.getState() == Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test stop on a terminated thread.\n+     *\/\n+    @Test\n+    public void testTerminatedThread() throws Exception {\n+        Thread thread = new Thread(() -> { });\n+        thread.start();\n+        thread.join();\n+        assertThrows(UnsupportedOperationException.class, thread::stop);\n+        assertTrue(thread.getState() == Thread.State.TERMINATED);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/StopTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}