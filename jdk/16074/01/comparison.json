{"files":[{"patch":"@@ -61,0 +61,4 @@\n+void VM_ShenandoahFinalMarkStartEvac::doit_epilogue() {\n+  OopMapCache::cleanup_old_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-  virtual  void doit();\n+  virtual void doit();\n+  virtual void doit_epilogue();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -132,0 +133,1 @@\n+    OopMapCache::cleanup_old_entries();\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -449,0 +450,1 @@\n+    OopMapCache::cleanup_old_entries();\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,3 +445,0 @@\n-    \/\/ Workaround OopMapCacheAlloc_lock reordering with the StackWatermark_lock\n-    DisableIsGCActiveMark mark;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -491,1 +492,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"called by RedefineClasses in a safepoint\");\n+  GlobalCounter::CriticalSection cs(Thread::current());\n@@ -493,1 +494,1 @@\n-    OopMapCacheEntry* entry = _array[i];\n+    OopMapCacheEntry* entry = entry_at(i);\n@@ -503,2 +504,4 @@\n-      _array[i] = nullptr;\n-      OopMapCacheEntry::deallocate(entry);\n+\n+      if (Atomic::cmpxchg(&_array[i], entry, (OopMapCacheEntry*)nullptr, memory_order_relaxed) == entry) {\n+        enqueue_for_cleanup(entry);\n+      }\n@@ -514,1 +517,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"called by GC in a safepoint\");\n@@ -527,8 +529,11 @@\n-  \/\/ Search hashtable for match\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n-    if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n-      entry_for->resource_copy(entry);\n-      assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n-      log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n-      return;\n+  {\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    \/\/ Search hashtable for match\n+    for(i = 0; i < _probe_depth; i++) {\n+      entry = entry_at(probe + i);\n+      if (entry != nullptr && !entry->is_empty() && !entry->method()->is_old() && entry->match(method, bci)) {\n+        entry_for->resource_copy(entry);\n+        assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n+        log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n+        return;\n+      }\n@@ -600,2 +605,7 @@\n-  OopMapCacheEntry* entry = _old_entries;\n-  _old_entries = nullptr;\n+  OopMapCacheEntry* entry = Atomic::xchg(&_old_entries, (OopMapCacheEntry*)nullptr);\n+  if (entry == nullptr) {\n+    return;\n+  }\n+\n+  GlobalCounter::write_synchronize();\n+\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1636,6 +1636,5 @@\n-    MutexLocker x(OopMapCacheAlloc_lock);\n-    \/\/ Check if _oop_map_cache was allocated while we were waiting for this lock\n-    if ((oop_map_cache = _oop_map_cache) == nullptr) {\n-      oop_map_cache = new OopMapCache();\n-      \/\/ Ensure _oop_map_cache is stable, since it is examined without a lock\n-      Atomic::release_store(&_oop_map_cache, oop_map_cache);\n+    oop_map_cache = new OopMapCache();\n+    OopMapCache* existing_cache = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n+    if (existing_cache != nullptr) {\n+      delete oop_map_cache;\n+      oop_map_cache = existing_cache;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -311,8 +311,1 @@\n-  \/\/ Only GC uses the OopMapCache during thread stack root scanning\n-  \/\/ any other uses generate an oopmap but do not save it in the cache.\n-  if (Universe::heap()->is_gc_active()) {\n-    method_holder()->mask_for(h_this, bci, mask);\n-  } else {\n-    OopMapCache::compute_one_oop_map(h_this, bci, mask);\n-  }\n-  return;\n+  method_holder()->mask_for(h_this, bci, mask);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -314,0 +314,2 @@\n+  OopMapCache::cleanup_old_entries();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-Mutex*   OopMapCacheAlloc_lock        = nullptr;\n@@ -359,1 +358,0 @@\n-  MUTEX_DEFL(OopMapCacheAlloc_lock          , PaddedMutex  ,  Threads_lock, true);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-extern Mutex*   OopMapCacheAlloc_lock;           \/\/ protects allocation of oop_map caches\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}