{"files":[{"patch":"@@ -366,1 +366,1 @@\n-                count = 0;\n+                underflowToZero(maximumDigits);\n@@ -395,0 +395,44 @@\n+    \/**\n+     * Determine if a number should create a 1 in the least significant location\n+     * if truncating the representation to the given number of digits would\n+     * violate the current RoundingMode contract.\n+     * @param maximumDigits The maximum number of digits to be shown.\n+     *\n+     * Upon return, count will either be one or zero.\n+     *\/\n+    private void underflowToZero(int maximumDigits) {\n+        switch(roundingMode) {\n+            case UP:\n+                \/\/ RoundingMode.UP can not decrease the magnitude of the value\n+                \/\/ whether negative or positive.\n+                decimalAt = -maximumDigits + 1;\n+                digits[0] = '1';\n+                count = 1;\n+                break;\n+            case CEILING:\n+                \/\/ RoundingMode.CEILING follows RoundingMode.UP behavior when\n+                \/\/ the value is positive\n+                if (!isNegative) {\n+                    decimalAt = -maximumDigits + 1;\n+                    digits[0] = '1';\n+                    count = 1;\n+                } else {\n+                    count = 0;\n+                }\n+                break;\n+            case FLOOR:\n+                \/\/ RoundingMode.FLOOR can not increase the value\n+                \/\/ when negative\n+                if (isNegative) {\n+                    decimalAt = -maximumDigits + 1;\n+                    digits[0] = '1';\n+                    count = 1;\n+                } else {\n+                    count = 0;\n+                }\n+                break;\n+            default:\n+                count = 0;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8174722\n+* @summary Tests underflow for rounding values < abs(0.1) in DecimalFormat\n+* @run junit UnderflowToZero\n+*\/\n+\n+import java.math.RoundingMode;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class UnderflowToZero {\n+    private static final List<RoundingMode> MODES;\n+    private static final String ERRMSG = \"%f formatted with pattern %s and mode \" +\n+            \"%s gives %s but %f formatted with the same pattern and mode gives %s\";\n+\n+    static {\n+        MODES = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n+        MODES.remove(RoundingMode.UNNECESSARY);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"patternAndNumbers\")\n+    public void testModes(double bigger, double smaller, String pattern) {\n+        DecimalFormat df = new DecimalFormat();\n+        df.applyPattern(pattern);\n+        for (RoundingMode mode : MODES) {\n+            testFormat(bigger, smaller, pattern, mode, df);\n+        }\n+    }\n+\n+    @Test\n+    public void testZero() {\n+        DecimalFormat df = new DecimalFormat();\n+        df.applyPattern(\"0.0\");\n+        for (RoundingMode mode : MODES) {\n+            df.setRoundingMode(mode);\n+            String decimalFormatted = df.format(0.0000);\n+            assertEquals(decimalFormatted, \"0.0\");\n+        }\n+    }\n+\n+    \/\/ Ensure formatting values less than abs(.1) adheres\n+    \/\/ to contracts of rounding modes. To ensure this, we can compare\n+    \/\/ the fractional portion of the result to the fractional portion\n+    \/\/ of the same value +- 1;\n+    private void testFormat(double bigger, double smaller, String pattern,\n+                            RoundingMode mode, DecimalFormat df) {\n+        df.setRoundingMode(mode);\n+        \/\/ Compare the fractional part of both numbers\n+        \/\/ Eg: Compare 1.(0001) to 0.(0001)\n+        String biggerFormatted = df.format(bigger).split(\"\\\\.\")[1];\n+        String smallerFormatted = df.format(smaller).split(\"\\\\.\")[1];\n+        assertEquals(biggerFormatted, smallerFormatted, String.format(ERRMSG, bigger, pattern,\n+                mode, df.format(bigger), smaller, df.format(smaller)));\n+    }\n+\n+    private static Stream<Arguments> patternAndNumbers() {\n+        return Stream.of(\n+                Arguments.of(1.0001, 0.0001, \"0.0\"),\n+                Arguments.of(1.0001, 0.0001, \"0.00\"),\n+                Arguments.of(1.0001, 0.0001, \"0.000\"),\n+\n+                Arguments.of(-1.0001, -0.0001, \"0.0\"),\n+                Arguments.of(-1.0001, -0.0001, \"0.00\"),\n+                Arguments.of(-1.0001, -0.0001, \"0.000\"),\n+\n+                Arguments.of(1.0009, 0.0009, \"0.0\"),\n+                Arguments.of(1.0009, 0.0009, \"0.00\"),\n+                Arguments.of(1.0009, 0.0009, \"0.000\"),\n+\n+                Arguments.of(-1.0009, -0.0009, \"0.0\"),\n+                Arguments.of(-1.0009, -0.0009, \"0.00\"),\n+                Arguments.of(-1.0009, -0.0009, \"0.000\"),\n+\n+                Arguments.of(1.0004545, 0.0004545, \"0.0\"),\n+                Arguments.of(1.0004545, 0.0004545, \"0.00\"),\n+                Arguments.of(1.0004545, 0.0004545, \"0.000\"),\n+\n+                Arguments.of(-1.0004545, -0.0004545, \"0.0\"),\n+                Arguments.of(-1.0004545, -0.0004545, \"0.00\"),\n+                Arguments.of(-1.0004545, -0.0004545, \"0.000\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/UnderflowToZero.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}