{"files":[{"patch":"@@ -366,1 +366,1 @@\n-                count = 0;\n+                underflowToZero(maximumDigits);\n@@ -395,0 +395,24 @@\n+    \/**\n+     * This method sets the Digit List to a state that is either\n+     * equivalent to zero, or a state with a 1 in the least significant location\n+     * if an underflow to zero would violate the current RoundingMode contract.\n+     *\n+     * This method does not return any value, and instead adjusts\n+     * the instance variables that the Digit List is composed of.\n+     *\n+     * @param maximumDigits The maximum number of digits to be shown.\n+     *\/\n+    private void underflowToZero(int maximumDigits) {\n+        \/\/ These modes under the right conditions should not\n+        \/\/ decrease the magnitude of the formatted value\n+        if (roundingMode == RoundingMode.UP\n+                || (roundingMode == RoundingMode.CEILING && !isNegative)\n+                || (roundingMode == RoundingMode.FLOOR && isNegative)) {\n+            decimalAt = -maximumDigits + 1;\n+            digits[0] = '1';\n+            count = 1;\n+        } else {\n+            count = 0;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+* @test\n+* @bug 8174722\n+* @summary Tests underflow for rounding values < abs(0.1) in DecimalFormat\n+* @run junit UnderflowToZero\n+*\/\n+\n+import java.math.RoundingMode;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class UnderflowToZero {\n+    private static final List<RoundingMode> MODES;\n+    private static final String ERRMSG = \"%f formatted with pattern %s and mode \" +\n+            \"%s gives %s\";\n+\n+    static {\n+        MODES = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n+        MODES.remove(RoundingMode.UNNECESSARY);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"numberAndPattern\")\n+    public void testModes(double num, String pattern) {\n+        DecimalFormat df = new DecimalFormat();\n+        df.applyPattern(pattern);\n+        for (RoundingMode mode : MODES) {\n+            testFormat(num, pattern, mode, df);\n+        }\n+    }\n+\n+    @Test\n+    public void testZero() {\n+        DecimalFormat df = new DecimalFormat();\n+        df.applyPattern(\"0.0\");\n+        for (RoundingMode mode : MODES) {\n+            df.setRoundingMode(mode);\n+            String decimalFormatted = df.format(0.0000);\n+            assertEquals(decimalFormatted, \"0.0\");\n+        }\n+    }\n+\n+    \/\/ Ensure formatting values less than abs(.1) adheres\n+    \/\/ to contracts of certain rounding modes\n+    private void testFormat(double smallNum, String pattern, RoundingMode mode,\n+                            DecimalFormat df) {\n+        validateData(smallNum, pattern);\n+        df.setRoundingMode(mode);\n+        df.applyPattern(pattern);\n+        String formattedNum = df.format(smallNum);\n+        long oneCount = formattedNum.chars().filter(ch -> ch == '1').count();\n+        String error = String.format(ERRMSG, smallNum, pattern, mode, formattedNum);\n+        if (shouldRound(smallNum, mode)) {\n+            \/\/ Expecting a single occurrence of 1 as the last digit\n+            assertEquals(\"1\", formattedNum.substring(\n+                    formattedNum.length() - 1), error);\n+            assertEquals(1, oneCount, error);\n+        } else {\n+            \/\/ Expecting no occurrences of 1\n+            assertEquals(\"0\", formattedNum.substring(\n+                    formattedNum.length() - 1), error);\n+            assertEquals(0, oneCount, error);\n+        }\n+    }\n+\n+    private Boolean shouldRound(double smallNum, RoundingMode mode) {\n+        if (mode == RoundingMode.UP) {\n+            return true;\n+        } else if (mode == RoundingMode.CEILING && smallNum > 0) {\n+            return true;\n+        } else return mode == RoundingMode.FLOOR && smallNum < 0;\n+    }\n+\n+    private void validateData(double number, String pattern) {\n+        \/\/ Sum 0s in pattern, exclude the integer 0\n+        long zeroCount = pattern.split(\"\\\\.\")[1].length();\n+        if (countZeros(number) <= zeroCount) {\n+            throw new RuntimeException(\"Data is not in right format, \" +\n+                    \"see comments above method source\");\n+        }\n+    }\n+\n+    \/\/ Utility function to count the fractional zeros\n+    \/\/ of a number less than abs(1)\n+    private int countZeros(double num) {\n+        int zeros = 0;\n+        double number = Math.abs(num);\n+        while (number < 1) {\n+            zeros = zeros + 1;\n+            number = number * 10;\n+        }\n+        return zeros - 1;\n+    }\n+\n+    \/\/ For the supplied data, the number must have more zeros between the decimal\n+    \/\/ and first non-zero digit than digits in the fractional portion of the pattern\n+    private static Stream<Arguments> numberAndPattern() {\n+        return Stream.of(\n+                Arguments.of(0.00001, \"0.0\"),\n+                Arguments.of(0.00001, \"0.00\"),\n+                Arguments.of(0.00001, \"0.000\"),\n+\n+                Arguments.of(-0.00001, \"0.0\"),\n+                Arguments.of(-0.00001, \"0.00\"),\n+                Arguments.of(-0.00001, \"0.000\"),\n+\n+                Arguments.of(0.00009, \"0.0\"),\n+                Arguments.of(0.00009, \"0.00\"),\n+                Arguments.of(0.00009, \"0.000\"),\n+\n+                Arguments.of(-0.00009, \"0.0\"),\n+                Arguments.of(-0.00009, \"0.00\"),\n+                Arguments.of(-0.00009, \"0.000\"),\n+\n+                Arguments.of(0.00004545, \"0.0\"),\n+                Arguments.of(0.00004545, \"0.00\"),\n+                Arguments.of(0.00004545, \"0.000\"),\n+\n+                Arguments.of(-0.00004545, \"0.0\"),\n+                Arguments.of(-0.00004545, \"0.00\"),\n+                Arguments.of(-0.00004545, \"0.000\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/UnderflowToZero.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}