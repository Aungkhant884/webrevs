{"files":[{"patch":"@@ -49,1 +49,1 @@\n-            \"%s gives %s but %f formatted with the same pattern and mode gives %s\";\n+            \"%s gives %s\";\n@@ -57,2 +57,2 @@\n-    @MethodSource(\"patternAndNumbers\")\n-    public void testModes(double bigger, double smaller, String pattern) {\n+    @MethodSource(\"numberAndPattern\")\n+    public void testModes(double num, String pattern) {\n@@ -62,1 +62,1 @@\n-            testFormat(bigger, smaller, pattern, mode, df);\n+            testFormat(num, pattern, mode, df);\n@@ -78,5 +78,4 @@\n-    \/\/ to contracts of rounding modes. To ensure this, we can compare\n-    \/\/ the fractional portion of the result to the fractional portion\n-    \/\/ of the same value +- 1;\n-    private void testFormat(double bigger, double smaller, String pattern,\n-                            RoundingMode mode, DecimalFormat df) {\n+    \/\/ to contracts of certain rounding modes\n+    private void testFormat(double smallNum, String pattern, RoundingMode mode,\n+                            DecimalFormat df) {\n+        validateData(smallNum, pattern);\n@@ -84,6 +83,44 @@\n-        \/\/ Compare the fractional part of both numbers\n-        \/\/ Eg: Compare 1.(0001) to 0.(0001)\n-        String biggerFormatted = df.format(bigger).split(\"\\\\.\")[1];\n-        String smallerFormatted = df.format(smaller).split(\"\\\\.\")[1];\n-        assertEquals(biggerFormatted, smallerFormatted, String.format(ERRMSG, bigger, pattern,\n-                mode, df.format(bigger), smaller, df.format(smaller)));\n+        df.applyPattern(pattern);\n+        String formattedNum = df.format(smallNum);\n+        long oneCount = formattedNum.chars().filter(ch -> ch == '1').count();\n+        String error = String.format(ERRMSG, smallNum, pattern, mode, formattedNum);\n+        if (shouldRound(smallNum, mode)) {\n+            \/\/ Expecting a single occurrence of 1 as the last digit\n+            assertEquals(\"1\", formattedNum.substring(\n+                    formattedNum.length() - 1), error);\n+            assertEquals(1, oneCount, error);\n+        } else {\n+            \/\/ Expecting no occurrences of 1\n+            assertEquals(\"0\", formattedNum.substring(\n+                    formattedNum.length() - 1), error);\n+            assertEquals(0, oneCount, error);\n+        }\n+    }\n+\n+    private Boolean shouldRound(double smallNum, RoundingMode mode) {\n+        if (mode == RoundingMode.UP) {\n+            return true;\n+        } else if (mode == RoundingMode.CEILING && smallNum > 0) {\n+            return true;\n+        } else return mode == RoundingMode.FLOOR && smallNum < 0;\n+    }\n+\n+    private void validateData(double number, String pattern) {\n+        \/\/ Sum 0s in pattern, exclude the integer 0\n+        long zeroCount = pattern.split(\"\\\\.\")[1].length();\n+        if (countZeros(number) <= zeroCount) {\n+            throw new RuntimeException(\"Data is not in right format, \" +\n+                    \"see comments above method source\");\n+        }\n+    }\n+\n+    \/\/ Utility function to count the fractional zeros\n+    \/\/ of a number less than abs(1)\n+    private int countZeros(double num) {\n+        int zeros = 0;\n+        double number = Math.abs(num);\n+        while (number < 1) {\n+            zeros = zeros + 1;\n+            number = number * 10;\n+        }\n+        return zeros - 1;\n@@ -92,1 +129,3 @@\n-    private static Stream<Arguments> patternAndNumbers() {\n+    \/\/ For the supplied data, the number must have more zeros between the decimal\n+    \/\/ and first non-zero digit than digits in the fractional portion of the pattern\n+    private static Stream<Arguments> numberAndPattern() {\n@@ -94,3 +133,3 @@\n-                Arguments.of(1.0001, 0.0001, \"0.0\"),\n-                Arguments.of(1.0001, 0.0001, \"0.00\"),\n-                Arguments.of(1.0001, 0.0001, \"0.000\"),\n+                Arguments.of(0.00001, \"0.0\"),\n+                Arguments.of(0.00001, \"0.00\"),\n+                Arguments.of(0.00001, \"0.000\"),\n@@ -98,3 +137,3 @@\n-                Arguments.of(-1.0001, -0.0001, \"0.0\"),\n-                Arguments.of(-1.0001, -0.0001, \"0.00\"),\n-                Arguments.of(-1.0001, -0.0001, \"0.000\"),\n+                Arguments.of(-0.00001, \"0.0\"),\n+                Arguments.of(-0.00001, \"0.00\"),\n+                Arguments.of(-0.00001, \"0.000\"),\n@@ -102,3 +141,3 @@\n-                Arguments.of(1.0009, 0.0009, \"0.0\"),\n-                Arguments.of(1.0009, 0.0009, \"0.00\"),\n-                Arguments.of(1.0009, 0.0009, \"0.000\"),\n+                Arguments.of(0.00009, \"0.0\"),\n+                Arguments.of(0.00009, \"0.00\"),\n+                Arguments.of(0.00009, \"0.000\"),\n@@ -106,3 +145,3 @@\n-                Arguments.of(-1.0009, -0.0009, \"0.0\"),\n-                Arguments.of(-1.0009, -0.0009, \"0.00\"),\n-                Arguments.of(-1.0009, -0.0009, \"0.000\"),\n+                Arguments.of(-0.00009, \"0.0\"),\n+                Arguments.of(-0.00009, \"0.00\"),\n+                Arguments.of(-0.00009, \"0.000\"),\n@@ -110,3 +149,3 @@\n-                Arguments.of(1.0004545, 0.0004545, \"0.0\"),\n-                Arguments.of(1.0004545, 0.0004545, \"0.00\"),\n-                Arguments.of(1.0004545, 0.0004545, \"0.000\"),\n+                Arguments.of(0.00004545, \"0.0\"),\n+                Arguments.of(0.00004545, \"0.00\"),\n+                Arguments.of(0.00004545, \"0.000\"),\n@@ -114,3 +153,3 @@\n-                Arguments.of(-1.0004545, -0.0004545, \"0.0\"),\n-                Arguments.of(-1.0004545, -0.0004545, \"0.00\"),\n-                Arguments.of(-1.0004545, -0.0004545, \"0.000\")\n+                Arguments.of(-0.00004545, \"0.0\"),\n+                Arguments.of(-0.00004545, \"0.00\"),\n+                Arguments.of(-0.00004545, \"0.000\")\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/UnderflowToZero.java","additions":73,"deletions":34,"binary":false,"changes":107,"status":"modified"}]}