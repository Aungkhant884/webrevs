{"files":[{"patch":"@@ -1299,11 +1299,15 @@\n-     * <p> If the underlying class is an array class, then its\n-     * {@code public}, {@code private} and {@code protected}\n-     * modifiers are the same as those of its component type.  If this\n-     * {@code Class} object represents a primitive type or void, its\n-     * {@code public} modifier is always {@code true}, and its\n-     * {@code protected} and {@code private} modifiers are always\n-     * {@code false}. If this {@code Class} object represents an array class, a\n-     * primitive type or void, then its {@code final} modifier is always\n-     * {@code true} and its interface modifier is always\n-     * {@code false}. The values of its other modifiers are not determined\n-     * by this specification.\n+     * <p> If the underlying class is an array class:\n+     * <ul>\n+     * <li> its {@code public}, {@code private} and {@code protected}\n+     *      modifiers are the same as those of its component type\n+     * <li> its {@code final} modifier is always\n+     *      {@code true}\n+     * <li> its interface modifier is always {@code false}, event when\n+     *      the component type is an interface\n+     * <\/ul>\n+     * If this {@code Class} object represents a primitive type or\n+     * void, its {@code public}, {@code abstract}, and {@code final}\n+     * modifiers are always {@code true}.\n+     * For class objects representing void, primitive types, and\n+     * arrays, the values of other modifiers are {@code false} other\n+     * than as specified above.\n@@ -1323,0 +1327,1 @@\n+     * @jvms 4.1 The {@code ClassFile} Structure\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.annotation.*;\n+\n+\/*\n+ * @test\n+ * @bug 8296743\n+ * @summary Verify array classes and primitives have expected modifiers\n+ *\/\n+@ExpectedModifiers(Modifier.PUBLIC | Modifier.FINAL | Modifier.ABSTRACT)\n+public class TestPrimitiveAndArrayModifiers {\n+\n+    \/*\n+     * Relevant excerpt of the Class.getModifiers() specification:\n+     * <p> If the underlying class is an array class:\n+     * <ul>\n+     * <li> its {@code public}, {@code private} and {@code protected}\n+     *      modifiers are the same as those of its component type\n+     * <li> its {@code final} modifier is always\n+     *      {@code true}\n+     * <li> its interface modifier is always {@code false}, event when\n+     *      the component type is an interface\n+     * <\/ul>\n+     *\/\n+\n+    public static void main(String... args) throws Exception {\n+        testPrimitives();\n+        testArrays();\n+    }\n+\n+    private static void testArrays() {\n+        Class<?>[] testCases = {\n+            TestPrimitiveAndArrayModifiers.class,\n+\n+            PackagePrivateClass.class,\n+            ProtectedClass.class,\n+            PrivateClass.class,\n+\n+            PublicInterface.class,\n+            PackagePrivateInterface.class,\n+            ProtectedInterface.class,\n+            PrivateInterface.class,\n+        };\n+\n+        for(var testCase : testCases) {\n+            int expectedModifiers =\n+                testCase.getAnnotation(ExpectedModifiers.class).value();\n+            Class<?> arrayClass = testCase.arrayType();\n+            int actualModifiers = arrayClass.getModifiers();\n+            if (expectedModifiers != actualModifiers) {\n+                System.out.println(\"Expected \" + Modifier.toString(expectedModifiers) +\n+                                   \", but got \" + Modifier.toString(actualModifiers));\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT)\n+    class PackagePrivateClass {}\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT | Modifier.PROTECTED)\n+    protected class ProtectedClass {}\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT | Modifier.PRIVATE)\n+    private class  PrivateClass {}\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT | Modifier.PUBLIC)\n+    public interface PublicInterface {}\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT)\n+    interface PackagePrivateInterface {}\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT | Modifier.PROTECTED)\n+    protected interface ProtectedInterface {}\n+\n+    @ExpectedModifiers(Modifier.FINAL | Modifier.ABSTRACT | Modifier.PRIVATE)\n+    private interface PrivateInterface {}\n+\n+    \/*\n+     * Relevant excerpt of the Class.getModifiers() specification:\n+     *\n+     * If this {@code Class} object represents a primitive type or\n+     * void, its {@code public}, {@code abstract}, and {@code final}\n+     * modifiers are always {@code true}.\n+     *\/\n+    private static void testPrimitives() {\n+        Class<?>[] testCases = {\n+            void.class,\n+            boolean.class,\n+            byte.class,\n+            short.class,\n+            char.class,\n+            int.class,\n+            float.class,\n+            long.class,\n+            double.class,\n+        };\n+\n+        for(var testCase : testCases) {\n+            int actualModifiers = testCase.getModifiers();\n+            if ((Modifier.PUBLIC | Modifier.ABSTRACT | Modifier.FINAL) !=\n+                actualModifiers) {\n+                System.out.println(\"Bad modifiers \" + Modifier.toString(actualModifiers) +\n+                                   \" on primitive type \" + testCase);\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface ExpectedModifiers {\n+    int value() default 0;\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/Class\/getModifiers\/TestPrimitiveAndArrayModifiers.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}