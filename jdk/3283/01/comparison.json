{"files":[{"patch":"@@ -803,17 +803,61 @@\n-            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n-            id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n-\n-            \/\/ Create an intrermediate buffer\n-            int totalBuffsize = srcWidth * srcHeight * 4;\n-            id <MTLBuffer> buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];\n-\n-            [blitEncoder copyFromTexture:dstOps->pTexture\n-                    sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(srcBounds.x1, srcBounds.y1, 0) sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n-                     toBuffer:buff destinationOffset:0 destinationBytesPerRow:(srcWidth * 4) destinationBytesPerImage:totalBuffsize];\n-\n-            [blitEncoder copyFromBuffer:buff\n-                    sourceOffset:0 sourceBytesPerRow:srcWidth*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n-                    toTexture:dstOps->pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dstBounds.x1, dstBounds.y1, 0)];\n-            [blitEncoder endEncoding];\n-\n-            [cb commit];\n+            struct TxtVertex quadTxVerticesBuffer[6];\n+            MTLPooledTextureHandle * interHandle =\n+                [mtlc.texturePool getTexture:texWidth\n+                                      height:texHeight\n+                                      format:MTLPixelFormatBGRA8Unorm];\n+            if (interHandle == nil) {\n+                J2dTraceLn(J2D_TRACE_ERROR,\n+                    \"MTLBlitLoops_CopyArea: texture handle is null\");\n+                return;\n+            }\n+            [[mtlc getCommandBufferWrapper] registerPooledTexture:interHandle];\n+\n+            id<MTLTexture> interTexture = interHandle.texture;\n+\n+            \/*\n+             * We need to consider common states like clipping while\n+             * performing copyArea, thats why we need to query encoder with\n+             * appropriate state from EncoderManager and not use\n+             * direct MTLBlitCommandEncoder for texture mapping.\n+             *\/\n+\n+            id<MTLRenderCommandEncoder> interEncoder =\n+                [mtlc.encoderManager getTextureEncoder:interTexture\n+                                           isSrcOpaque:dstOps->isOpaque\n+                                           isDstOpaque:dstOps->isOpaque\n+            ];\n+\n+            fillTxQuad(quadTxVerticesBuffer, 0, 0,\n+                texWidth, texHeight, texWidth, texHeight, 0,\n+                0, texWidth, texHeight, texWidth, texHeight);\n+\n+            [interEncoder setVertexBytes:quadTxVerticesBuffer\n+                             length:sizeof(quadTxVerticesBuffer)\n+                            atIndex:MeshVertexBuffer];\n+            [interEncoder setFragmentTexture:dstOps->pTexture atIndex: 0];\n+            [interEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0\n+                                                             vertexCount:6];\n+\n+            id<MTLRenderCommandEncoder> finalEncoder =\n+                [mtlc.encoderManager getTextureEncoder:dstOps->pTexture\n+                                           isSrcOpaque:dstOps->isOpaque\n+                                           isDstOpaque:dstOps->isOpaque\n+            ];\n+\n+            fillTxQuad(quadTxVerticesBuffer, srcBounds.x1, srcBounds.y1,\n+                srcBounds.x2, srcBounds.y2, texWidth, texHeight, dstBounds.x1,\n+                dstBounds.y1, dstBounds.x2, dstBounds.y2, texWidth, texHeight);\n+            [finalEncoder setVertexBytes:quadTxVerticesBuffer\n+                             length:sizeof(quadTxVerticesBuffer)\n+                            atIndex:MeshVertexBuffer];\n+            [finalEncoder setFragmentTexture:interTexture atIndex: 0];\n+            [finalEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0\n+                                                             vertexCount:6];\n+            [mtlc.encoderManager endEncoder];\n+            MTLCommandBufferWrapper * cbwrapper =\n+                [mtlc pullCommandBufferWrapper];\n+            id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+            [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                [cbwrapper release];\n+            }];\n+            [commandbuf commit];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":61,"deletions":17,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -205,0 +205,2 @@\n+    textureDescriptor.usage = MTLTextureUsageRenderTarget |\n+        MTLTextureUsageShaderRead;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexurePool.m","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}