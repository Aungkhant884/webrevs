{"files":[{"patch":"@@ -803,17 +803,39 @@\n-            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n-            id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n-\n-            \/\/ Create an intrermediate buffer\n-            int totalBuffsize = srcWidth * srcHeight * 4;\n-            id <MTLBuffer> buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];\n-\n-            [blitEncoder copyFromTexture:dstOps->pTexture\n-                    sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(srcBounds.x1, srcBounds.y1, 0) sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n-                     toBuffer:buff destinationOffset:0 destinationBytesPerRow:(srcWidth * 4) destinationBytesPerImage:totalBuffsize];\n-\n-            [blitEncoder copyFromBuffer:buff\n-                    sourceOffset:0 sourceBytesPerRow:srcWidth*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n-                    toTexture:dstOps->pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dstBounds.x1, dstBounds.y1, 0)];\n-            [blitEncoder endEncoding];\n-\n-            [cb commit];\n+            struct TxtVertex quadTxVerticesBuffer[6];\n+            MTLPooledTextureHandle * interHandle =\n+                [mtlc.texturePool getTexture:texWidth\n+                                      height:texHeight\n+                                      format:MTLPixelFormatBGRA8Unorm];\n+            if (interHandle == nil) {\n+                J2dTraceLn(J2D_TRACE_ERROR,\n+                    \"MTLBlitLoops_CopyArea: texture handle is null\");\n+                return;\n+            }\n+            [[mtlc getCommandBufferWrapper] registerPooledTexture:interHandle];\n+\n+            id<MTLTexture> interTexture = interHandle.texture;\n+\n+            \/*\n+             * We need to consider common states like clipping while\n+             * performing copyArea, thats why we use drawTex2Tex and\n+             * get encoder with appropriate state from EncoderManager\n+             * and not directly use MTLBlitCommandEncoder for texture copy.\n+             *\/\n+\n+            \/\/ copy content to intermediate texture\n+            drawTex2Tex(mtlc, dstOps->pTexture, interTexture, dstOps->isOpaque,\n+                        JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR,\n+                        0, 0, texWidth, texHeight, 0, 0, texWidth, texHeight);\n+\n+            \/\/ copy content with appropriate bounds to destination texture\n+            drawTex2Tex(mtlc, interTexture, dstOps->pTexture, JNI_FALSE,\n+                        dstOps->isOpaque, INTERPOLATION_NEAREST_NEIGHBOR,\n+                        srcBounds.x1, srcBounds.y1, srcBounds.x2, srcBounds.y2,\n+                        dstBounds.x1, dstBounds.y1, dstBounds.x2, dstBounds.y2);\n+            [mtlc.encoderManager endEncoder];\n+            MTLCommandBufferWrapper * cbwrapper =\n+                [mtlc pullCommandBufferWrapper];\n+            id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+            [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                [cbwrapper release];\n+            }];\n+            [commandbuf commit];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -205,0 +205,2 @@\n+    textureDescriptor.usage = MTLTextureUsageRenderTarget |\n+        MTLTextureUsageShaderRead;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexurePool.m","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}