{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1939,1 +1939,0 @@\n-  class ClassesDo;\n@@ -2030,2 +2029,1 @@\n-\/\/ writes a HPROF_LOAD_CLASS record for the class (and each of its\n-\/\/ array classes)\n+\/\/ writes a HPROF_LOAD_CLASS record for the class\n@@ -2038,3 +2036,1 @@\n-  \/\/ write a HPROF_LOAD_CLASS for the class and each array class\n-  do {\n-    DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n+  DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n@@ -2042,2 +2038,2 @@\n-    \/\/ class serial number is just a number\n-    writer()->write_u4(++class_serial_num);\n+  \/\/ class serial number is just a number\n+  writer()->write_u4(++class_serial_num);\n@@ -2045,6 +2041,3 @@\n-    \/\/ class ID\n-    Klass* klass = k;\n-    writer()->write_classID(klass);\n-\n-    \/\/ add the Klass* and class serial number pair\n-    dumper()->add_class_serial_number(klass, class_serial_num);\n+  \/\/ class ID\n+  Klass* klass = k;\n+  writer()->write_classID(klass);\n@@ -2052,1 +2045,2 @@\n-    writer()->write_u4(STACK_TRACE_ID);\n+  \/\/ add the Klass* and class serial number pair\n+  dumper()->add_class_serial_number(klass, class_serial_num);\n@@ -2054,3 +2048,1 @@\n-    \/\/ class name ID\n-    Symbol* name = klass->name();\n-    writer()->write_symbolID(name);\n+  writer()->write_u4(STACK_TRACE_ID);\n@@ -2058,3 +2050,3 @@\n-    \/\/ write a LOAD_CLASS record for the array type (if it exists)\n-    k = klass->array_klass_or_null();\n-  } while (k != NULL);\n+  \/\/ class name ID\n+  Symbol* name = klass->name();\n+  writer()->write_symbolID(name);\n@@ -2294,1 +2286,0 @@\n-    Universe::basic_type_classes_do(&do_load_class);\n@@ -2301,0 +2292,2 @@\n+    \/\/ For array classes we need signers and protection domain from their bottom classes\n+    \/\/ so do_class_dump skips array classes and dumps array classes with corresponding instance class.\n@@ -2305,0 +2298,1 @@\n+    \/\/ Need additionally dump basic array classes.\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedInputStream;\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.ref.Reference;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.hprof.parser.PositionDataInputStream;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @bug 8281267\n+ * @summary Verifies heap dump does not contain duplicate array classes\n+ * @library \/test\/lib\n+ * @run driver DuplicateArrayClassesTest\n+ *\/\n+\n+class DuplicateArrayClassesTarg extends LingeredApp {\n+    public static void main(String[] args) {\n+        \/\/ Initialize some array classes (for primitive type and object type).\n+        int[][][] intArray = new int[0][][];\n+        String[][][] strArray = new String[0][][];\n+        LingeredApp.main(args);\n+        Reference.reachabilityFence(intArray);\n+        Reference.reachabilityFence(strArray);\n+    }\n+}\n+\n+\n+public class DuplicateArrayClassesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new DuplicateArrayClassesTarg();\n+\n+            LingeredApp.startApp(theApp);\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static final byte HPROF_UTF8                = 0x01;\n+    private static final byte HPROF_LOAD_CLASS          = 0x02;\n+    private static final byte HPROF_HEAP_DUMP           = 0x0c;\n+    private static final byte HPROF_GC_CLASS_DUMP       = 0x20;\n+    private static final byte HPROF_HEAP_DUMP_SEGMENT   = 0x1C;\n+    private static final byte HPROF_HEAP_DUMP_END       = 0x2C;\n+\n+    private static void verifyDump(File dumpFile) throws IOException {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        \/\/ HPROF_UTF8 records.\n+        Map<Long, String> names = new HashMap<>();\n+        \/\/ Maps from HPROF_LOAD_CLASS records.\n+        Map<Long, String> classId2Name = new Hashtable<>();\n+        Map<String, Long> className2Id = new Hashtable<>();\n+        \/\/ Duplicate HPROF_LOAD_CLASS records.\n+        List<Long> duplicateLoadClassIDs = new LinkedList<>();\n+        \/\/ HPROF_GC_CLASS_DUMP records.\n+        Set<Long> dumpClassIDs = new HashSet<>();\n+        \/\/ Duplicate HPROF_GC_CLASS_DUMP records.\n+        List<Long> duplicateDumpClassIDs = new LinkedList<>();\n+\n+        try (DumpInputStream in = new DumpInputStream(dumpFile)) {\n+            while (true) {\n+                DumpRecord rec;\n+                try {\n+                    rec = in.readRecord();\n+                } catch (EOFException ex) {\n+                    break;\n+                }\n+                long pos = in.position();   \/\/ save the current pos\n+\n+                switch (rec.tag()) {\n+                    case HPROF_UTF8:\n+                        long id = in.readID();\n+                        byte[] chars = new byte[(int) rec.size - in.idSize];\n+                        in.readFully(chars);\n+                        names.put(id, new String(chars));\n+                        break;\n+                    case HPROF_LOAD_CLASS:\n+                        long classSerialNo = in.readU4();\n+                        long classID = in.readID();\n+                        long stackTraceSerialNo = in.readU4();\n+                        long classNameID = in.readID();\n+                        \/\/ We expect all names are dumped before classes.\n+                        String className = names.get(classNameID);\n+\n+                        String prevName = classId2Name.putIfAbsent(classID, className);\n+                        if (prevName != null) { \/\/ there is a class with the same ID\n+                            if (!prevName.equals(className)) {\n+                                \/\/ Something is completely wrong.\n+                                throw new RuntimeException(\"Found new class with id=\" + classID\n+                                        + \" and different name (\" + className + \", was \" + prevName + \")\");\n+                            }\n+                            duplicateLoadClassIDs.add(classID);\n+                        }\n+                        \/\/ It's ok if we have other class with the same name (may be from other classloader).\n+                        className2Id.putIfAbsent(className, classID);\n+                        break;\n+                    case HPROF_HEAP_DUMP:\n+                    case HPROF_HEAP_DUMP_SEGMENT:\n+                        \/\/ HPROF_GC_CLASS_DUMP records are dumped first (in the beginning of the dump).\n+                        long endOfRecordPos = pos + rec.size();\n+\n+                        while (in.position() < endOfRecordPos) {\n+                            byte subTag = in.readU1();\n+                            if (subTag != HPROF_GC_CLASS_DUMP) {\n+                                break;\n+                            }\n+                            \/\/ We don't know HPROF_GC_CLASS_DUMP size, so have to read it completely.\n+                            long dumpClassID = readClassDump(in);\n+\n+                            if (!dumpClassIDs.add(dumpClassID)) {\n+                                duplicateDumpClassIDs.add(dumpClassID);\n+                            }\n+                        }\n+                        break;\n+                }\n+\n+                \/\/ Skip bytes till end of the record.\n+                long bytesRead = in.position() - pos;\n+                if (bytesRead > rec.size()) {\n+                    throw new RuntimeException(\"Bad record,\"\n+                            + \" record.size = \" + rec.size() + \", read \" + bytesRead);\n+                }\n+                in.skipNBytes(rec.size() - bytesRead);\n+            }\n+\n+            log(\"HPROF_LOAD_CLASS records: \" + (classId2Name.size() + duplicateLoadClassIDs.size()));\n+            log(\"HPROF_GC_CLASS_DUMP records: \" + (dumpClassIDs.size() + duplicateDumpClassIDs.size()));\n+\n+            \/\/ Verify we have array classes used by target app.\n+            String[] expectedClasses = {\"[I\", \"[[I\", \"[[[I\",\n+                    \"[Ljava\/lang\/String;\", \"[[Ljava\/lang\/String;\", \"[[[Ljava\/lang\/String;\"};\n+            for (String className: expectedClasses) {\n+                Long classId = className2Id.get(className);\n+                if (classId == null) {\n+                    throw new RuntimeException(\"no HPROF_LOAD_CLASS record for class \" + className);\n+                }\n+                \/\/ verify there is HPROF_GC_CLASS_DUMP record for the class\n+                if (!dumpClassIDs.contains(classId)) {\n+                    throw new RuntimeException(\"no HPROF_GC_CLASS_DUMP for class \" + className);\n+                }\n+                log(\"found \" + className);\n+            }\n+            if (!duplicateLoadClassIDs.isEmpty() || !duplicateDumpClassIDs.isEmpty()) {\n+                log(\"Duplicate(s) detected:\");\n+                log(\"HPROF_LOAD_CLASS records (\" + duplicateLoadClassIDs.size() + \"):\");\n+                duplicateLoadClassIDs.forEach(id -> log(\"  - id = \" + id + \": \" + classId2Name.get(id)));\n+                log(\"HPROF_GC_CLASS_DUMP records (\" + duplicateDumpClassIDs.size() + \"):\");\n+                duplicateDumpClassIDs.forEach(id -> log(\"  - id = \" + id + \": \" + classId2Name.get(id)));\n+                throw new RuntimeException(\"duplicates detected\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Reads the whole HPROF_GC_CLASS_DUMP record, returns class ID.\n+    private static long readClassDump(DumpInputStream in) throws IOException {\n+        long classID = in.readID();\n+        long stackTraceNum = in.readU4();\n+        long superClassId = in.readID();\n+        long loaderClassId = in.readID();\n+        long signerClassId = in.readID();\n+        long protectionDomainClassId = in.readID();\n+        long reserved1 = in.readID();\n+        long reserved2 = in.readID();\n+        long instanceSize = in.readU4();\n+        long cpSize = in.readU2();\n+        for (long i = 0; i < cpSize; i++) {\n+            long cpIndex = in.readU2();\n+            byte type = in.readU1();\n+            in.skipNBytes(in.type2size(type)); \/\/ value\n+        }\n+        long staticNum = in.readU2();\n+        for (long i = 0; i < staticNum; i++) {\n+            long nameId = in.readID();\n+            byte type = in.readU1();\n+            in.skipNBytes(in.type2size(type)); \/\/ value\n+        }\n+        long instanceNum = in.readU2();\n+        for (long i = 0; i < instanceNum; i++) {\n+            long nameId = in.readID();\n+            byte type = in.readU1();\n+        }\n+        return classID;\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+\n+\n+    private static record DumpRecord (byte tag, long size) {}\n+\n+    private static class DumpInputStream extends PositionDataInputStream {\n+        public final int idSize;\n+\n+        public DumpInputStream(File f) throws IOException {\n+            super(new BufferedInputStream(new FileInputStream(f)));\n+\n+            \/\/ read header:\n+            \/\/   header    \"JAVA PROFILE 1.0.2\" (0-terminated)\n+            \/\/   u4        size of identifiers. Identifiers are used to represent\n+            \/\/   u4         high word\n+            \/\/   u4         low word    number of milliseconds since 0:00 GMT, 1\/1\/70\n+            String header = readStr();\n+            log(\"header: \\\"\" + header + \"\\\"\");\n+            Asserts.assertTrue(header.startsWith(\"JAVA PROFILE \"));\n+\n+            idSize = readInt();\n+            if (idSize != 4 && idSize != 8) {\n+                Asserts.fail(\"id size \" + idSize + \" is not supported\");\n+            }\n+            \/\/ ignore timestamp\n+            readU4();\n+            readU4();\n+        }\n+\n+        \/\/ Reads null-terminated string\n+        public String readStr() throws IOException {\n+            StringBuilder sb = new StringBuilder();\n+            for (char ch = (char)readByte(); ch != '\\0'; ch = (char)readByte()) {\n+                sb.append(ch);\n+            }\n+            return sb.toString();\n+        }\n+\n+        public byte readU1() throws IOException {\n+            return readByte();\n+        }\n+        public int readU2() throws IOException {\n+            return readUnsignedShort();\n+        }\n+        public long readU4() throws IOException {\n+            \/\/ keep the value positive\n+            return ((long)readInt() & 0x0FFFFFFFFL);\n+        }\n+\n+        public long readID() throws IOException {\n+            return idSize == 4 ? readU4() : readLong();\n+        }\n+\n+        public DumpRecord readRecord() throws IOException {\n+            byte tag = readU1();\n+            readU4();   \/\/ timestamp, ignore it\n+            long size = readU4();\n+            return new DumpRecord(tag, size);\n+        }\n+\n+        public long type2size(byte type) {\n+            switch (type) {\n+                case 1:     \/\/ array\n+                case 2:     \/\/ object\n+                    return idSize;\n+                case 4:     \/\/ boolean\n+                case 8:     \/\/ byte\n+                    return 1;\n+                case 5:     \/\/ char\n+                case 9:     \/\/ short\n+                    return 2;\n+                case 6:     \/\/ float\n+                case 10:    \/\/ int\n+                    return 4;\n+                case 7:     \/\/ double\n+                case 11:    \/\/ long\n+                    return 8;\n+            }\n+            throw new RuntimeException(\"unknown type: \" + type);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/DuplicateArrayClassesTest.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"}]}