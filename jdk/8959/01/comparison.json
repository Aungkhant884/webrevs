{"files":[{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A case label element that refers to a constant expression\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface ConstantCaseLabelTree extends CaseLabelTree {\n+\n+    \/**\n+     * The constant expression for the case.\n+     *\n+     * @return the constant expression\n+     *\/\n+    public ExpressionTree getConstantExpression();\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ConstantCaseLabelTree.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.NoPreview;\n-\n@@ -40,2 +38,1 @@\n-@NoPreview\n-public interface ExpressionTree extends Tree, CaseLabelTree {}\n+public interface ExpressionTree extends Tree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ExpressionTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A case label element that refers to an expression\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface PatternCaseLabelTree extends CaseLabelTree {\n+\n+    \/**\n+     * The pattern for the case.\n+     *\n+     * @return the pattern\n+     *\/\n+    public PatternTree getPattern();\n+\n+    \/**\n+     * The guard for the case.\n+     *\n+     * @return the guard\n+     *\/\n+    ExpressionTree getGuard();\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternCaseLabelTree.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -36,11 +34,1 @@\n-public interface PatternTree extends Tree, CaseLabelTree {\n-\n-    \/**\n-     * The guard for the case.\n-     *\n-     * @return the guard\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    ExpressionTree getGuard();\n-\n+public interface PatternTree extends Tree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternTree.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -247,0 +247,16 @@\n+        \/**\n+         * Used for instances of {@link ConstantCaseLabelTree}.\n+         *\n+         * @since 19\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        CONSTANT_CASE_LABEL(ConstantCaseLabelTree.class),\n+\n+        \/**\n+         * Used for instances of {@link PatternCaseLabelTree}.\n+         *\n+         * @since 19\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        PATTERN_CASE_LABEL(PatternCaseLabelTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -281,0 +281,20 @@\n+    \/**\n+     * Visits a {@code ConstantCaseLabelTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitConstantCaseLabel(ConstantCaseLabelTree node, P p);\n+\n+    \/**\n+     * Visits a {@code PatternCaseLabelTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitPatternCaseLabel(PatternCaseLabelTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -662,0 +662,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 19\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitConstantCaseLabel(ConstantCaseLabelTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n@@ -679,1 +695,19 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 19\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitPatternCaseLabel(PatternCaseLabelTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-        R r = scan(node.getExpressions(), p);\n+        R r = scan(node.getLabels(), p);\n@@ -774,3 +774,1 @@\n-        R r = scan(node.getVariable(), p);\n-        r = scanAndReduce(node.getGuard(), p, r);\n-        return r;\n+        return scan(node.getVariable(), p);\n@@ -795,0 +793,34 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 19\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitConstantCaseLabel(ConstantCaseLabelTree node, P p) {\n+        return scan(node.getConstantExpression(), p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 19\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitPatternCaseLabel(PatternCaseLabelTree node, P p) {\n+        R r = scan(node.getPattern(), p);\n+        r = scanAndReduce(node.getGuard(), p, r);\n+        return r;\n+    }\n+\n@@ -811,1 +843,0 @@\n-        r = scanAndReduce(node.getGuard(), p, r);\n@@ -856,3 +887,1 @@\n-        R r = scan(node.getPattern(), p);\n-        r = scanAndReduce(node.getGuard(), p, r);\n-        return r;\n+        return scan(node.getPattern(), p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1692,1 +1692,1 @@\n-                                     .anyMatch(l -> l.isPattern());\n+                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL));\n@@ -1718,3 +1718,3 @@\n-                for (JCCaseLabel pat : c.labels) {\n-                    if (pat.isExpression()) {\n-                        JCExpression expr = (JCExpression) pat;\n+                for (JCCaseLabel label : c.labels) {\n+                    if (label.hasTag(CONSTANTCASELABEL)) {\n+                        JCExpression expr = ((JCConstantCaseLabel) label).expr;\n@@ -1724,1 +1724,1 @@\n-                                log.error(pat.pos(), Errors.DuplicateCaseLabel);\n+                                log.error(label.pos(), Errors.DuplicateCaseLabel);\n@@ -1726,1 +1726,1 @@\n-                                log.error(pat.pos(), Errors.PatternDominated);\n+                                log.error(label.pos(), Errors.PatternDominated);\n@@ -1736,1 +1736,1 @@\n-                                log.error(pat.pos(), Errors.DuplicateCaseLabel);\n+                                log.error(label.pos(), Errors.DuplicateCaseLabel);\n@@ -1738,1 +1738,1 @@\n-                                checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, sym.type);\n+                                checkCaseLabelDominated(label.pos(), coveredTypesForConstants, sym.type);\n@@ -1747,1 +1747,1 @@\n-                                attribExpr(pat, switchEnv, seltype);\n+                                attribExpr(expr, switchEnv, seltype);\n@@ -1767,1 +1767,1 @@\n-                                    log.error(pat.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n@@ -1771,1 +1771,1 @@\n-                                    checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n+                                    checkCaseLabelDominated(label.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n@@ -1775,1 +1775,1 @@\n-                    } else if (pat.hasTag(DEFAULTCASELABEL)) {\n+                    } else if (label.hasTag(DEFAULTCASELABEL)) {\n@@ -1777,1 +1777,1 @@\n-                            log.error(pat.pos(), Errors.DuplicateDefaultLabel);\n+                            log.error(label.pos(), Errors.DuplicateDefaultLabel);\n@@ -1779,1 +1779,1 @@\n-                            log.error(pat.pos(), Errors.UnconditionalPatternAndDefault);\n+                            log.error(label.pos(), Errors.UnconditionalPatternAndDefault);\n@@ -1784,1 +1784,2 @@\n-                        \/\/binding pattern\n+                        \/\/pattern\n+                        JCPattern pat = ((JCPatternCaseLabel) label).pat;\n@@ -1792,1 +1793,1 @@\n-                        JCExpression guard = ((JCPattern) pat).guard;\n+                        JCExpression guard = ((JCPatternCaseLabel) label).guard;\n@@ -1807,1 +1808,1 @@\n-                        boolean unguarded = TreeInfo.unguardedCaseLabel(pat) && !pat.hasTag(RECORDPATTERN);\n+                        boolean unguarded = TreeInfo.unguardedCaseLabel(label) && !pat.hasTag(RECORDPATTERN);\n@@ -1830,1 +1831,1 @@\n-                    currentBindings = matchBindingsComputer.switchCase(pat, currentBindings, matchBindings);\n+                    currentBindings = matchBindingsComputer.switchCase(label, currentBindings, matchBindings);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -4330,3 +4330,3 @@\n-            for (JCCaseLabel pat : c.labels) {\n-                if (pat.isExpression()) {\n-                    JCExpression expr = (JCExpression) pat;\n+            for (JCCaseLabel label : c.labels) {\n+                if (label.hasTag(CONSTANTCASELABEL)) {\n+                    JCExpression expr = ((JCConstantCaseLabel) label).expr;\n@@ -4335,1 +4335,1 @@\n-                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n@@ -4340,1 +4340,1 @@\n-                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n@@ -4344,1 +4344,1 @@\n-                } else if (pat.hasTag(DEFAULTCASELABEL)) {\n+                } else if (label.hasTag(DEFAULTCASELABEL)) {\n@@ -4346,1 +4346,1 @@\n-                        log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                        log.error(label.pos(), Errors.FlowsThroughFromPattern);\n@@ -4350,0 +4350,1 @@\n+                    JCPattern pat = ((JCPatternCaseLabel) label).pat;\n@@ -4353,1 +4354,1 @@\n-                        log.error(pat.pos(), Errors.FlowsThroughToPattern);\n+                        log.error(label.pos(), Errors.FlowsThroughToPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -741,4 +741,7 @@\n-            HashSet<JCCaseLabel> labels = cases.stream()\n-                                               .flatMap(c -> c.labels.stream())\n-                                               .filter(TreeInfo::unguardedCaseLabel)\n-                                               .collect(Collectors.toCollection(HashSet::new));\n+            HashSet<JCTree> labels = cases.stream()\n+                                          .flatMap(c -> c.labels.stream())\n+                                          .filter(TreeInfo::unguardedCaseLabel)\n+                                          .filter(l -> !l.hasTag(DEFAULTCASELABEL))\n+                                          .map(l -> l.hasTag(CONSTANTCASELABEL) ? ((JCConstantCaseLabel) l).expr\n+                                                                                : ((JCPatternCaseLabel) l).pat)\n+                                          .collect(Collectors.toCollection(HashSet::new));\n@@ -749,1 +752,1 @@\n-                                           Iterable<? extends JCCaseLabel> labels) {\n+                                           Iterable<? extends JCTree> labels) {\n@@ -753,1 +756,1 @@\n-            for (JCCaseLabel label : labels) {\n+            for (JCTree label : labels) {\n@@ -771,2 +774,0 @@\n-\n-                    case DEFAULTCASELABEL -> {}\n@@ -774,7 +775,4 @@\n-                        if (label.isExpression()) {\n-                            JCExpression expr = (JCExpression) label;\n-                            if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n-                                coveredSymbols.add(((JCIdent) expr).sym);\n-                        } else {\n-                            throw new AssertionError(label.getTag());\n-                        }\n+                        Assert.check(label instanceof JCExpression, label.getTag().name());\n+                        JCExpression expr = (JCExpression) label;\n+                        if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n+                            coveredSymbols.add(((JCIdent) expr).sym);\n@@ -2588,2 +2586,2 @@\n-                    l.tail.head.labels.head.isExpression() &&\n-                    TreeInfo.isNull(l.tail.head.labels.head)) {\n+                    l.tail.head.labels.head.hasTag(CONSTANTCASELABEL) &&\n+                    TreeInfo.isNull(((JCConstantCaseLabel) l.tail.head.labels.head).expr)) {\n@@ -2974,0 +2972,5 @@\n+        }\n+\n+        @Override\n+        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+            scan(tree.pat);\n@@ -3074,1 +3077,1 @@\n-                    case BINDINGPATTERN, PARENTHESIZEDPATTERN:\n+                    case PATTERNCASELABEL:\n@@ -3109,1 +3112,1 @@\n-                case BINDINGPATTERN, PARENTHESIZEDPATTERN -> Fragments.Guard;\n+                case PATTERNCASELABEL -> Fragments.Guard;\n@@ -3151,7 +3154,0 @@\n-            JCTree prevTree = currentTree;\n-            try {\n-                currentTree = tree;\n-                scan(tree.guard);\n-            } finally {\n-                currentTree = prevTree;\n-            }\n@@ -3163,0 +3159,5 @@\n+        }\n+\n+        @Override\n+        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+             scan(tree.pat);\n@@ -3176,7 +3177,1 @@\n-            JCTree prevTree = currentTree;\n-            try {\n-                currentTree = tree;\n-                scan(tree.guard);\n-            } finally {\n-                currentTree = prevTree;\n-            }\n+            scan(tree.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-            cases.add(make.Case(JCCase.STATEMENT, List.of(make.Literal(entry.getKey())), stmts, null));\n+            cases.add(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(make.Literal(entry.getKey()))), stmts, null));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3731,1 +3731,1 @@\n-        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNullCaseLabel(c.labels.head))) {\n@@ -3757,1 +3757,1 @@\n-            if (c.labels.head.isExpression()) {\n+            if (c.labels.head.hasTag(CONSTANTCASELABEL)) {\n@@ -3759,1 +3759,1 @@\n-                if (TreeInfo.isNull(c.labels.head)) {\n+                if (TreeInfo.isNullCaseLabel(c.labels.head)) {\n@@ -3762,1 +3762,1 @@\n-                    VarSymbol label = (VarSymbol)TreeInfo.symbol((JCExpression) c.labels.head);\n+                    VarSymbol label = (VarSymbol)TreeInfo.symbol(((JCConstantCaseLabel) c.labels.head).expr);\n@@ -3765,1 +3765,1 @@\n-                newCases.append(make.Case(JCCase.STATEMENT, List.of(pat), c.stats, null));\n+                newCases.append(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(pat)), c.stats, null));\n@@ -3845,2 +3845,2 @@\n-                if (oneCase.labels.head.isExpression()) {\n-                    if (TreeInfo.isNull(oneCase.labels.head)) {\n+                if (oneCase.labels.head.hasTag(CONSTANTCASELABEL)) {\n+                    if (TreeInfo.isNullCaseLabel(oneCase.labels.head)) {\n@@ -3850,1 +3850,1 @@\n-                        JCExpression expression = (JCExpression) oneCase.labels.head;\n+                        JCExpression expression = ((JCConstantCaseLabel) oneCase.labels.head).expr;\n@@ -3935,1 +3935,4 @@\n-                caseBuffer.append(make.Case(JCCase.STATEMENT, List.of(make.Literal(hashCode)), lb.toList(), null));\n+                caseBuffer.append(make.Case(JCCase.STATEMENT,\n+                                            List.of(make.ConstantCaseLabel(make.Literal(hashCode))),\n+                                            lb.toList(),\n+                                            null));\n@@ -3954,2 +3957,2 @@\n-                boolean isDefault = !oneCase.labels.head.isExpression();\n-                JCCaseLabel caseExpr;\n+                boolean isDefault = !oneCase.labels.head.hasTag(CONSTANTCASELABEL);\n+                JCExpression caseExpr;\n@@ -3961,2 +3964,4 @@\n-                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens((JCExpression) oneCase.labels.head).\n-                                                                    type.constValue()));\n+                    JCExpression expression = ((JCConstantCaseLabel) oneCase.labels.head).expr;\n+                    String name = (String) TreeInfo.skipParens(expression)\n+                                                   .type.constValue();\n+                    caseExpr = make.Literal(caseLabelToPosition.get(name));\n@@ -3965,1 +3970,2 @@\n-                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel()) : List.of(caseExpr),\n+                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel())\n+                                                                       : List.of(make.ConstantCaseLabel(caseExpr)),\n@@ -4002,1 +4008,1 @@\n-        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNullCaseLabel(c.labels.head))) {\n@@ -4012,1 +4018,1 @@\n-                if (TreeInfo.isNull(c.labels.head)) {\n+                if (TreeInfo.isNullCaseLabel(c.labels.head)) {\n@@ -4015,1 +4021,1 @@\n-                    constants.add((int) c.labels.head.type.constValue());\n+                    constants.add((int) ((JCConstantCaseLabel) c.labels.head).expr.type.constValue());\n@@ -4026,1 +4032,1 @@\n-            nullCase.labels.head = makeLit(syms.intType, nullValue);\n+            nullCase.labels.head = make.ConstantCaseLabel(makeLit(syms.intType, nullValue));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCConstantCaseLabel;\n@@ -92,0 +93,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCPatternCaseLabel;\n@@ -461,2 +463,1 @@\n-                                       .anyMatch(p -> p.isExpression() &&\n-                                                      TreeInfo.isNull((JCExpression) p));\n+                                       .anyMatch(p -> TreeInfo.isNullCaseLabel(p));\n@@ -522,1 +523,1 @@\n-                        c.labels.size() > 1 && c.labels.stream().anyMatch(l -> l.isNullPattern());\n+                        c.labels.size() > 1 && c.labels.stream().anyMatch(l -> TreeInfo.isNullCaseLabel(l));\n@@ -525,1 +526,1 @@\n-                                              .filter(l -> !l.isNullPattern())\n+                                              .filter(l -> !TreeInfo.isNullCaseLabel(l))\n@@ -528,2 +529,2 @@\n-                if (clearedPatterns.size() == 1 && clearedPatterns.head.isPattern() && !previousCompletesNormally) {\n-                    JCCaseLabel p = clearedPatterns.head;\n+                if (clearedPatterns.size() == 1 && clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL) && !previousCompletesNormally) {\n+                    JCPatternCaseLabel label = (JCPatternCaseLabel) clearedPatterns.head;\n@@ -534,3 +535,3 @@\n-                        JCExpression test = (JCExpression) this.<JCTree>translate(p);\n-                        if (((JCPattern) p).guard != null) {\n-                            test = makeBinary(Tag.AND, test, translate(((JCPattern) p).guard));\n+                        JCExpression test = (JCExpression) this.<JCTree>translate(label.pat);\n+                        if (label.guard != null) {\n+                            test = makeBinary(Tag.AND, test, translate(label.guard));\n@@ -561,1 +562,1 @@\n-                               c == lastCase && p.isPattern()) {\n+                               c == lastCase && p.hasTag(Tag.PATTERNCASELABEL)) {\n@@ -568,1 +569,1 @@\n-                        if (p.isNullPattern()) {\n+                        if (TreeInfo.isNullCaseLabel(p)) {\n@@ -573,1 +574,1 @@\n-                        translatedLabels.add(make.Literal(value));\n+                        translatedLabels.add(make.ConstantCaseLabel(make.Literal(value)));\n@@ -636,2 +637,2 @@\n-        if (l.isPattern()) {\n-            Type principalType = principalType(l);\n+        if (l.hasTag(Tag.PATTERNCASELABEL)) {\n+            Type principalType = principalType(((JCPatternCaseLabel) l).pat);\n@@ -643,3 +644,4 @@\n-        } else if (l.isExpression() && !TreeInfo.isNull((JCExpression) l)) {\n-            if ((l.type.tsym.flags_field & Flags.ENUM) != 0) {\n-                return LoadableConstant.String(((JCIdent) l).name.toString());\n+        } else if (l.hasTag(Tag.CONSTANTCASELABEL)&& !TreeInfo.isNullCaseLabel(l)) {\n+            JCExpression expr = ((JCConstantCaseLabel) l).expr;\n+            if ((expr.type.tsym.flags_field & Flags.ENUM) != 0) {\n+                return LoadableConstant.String(((JCIdent) expr).name.toString());\n@@ -647,1 +649,1 @@\n-                Assert.checkNonNull(l.type.constValue());\n+                Assert.checkNonNull(expr.type.constValue());\n@@ -649,1 +651,1 @@\n-                return switch (l.type.getTag()) {\n+                return switch (expr.type.getTag()) {\n@@ -651,2 +653,2 @@\n-                         SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n-                    case CLASS -> LoadableConstant.String((String) l.type.constValue());\n+                         SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case CLASS -> LoadableConstant.String((String) expr.type.constValue());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -568,0 +568,12 @@\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+        tree.expr = translate(tree.expr, null);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+        tree.pat = translate(tree.pat, null);\n@@ -586,1 +598,0 @@\n-        tree.guard = translate(tree.guard, syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -335,0 +335,15 @@\n+        @Override\n+        public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n+            sr.mergeWith(csp(tree.expr));\n+            result = sr;\n+        }\n+\n+        @Override\n+        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n+            sr.mergeWith(csp(tree.pat));\n+            sr.mergeWith(csp(tree.guard));\n+            result = sr;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1302,1 +1302,1 @@\n-                if (l.head.labels.head.isExpression()) {\n+                if (l.head.labels.head.hasTag(CONSTANTCASELABEL)) {\n@@ -1304,1 +1304,1 @@\n-                    int val = ((Number)((JCExpression) l.head.labels.head).type.constValue()).intValue();\n+                    int val = ((Number)((JCConstantCaseLabel) l.head.labels.head).expr.type.constValue()).intValue();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3120,0 +3120,1 @@\n+                JCExpression guard = null;\n@@ -3122,1 +3123,1 @@\n-                    p.guard = term(EXPR | NOLAMBDA);\n+                    guard = term(EXPR | NOLAMBDA);\n@@ -3124,1 +3125,1 @@\n-                return p;\n+                return toP(F.at(patternPos).PatternCaseLabel(p, guard));\n@@ -3126,1 +3127,2 @@\n-                return term(EXPR | NOLAMBDA);\n+                JCExpression expr = term(EXPR | NOLAMBDA);\n+                return toP(F.at(patternPos).ConstantCaseLabel(expr));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -243,1 +243,0 @@\n-        DEFAULTCASELABEL,\n@@ -245,1 +244,0 @@\n-\n@@ -248,0 +246,6 @@\n+        \/* Case labels.\n+         *\/\n+        DEFAULTCASELABEL,\n+        CONSTANTCASELABEL,\n+        PATTERNCASELABEL,\n+\n@@ -707,5 +711,0 @@\n-        public abstract boolean isExpression();\n-        public boolean isNullPattern() {\n-            return isExpression() && TreeInfo.isNull((JCExpression) this);\n-        }\n-        public abstract boolean isPattern();\n@@ -714,1 +713,1 @@\n-    public abstract static class JCExpression extends JCCaseLabel implements ExpressionTree {\n+    public abstract static class JCExpression extends JCTree implements ExpressionTree {\n@@ -729,9 +728,0 @@\n-        @Override\n-        public boolean isExpression() {\n-            return true;\n-        }\n-\n-        @Override\n-        public boolean isPattern() {\n-            return false;\n-        }\n@@ -1344,0 +1334,1 @@\n+\n@@ -1345,1 +1336,7 @@\n-        public List<JCExpression> getExpressions() { return labels.stream().filter(p -> p instanceof JCExpression).map(p -> (JCExpression) p).collect(List.collector()); }\n+        public List<JCExpression> getExpressions() {\n+            return labels.stream()\n+                         .filter(p -> p.hasTag(CONSTANTCASELABEL))\n+                         .map(p -> ((JCConstantCaseLabel) p).expr)\n+                         .collect(List.collector());\n+        }\n+\n@@ -2246,1 +2243,1 @@\n-    public abstract static class JCPattern extends JCCaseLabel\n+    public abstract static class JCPattern extends JCTree\n@@ -2248,15 +2245,0 @@\n-\n-        public JCExpression guard;\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getGuard() { return guard; }\n-\n-        @Override\n-        public boolean isExpression() {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isPattern() {\n-            return true;\n-        }\n@@ -2327,0 +2309,16 @@\n+    }\n+\n+    public static class JCConstantCaseLabel extends JCCaseLabel\n+            implements ConstantCaseLabelTree {\n+\n+        public JCExpression expr;\n+\n+        protected JCConstantCaseLabel(JCExpression expr) {\n+            this.expr = expr;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getConstantExpression() {\n+            return expr;\n+        }\n+\n@@ -2328,2 +2326,7 @@\n-        public boolean isExpression() {\n-            return false;\n+        public void accept(Visitor v) {\n+            v.visitConstantCaseLabel(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.CONSTANT_CASE_LABEL;\n@@ -2333,2 +2336,3 @@\n-        public boolean isPattern() {\n-            return false;\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitConstantCaseLabel(this, d);\n@@ -2336,0 +2340,50 @@\n+\n+        @Override\n+        public Tag getTag() {\n+            return CONSTANTCASELABEL;\n+        }\n+\n+    }\n+\n+    public static class JCPatternCaseLabel extends JCCaseLabel\n+            implements PatternCaseLabelTree {\n+\n+        public JCPattern pat;\n+        public JCExpression guard;\n+\n+        protected JCPatternCaseLabel(JCPattern pat, JCExpression guard) {\n+            this.pat = pat;\n+            this.guard = guard;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public JCPattern getPattern() {\n+            return pat;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getGuard() {\n+            return guard;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitPatternCaseLabel(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.PATTERN_CASE_LABEL;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitPatternCaseLabel(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return PATTERNCASELABEL;\n+        }\n+\n@@ -3472,0 +3526,2 @@\n+        public void visitConstantCaseLabel(JCConstantCaseLabel that) { visitTree(that); }\n+        public void visitPatternCaseLabel(JCPatternCaseLabel that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":94,"deletions":38,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -880,0 +880,22 @@\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+        try {\n+            print(tree.expr);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+        try {\n+            print(tree.pat);\n+            if (tree.guard != null) {\n+                print(\" when \");\n+                print(tree.guard);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n@@ -903,4 +925,0 @@\n-            if (patt.guard != null) {\n-                print(\" when \");\n-                printExpr(patt.guard);\n-            }\n@@ -918,4 +936,0 @@\n-            if (patt.guard != null) {\n-                print(\" when \");\n-                printExpr(patt.guard);\n-            }\n@@ -938,4 +952,0 @@\n-            if (tree.guard != null) {\n-                print(\" when \");\n-                printExpr(tree.guard);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -497,4 +497,1 @@\n-        JCExpression guard = copy(t.guard, p);\n-        JCPattern pat = M.at(t.pos).BindingPattern(var);\n-        pat.guard = guard;\n-        return pat;\n+        return M.at(t.pos).BindingPattern(var);\n@@ -507,4 +504,1 @@\n-        JCExpression guard = copy(t.guard, p);\n-        JCPattern pat = M.at(t.pos).ParenthesizedPattern(pattern);\n-        pat.guard = guard;\n-        return pat;\n+        return M.at(t.pos).ParenthesizedPattern(pattern);\n@@ -519,0 +513,15 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitConstantCaseLabel(ConstantCaseLabelTree node, P p) {\n+        JCConstantCaseLabel t = (JCConstantCaseLabel) node;\n+        JCExpression expr = copy(t.expr, p);\n+        return M.at(t.pos).ConstantCaseLabel(expr);\n+    }\n+\n+    @Override\n+    public JCTree visitPatternCaseLabel(PatternCaseLabelTree node, P p) {\n+        JCPatternCaseLabel t = (JCPatternCaseLabel) node;\n+        JCPattern pat = copy(t.pat, p);\n+        JCExpression guard = copy(t.guard, p);\n+        return M.at(t.pos).PatternCaseLabel(pat, guard);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1306,0 +1306,2 @@\n+                             .filter(l -> l.hasTag(CONSTANTCASELABEL))\n+                             .map(l -> ((JCConstantCaseLabel) l).expr)\n@@ -1331,1 +1333,1 @@\n-                         .anyMatch(l -> TreeInfo.isNull(l));\n+                         .anyMatch(l -> TreeInfo.isNullCaseLabel(l));\n@@ -1335,1 +1337,1 @@\n-        if (!cse.isPattern()) {\n+        if (!cse.hasTag(PATTERNCASELABEL)) {\n@@ -1338,1 +1340,1 @@\n-        JCExpression guard = ((JCPattern) cse).guard;\n+        JCExpression guard = ((JCPatternCaseLabel) cse).guard;\n@@ -1351,0 +1353,5 @@\n+\n+    public static boolean isNullCaseLabel(JCCaseLabel label) {\n+        return label.hasTag(CONSTANTCASELABEL) &&\n+               TreeInfo.isNull(((JCConstantCaseLabel) label).expr);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -497,0 +497,12 @@\n+    public JCConstantCaseLabel ConstantCaseLabel(JCExpression expr) {\n+        JCConstantCaseLabel tree = new JCConstantCaseLabel(expr);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCPatternCaseLabel PatternCaseLabel(JCPattern pat, JCExpression guard) {\n+        JCPatternCaseLabel tree = new JCPatternCaseLabel(pat, guard);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -308,1 +308,0 @@\n-        scan(tree.guard);\n@@ -315,0 +314,11 @@\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+        scan(tree.expr);\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+        scan(tree.pat);\n+        scan(tree.guard);\n+    }\n+\n@@ -318,1 +328,0 @@\n-        scan(tree.guard);\n@@ -328,1 +337,0 @@\n-        scan(that.guard);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -363,1 +363,0 @@\n-        tree.guard = translate(tree.guard);\n@@ -372,0 +371,13 @@\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+        tree.expr = translate(tree.expr);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+        tree.pat = translate(tree.pat);\n+        tree.guard = translate(tree.guard);\n+        result = tree;\n+    }\n+\n@@ -375,1 +387,0 @@\n-        tree.guard = translate(tree.guard);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ConstantCaseLabelTree;\n@@ -40,1 +40,1 @@\n-import com.sun.source.tree.PatternTree;\n+import com.sun.source.tree.PatternCaseLabelTree;\n@@ -142,2 +142,2 @@\n-            case ExpressionTree et -> ExpressionType.EXPRESSION;\n-            case PatternTree pt -> ExpressionType.PATTERN;\n+            case ConstantCaseLabelTree et -> ExpressionType.EXPRESSION;\n+            case PatternCaseLabelTree pt -> ExpressionType.PATTERN;\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -98,2 +98,0 @@\n-            if (!tree.sourcefile.toString().contains(\"EmptyBreak.java\"))\n-                return 0;\n@@ -148,23 +146,19 @@\n-                if (!tree.hasTag(JCTree.Tag.DEFAULTCASELABEL)) {\n-                    expect.add(tree);\n-                    for (Field f: getFields(tree)) {\n-                        if (TypeBoundKind.class.isAssignableFrom(f.getType())) {\n-                            \/\/ not part of public API\n-                            continue;\n-                        }\n-                        try {\n-                            \/\/System.err.println(\"FIELD: \" + f.getName());\n-                            if (tree instanceof JCModuleDecl && f.getName().equals(\"mods\")) {\n-                                \/\/ The modifiers will not found by TreeScanner,\n-                                \/\/ but the embedded annotations will be.\n-                                reflectiveScan(((JCModuleDecl) tree).mods.annotations);\n-                            } else if (tree instanceof JCCase &&\n-                                       ((JCCase) tree).getCaseKind() == CaseKind.RULE &&\n-                                       f.getName().equals(\"stats\")) {\n-                                \/\/value case, visit value:\n-                                reflectiveScan(((JCCase) tree).getBody());\n-                            } else {\n-                                reflectiveScan(f.get(tree));\n-                            }\n-                        } catch (IllegalAccessException e) {\n-                            error(e.toString());\n+                expect.add(tree);\n+                for (Field f: getFields(tree)) {\n+                    if (TypeBoundKind.class.isAssignableFrom(f.getType())) {\n+                        \/\/ not part of public API\n+                        continue;\n+                    }\n+                    try {\n+                        \/\/System.err.println(\"FIELD: \" + f.getName());\n+                        if (tree instanceof JCModuleDecl && f.getName().equals(\"mods\")) {\n+                            \/\/ The modifiers will not found by TreeScanner,\n+                            \/\/ but the embedded annotations will be.\n+                            reflectiveScan(((JCModuleDecl) tree).mods.annotations);\n+                        } else if (tree instanceof JCCase &&\n+                                   ((JCCase) tree).getCaseKind() == CaseKind.RULE &&\n+                                   f.getName().equals(\"stats\")) {\n+                            \/\/value case, visit value:\n+                            reflectiveScan(((JCCase) tree).getBody());\n+                        } else {\n+                            reflectiveScan(f.get(tree));\n@@ -172,0 +166,2 @@\n+                    } catch (IllegalAccessException e) {\n+                        error(e.toString());\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"}]}