{"files":[{"patch":"@@ -31,1 +31,0 @@\n-#include \"classfile\/symbolTable.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"classfile\/symbolTable.hpp\"\n@@ -68,0 +67,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-class TempNewSymbol;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n@@ -113,1 +114,1 @@\n-ResourceHashtable<Symbol*, ConstraintSet, 107, ResourceObj::C_HEAP, mtClass> _loader_constraint_table;\n+ResourceHashtable<SymbolHandle, ConstraintSet, 107, ResourceObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _loader_constraint_table;\n@@ -174,2 +175,0 @@\n-    \/\/ Increment the key refcount when putting in the table.\n-    name->increment_refcount();\n@@ -184,1 +183,1 @@\n-  bool do_entry(Symbol*& name, ConstraintSet& set) {\n+  bool do_entry(SymbolHandle& name, ConstraintSet& set) {\n@@ -245,2 +244,0 @@\n-      \/\/ decrement name refcount before freeing\n-      name->decrement_refcount();\n@@ -458,1 +455,1 @@\n-  auto check = [&] (Symbol*& key, ConstraintSet& set) {\n+  auto check = [&] (SymbolHandle& key, ConstraintSet& set) {\n@@ -465,1 +462,1 @@\n-        guarantee(ik->name() == key, \"name should match\");\n+        guarantee(key == ik->name(), \"name should match\");\n@@ -495,1 +492,1 @@\n-  auto size = [&] (Symbol*& key, ConstraintSet& set) {\n+  auto size = [&] (SymbolHandle& key, ConstraintSet& set) {\n@@ -511,1 +508,1 @@\n-  auto printer = [&] (Symbol*& key, ConstraintSet& set) {\n+  auto printer = [&] (SymbolHandle& key, ConstraintSet& set) {\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-    bool do_entry(const Symbol*& name, ModuleEntry*& entry) {\n+    bool do_entry(const SymbolHandle& name, ModuleEntry*& entry) {\n@@ -514,1 +514,1 @@\n-  auto syms = [&] (const Symbol*& key, ModuleEntry*& m) {\n+  auto syms = [&] (const SymbolHandle& key, ModuleEntry*& m) {\n@@ -523,1 +523,1 @@\n-  auto grab = [&] (const Symbol*& key, ModuleEntry*& m) {\n+  auto grab = [&] (const SymbolHandle& key, ModuleEntry*& m) {\n@@ -606,1 +606,1 @@\n-  auto purge = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+  auto purge = [&] (const SymbolHandle& key, ModuleEntry*& entry) {\n@@ -673,1 +673,1 @@\n-  auto printer = [&] (const Symbol*& name, ModuleEntry*& entry) {\n+  auto printer = [&] (const SymbolHandle& name, ModuleEntry*& entry) {\n@@ -683,1 +683,1 @@\n-  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+  auto do_f = [&] (const SymbolHandle& key, ModuleEntry*& entry) {\n@@ -690,1 +690,1 @@\n-  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+  auto do_f = [&] (const SymbolHandle& key, ModuleEntry*& entry) {\n@@ -708,1 +708,1 @@\n-  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+  auto do_f = [&] (const SymbolHandle& key, ModuleEntry*& entry) {\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n@@ -208,2 +209,2 @@\n-  ResourceHashtable<const Symbol*, ModuleEntry*, 109, ResourceObj::C_HEAP, mtModule,\n-                    Symbol::compute_hash> _table;\n+  ResourceHashtable<SymbolHandle, ModuleEntry*, 109, ResourceObj::C_HEAP, mtModule,\n+                    SymbolHandle::compute_hash> _table;\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-    bool do_entry(const Symbol*& name, PackageEntry*& entry) {\n+    bool do_entry(const SymbolHandle& name, PackageEntry*& entry) {\n@@ -273,1 +273,1 @@\n-  auto syms = [&] (const Symbol*& key, PackageEntry*& p) {\n+  auto syms = [&] (const SymbolHandle& key, PackageEntry*& p) {\n@@ -282,1 +282,1 @@\n-  auto count = [&] (const Symbol*& key, PackageEntry*& p) {\n+  auto count = [&] (const SymbolHandle& key, PackageEntry*& p) {\n@@ -292,1 +292,1 @@\n-  auto grab = [&] (const Symbol*& key, PackageEntry*& p) {\n+  auto grab = [&] (const SymbolHandle& key, PackageEntry*& p) {\n@@ -377,1 +377,1 @@\n-  auto verifier = [&] (const Symbol*& name, PackageEntry*& entry) {\n+  auto verifier = [&] (const SymbolHandle& name, PackageEntry*& entry) {\n@@ -413,1 +413,1 @@\n-  auto purge = [&] (const Symbol*& name, PackageEntry*& entry) {\n+  auto purge = [&] (const SymbolHandle& name, PackageEntry*& entry) {\n@@ -426,1 +426,1 @@\n-  auto doit = [&] (const Symbol*&name, PackageEntry*& entry) {\n+  auto doit = [&] (const SymbolHandle&name, PackageEntry*& entry) {\n@@ -436,1 +436,1 @@\n-  auto grab = [&] (const Symbol*&name, PackageEntry*& entry) {\n+  auto grab = [&] (const SymbolHandle& name, PackageEntry*& entry) {\n@@ -449,1 +449,1 @@\n-  auto printer = [&] (const Symbol*& name, PackageEntry*& entry) {\n+  auto printer = [&] (const SymbolHandle& name, PackageEntry*& entry) {\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n@@ -239,2 +240,2 @@\n-  ResourceHashtable<const Symbol*, PackageEntry*, 109, ResourceObj::C_HEAP, mtModule,\n-                    Symbol::compute_hash> _table;\n+  ResourceHashtable<SymbolHandle, PackageEntry*, 109, ResourceObj::C_HEAP, mtModule,\n+                    SymbolHandle::compute_hash> _table;\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n@@ -37,1 +38,1 @@\n-  Symbol* _name;\n+  SymbolHandle _name;\n@@ -207,2 +208,0 @@\n-  \/\/ Since we're storing this key in the hashtable, we need to increment the refcount.\n-  class_name->increment_refcount();\n@@ -221,2 +220,0 @@\n-  \/\/ Decrement the refcount in key, since it's no longer in the table.\n-  class_name->decrement_refcount();\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n@@ -36,52 +37,2 @@\n-\/\/ TempNewSymbol acts as a handle class in a handle\/body idiom and is\n-\/\/ responsible for proper resource management of the body (which is a Symbol*).\n-\/\/ The body is resource managed by a reference counting scheme.\n-\/\/ TempNewSymbol can therefore be used to properly hold a newly created or referenced\n-\/\/ Symbol* temporarily in scope.\n-\/\/\n-\/\/ Routines in SymbolTable will initialize the reference count of a Symbol* before\n-\/\/ it becomes \"managed\" by TempNewSymbol instances. As a handle class, TempNewSymbol\n-\/\/ needs to maintain proper reference counting in context of copy semantics.\n-\/\/\n-\/\/ In SymbolTable, new_symbol() will create a Symbol* if not already in the\n-\/\/ symbol table and add to the symbol's reference count.\n-\/\/ probe() and lookup_only() will increment the refcount if symbol is found.\n-class TempNewSymbol : public StackObj {\n-  Symbol* _temp;\n-\n-public:\n-  TempNewSymbol() : _temp(NULL) {}\n-\n-  \/\/ Conversion from a Symbol* to a TempNewSymbol.\n-  \/\/ Does not increment the current reference count.\n-  TempNewSymbol(Symbol *s) : _temp(s) {}\n-\n-  \/\/ Copy constructor increments reference count.\n-  TempNewSymbol(const TempNewSymbol& rhs) : _temp(rhs._temp) {\n-    if (_temp != NULL) {\n-      _temp->increment_refcount();\n-    }\n-  }\n-\n-  \/\/ Assignment operator uses a c++ trick called copy and swap idiom.\n-  \/\/ rhs is passed by value so within the scope of this method it is a copy.\n-  \/\/ At method exit it contains the former value of _temp, triggering the correct refcount\n-  \/\/ decrement upon destruction.\n-  void operator=(TempNewSymbol rhs) {\n-    Symbol* tmp = rhs._temp;\n-    rhs._temp = _temp;\n-    _temp = tmp;\n-  }\n-\n-  \/\/ Decrement reference counter so it can go away if it's unused\n-  ~TempNewSymbol() {\n-    if (_temp != NULL) {\n-      _temp->decrement_refcount();\n-    }\n-  }\n-\n-  \/\/ Symbol* conversion operators\n-  Symbol* operator -> () const                   { return _temp; }\n-  bool    operator == (Symbol* o) const          { return _temp == o; }\n-  operator Symbol*()                             { return _temp; }\n-};\n+\/\/ TempNewSymbol in symbolHandle.hpp is used with SymbolTable operations,\n+\/\/ so include it here.\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.hpp","additions":3,"deletions":52,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-ResourceHashtable<Symbol*, OopHandle, 139, ResourceObj::C_HEAP, mtClass> _invoke_method_type_table;\n+ResourceHashtable<SymbolHandle, OopHandle, 139, ResourceObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _invoke_method_type_table;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/symbolTable.hpp\"\n@@ -52,0 +51,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"classfile\/symbolTable.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_SYMBOLHANDLE_HPP\n+#define SHARE_OOPS_SYMBOLHANDLE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+\/\/ TempNewSymbol acts as a handle class in a handle\/body idiom and is\n+\/\/ responsible for proper resource management of the body (which is a Symbol*).\n+\/\/ The body is resource managed by a reference counting scheme.\n+\/\/ TempNewSymbol can therefore be used to properly hold a newly created or referenced\n+\/\/ Symbol* temporarily in scope.\n+\/\/\n+\/\/ Routines in SymbolTable will initialize the reference count of a Symbol* before\n+\/\/ it becomes \"managed\" by TempNewSymbol instances. As a handle class, TempNewSymbol\n+\/\/ needs to maintain proper reference counting in context of copy semantics.\n+\/\/\n+\/\/ In SymbolTable, new_symbol() will create a Symbol* if not already in the\n+\/\/ symbol table and add to the symbol's reference count.\n+\/\/ probe() and lookup_only() will increment the refcount if symbol is found.\n+template <bool TEMP>\n+class SymbolHandleBase : public StackObj {\n+  Symbol* _temp;\n+\n+public:\n+  SymbolHandleBase() : _temp(NULL) { }\n+\n+  \/\/ Conversion from a Symbol* to a SymbolHandleBase.\n+  \/\/ Does not increment the current reference count if temporary.\n+  SymbolHandleBase(Symbol *s) : _temp(s) {\n+    if (!TEMP) {\n+      assert(s != nullptr, \"must not be null\");\n+      s->increment_refcount();\n+    }\n+  }\n+\n+  \/\/ Copy constructor increments reference count.\n+  SymbolHandleBase(const SymbolHandleBase& rhs) : _temp(rhs._temp) {\n+    Symbol::maybe_increment_refcount(_temp);\n+  }\n+\n+  \/\/ Assignment operator uses a c++ trick called copy and swap idiom.\n+  \/\/ rhs is passed by value so within the scope of this method it is a copy.\n+  \/\/ At method exit it contains the former value of _temp, triggering the correct refcount\n+  \/\/ decrement upon destruction.\n+  void operator=(SymbolHandleBase rhs) {\n+    Symbol* tmp = rhs._temp;\n+    rhs._temp = _temp;\n+    _temp = tmp;\n+  }\n+\n+  \/\/ Decrement reference counter so it can go away if it's unused\n+  ~SymbolHandleBase() {\n+    Symbol::maybe_decrement_refcount(_temp);\n+  }\n+\n+  \/\/ Symbol* conversion operators\n+  Symbol* operator -> () const                   { return _temp; }\n+  bool    operator == (Symbol* o) const          { return _temp == o; }\n+  operator Symbol*() const                       { return _temp; }\n+\n+  static unsigned int compute_hash(const SymbolHandleBase& name) {\n+    return (unsigned int) name->identity_hash();\n+  }\n+};\n+\n+\/\/ TempNewSymbol is a temporary holder for a newly created symbol\n+using TempNewSymbol = SymbolHandleBase<true>;\n+\n+\/\/ SymbolHandle is a non-temp symbol used to hold a symbol in a semi permanent place,\n+\/\/ like in a hashtable. The only difference is that the constructor increments the refcount.\n+using SymbolHandle = SymbolHandleBase<false>;\n+\n+#endif \/\/ SHARE_OOPS_SYMBOLHANDLE_HPP\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/symbolHandle.hpp\"\n@@ -292,2 +293,2 @@\n-\/\/ Simple ResourceHashtable whose key is a Symbol* and value is an int\n-\/\/ This test is to show that you need to manipulate the refcount of the Symbol to store\n+\/\/ Simple ResourceHashtable whose key is a SymbolHandle and value is an int\n+\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n@@ -297,1 +298,1 @@\n-    ResourceHashtable<Symbol*, int, 107, ResourceObj::C_HEAP, mtTest> _simple_test_table;\n+    ResourceHashtable<SymbolHandle, int, 107, ResourceObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n@@ -301,4 +302,1 @@\n-        bool do_entry(Symbol*& key, int value) {\n-          \/\/ We need to decrement the refcount for the key in the delete function.\n-          \/\/ Since we incremented the key, in this case, we should decrement it.\n-          key->decrement_refcount();\n+        bool do_entry(SymbolHandle& key, int value) {\n@@ -311,1 +309,2 @@\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n@@ -313,2 +312,0 @@\n-  \/\/ Need to increment a Symbol* when you keep it in a table.\n-  s->increment_refcount();\n@@ -320,2 +317,0 @@\n-  \/\/ Now decrement the refcount for s since it's no longer in the table.\n-  s->decrement_refcount();\n@@ -326,1 +321,2 @@\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n@@ -328,2 +324,0 @@\n-  \/\/ Need to increment a Symbol* when you keep it in a table.\n-  s->increment_refcount();\n@@ -339,2 +333,3 @@\n-\/\/ More complicated ResourceHashtable with Symbol* as the key. Since the *same* Symbol is part\n-\/\/ of the value, it's not necessary to maniuplate the refcount of the key, but you must in the value.\n+\/\/ More complicated ResourceHashtable with SymbolHandle in the key. Since the *same* Symbol is part\n+\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n+\/\/ Luckily SymbolHandle does this.\n@@ -344,1 +339,1 @@\n-        Symbol* _s;\n+        SymbolHandle _s;\n@@ -349,15 +344,5 @@\n-        TestValue(Symbol* name) : _s(name) { _s->increment_refcount(); }\n-        TestValue(const TestValue& tv) { _s = tv.s(); _s->increment_refcount(); }\n-\n-        \/\/ Refcounting with assignment operators is tricky.  See TempNewSymbol for more information.\n-        \/\/ (1) A copy (from) of the argument is created to be passed by value to operator=.  This increments\n-        \/\/ the refcount of the symbol.\n-        \/\/ (2) Exchange the values this->_s and from._s as a trivial pointer exchange.  No reference count\n-        \/\/ manipulation occurs.  this->_s is the desired new value, with its refcount incremented appropriately\n-        \/\/ (by the copy that created from).\n-        \/\/ (3) The operation completes and from goes out of scope, calling its destructor.  This decrements the\n-        \/\/ refcount for from._s, which is the _old_ value of this->_s.\n-        TestValue& operator=(TestValue tv) { swap(_s, tv._s); return *this; }\n-\n-        ~TestValue() { _s->decrement_refcount(); }\n-        Symbol* s() const { return _s; }\n+\n+        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n+        \/\/ have dtors, copy ctors and assignment operators to do so.\n+        TestValue(Symbol* name) : _s(name) { }\n+        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        output.shouldContain(\"17 2: jdk\/test\/lib\/apps\\n\");\n+        output.shouldContain(\"17 3: jdk\/test\/lib\/apps\\n\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicSharedSymbols.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}