{"files":[{"patch":"@@ -1408,0 +1408,50 @@\n+\/\/ vector bcax (unpredicated)\n+\n+instruct vbcaxI_neon(vReg dst, vReg src1, vReg src2, vReg src3, immI_M1 m1) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateB m1)))));\n+  match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateS m1)))));\n+  match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateI m1)))));\n+  format %{ \"vbcaxI_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ bcax($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vbcaxL_neon(vReg dst, vReg src1, vReg src2, vReg src3, immL_M1 m1) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateL m1)))));\n+  format %{ \"vbcaxL_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ bcax($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vbcaxI_sve(vReg dst_src1, vReg src2, vReg src3, immI_M1 m1) %{\n+  predicate(UseSVE > 1 && !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateB m1)))));\n+  match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateS m1)))));\n+  match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateI m1)))));\n+  format %{ \"vbcaxI_sve $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_bcax($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vbcaxL_sve(vReg dst_src1, vReg src2, vReg src3, immL_M1 m1) %{\n+  predicate(UseSVE > 1 && !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateL m1)))));\n+  format %{ \"vbcaxL_sve $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_bcax($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -735,0 +735,51 @@\n+\/\/ vector bcax (unpredicated)\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateB m1)))));\n+  match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateS m1)))));\n+  match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateI m1)))));',\n+`match(Set dst (XorV src1 (AndV src2 (XorV src3 (ReplicateL m1)))));')')dnl\n+dnl\n+dnl VECTOR_BCAX_NEON($1  )\n+dnl VECTOR_BCAX_NEON(type)\n+define(`VECTOR_BCAX_NEON', `\n+instruct vbcax$1_neon`'(vReg dst, vReg src1, vReg src2, vReg src3, imm$1_M1 m1) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  MATCH_RULE($1)\n+  format %{ \"vbcax$1_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ bcax($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VECTOR_BCAX_NEON(I)\n+VECTOR_BCAX_NEON(L)dnl\n+undefine(MATCH_RULE)\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateB m1)))));\n+  match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateS m1)))));\n+  match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateI m1)))));',\n+`match(Set dst_src1 (XorV dst_src1 (AndV src2 (XorV src3 (ReplicateL m1)))));')')dnl\n+dnl\n+dnl VECTOR_BCAX_SVE($1  )\n+dnl VECTOR_BCAX_SVE(type)\n+define(`VECTOR_BCAX_SVE', `\n+instruct vbcax$1_sve`'(vReg dst_src1, vReg src2, vReg src3, imm$1_M1 m1) %{\n+  predicate(UseSVE > 1 && !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  MATCH_RULE($1)\n+  format %{ \"vbcax$1_sve $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_bcax($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VECTOR_BCAX_SVE(I)\n+VECTOR_BCAX_SVE(L)dnl\n+undefine(MATCH_RULE)\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -4145,0 +4145,1 @@\n+  INSN(sve_bcax, 0b011); \/\/ Bitwise clear and exclusive OR\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\", \"eor3\"]):\n+        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\", \"eor3\", \"bcax\"]):\n@@ -1104,1 +1104,1 @@\n-        firstArg = 0 if self._name == \"eor3\" else 1\n+        firstArg = 0 if self._name == \"eor3\" or self._name == \"bcax\" else 1\n@@ -2050,0 +2050,1 @@\n+                       [\"bcax\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1260,0 +1260,1 @@\n+    __ sve_bcax(z29, z1, z14);                         \/\/       bcax    z29.d, z29.d, z1.d, z14.d\n@@ -1262,9 +1263,9 @@\n-    __ sve_andv(v29, __ D, p0, z14);                   \/\/       andv d29, p0, z14.d\n-    __ sve_orv(v3, __ H, p0, z25);                     \/\/       orv h3, p0, z25.h\n-    __ sve_eorv(v24, __ D, p2, z1);                    \/\/       eorv d24, p2, z1.d\n-    __ sve_smaxv(v10, __ S, p3, z1);                   \/\/       smaxv s10, p3, z1.s\n-    __ sve_sminv(v25, __ S, p1, z28);                  \/\/       sminv s25, p1, z28.s\n-    __ sve_fminv(v16, __ S, p1, z27);                  \/\/       fminv s16, p1, z27.s\n-    __ sve_fmaxv(v1, __ S, p7, z11);                   \/\/       fmaxv s1, p7, z11.s\n-    __ sve_fadda(v1, __ D, p0, z1);                    \/\/       fadda d1, p0, d1, z1.d\n-    __ sve_uaddv(v26, __ B, p3, z2);                   \/\/       uaddv d26, p3, z2.b\n+    __ sve_andv(v3, __ H, p0, z25);                    \/\/       andv h3, p0, z25.h\n+    __ sve_orv(v24, __ D, p2, z1);                     \/\/       orv d24, p2, z1.d\n+    __ sve_eorv(v10, __ S, p3, z1);                    \/\/       eorv s10, p3, z1.s\n+    __ sve_smaxv(v25, __ S, p1, z28);                  \/\/       smaxv s25, p1, z28.s\n+    __ sve_sminv(v16, __ H, p1, z27);                  \/\/       sminv h16, p1, z27.h\n+    __ sve_fminv(v1, __ S, p7, z11);                   \/\/       fminv s1, p7, z11.s\n+    __ sve_fmaxv(v1, __ D, p0, z1);                    \/\/       fmaxv d1, p0, z1.d\n+    __ sve_fadda(v26, __ S, p3, z2);                   \/\/       fadda s26, p3, s26, z2.s\n+    __ sve_uaddv(v29, __ B, p4, z24);                  \/\/       uaddv d29, p4, z24.b\n@@ -1289,7 +1290,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400041e,     0x94000000,\n-    0x97ffffd4,     0x9400041b,     0x3400000a,     0x34fffa2a,\n-    0x3400830a,     0x35000008,     0x35fff9c8,     0x350082a8,\n-    0xb400000b,     0xb4fff96b,     0xb400824b,     0xb500001d,\n-    0xb5fff91d,     0xb50081fd,     0x10000013,     0x10fff8b3,\n-    0x10008193,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36308116,     0x3758000c,     0x375ff7cc,     0x375880ac,\n+    0x14000000,     0x17ffffd7,     0x1400041f,     0x94000000,\n+    0x97ffffd4,     0x9400041c,     0x3400000a,     0x34fffa2a,\n+    0x3400832a,     0x35000008,     0x35fff9c8,     0x350082c8,\n+    0xb400000b,     0xb4fff96b,     0xb400826b,     0xb500001d,\n+    0xb5fff91d,     0xb500821d,     0x10000013,     0x10fff8b3,\n+    0x100081b3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36308136,     0x3758000c,     0x375ff7cc,     0x375880cc,\n@@ -1300,13 +1301,13 @@\n-    0x54007e80,     0x54000001,     0x54fff541,     0x54007e21,\n-    0x54000002,     0x54fff4e2,     0x54007dc2,     0x54000002,\n-    0x54fff482,     0x54007d62,     0x54000003,     0x54fff423,\n-    0x54007d03,     0x54000003,     0x54fff3c3,     0x54007ca3,\n-    0x54000004,     0x54fff364,     0x54007c44,     0x54000005,\n-    0x54fff305,     0x54007be5,     0x54000006,     0x54fff2a6,\n-    0x54007b86,     0x54000007,     0x54fff247,     0x54007b27,\n-    0x54000008,     0x54fff1e8,     0x54007ac8,     0x54000009,\n-    0x54fff189,     0x54007a69,     0x5400000a,     0x54fff12a,\n-    0x54007a0a,     0x5400000b,     0x54fff0cb,     0x540079ab,\n-    0x5400000c,     0x54fff06c,     0x5400794c,     0x5400000d,\n-    0x54fff00d,     0x540078ed,     0x5400000e,     0x54ffefae,\n-    0x5400788e,     0x5400000f,     0x54ffef4f,     0x5400782f,\n+    0x54007ea0,     0x54000001,     0x54fff541,     0x54007e41,\n+    0x54000002,     0x54fff4e2,     0x54007de2,     0x54000002,\n+    0x54fff482,     0x54007d82,     0x54000003,     0x54fff423,\n+    0x54007d23,     0x54000003,     0x54fff3c3,     0x54007cc3,\n+    0x54000004,     0x54fff364,     0x54007c64,     0x54000005,\n+    0x54fff305,     0x54007c05,     0x54000006,     0x54fff2a6,\n+    0x54007ba6,     0x54000007,     0x54fff247,     0x54007b47,\n+    0x54000008,     0x54fff1e8,     0x54007ae8,     0x54000009,\n+    0x54fff189,     0x54007a89,     0x5400000a,     0x54fff12a,\n+    0x54007a2a,     0x5400000b,     0x54fff0cb,     0x540079cb,\n+    0x5400000c,     0x54fff06c,     0x5400796c,     0x5400000d,\n+    0x54fff00d,     0x5400790d,     0x5400000e,     0x54ffefae,\n+    0x540078ae,     0x5400000f,     0x54ffef4f,     0x5400784f,\n@@ -1550,4 +1551,4 @@\n-    0x4580b3a3,     0x45deb685,     0x042d390d,     0x04da21dd,\n-    0x04582323,     0x04d92838,     0x04882c2a,     0x048a2799,\n-    0x65872770,     0x65863d61,     0x65d82021,     0x04012c5a,\n-\n+    0x4580b3a3,     0x45deb685,     0x042d390d,     0x046139dd,\n+    0x045a2323,     0x04d82838,     0x04992c2a,     0x04882799,\n+    0x044a2770,     0x65873d61,     0x65c62021,     0x65982c5a,\n+    0x0401331d,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1421,0 +1421,20 @@\n+    public static final String VBCAX_I_NEON = PREFIX + \"VBCAX_I_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VBCAX_I_NEON, \"vbcaxI_neon\");\n+    }\n+\n+    public static final String VBCAX_L_NEON = PREFIX + \"VBCAX_L_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VBCAX_L_NEON, \"vbcaxL_neon\");\n+    }\n+\n+    public static final String VBCAX_I_SVE = PREFIX + \"VBCAX_I_SVE\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VBCAX_I_SVE, \"vbcaxI_sve\");\n+    }\n+\n+    public static final String VBCAX_L_SVE = PREFIX + \"VBCAX_L_SVE\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VBCAX_L_SVE, \"vbcaxL_sve\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8303553\n+ * @summary AArch64: Add BCAX backend rule\n+ * @library \/test\/lib \/\n+ * @requires os.arch == \"aarch64\"\n+ * @run driver compiler.vectorization.TestBcaxAArch64\n+ *\/\n+\n+public class TestBcaxAArch64 {\n+    private static final int LENGTH = 2048;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static byte[] bc;\n+    private static byte[] br;\n+\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static short[] sc;\n+    private static short[] sr;\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static int[] ir;\n+\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lc;\n+    private static long[] lr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        bc = new byte[LENGTH];\n+        br = new byte[LENGTH];\n+\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        sc = new short[LENGTH];\n+        sr = new short[LENGTH];\n+\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        ir = new int[LENGTH];\n+\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        lr = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte) RD.nextInt(30);\n+            bb[i] = (byte) RD.nextInt(30);\n+            bc[i] = (byte) RD.nextInt(30);\n+\n+            sa[i] = (short) RD.nextInt(30);\n+            sb[i] = (short) RD.nextInt(30);\n+            sc[i] = (short) RD.nextInt(30);\n+\n+            ia[i] = RD.nextInt(30);\n+            ib[i] = RD.nextInt(30);\n+            ic[i] = RD.nextInt(30);\n+\n+            la[i] = RD.nextLong(30);\n+            lb[i] = RD.nextLong(30);\n+            lc[i] = RD.nextLong(30);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VBCAX_I_NEON, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"<= 16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {IRNode.VBCAX_I_SVE, \"> 0\"}, applyIfAnd = {\"UseSVE\", \"> 1\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testByteBCAX() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            br[i] = (byte) (ba[i] ^ (bb[i] & (~bc[i])));\n+        }\n+    }\n+\n+    @Run(test = \"testByteBCAX\")\n+    public static void testByteBCAX_runner() {\n+        testByteBCAX();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((byte)(ba[i] ^ (bb[i] & (~bc[i]))), br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VBCAX_I_NEON, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"<= 16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {IRNode.VBCAX_I_SVE, \"> 0\"}, applyIfAnd = {\"UseSVE\", \"> 1\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testShortBCAX() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            sr[i] = (short) (sa[i] ^ (sb[i] & (~sc[i])));\n+        }\n+    }\n+\n+    @Run(test = \"testShortBCAX\")\n+    public static void testShortBCAX_runner() {\n+        testShortBCAX();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((short)(sa[i] ^ (sb[i] & (~sc[i]))), sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VBCAX_I_NEON, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"<= 16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {IRNode.VBCAX_I_SVE, \"> 0\"}, applyIfAnd = {\"UseSVE\", \"> 1\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testIntBCAX() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ir[i] = ia[i] ^ (ib[i] & (~ic[i]));\n+        }\n+    }\n+\n+    @Run(test = \"testIntBCAX\")\n+    public static void testIntBCAX_runner() {\n+        testIntBCAX();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(ia[i] ^ (ib[i] & (~ic[i])), ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VBCAX_L_NEON, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {IRNode.VBCAX_L_SVE, \"> 0\"}, applyIfAnd = {\"UseSVE\", \"> 1\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testLongBCAX() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            lr[i] = la[i] ^ (lb[i] & (~lc[i]));\n+        }\n+    }\n+\n+    @Run(test = \"testLongBCAX\")\n+    public static void testLongBCAX_runner() {\n+        testLongBCAX();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals(la[i] ^ (lb[i] & (~lc[i])), lr[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBcaxAArch64.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3)\n+public class TestBcax {\n+    @Param({\"2048\"})\n+    private int LENGTH;\n+\n+    private byte[] ba;\n+    private byte[] bb;\n+    private byte[] bc;\n+    private byte[] bd;\n+\n+    private short[] sa;\n+    private short[] sb;\n+    private short[] sc;\n+    private short[] sd;\n+\n+    private int[] ia;\n+    private int[] ib;\n+    private int[] ic;\n+    private int[] id;\n+\n+    private long[] la;\n+    private long[] lb;\n+    private long[] lc;\n+    private long[] ld;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random random = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        bc = new byte[LENGTH];\n+        bd = new byte[LENGTH];\n+\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        sc = new short[LENGTH];\n+        sd = new short[LENGTH];\n+\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        id = new int[LENGTH];\n+\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        ld = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte)random.nextInt();\n+            bb[i] = (byte)random.nextInt();\n+            bc[i] = (byte)random.nextInt();\n+\n+            sa[i] = (short)random.nextInt();\n+            sb[i] = (short)random.nextInt();\n+            sc[i] = (short)random.nextInt();\n+\n+            ia[i] = random.nextInt();\n+            ib[i] = random.nextInt();\n+            ic[i] = random.nextInt();\n+\n+            la[i] = random.nextLong();\n+            lb[i] = random.nextLong();\n+            lc[i] = random.nextLong();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testByte() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            bd[i] = (byte)(ba[i] ^ (bb[i] & (~bc[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShort() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            sd[i] = (short)(sa[i] ^ (sb[i] & (~sc[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            id[i] = ia[i] ^ (ib[i] & (~ic[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLong() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ld[i] = la[i] ^ (lb[i] & (~lc[i]));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/aarch64\/TestBcax.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/aarch64\/TestEor3.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TestEor3.java","status":"renamed"}]}