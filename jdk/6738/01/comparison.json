{"files":[{"patch":"@@ -49,4 +49,0 @@\n-\/\/ The result is the number of characters copied before the first incompatible character was found.\n-\/\/ If precise is true, the processing stops exactly at this point. Otherwise, the result may be off\n-\/\/ by a few bytes. The result always indicates the number of copied characters.\n-\/\/ When used as a character index, the returned value points to the first incompatible character.\n@@ -54,3 +50,19 @@\n-\/\/ Note: Does not behave exactly like package private StringUTF16 compress java implementation in case of failure:\n-\/\/ - Different number of characters may have been written to dead array (if precise is false).\n-\/\/ - Returns a number <cnt instead of 0. (Result gets compared with cnt.)\n+\/\/ The result indicates success or failure of the operation.\n+\/\/   General compress operation (cut off high order byte which must be all zeroes).\n+\/\/    = len - all characters have been successfully compressed.\n+\/\/    = 0   - compress failed. At least one character was found with a non-zero high order byte.\n+\/\/            This is the failure return value which exactly corresponds to the Java implementation.\n+\/\/    0 <= result < len - compress failed. That many characters were compressed successfully\n+\/\/                        before the first non-compressable character was found. This is the\n+\/\/                        current, but not fully compatible, implementation. See below.\n+\/\/   Encode to ISO or 7-bit ASCII array.\n+\/\/    = len - all characters have been encoded successfully.\n+\/\/    < len - encode failed. That many characters were encoded successfully.\n+\/\/            When used as an index into the character array, the return value addresses the\n+\/\/            first not encodeable character.\n+\/\/\n+\/\/ If precise is true, the processing stops exactly at the point where a failure is detected.\n+\/\/ More characters than indicated by the return value may have been read from the src array.\n+\/\/ Exactly the number of characters indicated by the return value have been written to dst.\n+\/\/ If precise is false, a few characters more than indicated by the return value may have been\n+\/\/ written to the dst array. In any failure case, The result value indexes the first invalid character.\n@@ -58,1 +70,1 @@\n-                                                Register tmp,    bool precise) {\n+                                                Register tmp,    bool precise, bool toASCII) {\n@@ -61,0 +73,3 @@\n+  unsigned short char_mask = 0xff00;  \/\/ all selected bits must be '0' for a char to be valid\n+  unsigned int   mask_ix_l = 0;       \/\/ leftmost one bit pos in mask\n+  unsigned int   mask_ix_r = 7;       \/\/ rightmost one bit pos in mask\n@@ -62,1 +77,7 @@\n-    BLOCK_COMMENT(\"encode_iso_array {\");\n+    if (toASCII) {\n+      BLOCK_COMMENT(\"encode_ascii_array {\");\n+      char_mask = 0xff80;\n+      mask_ix_r = 8;         \/\/ rightmost one bit pos in mask. ASCII only uses codes 0..127\n+    } else {\n+      BLOCK_COMMENT(\"encode_iso_array {\");\n+    }\n@@ -75,2 +96,2 @@\n-  z_iilf(Rmask, 0xFF00FF00);\n-  z_iihf(Rmask, 0xFF00FF00);\n+  z_iilf(Rmask, (unsigned int)char_mask<<16 | (unsigned int)char_mask);\n+  z_iihf(Rmask, (unsigned int)char_mask<<16 | (unsigned int)char_mask);\n@@ -81,1 +102,1 @@\n-    \/\/   Strings with 4 and 8 characters were fond to occur very frequently.\n+    \/\/   Strings with 4 and 8 characters were found to occur very frequently.\n@@ -136,1 +157,2 @@\n-                                           \/\/ Must be multiple of 2*(vector register length in chars (8 HW = 128 bits)).\n+                                           \/\/ Must correspond to # vector registers used by implementation,\n+                                           \/\/ and must be a power of 2.\n@@ -153,1 +175,1 @@\n-    z_vgmh(Vmask, 0, 7);                   \/\/ generate 0xff00 mask for all 2-byte elements\n+    z_vgmh(Vmask, mask_ix_l, mask_ix_r);   \/\/ generate 0xff00\/0xff80 mask for all 2-byte elements\n@@ -165,1 +187,1 @@\n-      z_vceqhs(Vtmp1, Vtmp1, Vzero);       \/\/ high half of all chars must be zero for successful compress.\n+      z_vceqhs(Vtmp1, Vtmp1, Vzero);       \/\/ all bits selected by mask must be zero for successful compress.\n@@ -190,1 +212,2 @@\n-                                           \/\/ Must be multiple of 8.\n+                                           \/\/ Must correspond to # registers used by implementation,\n+                                           \/\/ and must be a power of 2.\n@@ -200,1 +223,1 @@\n-    z_sra(Rix, log_min_cnt);             \/\/ unrolled loop count\n+    z_sra(Rix, log_min_cnt);               \/\/ unrolled loop count\n@@ -247,0 +270,2 @@\n+      \/\/ Because we don't need to be precise, we just return the # of characters which have been written.\n+      \/\/ The first illegal character is in the index range [result-min_cnt\/2, result+min_cnt\/2).\n@@ -277,1 +302,1 @@\n-      z_tmll(Z_R1, 0xff00);\n+      z_tmll(Z_R1, char_mask);\n@@ -286,1 +311,1 @@\n-      z_tmll(Z_R1, 0xff00);\n+      z_tmll(Z_R1, char_mask);\n@@ -290,1 +315,1 @@\n-      z_tmll(Z_R0, 0xff00);\n+      z_tmll(Z_R0, char_mask);\n@@ -302,1 +327,1 @@\n-      z_srk(Rix, Rcnt, Z_R0);              \/\/ remaining # chars to compress in unrolled loop\n+      z_srk(Rix, Rcnt, Z_R0);              \/\/ remaining # chars to compress in scalar loop\n@@ -307,2 +332,2 @@\n-    z_lgfr(result, Rcnt);                  \/\/ # processed characters (if all runs ok).\n-    z_brz(ScalarDone);                     \/\/ uses CC from Rix calculation\n+    z_lgfr(result, Rcnt);                  \/\/ # processed characters (if all encodes ok).\n+    z_brz(ScalarDone);                     \/\/ anything left to do? (uses CC from Rix calculation)\n@@ -312,1 +337,1 @@\n-      z_tmll(Z_R1, 0xff00);\n+      z_tmll(Z_R1, char_mask);\n@@ -332,1 +357,5 @@\n-    BLOCK_COMMENT(\"} encode_iso_array\");\n+    if (toASCII) {\n+      BLOCK_COMMENT(\"} encode_ascii_array\");\n+    } else {\n+      BLOCK_COMMENT(\"} encode_iso_array\");\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":54,"deletions":25,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                               Register tmp,    bool precise);\n+                               Register tmp,    bool precise, bool toASCII);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  static const bool supports_encode_ascii_array = false;\n+  static const bool supports_encode_ascii_array = true;\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10233,1 +10233,1 @@\n-                       $tmp$$Register, false);\n+                       $tmp$$Register, false, false);\n@@ -10294,1 +10294,1 @@\n-  format %{ \"Encode array $src->$dst($len) -> $result\" %}\n+  format %{ \"Encode iso array $src->$dst($len) -> $result\" %}\n@@ -10297,1 +10297,15 @@\n-                       $tmp$$Register, true);\n+                       $tmp$$Register, true, false);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ encode char[] to byte[] in ASCII\n+instruct encode_ascii_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(TEMP_DEF result, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+  ins_cost(300);\n+  format %{ \"Encode ascii array $src->$dst($len) -> $result\" %}\n+  ins_encode %{\n+    __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,\n+                       $tmp$$Register, true, true);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"}]}