{"files":[{"patch":"@@ -113,4 +113,3 @@\n-  size_t num_regions = _heap->num_regions();\n-  if (_current_index >= (jint)num_regions) {\n-    return NULL;\n-  }\n+  \/\/ This code is optimized for the case when collection set contains only\n+  \/\/ a few regions. In this case, it is more constructive to check for is_in\n+  \/\/ before hitting the (potentially contended) atomic index.\n@@ -118,2 +117,2 @@\n-  jint saved_current = _current_index;\n-  size_t index = (size_t)saved_current;\n+  size_t max = _heap->num_regions();\n+  size_t old = Atomic::load(&_current_index);\n@@ -121,1 +120,1 @@\n-  while(index < num_regions) {\n+  for (size_t index = old; index < max; index++) {\n@@ -123,4 +122,4 @@\n-      jint cur = Atomic::cmpxchg(&_current_index, saved_current, (jint)(index + 1));\n-      assert(cur >= (jint)saved_current, \"Must move forward\");\n-      if (cur == saved_current) {\n-        assert(is_in(index), \"Invariant\");\n+      size_t cur = Atomic::cmpxchg(&_current_index, old, index + 1, memory_order_relaxed);\n+      assert(cur >= old, \"Always move forward\");\n+      if (cur == old) {\n+        \/\/ Successfully moved the claim index, this is our region.\n@@ -129,2 +128,3 @@\n-        index = (size_t)cur;\n-        saved_current = cur;\n+        \/\/ Somebody else moved the claim index, restart from there.\n+        index = cur - 1; \/\/ adjust for loop post-increment\n+        old = cur;\n@@ -132,2 +132,0 @@\n-    } else {\n-      index ++;\n@@ -142,2 +140,3 @@\n-  size_t num_regions = _heap->num_regions();\n-  for (size_t index = (size_t)_current_index; index < num_regions; index ++) {\n+\n+  size_t max = _heap->num_regions();\n+  for (size_t index = _current_index; index < max; index++) {\n@@ -145,1 +144,1 @@\n-      _current_index = (jint)(index + 1);\n+      _current_index = index + 1;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  volatile jint         _current_index;\n+  volatile size_t       _current_index;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1500,2 +1500,2 @@\n-    while (_index < max) {\n-      size_t cur = Atomic::fetch_and_add(&_index, stride);\n+    while (Atomic::load(&_index) < max) {\n+      size_t cur = Atomic::fetch_and_add(&_index, stride, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  size_t new_index = Atomic::add(&_index, (size_t) 1);\n+  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}