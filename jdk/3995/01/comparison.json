{"files":[{"patch":"@@ -1434,8 +1434,6 @@\n-Klass* Dependencies::find_finalizable_subclass(Klass* k) {\n-  if (k->is_interface())  return NULL;\n-  if (k->has_finalizer()) return k;\n-  k = k->subklass();\n-  while (k != NULL) {\n-    Klass* result = find_finalizable_subclass(k);\n-    if (result != NULL) return result;\n-    k = k->next_sibling();\n+Klass* Dependencies::find_finalizable_subclass(InstanceKlass* ik) {\n+  for (ClassHierarchyIterator iter(ik); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    if (sub->has_finalizer() && !sub->is_interface()) {\n+      return sub;\n+    }\n@@ -1443,1 +1441,1 @@\n-  return NULL;\n+  return NULL; \/\/ not found\n@@ -1592,2 +1590,2 @@\n-  Klass* search_at = ctxk;\n-  if (changes != NULL)\n+  InstanceKlass* search_at = ctxk;\n+  if (changes != NULL) {\n@@ -1595,0 +1593,1 @@\n+  }\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-  static Klass* find_finalizable_subclass(Klass* k);\n+  static Klass* find_finalizable_subclass(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,20 +334,4 @@\n-  Stack<const Klass*, mtTracing> mark_stack;\n-  mark_stack.push(vmClasses::ClassLoader_klass()->subklass());\n-\n-  while (!mark_stack.is_empty()) {\n-    const Klass* const current = mark_stack.pop();\n-    assert(current != NULL, \"null element in stack!\");\n-    if (is_classloader_klass_allowed(current)) {\n-      do_loader_klass(current);\n-    }\n-\n-    \/\/ subclass (depth)\n-    const Klass* next_klass = current->subklass();\n-    if (next_klass != NULL) {\n-      mark_stack.push(next_klass);\n-    }\n-\n-    \/\/ siblings (breadth)\n-    next_klass = current->next_sibling();\n-    if (next_klass != NULL) {\n-      mark_stack.push(next_klass);\n+  for (ClassHierarchyIterator iter(vmClasses::ClassLoader_klass()); !iter.done(); iter.next()) {\n+    Klass* subk = iter.klass();\n+    if (is_classloader_klass_allowed(subk)) {\n+      do_loader_klass(subk);\n@@ -356,1 +340,0 @@\n-  assert(mark_stack.is_empty(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-static void fill_klasses(GrowableArray<const void*>& event_subklasses, const Klass* event_klass, Thread* thread) {\n+static void fill_klasses(GrowableArray<const void*>& event_subklasses, const InstanceKlass* event_klass, Thread* thread) {\n@@ -84,21 +84,4 @@\n-  Stack<const Klass*, mtTracing> mark_stack;\n-  mark_stack.push(event_klass->subklass());\n-\n-  while (!mark_stack.is_empty()) {\n-    const Klass* const current = mark_stack.pop();\n-    assert(current != NULL, \"null element in stack!\");\n-\n-    if (is_allowed(current)) {\n-      event_subklasses.append(current);\n-    }\n-\n-    \/\/ subclass (depth)\n-    const Klass* next_klass = current->subklass();\n-    if (next_klass != NULL) {\n-      mark_stack.push(next_klass);\n-    }\n-\n-    \/\/ siblings (breadth)\n-    next_klass = current->next_sibling();\n-    if (next_klass != NULL) {\n-      mark_stack.push(next_klass);\n+  for (ClassHierarchyIterator iter(const_cast<InstanceKlass*>(event_klass)); !iter.done(); iter.next()) {\n+    Klass* subk = iter.klass();\n+    if (is_allowed(subk)) {\n+      event_subklasses.append(subk);\n@@ -107,1 +90,0 @@\n-  assert(mark_stack.is_empty(), \"invariant\");\n@@ -135,0 +117,1 @@\n+  assert(klass->is_instance_klass(), \"invariant\");\n@@ -143,1 +126,1 @@\n-  fill_klasses(event_subklasses, klass, THREAD);\n+  fill_klasses(event_subklasses, InstanceKlass::cast(klass), THREAD);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.cpp","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -830,1 +830,5 @@\n-  return Dependencies::find_finalizable_subclass(klass) != NULL;\n+  if (!klass->is_instance_klass()) {\n+    return false;\n+  }\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  return Dependencies::find_finalizable_subclass(iklass) != NULL;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -516,12 +516,0 @@\n-static void reinitialize_vtable_of(Klass* ko) {\n-  \/\/ init vtable of k and all subclasses\n-  ko->vtable().initialize_vtable();\n-  if (ko->is_instance_klass()) {\n-    for (Klass* sk = ko->subklass();\n-         sk != NULL;\n-         sk = sk->next_sibling()) {\n-      reinitialize_vtable_of(sk);\n-    }\n-  }\n-}\n-\n@@ -532,2 +520,4 @@\n-  Klass* ok = vmClasses::Object_klass();\n-  reinitialize_vtable_of(ok);\n+  for (ClassHierarchyIterator iter(vmClasses::Object_klass()); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    sub->vtable().initialize_vtable();\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1430,1 +1430,0 @@\n-    assert(!root->is_interface(), \"no subclasses\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4425,1 +4425,1 @@\n-  increment_class_counter((InstanceKlass *)the_class);\n+  increment_class_counter(the_class);\n@@ -4454,18 +4454,14 @@\n-void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik) {\n-  oop class_mirror = ik->java_mirror();\n-  Klass* class_oop = java_lang_Class::as_Klass(class_mirror);\n-  int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;\n-  java_lang_Class::set_classRedefinedCount(class_mirror, new_count);\n-\n-  if (class_oop != _the_class) {\n-    \/\/ _the_class count is printed at end of redefine_single_class()\n-    log_debug(redefine, class, subclass)(\"updated count in subclass=%s to %d\", ik->external_name(), new_count);\n-  }\n-\n-  for (Klass *subk = ik->subklass(); subk != NULL;\n-       subk = subk->next_sibling()) {\n-    if (subk->is_instance_klass()) {\n-      \/\/ Only update instanceKlasses\n-      InstanceKlass *subik = InstanceKlass::cast(subk);\n-      \/\/ recursively do subclasses of the current subclass\n-      increment_class_counter(subik);\n+void VM_RedefineClasses::increment_class_counter(InstanceKlass* ik) {\n+  for (ClassHierarchyIterator iter(ik); !iter.done(); iter.next()) {\n+    \/\/ Only update instanceKlasses\n+    Klass* sub = iter.klass();\n+    if (sub->is_instance_klass()) {\n+      oop class_mirror = InstanceKlass::cast(sub)->java_mirror();\n+      Klass* class_oop = java_lang_Class::as_Klass(class_mirror);\n+      int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;\n+      java_lang_Class::set_classRedefinedCount(class_mirror, new_count);\n+\n+      if (class_oop != _the_class) {\n+        \/\/ _the_class count is printed at end of redefine_single_class()\n+        log_debug(redefine, class, subclass)(\"updated count in subclass=%s to %d\", ik->external_name(), new_count);\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  void increment_class_counter(InstanceKlass *ik);\n+  void increment_class_counter(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}