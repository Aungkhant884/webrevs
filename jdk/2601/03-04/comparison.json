{"files":[{"patch":"@@ -175,1 +175,4 @@\n-        synchronized (ExtendedSocketOptions.class) {\n+        try {\n+            \/\/ If the class is present, it will be initialized which\n+            \/\/ triggers registration of the extended socket options.\n+            Class<?> c = Class.forName(\"jdk.net.ExtendedSocketOptions\");\n@@ -177,8 +180,6 @@\n-            if (ext != null) {\n-                return ext;\n-            }\n-            try {\n-                \/\/ If the class is present, it will be initialized which\n-                \/\/ triggers registration of the extended socket options.\n-                Class<?> c = Class.forName(\"jdk.net.ExtendedSocketOptions\");\n-            } catch (ClassNotFoundException e) {\n+        } catch (ClassNotFoundException e) {\n+            synchronized (ExtendedSocketOptions.class) {\n+                ext = instance;\n+                if (ext != null) {\n+                    return ext;\n+                }\n@@ -186,1 +187,1 @@\n-                instance = new NoExtendedSocketOptions();\n+                ext = instance = new NoExtendedSocketOptions();\n@@ -189,1 +190,1 @@\n-        return instance;\n+        return ext;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ext\/ExtendedSocketOptions.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -50,2 +53,3 @@\n-     * concurrently in a thread of their own and expects the classloading of both those classes\n-     * to succeed. Additionally, after the classloading is successfully done, calls the\n+     * and invokes {@code sun.net.ext.ExtendedSocketOptions#getInstance()} concurrently in a thread\n+     * of their own and expects the classloading of both those classes\n+     * to succeed. Additionally, after these tasks are done, calls the\n@@ -57,4 +61,8 @@\n-        final CountDownLatch classLoadingTriggerLatch = new CountDownLatch(2);\n-        final Callable<Class<?>> task1 = new Task(\"jdk.net.ExtendedSocketOptions\", classLoadingTriggerLatch);\n-        final Callable<Class<?>> task2 = new Task(\"sun.net.ext.ExtendedSocketOptions\", classLoadingTriggerLatch);\n-        final ExecutorService executor = Executors.newFixedThreadPool(2);\n+        final CountDownLatch taskTriggerLatch = new CountDownLatch(4);\n+        final List<Callable<?>> tasks = new ArrayList<>();\n+        tasks.add(new Task(\"jdk.net.ExtendedSocketOptions\", taskTriggerLatch));\n+        tasks.add(new Task(\"sun.net.ext.ExtendedSocketOptions\", taskTriggerLatch));\n+        \/\/ add a couple of tasks which call sun.net.ext.ExtendedSocketOptions#getInstance\n+        tasks.add(new GetInstanceTask(taskTriggerLatch));\n+        tasks.add(new GetInstanceTask(taskTriggerLatch));\n+        final ExecutorService executor = Executors.newFixedThreadPool(tasks.size());\n@@ -62,1 +70,1 @@\n-            final Future<Class<?>>[] results = new Future[2];\n+            final Future<?>[] results = new Future[tasks.size()];\n@@ -64,2 +72,3 @@\n-            for (int i = 0; i < 2; i++) {\n-                results[i] = executor.submit(i == 0 ? task1 : task2);\n+            int i = 0;\n+            for (final Callable<?> task : tasks) {\n+                results[i++] = executor.submit(task);\n@@ -68,3 +77,2 @@\n-            for (int i = 0; i < 2; i++) {\n-                final Class<?> k = results[i].get();\n-                System.out.println(\"Completed loading \" + k.getName());\n+            for (i = 0; i < tasks.size(); i++) {\n+                results[i].get();\n@@ -77,2 +85,1 @@\n-        final Class<?> k = Class.forName(\"sun.net.ext.ExtendedSocketOptions\");\n-        final Object extSocketOptions = k.getDeclaredMethod(\"getInstance\").invoke(null);\n+        final Object extSocketOptions = callSunNetExtSocketOptionsGetInstance();\n@@ -81,0 +88,16 @@\n+        \/\/ now verify that each call to getInstance(), either in the tasks or here, returned the exact\n+        \/\/ same instance of ExtendedSocketOptions\n+        Assert.assertEquals(2, GetInstanceTask.extendedSocketOptionsInstances.size());\n+        for (final Object inst : GetInstanceTask.extendedSocketOptionsInstances) {\n+            Assert.assertSame(inst, extSocketOptions, \"sun.net.ext.ExtendedSocketOptions#getInstance()\" +\n+                    \" returned different instances\");\n+        }\n+    }\n+\n+    \/**\n+     * Reflectively calls sun.net.ext.ExtendedSocketOptions#getInstance() and returns\n+     * the result\n+     *\/\n+    private static Object callSunNetExtSocketOptionsGetInstance() throws Exception {\n+        final Class<?> k = Class.forName(\"sun.net.ext.ExtendedSocketOptions\");\n+        return k.getDeclaredMethod(\"getInstance\").invoke(null);\n@@ -85,1 +108,1 @@\n-        private final CountDownLatch classLoadingTriggerLatch;\n+        private final CountDownLatch latch;\n@@ -87,1 +110,1 @@\n-        private Task(final String className, final CountDownLatch classLoadingTriggerLatch) {\n+        private Task(final String className, final CountDownLatch latch) {\n@@ -89,1 +112,1 @@\n-            this.classLoadingTriggerLatch = classLoadingTriggerLatch;\n+            this.latch = latch;\n@@ -92,0 +115,1 @@\n+        @Override\n@@ -95,4 +119,4 @@\n-                \/\/ let the other task know we are ready to load the class\n-                classLoadingTriggerLatch.countDown();\n-                \/\/ wait for the other task to let us know it's ready too, to load the class\n-                classLoadingTriggerLatch.await();\n+                \/\/ let the other tasks know we are ready to trigger our work\n+                latch.countDown();\n+                \/\/ wait for the other task to let us know they are ready to trigger their work too\n+                latch.await();\n@@ -101,1 +125,29 @@\n-                System.err.println(\"Failed to load \" + this.className);\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private static class GetInstanceTask implements Callable<Object> {\n+        \/\/ keeps track of the instances returned by calls to sun.nex.ext.ExtendedSocketOptions#getInstance()\n+        \/\/ by the GetInstanceTask(s)\n+        private static final List<Object> extendedSocketOptionsInstances = Collections.synchronizedList(new ArrayList<>());\n+        private final CountDownLatch latch;\n+\n+        private GetInstanceTask(final CountDownLatch latch) {\n+            this.latch = latch;\n+        }\n+\n+        @Override\n+        public Object call() {\n+            System.out.println(Thread.currentThread().getName()\n+                    + \" calling  sun.net.ext.ExtendedSocketOptions#getInstance()\");\n+            try {\n+                \/\/ let the other tasks know we are ready to trigger our work\n+                latch.countDown();\n+                \/\/ wait for the other task to let us know they are ready to trigger their work too\n+                latch.await();\n+                \/\/ let's call getInstance on sun.net.ext.ExtendedSocketOptions\n+                final Object inst = callSunNetExtSocketOptionsGetInstance();\n+                extendedSocketOptionsInstances.add(inst);\n+                return inst;\n+            } catch (Exception e) {\n","filename":"test\/jdk\/sun\/net\/ext\/ExtendedSocketOptionsTest.java","additions":74,"deletions":22,"binary":false,"changes":96,"status":"modified"}]}