{"files":[{"patch":"@@ -5352,1 +5352,1 @@\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, null, true) != null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3692,1 +3692,2 @@\n-        Map<Symbol,Symbol> callMap = new HashMap<>();\n+        \/\/ use LinkedHashMap so we generate errors deterministically\n+        Map<Symbol,Symbol> callMap = new LinkedHashMap<>();\n@@ -3721,1 +3722,1 @@\n-                log.error(TreeInfo.diagnosticPositionFor(ctor, tree),\n+                log.error(TreeInfo.diagnosticPositionFor(ctor, tree, JCIdent.class::isInstance, false),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Predicate;\n@@ -709,1 +710,1 @@\n-        return diagnosticPositionFor(sym, tree, false);\n+        return diagnosticPositionFor(sym, tree, null, false);\n@@ -712,1 +713,2 @@\n-    public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree, boolean returnNullIfNotFound) {\n+    public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree,\n+            Predicate<? super JCTree> filter, boolean returnNullIfNotFound) {\n@@ -714,2 +716,2 @@\n-            DiagScanner(Symbol sym) {\n-                super(sym);\n+            DiagScanner(Symbol sym, Predicate<? super JCTree> filter) {\n+                super(sym, filter);\n@@ -719,2 +721,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitIdent(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitIdent(that);\n@@ -723,2 +725,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitSelect(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitSelect(that);\n@@ -727,1 +729,1 @@\n-        DiagScanner s = new DiagScanner(sym);\n+        DiagScanner s = new DiagScanner(sym, filter);\n@@ -740,0 +742,1 @@\n+        final Predicate<? super JCTree> filter;\n@@ -741,1 +744,1 @@\n-        DeclScanner(final Symbol sym) {\n+        DeclScanner(final Symbol sym, Predicate<? super JCTree> filter) {\n@@ -743,0 +746,1 @@\n+            this.filter = filter;\n@@ -751,2 +755,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitTopLevel(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitTopLevel(that);\n@@ -755,1 +759,1 @@\n-            if (that.sym == sym) result = that;\n+            checkMatch(that, that.sym);\n@@ -759,2 +763,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitPackageDef(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitPackageDef(that);\n@@ -763,2 +767,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitClassDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitClassDef(that);\n@@ -767,2 +771,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitMethodDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitMethodDef(that);\n@@ -771,2 +775,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitVarDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitVarDef(that);\n@@ -775,2 +779,10 @@\n-            if (that.type != null && that.type.tsym == sym) result = that;\n-            else super.visitTypeParameter(that);\n+            if (that.type == null || !checkMatch(that, that.type.tsym))\n+                super.visitTypeParameter(that);\n+        }\n+\n+        protected boolean checkMatch(JCTree that, Symbol thatSym) {\n+            if (thatSym == this.sym && (filter == null || filter.test(that))) {\n+                result = that;\n+                return true;\n+            }\n+            return false;\n@@ -783,1 +795,1 @@\n-        DeclScanner s = new DeclScanner(sym);\n+        DeclScanner s = new DeclScanner(sym, null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug     8295024\n+ * @summary Cyclic constructor error is non-deterministic and inconsistent\n+ * @compile T8295024.java\n+ * @run main T8295024\n+ *\/\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import javax.tools.*;\n+public class T8295024 {\n+\n+    private static final int NUM_RUNS = 10;\n+    private static final String EXPECTED_ERROR = \"\"\"\n+        Cyclic.java:12:9: compiler.err.recursive.ctor.invocation\n+        1 error\n+        \"\"\";\n+    private static final String SOURCE = \"\"\"\n+        public class Cyclic {\n+            public Cyclic(int x) {\n+                this((float)x);\n+            }\n+            public Cyclic(float x) {\n+                this((long)x);\n+            }\n+            public Cyclic(long x) {\n+                this((double)x);\n+            }\n+            public Cyclic(double x) {\n+                this((int)x);\n+            \/\/  ^ error should be reported here every time\n+            }\n+        }\n+        \"\"\";\n+\n+    private static final SimpleJavaFileObject FILE = new SimpleJavaFileObject(\n+      URI.create(\"string:\/\/\/Cyclic.java\"), JavaFileObject.Kind.SOURCE) {\n+        @Override\n+        public String getCharContent(boolean ignoreEncodingErrors) {\n+            return  SOURCE;\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Compile program NUM_RUNS times\n+        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        final StringWriter output = new StringWriter();\n+        final Iterable<String> options = Collections.singleton(\"-XDrawDiagnostics\");\n+        final Iterable<SimpleJavaFileObject> files = Collections.singleton(FILE);\n+        for (int i = 0; i < NUM_RUNS; i++)\n+            compiler.getTask(output, null, null, options, null, files).call();\n+\n+        \/\/ Verify consistent error report each time\n+        final String expected = IntStream.range(0, NUM_RUNS)\n+          .mapToObj(i -> EXPECTED_ERROR)\n+          .collect(Collectors.joining(\"\"));\n+        final String actual = output.toString().replaceAll(\"\\\\r\", \"\");\n+        assert expected.equals(actual) : \"EXPECTED:\\n\" + expected + \"ACTUAL:\\n\" + actual;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8295024\/T8295024.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}