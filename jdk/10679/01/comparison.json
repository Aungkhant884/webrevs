{"files":[{"patch":"@@ -3692,1 +3692,2 @@\n-        Map<Symbol,Symbol> callMap = new HashMap<>();\n+        \/\/ use LinkedHashMap so we generate errors deterministically\n+        Map<Symbol,Symbol> callMap = new LinkedHashMap<>();\n@@ -3721,1 +3722,1 @@\n-                log.error(TreeInfo.diagnosticPositionFor(ctor, tree),\n+                log.error(TreeInfo.diagnosticPositionFor(ctor, tree, false, t -> t.hasTag(IDENT)),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Predicate;\n@@ -713,0 +714,5 @@\n+        return diagnosticPositionFor(sym, tree, returnNullIfNotFound, null);\n+    }\n+\n+    public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree, boolean returnNullIfNotFound,\n+            Predicate<? super JCTree> filter) {\n@@ -714,2 +720,2 @@\n-            DiagScanner(Symbol sym) {\n-                super(sym);\n+            DiagScanner(Symbol sym, Predicate<? super JCTree> filter) {\n+                super(sym, filter);\n@@ -719,2 +725,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitIdent(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitIdent(that);\n@@ -723,2 +729,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitSelect(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitSelect(that);\n@@ -727,1 +733,1 @@\n-        DiagScanner s = new DiagScanner(sym);\n+        DiagScanner s = new DiagScanner(sym, filter);\n@@ -740,0 +746,1 @@\n+        final Predicate<? super JCTree> filter;\n@@ -742,0 +749,3 @@\n+            this(sym, null);\n+        }\n+        DeclScanner(final Symbol sym, Predicate<? super JCTree> filter) {\n@@ -743,0 +753,1 @@\n+            this.filter = filter;\n@@ -751,2 +762,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitTopLevel(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitTopLevel(that);\n@@ -755,1 +766,1 @@\n-            if (that.sym == sym) result = that;\n+            checkMatch(that, that.sym);\n@@ -759,2 +770,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitPackageDef(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitPackageDef(that);\n@@ -763,2 +774,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitClassDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitClassDef(that);\n@@ -767,2 +778,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitMethodDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitMethodDef(that);\n@@ -771,2 +782,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitVarDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitVarDef(that);\n@@ -775,2 +786,10 @@\n-            if (that.type != null && that.type.tsym == sym) result = that;\n-            else super.visitTypeParameter(that);\n+            if (that.type == null || !checkMatch(that, that.type.tsym))\n+                super.visitTypeParameter(that);\n+        }\n+\n+        protected boolean checkMatch(JCTree that, Symbol thatSym) {\n+            if (thatSym == this.sym && (filter == null || filter.test(that))) {\n+                result = that;\n+                return true;\n+            }\n+            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":39,"deletions":20,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug     8295024\n+ * @summary Cyclic constructor error is non-deterministic and inconsistent\n+ *\/\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import javax.tools.*;\n+public class T8295024 {\n+\n+    private static final int NUM_RUNS = 10;\n+    private static final String EXPECTED_ERROR = \"\"\"\n+        Cyclic.java:12:9: compiler.err.recursive.ctor.invocation\n+        1 error\n+        \"\"\";\n+    private static final String SOURCE = \"\"\"\n+        public class Cyclic {\n+            public Cyclic(int x) {\n+                this((float)x);\n+            }\n+            public Cyclic(float x) {\n+                this((long)x);\n+            }\n+            public Cyclic(long x) {\n+                this((double)x);\n+            }\n+            public Cyclic(double x) {\n+                this((int)x);\n+            \/\/  ^ error should be reported here every time\n+            }\n+        }\n+        \"\"\";\n+\n+    private static final SimpleJavaFileObject FILE = new SimpleJavaFileObject(\n+      URI.create(\"string:\/\/\/Cyclic.java\"), JavaFileObject.Kind.SOURCE) {\n+        @Override\n+        public String getCharContent(boolean ignoreEncodingErrors) {\n+            return  SOURCE;\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Compile program NUM_RUNS times\n+        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        final StringWriter output = new StringWriter();\n+        final Iterable<String> options = Collections.singleton(\"-XDrawDiagnostics\");\n+        final Iterable<SimpleJavaFileObject> files = Collections.singleton(FILE);\n+        for (int i = 0; i < NUM_RUNS; i++)\n+            compiler.getTask(output, null, null, options, null, files).call();\n+\n+        \/\/ Verify consistent error report each time\n+        final String expected = IntStream.range(0, NUM_RUNS)\n+          .mapToObj(i -> EXPECTED_ERROR)\n+          .collect(Collectors.joining(\"\"));\n+        final String actual = output.toString().replaceAll(\"\\\\r\", \"\");\n+        assert expected.equals(actual) : \"EXPECTED:\\n\" + expected + \"ACTUAL:\\n\" + actual;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8295024\/T8295024.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}