{"files":[{"patch":"@@ -62,0 +62,31 @@\n+\/\/ Small wrapper to provide semaphore version of a lock.\n+\/\/ Useful for low-level leaf locks.\n+class SemaphoreLock : public CHeapObj<mtSynchronizer> {\n+  Semaphore _semaphore;\n+\n+public:\n+  SemaphoreLock() : _semaphore(1) {}\n+\n+  void lock()     { _semaphore.wait(); }\n+  void unlock()   { _semaphore.signal(); }\n+  bool try_lock() { return _semaphore.trywait(); }\n+};\n+\n+\/\/ Convenience RAII class to lock a SemaphoreLock.\n+class SemaphoreLocker : public StackObj {\n+  SemaphoreLock* const _lock;\n+\n+public:\n+  SemaphoreLocker(SemaphoreLock* lock) : _lock(lock) {\n+    if (_lock != NULL) {\n+      _lock->lock();\n+    }\n+  }\n+\n+  ~SemaphoreLocker() {\n+    if (_lock != NULL) {\n+      _lock->unlock();\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/semaphore.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -106,0 +106,28 @@\n+\n+TEST(SemaphoreLock, lock_unlock) {\n+  SemaphoreLock lock;\n+  lock.lock();\n+  lock.unlock();\n+}\n+\n+TEST(SemaphoreLock, try_lock) {\n+  SemaphoreLock lock;\n+  lock.lock();\n+  ASSERT_EQ(lock.try_lock(), false);\n+  lock.unlock();\n+\n+  ASSERT_EQ(lock.try_lock(), true);\n+  lock.unlock();\n+}\n+\n+TEST(SemaphoreLocker, sanity) {\n+  SemaphoreLock lock;\n+\n+  {\n+    SemaphoreLocker sl(&lock);\n+    ASSERT_EQ(lock.try_lock(), false);\n+  }\n+\n+  ASSERT_EQ(lock.try_lock(), true);\n+  lock.unlock();\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_semaphore.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}