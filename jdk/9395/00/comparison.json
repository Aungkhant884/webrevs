{"files":[{"patch":"@@ -82,13 +82,0 @@\n-void G1BlockOffsetTablePart::update() {\n-  HeapWord* next_addr = _hr->bottom();\n-  HeapWord* const limit = _hr->top();\n-\n-  HeapWord* prev_addr;\n-  while (next_addr < limit) {\n-    prev_addr = next_addr;\n-    next_addr  = prev_addr + block_size(prev_addr);\n-    update_for_block(prev_addr, next_addr);\n-  }\n-  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n-}\n-\n@@ -278,1 +265,1 @@\n-        size_t obj_size = block_size(obj);\n+        size_t obj_size = _hr->block_size(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  friend class HeapRegion;\n@@ -117,1 +116,1 @@\n-  \/\/ The region that owns this subregion.\n+  \/\/ The region that owns this part of the BOT.\n@@ -124,11 +123,0 @@\n-  inline size_t block_size(const HeapWord* p) const;\n-\n-  \/\/ Returns the address of a block whose start is at most \"addr\".\n-  inline HeapWord* block_at_or_preceding(const void* addr) const;\n-\n-  \/\/ Return the address of the beginning of the block that contains \"addr\".\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the space.)\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                    const void* addr) const;\n-\n@@ -155,2 +143,0 @@\n-  void update();\n-\n@@ -159,6 +145,5 @@\n-  \/\/ Returns the address of the start of the block containing \"addr\", or\n-  \/\/ else \"null\" if it is covered by no block.  (May have side effects,\n-  \/\/ namely updating of shared array entries that \"point\" too far\n-  \/\/ backwards.  This can occur, for example, when lab allocation is used\n-  \/\/ in a space covered by the table.)\n-  inline HeapWord* block_start(const void* addr);\n+  void assert_same_bot_entry(const void* n, const void* addr) const NOT_DEBUG_RETURN;\n+\n+  \/\/ Returns the address of the start of the block reaching into the card containing\n+  \/\/ \"addr\".\n+  inline HeapWord* block_start_reaching_into_card(const void* addr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,1 +35,9 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) {\n+#ifdef ASSERT\n+inline void G1BlockOffsetTablePart::assert_same_bot_entry(const void* n, const void* addr) const {\n+  assert(_bot->index_for(n) == _bot->index_for(addr),\n+         \"BOT not precise. Index for n: \" SIZE_FORMAT \" must be equal to the index for addr: \" SIZE_FORMAT,\n+         _bot->index_for(n), _bot->index_for(addr));\n+}\n+#endif\n+\n+inline HeapWord* G1BlockOffsetTablePart::block_start_reaching_into_card(const void* addr) {\n@@ -37,3 +45,24 @@\n-  HeapWord* q = block_at_or_preceding(addr);\n-  HeapWord* n = q + block_size(q);\n-  return forward_to_block_containing_addr(q, n, addr);\n+\n+#ifdef ASSERT\n+  if (!_hr->is_continues_humongous()) {\n+    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n+    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n+    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n+           offset, _hr->hrm_index(), _hr->get_short_type_str());\n+  }\n+#endif\n+\n+  size_t index = _bot->index_for(addr);\n+\n+  uint offset = _bot->offset_array(index);\n+  while (offset >= BOTConstants::card_size_in_words()) {\n+    \/\/ The excess of the offset from N_words indicates a power of Base\n+    \/\/ to go back by.\n+    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n+    index -= n_cards_back;\n+    offset = _bot->offset_array(index);\n+  }\n+  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n+\n+  HeapWord* q = _bot->address_for_index(index);\n+  return q - offset;\n@@ -98,50 +127,0 @@\n-inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p) const {\n-  return _hr->block_size(p);\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr) const {\n-#ifdef ASSERT\n-  if (!_hr->is_continues_humongous()) {\n-    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n-    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n-    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n-           offset, _hr->hrm_index(), _hr->get_short_type_str());\n-  }\n-#endif\n-\n-  size_t index = _bot->index_for(addr);\n-\n-  uint offset = _bot->offset_array(index);  \/\/ Extend u_char to uint.\n-  while (offset >= BOTConstants::card_size_in_words()) {\n-    \/\/ The excess of the offset from N_words indicates a power of Base\n-    \/\/ to go back by.\n-    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n-    index -= n_cards_back;\n-    offset = _bot->offset_array(index);\n-  }\n-  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n-\n-  HeapWord* q = _bot->address_for_index(index);\n-  return q - offset;\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                                          const void* addr) const {\n-  while (n <= addr) {\n-    \/\/ When addr is not covered by the block starting at q we need to\n-    \/\/ step forward until we find the correct block. With the BOT\n-    \/\/ being precise, we should never have to step through more than\n-    \/\/ a single card.\n-    assert(_bot->index_for(n) == _bot->index_for(addr),\n-           \"BOT not precise. Index for n: \" SIZE_FORMAT \" must be equal to the index for addr: \" SIZE_FORMAT,\n-           _bot->index_for(n), _bot->index_for(addr));\n-    q = n;\n-    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n-        \"start of block must be an initialized object\");\n-    n += block_size(q);\n-  }\n-  assert(q <= addr, \"wrong order for q and addr\");\n-  assert(addr < n, \"wrong order for addr and n\");\n-  return q;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":33,"deletions":54,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -267,0 +267,12 @@\n+void HeapRegion::update_bot() {\n+  HeapWord* next_addr = bottom();\n+  HeapWord* const limit = top();\n+\n+  HeapWord* prev_addr;\n+  while (next_addr < limit) {\n+    prev_addr = next_addr;\n+    next_addr  = prev_addr + block_size(prev_addr);\n+    _bot_part.update_for_block(prev_addr, next_addr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -147,0 +147,6 @@\n+  \/\/ Return the address of the beginning of the block that contains \"addr\".\n+  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n+  \/\/ next block (or the end of the HeapRegion.)\n+  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                    const void* addr) const;\n+\n@@ -148,1 +154,2 @@\n-  HeapWord* block_start(const void* p);\n+  \/\/ Returns the address of the block reaching into or starting at addr.\n+  HeapWord* block_start(const void* addr);\n@@ -192,3 +199,1 @@\n-  void update_bot() {\n-    _bot_part.update();\n-  }\n+  void update_bot();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,2 +82,24 @@\n-inline HeapWord* HeapRegion::block_start(const void* p) {\n-  return _bot_part.block_start(p);\n+inline HeapWord* HeapRegion::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                              const void* addr) const {\n+  while (n <= addr) {\n+    \/\/ When addr is not covered by the block starting at q we need to\n+    \/\/ step forward until we find the correct block. With the BOT\n+    \/\/ being precise, we should never have to step through more than\n+    \/\/ a single card.\n+    _bot_part.assert_same_bot_entry(n, addr);\n+    q = n;\n+    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n+        \"start of block must be an initialized object\");\n+    n += block_size(q);\n+  }\n+  assert(q <= addr, \"wrong order for q and addr\");\n+  assert(addr < n, \"wrong order for addr and n\");\n+  return q;\n+}\n+\n+inline HeapWord* HeapRegion::block_start(const void* addr) {\n+  HeapWord* q = _bot_part.block_start_reaching_into_card(addr);\n+  \/\/ The returned address is the block that reaches into the card of addr. Walk\n+  \/\/ the heap to get to the block reaching into addr.\n+  HeapWord* n = q + block_size(q);\n+  return forward_to_block_containing_addr(q, n, addr);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"}]}