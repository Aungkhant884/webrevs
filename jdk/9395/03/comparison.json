{"files":[{"patch":"@@ -137,1 +137,1 @@\n-  DEBUG_ONLY(check_all_cards(start_card, end_card);)\n+  check_all_cards(start_card, end_card);\n@@ -140,0 +140,1 @@\n+#ifdef ASSERT\n@@ -177,0 +178,1 @@\n+#endif\n@@ -265,1 +267,1 @@\n-        size_t obj_size = block_size(obj);\n+        size_t obj_size = _hr->block_size(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  friend class HeapRegion;\n@@ -117,1 +116,1 @@\n-  \/\/ The region that owns this subregion.\n+  \/\/ The region that owns this part of the BOT.\n@@ -125,1 +124,0 @@\n-  inline size_t block_size(const HeapWord* p, HeapWord* pb) const;\n@@ -133,1 +131,0 @@\n-  \/\/ \"pb\" is the current value of the region's parsable_bottom.\n@@ -141,1 +138,1 @@\n-  void check_all_cards(size_t left_card, size_t right_card) const;\n+  void check_all_cards(size_t left_card, size_t right_card) const NOT_DEBUG_RETURN;\n@@ -143,1 +140,0 @@\n-public:\n@@ -148,0 +144,4 @@\n+  void update_for_block(HeapWord* blk_start, size_t size) {\n+    update_for_block(blk_start, blk_start + size);\n+  }\n+public:\n@@ -160,7 +160,3 @@\n-  \/\/ Returns the address of the start of the block containing \"addr\", or\n-  \/\/ else \"null\" if it is covered by no block.  (May have side effects,\n-  \/\/ namely updating of shared array entries that \"point\" too far\n-  \/\/ backwards.  This can occur, for example, when lab allocation is used\n-  \/\/ in a space covered by the table.)\n-  \/\/ \"pb\" is the current value of the region's parsable_bottom.\n-  inline HeapWord* block_start(const void* addr, HeapWord* pb);\n+  \/\/ Returns the address of the start of the block reaching into the card containing\n+  \/\/ \"addr\".\n+  inline HeapWord* block_start_reaching_into_card(const void* addr) const;\n@@ -174,4 +170,0 @@\n-  void update_for_block(HeapWord* blk_start, size_t size) {\n-    update_for_block(blk_start, blk_start + size);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr, HeapWord* const pb) {\n+inline HeapWord* G1BlockOffsetTablePart::block_start_reaching_into_card(const void* addr) const {\n@@ -37,3 +37,24 @@\n-  HeapWord* q = block_at_or_preceding(addr);\n-  HeapWord* n = q + block_size(q, pb);\n-  return forward_to_block_containing_addr(q, n, addr, pb);\n+\n+#ifdef ASSERT\n+  if (!_hr->is_continues_humongous()) {\n+    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n+    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n+    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n+           offset, _hr->hrm_index(), _hr->get_short_type_str());\n+  }\n+#endif\n+\n+  size_t index = _bot->index_for(addr);\n+\n+  uint offset = _bot->offset_array(index);\n+  while (offset >= BOTConstants::card_size_in_words()) {\n+    \/\/ The excess of the offset from N_words indicates a power of Base\n+    \/\/ to go back by.\n+    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n+    index -= n_cards_back;\n+    offset = _bot->offset_array(index);\n+  }\n+  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n+\n+  HeapWord* q = _bot->address_for_index(index);\n+  return q - offset;\n@@ -98,55 +119,0 @@\n-inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p) const {\n-  return _hr->block_size(p);\n-}\n-\n-inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p, HeapWord* const pb) const {\n-  return _hr->block_size(p, pb);\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr) const {\n-#ifdef ASSERT\n-  if (!_hr->is_continues_humongous()) {\n-    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n-    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n-    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n-           offset, _hr->hrm_index(), _hr->get_short_type_str());\n-  }\n-#endif\n-\n-  size_t index = _bot->index_for(addr);\n-\n-  uint offset = _bot->offset_array(index);  \/\/ Extend u_char to uint.\n-  while (offset >= BOTConstants::card_size_in_words()) {\n-    \/\/ The excess of the offset from N_words indicates a power of Base\n-    \/\/ to go back by.\n-    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n-    index -= n_cards_back;\n-    offset = _bot->offset_array(index);\n-  }\n-  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n-\n-  HeapWord* q = _bot->address_for_index(index);\n-  return q - offset;\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                                          const void* addr,\n-                                                                          HeapWord* const pb) const {\n-  while (n <= addr) {\n-    \/\/ When addr is not covered by the block starting at q we need to\n-    \/\/ step forward until we find the correct block. With the BOT\n-    \/\/ being precise, we should never have to step through more than\n-    \/\/ a single card.\n-    assert(_bot->index_for(n) == _bot->index_for(addr),\n-           \"BOT not precise. Index for n: \" SIZE_FORMAT \" must be equal to the index for addr: \" SIZE_FORMAT,\n-           _bot->index_for(n), _bot->index_for(addr));\n-    q = n;\n-    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n-        \"start of block must be an initialized object\");\n-    n += block_size(q, pb);\n-  }\n-  assert(q <= addr, \"wrong order for q and addr\");\n-  assert(addr < n, \"wrong order for addr and n\");\n-  return q;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":25,"deletions":59,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -266,0 +266,12 @@\n+void HeapRegion::update_bot() {\n+  HeapWord* next_addr = bottom();\n+  HeapWord* const limit = top();\n+\n+  HeapWord* prev_addr;\n+  while (next_addr < limit) {\n+    prev_addr = next_addr;\n+    next_addr  = prev_addr + block_size(prev_addr);\n+    _bot_part.update_for_block(prev_addr, next_addr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -147,0 +147,7 @@\n+  \/\/ Return the address of the beginning of the block that contains \"addr\".\n+  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n+  \/\/ next block (or the end of the HeapRegion.)\n+  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                    const void* addr,\n+                                                    HeapWord* pb) const;\n+\n@@ -150,1 +157,3 @@\n-  HeapWord* block_start(const void* addr, HeapWord* const pb);\n+  \/\/ Returns the address of the block reaching into or starting at addr.\n+  HeapWord* block_start(const void* addr) const;\n+  HeapWord* block_start(const void* addr, HeapWord* const pb) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -85,2 +85,29 @@\n-inline HeapWord* HeapRegion::block_start(const void* addr, HeapWord* const pb) {\n-  return _bot_part.block_start(addr, pb);\n+inline HeapWord* HeapRegion::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                              const void* addr,\n+                                                              HeapWord* pb) const {\n+  while (n <= addr) {\n+    \/\/ When addr is not covered by the block starting at q we need to\n+    \/\/ step forward until we find the correct block. With the BOT\n+    \/\/ being precise, we should never have to step through more than\n+    \/\/ a single card.\n+    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(n, (HeapWord*)addr), \"must be\");\n+    q = n;\n+    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n+        \"start of block must be an initialized object\");\n+    n += block_size(q, pb);\n+  }\n+  assert(q <= addr, \"wrong order for q and addr\");\n+  assert(addr < n, \"wrong order for addr and n\");\n+  return q;\n+}\n+\n+inline HeapWord* HeapRegion::block_start(const void* addr) const {\n+  return block_start(addr, parsable_bottom_acquire());\n+}\n+\n+inline HeapWord* HeapRegion::block_start(const void* addr, HeapWord* const pb) const {\n+  HeapWord* q = _bot_part.block_start_reaching_into_card(addr);\n+  \/\/ The returned address is the block that reaches into the card of addr. Walk\n+  \/\/ the heap to get to the block reaching into addr.\n+  HeapWord* n = q + block_size(q, pb);\n+  return forward_to_block_containing_addr(q, n, addr, pb);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"}]}