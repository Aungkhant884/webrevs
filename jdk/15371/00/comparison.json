{"files":[{"patch":"@@ -50,2 +50,0 @@\n-  public long      longAt(int slot)      { return VM.getVM().buildLongFromIntsPD((int) get(slot).getInteger(),\n-                                                                                 (int) get(slot+1).getInteger()); }\n@@ -62,1 +60,0 @@\n-  public double    doubleAt(int slot)    { return Double.longBitsToDouble(longAt(slot)); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/StackValueCollection.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -410,0 +410,1 @@\n+      System.out.println(\"VM()\");\n@@ -538,0 +539,1 @@\n+      System.out.println(\"VM.initialize()\");\n@@ -555,0 +557,1 @@\n+      System.out.println(\"VM.shutdown()\");\n@@ -730,10 +733,0 @@\n-  \/** Utility routine for building a long from two \"unsigned\" 32-bit\n-      ints in <b>platform-dependent<\/b> order *\/\n-  public long buildLongFromIntsPD(int oneHalf, int otherHalf) {\n-    if (isBigEndian) {\n-      return (((long) otherHalf) << 32) | (((long) oneHalf) & 0x00000000FFFFFFFFL);\n-    } else{\n-      return (((long) oneHalf) << 32) | (((long) otherHalf) & 0x00000000FFFFFFFFL);\n-    }\n-  }\n-\n@@ -956,1 +949,1 @@\n-    if (compressedOopsEnabled == null) {\n+      \/\/if (compressedOopsEnabled == null) {\n@@ -960,1 +953,1 @@\n-    }\n+        \/\/}\n@@ -965,1 +958,1 @@\n-    if (compressedKlassPointersEnabled == null) {\n+      \/\/if (compressedKlassPointersEnabled == null) {\n@@ -969,1 +962,1 @@\n-    }\n+        \/\/}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"}]}