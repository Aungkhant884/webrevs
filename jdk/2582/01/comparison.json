{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,15 +268,0 @@\n-        void printOopValue(Oop oop) {\n-            if (oop != null) {\n-                Klass k = oop.getKlass();\n-                Symbol s = k.getName();\n-                if (s != null) {\n-                    out.print(\"Oop for \" + s.asString() + \" @ \");\n-                } else {\n-                    out.print(\"Oop @ \");\n-                }\n-                Oop.printOopAddressOn(oop, out);\n-            } else {\n-                out.print(\"null\");\n-            }\n-        }\n-\n@@ -288,8 +273,1 @@\n-                    if (field instanceof OopTreeNodeAdapter) {\n-                        out.print(field);\n-                        out.print(\" \");\n-                        printOopValue(((OopTreeNodeAdapter)field).getOop());\n-                        out.println();\n-                    } else {\n-                        out.println(field);\n-                    }\n+                    out.println(field);\n@@ -1030,1 +1008,1 @@\n-                        out.println(\"instance of \" + node.getValue() + \" @ \" + a +\n+                        out.println(\"instance of \" + node.getValue() +\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,92 @@\n+\n+            \/\/ This part is testing JDK-8261269. When inspecting a java object, we want to make\n+            \/\/ sure the address is not printed twice and that \"Oop for ...\" is not printed twice.\n+            \/\/\n+            \/\/ The goal of this test is to dump the Class instance for java.lang.System. It contains\n+            \/\/ some Oop statics, and that's where the redundant \"Oop for...\" was noticed. The script\n+            \/\/ looks something like this:\n+            \/\/\n+            \/\/ hsdb> class java.lang.System\n+            \/\/ java\/lang\/System @0x000000080000f388\n+            \/\/\n+            \/\/ hsdb> inspect 0x000000080000f388\n+            \/\/ Type is InstanceKlass (size of 480)\n+            \/\/ ...\n+            \/\/ OopHandle Klass::_java_mirror: OopHandle @ 0x000000080000f400\n+            \/\/ ...\n+            \/\/\n+            \/\/ hsdb> examine 0x000000080000f400\n+            \/\/ 0x000000080000f400: 0x00007fd8b812e5e8\n+            \/\/\n+            \/\/ hsdb> examine 0x00007fd8b812e5e8\n+            \/\/ 0x00007fd8b812e5e8: 0x00000007fef00770\n+            \/\/\n+            \/\/ hsdb> inspect 0x00000007fef00770\n+            \/\/ instance of Oop for java\/lang\/Class @ 0x00000007fef00770 @ 0x00000007fef00770 (size = 160)\n+            \/\/ in: Oop for java\/io\/BufferedInputStream @ 0x0000000082005b08 Oop for java\/io\/BufferedInputStream @ 0x0000000082005b08\n+            \/\/ out: Oop for java\/io\/PrintStream @ 0x0000000082007b60 Oop for java\/io\/PrintStream @ 0x0000000082007b60\n+            \/\/ err: Oop for java\/io\/PrintStream @ 0x000000008200e0c8 Oop for java\/io\/PrintStream @ 0x000000008200e0c8\n+\n+            String cmd;\n+            Map<String, List<String>> expStrMap;\n+            Map<String, List<String>> unexpStrMap;\n+\n+            \/\/ Start with the \"class java.lang.System\"\n+            cmd = \"class java.lang.System\";\n+            cmds = List.of(cmd);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmd, List.of(\"java.lang.System @0x\"));\n+            String classCmdOutput = test.run(theApp.getPid(), cmds, expStrMap, null);\n+\n+            \/\/ \"inspect\" the address produced by the \"class java.lang.System\". This is the InstanceKlass.\n+            String classAddress = classCmdOutput.substring(classCmdOutput.indexOf(\"@0x\")+1);\n+            lines = classAddress.split(\"\\\\R\");\n+            classAddress = lines[0];\n+            cmd = \"inspect \" + classAddress;\n+            cmds = List.of(cmd);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmd, List.of(\"Type is InstanceKlass\", \"Klass::_java_mirror: OopHandle @\"));\n+            String inspectCmdOutput = test.run(theApp.getPid(), cmds, expStrMap, null);\n+\n+            \/\/ Get the Klass::_java_mirror value from the InstanceKlass\n+            String mirrorPattern = \"Klass::_java_mirror: OopHandle @ \";\n+            String mirrorAddress = inspectCmdOutput.substring(\n+                     inspectCmdOutput.indexOf(mirrorPattern) + mirrorPattern.length());\n+            lines = mirrorAddress.split(\"\\\\R\");\n+            mirrorAddress = lines[0];\n+\n+            \/\/ Use \"examine\" to do an indirection of the _java_mirror.\n+            cmd = \"examine \" + mirrorAddress;\n+            cmds = List.of(cmd);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmd, List.of(mirrorAddress + \": 0x\"));\n+            String examineCmdOutput = test.run(theApp.getPid(), cmds, expStrMap, null);\n+            String examineResult = examineCmdOutput.substring(examineCmdOutput.indexOf(\": 0x\")+2);\n+            lines = examineResult.split(\"\\\\R\");\n+            examineResult = lines[0].trim(); \/\/ examine leaves a trailing space\n+\n+            \/\/ Do another indirection using \"examine\" to get to the address of the Class instance.\n+            cmd = \"examine \" + examineResult;\n+            cmds = List.of(cmd);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmd, List.of(examineResult + \": 0x\"));\n+            examineCmdOutput = test.run(theApp.getPid(), cmds, expStrMap, null);\n+            examineResult = examineCmdOutput.substring(examineCmdOutput.indexOf(\": 0x\")+2);\n+            lines = examineResult.split(\"\\\\R\");\n+            examineResult = lines[0].trim(); \/\/ examine leaves a trailing space\n+\n+            \/\/ inspect the Class instance\n+            String instanceOfString = \"instance of Oop for java\/lang\/Class @ \";\n+            String staticFieldString = \"Oop for java\/io\/BufferedInputStream @\";\n+            cmd = \"inspect \" + examineResult;\n+            cmds = List.of(cmd);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmd, List.of(instanceOfString + examineResult,\n+                                       \"in: \" + staticFieldString));\n+            unexpStrMap = new HashMap<>();\n+            \/\/ Make sure we don't see the address of the class intance twice, and make sure\n+            \/\/ we don't see \"Oop for ...\" twice for the \"in\" static field.\n+            unexpStrMap.put(cmd, List.of(\n+                    instanceOfString  + examineResult + \" @ \" + examineResult,\n+                    \"in: \" + staticFieldString + \" .* \" + staticFieldString));\n+            inspectCmdOutput = test.run(theApp.getPid(), cmds, expStrMap, unexpStrMap);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbInspect.java","additions":93,"deletions":1,"binary":false,"changes":94,"status":"modified"}]}