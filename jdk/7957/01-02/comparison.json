{"files":[{"patch":"@@ -587,1 +587,4 @@\n-    \/* package-private *\/ abstract ZoneOffset getOffset(long epochSecond, int nanoOfSecond);\n+    \/**\n+     * Get the effective offset for an instant at the given epochSecond.\n+     *\/\n+    \/* package-private *\/ abstract ZoneOffset getOffset(long epochSecond);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneId.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -171,0 +173,5 @@\n+    \/**\n+     * The zone rules for an offset will always return this offset. Cache it for efficiency.\n+     *\/\n+    @Stable\n+    private transient ZoneRules rules;\n@@ -507,1 +514,10 @@\n-        return ZoneRules.of(this);\n+        ZoneRules rules = this.rules;\n+        if (rules == null) {\n+            rules = this.rules = ZoneRules.of(this);\n+        }\n+        return rules;\n+    }\n+\n+    @Override\n+    public ZoneId normalized() {\n+        return this;\n@@ -511,1 +527,1 @@\n-    \/* package-private *\/ ZoneOffset getOffset(long epochSecond, int nanoOfSecond) {\n+    \/* package-private *\/ ZoneOffset getOffset(long epochSecond) {\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -182,2 +182,2 @@\n-    \/* package-private *\/ ZoneOffset getOffset(long epochSecond, int nanoOfSecond) {\n-        return getRules().getOffset(Instant.ofEpochSecond(epochSecond, nanoOfSecond));\n+    \/* package-private *\/ ZoneOffset getOffset(long epochSecond) {\n+        return getRules().getOffset(Instant.ofEpochSecond(epochSecond));\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneRegion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -455,1 +455,3 @@\n-        ZoneOffset offset = zone.getOffset(epochSecond, nanoOfSecond);\n+        \/\/ nanoOfSecond is in a range that'll not affect epochSecond, validated\n+        \/\/ by LocalDateTime.ofEpochSecond\n+        ZoneOffset offset = zone.getOffset(epochSecond);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,0 +113,8 @@\n+\n+    @Benchmark\n+    public int[] getYearFromMillisZoneRegionNormalized() {\n+        for (int i = 0; i < YEARS.length; i++) {\n+            YEARS[i] = Instant.ofEpochMilli(INSTANT_MILLIS[i]).atZone(UTC.toZoneId().normalized()).getYear();\n+        }\n+        return YEARS;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/GetYearBench.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}