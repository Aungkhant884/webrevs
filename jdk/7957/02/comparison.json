{"files":[{"patch":"@@ -587,0 +587,5 @@\n+    \/**\n+     * Get the effective offset for an instant at the given epochSecond.\n+     *\/\n+    \/* package-private *\/ abstract ZoneOffset getOffset(long epochSecond);\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneId.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -171,0 +173,5 @@\n+    \/**\n+     * The zone rules for an offset will always return this offset. Cache it for efficiency.\n+     *\/\n+    @Stable\n+    private transient ZoneRules rules;\n@@ -507,1 +514,15 @@\n-        return ZoneRules.of(this);\n+        ZoneRules rules = this.rules;\n+        if (rules == null) {\n+            rules = this.rules = ZoneRules.of(this);\n+        }\n+        return rules;\n+    }\n+\n+    @Override\n+    public ZoneId normalized() {\n+        return this;\n+    }\n+\n+    @Override\n+    \/* package-private *\/ ZoneOffset getOffset(long epochSecond) {\n+        return this;\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -181,0 +181,5 @@\n+    @Override\n+    \/* package-private *\/ ZoneOffset getOffset(long epochSecond) {\n+        return getRules().getOffset(Instant.ofEpochSecond(epochSecond));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneRegion.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -455,3 +455,3 @@\n-        ZoneRules rules = zone.getRules();\n-        Instant instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);  \/\/ TODO: rules should be queryable by epochSeconds\n-        ZoneOffset offset = rules.getOffset(instant);\n+        \/\/ nanoOfSecond is in a range that'll not affect epochSecond, validated\n+        \/\/ by LocalDateTime.ofEpochSecond\n+        ZoneOffset offset = zone.getOffset(epochSecond);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Examine ability to perform escape analysis on expressions\n+ * such as {@code Instant.ofEpochMilli(value).atZone(ZoneOffset.UTC).getYear()}\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class GetYearBench {\n+\n+    private TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n+\n+    private TimeZone LONDON = TimeZone.getTimeZone(\"Europe\/London\");\n+\n+    private long[] INSTANT_MILLIS;\n+\n+    private int[] YEARS;\n+\n+    @Setup\n+    public void createInstants() {\n+        \/\/ Various instants during the same day\n+        final Instant loInstant = Instant.EPOCH.plus(Duration.ofDays(365*50)); \/\/ 2020-01-01\n+        final Instant hiInstant = loInstant.plus(Duration.ofDays(1));\n+        final long maxOffsetNanos = Duration.between(loInstant, hiInstant).toNanos();\n+        final Random random = new Random(0);\n+        INSTANT_MILLIS = IntStream\n+                .range(0, 1_000)\n+                .mapToObj(ignored -> {\n+                    final long offsetNanos = (long) Math.floor(random.nextDouble() * maxOffsetNanos);\n+                    return loInstant.plus(offsetNanos, ChronoUnit.NANOS);\n+                })\n+                .mapToLong(instant -> instant.toEpochMilli())\n+                .toArray();\n+        YEARS = new int[INSTANT_MILLIS.length];\n+    }\n+\n+    @Benchmark\n+    public int[] getYearFromMillisZoneOffset() {\n+        for (int i = 0; i < YEARS.length; i++) {\n+            YEARS[i] = Instant.ofEpochMilli(INSTANT_MILLIS[i]).atZone(ZoneOffset.UTC).getYear();\n+        }\n+        return YEARS;\n+    }\n+\n+    @Benchmark\n+    public int[] getYearFromMillisZoneRegionUTC() {\n+        for (int i = 0; i < YEARS.length; i++) {\n+            YEARS[i] = Instant.ofEpochMilli(INSTANT_MILLIS[i]).atZone(UTC.toZoneId()).getYear();\n+        }\n+        return YEARS;\n+    }\n+\n+    @Benchmark\n+    public int[] getYearFromMillisZoneRegion() {\n+        for (int i = 0; i < YEARS.length; i++) {\n+            YEARS[i] = Instant.ofEpochMilli(INSTANT_MILLIS[i]).atZone(LONDON.toZoneId()).getYear();\n+        }\n+        return YEARS;\n+    }\n+\n+    @Benchmark\n+    public int[] getYearFromMillisZoneRegionNormalized() {\n+        for (int i = 0; i < YEARS.length; i++) {\n+            YEARS[i] = Instant.ofEpochMilli(INSTANT_MILLIS[i]).atZone(UTC.toZoneId().normalized()).getYear();\n+        }\n+        return YEARS;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/GetYearBench.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}