{"files":[{"patch":"@@ -1586,1 +1586,3 @@\n-    f(method);\n+    if (method != nullptr) {\n+      f(method);\n+    }\n@@ -1590,1 +1592,1 @@\n-    MutexLocker ml(InvokeMethodTable_lock);\n+    MutexLocker ml(InvokeMethodIntrinsicTable_lock);\n@@ -1942,0 +1944,7 @@\n+  InvokeMethodKey key(signature, iid_as_int);\n+  Method** met = nullptr;\n+\n+  \/\/ We only want one entry in the table for this (signature\/id, method) pair but the code\n+  \/\/ to create the intrinsic method needs to be outside the lock.\n+  \/\/ The first thread claims the entry by adding the key and the other threads wait, until the\n+  \/\/ Method has been added as the value.\n@@ -1943,5 +1952,11 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    InvokeMethodKey key(signature, iid_as_int);\n-    Method** met = _invoke_method_intrinsic_table.get(key);\n-    if (met != nullptr) {\n-      return *met;\n+    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n+    while (met == nullptr) {\n+      bool created;\n+      met = _invoke_method_intrinsic_table.put_if_absent(key, &created);\n+      if (met != nullptr && *met != nullptr) {\n+        return *met;\n+      } else if (!created) {\n+        \/\/ Second thread waits for first to actually create the entry and returns\n+        \/\/ it after notify.\n+        ml.wait();\n+      }\n@@ -1949,0 +1964,1 @@\n+  }\n@@ -1950,11 +1966,9 @@\n-    bool throw_error = false;\n-    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n-    \/\/ throwing OutOfMemoryError doesn't call Java code.\n-    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-        \/\/ Generate a compiled form of the MH intrinsic\n-        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-        AdapterHandlerLibrary::create_native_wrapper(m);\n-        \/\/ Check if have the compiled code.\n-        throw_error = (!m->has_compiled_code());\n-    }\n+  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, THREAD);\n+  bool throw_error = HAS_PENDING_EXCEPTION;\n+  if (!throw_error && (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative)) {\n+    \/\/ Generate a compiled form of the MH intrinsic\n+    \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+    AdapterHandlerLibrary::create_native_wrapper(m);\n+    \/\/ Check if have the compiled code.\n+    throw_error = (!m->has_compiled_code());\n+  }\n@@ -1962,1 +1976,7 @@\n-    if (!throw_error) {\n+  {\n+    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n+    if (throw_error) {\n+      \/\/ Remove the entry and let another thread try, or get the same exception.\n+      _invoke_method_intrinsic_table.remove(key);\n+      ml.notify_all();\n+    } else {\n@@ -1965,1 +1985,1 @@\n-      assert(created, \"must be since we still hold the lock\");\n+      assert(!created, \"must already be created when holding the lock above\");\n@@ -1969,0 +1989,1 @@\n+      ml.notify_all();\n@@ -1973,3 +1994,8 @@\n-  \/\/ Throw error outside of the lock.\n-  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                 \"Out of space in CodeCache for method handle intrinsic\");\n+  if (throw_error) {\n+    \/\/ Throw VirtualMachineError or else the other error is in the thread.\n+    if (!HAS_PENDING_EXCEPTION) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                     \"Out of space in CodeCache for method handle intrinsic\");\n+    }\n+  }\n+  return nullptr;\n@@ -2118,1 +2144,1 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    MutexLocker ml(THREAD, InvokeMethodTypeTable_lock);\n@@ -2187,1 +2213,1 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    MutexLocker ml(THREAD, InvokeMethodTypeTable_lock);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":51,"deletions":25,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-Mutex*   InvokeMethodTable_lock       = nullptr;\n+Mutex*   InvokeMethodTypeTable_lock   = nullptr;\n+Monitor* InvokeMethodIntrinsicTable_lock = nullptr;\n@@ -257,1 +258,3 @@\n-  MUTEX_DEFN(InvokeMethodTable_lock          , PaddedMutex  , safepoint);\n+  MUTEX_DEFN(InvokeMethodTypeTable_lock      , PaddedMutex  , safepoint);\n+  MUTEX_DEFN(InvokeMethodIntrinsicTable_lock , PaddedMonitor, safepoint);\n+  MUTEX_DEFN(AdapterHandlerLibrary_lock      , PaddedMutex  , safepoint);\n@@ -347,1 +350,0 @@\n-  MUTEX_DEFL(AdapterHandlerLibrary_lock     , PaddedMutex  , InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-extern Mutex*   InvokeMethodTable_lock;\n+extern Mutex*   InvokeMethodTypeTable_lock;\n+extern Monitor* InvokeMethodIntrinsicTable_lock;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}