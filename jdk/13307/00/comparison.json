{"files":[{"patch":"@@ -1942,0 +1942,7 @@\n+  InvokeMethodKey key(signature, iid_as_int);\n+  Method** met = nullptr;\n+\n+  \/\/ We only want one entry in the table for this (signature\/id, method) pair but the code\n+  \/\/ to create the intrinsic method needs to be outside the lock.\n+  \/\/ The first thread claims the entry by adding the key and the other threads wait, until the\n+  \/\/ Method has been added as the value.\n@@ -1943,5 +1950,11 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    InvokeMethodKey key(signature, iid_as_int);\n-    Method** met = _invoke_method_intrinsic_table.get(key);\n-    if (met != nullptr) {\n-      return *met;\n+    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n+    while (met == nullptr) {\n+      bool created;\n+      met = _invoke_method_intrinsic_table.put_if_absent(key, &created);\n+      if (met != nullptr && *met != nullptr) {\n+        return *met;\n+      } else if (!created) {\n+        \/\/ Second thread waits for first to actually create the entry and returns\n+        \/\/ it after notify.\n+        ml.wait();\n+      }\n@@ -1949,0 +1962,1 @@\n+  }\n@@ -1950,11 +1964,9 @@\n-    bool throw_error = false;\n-    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n-    \/\/ throwing OutOfMemoryError doesn't call Java code.\n-    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-        \/\/ Generate a compiled form of the MH intrinsic\n-        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-        AdapterHandlerLibrary::create_native_wrapper(m);\n-        \/\/ Check if have the compiled code.\n-        throw_error = (!m->has_compiled_code());\n-    }\n+  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, THREAD);\n+  bool throw_error = HAS_PENDING_EXCEPTION;\n+  if (!throw_error && (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative)) {\n+    \/\/ Generate a compiled form of the MH intrinsic\n+    \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+    AdapterHandlerLibrary::create_native_wrapper(m);\n+    \/\/ Check if have the compiled code.\n+    throw_error = (!m->has_compiled_code());\n+  }\n@@ -1962,1 +1974,7 @@\n-    if (!throw_error) {\n+  {\n+    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n+    if (throw_error) {\n+      \/\/ Remove the entry and let another thread try, or get the same exception.\n+      _invoke_method_intrinsic_table.remove(key);\n+      ml.notify_all();\n+    } else {\n@@ -1965,1 +1983,1 @@\n-      assert(created, \"must be since we still hold the lock\");\n+      assert(!created, \"must already be created when holding the lock above\");\n@@ -1969,0 +1987,1 @@\n+      ml.notify_all();\n@@ -1973,3 +1992,8 @@\n-  \/\/ Throw error outside of the lock.\n-  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                 \"Out of space in CodeCache for method handle intrinsic\");\n+  if (throw_error) {\n+    \/\/ Throw VirtualMachineError or else the other error is in the thread.\n+    if (!HAS_PENDING_EXCEPTION) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                     \"Out of space in CodeCache for method handle intrinsic\");\n+    }\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+Monitor* InvokeMethodIntrinsicTable_lock = nullptr;\n@@ -258,0 +259,2 @@\n+  MUTEX_DEFN(InvokeMethodIntrinsicTable_lock , PaddedMonitor, safepoint);\n+  MUTEX_DEFN(AdapterHandlerLibrary_lock      , PaddedMutex  , safepoint);\n@@ -347,1 +350,0 @@\n-  MUTEX_DEFL(AdapterHandlerLibrary_lock     , PaddedMutex  , InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+extern Monitor* InvokeMethodIntrinsicTable_lock;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}