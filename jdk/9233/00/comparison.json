{"files":[{"patch":"@@ -1455,1 +1455,0 @@\n-  _humongous_reclaim_candidates(),\n@@ -1687,1 +1686,0 @@\n-    _humongous_reclaim_candidates.initialize(reserved(), granularity);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,20 +231,0 @@\n-  \/\/ Records whether the region at the given index is (still) a\n-  \/\/ candidate for eager reclaim.  Only valid for humongous start\n-  \/\/ regions; other regions have unspecified values.  Humongous start\n-  \/\/ regions are initialized at start of collection pause, with\n-  \/\/ candidates removed from the set as they are found reachable from\n-  \/\/ roots or the young generation.\n-  class HumongousReclaimCandidates : public G1BiasedMappedArray<bool> {\n-  protected:\n-    bool default_value() const override { return false; }\n-  public:\n-    void clear() { G1BiasedMappedArray<bool>::clear(); }\n-    void set_candidate(uint region, bool value) {\n-      set_by_index(region, value);\n-    }\n-    bool is_candidate(uint region) {\n-      return get_by_index(region);\n-    }\n-  };\n-\n-  HumongousReclaimCandidates _humongous_reclaim_candidates;\n@@ -592,3 +572,0 @@\n-  \/\/ Modify the reclaim candidate set and test for presence.\n-  \/\/ These are only valid for starts_humongous regions.\n-  inline void set_humongous_reclaim_candidate(uint region, bool value);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -241,5 +241,0 @@\n-inline void G1CollectedHeap::set_humongous_reclaim_candidate(uint region, bool value) {\n-  assert(_hrm.at(region)->is_starts_humongous(), \"Must start a humongous object\");\n-  _humongous_reclaim_candidates.set_candidate(region, value);\n-}\n-\n@@ -248,1 +243,1 @@\n-  return _humongous_reclaim_candidates.is_candidate(region);\n+  return _region_attr.is_humongous(region);\n@@ -253,12 +248,7 @@\n-  \/\/ Clear the flag in the humongous_reclaim_candidates table.  Also\n-  \/\/ reset the entry in the region attribute table so that subsequent references\n-  \/\/ to the same humongous object do not go into the slow path again.\n-  \/\/ This is racy, as multiple threads may at the same time enter here, but this\n-  \/\/ is benign.\n-  \/\/ During collection we only ever clear the \"candidate\" flag, and only ever clear the\n-  \/\/ entry in the in_cset_fast_table.\n-  \/\/ We only ever evaluate the contents of these tables (in the VM thread) after\n-  \/\/ having synchronized the worker threads with the VM thread, or in the same\n-  \/\/ thread (i.e. within the VM thread).\n-  if (is_humongous_reclaim_candidate(region)) {\n-    set_humongous_reclaim_candidate(region, false);\n+  \/\/ Reset the entry in the region attribute table so that subsequent\n+  \/\/ references to the same humongous object do not go into the slow path\n+  \/\/ again. This is racy, as multiple threads may at the same time enter here,\n+  \/\/ but this is benign because the transition is unidirectional, from\n+  \/\/ humongous-candidate to not, and the write, in evacuation, is\n+  \/\/ separated from the read, in post-evacuation.\n+  if (_region_attr.is_humongous(region)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -145,0 +145,4 @@\n+  bool is_humongous(uintptr_t index) {\n+    return get_ref_by_index(index)->is_humongous();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -385,1 +385,0 @@\n-        _g1h->set_humongous_reclaim_candidate(index, true);\n@@ -390,1 +389,0 @@\n-        _g1h->set_humongous_reclaim_candidate(index, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}