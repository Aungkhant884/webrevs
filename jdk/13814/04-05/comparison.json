{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,1 @@\n+  int64_t _Atomic_add_long(int64_t, volatile int64_t*, int64_t);\n@@ -146,0 +147,8 @@\n+template<>\n+template<typename D, typename I>\n+inline D Atomic::PlatformAdd<8>fetch_and_add(D volatile* dest, I add_value,\n+                                             atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  return add_using_helper<int64_t>(_Atomic_add_long, dest, add_value);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomic_linux_x86.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -509,0 +509,23 @@\n+        # Support for jlong Atomic::add(volatile jlong* dest,\n+        #                               jlong addend)\n+        #\n+        .p2align 4,,15\n+        .type    _Atomic_add_long,@function\n+_Atomic_add_long:\n+                                   #  8(%esp) : return PC\n+        pushl    %ebx              #  4(%esp) : old %ebx\n+        pushl    %edi              #  0(%esp) : old %edi\n+        movl     12(%esp), %ebx    # 12(%esp) : add_value (low)\n+        movl     16(%esp), %ecx    # 16(%esp) : add_value (high)\n+        movl     20(%esp), %edi    # 20(%esp) : dest\n+\tmovl     0(%edi), %eax     # dest (low)\n+        movl     4(%edi), %edx     # dest (high)\n+        addl     %eax, %ebx        # result (low)\n+        adcl     %edx, %ecx        # result (high)\n+1:      lock cmpxchg8b (%edi)\n+        jne      $1\n+        popl     %edi\n+        popl     %ebx\n+        ret\n+\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/linux_x86_32.S","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  jlong        (JNICALL *GetAllThreadAllocatedMemory)\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,2 +310,2 @@\n-  \/\/ bytes and (if different) pointer size bytes are required.  The\n-  \/\/ class must be default constructable, with these requirements:\n+  \/\/ and 8 bytes are required.  The class must be default constructable,\n+  \/\/ with these requirements:\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2100,1 +2100,1 @@\n-JVM_ENTRY(jlong, jmm_GetAllThreadAllocatedMemory(JNIEnv *env))\n+JVM_ENTRY(jlong, jmm_GetTotalThreadAllocatedMemory(JNIEnv *env))\n@@ -2105,1 +2105,4 @@\n-    \/\/ when result is initialized.\n+    \/\/ when result is initialized. The iterator is created and initialized\n+    \/\/ before the call to exited_allocated_bytes to ensure we don't miss\n+    \/\/ accounting for threads that are just about to terminate.\n+    JavaThreadIteratorWithHandle jtiwh;\n@@ -2107,1 +2110,2 @@\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next();) {\n+    JavaThread* thread;\n+    while ((thread = jtiwh.next()) != nullptr) {\n@@ -2255,1 +2259,1 @@\n-  jmm_GetAllThreadAllocatedMemory,\n+  jmm_GetTotalThreadAllocatedMemory,\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-Java_sun_management_ThreadImpl_getAllThreadAllocatedMemory\n+Java_sun_management_ThreadImpl_getTotalThreadAllocatedMemory\n@@ -115,1 +115,1 @@\n-    return jmm_interface->GetAllThreadAllocatedMemory(env);\n+    return jmm_interface->GetTotalThreadAllocatedMemory(env);\n","filename":"src\/java.management\/share\/native\/libmanagement\/ThreadImpl.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -109,3 +109,2 @@\n-     * Returns an approximation of the total amount of memory, in bytes,\n-     * allocated in heap memory since the Java virtual machine was launched,\n-     * including the amount allocated by terminated threads.\n+     * Returns an approximation of the total amount of memory, in bytes, allocated\n+     * in heap memory by all threads since the Java virtual machine started.\n@@ -118,0 +117,5 @@\n+     * @implSpec The default implementation throws UnsupportedOperationException\n+     * if the Java virtual machine implementation does not support thread\n+     * memory allocation measuremust, and otherwise acts as though thread\n+     * memory allocation measurement is disabled.\n+     *\n@@ -133,1 +137,1 @@\n-    public default long getAllThreadAllocatedBytes() {\n+    public default long getTotalThreadAllocatedBytes() {\n@@ -138,2 +142,0 @@\n-        \/\/ Since we do not have an implementation, return -1 whether or not\n-        \/\/ thread allocated memory measurement is enabled.\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    public long getAllThreadAllocatedBytes() {\n-        return super.getAllThreadAllocatedBytes();\n+    public long getTotalThreadAllocatedBytes() {\n+        return super.getTotalThreadAllocatedBytes();\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/HotSpotThreadImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}