{"files":[{"patch":"@@ -448,1 +448,1 @@\n-  \/\/     R0: the new stored in dest\n+  \/\/     R0: the new value stored in dest\n@@ -489,0 +489,26 @@\n+  \/\/ Implementation of atomic_add(jlong add_value, volatile jlong* dest)\n+  \/\/ used by Atomic::add(volatile jlong* dest, jlong add_value)\n+  \/\/\n+  \/\/ Arguments :\n+  \/\/\n+  \/\/      add_value:      R1 (High), R0 (Low)\n+  \/\/      dest:           R2\n+  \/\/\n+  \/\/ Results:\n+  \/\/\n+  \/\/     R0:R1: the new value stored in dest\n+  \/\/\n+  \/\/ Overwrites:\n+  \/\/\n+  \/\/     R1, R2, R3, R4\n+  \/\/\n+  address generate_atomic_add_long() {\n+    address start;\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"atomic_add_long\");\n+    \/\/ TBD\n+    __ bx(LR);\n+\n+    return start;\n+  }\n+\n@@ -3105,0 +3131,1 @@\n+    StubRoutines::_atomic_add_long_entry = generate_atomic_add_long();\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    StubRoutines::_atomic_add_long_entry     = ShouldNotCallThisStub();\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+\n@@ -142,0 +143,1 @@\n+  int64_t _Atomic_add_long(int64_t, volatile int64_t*);\n@@ -146,0 +148,9 @@\n+template<>\n+template<typename D, typename I>\n+inline D Atomic::PlatformAdd<8>::fetch_and_add(D volatile* dest, I add_value,\n+                                               atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  return add_using_helper<int64_t>(_Atomic_add_long, dest, add_value);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomic_bsd_x86.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+        .globl SYMBOL(_Atomic_add_long)\n@@ -528,0 +529,24 @@\n+        # Support for jlong Atomic::add(volatile jlong* dest,\n+        #                               jlong addend)\n+        #\n+        .p2align 4,,15\n+        ELF_TYPE(_Atomic_add_long,@function)\n+_Atomic_add_long:\n+                                   #  8(%esp) : return PC\n+        pushl    %ebx              #  4(%esp) : old %ebx\n+        pushl    %edi              #  0(%esp) : old %edi\n+        movl     12(%esp), %ebx    # 12(%esp) : add_value (low)\n+        movl     16(%esp), %ecx    # 16(%esp) : add_value (high)\n+        movl     20(%esp), %edi    # 20(%esp) : dest\n+\tmovl     0(%edi), %eax     # dest (low)\n+        movl     4(%edi), %edx     # dest (high)\n+        addl     %eax, %ebx        # result (low)\n+        adcl     %edx, %ecx        # result (high)\n+1:      lock\n+        cmpxchg8b (%edi)\n+        jne      1b\n+        popl     %edi\n+        popl     %ebx\n+        ret\n+\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/bsd_x86_32.S","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  typedef int64_t (*atomic_add_long_func_t)(int64_t add_value, volatile int64_t *dest);\n@@ -38,3 +39,3 @@\n-  typedef void (*store_long_func_t)(int64_t, volatile int64_t*);\n-  typedef int32_t  (*atomic_add_func_t)(int32_t add_value, volatile int32_t *dest);\n-  typedef int32_t  (*atomic_xchg_func_t)(int32_t exchange_value, volatile int32_t *dest);\n+  typedef void    (*store_long_func_t)(int64_t, volatile int64_t*);\n+  typedef int32_t (*atomic_add_func_t)(int32_t add_value, volatile int32_t *dest);\n+  typedef int32_t (*atomic_xchg_func_t)(int32_t exchange_value, volatile int32_t *dest);\n@@ -43,6 +44,7 @@\n-  static cmpxchg_long_func_t  _cmpxchg_long_func;\n-  static load_long_func_t     _load_long_func;\n-  static store_long_func_t    _store_long_func;\n-  static atomic_add_func_t    _add_func;\n-  static atomic_xchg_func_t   _xchg_func;\n-  static cmpxchg_func_t       _cmpxchg_func;\n+  static atomic_add_long_func_t _add_func;\n+  static cmpxchg_long_func_t    _cmpxchg_long_func;\n+  static load_long_func_t       _load_long_func;\n+  static store_long_func_t      _store_long_func;\n+  static atomic_add_func_t      _add_func;\n+  static atomic_xchg_func_t     _xchg_func;\n+  static cmpxchg_func_t         _cmpxchg_func;\n@@ -50,0 +52,1 @@\n+  static int64_t add_long_bootstrap(int64_t add_value, volatile int64_t *dest);\n@@ -51,1 +54,0 @@\n-\n@@ -53,10 +55,6 @@\n-\n-  static void store_long_bootstrap(int64_t, volatile int64_t*);\n-\n-  static int32_t  add_bootstrap(int32_t add_value, volatile int32_t *dest);\n-\n-  static int32_t  xchg_bootstrap(int32_t exchange_value, volatile int32_t *dest);\n-\n-  static int32_t  cmpxchg_bootstrap(int32_t compare_value,\n-                                    int32_t exchange_value,\n-                                    volatile int32_t *dest);\n+  static void    store_long_bootstrap(int64_t, volatile int64_t*);\n+  static int32_t add_bootstrap(int32_t add_value, volatile int32_t *dest);\n+  static int32_t xchg_bootstrap(int32_t exchange_value, volatile int32_t *dest);\n+  static int32_t cmpxchg_bootstrap(int32_t compare_value,\n+                                   int32_t exchange_value,\n+                                   volatile int32_t *dest);\n@@ -121,0 +119,9 @@\n+template<>\n+template<typename D, typename I>\n+inline D Atomic::PlatformAdd<8>::add_and_fetch(D volatile* dest, I add_value,\n+                                               atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  return add_using_helper<int64_t>(ARMAtomicFuncs::_add_long_func, dest, add_value);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -506,6 +506,20 @@\n-ARMAtomicFuncs::cmpxchg_long_func_t ARMAtomicFuncs::_cmpxchg_long_func = ARMAtomicFuncs::cmpxchg_long_bootstrap;\n-ARMAtomicFuncs::load_long_func_t    ARMAtomicFuncs::_load_long_func    = ARMAtomicFuncs::load_long_bootstrap;\n-ARMAtomicFuncs::store_long_func_t   ARMAtomicFuncs::_store_long_func   = ARMAtomicFuncs::store_long_bootstrap;\n-ARMAtomicFuncs::atomic_add_func_t   ARMAtomicFuncs::_add_func          = ARMAtomicFuncs::add_bootstrap;\n-ARMAtomicFuncs::atomic_xchg_func_t  ARMAtomicFuncs::_xchg_func         = ARMAtomicFuncs::xchg_bootstrap;\n-ARMAtomicFuncs::cmpxchg_func_t      ARMAtomicFuncs::_cmpxchg_func      = ARMAtomicFuncs::cmpxchg_bootstrap;\n+ARMAtomicFuncs::atomic_add_long_func_t ARMAtomicFuncs::_add_long_func     = ARMAtomicFuncs::add_long_bootstrap;\n+ARMAtomicFuncs::cmpxchg_long_func_t    ARMAtomicFuncs::_cmpxchg_long_func = ARMAtomicFuncs::cmpxchg_long_bootstrap;\n+ARMAtomicFuncs::load_long_func_t       ARMAtomicFuncs::_load_long_func    = ARMAtomicFuncs::load_long_bootstrap;\n+ARMAtomicFuncs::store_long_func_t      ARMAtomicFuncs::_store_long_func   = ARMAtomicFuncs::store_long_bootstrap;\n+ARMAtomicFuncs::atomic_add_func_t      ARMAtomicFuncs::_add_func          = ARMAtomicFuncs::add_bootstrap;\n+ARMAtomicFuncs::atomic_xchg_func_t     ARMAtomicFuncs::_xchg_func         = ARMAtomicFuncs::xchg_bootstrap;\n+ARMAtomicFuncs::cmpxchg_func_t         ARMAtomicFuncs::_cmpxchg_func      = ARMAtomicFuncs::cmpxchg_bootstrap;\n+\n+int64_t ARMAtomicFuncs::add_long_bootstrap(int64_t add_value, volatile int64_t *dest) {\n+  atomic_add_long_func_t func = CAST_TO_FN_PTR(atomic_add_long_func_t,\n+                                               StubRoutines::atomic_add_long_entry());\n+  if (func != nullptr) {\n+    _add_func = func;\n+    return (*func)(add_value, dest);\n+  }\n+\n+  int64_t old_value = *dest;\n+  *dest = old_value + add_value;\n+  return (old_value + add_value);\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+address StubRoutines::_atomic_add_long_entry                    = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  static address _atomic_add_long_entry;\n@@ -324,0 +325,1 @@\n+  static address atomic_add_long_entry()                   { return _atomic_add_long_entry; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n@@ -458,2 +456,0 @@\n-#if INCLUDE_MANAGEMENT\n-\n@@ -2101,7 +2097,23 @@\n-    \/\/ The result may be \"too small\" because the threads iterator takes a\n-    \/\/ snapshot and new threads may be created after result is initialized.\n-    \/\/ There's no check for terminated threads in the loop because their\n-    \/\/ allocated byte counts aren't included in exited_allocated_bytes\n-    \/\/ when result is initialized. The iterator is created and initialized\n-    \/\/ before the call to exited_allocated_bytes to ensure we don't miss\n-    \/\/ accounting for threads that are just about to terminate.\n+    \/\/ A thread increments exited_allocated_bytes after being removed from\n+    \/\/ the threads list (in ThreadService::remove_thread), which means there's\n+    \/\/ a race between threads that exit during the loop and reading\n+    \/\/ exited_allocated_bytes. If result is initialized with exited_allocated_bytes,\n+    \/\/ the final result may be \"too small\" because a thread might be removed\n+    \/\/ from the list before the loop gets to it and thus not be counted. If,\n+    \/\/ on the other hand, exited_allocated_bytes is added after the loop,\n+    \/\/ the final result might be \"too large\" because a thread might be counted\n+    \/\/ twice, once in the loop and agsin in exited_allocated_bytes if it's\n+    \/\/ removed from the list after it's encountered in the loop but before\n+    \/\/ adding exited_allocated_bytes.\n+    \/\/\n+    \/\/ The \"too large\" approach can result in multiple calls to this method\n+    \/\/ returning non-monotonically increasing values. Consider the case where\n+    \/\/ (1) all threads on the list exit after being counted but before adding\n+    \/\/ exited_allocated_bytes, so we double count all of them, (2) on the\n+    \/\/ next call, all threads exit before the addition, so we single count\n+    \/\/ all of them and the total is less than the total (before double\n+    \/\/ counting) for the previous call. The result of the second call will\n+    \/\/ be less than the result of the first.\n+    \/\/\n+    \/\/ The \"too small\" approach doesn't have this problem, so we choose it\n+    \/\/ over the \"too large\" approach to avoid user surprise.\n@@ -2109,3 +2121,2 @@\n-    jlong result;\n-    for (result = ThreadService::exited_allocated_bytes();\n-         JavaThread* thread = jtiwh.next();) {\n+    jlong result = ThreadService::exited_allocated_bytes();\n+    for (; JavaThread* thread = jtiwh.next();) {\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -163,0 +163,3 @@\n+  \/\/ Include hidden thread allcations in exited_allocated_bytes\n+  ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n+\n@@ -173,1 +176,0 @@\n-    ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n@@ -224,1 +226,0 @@\n-  ThreadService::incr_exited_allocated_bytes(jt->cooked_allocated_bytes());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -114,2 +114,1 @@\n-     * recorded. An implementation that walks an active Java thread list will\n-     * necessarily also deliver an approximate result.\n+     * recorded.\n@@ -119,1 +118,1 @@\n-     * memory allocation measuremust, and otherwise acts as though thread\n+     * memory allocation measurement, and otherwise acts as though thread\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}