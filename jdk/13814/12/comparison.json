{"files":[{"patch":"@@ -448,1 +448,1 @@\n-  \/\/     R0: the new stored in dest\n+  \/\/     R0: the new value stored in dest\n@@ -489,0 +489,26 @@\n+  \/\/ Implementation of atomic_add(jlong add_value, volatile jlong* dest)\n+  \/\/ used by Atomic::add(volatile jlong* dest, jlong add_value)\n+  \/\/\n+  \/\/ Arguments :\n+  \/\/\n+  \/\/      add_value:      R1 (High), R0 (Low)\n+  \/\/      dest:           R2\n+  \/\/\n+  \/\/ Results:\n+  \/\/\n+  \/\/     R0:R1: the new value stored in dest\n+  \/\/\n+  \/\/ Overwrites:\n+  \/\/\n+  \/\/     R1, R2, R3, R4\n+  \/\/\n+  address generate_atomic_add_long() {\n+    address start;\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"atomic_add_long\");\n+    \/\/ TBD\n+    __ bx(LR);\n+\n+    return start;\n+  }\n+\n@@ -3105,0 +3131,1 @@\n+    StubRoutines::_atomic_add_long_entry = generate_atomic_add_long();\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    StubRoutines::_atomic_add_long_entry     = ShouldNotCallThisStub();\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+\n@@ -142,0 +143,1 @@\n+  int64_t _Atomic_add_long(int64_t, volatile int64_t*);\n@@ -146,0 +148,9 @@\n+template<>\n+template<typename D, typename I>\n+inline D Atomic::PlatformAdd<8>::fetch_and_add(D volatile* dest, I add_value,\n+                                               atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  return add_using_helper<int64_t>(_Atomic_add_long, dest, add_value);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomic_bsd_x86.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+        .globl SYMBOL(_Atomic_add_long)\n@@ -528,0 +529,24 @@\n+        # Support for jlong Atomic::add(volatile jlong* dest,\n+        #                               jlong addend)\n+        #\n+        .p2align 4,,15\n+        ELF_TYPE(_Atomic_add_long,@function)\n+_Atomic_add_long:\n+                                   #  8(%esp) : return PC\n+        pushl    %ebx              #  4(%esp) : old %ebx\n+        pushl    %edi              #  0(%esp) : old %edi\n+        movl     12(%esp), %ebx    # 12(%esp) : add_value (low)\n+        movl     16(%esp), %ecx    # 16(%esp) : add_value (high)\n+        movl     20(%esp), %edi    # 20(%esp) : dest\n+\tmovl     0(%edi), %eax     # dest (low)\n+        movl     4(%edi), %edx     # dest (high)\n+        addl     %eax, %ebx        # result (low)\n+        adcl     %edx, %ecx        # result (high)\n+1:      lock\n+        cmpxchg8b (%edi)\n+        jne      1b\n+        popl     %edi\n+        popl     %ebx\n+        ret\n+\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/bsd_x86_32.S","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  typedef int64_t (*atomic_add_long_func_t)(int64_t add_value, volatile int64_t *dest);\n@@ -38,3 +39,3 @@\n-  typedef void (*store_long_func_t)(int64_t, volatile int64_t*);\n-  typedef int32_t  (*atomic_add_func_t)(int32_t add_value, volatile int32_t *dest);\n-  typedef int32_t  (*atomic_xchg_func_t)(int32_t exchange_value, volatile int32_t *dest);\n+  typedef void    (*store_long_func_t)(int64_t, volatile int64_t*);\n+  typedef int32_t (*atomic_add_func_t)(int32_t add_value, volatile int32_t *dest);\n+  typedef int32_t (*atomic_xchg_func_t)(int32_t exchange_value, volatile int32_t *dest);\n@@ -43,6 +44,7 @@\n-  static cmpxchg_long_func_t  _cmpxchg_long_func;\n-  static load_long_func_t     _load_long_func;\n-  static store_long_func_t    _store_long_func;\n-  static atomic_add_func_t    _add_func;\n-  static atomic_xchg_func_t   _xchg_func;\n-  static cmpxchg_func_t       _cmpxchg_func;\n+  static atomic_add_long_func_t _add_func;\n+  static cmpxchg_long_func_t    _cmpxchg_long_func;\n+  static load_long_func_t       _load_long_func;\n+  static store_long_func_t      _store_long_func;\n+  static atomic_add_func_t      _add_func;\n+  static atomic_xchg_func_t     _xchg_func;\n+  static cmpxchg_func_t         _cmpxchg_func;\n@@ -50,0 +52,1 @@\n+  static int64_t add_long_bootstrap(int64_t add_value, volatile int64_t *dest);\n@@ -51,1 +54,0 @@\n-\n@@ -53,10 +55,6 @@\n-\n-  static void store_long_bootstrap(int64_t, volatile int64_t*);\n-\n-  static int32_t  add_bootstrap(int32_t add_value, volatile int32_t *dest);\n-\n-  static int32_t  xchg_bootstrap(int32_t exchange_value, volatile int32_t *dest);\n-\n-  static int32_t  cmpxchg_bootstrap(int32_t compare_value,\n-                                    int32_t exchange_value,\n-                                    volatile int32_t *dest);\n+  static void    store_long_bootstrap(int64_t, volatile int64_t*);\n+  static int32_t add_bootstrap(int32_t add_value, volatile int32_t *dest);\n+  static int32_t xchg_bootstrap(int32_t exchange_value, volatile int32_t *dest);\n+  static int32_t cmpxchg_bootstrap(int32_t compare_value,\n+                                   int32_t exchange_value,\n+                                   volatile int32_t *dest);\n@@ -121,0 +119,9 @@\n+template<>\n+template<typename D, typename I>\n+inline D Atomic::PlatformAdd<8>::add_and_fetch(D volatile* dest, I add_value,\n+                                               atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  return add_using_helper<int64_t>(ARMAtomicFuncs::_add_long_func, dest, add_value);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -506,6 +506,20 @@\n-ARMAtomicFuncs::cmpxchg_long_func_t ARMAtomicFuncs::_cmpxchg_long_func = ARMAtomicFuncs::cmpxchg_long_bootstrap;\n-ARMAtomicFuncs::load_long_func_t    ARMAtomicFuncs::_load_long_func    = ARMAtomicFuncs::load_long_bootstrap;\n-ARMAtomicFuncs::store_long_func_t   ARMAtomicFuncs::_store_long_func   = ARMAtomicFuncs::store_long_bootstrap;\n-ARMAtomicFuncs::atomic_add_func_t   ARMAtomicFuncs::_add_func          = ARMAtomicFuncs::add_bootstrap;\n-ARMAtomicFuncs::atomic_xchg_func_t  ARMAtomicFuncs::_xchg_func         = ARMAtomicFuncs::xchg_bootstrap;\n-ARMAtomicFuncs::cmpxchg_func_t      ARMAtomicFuncs::_cmpxchg_func      = ARMAtomicFuncs::cmpxchg_bootstrap;\n+ARMAtomicFuncs::atomic_add_long_func_t ARMAtomicFuncs::_add_long_func     = ARMAtomicFuncs::add_long_bootstrap;\n+ARMAtomicFuncs::cmpxchg_long_func_t    ARMAtomicFuncs::_cmpxchg_long_func = ARMAtomicFuncs::cmpxchg_long_bootstrap;\n+ARMAtomicFuncs::load_long_func_t       ARMAtomicFuncs::_load_long_func    = ARMAtomicFuncs::load_long_bootstrap;\n+ARMAtomicFuncs::store_long_func_t      ARMAtomicFuncs::_store_long_func   = ARMAtomicFuncs::store_long_bootstrap;\n+ARMAtomicFuncs::atomic_add_func_t      ARMAtomicFuncs::_add_func          = ARMAtomicFuncs::add_bootstrap;\n+ARMAtomicFuncs::atomic_xchg_func_t     ARMAtomicFuncs::_xchg_func         = ARMAtomicFuncs::xchg_bootstrap;\n+ARMAtomicFuncs::cmpxchg_func_t         ARMAtomicFuncs::_cmpxchg_func      = ARMAtomicFuncs::cmpxchg_bootstrap;\n+\n+int64_t ARMAtomicFuncs::add_long_bootstrap(int64_t add_value, volatile int64_t *dest) {\n+  atomic_add_long_func_t func = CAST_TO_FN_PTR(atomic_add_long_func_t,\n+                                               StubRoutines::atomic_add_long_entry());\n+  if (func != nullptr) {\n+    _add_func = func;\n+    return (*func)(add_value, dest);\n+  }\n+\n+  int64_t old_value = *dest;\n+  *dest = old_value + add_value;\n+  return (old_value + add_value);\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,2 @@\n-  \/\/ defined in linux_x86.s\n+  \/\/ defined in linux_x86.S\n+  int64_t _Atomic_add_long(int64_t, volatile int64_t*);\n@@ -146,0 +147,9 @@\n+template<>\n+template<typename D, typename I>\n+inline D Atomic::PlatformAdd<8>::fetch_and_add(D volatile* dest, I add_value,\n+                                               atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  return add_using_helper<int64_t>(_Atomic_add_long, dest, add_value);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomic_linux_x86.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+        .globl _Atomic_add_long\n@@ -58,1 +59,1 @@\n-\t.type    _Copy_arrayof_conjoint_bytes,@function\n+        .type    _Copy_arrayof_conjoint_bytes,@function\n@@ -146,1 +147,1 @@\n-\t.type    _Copy_conjoint_jshorts_atomic,@function\n+        .type    _Copy_conjoint_jshorts_atomic,@function\n@@ -233,1 +234,1 @@\n-\t.type    _Copy_arrayof_conjoint_jshorts,@function\n+        .type    _Copy_arrayof_conjoint_jshorts,@function\n@@ -310,2 +311,2 @@\n-\t.type    _Copy_conjoint_jints_atomic,@function\n-\t.type    _Copy_arrayof_conjoint_jints,@function\n+        .type    _Copy_conjoint_jints_atomic,@function\n+        .type    _Copy_arrayof_conjoint_jints,@function\n@@ -387,1 +388,1 @@\n-\t.type    _Copy_conjoint_jlongs_atomic,@function\n+        .type    _Copy_conjoint_jlongs_atomic,@function\n@@ -416,1 +417,1 @@\n-\t.type    _mmx_Copy_arrayof_conjoint_jshorts,@function\n+        .type    _mmx_Copy_arrayof_conjoint_jshorts,@function\n@@ -509,0 +510,23 @@\n+        # Support for jlong Atomic::add(volatile jlong* dest,\n+        #                               jlong addend)\n+        #\n+        .p2align 4,,15\n+        .type    _Atomic_add_long,@function\n+_Atomic_add_long:\n+                                   #  8(%esp) : return PC\n+        pushl    %ebx              #  4(%esp) : old %ebx\n+        pushl    %edi              #  0(%esp) : old %edi\n+        movl     12(%esp), %ebx    # 12(%esp) : add_value (low)\n+        movl     16(%esp), %ecx    # 16(%esp) : add_value (high)\n+        movl     20(%esp), %edi    # 20(%esp) : dest\n+\tmovl     0(%edi), %eax     # dest (low)\n+        movl     4(%edi), %edx     # dest (high)\n+        addl     %eax, %ebx        # result (low)\n+        adcl     %edx, %ecx        # result (high)\n+1:      lock cmpxchg8b (%edi)\n+        jne      1b\n+        popl     %edi\n+        popl     %ebx\n+        ret\n+\n+\n@@ -514,1 +538,1 @@\n-\t.type    _Atomic_cmpxchg_long,@function\n+        .type    _Atomic_cmpxchg_long,@function\n@@ -533,1 +557,1 @@\n-\t.type    _Atomic_move_long,@function\n+        .type    _Atomic_move_long,@function\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/linux_x86_32.S","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-  JMM_VERSION     = JMM_VERSION_3\n+  JMM_VERSION_4   = 0x20040000, \/\/ JDK 21\n+  JMM_VERSION     = JMM_VERSION_4\n@@ -243,0 +244,2 @@\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n+                                                 (JNIEnv *env);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -310,2 +310,2 @@\n-  \/\/ bytes and (if different) pointer size bytes are required.  The\n-  \/\/ class must be default constructable, with these requirements:\n+  \/\/ and 8 bytes are required.  The class must be default constructable,\n+  \/\/ with these requirements:\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+address StubRoutines::_atomic_add_long_entry                    = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  static address _atomic_add_long_entry;\n@@ -324,0 +325,1 @@\n+  static address atomic_add_long_entry()                   { return _atomic_add_long_entry; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n@@ -458,2 +456,0 @@\n-#if INCLUDE_MANAGEMENT\n-\n@@ -2098,1 +2094,34 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n+\n+\/\/ Gets the amount of memory allocated on the Java heap since JVM launch.\n+JVM_ENTRY(jlong, jmm_GetTotalThreadAllocatedMemory(JNIEnv *env))\n+    \/\/ A thread increments exited_allocated_bytes after being removed from\n+    \/\/ the threads list (in ThreadService::remove_thread), which means there's\n+    \/\/ a race between threads that exit during the loop and reading\n+    \/\/ exited_allocated_bytes. If result is initialized with exited_allocated_bytes,\n+    \/\/ the final result may be \"too small\" because a thread might be removed\n+    \/\/ from the list before the loop gets to it and thus not be counted. If,\n+    \/\/ on the other hand, exited_allocated_bytes is added after the loop,\n+    \/\/ the final result might be \"too large\" because a thread might be counted\n+    \/\/ twice, once in the loop and agsin in exited_allocated_bytes if it's\n+    \/\/ removed from the list after it's encountered in the loop but before\n+    \/\/ adding exited_allocated_bytes.\n+    \/\/\n+    \/\/ The \"too large\" approach can result in multiple calls to this method\n+    \/\/ returning non-monotonically increasing values. Consider the case where\n+    \/\/ (1) all threads on the list exit after being counted but before adding\n+    \/\/ exited_allocated_bytes, so we double count all of them, (2) on the\n+    \/\/ next call, all threads exit before the addition, so we single count\n+    \/\/ all of them and the total is less than the total (before double\n+    \/\/ counting) for the previous call. The result of the second call will\n+    \/\/ be less than the result of the first.\n+    \/\/\n+    \/\/ The \"too small\" approach doesn't have this problem, so we choose it\n+    \/\/ over the \"too large\" approach to avoid user surprise.\n+    JavaThreadIteratorWithHandle jtiwh;\n+    jlong result = ThreadService::exited_allocated_bytes();\n+    for (; JavaThread* thread = jtiwh.next();) {\n+      jlong size = thread->cooked_allocated_bytes();\n+      result += size;\n+    }\n+    return result;\n+JVM_END\n@@ -2231,3 +2260,0 @@\n-\n-\n-#if INCLUDE_MANAGEMENT\n@@ -2244,0 +2270,1 @@\n+  jmm_GetTotalThreadAllocatedMemory,\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -73,0 +74,2 @@\n+volatile jlong ThreadService::_exited_allocated_bytes = 0;\n+\n@@ -160,0 +163,3 @@\n+  \/\/ Include hidden thread allcations in exited_allocated_bytes\n+  ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n+\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+  \/\/ As could this...\n+  \/\/ Number of heap bytes allocated by termianted threads.\n+  static volatile jlong _exited_allocated_bytes;\n+\n@@ -105,0 +109,5 @@\n+  static jlong exited_allocated_bytes()       { return _exited_allocated_bytes; }\n+  static void incr_exited_allocated_bytes(jlong size) {\n+    Atomic::add(&_exited_allocated_bytes, size, memory_order_relaxed);\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -345,0 +345,7 @@\n+    protected long getTotalThreadAllocatedBytes() {\n+        if (isThreadAllocatedMemoryEnabled()) {\n+            return getTotalThreadAllocatedMemory();\n+        }\n+        return -1;\n+    }\n+\n@@ -528,0 +535,1 @@\n+    private static native long getTotalThreadAllocatedMemory();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n+    return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n@@ -111,0 +111,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_ThreadImpl_getTotalThreadAllocatedMemory\n+  (JNIEnv *env, jclass cls)\n+{\n+    return jmm_interface->GetTotalThreadAllocatedMemory(env);\n+}\n+\n","filename":"src\/java.management\/share\/native\/libmanagement\/ThreadImpl.c","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -108,0 +108,36 @@\n+    \/**\n+     * Returns an approximation of the total amount of memory, in bytes, allocated\n+     * in heap memory by all threads since the Java virtual machine started.\n+     * The returned value is an approximation because some Java virtual machine\n+     * implementations may use object allocation mechanisms that result in a\n+     * delay between the time an object is allocated and the time its size is\n+     * recorded.\n+     *\n+     * @implSpec The default implementation throws UnsupportedOperationException\n+     * if the Java virtual machine implementation does not support thread\n+     * memory allocation measurement, and otherwise acts as though thread\n+     * memory allocation measurement is disabled.\n+     *\n+     * @return an approximation of the total memory allocated, in bytes, in\n+     * heap memory since the Java virtual machine was launched,\n+     * if thread memory allocation measurement is enabled;\n+     * {@code -1} otherwise.\n+     *\n+     * @throws UnsupportedOperationException if the Java virtual\n+     *         machine implementation does not support thread memory allocation\n+     *         measurement.\n+     *\n+     * @see #isThreadAllocatedMemorySupported\n+     * @see #isThreadAllocatedMemoryEnabled\n+     * @see #setThreadAllocatedMemoryEnabled\n+     *\n+     * @since 21\n+     *\/\n+    public default long getTotalThreadAllocatedBytes() {\n+        if (!isThreadAllocatedMemorySupported()) {\n+            throw new UnsupportedOperationException(\n+                \"Thread allocated memory measurement is not supported.\");\n+        }\n+        return -1;\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+    @Override\n+    public long getTotalThreadAllocatedBytes() {\n+        return super.getTotalThreadAllocatedBytes();\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/HotSpotThreadImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug     6173675 8231209\n+ * @bug     6173675 8231209 8304074\n@@ -58,0 +58,3 @@\n+        \/\/ Test cumulative Java thread allocation since JVM launch\n+        testGetTotalThreadAllocatedBytes();\n+\n@@ -95,0 +98,2 @@\n+        Thread curThread = Thread.currentThread();\n+\n@@ -96,1 +101,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -101,1 +106,1 @@\n-        checkResult(Thread.currentThread(), size,\n+        checkResult(curThread, size,\n@@ -110,1 +115,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -131,1 +136,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -155,1 +160,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n+            System.out.println(\"Unexpected exception thrown.\");\n@@ -175,1 +180,1 @@\n-            ensureValidSize(sizes[i]);\n+            ensureValidSize(threads[i], sizes[i]);\n@@ -204,1 +209,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n+                System.out.println(\"Unexpected exception thrown.\");\n@@ -211,1 +216,61 @@\n-    private static void ensureValidSize(long size) {\n+    private static void testGetTotalThreadAllocatedBytes()\n+        throws Exception {\n+\n+        \/\/ baseline should be positive\n+        Thread curThread = Thread.currentThread();\n+        long cumulativeSize = mbean.getTotalThreadAllocatedBytes();\n+        if (cumulativeSize <= 0) {\n+            throw new RuntimeException(\n+                \"Invalid allocated bytes returned for \" + curThread.getName() + \" = \" + cumulativeSize);\n+        }\n+\n+        \/\/ start threads\n+        done = false; done1 = false;\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            threads[i] = new MyThread(\"MyThread-\" + i);\n+            threads[i].start();\n+        }\n+\n+        \/\/ wait for threads to block after doing some allocation\n+        waitUntilThreadsBlocked();\n+\n+        \/\/ check after threads are blocked\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads go to do some more allocation\n+        synchronized (obj) {\n+            done = true;\n+            obj.notifyAll();\n+        }\n+\n+        \/\/ wait for threads to get going again. we don't care if we\n+        \/\/ catch them in mid-execution or if some of them haven't\n+        \/\/ restarted after we're done sleeping.\n+        goSleep(400);\n+\n+        System.out.println(\"Done sleeping\");\n+\n+        \/\/ check while threads are running\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads exit\n+        synchronized (obj) {\n+            done1 = true;\n+            obj.notifyAll();\n+        }\n+\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            try {\n+                threads[i].join();\n+            } catch (InterruptedException e) {\n+                System.out.println(\"Unexpected exception thrown.\");\n+                e.printStackTrace(System.out);\n+                break;\n+            }\n+        }\n+\n+        \/\/ check after threads exit\n+        checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+    }\n+\n+    private static void ensureValidSize(Thread curThread, long size) {\n@@ -216,1 +281,2 @@\n-                \"Invalid allocated bytes returned = \" + size);\n+                \"Invalid allocated bytes returned for thread \" +\n+                curThread.getName() + \" = \" + size);\n@@ -220,6 +286,2 @@\n-    private static void checkResult(Thread curThread,\n-                                    long prev_size, long curr_size) {\n-        if (curr_size < prev_size) {\n-            throw new RuntimeException(\"Allocated bytes \" + curr_size +\n-                                       \" expected >= \" + prev_size);\n-        }\n+    private static long checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n@@ -227,2 +289,9 @@\n-                           \" Previous allocated bytes = \" + prev_size +\n-                           \" Current allocated bytes = \" + curr_size);\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+        }\n+        return currSize;\n@@ -235,1 +304,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n+            System.out.println(\"Unexpected exception thrown.\");\n@@ -290,1 +359,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown while !done.\");\n@@ -297,1 +366,1 @@\n-            long size1 = mbean.getThreadAllocatedBytes(getId());\n+            long prevSize = mbean.getThreadAllocatedBytes(getId());\n@@ -299,11 +368,2 @@\n-            long size2 = mbean.getThreadAllocatedBytes(getId());\n-\n-            System.out.println(getName() + \": \" +\n-                \"ThreadAllocatedBytes  = \" + size1 +\n-                \" ThreadAllocatedBytes  = \" + size2);\n-\n-            if (size1 > size2) {\n-                throw new RuntimeException(getName() +\n-                    \" ThreadAllocatedBytes = \" + size1 +\n-                    \" > ThreadAllocatedBytes = \" + size2);\n-            }\n+            long currSize = mbean.getThreadAllocatedBytes(getId());\n+            checkResult(this, prevSize, currSize);\n@@ -316,1 +376,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown while !done1.\");\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemory.java","additions":94,"deletions":34,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-\n@@ -62,1 +61,0 @@\n-\n@@ -120,2 +118,1 @@\n-        long[] sizes1 = mbean.getThreadAllocatedBytes(ids);\n-\n+        long[] afterSizes = mbean.getThreadAllocatedBytes(ids);\n@@ -123,10 +120,1 @@\n-            long newSize = sizes1[i];\n-            if (sizes[i] > newSize) {\n-                throw new RuntimeException(\"TEST FAILED: \" +\n-                    threads[i].getName() +\n-                    \" previous allocated bytes = \" + sizes[i] +\n-                    \" > current allocated bytes = \" + newSize);\n-            }\n-            System.out.println(threads[i].getName() +\n-                \" Previous allocated bytes = \" + sizes[i] +\n-                \" Current allocated bytes = \" + newSize);\n+            checkResult(threads[i], sizes[i], afterSizes[i]);\n@@ -150,1 +138,0 @@\n-\n@@ -161,1 +148,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n+                System.out.println(\"Unexpected exception thrown.\");\n@@ -176,0 +163,14 @@\n+    private static void checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n+        System.out.println(curThread.getName() +\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+\n+        }\n+    }\n+\n@@ -180,1 +181,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n+            System.out.println(\"Unexpected exception thrown.\");\n@@ -224,1 +225,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown.\");\n@@ -239,1 +240,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown.\");\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemoryArray.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"}]}