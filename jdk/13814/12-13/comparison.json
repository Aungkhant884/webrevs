{"files":[{"patch":"@@ -509,1 +509,1 @@\n-    \/\/ TBD\n+    Unimplemented();\n@@ -3106,0 +3106,8 @@\n+  static void should_not_call() {\n+    report_should_not_call(__FILE__, __LINE__);\n+  }\n+\n+  static address ShouldNotCallThisStub() {\n+    return (address) should_not_call;\n+  }\n+\n@@ -3131,1 +3139,1 @@\n-    StubRoutines::_atomic_add_long_entry = generate_atomic_add_long();\n+    StubRoutines::_atomic_add_long_entry = ShouldNotCallThisStub();\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  static atomic_add_long_func_t _add_func;\n+  static atomic_add_long_func_t _add_long_func;\n@@ -125,0 +125,3 @@\n+\n+#if 0\n+  \/\/ TBD assembly stub\n@@ -126,0 +129,5 @@\n+#else\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2097,23 +2097,8 @@\n-    \/\/ A thread increments exited_allocated_bytes after being removed from\n-    \/\/ the threads list (in ThreadService::remove_thread), which means there's\n-    \/\/ a race between threads that exit during the loop and reading\n-    \/\/ exited_allocated_bytes. If result is initialized with exited_allocated_bytes,\n-    \/\/ the final result may be \"too small\" because a thread might be removed\n-    \/\/ from the list before the loop gets to it and thus not be counted. If,\n-    \/\/ on the other hand, exited_allocated_bytes is added after the loop,\n-    \/\/ the final result might be \"too large\" because a thread might be counted\n-    \/\/ twice, once in the loop and agsin in exited_allocated_bytes if it's\n-    \/\/ removed from the list after it's encountered in the loop but before\n-    \/\/ adding exited_allocated_bytes.\n-    \/\/\n-    \/\/ The \"too large\" approach can result in multiple calls to this method\n-    \/\/ returning non-monotonically increasing values. Consider the case where\n-    \/\/ (1) all threads on the list exit after being counted but before adding\n-    \/\/ exited_allocated_bytes, so we double count all of them, (2) on the\n-    \/\/ next call, all threads exit before the addition, so we single count\n-    \/\/ all of them and the total is less than the total (before double\n-    \/\/ counting) for the previous call. The result of the second call will\n-    \/\/ be less than the result of the first.\n-    \/\/\n-    \/\/ The \"too small\" approach doesn't have this problem, so we choose it\n-    \/\/ over the \"too large\" approach to avoid user surprise.\n+    \/\/ A thread increments exited_allocated_bytes in ThreadService::remove_thread\n+    \/\/ only after it removes itself from the threads list, and once a TLH is\n+    \/\/ created, no thread it references can remove itself from the threads\n+    \/\/ list, so none can update exited_allocated_bytes. We therefore initialize\n+    \/\/ result with exited_allocated_bytes after after we create the TLH so that\n+    \/\/ the final result can only be short due to (1) threads that start after\n+    \/\/ the TLH is created, or (2) terminating threads that escape TLH creation\n+    \/\/ and don't update exited_allocated_bytes before we initialize result.\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"}]}