{"files":[{"patch":"@@ -83,0 +83,1 @@\n+<li><a href=\"#fontconfig\" id=\"toc-fontconfig\">Fontconfig<\/a><\/li>\n@@ -326,0 +327,1 @@\n+<p>Note: The Windows 32-bit x86 port is deprecated and may be removed in a future release.<\/p>\n@@ -402,0 +404,1 @@\n+<p>Note: The Windows 32-bit x86 port is deprecated and may be removed in a future release.<\/p>\n@@ -680,0 +683,11 @@\n+<h3 id=\"fontconfig\">Fontconfig<\/h3>\n+<p>Fontconfig from <a href=\"http:\/\/fontconfig.org\">freedesktop.org\n+Fontconfig<\/a> is required on all platforms except Windows and\n+macOS.<\/p>\n+<ul>\n+<li>To install on an rpm-based Linux, try running\n+<code>sudo yum install     fontconfig-devel<\/code>.<\/li>\n+<\/ul>\n+<p>Use <code>--with-fontconfig-include=&lt;path&gt;<\/code> and\n+<code>--with-fontconfig=&lt;path&gt;<\/code> if <code>configure<\/code>\n+does not automatically locate the platform Fontconfig files.<\/p>\n","filename":"doc\/building.html","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+Note: The Windows 32-bit x86 port is deprecated and may be removed in a future release.\n+\n@@ -202,0 +204,2 @@\n+Note: The Windows 32-bit x86 port is deprecated and may be removed in a future release.\n+\n@@ -474,0 +478,11 @@\n+### Fontconfig\n+\n+Fontconfig from [freedesktop.org Fontconfig](http:\/\/fontconfig.org) is required\n+on all platforms except Windows and macOS.\n+\n+  * To install on an rpm-based Linux, try running `sudo yum install\n+    fontconfig-devel`.\n+\n+Use `--with-fontconfig-include=<path>` and `--with-fontconfig=<path>`\n+if `configure` does not automatically locate the platform Fontconfig files.\n+\n","filename":"doc\/building.md","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -598,9 +598,1 @@\n-  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\n+  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native\n","filename":"make\/RunTests.gmk","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -660,0 +660,16 @@\n+  PLATFORM_CHECK_DEPRECATION\n+])\n+\n+AC_DEFUN_ONCE([PLATFORM_CHECK_DEPRECATION],\n+[\n+  AC_ARG_ENABLE(deprecated-ports, [AS_HELP_STRING([--enable-deprecated-ports@<:@=yes\/no@:>@],\n+       [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n+  AC_REQUIRE([PLATFORM_EXTRACT_TARGET_AND_BUILD])\n+  if test \"x$OPENJDK_TARGET_OS\" = xwindows && test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n+    if test \"x$enable_deprecated_ports\" = \"xyes\"; then\n+      AC_MSG_WARN([The Windows 32-bit x86 port is deprecated and may be removed in a future release.])\n+    else\n+      AC_MSG_ERROR(m4_normalize([The Windows 32-bit x86 port is deprecated and may be removed in a future release.\n+        Use --enable-deprecated-ports=yes to suppress this error.]))\n+    fi\n+  fi\n","filename":"make\/autoconf\/platform.m4","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type expansion-to-defined\n+   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type expansion-to-defined dangling-reference\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-ifeq ($(call isTargetOs, windows), true)\n+ifeq ($(call isTargetOs, linux macosx windows), true)\n@@ -34,0 +34,1 @@\n+      TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n@@ -35,1 +36,1 @@\n-      CFLAGS := $(CFLAGS_JDKLIB), \\\n+      CFLAGS := $(CXXFLAGS_JDKLIB), \\\n@@ -37,1 +38,2 @@\n-      LIBS := $(JDKLIB_LIBS) user32.lib, \\\n+      LIBS_unix := $(JDKLIB_LIBS) $(LIBCXX), \\\n+      LIBS_windows := $(JDKLIB_LIBS) user32.lib, \\\n","filename":"make\/modules\/jdk.internal.le\/Lib.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3887,1 +3887,1 @@\n-    __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));\n+    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n@@ -3905,1 +3905,1 @@\n-    __ increment(Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value), 1);\n+    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n@@ -3971,1 +3971,1 @@\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n@@ -3981,1 +3981,1 @@\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n@@ -3988,1 +3988,1 @@\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n@@ -3993,2 +3993,2 @@\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset_in_bytes()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset_in_bytes()));\n+    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n+    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n@@ -3999,1 +3999,1 @@\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -143,1 +143,1 @@\n-  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  __ str(rthread, Address(mon, ObjectMonitor::owner_offset_in_bytes()));\n+  __ str(rthread, Address(mon, ObjectMonitor::owner_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,2 +279,2 @@\n-  ldr(result, Address(result, ConstantPool::cache_offset_in_bytes()));\n-  ldr(result, Address(result, ConstantPoolCache::resolved_references_offset_in_bytes()));\n+  ldr(result, Address(result, ConstantPool::cache_offset()));\n+  ldr(result, Address(result, ConstantPoolCache::resolved_references_offset()));\n@@ -291,1 +291,1 @@\n-  ldr(klass, Address(cpool,  ConstantPool::resolved_klasses_offset_in_bytes())); \/\/ klass = cpool->_resolved_klasses\n+  ldr(klass, Address(cpool,  ConstantPool::resolved_klasses_offset())); \/\/ klass = cpool->_resolved_klasses\n@@ -518,1 +518,1 @@\n-  dispatch_base(state, Interpreter::dispatch_table(state), generate_poll);\n+  dispatch_base(state, Interpreter::dispatch_table(state), \/*verifyoop*\/true, generate_poll);\n@@ -592,1 +592,1 @@\n-  ldr(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+  ldr(r0, Address(c_rarg1, BasicObjectLock::obj_offset()));\n@@ -669,1 +669,1 @@\n-    ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+    ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset()));\n@@ -744,2 +744,2 @@\n-    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n-    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n+    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n@@ -867,1 +867,1 @@\n-      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n+      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n@@ -871,1 +871,1 @@\n-    ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+    ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -874,1 +874,1 @@\n-    str(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+    str(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -909,1 +909,1 @@\n-    str(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes())); \/\/ restore obj\n+    str(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n@@ -1808,1 +1808,1 @@\n-      ldrh(rscratch1, Address(tmp, Method::intrinsic_id_offset_in_bytes()));\n+      ldrh(rscratch1, Address(tmp, Method::intrinsic_id_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-    ldr(reg, Address(reg, ConstantPool::cache_offset_in_bytes()));\n+    ldr(reg, Address(reg, ConstantPool::cache_offset()));\n@@ -137,1 +137,1 @@\n-    ldr(tags, Address(cpool, ConstantPool::tags_offset_in_bytes()));\n+    ldr(tags, Address(cpool, ConstantPool::tags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1146,1 +1146,1 @@\n-  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n@@ -1174,1 +1174,1 @@\n-  ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+  ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset()));\n@@ -1182,1 +1182,1 @@\n-  if (itableOffsetEntry::interface_offset_in_bytes() != 0) {\n+  if (itableOffsetEntry::interface_offset() != 0) {\n@@ -1184,1 +1184,1 @@\n-    ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+    ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset()));\n@@ -1195,1 +1195,1 @@\n-    ldrw(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));\n+    ldrw(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset()));\n@@ -1204,1 +1204,0 @@\n-  const int base = in_bytes(Klass::vtable_start_offset());\n@@ -1207,1 +1206,1 @@\n-  int vtable_offset_in_bytes = base + vtableEntry::method_offset_in_bytes();\n+  int64_t vtable_offset_in_bytes = in_bytes(Klass::vtable_start_offset() + vtableEntry::method_offset());\n@@ -4314,1 +4313,1 @@\n-  ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); \/\/ InstanceKlass*\n+  ldr(holder, Address(holder, ConstantPool::pool_holder_offset()));          \/\/ InstanceKlass*\n@@ -4351,1 +4350,1 @@\n-  ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));\n+  ldr(dst, Address(dst, ConstantPool::pool_holder_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    __ ldrh(rscratch1, Address(rmethod, Method::intrinsic_id_offset_in_bytes()));\n+    __ ldrh(rscratch1, Address(rmethod, Method::intrinsic_id_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1992,1 +1992,1 @@\n-  __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));\n+  __ str(zr, Address(r2, JNIHandleBlock::top_offset()));\n@@ -2392,1 +2392,1 @@\n-  __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+  __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -2438,1 +2438,1 @@\n-  __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n+  __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n@@ -2449,1 +2449,1 @@\n-  __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -2453,1 +2453,1 @@\n-  __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+  __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2459,1 +2459,1 @@\n-  __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -2462,1 +2462,1 @@\n-  __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+  __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -2474,1 +2474,1 @@\n-                       caller_adjustment_offset_in_bytes()));\n+                       caller_adjustment_offset()));\n@@ -2634,1 +2634,1 @@\n-    __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+    __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -2655,1 +2655,1 @@\n-                      size_of_deoptimized_frame_offset_in_bytes()));\n+                      size_of_deoptimized_frame_offset()));\n@@ -2668,1 +2668,1 @@\n-                      total_frame_sizes_offset_in_bytes()));\n+                      total_frame_sizes_offset()));\n@@ -2674,1 +2674,1 @@\n-                     Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2679,1 +2679,1 @@\n-                     frame_sizes_offset_in_bytes()));\n+                     frame_sizes_offset()));\n@@ -2684,1 +2684,1 @@\n-                      number_of_frames_offset_in_bytes())); \/\/ (int)\n+                      number_of_frames_offset())); \/\/ (int)\n@@ -2696,1 +2696,1 @@\n-                      caller_adjustment_offset_in_bytes())); \/\/ (int)\n+                      caller_adjustment_offset())); \/\/ (int)\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -3335,0 +3335,27 @@\n+  class Cached64Bytes {\n+  private:\n+    MacroAssembler *_masm;\n+    Register _regs[8];\n+\n+  public:\n+    Cached64Bytes(MacroAssembler *masm, RegSet rs): _masm(masm) {\n+      assert(rs.size() == 8, \"%u registers are used to cache 16 4-byte data\", rs.size());\n+      auto it = rs.begin();\n+      for (auto &r: _regs) {\n+        r = *it;\n+        ++it;\n+      }\n+    }\n+\n+    void gen_loads(Register base) {\n+      for (int i = 0; i < 8; i += 2) {\n+        __ ldp(_regs[i], _regs[i + 1], Address(base, 8 * i));\n+      }\n+    }\n+\n+    \/\/ Generate code extracting i-th unsigned word (4 bytes) from cached 64 bytes.\n+    void extract_u32(Register dest, int i) {\n+      __ ubfx(dest, _regs[i \/ 2], 32 * (i % 2), 32);\n+    }\n+  };\n+\n@@ -3337,1 +3364,1 @@\n-  void md5_FF(Register buf, Register r1, Register r2, Register r3, Register r4,\n+  void md5_FF(Cached64Bytes& reg_cache, Register r1, Register r2, Register r3, Register r4,\n@@ -3346,1 +3373,1 @@\n-    __ ldrw(rscratch1, Address(buf, k*4));\n+    reg_cache.extract_u32(rscratch1, k);\n@@ -3354,1 +3381,1 @@\n-  void md5_GG(Register buf, Register r1, Register r2, Register r3, Register r4,\n+  void md5_GG(Cached64Bytes& reg_cache, Register r1, Register r2, Register r3, Register r4,\n@@ -3361,1 +3388,1 @@\n-    __ ldrw(rscratch1, Address(buf, k*4));\n+    reg_cache.extract_u32(rscratch1, k);\n@@ -3371,1 +3398,1 @@\n-  void md5_HH(Register buf, Register r1, Register r2, Register r3, Register r4,\n+  void md5_HH(Cached64Bytes& reg_cache, Register r1, Register r2, Register r3, Register r4,\n@@ -3379,1 +3406,1 @@\n-    __ ldrw(rscratch1, Address(buf, k*4));\n+    reg_cache.extract_u32(rscratch1, k);\n@@ -3387,1 +3414,1 @@\n-  void md5_II(Register buf, Register r1, Register r2, Register r3, Register r4,\n+  void md5_II(Cached64Bytes& reg_cache, Register r1, Register r2, Register r3, Register r4,\n@@ -3395,1 +3422,1 @@\n-    __ ldrw(rscratch1, Address(buf, k*4));\n+    reg_cache.extract_u32(rscratch1, k);\n@@ -3427,0 +3454,12 @@\n+    Register state_regs[2] = { r12, r13 };\n+    RegSet saved_regs = RegSet::range(r16, r22) - r18_tls;\n+    Cached64Bytes reg_cache(_masm, RegSet::of(r14, r15) + saved_regs);  \/\/ using 8 registers\n+\n+    __ push(saved_regs, sp);\n+\n+    __ ldp(state_regs[0], state_regs[1], Address(state));\n+    __ ubfx(a, state_regs[0],  0, 32);\n+    __ ubfx(b, state_regs[0], 32, 32);\n+    __ ubfx(c, state_regs[1],  0, 32);\n+    __ ubfx(d, state_regs[1], 32, 32);\n+\n@@ -3430,5 +3469,1 @@\n-    \/\/ Save hash values for addition after rounds\n-    __ ldrw(a, Address(state,  0));\n-    __ ldrw(b, Address(state,  4));\n-    __ ldrw(c, Address(state,  8));\n-    __ ldrw(d, Address(state, 12));\n+    reg_cache.gen_loads(buf);\n@@ -3437,16 +3472,16 @@\n-    md5_FF(buf, a, b, c, d,  0,  7, 0xd76aa478);\n-    md5_FF(buf, d, a, b, c,  1, 12, 0xe8c7b756);\n-    md5_FF(buf, c, d, a, b,  2, 17, 0x242070db);\n-    md5_FF(buf, b, c, d, a,  3, 22, 0xc1bdceee);\n-    md5_FF(buf, a, b, c, d,  4,  7, 0xf57c0faf);\n-    md5_FF(buf, d, a, b, c,  5, 12, 0x4787c62a);\n-    md5_FF(buf, c, d, a, b,  6, 17, 0xa8304613);\n-    md5_FF(buf, b, c, d, a,  7, 22, 0xfd469501);\n-    md5_FF(buf, a, b, c, d,  8,  7, 0x698098d8);\n-    md5_FF(buf, d, a, b, c,  9, 12, 0x8b44f7af);\n-    md5_FF(buf, c, d, a, b, 10, 17, 0xffff5bb1);\n-    md5_FF(buf, b, c, d, a, 11, 22, 0x895cd7be);\n-    md5_FF(buf, a, b, c, d, 12,  7, 0x6b901122);\n-    md5_FF(buf, d, a, b, c, 13, 12, 0xfd987193);\n-    md5_FF(buf, c, d, a, b, 14, 17, 0xa679438e);\n-    md5_FF(buf, b, c, d, a, 15, 22, 0x49b40821);\n+    md5_FF(reg_cache, a, b, c, d,  0,  7, 0xd76aa478);\n+    md5_FF(reg_cache, d, a, b, c,  1, 12, 0xe8c7b756);\n+    md5_FF(reg_cache, c, d, a, b,  2, 17, 0x242070db);\n+    md5_FF(reg_cache, b, c, d, a,  3, 22, 0xc1bdceee);\n+    md5_FF(reg_cache, a, b, c, d,  4,  7, 0xf57c0faf);\n+    md5_FF(reg_cache, d, a, b, c,  5, 12, 0x4787c62a);\n+    md5_FF(reg_cache, c, d, a, b,  6, 17, 0xa8304613);\n+    md5_FF(reg_cache, b, c, d, a,  7, 22, 0xfd469501);\n+    md5_FF(reg_cache, a, b, c, d,  8,  7, 0x698098d8);\n+    md5_FF(reg_cache, d, a, b, c,  9, 12, 0x8b44f7af);\n+    md5_FF(reg_cache, c, d, a, b, 10, 17, 0xffff5bb1);\n+    md5_FF(reg_cache, b, c, d, a, 11, 22, 0x895cd7be);\n+    md5_FF(reg_cache, a, b, c, d, 12,  7, 0x6b901122);\n+    md5_FF(reg_cache, d, a, b, c, 13, 12, 0xfd987193);\n+    md5_FF(reg_cache, c, d, a, b, 14, 17, 0xa679438e);\n+    md5_FF(reg_cache, b, c, d, a, 15, 22, 0x49b40821);\n@@ -3455,16 +3490,16 @@\n-    md5_GG(buf, a, b, c, d,  1,  5, 0xf61e2562);\n-    md5_GG(buf, d, a, b, c,  6,  9, 0xc040b340);\n-    md5_GG(buf, c, d, a, b, 11, 14, 0x265e5a51);\n-    md5_GG(buf, b, c, d, a,  0, 20, 0xe9b6c7aa);\n-    md5_GG(buf, a, b, c, d,  5,  5, 0xd62f105d);\n-    md5_GG(buf, d, a, b, c, 10,  9, 0x02441453);\n-    md5_GG(buf, c, d, a, b, 15, 14, 0xd8a1e681);\n-    md5_GG(buf, b, c, d, a,  4, 20, 0xe7d3fbc8);\n-    md5_GG(buf, a, b, c, d,  9,  5, 0x21e1cde6);\n-    md5_GG(buf, d, a, b, c, 14,  9, 0xc33707d6);\n-    md5_GG(buf, c, d, a, b,  3, 14, 0xf4d50d87);\n-    md5_GG(buf, b, c, d, a,  8, 20, 0x455a14ed);\n-    md5_GG(buf, a, b, c, d, 13,  5, 0xa9e3e905);\n-    md5_GG(buf, d, a, b, c,  2,  9, 0xfcefa3f8);\n-    md5_GG(buf, c, d, a, b,  7, 14, 0x676f02d9);\n-    md5_GG(buf, b, c, d, a, 12, 20, 0x8d2a4c8a);\n+    md5_GG(reg_cache, a, b, c, d,  1,  5, 0xf61e2562);\n+    md5_GG(reg_cache, d, a, b, c,  6,  9, 0xc040b340);\n+    md5_GG(reg_cache, c, d, a, b, 11, 14, 0x265e5a51);\n+    md5_GG(reg_cache, b, c, d, a,  0, 20, 0xe9b6c7aa);\n+    md5_GG(reg_cache, a, b, c, d,  5,  5, 0xd62f105d);\n+    md5_GG(reg_cache, d, a, b, c, 10,  9, 0x02441453);\n+    md5_GG(reg_cache, c, d, a, b, 15, 14, 0xd8a1e681);\n+    md5_GG(reg_cache, b, c, d, a,  4, 20, 0xe7d3fbc8);\n+    md5_GG(reg_cache, a, b, c, d,  9,  5, 0x21e1cde6);\n+    md5_GG(reg_cache, d, a, b, c, 14,  9, 0xc33707d6);\n+    md5_GG(reg_cache, c, d, a, b,  3, 14, 0xf4d50d87);\n+    md5_GG(reg_cache, b, c, d, a,  8, 20, 0x455a14ed);\n+    md5_GG(reg_cache, a, b, c, d, 13,  5, 0xa9e3e905);\n+    md5_GG(reg_cache, d, a, b, c,  2,  9, 0xfcefa3f8);\n+    md5_GG(reg_cache, c, d, a, b,  7, 14, 0x676f02d9);\n+    md5_GG(reg_cache, b, c, d, a, 12, 20, 0x8d2a4c8a);\n@@ -3473,16 +3508,16 @@\n-    md5_HH(buf, a, b, c, d,  5,  4, 0xfffa3942);\n-    md5_HH(buf, d, a, b, c,  8, 11, 0x8771f681);\n-    md5_HH(buf, c, d, a, b, 11, 16, 0x6d9d6122);\n-    md5_HH(buf, b, c, d, a, 14, 23, 0xfde5380c);\n-    md5_HH(buf, a, b, c, d,  1,  4, 0xa4beea44);\n-    md5_HH(buf, d, a, b, c,  4, 11, 0x4bdecfa9);\n-    md5_HH(buf, c, d, a, b,  7, 16, 0xf6bb4b60);\n-    md5_HH(buf, b, c, d, a, 10, 23, 0xbebfbc70);\n-    md5_HH(buf, a, b, c, d, 13,  4, 0x289b7ec6);\n-    md5_HH(buf, d, a, b, c,  0, 11, 0xeaa127fa);\n-    md5_HH(buf, c, d, a, b,  3, 16, 0xd4ef3085);\n-    md5_HH(buf, b, c, d, a,  6, 23, 0x04881d05);\n-    md5_HH(buf, a, b, c, d,  9,  4, 0xd9d4d039);\n-    md5_HH(buf, d, a, b, c, 12, 11, 0xe6db99e5);\n-    md5_HH(buf, c, d, a, b, 15, 16, 0x1fa27cf8);\n-    md5_HH(buf, b, c, d, a,  2, 23, 0xc4ac5665);\n+    md5_HH(reg_cache, a, b, c, d,  5,  4, 0xfffa3942);\n+    md5_HH(reg_cache, d, a, b, c,  8, 11, 0x8771f681);\n+    md5_HH(reg_cache, c, d, a, b, 11, 16, 0x6d9d6122);\n+    md5_HH(reg_cache, b, c, d, a, 14, 23, 0xfde5380c);\n+    md5_HH(reg_cache, a, b, c, d,  1,  4, 0xa4beea44);\n+    md5_HH(reg_cache, d, a, b, c,  4, 11, 0x4bdecfa9);\n+    md5_HH(reg_cache, c, d, a, b,  7, 16, 0xf6bb4b60);\n+    md5_HH(reg_cache, b, c, d, a, 10, 23, 0xbebfbc70);\n+    md5_HH(reg_cache, a, b, c, d, 13,  4, 0x289b7ec6);\n+    md5_HH(reg_cache, d, a, b, c,  0, 11, 0xeaa127fa);\n+    md5_HH(reg_cache, c, d, a, b,  3, 16, 0xd4ef3085);\n+    md5_HH(reg_cache, b, c, d, a,  6, 23, 0x04881d05);\n+    md5_HH(reg_cache, a, b, c, d,  9,  4, 0xd9d4d039);\n+    md5_HH(reg_cache, d, a, b, c, 12, 11, 0xe6db99e5);\n+    md5_HH(reg_cache, c, d, a, b, 15, 16, 0x1fa27cf8);\n+    md5_HH(reg_cache, b, c, d, a,  2, 23, 0xc4ac5665);\n@@ -3491,33 +3526,26 @@\n-    md5_II(buf, a, b, c, d,  0,  6, 0xf4292244);\n-    md5_II(buf, d, a, b, c,  7, 10, 0x432aff97);\n-    md5_II(buf, c, d, a, b, 14, 15, 0xab9423a7);\n-    md5_II(buf, b, c, d, a,  5, 21, 0xfc93a039);\n-    md5_II(buf, a, b, c, d, 12,  6, 0x655b59c3);\n-    md5_II(buf, d, a, b, c,  3, 10, 0x8f0ccc92);\n-    md5_II(buf, c, d, a, b, 10, 15, 0xffeff47d);\n-    md5_II(buf, b, c, d, a,  1, 21, 0x85845dd1);\n-    md5_II(buf, a, b, c, d,  8,  6, 0x6fa87e4f);\n-    md5_II(buf, d, a, b, c, 15, 10, 0xfe2ce6e0);\n-    md5_II(buf, c, d, a, b,  6, 15, 0xa3014314);\n-    md5_II(buf, b, c, d, a, 13, 21, 0x4e0811a1);\n-    md5_II(buf, a, b, c, d,  4,  6, 0xf7537e82);\n-    md5_II(buf, d, a, b, c, 11, 10, 0xbd3af235);\n-    md5_II(buf, c, d, a, b,  2, 15, 0x2ad7d2bb);\n-    md5_II(buf, b, c, d, a,  9, 21, 0xeb86d391);\n-\n-    \/\/ write hash values back in the correct order\n-    __ ldrw(rscratch1, Address(state,  0));\n-    __ addw(rscratch1, rscratch1, a);\n-    __ strw(rscratch1, Address(state,  0));\n-\n-    __ ldrw(rscratch2, Address(state,  4));\n-    __ addw(rscratch2, rscratch2, b);\n-    __ strw(rscratch2, Address(state,  4));\n-\n-    __ ldrw(rscratch3, Address(state,  8));\n-    __ addw(rscratch3, rscratch3, c);\n-    __ strw(rscratch3, Address(state,  8));\n-\n-    __ ldrw(rscratch4, Address(state, 12));\n-    __ addw(rscratch4, rscratch4, d);\n-    __ strw(rscratch4, Address(state, 12));\n+    md5_II(reg_cache, a, b, c, d,  0,  6, 0xf4292244);\n+    md5_II(reg_cache, d, a, b, c,  7, 10, 0x432aff97);\n+    md5_II(reg_cache, c, d, a, b, 14, 15, 0xab9423a7);\n+    md5_II(reg_cache, b, c, d, a,  5, 21, 0xfc93a039);\n+    md5_II(reg_cache, a, b, c, d, 12,  6, 0x655b59c3);\n+    md5_II(reg_cache, d, a, b, c,  3, 10, 0x8f0ccc92);\n+    md5_II(reg_cache, c, d, a, b, 10, 15, 0xffeff47d);\n+    md5_II(reg_cache, b, c, d, a,  1, 21, 0x85845dd1);\n+    md5_II(reg_cache, a, b, c, d,  8,  6, 0x6fa87e4f);\n+    md5_II(reg_cache, d, a, b, c, 15, 10, 0xfe2ce6e0);\n+    md5_II(reg_cache, c, d, a, b,  6, 15, 0xa3014314);\n+    md5_II(reg_cache, b, c, d, a, 13, 21, 0x4e0811a1);\n+    md5_II(reg_cache, a, b, c, d,  4,  6, 0xf7537e82);\n+    md5_II(reg_cache, d, a, b, c, 11, 10, 0xbd3af235);\n+    md5_II(reg_cache, c, d, a, b,  2, 15, 0x2ad7d2bb);\n+    md5_II(reg_cache, b, c, d, a,  9, 21, 0xeb86d391);\n+\n+    __ addw(a, state_regs[0], a);\n+    __ ubfx(rscratch2, state_regs[0], 32, 32);\n+    __ addw(b, rscratch2, b);\n+    __ addw(c, state_regs[1], c);\n+    __ ubfx(rscratch4, state_regs[1], 32, 32);\n+    __ addw(d, rscratch4, d);\n+\n+    __ orr(state_regs[0], a, b, Assembler::LSL, 32);\n+    __ orr(state_regs[1], c, d, Assembler::LSL, 32);\n@@ -3533,0 +3561,5 @@\n+    \/\/ write hash values back in the correct order\n+    __ stp(state_regs[0], state_regs[1], Address(state));\n+\n+    __ pop(saved_regs, sp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":127,"deletions":94,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -815,1 +815,1 @@\n-  __ str(r0, Address(esp, BasicObjectLock::obj_offset_in_bytes()));\n+  __ str(r0, Address(esp, BasicObjectLock::obj_offset()));\n@@ -861,1 +861,1 @@\n-  __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));\n+  __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset()));\n@@ -1437,1 +1437,1 @@\n-  __ str(zr, Address(t, JNIHandleBlock::top_offset_in_bytes()));\n+  __ str(zr, Address(t, JNIHandleBlock::top_offset()));\n@@ -1515,1 +1515,1 @@\n-      __ ldr(t, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+      __ ldr(t, Address(c_rarg1, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3835,1 +3835,1 @@\n-    __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));\n+    __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset()));\n@@ -3895,1 +3895,1 @@\n-  __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+  __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset()));\n@@ -3934,1 +3934,1 @@\n-    __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+    __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-  assert(BasicObjectLock::lock_offset_in_bytes() == 0, \"adjust this code\");\n-  const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n+  assert(BasicObjectLock::lock_offset() == 0, \"adjust this code\");\n+  const ByteSize obj_offset = BasicObjectLock::obj_offset();\n@@ -269,2 +269,2 @@\n-  assert(BasicObjectLock::lock_offset_in_bytes() == 0, \"adjust this code\");\n-  const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n+  assert(BasicObjectLock::lock_offset() == 0, \"adjust this code\");\n+  const ByteSize obj_offset = BasicObjectLock::obj_offset();\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-  ldr(cache, Address(result, ConstantPool::cache_offset_in_bytes()));\n-  ldr(cache, Address(result, ConstantPoolCache::resolved_references_offset_in_bytes()));\n+  ldr(cache, Address(result, ConstantPool::cache_offset()));\n+  ldr(cache, Address(result, ConstantPoolCache::resolved_references_offset()));\n@@ -288,1 +288,1 @@\n-  ldr(Rklass, Address(Rcpool,  ConstantPool::resolved_klasses_offset_in_bytes())); \/\/ Rklass = cpool->_resolved_klasses\n+  ldr(Rklass, Address(Rcpool,  ConstantPool::resolved_klasses_offset())); \/\/ Rklass = cpool->_resolved_klasses\n@@ -758,1 +758,1 @@\n-  ldr(Robj, Address(Rmonitor, BasicObjectLock::obj_offset_in_bytes()));\n+  ldr(Robj, Address(Rmonitor, BasicObjectLock::obj_offset()));\n@@ -829,1 +829,1 @@\n-    ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset_in_bytes()), ne);\n+    ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset()), ne);\n@@ -839,1 +839,1 @@\n-    ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset_in_bytes()), ne);\n+    ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset()), ne);\n@@ -897,2 +897,2 @@\n-    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n-    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n+    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n@@ -1014,2 +1014,2 @@\n-    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n-    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n+    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-  void get_constant_pool_cache(Register reg)               { get_constant_pool(reg); ldr(reg, Address(reg, ConstantPool::cache_offset_in_bytes())); }\n-  void get_cpool_and_tags(Register cpool, Register tags)   { get_constant_pool(cpool); ldr(tags, Address(cpool, ConstantPool::tags_offset_in_bytes())); }\n+  void get_constant_pool_cache(Register reg)               { get_constant_pool(reg); ldr(reg, Address(reg, ConstantPool::cache_offset())); }\n+  void get_cpool_and_tags(Register cpool, Register tags)   { get_constant_pool(cpool); ldr(tags, Address(cpool, ConstantPool::tags_offset())); }\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  const int base_offset = in_bytes(Klass::vtable_start_offset()) + vtableEntry::method_offset_in_bytes();\n+  const ByteSize base_offset = Klass::vtable_start_offset() + vtableEntry::method_offset();\n@@ -1383,1 +1383,1 @@\n-  assert(itableOffsetEntry::interface_offset_in_bytes() == 0, \"not added for convenience\");\n+  assert(itableOffsetEntry::interface_offset() == 0, \"not added for convenience\");\n@@ -1407,1 +1407,1 @@\n-    ldr_s32(Rtmp, Address(Rscan, itableOffsetEntry::offset_offset_in_bytes() - entry_size));\n+    ldr_s32(Rtmp, Address(Rscan, in_bytes(itableOffsetEntry::offset_offset()) - entry_size));\n@@ -1411,1 +1411,1 @@\n-      assert(itableMethodEntry::method_offset_in_bytes() == 0, \"adjust the offset in the code below\");\n+      assert(itableMethodEntry::method_offset() == 0, \"adjust the offset in the code below\");\n@@ -1415,1 +1415,1 @@\n-                          itableMethodEntry::method_offset_in_bytes();\n+                          in_bytes(itableMethodEntry::method_offset());\n@@ -1646,1 +1646,1 @@\n-  ldr(tmp, Address(tmp, ConstantPool::pool_holder_offset_in_bytes()));\n+  ldr(tmp, Address(tmp, ConstantPool::pool_holder_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    __ ldrh(rdi_temp, Address(rbx_method, Method::intrinsic_id_offset_in_bytes()));\n+    __ ldrh(rdi_temp, Address(rbx_method, Method::intrinsic_id_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1265,1 +1265,1 @@\n-  __ str_32(Rtemp, Address(LR, JNIHandleBlock::top_offset_in_bytes()));\n+  __ str_32(Rtemp, Address(LR, JNIHandleBlock::top_offset()));\n@@ -1453,1 +1453,1 @@\n-  __ ldr_s32(Rkind, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+  __ ldr_s32(Rkind, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -1487,3 +1487,3 @@\n-  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n-  __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n-  __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n+  __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset()));\n+  __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -1505,2 +1505,2 @@\n-  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n-  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -1509,1 +1509,1 @@\n-  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -1521,1 +1521,1 @@\n-  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n@@ -1523,1 +1523,1 @@\n-  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));\n+  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n@@ -1564,1 +1564,1 @@\n-    __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+    __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -1674,1 +1674,1 @@\n-    __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+    __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -1684,3 +1684,3 @@\n-  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n-  __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n-  __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n+  __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset()));\n+  __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -1702,2 +1702,2 @@\n-  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n-  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -1706,2 +1706,2 @@\n-  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n-  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset()));\n+  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n@@ -1711,1 +1711,1 @@\n-  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-  __ str(R0, Address(Rstack_top, BasicObjectLock::obj_offset_in_bytes()));\n+  __ str(R0, Address(Rstack_top, BasicObjectLock::obj_offset()));\n@@ -661,1 +661,1 @@\n-  __ ldr(Rtemp, Address(Rtemp, ConstantPool::cache_offset_in_bytes()));\n+  __ ldr(Rtemp, Address(Rtemp, ConstantPool::cache_offset()));\n@@ -1057,1 +1057,1 @@\n-  __ str_32(__ zero_register(Rtemp), Address(R3, JNIHandleBlock::top_offset_in_bytes()));\n+  __ str_32(__ zero_register(Rtemp), Address(R3, JNIHandleBlock::top_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3692,1 +3692,1 @@\n-  const int base = in_bytes(Klass::vtable_start_offset());\n+  const ByteSize base = Klass::vtable_start_offset();\n@@ -3695,1 +3695,1 @@\n-  __ ldr(Rmethod, Address(Rtemp, base + vtableEntry::method_offset_in_bytes()));\n+  __ ldr(Rmethod, Address(Rtemp, base + vtableEntry::method_offset()));\n@@ -3804,1 +3804,1 @@\n-  __ ldr(Rinterf, Address(Rtemp, ConstantPool::pool_holder_offset_in_bytes()));\n+  __ ldr(Rinterf, Address(Rtemp, ConstantPool::pool_holder_offset()));\n@@ -4293,1 +4293,1 @@\n-    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset_in_bytes()), ne);\n+    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset()), ne);\n@@ -4307,1 +4307,1 @@\n-    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset_in_bytes()), ne);\n+    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset()), ne);\n@@ -4360,1 +4360,1 @@\n-  __ str(Robj, Address(Rentry, BasicObjectLock::obj_offset_in_bytes()));     \/\/ store object\n+  __ str(Robj, Address(Rentry, BasicObjectLock::obj_offset()));     \/\/ store object\n@@ -4397,1 +4397,1 @@\n-    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset_in_bytes()), ne);\n+    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset()), ne);\n@@ -4407,1 +4407,1 @@\n-    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset_in_bytes()), ne);\n+    __ ldr(Rcur_obj, Address(Rcur, BasicObjectLock::obj_offset()), ne);\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    int method_offset = vtableEntry::method_offset_in_bytes() + entry_offset;\n+    int method_offset = in_bytes(vtableEntry::method_offset()) + entry_offset;\n","filename":"src\/hotspot\/cpu\/arm\/vtableStubs_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1751,0 +1751,1 @@\n+  inline void ld(   Register d, ByteSize si16, Register s1);\n@@ -2489,0 +2490,1 @@\n+  inline void ld(   Register d, ByteSize si16);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+inline void Assembler::ld(   Register d, ByteSize si16, Register s1) { assert(in_bytes(si16) < 0x7fff, \"overflow\"); ld(d, in_bytes(si16), s1); }\n@@ -1082,0 +1083,1 @@\n+inline void Assembler::ld(   Register d, ByteSize si16) { assert(in_bytes(si16) < 0x7fff, \"overflow\"); ld(d, in_bytes(si16)); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  std(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n+  std(Roop, in_bytes(BasicObjectLock::obj_offset()), Rbox);\n@@ -170,1 +170,1 @@\n-  ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n+  ld(Roop, in_bytes(BasicObjectLock::obj_offset()), Rbox);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -508,2 +508,2 @@\n-  ld(result, ConstantPool::cache_offset_in_bytes(), result);\n-  ld(result, ConstantPoolCache::resolved_references_offset_in_bytes(), result);\n+  ld(result, ConstantPool::cache_offset(), result);\n+  ld(result, ConstantPoolCache::resolved_references_offset(), result);\n@@ -539,1 +539,1 @@\n-  ld(Rklass, ConstantPool::resolved_klasses_offset_in_bytes(), Rcpool); \/\/ Rklass = Rcpool->_resolved_klasses\n+  ld(Rklass, ConstantPool::resolved_klasses_offset(), Rcpool); \/\/ Rklass = Rcpool->_resolved_klasses\n@@ -649,1 +649,1 @@\n-  ld(Rdst, ConstantPool::cache_offset_in_bytes(), Rdst);\n+  ld(Rdst, ConstantPool::cache_offset(), Rdst);\n@@ -654,1 +654,1 @@\n-  ld(Rtags, ConstantPool::tags_offset_in_bytes(), Rcpool);\n+  ld(Rtags, ConstantPool::tags_offset(), Rcpool);\n@@ -704,1 +704,1 @@\n-    ld(R0, BasicObjectLock::obj_offset_in_bytes(), Rmonitor_base);\n+    ld(R0, BasicObjectLock::obj_offset(), Rmonitor_base);\n@@ -743,1 +743,1 @@\n-           BasicObjectLock::obj_offset_in_bytes() - frame::interpreter_frame_monitor_size_in_bytes());\n+           in_bytes(BasicObjectLock::obj_offset()) - frame::interpreter_frame_monitor_size_in_bytes());\n@@ -778,1 +778,1 @@\n-      addi(Rmonitor_addr, Rcurrent_obj_addr, -BasicObjectLock::obj_offset_in_bytes() + delta);\n+      addi(Rmonitor_addr, Rcurrent_obj_addr, -in_bytes(BasicObjectLock::obj_offset()) + delta);\n@@ -967,0 +967,3 @@\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+    const int mark_offset = lock_offset +\n+                            BasicLock::displaced_header_offset_in_bytes();\n@@ -969,2 +972,1 @@\n-    std(displaced_header, BasicObjectLock::lock_offset_in_bytes() +\n-        BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    std(displaced_header, mark_offset, monitor);\n@@ -1011,2 +1013,1 @@\n-    std(R0\/*==0!*\/, BasicObjectLock::lock_offset_in_bytes() +\n-        BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    std(R0\/*==0!*\/, mark_offset, monitor);\n@@ -1068,2 +1069,2 @@\n-    ld(displaced_header, BasicObjectLock::lock_offset_in_bytes() +\n-           BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    ld(displaced_header, in_bytes(BasicObjectLock::lock_offset()) +\n+                         BasicLock::displaced_header_offset_in_bytes(), monitor);\n@@ -1082,1 +1083,1 @@\n-    ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n+    ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n@@ -1116,1 +1117,1 @@\n-    std(R0, BasicObjectLock::obj_offset_in_bytes(), monitor);\n+    std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n@@ -1864,1 +1865,1 @@\n-      lbz(tmp2, Method::intrinsic_id_offset_in_bytes(), R19_method);\n+      lbz(tmp2, in_bytes(Method::intrinsic_id_offset()), R19_method);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1792,1 +1792,1 @@\n-  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n@@ -1829,1 +1829,1 @@\n-    ld(temp2, itableOffsetEntry::interface_offset_in_bytes(), scan_temp);\n+    ld(temp2, in_bytes(itableOffsetEntry::interface_offset()), scan_temp);\n@@ -1856,1 +1856,1 @@\n-    int ito_offset = itableOffsetEntry::offset_offset_in_bytes();\n+    int ito_offset = in_bytes(itableOffsetEntry::offset_offset());\n@@ -1869,1 +1869,1 @@\n-  const int base = in_bytes(Klass::vtable_start_offset());\n+  const ByteSize base = Klass::vtable_start_offset();\n@@ -1878,1 +1878,1 @@\n-  ld(R19_method, base + vtableEntry::method_offset_in_bytes(), recv_klass);\n+  ld(R19_method, in_bytes(base + vtableEntry::method_offset()), recv_klass);\n@@ -2356,1 +2356,1 @@\n-    load_const(R0, (address)method_data + MethodData::rtm_state_offset_in_bytes(), tmpReg);\n+    load_const(R0, (address)method_data + in_bytes(MethodData::rtm_state_offset()), tmpReg);\n@@ -2376,1 +2376,1 @@\n-    load_const(R0, (address)method_data + MethodData::rtm_state_offset_in_bytes(), tmpReg);\n+    load_const(R0, (address)method_data + in_bytes(MethodData::rtm_state_offset()), tmpReg);\n@@ -2549,1 +2549,1 @@\n-  int owner_offset = ObjectMonitor::owner_offset_in_bytes() - markWord::monitor_value;\n+  int owner_offset = in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value;\n@@ -2722,1 +2722,1 @@\n-  addi(temp, displaced_header, ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value);\n+  addi(temp, displaced_header, in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value);\n@@ -2741,1 +2741,1 @@\n-  ld(recursions, ObjectMonitor::recursions_offset_in_bytes()-ObjectMonitor::owner_offset_in_bytes(), temp);\n+  ld(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n@@ -2743,1 +2743,1 @@\n-  std(recursions, ObjectMonitor::recursions_offset_in_bytes()-ObjectMonitor::owner_offset_in_bytes(), temp);\n+  std(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n@@ -2820,1 +2820,1 @@\n-  ld(temp,             ObjectMonitor::owner_offset_in_bytes(), current_header);\n+  ld(temp,             in_bytes(ObjectMonitor::owner_offset()), current_header);\n@@ -2835,1 +2835,1 @@\n-  ld(displaced_header, ObjectMonitor::recursions_offset_in_bytes(), current_header);\n+  ld(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n@@ -2842,1 +2842,1 @@\n-  std(displaced_header, ObjectMonitor::recursions_offset_in_bytes(), current_header);\n+  std(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n@@ -2846,2 +2846,2 @@\n-  ld(temp,             ObjectMonitor::EntryList_offset_in_bytes(), current_header);\n-  ld(displaced_header, ObjectMonitor::cxq_offset_in_bytes(), current_header);\n+  ld(temp,             in_bytes(ObjectMonitor::EntryList_offset()), current_header);\n+  ld(displaced_header, in_bytes(ObjectMonitor::cxq_offset()), current_header);\n@@ -2852,1 +2852,1 @@\n-  std(temp, ObjectMonitor::owner_offset_in_bytes(), current_header);\n+  std(temp, in_bytes(ObjectMonitor::owner_offset()), current_header);\n@@ -3088,1 +3088,1 @@\n-  ld(holder, ConstantPool::pool_holder_offset_in_bytes(), holder);\n+  ld(holder, ConstantPool::pool_holder_offset(), holder);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    __ load_sized_value(R30_tmp1, Method::intrinsic_id_offset_in_bytes(), R19_method,\n+    __ load_sized_value(R30_tmp1, in_bytes(Method::intrinsic_id_offset()), R19_method,\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3606,1 +3606,1 @@\n-      int v_off = entry_offset + vtableEntry::method_offset_in_bytes();\n+      int v_off = entry_offset + in_bytes(vtableEntry::method_offset());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2747,1 +2747,1 @@\n-  __ stw(r_temp_2, JNIHandleBlock::top_offset_in_bytes(), r_temp_1);\n+  __ stw(r_temp_2, in_bytes(JNIHandleBlock::top_offset()), r_temp_1);\n@@ -2859,1 +2859,1 @@\n-             Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes(),\n+             in_bytes(Deoptimization::UnrollBlock::number_of_frames_offset()),\n@@ -2862,1 +2862,1 @@\n-            Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes(),\n+            in_bytes(Deoptimization::UnrollBlock::frame_pcs_offset()),\n@@ -2865,1 +2865,1 @@\n-            Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes(),\n+            in_bytes(Deoptimization::UnrollBlock::frame_sizes_offset()),\n@@ -2891,1 +2891,1 @@\n-             Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes(),\n+             in_bytes(Deoptimization::UnrollBlock::caller_adjustment_offset()),\n@@ -3072,1 +3072,1 @@\n-  __ lwz(exec_mode_reg, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes(), unroll_block_reg);\n+  __ lwz(exec_mode_reg, in_bytes(Deoptimization::UnrollBlock::unpack_kind_offset()), unroll_block_reg);\n@@ -3099,1 +3099,1 @@\n-  __ ld_ptr(caller_sp, Deoptimization::UnrollBlock::initial_info_offset_in_bytes(), unroll_block_reg);\n+  __ ld_ptr(caller_sp, Deoptimization::UnrollBlock::initial_info_offset(), unroll_block_reg);\n@@ -3232,1 +3232,1 @@\n-  __ lwz(R22_tmp2, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes(), unroll_block_reg);\n+  __ lwz(R22_tmp2, in_bytes(Deoptimization::UnrollBlock::unpack_kind_offset()), unroll_block_reg);\n@@ -3241,1 +3241,1 @@\n-  __ ld_ptr(caller_sp, Deoptimization::UnrollBlock::initial_info_offset_in_bytes(), unroll_block_reg);\n+  __ ld_ptr(caller_sp, Deoptimization::UnrollBlock::initial_info_offset(), unroll_block_reg);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-  __ std(Robj_to_lock, BasicObjectLock::obj_offset_in_bytes(), R26_monitor);\n+  __ std(Robj_to_lock, in_bytes(BasicObjectLock::obj_offset()), R26_monitor);\n@@ -1004,1 +1004,1 @@\n-  __ ld(R27_constPoolCache, ConstantPool::cache_offset_in_bytes(), Rconst_pool);\n+  __ ld(R27_constPoolCache, ConstantPool::cache_offset(), Rconst_pool);\n@@ -1029,1 +1029,1 @@\n-  __ ld(Rmirror, ConstantPool::pool_holder_offset_in_bytes(), Rconst_pool);\n+  __ ld(Rmirror, ConstantPool::pool_holder_offset(), Rconst_pool);\n@@ -1544,1 +1544,1 @@\n-  __ stw(R0, JNIHandleBlock::top_offset_in_bytes(), active_handles);\n+  __ stw(R0, in_bytes(JNIHandleBlock::top_offset()), active_handles);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1739,1 +1739,1 @@\n-    __ lbz(R0, nmethod::state_offset(), R3_RET);\n+    __ lbz(R0, in_bytes(nmethod::state_offset()), R3_RET);\n@@ -3462,1 +3462,1 @@\n-  const int base = in_bytes(Klass::vtable_start_offset());\n+  const ByteSize base = Klass::vtable_start_offset();\n@@ -3466,1 +3466,1 @@\n-  __ addi(Rrecv_klass, Rrecv_klass, base + vtableEntry::method_offset_in_bytes());\n+  __ addi(Rrecv_klass, Rrecv_klass, in_bytes(base + vtableEntry::method_offset()));\n@@ -4138,1 +4138,1 @@\n-    __ addi(Rcurrent_obj_addr, R26_monitor, BasicObjectLock::obj_offset_in_bytes());\n+    __ addi(Rcurrent_obj_addr, R26_monitor, in_bytes(BasicObjectLock::obj_offset()));\n@@ -4141,1 +4141,1 @@\n-    __ addi(Rlimit, Rlimit, - (frame::ijava_state_size + frame::interpreter_frame_monitor_size_in_bytes() - BasicObjectLock::obj_offset_in_bytes())); \/\/ Monitor base\n+    __ addi(Rlimit, Rlimit, - (frame::ijava_state_size + frame::interpreter_frame_monitor_size_in_bytes() - in_bytes(BasicObjectLock::obj_offset()))); \/\/ Monitor base\n@@ -4172,1 +4172,1 @@\n-  __ addi(Rcurrent_monitor, Rcurrent_obj_addr, -(frame::interpreter_frame_monitor_size() * wordSize) - BasicObjectLock::obj_offset_in_bytes());\n+  __ addi(Rcurrent_monitor, Rcurrent_obj_addr, -(frame::interpreter_frame_monitor_size() * wordSize) - in_bytes(BasicObjectLock::obj_offset()));\n@@ -4181,1 +4181,1 @@\n-  __ addi(Rcurrent_obj_addr, R26_monitor, BasicObjectLock::obj_offset_in_bytes());\n+  __ addi(Rcurrent_obj_addr, R26_monitor, in_bytes(BasicObjectLock::obj_offset()));\n@@ -4228,2 +4228,2 @@\n-    __ addi(Rcurrent_obj_addr, R26_monitor, BasicObjectLock::obj_offset_in_bytes());\n-    __ addi(Rlimit, Rlimit, BasicObjectLock::obj_offset_in_bytes());\n+    __ addi(Rcurrent_obj_addr, R26_monitor, in_bytes(BasicObjectLock::obj_offset()));\n+    __ addi(Rlimit, Rlimit, in_bytes(BasicObjectLock::obj_offset()));\n@@ -4256,1 +4256,1 @@\n-          -(frame::interpreter_frame_monitor_size() * wordSize) - BasicObjectLock::obj_offset_in_bytes());\n+          -(frame::interpreter_frame_monitor_size() * wordSize) - in_bytes(BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();\n+  int v_off        = entry_offset + in_bytes(vtableEntry::method_offset());\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1314,0 +1314,3 @@\n+  \/\/ Vector Slide Instructions\n+  INSN(vslidedown_vi, 0b1010111, 0b011, 0b001111);\n+\n@@ -1514,0 +1517,3 @@\n+  \/\/ Vector Slide Instructions\n+  INSN(vslidedown_vx, 0b1010111, 0b100, 0b001111);\n+\n@@ -1526,0 +1532,10 @@\n+#define INSN(NAME, op, funct3, vm, funct6)                                                         \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, FloatRegister Rs1) {                            \\\n+    patch_VArith(op, Vd, funct3, Rs1->raw_encoding(), Vs2, vm, funct6);                            \\\n+  }\n+\n+  \/\/ Vector Floating-Point Merge Instruction\n+  INSN(vfmerge_vfm,  0b1010111, 0b101, 0b0, 0b010111);\n+\n+#undef INSN\n+\n@@ -1764,2 +1780,0 @@\n-  INSN(vluxei8_v,  0b0000111, 0b000, 0b01, 0b0);\n-  INSN(vluxei16_v, 0b0000111, 0b101, 0b01, 0b0);\n@@ -1767,1 +1781,0 @@\n-  INSN(vluxei64_v, 0b0000111, 0b111, 0b01, 0b0);\n@@ -1769,5 +1782,3 @@\n-  \/\/ Vector ordered indexed load instructions\n-  INSN(vloxei8_v,  0b0000111, 0b000, 0b11, 0b0);\n-  INSN(vloxei16_v, 0b0000111, 0b101, 0b11, 0b0);\n-  INSN(vloxei32_v, 0b0000111, 0b110, 0b11, 0b0);\n-  INSN(vloxei64_v, 0b0000111, 0b111, 0b11, 0b0);\n+  \/\/ Vector unordered indexed store instructions\n+  INSN(vsuxei32_v, 0b0100111, 0b110, 0b01, 0b0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  sd(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  sd(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -133,1 +133,1 @@\n-  ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  __ sd(xthread, Address(mon, ObjectMonitor::owner_offset_in_bytes()));\n+  __ sd(xthread, Address(mon, ObjectMonitor::owner_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/c2_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1642,0 +1642,24 @@\n+\/\/ Set dst to NaN if any NaN input.\n+\/\/ The destination vector register elements corresponding to masked-off elements\n+\/\/ are handled with a mask-undisturbed policy.\n+void C2_MacroAssembler::minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                                           VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                                           bool is_double, bool is_min, int vector_length) {\n+  assert_different_registers(src1, src2, tmp1, tmp2);\n+  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+\n+  \/\/ Check vector elements of src1 and src2 for NaN.\n+  vmfeq_vv(tmp1, src1, src1);\n+  vmfeq_vv(tmp2, src2, src2);\n+\n+  vmandn_mm(v0, vmask, tmp1);\n+  vfadd_vv(dst, src1, src1, Assembler::v0_t);\n+  vmandn_mm(v0, vmask, tmp2);\n+  vfadd_vv(dst, src2, src2, Assembler::v0_t);\n+\n+  vmand_mm(tmp2, tmp1, tmp2);\n+  vmand_mm(v0, vmask, tmp2);\n+  is_min ? vfmin_vv(dst, src1, src2, Assembler::v0_t)\n+         : vfmax_vv(dst, src1, src2, Assembler::v0_t);\n+}\n+\n@@ -1646,1 +1670,2 @@\n-                                           bool is_double, bool is_min, int vector_length) {\n+                                           bool is_double, bool is_min, int vector_length, VectorMask vm) {\n+  assert_different_registers(dst, src1);\n@@ -1649,1 +1674,6 @@\n-  Label L_done, L_NaN;\n+  Label L_done, L_NaN_1, L_NaN_2;\n+  \/\/ Set dst to src1 if src1 is NaN\n+  is_double ? feq_d(t0, src1, src1)\n+            : feq_s(t0, src1, src1);\n+  beqz(t0, L_NaN_2);\n+\n@@ -1653,2 +1683,3 @@\n-  is_min ? vfredmin_vs(tmp1, src2, tmp2)\n-         : vfredmax_vs(tmp1, src2, tmp2);\n+  is_min ? vfredmin_vs(tmp1, src2, tmp2, vm)\n+         : vfredmax_vs(tmp1, src2, tmp2, vm);\n+  vfmv_f_s(dst, tmp1);\n@@ -1656,6 +1687,4 @@\n-  fsflags(zr);\n-  \/\/ Checking NaNs\n-  vmflt_vf(tmp2, src2, src1);\n-  frflags(t0);\n-  bnez(t0, L_NaN);\n-  j(L_done);\n+  \/\/ Checking NaNs in src2\n+  vmfne_vv(tmp1, src2, src2, vm);\n+  vcpop_m(t0, tmp1, vm);\n+  beqz(t0, L_done);\n@@ -1663,3 +1692,4 @@\n-  bind(L_NaN);\n-  vfmv_s_f(tmp2, src1);\n-  vfredusum_vs(tmp1, src2, tmp2);\n+  bind(L_NaN_1);\n+  vfredusum_vs(tmp1, src2, tmp2, vm);\n+  vfmv_f_s(dst, tmp1);\n+  j(L_done);\n@@ -1667,0 +1697,3 @@\n+  bind(L_NaN_2);\n+  is_double ? fmv_d(dst, src1)\n+            : fmv_s(dst, src1);\n@@ -1668,1 +1701,0 @@\n-  vfmv_f_s(dst, tmp1);\n@@ -1681,3 +1713,3 @@\n-void C2_MacroAssembler::reduce_integral_v(Register dst, VectorRegister tmp,\n-                                          Register src1, VectorRegister src2,\n-                                          BasicType bt, int opc, int vector_length) {\n+void C2_MacroAssembler::reduce_integral_v(Register dst, Register src1,\n+                                          VectorRegister src2, VectorRegister tmp,\n+                                          int opc, BasicType bt, int vector_length, VectorMask vm) {\n@@ -1685,1 +1717,0 @@\n-\n@@ -1687,1 +1718,0 @@\n-\n@@ -1689,1 +1719,0 @@\n-\n@@ -1693,1 +1722,1 @@\n-      vredsum_vs(tmp, src2, tmp);\n+      vredsum_vs(tmp, src2, tmp, vm);\n@@ -1696,1 +1725,1 @@\n-      vredand_vs(tmp, src2, tmp);\n+      vredand_vs(tmp, src2, tmp, vm);\n@@ -1699,1 +1728,1 @@\n-      vredor_vs(tmp, src2, tmp);\n+      vredor_vs(tmp, src2, tmp, vm);\n@@ -1702,1 +1731,1 @@\n-      vredxor_vs(tmp, src2, tmp);\n+      vredxor_vs(tmp, src2, tmp, vm);\n@@ -1705,1 +1734,1 @@\n-      vredmax_vs(tmp, src2, tmp);\n+      vredmax_vs(tmp, src2, tmp, vm);\n@@ -1708,1 +1737,1 @@\n-      vredmin_vs(tmp, src2, tmp);\n+      vredmin_vs(tmp, src2, tmp, vm);\n@@ -1713,1 +1742,0 @@\n-\n@@ -1731,2 +1759,2 @@\n-void C2_MacroAssembler::compare_integral_v(VectorRegister vd, BasicType bt, int vector_length,\n-                                           VectorRegister src1, VectorRegister src2, int cond, VectorMask vm) {\n+void C2_MacroAssembler::compare_integral_v(VectorRegister vd, VectorRegister src1, VectorRegister src2,\n+                                           int cond, BasicType bt, int vector_length, VectorMask vm) {\n@@ -1750,4 +1778,2 @@\n-void C2_MacroAssembler::compare_floating_point_v(VectorRegister vd, BasicType bt, int vector_length,\n-                                                 VectorRegister src1, VectorRegister src2,\n-                                                 VectorRegister tmp1, VectorRegister tmp2,\n-                                                 VectorRegister vmask, int cond, VectorMask vm) {\n+void C2_MacroAssembler::compare_fp_v(VectorRegister vd, VectorRegister src1, VectorRegister src2,\n+                                     int cond, BasicType bt, int vector_length, VectorMask vm) {\n@@ -1755,2 +1781,1 @@\n-  assert(vd != v0, \"should be different registers\");\n-  assert(vm == Assembler::v0_t ? vmask != v0 : true, \"vmask should not be v0\");\n+  assert(vm == Assembler::v0_t ? vd != v0 : true, \"should be different registers\");\n@@ -1758,19 +1783,0 @@\n-  \/\/ Check vector elements of src1 and src2 for quiet and signaling NaN.\n-  vfclass_v(tmp1, src1);\n-  vfclass_v(tmp2, src2);\n-  vsrl_vi(tmp1, tmp1, 8);\n-  vsrl_vi(tmp2, tmp2, 8);\n-  vmseq_vx(tmp1, tmp1, zr);\n-  vmseq_vx(tmp2, tmp2, zr);\n-  if (vm == Assembler::v0_t) {\n-    vmand_mm(tmp2, tmp1, tmp2);\n-    if (cond == BoolTest::ne) {\n-      vmandn_mm(tmp1, vmask, tmp2);\n-    }\n-    vmand_mm(v0, vmask, tmp2);\n-  } else {\n-    vmand_mm(v0, tmp1, tmp2);\n-    if (cond == BoolTest::ne) {\n-      vmnot_m(tmp1, v0);\n-    }\n-  }\n@@ -1779,7 +1785,6 @@\n-    case BoolTest::eq: vmfeq_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::ne: vmfne_vv(vd, src1, src2, Assembler::v0_t);\n-                       vmor_mm(vd, vd, tmp1); break;\n-    case BoolTest::le: vmfle_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::ge: vmfge_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::lt: vmflt_vv(vd, src1, src2, Assembler::v0_t); break;\n-    case BoolTest::gt: vmfgt_vv(vd, src1, src2, Assembler::v0_t); break;\n+    case BoolTest::eq: vmfeq_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ne: vmfne_vv(vd, src1, src2, vm); break;\n+    case BoolTest::le: vmfle_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ge: vmfge_vv(vd, src1, src2, vm); break;\n+    case BoolTest::lt: vmflt_vv(vd, src1, src2, vm); break;\n+    case BoolTest::gt: vmfgt_vv(vd, src1, src2, vm); break;\n@@ -1866,1 +1871,0 @@\n-  vfclass_v(v0, src);                                                              \\\n@@ -1868,2 +1872,1 @@\n-  vsrl_vi(v0, v0, 8);                                                              \\\n-  vmseq_vx(v0, v0, zr);                                                            \\\n+  vmfeq_vv(v0, src, src);                                                          \\\n@@ -1878,0 +1881,40 @@\n+\n+\/\/ Extract a scalar element from an vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of integral type.\n+void C2_MacroAssembler::extract_v(Register dst, VectorRegister src, BasicType bt,\n+                                  int idx, VectorRegister tmp) {\n+  assert(is_integral_type(bt), \"unsupported element type\");\n+  assert(idx >= 0, \"idx cannot be negative\");\n+  \/\/ Only need the first element after vector slidedown\n+  vsetvli_helper(bt, 1);\n+  if (idx == 0) {\n+    vmv_x_s(dst, src);\n+  } else if (idx <= 31) {\n+    vslidedown_vi(tmp, src, idx);\n+    vmv_x_s(dst, tmp);\n+  } else {\n+    mv(t0, idx);\n+    vslidedown_vx(tmp, src, t0);\n+    vmv_x_s(dst, tmp);\n+  }\n+}\n+\n+\/\/ Extract a scalar element from an vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of floating point type.\n+void C2_MacroAssembler::extract_fp_v(FloatRegister dst, VectorRegister src, BasicType bt,\n+                                     int idx, VectorRegister tmp) {\n+  assert(is_floating_point_type(bt), \"unsupported element type\");\n+  assert(idx >= 0, \"idx cannot be negative\");\n+  \/\/ Only need the first element after vector slidedown\n+  vsetvli_helper(bt, 1);\n+  if (idx == 0) {\n+    vfmv_f_s(dst, src);\n+  } else if (idx <= 31) {\n+    vslidedown_vi(tmp, src, idx);\n+    vfmv_f_s(dst, tmp);\n+  } else {\n+    mv(t0, idx);\n+    vslidedown_vx(tmp, src, t0);\n+    vfmv_f_s(dst, tmp);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":107,"deletions":64,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+ void minmax_fp_masked_v(VectorRegister dst, VectorRegister src1, VectorRegister src2,\n+                         VectorRegister vmask, VectorRegister tmp1, VectorRegister tmp2,\n+                         bool is_double, bool is_min, int vector_length);\n+\n@@ -195,1 +199,2 @@\n-                         bool is_double, bool is_min, int vector_length);\n+                         bool is_double, bool is_min, int vector_length,\n+                         VectorMask vm = Assembler::unmasked);\n@@ -197,3 +202,4 @@\n- void reduce_integral_v(Register dst, VectorRegister tmp,\n-                        Register src1, VectorRegister src2,\n-                        BasicType bt, int opc, int vector_length);\n+ void reduce_integral_v(Register dst, Register src1,\n+                        VectorRegister src2, VectorRegister tmp,\n+                        int opc, BasicType bt, int vector_length,\n+                        VectorMask vm = Assembler::unmasked);\n@@ -203,2 +209,2 @@\n- void compare_integral_v(VectorRegister dst, BasicType bt, int vector_length,\n-                         VectorRegister src1, VectorRegister src2, int cond, VectorMask vm = Assembler::unmasked);\n+ void compare_integral_v(VectorRegister dst, VectorRegister src1, VectorRegister src2, int cond,\n+                         BasicType bt, int vector_length, VectorMask vm = Assembler::unmasked);\n@@ -206,3 +212,2 @@\n- void compare_floating_point_v(VectorRegister dst, BasicType bt, int vector_length,\n-                               VectorRegister src1, VectorRegister src2, VectorRegister tmp1, VectorRegister tmp2,\n-                               VectorRegister vmask, int cond, VectorMask vm = Assembler::unmasked);\n+ void compare_fp_v(VectorRegister dst, VectorRegister src1, VectorRegister src2, int cond,\n+                   BasicType bt, int vector_length, VectorMask vm = Assembler::unmasked);\n@@ -243,0 +248,3 @@\n+  void extract_v(Register dst, VectorRegister src, BasicType bt, int idx, VectorRegister tmp);\n+  void extract_fp_v(FloatRegister dst, VectorRegister src, BasicType bt, int idx, VectorRegister tmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -303,2 +303,2 @@\n-  ld(result, Address(result, ConstantPool::cache_offset_in_bytes()));\n-  ld(result, Address(result, ConstantPoolCache::resolved_references_offset_in_bytes()));\n+  ld(result, Address(result, ConstantPool::cache_offset()));\n+  ld(result, Address(result, ConstantPoolCache::resolved_references_offset()));\n@@ -316,1 +316,1 @@\n-  ld(klass, Address(cpool, ConstantPool::resolved_klasses_offset_in_bytes())); \/\/ klass = cpool->_resolved_klasses\n+  ld(klass, Address(cpool, ConstantPool::resolved_klasses_offset())); \/\/ klass = cpool->_resolved_klasses\n@@ -661,1 +661,1 @@\n-  ld(x10, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+  ld(x10, Address(c_rarg1, BasicObjectLock::obj_offset()));\n@@ -740,1 +740,1 @@\n-    add(t0, c_rarg1, BasicObjectLock::obj_offset_in_bytes());\n+    add(t0, c_rarg1, in_bytes(BasicObjectLock::obj_offset()));\n@@ -814,2 +814,2 @@\n-    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n-    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n+    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n@@ -917,1 +917,1 @@\n-      la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n+      la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n@@ -921,1 +921,1 @@\n-    ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+    ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -924,1 +924,1 @@\n-    sd(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+    sd(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -963,1 +963,1 @@\n-    sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes())); \/\/ restore obj\n+    sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n@@ -1911,1 +1911,1 @@\n-      lhu(t0, Address(tmp, Method::intrinsic_id_offset_in_bytes()));\n+      lhu(t0, Address(tmp, Method::intrinsic_id_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-    ld(reg, Address(reg, ConstantPool::cache_offset_in_bytes()));\n+    ld(reg, Address(reg, ConstantPool::cache_offset()));\n@@ -133,1 +133,1 @@\n-    ld(tags, Address(cpool, ConstantPool::tags_offset_in_bytes()));\n+    ld(tags, Address(cpool, ConstantPool::tags_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2088,1 +2088,1 @@\n-  ld(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));\n+  ld(dst, Address(dst, ConstantPool::pool_holder_offset()));\n@@ -2403,1 +2403,1 @@\n-  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n@@ -2430,1 +2430,1 @@\n-  ld(method_result, Address(scan_tmp, itableOffsetEntry::interface_offset_in_bytes()));\n+  ld(method_result, Address(scan_tmp, itableOffsetEntry::interface_offset()));\n@@ -2438,1 +2438,1 @@\n-  ld(method_result, Address(scan_tmp, itableOffsetEntry::interface_offset_in_bytes()));\n+  ld(method_result, Address(scan_tmp, itableOffsetEntry::interface_offset()));\n@@ -2445,1 +2445,1 @@\n-    lwu(scan_tmp, Address(scan_tmp, itableOffsetEntry::offset_offset_in_bytes()));\n+    lwu(scan_tmp, Address(scan_tmp, itableOffsetEntry::offset_offset()));\n@@ -2455,1 +2455,1 @@\n-  const int base = in_bytes(Klass::vtable_start_offset());\n+  const ByteSize base = Klass::vtable_start_offset();\n@@ -2458,1 +2458,1 @@\n-  int vtable_offset_in_bytes = base + vtableEntry::method_offset_in_bytes();\n+  int vtable_offset_in_bytes = in_bytes(base + vtableEntry::method_offset());\n@@ -3386,1 +3386,1 @@\n-  ld(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); \/\/ InstanceKlass*\n+  ld(holder, Address(holder, ConstantPool::pool_holder_offset()));          \/\/ InstanceKlass*\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1276,2 +1276,2 @@\n-  inline void vneg_v(VectorRegister vd, VectorRegister vs) {\n-    vrsub_vx(vd, vs, x0);\n+  inline void vneg_v(VectorRegister vd, VectorRegister vs, VectorMask vm = unmasked) {\n+    vrsub_vx(vd, vs, x0, vm);\n@@ -1280,2 +1280,2 @@\n-  inline void vfneg_v(VectorRegister vd, VectorRegister vs) {\n-    vfsgnjn_vv(vd, vs, vs);\n+  inline void vfneg_v(VectorRegister vd, VectorRegister vs, VectorMask vm = unmasked) {\n+    vfsgnjn_vv(vd, vs, vs, vm);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-    __ lhu(t0, Address(xmethod, Method::intrinsic_id_offset_in_bytes()));\n+    __ lhu(t0, Address(xmethod, Method::intrinsic_id_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1890,79 +1890,0 @@\n-const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n-\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n-  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n-    return false;\n-  }\n-\n-  return op_vec_supported(opcode);\n-}\n-\n-const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n-  if (!UseRVV) {\n-    return false;\n-  }\n-  switch (opcode) {\n-    case Op_AddVB:\n-    case Op_AddVS:\n-    case Op_AddVI:\n-    case Op_AddVL:\n-    case Op_AddVF:\n-    case Op_AddVD:\n-    case Op_SubVB:\n-    case Op_SubVS:\n-    case Op_SubVI:\n-    case Op_SubVL:\n-    case Op_SubVF:\n-    case Op_SubVD:\n-    case Op_MulVB:\n-    case Op_MulVS:\n-    case Op_MulVI:\n-    case Op_MulVL:\n-    case Op_MulVF:\n-    case Op_MulVD:\n-    case Op_DivVF:\n-    case Op_DivVD:\n-    case Op_VectorLoadMask:\n-    case Op_VectorMaskCmp:\n-    case Op_AndVMask:\n-    case Op_XorVMask:\n-    case Op_OrVMask:\n-    case Op_RShiftVB:\n-    case Op_RShiftVS:\n-    case Op_RShiftVI:\n-    case Op_RShiftVL:\n-    case Op_LShiftVB:\n-    case Op_LShiftVS:\n-    case Op_LShiftVI:\n-    case Op_LShiftVL:\n-    case Op_URShiftVB:\n-    case Op_URShiftVS:\n-    case Op_URShiftVI:\n-    case Op_URShiftVL:\n-    case Op_VectorBlend:\n-    case Op_VectorReinterpret:\n-      break;\n-    case Op_LoadVector:\n-      opcode = Op_LoadVectorMasked;\n-      break;\n-    case Op_StoreVector:\n-      opcode = Op_StoreVectorMasked;\n-      break;\n-    default:\n-      return false;\n-  }\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n-  return false;\n-}\n-\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  return false;\n-}\n-\n@@ -2570,1 +2491,1 @@\n-    __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes() - markWord::monitor_value));\n+    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n@@ -2589,1 +2510,1 @@\n-    __ increment(Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value), 1, t0, tmp);\n+    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, t0, tmp);\n@@ -2665,1 +2586,1 @@\n-      __ ld(tmp2, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+      __ ld(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n@@ -2673,1 +2594,1 @@\n-    __ ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+    __ ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n@@ -2680,1 +2601,1 @@\n-    __ sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+    __ sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n@@ -2685,2 +2606,2 @@\n-    __ ld(flag, Address(tmp, ObjectMonitor::EntryList_offset_in_bytes()));\n-    __ ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset_in_bytes()));\n+    __ ld(flag, Address(tmp, ObjectMonitor::EntryList_offset()));\n+    __ ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n@@ -2690,1 +2611,1 @@\n-    __ la(tmp, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+    __ la(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n@@ -7671,1 +7592,1 @@\n-  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));\n+  match(Set dst (SqrtF src));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":9,"deletions":88,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -31,4 +31,0 @@\n-source_hpp %{\n-  bool op_vec_supported(int opcode);\n-%}\n-\n@@ -53,1 +49,15 @@\n-  bool op_vec_supported(int opcode) {\n+  const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  \/\/ Identify extra cases that we might want to provide match rules for vector nodes\n+  \/\/ and other intrinsics guarded with vector length (vlen) and element type (bt).\n+  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+    if (!UseRVV) {\n+      return false;\n+    }\n+\n+    if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+      return false;\n+    }\n+\n@@ -55,23 +65,11 @@\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n-      \/\/ Others\n-      case Op_Extract:\n-      case Op_ExtractB:\n-      case Op_ExtractC:\n-      case Op_ExtractD:\n-      case Op_ExtractF:\n-      case Op_ExtractI:\n-      case Op_ExtractL:\n-      case Op_ExtractS:\n-      case Op_ExtractUB:\n-      \/\/ Vector API specific\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_VectorInsert:\n-      case Op_VectorTest:\n-      case Op_PopCountVI:\n-      case Op_PopCountVL:\n-        return false;\n+      case Op_VectorMaskLastTrue:\n+        if (!UseZbb || vlen > XLEN) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskToLong:\n+      case Op_VectorLongToMask:\n+        if (vlen > XLEN) {\n+          return false;\n+        }\n+        break;\n@@ -79,1 +77,1 @@\n-        return UseRVV;\n+        break;\n@@ -81,0 +79,1 @@\n+    return true;\n@@ -83,0 +82,14 @@\n+  const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+    if (!UseRVV) {\n+      return false;\n+    }\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+    return false;\n+  }\n+\n+  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n@@ -164,2 +177,3 @@\n-    __ compare_integral_v(as_VectorRegister($dst$$reg), bt, vector_length, as_VectorRegister($src1$$reg),\n-                          as_VectorRegister($src2$$reg), (int)($cond$$constant));\n+    __ compare_integral_v(as_VectorRegister($dst$$reg),\n+                          as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                          (int)($cond$$constant), bt, vector_length);\n@@ -181,2 +195,3 @@\n-    __ compare_integral_v(as_VectorRegister($dst$$reg), bt, vector_length, as_VectorRegister($src1$$reg),\n-                          as_VectorRegister($src2$$reg), (int)($cond$$constant), Assembler::v0_t);\n+    __ compare_integral_v(as_VectorRegister($dst$$reg),\n+                          as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                          (int)($cond$$constant), bt, vector_length, Assembler::v0_t);\n@@ -189,1 +204,1 @@\n-instruct vmaskcmp_fp(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+instruct vmaskcmp_fp(vRegMask dst, vReg src1, vReg src2, immI cond) %{\n@@ -193,2 +208,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP v0);\n-  format %{ \"vmaskcmp_fp $dst, $src1, $src2, $cond\\t# KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst);\n+  format %{ \"vmaskcmp_fp $dst, $src1, $src2, $cond\" %}\n@@ -198,4 +213,3 @@\n-    __ compare_floating_point_v(as_VectorRegister($dst$$reg), bt, vector_length,\n-                                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n-                                as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                                as_VectorRegister($v0$$reg), (int)($cond$$constant));\n+    __ compare_fp_v(as_VectorRegister($dst$$reg),\n+                    as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                    (int)($cond$$constant), bt, vector_length);\n@@ -206,1 +220,1 @@\n-instruct vmaskcmp_fp_masked(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+instruct vmaskcmp_fp_masked(vRegMask dst, vReg src1, vReg src2, immI cond, vRegMask_V0 v0) %{\n@@ -209,3 +223,3 @@\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond vmask)));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP v0);\n-  format %{ \"vmaskcmp_fp_masked $dst, $src1, $src2, $cond, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond v0)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vmaskcmp_fp_masked $dst, $src1, $src2, $cond, $v0\" %}\n@@ -215,4 +229,3 @@\n-    __ compare_floating_point_v(as_VectorRegister($dst$$reg), bt, vector_length,\n-                                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n-                                as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                                as_VectorRegister($vmask$$reg), (int)($cond$$constant), Assembler::v0_t);\n+    __ compare_fp_v(as_VectorRegister($dst$$reg),\n+                    as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n+                    (int)($cond$$constant), bt, vector_length, Assembler::v0_t);\n@@ -303,0 +316,35 @@\n+\/\/ vector abs - predicated\n+\n+instruct vabs_masked(vReg dst_src, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst_src (AbsVB dst_src v0));\n+  match(Set dst_src (AbsVS dst_src v0));\n+  match(Set dst_src (AbsVI dst_src v0));\n+  match(Set dst_src (AbsVL dst_src v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP tmp);\n+  format %{ \"vabs_masked $dst_src, $dst_src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrsub_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($dst_src$$reg), 0,\n+                Assembler::v0_t);\n+    __ vmax_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($tmp$$reg),\n+               as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabs_fp_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (AbsVF dst_src v0));\n+  match(Set dst_src (AbsVD dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vabs_fp_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfsgnjx_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                  as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -433,0 +481,16 @@\n+\/\/ vector and - predicated\n+\n+instruct vand_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (AndV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vand_masked $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vand_vv(as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -449,0 +513,16 @@\n+\/\/ vector or - predicated\n+\n+instruct vor_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (OrV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vor_masked $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vor_vv(as_VectorRegister($dst_src1$$reg),\n+              as_VectorRegister($dst_src1$$reg),\n+              as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -465,0 +545,16 @@\n+\/\/ vector xor - predicated\n+\n+instruct vxor_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (XorV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vxor_masked $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vv(as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -542,0 +638,32 @@\n+\/\/ vector integer max\/min - predicated\n+\n+instruct vmax_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_FLOAT &&\n+            Matcher::vector_element_basic_type(n) != T_DOUBLE);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vmax_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmax_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmin_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_FLOAT &&\n+            Matcher::vector_element_basic_type(n) != T_DOUBLE);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vmin_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmin_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -544,1 +672,1 @@\n-instruct vmaxF(vReg dst, vReg src1, vReg src2) %{\n+instruct vmaxF(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -547,1 +675,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -558,1 +686,1 @@\n-instruct vmaxD(vReg dst, vReg src1, vReg src2) %{\n+instruct vmaxD(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -561,1 +689,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -572,1 +700,1 @@\n-instruct vminF(vReg dst, vReg src1, vReg src2) %{\n+instruct vminF(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -575,1 +703,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -586,1 +714,1 @@\n-instruct vminD(vReg dst, vReg src1, vReg src2) %{\n+instruct vminD(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n@@ -589,1 +717,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, TEMP v0);\n@@ -600,0 +728,62 @@\n+\/\/ vector float-point max\/min - predicated\n+\n+instruct vmaxF_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmaxF_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaxD_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmaxD_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminF_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vminF_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminD_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) vmask));\n+  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  ins_cost(VEC_COST);\n+  format %{ \"vminD_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  ins_encode %{\n+    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -630,0 +820,17 @@\n+\/\/ vector fmadd - predicated\n+\/\/ dst_src1 = dst_src1 * src2 + src3\n+\n+instruct vfmadd_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 v0)));\n+  format %{ \"vfmadd_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfmadd_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                 as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -664,0 +871,17 @@\n+\/\/ vector fnmsub - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+instruct vfnmsub_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 v0)));\n+  format %{ \"vfnmsub_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfnmsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                  as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -698,0 +922,17 @@\n+\/\/ vector fnmadd - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+instruct vfnmadd_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) v0)));\n+  format %{ \"vfnmadd_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfnmadd_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                  as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -728,0 +969,17 @@\n+\/\/ vector vfmsub - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+instruct vfmsub_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) v0)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) v0)));\n+  format %{ \"vfmsub_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfmsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                 as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -782,0 +1040,17 @@\n+\/\/ vector mla - predicated\n+\n+instruct vmla_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) v0));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) v0));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) v0));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) v0));\n+  format %{ \"vmla_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmacc_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -836,0 +1111,17 @@\n+\/\/ vector mls - predicated\n+\n+instruct vmls_masked(vReg dst_src1, vReg src2, vReg src3, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) v0));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) v0));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) v0));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) v0));\n+  format %{ \"vmls_masked $dst_src1, $src2, $src3, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vnmsac_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($src2$$reg),\n+                 as_VectorRegister($src3$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -967,0 +1259,16 @@\n+\/\/ vector neg - predicated\n+\n+instruct vneg_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (NegVI dst_src v0));\n+  match(Set dst_src (NegVL dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vneg_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vneg_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+              Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -991,0 +1299,16 @@\n+\/\/ vector fneg  - predicated\n+\n+instruct vfneg_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (NegVF dst_src v0));\n+  match(Set dst_src (NegVD dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vfneg_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfneg_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1005,3 +1329,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1022,3 +1346,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and reduction - predicated\n+\n+instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AndReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_andI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_andL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1043,3 +1403,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1060,3 +1420,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or reduction - predicated\n+\n+instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (OrReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_orI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_orL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1081,3 +1477,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1098,3 +1494,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1105,1 +1501,1 @@\n-\/\/ vector add reduction\n+\/\/ vector xor reduction - predicated\n@@ -1107,1 +1503,1 @@\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct reduce_xorI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -1111,1 +1507,1 @@\n-  match(Set dst (AddReductionVI src1 src2));\n+  match(Set dst (XorReductionV (Binary src1 src2) v0));\n@@ -1114,3 +1510,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addI\\n\\t\"\n-            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_xorI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1119,3 +1513,4 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1126,1 +1521,1 @@\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vReg tmp) %{\n+instruct reduce_xorL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -1128,1 +1523,1 @@\n-  match(Set dst (AddReductionVL src1 src2));\n+  match(Set dst (XorReductionV (Binary src1 src2) v0));\n@@ -1131,3 +1526,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addL\\n\\t\"\n-            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_xorL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1136,3 +1529,4 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1143,2 +1537,40 @@\n-instruct reduce_addF(fRegF src1_dst, vReg src2, vReg tmp) %{\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n+\/\/ vector add reduction\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addI\\n\\t\"\n+            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addL\\n\\t\"\n+            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n+            \"vmv.x.s $dst, $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF(fRegF src1_dst, vReg src2, vReg tmp) %{\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n@@ -1177,0 +1609,66 @@\n+\/\/ vector add reduction - predicated\n+\n+instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AddReductionVI (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AddReductionVL (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF_masked(fRegF src1_dst, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set src1_dst (AddReductionVF (Binary src1_dst src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addF_masked $src1_dst, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n+                    as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD_masked(fRegD src1_dst, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set src1_dst (AddReductionVD (Binary src1_dst src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"reduce_addD_masked $src1_dst, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this, $src2));\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfredosum_vs(as_VectorRegister($tmp$$reg), as_VectorRegister($src2$$reg),\n+                    as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1189,3 +1687,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1204,3 +1702,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector integer max reduction - predicated\n+\n+instruct vreduce_maxI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_maxI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_maxL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_maxL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1223,3 +1757,3 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n@@ -1238,3 +1772,39 @@\n-    __ reduce_integral_v($dst$$Register, as_VectorRegister($tmp$$reg),\n-                         $src1$$Register, as_VectorRegister($src2$$reg), bt,\n-                         this->ideal_Opcode(), Matcher::vector_length(this, $src2));\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector integer min reduction - predicated\n+\n+instruct vreduce_minI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_minI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_minL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  effect(TEMP tmp);\n+  ins_cost(VEC_COST);\n+  format %{ \"vreduce_minL_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    __ reduce_integral_v($dst$$Register, $src1$$Register,\n+                         as_VectorRegister($src2$$reg), as_VectorRegister($tmp$$reg),\n+                         this->ideal_Opcode(), bt, Matcher::vector_length(this, $src2),\n+                         Assembler::v0_t);\n@@ -1277,0 +1847,34 @@\n+\/\/ vector float max reduction - predicated\n+\n+instruct vreduce_maxF_masked(fRegF dst, fRegF src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_maxF_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, false \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_maxD_masked(fRegD dst, fRegD src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MaxReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_maxD_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, false \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1309,0 +1913,34 @@\n+\/\/ vector float min reduction - predicated\n+\n+instruct vreduce_minF_masked(fRegF dst, fRegF src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_minF_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          false \/* is_double *\/, true \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreduce_minD_masked(fRegD dst, fRegD src1, vReg src2, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MinReductionV (Binary src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"vreduce_minD_masked $dst, $src1, $src2, $v0\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ reduce_minmax_fp_v($dst$$FloatRegister,\n+                          $src1$$FloatRegister, as_VectorRegister($src2$$reg),\n+                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n+                          true \/* is_double *\/, true \/* is_min *\/,\n+                          Matcher::vector_length(this, $src2), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1878,0 +2516,67 @@\n+instruct vasrB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RShiftVB (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    if (con >= BitsPerByte) con = BitsPerByte - 1;\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RShiftVS (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    if (con >= BitsPerShort) con = BitsPerShort - 1;\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RShiftVI (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  predicate((n->in(1)->in(2)->in(1)->get_int() & 0x3f) < 32);\n+  match(Set dst_src (RShiftVL (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vasrL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vsra_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1952,1 +2657,76 @@\n-    __ vsrl_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+    __ vsrl_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (URShiftVB (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    if (con >= BitsPerByte) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (URShiftVS (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    if (con >= BitsPerShort) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (URShiftVI (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  predicate((n->in(1)->in(2)->in(1)->get_int() & 0x3f) < 32);\n+  match(Set dst_src (URShiftVL (Binary dst_src (RShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlsrL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vsrl_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n@@ -2016,0 +2796,63 @@\n+instruct vlslB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (LShiftVB (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    if (con >= BitsPerByte) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (LShiftVS (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    if (con >= BitsPerShort) {\n+      __ vxor_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                 as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+      return;\n+    }\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (LShiftVI (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  predicate((n->in(1)->in(2)->in(1)->get_int() & 0x3f) < 32);\n+  match(Set dst_src (LShiftVL (Binary dst_src (LShiftCntV shift)) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vlslL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  ins_encode %{\n+    uint32_t con = (unsigned)$shift$$constant & 0x1f;\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con,\n+               Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2054,0 +2897,26 @@\n+\/\/ vector sqrt - predicated\n+\n+instruct vsqrtF_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (SqrtVF dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vsqrtF_masked $dst_src, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n+    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (SqrtVD dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vsqrtD_masked $dst_src, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2443,0 +3312,2 @@\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmclr_m(as_VectorRegister($dst$$reg));\n@@ -2455,0 +3326,2 @@\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmclr_m(as_VectorRegister($dst$$reg));\n@@ -2466,0 +3339,4 @@\n+    if ($con$$constant != Matcher::vector_length(this)) {\n+      __ vsetvli_helper(bt, Matcher::vector_length(this));\n+      __ vmclr_m(as_VectorRegister($dst$$reg));\n+    }\n@@ -2489,1 +3366,1 @@\n-instruct vmaskAllI(vRegMask dst, iRegI src) %{\n+instruct vmaskAllI(vRegMask dst, iRegIorL2I src) %{\n@@ -2881,1 +3758,1 @@\n-\/\/ vector reinterpret\n+\/\/ ------------------------------ Vector reinterpret ---------------------------\n@@ -2954,1 +3831,449 @@\n-    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($shuffle$$reg));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                   as_VectorRegister($shuffle$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rearrange_masked(vReg dst, vReg src, vReg shuffle, vRegMask_V0 v0) %{\n+  match(Set dst (VectorRearrange (Binary src shuffle) v0));\n+  effect(TEMP_DEF dst);\n+  format %{ \"rearrange_masked $dst, $src, $shuffle, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                   as_VectorRegister($shuffle$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector extract ---------------------------------\n+\n+instruct extract(iRegINoSp dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractB src idx));\n+  match(Set dst (ExtractS src idx));\n+  match(Set dst (ExtractI src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extract $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_v($dst$$Register, as_VectorRegister($src$$reg),\n+                 Matcher::vector_element_basic_type(this, $src), (int)($idx$$constant),\n+                 as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractL src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractL $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_v($dst$$Register, as_VectorRegister($src$$reg), T_LONG,\n+                 (int)($idx$$constant), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct extractF(fRegF dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractF src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractF $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_fp_v($dst$$FloatRegister, as_VectorRegister($src$$reg), T_FLOAT,\n+                    (int)($idx$$constant), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractD(fRegD dst, vReg src, immI idx, vReg tmp)\n+%{\n+  match(Set dst (ExtractD src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractD $dst, $src, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ extract_fp_v($dst$$FloatRegister, as_VectorRegister($src$$reg), T_DOUBLE,\n+                    (int)($idx$$constant), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Compress\/Expand Operations -------------------\n+\n+instruct mcompress(vRegMask dst, vRegMask src, iRegLNoSp tmp) %{\n+  match(Set dst (CompressM src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"mcompress $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmclr_m(as_VectorRegister($dst$$reg));\n+    __ vcpop_m($tmp$$Register, as_VectorRegister($src$$reg));\n+    __ vsetvli(t0, $tmp$$Register, sew);\n+    __ vmset_m(as_VectorRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, vRegMask_V0 v0) %{\n+  match(Set dst (CompressV src v0));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcompress $dst, $src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vcompress_vm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                    as_VectorRegister($v0$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst (ExpandV src v0));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vexpand $dst, $src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ viota_m(as_VectorRegister($tmp$$reg), as_VectorRegister($v0$$reg));\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                   as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+\n+instruct gather_load(vReg dst, indirect mem, vReg idx) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load $dst, $mem, $idx\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vluxei32_v(as_VectorRegister($dst$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($dst$$reg));\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_masked(vReg dst, indirect mem, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx v0)));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"gather_load_masked $dst, $mem, $idx, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vxor_vv(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg),\n+               as_VectorRegister($dst$$reg));\n+    __ vluxei32_v(as_VectorRegister($dst$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------\n+\n+instruct scatter_store(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_store $mem, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsuxei32_v(as_VectorRegister($src$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_store_masked(indirect mem, vReg src, vReg idx, vRegMask_V0 v0, vReg tmp) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4 ||\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx v0))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_store_masked $mem, $idx, $src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsuxei32_v(as_VectorRegister($src$$reg), as_Register($mem$$base),\n+                  as_VectorRegister($tmp$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Populate Index to a Vector -------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, iRegIorL2I src2, vReg tmp) %{\n+  match(Set dst (PopulateIndex src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"populateindex $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($src1$$reg));\n+    __ vid_v(as_VectorRegister($tmp$$reg));\n+    __ vmacc_vx(as_VectorRegister($dst$$reg), as_Register($src2$$reg), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector insert --------------------------------\n+\n+\/\/ BYTE, SHORT, INT\n+\n+instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index(vReg dst, vReg src, iRegIorL2I val, iRegIorL2I idx, vReg tmp, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP v0);\n+  format %{ \"insertI_index $dst, $src, $val, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp$$reg));\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct insertL_index_lt32(vReg dst, vReg src, iRegL val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_LONG));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertL_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL_index(vReg dst, vReg src, iRegL val, iRegIorL2I idx, vReg tmp, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_LONG));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP v0);\n+  format %{ \"insertL_index $dst, $src, $val, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp$$reg));\n+    __ vmerge_vxm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct insertF_index_lt32(vReg dst, vReg src, fRegF val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_FLOAT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertF_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index(vReg dst, vReg src, fRegF val, iRegIorL2I idx, vReg tmp, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_FLOAT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP v0);\n+  format %{ \"insertF_index $dst, $src, $val, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp$$reg));\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct insertD_index_lt32(vReg dst, vReg src, fRegD val, immI idx, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_DOUBLE));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP v0);\n+  format %{ \"insertD_index_lt32 $dst, $src, $val, $idx\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vadd_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), -16);\n+    __ vmseq_vi(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), (int)($idx$$constant) - 16);\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_index(vReg dst, vReg src, fRegD val, iRegIorL2I idx, vReg tmp, vRegMask_V0 v0) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_DOUBLE));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP v0);\n+  format %{ \"insertD_index $dst, $src, $val, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    __ vid_v(as_VectorRegister($v0$$reg));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), $idx$$Register);\n+    __ vmseq_vv(as_VectorRegister($v0$$reg), as_VectorRegister($v0$$reg), as_VectorRegister($tmp$$reg));\n+    __ vfmerge_vfm(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask reductions -----------------------\n+\n+\/\/ true count\n+\n+instruct vmask_truecount(iRegINoSp dst, vRegMask src) %{\n+  match(Set dst (VectorMaskTrueCount src));\n+  format %{ \"vmask_truecount $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vcpop_m($dst$$Register, as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ first true\n+\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n+\n+instruct vmask_firsttrue(iRegINoSp dst, vRegMask src, vRegMask tmp) %{\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this, $src));\n+    __ vmsbf_m(as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg));\n+    __ vcpop_m($dst$$Register, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ last true\n+\n+\/\/ Return the index of the first last lane that is set, or -1 if none of\n+\/\/ them are set.\n+\n+instruct vmask_lasttrue(iRegINoSp dst, vRegMask src) %{\n+  match(Set dst (VectorMaskLastTrue src));\n+  format %{ \"vmask_lasttrue $dst, $src\" %}\n+  ins_encode %{\n+    uint vector_length = Matcher::vector_length(this, $src);\n+    assert(UseZbb && vector_length <= XLEN, \"precondition\");\n+    __ vsetvli_helper(T_LONG, 1);\n+    __ vmv_x_s($dst$$Register, as_VectorRegister($src$$reg));\n+    if (XLEN != vector_length) {\n+      __ slli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+      __ srli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+    }\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ mv(t0, XLEN - 1);\n+    __ sub($dst$$Register, t0, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ tolong\n+\n+instruct vmask_tolong(iRegLNoSp dst, vRegMask src) %{\n+  match(Set dst (VectorMaskToLong src));\n+  format %{ \"vmask_tolong $dst, $src\" %}\n+  ins_encode %{\n+    uint vector_length = Matcher::vector_length(this, $src);\n+    assert(vector_length <= XLEN, \"precondition\");\n+    __ vsetvli_helper(T_LONG, 1);\n+    __ vmv_x_s($dst$$Register, as_VectorRegister($src$$reg));\n+    if (XLEN != vector_length) {\n+      __ slli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+      __ srli($dst$$Register, $dst$$Register, XLEN - vector_length);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ fromlong\n+\n+instruct vmask_fromlong(vRegMask dst, iRegL src) %{\n+  match(Set dst (VectorLongToMask src));\n+  format %{ \"vmask_fromlong $dst, $src\" %}\n+  ins_encode %{\n+    assert(Matcher::vector_length(this) <= XLEN, \"precondition\");\n+    __ vsetvli_helper(T_LONG, 1);\n+    __ vmv_s_x(as_VectorRegister($dst$$reg), $src$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":1434,"deletions":109,"binary":false,"changes":1543,"status":"modified"},{"patch":"@@ -1872,1 +1872,1 @@\n-  __ sd(zr, Address(x12, JNIHandleBlock::top_offset_in_bytes()));\n+  __ sd(zr, Address(x12, JNIHandleBlock::top_offset()));\n@@ -2281,1 +2281,1 @@\n-  __ lwu(xcpool, Address(x15, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+  __ lwu(xcpool, Address(x15, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -2324,1 +2324,1 @@\n-  __ lwu(x12, Address(x15, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n+  __ lwu(x12, Address(x15, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n@@ -2336,1 +2336,1 @@\n-  __ lwu(x9, Address(x15, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ lwu(x9, Address(x15, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -2340,1 +2340,1 @@\n-  __ ld(x12, Address(x15, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+  __ ld(x12, Address(x15, Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2343,1 +2343,1 @@\n-  __ ld(x14, Address(x15, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ ld(x14, Address(x15, Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -2346,1 +2346,1 @@\n-  __ lwu(x13, Address(x15, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+  __ lwu(x13, Address(x15, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -2358,1 +2358,1 @@\n-                     caller_adjustment_offset_in_bytes()));\n+                     caller_adjustment_offset()));\n@@ -2524,1 +2524,1 @@\n-    __ lwu(t0, Address(x14, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+    __ lwu(t0, Address(x14, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -2544,1 +2544,1 @@\n-                      size_of_deoptimized_frame_offset_in_bytes()));\n+                      size_of_deoptimized_frame_offset()));\n@@ -2558,1 +2558,1 @@\n-                      total_frame_sizes_offset_in_bytes()));\n+                      total_frame_sizes_offset()));\n@@ -2564,1 +2564,1 @@\n-                     Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2569,1 +2569,1 @@\n-                     frame_sizes_offset_in_bytes()));\n+                     frame_sizes_offset()));\n@@ -2574,1 +2574,1 @@\n-                      number_of_frames_offset_in_bytes())); \/\/ (int)\n+                      number_of_frames_offset())); \/\/ (int)\n@@ -2585,1 +2585,1 @@\n-                      caller_adjustment_offset_in_bytes())); \/\/ (int)\n+                      caller_adjustment_offset())); \/\/ (int)\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  __ sd(x10, Address(esp, BasicObjectLock::obj_offset_in_bytes()));\n+  __ sd(x10, Address(esp, BasicObjectLock::obj_offset()));\n@@ -761,1 +761,1 @@\n-  __ ld(xcpool, Address(xcpool, ConstantPool::cache_offset_in_bytes()));\n+  __ ld(xcpool, Address(xcpool, ConstantPool::cache_offset()));\n@@ -1214,1 +1214,1 @@\n-  __ sd(zr, Address(t, JNIHandleBlock::top_offset_in_bytes()));\n+  __ sd(zr, Address(t, JNIHandleBlock::top_offset()));\n@@ -1289,1 +1289,1 @@\n-      __ ld(t, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+      __ ld(t, Address(c_rarg1, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3761,1 +3761,1 @@\n-     __ ld(t0, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));\n+     __ ld(t0, Address(c_rarg3, BasicObjectLock::obj_offset()));\n@@ -3818,1 +3818,1 @@\n-   __ sd(x10, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+   __ sd(x10, Address(c_rarg1, BasicObjectLock::obj_offset()));\n@@ -3855,1 +3855,1 @@\n-    __ ld(t0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));\n+    __ ld(t0, Address(c_rarg1, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  z_stg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  z_stg(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -161,1 +161,1 @@\n-  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -394,2 +394,2 @@\n-  z_lg(result, ConstantPool::cache_offset_in_bytes(), result);\n-  z_lg(result, ConstantPoolCache::resolved_references_offset_in_bytes(), result);\n+  z_lg(result, in_bytes(ConstantPool::cache_offset()), result);\n+  z_lg(result, in_bytes(ConstantPoolCache::resolved_references_offset()), result);\n@@ -415,1 +415,1 @@\n-  z_lg(iklass, Address(cpool, ConstantPool::resolved_klasses_offset_in_bytes())); \/\/ iklass = cpool->_resolved_klasses\n+  z_lg(iklass, Address(cpool, ConstantPool::resolved_klasses_offset())); \/\/ iklass = cpool->_resolved_klasses\n@@ -757,1 +757,1 @@\n-  mem2reg_opt(Rdst, Address(Rdst, ConstantPool::cache_offset_in_bytes()));\n+  mem2reg_opt(Rdst, Address(Rdst, ConstantPool::cache_offset()));\n@@ -762,1 +762,1 @@\n-  mem2reg_opt(Rtags, Address(Rcpool, ConstantPool::tags_offset_in_bytes()));\n+  mem2reg_opt(Rtags, Address(Rcpool, ConstantPool::tags_offset()));\n@@ -813,1 +813,1 @@\n-  z_lg(Z_ARG3, Address(Z_ARG2, BasicObjectLock::obj_offset_in_bytes()));\n+  z_lg(Z_ARG3, Address(Z_ARG2, BasicObjectLock::obj_offset()));\n@@ -880,1 +880,1 @@\n-    load_and_test_long(Z_R0_scratch, Address(R_current_monitor, BasicObjectLock::obj_offset_in_bytes()));\n+    load_and_test_long(Z_R0_scratch, Address(R_current_monitor, BasicObjectLock::obj_offset()));\n@@ -1028,1 +1028,1 @@\n-  z_stg(displaced_header, BasicObjectLock::lock_offset_in_bytes() +\n+  z_stg(displaced_header, in_bytes(BasicObjectLock::lock_offset()) +\n@@ -1062,1 +1062,1 @@\n-  z_stg(Z_R0\/*==0!*\/, BasicObjectLock::lock_offset_in_bytes() +\n+  z_stg(Z_R0\/*==0!*\/, in_bytes(BasicObjectLock::lock_offset()) +\n@@ -1110,1 +1110,1 @@\n-  Address obj_entry(monitor, BasicObjectLock::obj_offset_in_bytes());\n+  Address obj_entry(monitor, BasicObjectLock::obj_offset());\n@@ -1131,1 +1131,1 @@\n-                                     Address(monitor, BasicObjectLock::lock_offset_in_bytes() +\n+                                     Address(monitor, in_bytes(BasicObjectLock::lock_offset()) +\n@@ -1813,1 +1813,1 @@\n-        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n+        z_cli(in_bytes(Method::intrinsic_id_offset()), tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n@@ -1816,1 +1816,1 @@\n-        z_lh(tmp, Method::intrinsic_id_offset_in_bytes(), Z_R0, tmp);\n+        z_lh(tmp, in_bytes(Method::intrinsic_id_offset()), Z_R0, tmp);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2769,2 +2769,0 @@\n-  const int vtable_base_offset = in_bytes(Klass::vtable_start_offset());\n-\n@@ -2772,1 +2770,1 @@\n-                     vtable_base_offset + itableOffsetEntry::interface_offset_in_bytes(),\n+                     in_bytes(Klass::vtable_start_offset() + itableOffsetEntry::interface_offset()),\n@@ -2792,2 +2790,2 @@\n-    const int vtable_offset_offset = (itableOffsetEntry::offset_offset_in_bytes() -\n-                                      itableOffsetEntry::interface_offset_in_bytes()) -\n+    const int vtable_offset_offset = in_bytes(itableOffsetEntry::offset_offset() -\n+                                              itableOffsetEntry::interface_offset()) -\n@@ -2801,1 +2799,1 @@\n-    int method_offset = itableMethodEntry::method_offset_in_bytes();\n+    int method_offset = in_bytes(itableMethodEntry::method_offset());\n@@ -2841,1 +2839,1 @@\n-                              vtableEntry::method_offset_in_bytes());\n+                              in_bytes(vtableEntry::method_offset()));\n@@ -2848,1 +2846,1 @@\n-                               base + vtableEntry::method_offset_in_bytes());\n+                               base + in_bytes(vtableEntry::method_offset()));\n@@ -4214,1 +4212,1 @@\n-  mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset_in_bytes()));\n+  mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset()));\n@@ -4222,1 +4220,1 @@\n-  mem2reg_opt(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes()));\n+  mem2reg_opt(holder, Address(holder, ConstantPool::pool_holder_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-      __ z_cli(Address(Z_method, Method::intrinsic_id_offset_in_bytes()), (int)iid);\n+      __ z_cli(Address(Z_method, Method::intrinsic_id_offset()), (int)iid);\n@@ -282,1 +282,1 @@\n-      __ z_lh(Z_R0_scratch, Address(Z_method, Method::intrinsic_id_offset_in_bytes()));\n+      __ z_lh(Z_R0_scratch, Address(Z_method, Method::intrinsic_id_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2194,1 +2194,1 @@\n-      int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();\n+      int v_off        = entry_offset + in_bytes(vtableEntry::method_offset());\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1989,1 +1989,1 @@\n-  __ clear_mem(Address(Z_R1_scratch, JNIHandleBlock::top_offset_in_bytes()), 4);\n+  __ clear_mem(Address(Z_R1_scratch, JNIHandleBlock::top_offset()), 4);\n@@ -2321,2 +2321,2 @@\n-    const int holder_klass_offset    = CompiledICHolder::holder_klass_offset();\n-    const int holder_metadata_offset = CompiledICHolder::holder_metadata_offset();\n+    const int holder_klass_offset    = in_bytes(CompiledICHolder::holder_klass_offset());\n+    const int holder_metadata_offset = in_bytes(CompiledICHolder::holder_metadata_offset());\n@@ -2454,1 +2454,1 @@\n-           Address(unroll_block_reg, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+           Address(unroll_block_reg, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -2456,1 +2456,1 @@\n-          Address(unroll_block_reg, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+          Address(unroll_block_reg, Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2458,1 +2458,1 @@\n-          Address(unroll_block_reg, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+          Address(unroll_block_reg, Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -2468,1 +2468,1 @@\n-           Address(unroll_block_reg, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));\n+           Address(unroll_block_reg, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n@@ -2648,1 +2648,1 @@\n-  __ z_llgf(exec_mode_reg, Address(unroll_block_reg, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+  __ z_llgf(exec_mode_reg, Address(unroll_block_reg, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -2781,1 +2781,1 @@\n-  const int unpack_kind_byte_offset = Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()\n+  const int unpack_kind_byte_offset = in_bytes(Deoptimization::UnrollBlock::unpack_kind_offset())\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -923,1 +923,1 @@\n-  __ reg2mem_opt(object, Address(Z_tmp_1, BasicObjectLock::obj_offset_in_bytes()));\n+  __ reg2mem_opt(object, Address(Z_tmp_1, BasicObjectLock::obj_offset()));\n@@ -1121,1 +1121,1 @@\n-  __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstantPool::cache_offset_in_bytes()));\n+  __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstantPool::cache_offset()));\n@@ -1604,1 +1604,1 @@\n-  __ clear_mem(Address(Z_R1, JNIHandleBlock::top_offset_in_bytes()), 4);\n+  __ clear_mem(Address(Z_R1, JNIHandleBlock::top_offset()), 4);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1979,1 +1979,1 @@\n-    __ z_cliy(nmethod::state_offset(), Z_RET, nmethod::in_use);\n+    __ z_cliy(in_bytes(nmethod::state_offset()), Z_RET, nmethod::in_use);\n@@ -3558,1 +3558,1 @@\n-                         Klass::vtable_start_offset() + in_ByteSize(vtableEntry::method_offset_in_bytes())));\n+                         Klass::vtable_start_offset() + vtableEntry::method_offset()));\n@@ -4181,1 +4181,1 @@\n-    __ load_and_test_long(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));\n+    __ load_and_test_long(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset()));\n@@ -4213,1 +4213,1 @@\n-  __ z_stg(Z_tos, BasicObjectLock::obj_offset_in_bytes(), Rfree_slot);\n+  __ z_stg(Z_tos, in_bytes(BasicObjectLock::obj_offset()), Rfree_slot);\n@@ -4269,1 +4269,1 @@\n-    __ z_lg(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));\n+    __ z_lg(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();\n+  int v_off        = entry_offset + in_bytes(vtableEntry::method_offset());\n","filename":"src\/hotspot\/cpu\/s390\/vtableStubs_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  movptr(Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()), obj);\n+  movptr(Address(disp_hdr, BasicObjectLock::obj_offset()), obj);\n@@ -132,1 +132,1 @@\n-  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), NoRTM);\n+    orl(Address(tmpReg, MethodData::rtm_state_offset()), NoRTM);\n@@ -249,1 +249,1 @@\n-    orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), UseRTM);\n+    orl(Address(tmpReg, MethodData::rtm_state_offset()), UseRTM);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n+      cmpw(Address(tmp, Method::intrinsic_id_offset()), static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n@@ -513,2 +513,2 @@\n-  movptr(result, Address(result, ConstantPool::cache_offset_in_bytes()));\n-  movptr(result, Address(result, ConstantPoolCache::resolved_references_offset_in_bytes()));\n+  movptr(result, Address(result, ConstantPool::cache_offset()));\n+  movptr(result, Address(result, ConstantPoolCache::resolved_references_offset()));\n@@ -529,1 +529,1 @@\n-  movptr(resolved_klasses, Address(cpool, ConstantPool::resolved_klasses_offset_in_bytes()));\n+  movptr(resolved_klasses, Address(cpool, ConstantPool::resolved_klasses_offset()));\n@@ -1041,1 +1041,1 @@\n-  movptr(rax, Address(robj, BasicObjectLock::obj_offset_in_bytes()));\n+  movptr(rax, Address(robj, BasicObjectLock::obj_offset()));\n@@ -1124,1 +1124,1 @@\n-    cmpptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n+    cmpptr(Address(rmon, BasicObjectLock::obj_offset()), NULL_WORD);\n@@ -1211,2 +1211,2 @@\n-    const int obj_offset = BasicObjectLock::obj_offset_in_bytes();\n-    const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();\n+    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n@@ -1341,1 +1341,1 @@\n-      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n+      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n@@ -1345,1 +1345,1 @@\n-    movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+    movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -1348,1 +1348,1 @@\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n+    movptr(Address(lock_reg, BasicObjectLock::obj_offset()), NULL_WORD);\n@@ -1391,1 +1391,1 @@\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), obj_reg); \/\/ restore obj\n+    movptr(Address(lock_reg, BasicObjectLock::obj_offset()), obj_reg); \/\/ restore obj\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    movptr(reg, Address(reg, ConstantPool::cache_offset_in_bytes()));\n+    movptr(reg, Address(reg, ConstantPool::cache_offset()));\n@@ -103,1 +103,1 @@\n-    movptr(tags, Address(cpool, ConstantPool::tags_offset_in_bytes()));\n+    movptr(tags, Address(cpool, ConstantPool::tags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4247,1 +4247,1 @@\n-  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n@@ -4272,1 +4272,1 @@\n-    movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+    movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset()));\n@@ -4298,1 +4298,1 @@\n-    movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));\n+    movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset()));\n@@ -4308,1 +4308,1 @@\n-  const int base = in_bytes(Klass::vtable_start_offset());\n+  const ByteSize base = Klass::vtable_start_offset();\n@@ -4312,1 +4312,1 @@\n-                            base + vtableEntry::method_offset_in_bytes());\n+                            base + vtableEntry::method_offset());\n@@ -5119,1 +5119,1 @@\n-  movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); \/\/ InstanceKlass*\n+  movptr(holder, Address(holder, ConstantPool::pool_holder_offset()));          \/\/ InstanceKlass*\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-    __ cmpw(Address(rbx_method, Method::intrinsic_id_offset_in_bytes()), (int) iid);\n+    __ cmpw(Address(rbx_method, Method::intrinsic_id_offset()), (int) iid);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1921,1 +1921,1 @@\n-  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n+  __ movl(Address(rcx, JNIHandleBlock::top_offset()), NULL_WORD);\n@@ -2245,1 +2245,1 @@\n-  Address unpack_kind(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes());\n+  Address unpack_kind(rdi, Deoptimization::UnrollBlock::unpack_kind_offset());\n@@ -2291,1 +2291,1 @@\n-  __ addptr(rsp, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n+  __ addptr(rsp, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n@@ -2297,1 +2297,1 @@\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n@@ -2303,1 +2303,1 @@\n-  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -2308,1 +2308,1 @@\n-  __ movptr(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+  __ movptr(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2313,1 +2313,1 @@\n-  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -2315,1 +2315,1 @@\n-  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset_in_bytes());\n+  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset());\n@@ -2317,1 +2317,1 @@\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -2325,1 +2325,1 @@\n-  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset_in_bytes());\n+  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset());\n@@ -2327,1 +2327,1 @@\n-  __ movl2ptr(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));\n+  __ movl2ptr(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n@@ -2495,1 +2495,1 @@\n-    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()),\n+    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n@@ -2514,1 +2514,1 @@\n-  __ movl2ptr(rcx, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n+  __ movl2ptr(rcx, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n@@ -2521,1 +2521,1 @@\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n@@ -2527,1 +2527,1 @@\n-  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -2532,1 +2532,1 @@\n-  __ movl(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+  __ movl(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2537,1 +2537,1 @@\n-  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -2539,1 +2539,1 @@\n-  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset_in_bytes());\n+  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset());\n@@ -2541,1 +2541,1 @@\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -2549,1 +2549,1 @@\n-  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset_in_bytes());\n+  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset());\n@@ -2551,1 +2551,1 @@\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2372,1 +2372,1 @@\n-  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n+  __ movl(Address(rcx, JNIHandleBlock::top_offset()), NULL_WORD);\n@@ -2731,1 +2731,1 @@\n-  __ movl(r14, Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));\n+  __ movl(r14, Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()));\n@@ -2770,1 +2770,1 @@\n-  __ movl(rcx, Address(rdi, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));\n+  __ movl(rcx, Address(rdi, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n@@ -2777,1 +2777,1 @@\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n@@ -2783,1 +2783,1 @@\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -2788,1 +2788,1 @@\n-  __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+  __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2794,1 +2794,1 @@\n-  __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));\n+  __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock::frame_sizes_offset()));\n@@ -2797,1 +2797,1 @@\n-  __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));\n+  __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset()));\n@@ -2809,1 +2809,1 @@\n-                       caller_adjustment_offset_in_bytes()));\n+                       caller_adjustment_offset()));\n@@ -2950,1 +2950,1 @@\n-    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()),\n+    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n@@ -2971,1 +2971,1 @@\n-                       size_of_deoptimized_frame_offset_in_bytes()));\n+                       size_of_deoptimized_frame_offset()));\n@@ -2978,1 +2978,1 @@\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n@@ -2984,1 +2984,1 @@\n-  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n@@ -2989,1 +2989,1 @@\n-  __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));\n+  __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset()));\n@@ -2995,1 +2995,1 @@\n-  __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock:: frame_sizes_offset_in_bytes()));\n+  __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock:: frame_sizes_offset()));\n@@ -2998,1 +2998,1 @@\n-  __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock:: number_of_frames_offset_in_bytes())); \/\/ (int)\n+  __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock:: number_of_frames_offset())); \/\/ (int)\n@@ -3008,1 +3008,1 @@\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock:: caller_adjustment_offset_in_bytes())); \/\/ (int)\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock:: caller_adjustment_offset())); \/\/ (int)\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-  __ movptr(Address(rsp, BasicObjectLock::obj_offset_in_bytes()), rax);\n+  __ movptr(Address(rsp, BasicObjectLock::obj_offset()), rax);\n@@ -650,1 +650,1 @@\n-  __ movptr(rdx, Address(rdx, ConstantPool::cache_offset_in_bytes()));\n+  __ movptr(rdx, Address(rdx, ConstantPool::cache_offset()));\n@@ -1157,1 +1157,1 @@\n-  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n+  __ movl(Address(t, JNIHandleBlock::top_offset()), NULL_WORD);\n@@ -1251,1 +1251,1 @@\n-      __ movptr(t, Address(regmon, BasicObjectLock::obj_offset_in_bytes()));\n+      __ movptr(t, Address(regmon, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4344,1 +4344,1 @@\n-    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n+    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset()), NULL_WORD);\n@@ -4348,1 +4348,1 @@\n-    __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));\n+    __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset()));\n@@ -4397,1 +4397,1 @@\n-  __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);\n+  __ movptr(Address(rmon, BasicObjectLock::obj_offset()), rax);\n@@ -4437,1 +4437,1 @@\n-    __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));\n+    __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-    if (offset == BasicObjectLock::obj_offset_in_bytes())\n+    if (offset == in_bytes(BasicObjectLock::obj_offset()))\n@@ -397,1 +397,1 @@\n-    else if (offset ==  BasicObjectLock::lock_offset_in_bytes())\n+    else if (offset == in_bytes(BasicObjectLock::lock_offset()))\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1827,1 +1827,10 @@\n-static bool _print_ascii_file(const char* filename, outputStream* st, const char* hdr = nullptr) {\n+static unsigned count_newlines(const char* s) {\n+  unsigned n = 0;\n+  for (const char* s2 = strchr(s, '\\n');\n+       s2 != nullptr; s2 = strchr(s2 + 1, '\\n')) {\n+    n++;\n+  }\n+  return n;\n+}\n+\n+static bool _print_ascii_file(const char* filename, outputStream* st, unsigned* num_lines = nullptr, const char* hdr = nullptr) {\n@@ -1840,0 +1849,1 @@\n+  unsigned lines = 0;\n@@ -1842,0 +1852,8 @@\n+    \/\/ count newlines\n+    if (num_lines != nullptr) {\n+      lines += count_newlines(buf);\n+    }\n+  }\n+\n+  if (num_lines != nullptr) {\n+    (*num_lines) = lines;\n@@ -1863,2 +1881,2 @@\n-\n-  if (!_print_ascii_file(fname, st)) {\n+  unsigned num = 0;\n+  if (!_print_ascii_file(fname, st, &num)) {\n@@ -1866,0 +1884,2 @@\n+  } else {\n+    st->print_cr(\"Total number of mappings: %u\", num);\n@@ -2213,1 +2233,1 @@\n-  return _print_ascii_file(\"\/etc\/ld.so.preload\", st, \"\/etc\/ld.so.preload:\");\n+  return _print_ascii_file(\"\/etc\/ld.so.preload\", st, nullptr, \"\/etc\/ld.so.preload:\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,0 +405,7 @@\n+  \/\/ A discrete resource is a simple definition of a resource, while compound resources can be composed of multiple resources.\n+  \/\/ A discrete resource will always have a power of two mask, so this check succeeds in that case.\n+  \/\/ As compound resources have different masks added together, this check will not succeed there.\n+  bool is_discrete() const {\n+    return (_resmask & (_resmask - 1)) == 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,0 +275,1 @@\n+  const char* resource;\n@@ -277,10 +278,13 @@\n-  for (i = 0; i < pipeline->_rescount; i++) {\n-    if (res_stages[i] == 0) {\n-      if (max_stage < 9)\n-        max_stage = 9;\n-    }\n-    else {\n-      int stagelen = (int)strlen(pipeline->_stages.name(res_stages[i]-1));\n-      if (max_stage < stagelen)\n-        max_stage = stagelen;\n-    }\n+  i = 0;\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+    if (pipeline->_resdict[resource]->is_resource()->is_discrete()) {\n+      if (res_stages[i] == 0) {\n+        if (max_stage < 9) {\n+          max_stage = 9;\n+        }\n+      } else {\n+        int stagelen = (int)strlen(pipeline->_stages.name(res_stages[i]-1));\n+        if (max_stage < stagelen) {\n+          max_stage = stagelen;\n+        }\n+      }\n@@ -288,1 +292,3 @@\n-    commentlen += (int)strlen(pipeline->_reslist.name(i));\n+      commentlen += (int)strlen(resource);\n+      i++;\n+    }\n@@ -298,8 +304,10 @@\n-  for (i = 0; i < pipeline->_rescount; i++) {\n-    const char * const resname =\n-      res_stages[i] == 0 ? \"undefined\" : pipeline->_stages.name(res_stages[i]-1);\n-\n-    templen += snprintf_checked(&resource_stages[templen], resource_stages_size - templen, \"  stage_%s%-*s \/\/ %s\\n\",\n-      resname, max_stage - (int)strlen(resname) + 1,\n-      (i < pipeline->_rescount-1) ? \",\" : \"\",\n-      pipeline->_reslist.name(i));\n+  i = 0;\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+    if (pipeline->_resdict[resource]->is_resource()->is_discrete()) {\n+      const char* const resname = res_stages[i] == 0 ? \"undefined\" : pipeline->_stages.name(res_stages[i] - 1);\n+\n+      templen += snprintf_checked(&resource_stages[templen], resource_stages_size - templen,\"  stage_%s%-*s \/\/ %s\\n\",\n+          resname, max_stage - (int)strlen(resname) + 1,\n+          (i < pipeline->_rescount - 1) ? \",\" : \"\", resource);\n+      i++;\n+    }\n@@ -358,7 +366,16 @@\n-  for (i = 0; i < pipeline->_rescount; i++) {\n-    if (max_cycles < res_cycles[i])\n-      max_cycles = res_cycles[i];\n-    templen = snprintf_checked(temp, sizeof(temp), \"%d\", res_cycles[i]);\n-    if (cyclelen < templen)\n-      cyclelen = templen;\n-    commentlen += (int)strlen(pipeline->_reslist.name(i));\n+  const char* resource;\n+  i = 0;\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+    if (pipeline->_resdict[resource]->is_resource()->is_discrete()) {\n+      if (max_cycles < res_cycles[i]) {\n+        max_cycles = res_cycles[i];\n+      }\n+\n+      templen = snprintf_checked(temp, sizeof(temp), \"%d\", res_cycles[i]);\n+      if (cyclelen < templen) {\n+        cyclelen = templen;\n+      }\n+\n+      commentlen += (int)strlen(resource);\n+      i++;\n+    }\n@@ -375,3 +392,7 @@\n-  for (i = 0; i < pipeline->_rescount; i++) {\n-    templen += snprintf_checked(&resource_cycles[templen], resource_cycles_size - templen, \"  %*d%c \/\/ %s\\n\",\n-      cyclelen, res_cycles[i], (i < pipeline->_rescount-1) ? ',' : ' ', pipeline->_reslist.name(i));\n+  i = 0;\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+    if (pipeline->_resdict[resource]->is_resource()->is_discrete()) {\n+      templen += snprintf_checked(&resource_cycles[templen], resource_cycles_size - templen, \"  %*d%c \/\/ %s\\n\",\n+      cyclelen, res_cycles[i], (i < pipeline->_rescount-1) ? ',' : ' ', resource);\n+      i++;\n+    }\n@@ -985,2 +1006,9 @@\n-  for (i = 0; i < _pipeline->_rescount; i++)\n-    fprintf(fp_cpp, \" \\\"%s\\\"%c\", _pipeline->_reslist.name(i), i < _pipeline->_rescount-1 ? ',' : ' ');\n+  \/\/ Don't add compound resources to the list of resource names\n+  const char* resource;\n+  i = 0;\n+  for (_pipeline->_reslist.reset(); (resource = _pipeline->_reslist.iter()) != NULL;) {\n+    if (_pipeline->_resdict[resource]->is_resource()->is_discrete()) {\n+      fprintf(fp_cpp, \" \\\"%s\\\"%c\", resource, i < _pipeline->_rescount - 1 ? ',' : ' ');\n+      i++;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":60,"deletions":32,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -828,3 +828,2 @@\n-  for ( _pipeline->_reslist.reset(); (resource = _pipeline->_reslist.iter()) != NULL; ) {\n-      int mask = _pipeline->_resdict[resource]->is_resource()->mask();\n-      if ((mask & (mask-1)) == 0)\n+  for (_pipeline->_reslist.reset(); (resource = _pipeline->_reslist.iter()) != NULL;) {\n+      if (_pipeline->_resdict[resource]->is_resource()->is_discrete()) {\n@@ -832,0 +831,1 @@\n+      }\n@@ -2233,2 +2233,1 @@\n-      int mask = resform->mask();\n-      if ((mask & (mask-1)) == 0)\n+      if (resform->is_discrete()) {\n@@ -2236,0 +2235,1 @@\n+      }\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- : _output(NULL),\n+ : _output(nullptr),\n@@ -212,1 +212,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -236,1 +236,1 @@\n-  print(\"to_bci %d\", (block->end() == NULL ? -1 : block->end()->printable_bci()));\n+  print(\"to_bci %d\", (block->end() == nullptr ? -1 : block->end()->printable_bci()));\n@@ -248,1 +248,1 @@\n-  if (block->end() != NULL) {\n+  if (block->end() != nullptr) {\n@@ -275,1 +275,1 @@\n-  if (block->dominator() != NULL) {\n+  if (block->dominator() != nullptr) {\n@@ -327,1 +327,1 @@\n-    if (intervals->at(i) != NULL) {\n+    if (intervals->at(i) != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    void block_do(BlockBegin* block) { if (block != NULL) Compilation::current()->cfg_printer_output()->print_block(block); }\n+    void block_do(BlockBegin* block) { if (block != nullptr) Compilation::current()->cfg_printer_output()->print_block(block); }\n@@ -61,1 +61,1 @@\n-  outputStream* output() { assert(_output != NULL, \"\"); return _output; }\n+  outputStream* output() { assert(_output != nullptr, \"\"); return _output; }\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  assert(x != NULL, \"value must exist\");\n+  assert(x != nullptr, \"value must exist\");\n@@ -203,1 +203,1 @@\n-  while (max_distance > 0 && v != NULL && v->as_BlockEnd() == NULL) {\n+  while (max_distance > 0 && v != nullptr && v->as_BlockEnd() == nullptr) {\n@@ -207,1 +207,1 @@\n-  return v == NULL;\n+  return v == nullptr;\n@@ -216,1 +216,1 @@\n-    Value value = NULL;\n+    Value value = nullptr;\n@@ -225,1 +225,1 @@\n-    if (value != NULL && in_current_block(conv)) {\n+    if (value != nullptr && in_current_block(conv)) {\n@@ -239,1 +239,1 @@\n-  if ((na = x->array()->as_NewArray()) != NULL) {\n+  if ((na = x->array()->as_NewArray()) != nullptr) {\n@@ -246,3 +246,3 @@\n-    if (na->length() != NULL &&\n-        (length = na->length()->as_Constant()) != NULL) {\n-      assert(length->type()->as_IntConstant() != NULL, \"array length must be integer\");\n+    if (na->length() != nullptr &&\n+        (length = na->length()->as_Constant()) != nullptr) {\n+      assert(length->type()->as_IntConstant() != nullptr, \"array length must be integer\");\n@@ -250,3 +250,3 @@\n-    } else if ((nma = x->array()->as_NewMultiArray()) != NULL &&\n-               (length = nma->dims()->at(0)->as_Constant()) != NULL) {\n-      assert(length->type()->as_IntConstant() != NULL, \"array length must be integer\");\n+    } else if ((nma = x->array()->as_NewMultiArray()) != nullptr &&\n+               (length = nma->dims()->at(0)->as_Constant()) != nullptr) {\n+      assert(length->type()->as_IntConstant() != nullptr, \"array length must be integer\");\n@@ -256,1 +256,1 @@\n-  } else if ((ct = x->array()->as_Constant()) != NULL) {\n+  } else if ((ct = x->array()->as_Constant()) != nullptr) {\n@@ -259,1 +259,1 @@\n-    if (cnst != NULL) {\n+    if (cnst != nullptr) {\n@@ -263,1 +263,1 @@\n-  } else if ((lf = x->array()->as_LoadField()) != NULL) {\n+  } else if ((lf = x->array()->as_LoadField()) != nullptr) {\n@@ -281,1 +281,1 @@\n-  assert(array == NULL || FoldStableValues, \"not enabled\");\n+  assert(array == nullptr || FoldStableValues, \"not enabled\");\n@@ -284,1 +284,1 @@\n-  if (!x->mismatched() && array != NULL && index != NULL) {\n+  if (!x->mismatched() && array != nullptr && index != nullptr) {\n@@ -295,1 +295,1 @@\n-      ValueType* value = NULL;\n+      ValueType* value = nullptr;\n@@ -315,1 +315,1 @@\n-    Value value = NULL;\n+    Value value = nullptr;\n@@ -324,1 +324,1 @@\n-    if (value != NULL && in_current_block(conv)) {\n+    if (value != nullptr && in_current_block(conv)) {\n@@ -482,1 +482,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -491,1 +491,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -500,1 +500,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -509,1 +509,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -520,2 +520,2 @@\n-    if (c != NULL && !c->value()->is_null_object()) {\n-      \/\/ ciInstance::java_mirror_type() returns non-NULL only for Java mirrors\n+    if (c != nullptr && !c->value()->is_null_object()) {\n+      \/\/ ciInstance::java_mirror_type() returns non-null only for Java mirrors\n@@ -543,1 +543,1 @@\n-    if (c != NULL && !c->value()->is_null_object()) {\n+    if (c != nullptr && !c->value()->is_null_object()) {\n@@ -554,1 +554,1 @@\n-    if (c != NULL && !c->value()->is_null_object()) {\n+    if (c != nullptr && !c->value()->is_null_object()) {\n@@ -643,1 +643,1 @@\n-  if (x->obj()->as_NewArray() != NULL || x->obj()->as_NewInstance() != NULL) {\n+  if (x->obj()->as_NewArray() != nullptr || x->obj()->as_NewInstance() != nullptr) {\n@@ -669,1 +669,1 @@\n-    if (klass == NULL) {\n+    if (klass == nullptr) {\n@@ -672,1 +672,1 @@\n-    if (klass != NULL && klass->is_loaded()) {\n+    if (klass != nullptr && klass->is_loaded()) {\n@@ -692,1 +692,1 @@\n-    if (exact != NULL && exact->is_loaded() && (obj->as_NewInstance() || obj->as_NewArray())) {\n+    if (exact != nullptr && exact->is_loaded() && (obj->as_NewInstance() || obj->as_NewArray())) {\n@@ -740,1 +740,1 @@\n-    BlockBegin* sux = NULL;\n+    BlockBegin* sux = nullptr;\n@@ -756,1 +756,1 @@\n-    if (x->x()->as_Constant() != NULL) {\n+    if (x->x()->as_Constant() != nullptr) {\n@@ -761,1 +761,1 @@\n-      if (sux != NULL) {\n+      if (sux != nullptr) {\n@@ -766,1 +766,1 @@\n-  } else if (rt->as_IntConstant() != NULL) {\n+  } else if (rt->as_IntConstant() != nullptr) {\n@@ -769,1 +769,1 @@\n-    if (l->as_CompareOp() != NULL) {\n+    if (l->as_CompareOp() != nullptr) {\n@@ -787,2 +787,2 @@\n-        BlockBegin* tsux = NULL;\n-        BlockBegin* fsux = NULL;\n+        BlockBegin* tsux = nullptr;\n+        BlockBegin* fsux = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  virtual CodeEmitInfo* info() const             { return NULL; }\n+  virtual CodeEmitInfo* info() const             { return nullptr; }\n@@ -173,1 +173,1 @@\n-    assert(info != NULL, \"must have info\");\n+    assert(info != nullptr, \"must have info\");\n@@ -181,1 +181,1 @@\n-    assert(info != NULL, \"must have info\");\n+    assert(info != nullptr, \"must have info\");\n@@ -426,1 +426,1 @@\n-    , _info(NULL)\n+    , _info(nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    _log(NULL), _timer(timer)\n+    _log(nullptr), _timer(timer)\n@@ -88,1 +88,1 @@\n-    if (Compilation::current() != NULL) {\n+    if (Compilation::current() != nullptr) {\n@@ -92,1 +92,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -100,1 +100,1 @@\n-    if (_log != NULL)\n+    if (_log != nullptr)\n@@ -111,1 +111,1 @@\n-  if (_current_instruction != NULL && _last_instruction_printed != _current_instruction) {\n+  if (_current_instruction != nullptr && _last_instruction_printed != _current_instruction) {\n@@ -145,1 +145,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -215,1 +215,1 @@\n-    if (_hir->osr_entry() == NULL) {\n+    if (_hir->osr_entry() == nullptr) {\n@@ -485,1 +485,1 @@\n-  if (log() != NULL) \/\/ Print code cache state into compiler log\n+  if (log() != nullptr) \/\/ Print code cache state into compiler log\n@@ -564,1 +564,1 @@\n-, _hir(NULL)\n+, _hir(nullptr)\n@@ -566,2 +566,2 @@\n-, _frame_map(NULL)\n-, _masm(NULL)\n+, _frame_map(nullptr)\n+, _masm(nullptr)\n@@ -577,3 +577,3 @@\n-, _bailout_msg(NULL)\n-, _exception_info_list(NULL)\n-, _allocator(NULL)\n+, _bailout_msg(nullptr)\n+, _exception_info_list(nullptr)\n+, _allocator(nullptr)\n@@ -584,1 +584,1 @@\n-, _current_instruction(NULL)\n+, _current_instruction(nullptr)\n@@ -586,2 +586,2 @@\n-, _last_instruction_printed(NULL)\n-, _cfg_printer_output(NULL)\n+, _last_instruction_printed(nullptr)\n+, _cfg_printer_output(nullptr)\n@@ -610,1 +610,1 @@\n-    if (md != NULL) {\n+    if (md != nullptr) {\n@@ -620,1 +620,1 @@\n-  _env->set_compiler_data(NULL);\n+  _env->set_compiler_data(nullptr);\n@@ -640,1 +640,1 @@\n-  assert(msg != NULL, \"bailout message must exist\");\n+  assert(msg != nullptr, \"bailout message must exist\");\n@@ -649,1 +649,1 @@\n-  if (type != NULL && type->is_loaded() && type->is_instance_klass()) {\n+  if (type != nullptr && type->is_loaded() && type->is_instance_klass()) {\n@@ -651,1 +651,1 @@\n-    assert(ik->exact_klass() == NULL, \"no cha for final klass\");\n+    assert(ik->exact_klass() == nullptr, \"no cha for final klass\");\n@@ -657,1 +657,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,1 +201,1 @@\n-    guarantee(_cfg_printer_output != NULL, \"CFG printer output not initialized\");\n+    guarantee(_cfg_printer_output != nullptr, \"CFG printer output not initialized\");\n@@ -208,1 +208,1 @@\n-  bool bailed_out() const                        { return _bailout_msg != NULL; }\n+  bool bailed_out() const                        { return _bailout_msg != nullptr; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    if (buffer_blob == NULL) {\n+    if (buffer_blob == nullptr) {\n@@ -86,1 +86,1 @@\n-  assert (CompilerThread::current()->get_buffer_blob() == NULL, \"Should initialize only once\");\n+  assert (CompilerThread::current()->get_buffer_blob() == nullptr, \"Should initialize only once\");\n@@ -91,1 +91,1 @@\n-  if (buffer_blob != NULL) {\n+  if (buffer_blob != nullptr) {\n@@ -247,1 +247,1 @@\n-  assert(buffer_blob != NULL, \"Must exist\");\n+  assert(buffer_blob != nullptr, \"Must exist\");\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  intptr_t out_preserve = SharedRuntime::c_calling_convention(sig_bt, regs, NULL, sizeargs);\n+  intptr_t out_preserve = SharedRuntime::c_calling_convention(sig_bt, regs, nullptr, sizeargs);\n@@ -241,1 +241,1 @@\n-  if (second != NULL) {\n+  if (second != nullptr) {\n@@ -292,1 +292,1 @@\n-  return sp_offset_for_monitor_base(index) + in_ByteSize(BasicObjectLock::lock_offset_in_bytes());;\n+  return sp_offset_for_monitor_base(index) + BasicObjectLock::lock_offset();\n@@ -297,1 +297,1 @@\n-  return sp_offset_for_monitor_base(index) + in_ByteSize(BasicObjectLock::obj_offset_in_bytes());\n+  return sp_offset_for_monitor_base(index) + BasicObjectLock::obj_offset();\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-                            Location* loc, Location* second = NULL) const;\n+                            Location* loc, Location* second = nullptr) const;\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n- , _bci2block(new BlockList(scope->method()->code_size(), NULL))\n+ , _bci2block(new BlockList(scope->method()->code_size(), nullptr))\n@@ -151,2 +151,2 @@\n-  BlockBegin* std_entry = make_block_at(0, NULL);\n-  if (scope()->caller() == NULL) {\n+  BlockBegin* std_entry = make_block_at(0, nullptr);\n+  if (scope()->caller() == nullptr) {\n@@ -156,1 +156,1 @@\n-    BlockBegin* osr_entry = make_block_at(osr_bci, NULL);\n+    BlockBegin* osr_entry = make_block_at(osr_bci, nullptr);\n@@ -165,1 +165,1 @@\n-    BlockBegin* entry = make_block_at(h->handler_bci(), NULL);\n+    BlockBegin* entry = make_block_at(h->handler_bci(), nullptr);\n@@ -176,1 +176,1 @@\n-  if (block == NULL) {\n+  if (block == nullptr) {\n@@ -183,1 +183,1 @@\n-    assert(predecessor == NULL || predecessor->bci() < cur_bci, \"targets for backward branches must already exist\");\n+    assert(predecessor == nullptr || predecessor->bci() < cur_bci, \"targets for backward branches must already exist\");\n@@ -186,1 +186,1 @@\n-  if (predecessor != NULL) {\n+  if (predecessor != nullptr) {\n@@ -218,1 +218,1 @@\n-      assert(entry != NULL && entry == _bci2block->at(h->handler_bci()), \"entry must be set\");\n+      assert(entry != nullptr && entry == _bci2block->at(h->handler_bci()), \"entry must be set\");\n@@ -249,1 +249,1 @@\n-  BlockBegin* current = NULL;\n+  BlockBegin* current = nullptr;\n@@ -266,1 +266,1 @@\n-    assert(current != NULL, \"must have current block\");\n+    assert(current != nullptr, \"must have current block\");\n@@ -310,1 +310,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -333,1 +333,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -338,1 +338,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -343,1 +343,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -348,1 +348,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -353,1 +353,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -364,1 +364,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -376,1 +376,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -579,1 +579,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -586,1 +586,1 @@\n-    _values.at_put_grow(offset, value, NULL);\n+    _values.at_put_grow(offset, value, nullptr);\n@@ -631,1 +631,1 @@\n-        if (buf->at(field) == NULL && is_default_value(value)) {\n+        if (buf->at(field) == nullptr && is_default_value(value)) {\n@@ -638,1 +638,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -643,1 +643,1 @@\n-        _objects.at_put_grow(offset, object, NULL);\n+        _objects.at_put_grow(offset, object, nullptr);\n@@ -695,1 +695,1 @@\n-      Value result = NULL;\n+      Value result = nullptr;\n@@ -699,1 +699,1 @@\n-      } else if (_objects.at_grow(offset, NULL) == object) {\n+      } else if (_objects.at_grow(offset, nullptr) == object) {\n@@ -702,1 +702,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -720,1 +720,1 @@\n-    if (_fields.at_grow(index, NULL) == NULL) {\n+    if (_fields.at_grow(index, nullptr) == nullptr) {\n@@ -754,2 +754,2 @@\n-  , _bci2block(NULL)\n-  , _scope(NULL)\n+  , _bci2block(nullptr)\n+  , _scope(nullptr)\n@@ -757,2 +757,2 @@\n-  , _stream(NULL)\n-  , _work_list(NULL)\n+  , _stream(nullptr)\n+  , _work_list(nullptr)\n@@ -760,1 +760,1 @@\n-  , _continuation(NULL)\n+  , _continuation(nullptr)\n@@ -762,1 +762,1 @@\n-  , _jsr_xhandlers(NULL)\n+  , _jsr_xhandlers(nullptr)\n@@ -764,3 +764,3 @@\n-  , _cleanup_block(NULL)\n-  , _cleanup_return_prev(NULL)\n-  , _cleanup_state(NULL)\n+  , _cleanup_block(nullptr)\n+  , _cleanup_return_prev(nullptr)\n+  , _cleanup_state(nullptr)\n@@ -769,1 +769,1 @@\n-  if (parent != NULL) {\n+  if (parent != nullptr) {\n@@ -795,1 +795,1 @@\n-    if (block != NULL && block == parent()->bci2block()->at(bci)) {\n+    if (block != nullptr && block == parent()->bci2block()->at(bci)) {\n@@ -826,1 +826,1 @@\n-  if (_jsr_xhandlers == NULL) {\n+  if (_jsr_xhandlers == nullptr) {\n@@ -838,1 +838,1 @@\n-  if (parent() != NULL) {\n+  if (parent() != nullptr) {\n@@ -855,1 +855,1 @@\n-  if (_work_list == NULL) {\n+  if (_work_list == nullptr) {\n@@ -900,1 +900,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -907,1 +907,1 @@\n-  return (_work_list == NULL || _work_list->length() == 0);\n+  return (_work_list == nullptr || _work_list->length() == 0);\n@@ -956,1 +956,1 @@\n-    ValueStack* patch_state = NULL;\n+    ValueStack* patch_state = nullptr;\n@@ -989,1 +989,1 @@\n-    if (patch_state != NULL) {\n+    if (patch_state != nullptr) {\n@@ -1000,1 +1000,1 @@\n-    if (patch_state != NULL) {\n+    if (patch_state != nullptr) {\n@@ -1024,1 +1024,1 @@\n-  assert(x != NULL && !x->type()->is_illegal(), \"access of illegal local variable\");\n+  assert(x != nullptr && !x->type()->is_illegal(), \"access of illegal local variable\");\n@@ -1048,1 +1048,1 @@\n-           cur_scope_data != NULL && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n+           cur_scope_data != nullptr && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n@@ -1069,1 +1069,1 @@\n-  Value length = NULL;\n+  Value length = nullptr;\n@@ -1071,1 +1071,1 @@\n-      (array->as_Constant() != NULL) ||\n+      (array->as_Constant() != nullptr) ||\n@@ -1088,1 +1088,1 @@\n-  Value length = NULL;\n+  Value length = nullptr;\n@@ -1090,1 +1090,1 @@\n-      (array->as_Constant() != NULL) ||\n+      (array->as_Constant() != nullptr) ||\n@@ -1098,1 +1098,1 @@\n-  if (array_type != NULL) {\n+  if (array_type != nullptr) {\n@@ -1232,1 +1232,1 @@\n-    if (s1 != NULL) {\n+    if (s1 != nullptr) {\n@@ -1235,1 +1235,1 @@\n-      if (l != NULL && l->op() == Bytecodes::_ishl) {\n+      if (l != nullptr && l->op() == Bytecodes::_ishl) {\n@@ -1238,1 +1238,1 @@\n-        if (s0 != NULL) {\n+        if (s0 != nullptr) {\n@@ -1314,1 +1314,1 @@\n-  Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()->is_optimistic()) ? state_before : NULL, is_bb));\n+  Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()->is_optimistic()) ? state_before : nullptr, is_bb));\n@@ -1316,1 +1316,1 @@\n-  assert(i->as_Goto() == NULL ||\n+  assert(i->as_Goto() == nullptr ||\n@@ -1323,1 +1323,1 @@\n-    if (if_node != NULL) {\n+    if (if_node != nullptr) {\n@@ -1341,1 +1341,1 @@\n-    if (goto_node != NULL) {\n+    if (goto_node != nullptr) {\n@@ -1392,1 +1392,1 @@\n-       cur_scope_data != NULL && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n+       cur_scope_data != nullptr && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n@@ -1435,1 +1435,1 @@\n-    BlockList* sux = new BlockList(l + 1, NULL);\n+    BlockList* sux = new BlockList(l + 1, nullptr);\n@@ -1481,1 +1481,1 @@\n-    BlockList* sux = new BlockList(l + 1, NULL);\n+    BlockList* sux = new BlockList(l + 1, nullptr);\n@@ -1516,1 +1516,1 @@\n-  assert(receiver != NULL, \"must have a receiver\");\n+  assert(receiver != nullptr, \"must have a receiver\");\n@@ -1519,1 +1519,1 @@\n-  if (exact_type == NULL &&\n+  if (exact_type == nullptr &&\n@@ -1536,1 +1536,1 @@\n-  if (exact_type != NULL) {\n+  if (exact_type != nullptr) {\n@@ -1538,1 +1538,1 @@\n-  } else if (declared_type != NULL) {\n+  } else if (declared_type != nullptr) {\n@@ -1606,1 +1606,1 @@\n-  if (continuation() != NULL) {\n+  if (continuation() != nullptr) {\n@@ -1610,1 +1610,1 @@\n-    if (x != NULL  && !ignore_return) {\n+    if (x != nullptr  && !ignore_return) {\n@@ -1615,1 +1615,1 @@\n-        if (declared_ret_type->is_klass() && x->exact_type() == NULL &&\n+        if (declared_ret_type->is_klass() && x->exact_type() == nullptr &&\n@@ -1646,1 +1646,1 @@\n-    if (x != NULL) {\n+    if (x != nullptr) {\n@@ -1691,1 +1691,1 @@\n-  if (!field_value.is_valid())  return NULL;\n+  if (!field_value.is_valid())  return nullptr;\n@@ -1710,1 +1710,1 @@\n-      return NULL; \/\/ Not a constant.\n+      return nullptr; \/\/ Not a constant.\n@@ -1727,1 +1727,1 @@\n-  ValueStack* state_before = NULL;\n+  ValueStack* state_before = nullptr;\n@@ -1734,1 +1734,1 @@\n-  Value obj = NULL;\n+  Value obj = nullptr;\n@@ -1736,1 +1736,1 @@\n-    if (state_before != NULL) {\n+    if (state_before != nullptr) {\n@@ -1759,1 +1759,1 @@\n-      Value constant = NULL;\n+      Value constant = nullptr;\n@@ -1766,1 +1766,1 @@\n-      if (constant != NULL) {\n+      if (constant != nullptr) {\n@@ -1769,1 +1769,1 @@\n-        if (state_before == NULL) {\n+        if (state_before == nullptr) {\n@@ -1779,1 +1779,1 @@\n-      if (state_before == NULL) {\n+      if (state_before == nullptr) {\n@@ -1791,1 +1791,1 @@\n-      Value constant = NULL;\n+      Value constant = nullptr;\n@@ -1811,1 +1811,1 @@\n-      if (constant != NULL) {\n+      if (constant != nullptr) {\n@@ -1814,1 +1814,1 @@\n-        if (state_before == NULL) {\n+        if (state_before == nullptr) {\n@@ -1848,1 +1848,1 @@\n-      if (state_before == NULL) {\n+      if (state_before == nullptr) {\n@@ -1857,1 +1857,1 @@\n-      if (store != NULL) {\n+      if (store != nullptr) {\n@@ -1881,1 +1881,1 @@\n-    if (data != NULL && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n+    if (data != nullptr && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n@@ -1886,2 +1886,2 @@\n-  if (profile_parameters() && target != NULL) {\n-    if (target->method_data() != NULL && target->method_data()->parameters_type_data() != NULL) {\n+  if (profile_parameters() && target != nullptr) {\n+    if (target->method_data() != nullptr && target->method_data()->parameters_type_data() != nullptr) {\n@@ -1897,1 +1897,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1903,1 +1903,1 @@\n-  ciSignature* declared_signature = NULL;\n+  ciSignature* declared_signature = nullptr;\n@@ -1913,2 +1913,2 @@\n-  if (obj_args == NULL) {\n-    return NULL;\n+  if (obj_args == nullptr) {\n+    return nullptr;\n@@ -1930,1 +1930,1 @@\n-  ciSignature* declared_signature = NULL;\n+  ciSignature* declared_signature = nullptr;\n@@ -1934,1 +1934,1 @@\n-  assert(declared_signature != NULL, \"cannot be null\");\n+  assert(declared_signature != nullptr, \"cannot be null\");\n@@ -1947,1 +1947,1 @@\n-  if (log != NULL)\n+  if (log != nullptr)\n@@ -2013,3 +2013,3 @@\n-  ciMethod* cha_monomorphic_target = NULL;\n-  ciMethod* exact_target = NULL;\n-  Value better_receiver = NULL;\n+  ciMethod* cha_monomorphic_target = nullptr;\n+  ciMethod* exact_target = nullptr;\n+  Value better_receiver = nullptr;\n@@ -2021,2 +2021,2 @@\n-    Value receiver = NULL;\n-    ciInstanceKlass* receiver_klass = NULL;\n+    Value receiver = nullptr;\n+    ciInstanceKlass* receiver_klass = nullptr;\n@@ -2029,1 +2029,1 @@\n-      if (type != NULL && type->is_loaded() &&\n+      if (type != nullptr && type->is_loaded() &&\n@@ -2034,1 +2034,1 @@\n-      if (type == NULL) {\n+      if (type == nullptr) {\n@@ -2036,1 +2036,1 @@\n-        if (type != NULL && type->is_loaded() &&\n+        if (type != nullptr && type->is_loaded() &&\n@@ -2048,1 +2048,1 @@\n-    if (receiver_klass != NULL && type_is_exact &&\n+    if (receiver_klass != nullptr && type_is_exact &&\n@@ -2053,1 +2053,1 @@\n-      if (exact_target != NULL) {\n+      if (exact_target != nullptr) {\n@@ -2058,1 +2058,1 @@\n-    if (receiver_klass != NULL &&\n+    if (receiver_klass != nullptr &&\n@@ -2068,1 +2068,1 @@\n-    } else if (code == Bytecodes::_invokeinterface && callee_holder->is_loaded() && receiver != NULL) {\n+    } else if (code == Bytecodes::_invokeinterface && callee_holder->is_loaded() && receiver != nullptr) {\n@@ -2086,1 +2086,1 @@\n-      if (singleton != NULL) {\n+      if (singleton != nullptr) {\n@@ -2089,1 +2089,1 @@\n-        if (cha_monomorphic_target != NULL) {\n+        if (cha_monomorphic_target != nullptr) {\n@@ -2105,1 +2105,1 @@\n-            cha_monomorphic_target = NULL; \/\/ subtype check against Object is useless\n+            cha_monomorphic_target = nullptr; \/\/ subtype check against Object is useless\n@@ -2112,1 +2112,1 @@\n-  if (cha_monomorphic_target != NULL) {\n+  if (cha_monomorphic_target != nullptr) {\n@@ -2136,2 +2136,2 @@\n-      ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;\n-      bool holder_known = (cha_monomorphic_target != NULL) || (exact_target != NULL);\n+      ciMethod* inline_target = (cha_monomorphic_target != nullptr) ? cha_monomorphic_target : target;\n+      bool holder_known = (cha_monomorphic_target != nullptr) || (exact_target != nullptr);\n@@ -2180,1 +2180,1 @@\n-  Value recv = has_receiver ? apop() : NULL;\n+  Value recv = has_receiver ? apop() : nullptr;\n@@ -2199,1 +2199,1 @@\n-    if (recv != NULL) {\n+    if (recv != nullptr) {\n@@ -2208,3 +2208,3 @@\n-        assert(cha_monomorphic_target == NULL || exact_target == NULL, \"both can not be set\");\n-        ciKlass* target_klass = NULL;\n-        if (cha_monomorphic_target != NULL) {\n+        assert(cha_monomorphic_target == nullptr || exact_target == nullptr, \"both can not be set\");\n+        ciKlass* target_klass = nullptr;\n+        if (cha_monomorphic_target != nullptr) {\n@@ -2212,1 +2212,1 @@\n-        } else if (exact_target != NULL) {\n+        } else if (exact_target != nullptr) {\n@@ -2215,1 +2215,1 @@\n-        profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);\n+        profile_call(target, recv, target_klass, collect_args_for_profiling(args, nullptr, false), false);\n@@ -2333,1 +2333,1 @@\n-  Values* dims = new Values(dimensions, dimensions, NULL);\n+  Values* dims = new Values(dimensions, dimensions, nullptr);\n@@ -2363,3 +2363,3 @@\n-          fp_value->as_Constant() == NULL &&\n-          fp_value->as_Local() == NULL &&       \/\/ method parameters need no rounding\n-          fp_value->as_RoundFP() == NULL) {\n+          fp_value->as_Constant() == nullptr &&\n+          fp_value->as_Local() == nullptr &&       \/\/ method parameters need no rounding\n+          fp_value->as_RoundFP() == nullptr) {\n@@ -2400,1 +2400,1 @@\n-  assert(i1->next() == NULL, \"shouldn't already be linked\");\n+  assert(i1->next() == nullptr, \"shouldn't already be linked\");\n@@ -2422,1 +2422,1 @@\n-  if (s != NULL) {\n+  if (s != nullptr) {\n@@ -2425,1 +2425,1 @@\n-      if (s->as_Invoke() != NULL || (intrinsic && !intrinsic->preserves_state())) {\n+      if (s->as_Invoke() != nullptr || (intrinsic && !intrinsic->preserves_state())) {\n@@ -2435,1 +2435,1 @@\n-    assert(i1->exception_state() != NULL || !i1->needs_exception_state() || bailed_out(), \"handle_exception must set exception state\");\n+    assert(i1->exception_state() != nullptr || !i1->needs_exception_state() || bailed_out(), \"handle_exception must set exception state\");\n@@ -2442,1 +2442,1 @@\n-  assert(instr->as_StateSplit() == NULL || instr->as_BlockEnd() != NULL, \"wrong append used\");\n+  assert(instr->as_StateSplit() == nullptr || instr->as_BlockEnd() != nullptr, \"wrong append used\");\n@@ -2453,1 +2453,1 @@\n-  if (value->as_NewArray() != NULL || value->as_NewInstance() != NULL) {\n+  if (value->as_NewArray() != nullptr || value->as_NewInstance() != nullptr) {\n@@ -2473,2 +2473,2 @@\n-  if (!has_handler() && (!instruction->needs_exception_state() || instruction->exception_state() != NULL)) {\n-    assert(instruction->exception_state() == NULL\n+  if (!has_handler() && (!instruction->needs_exception_state() || instruction->exception_state() != nullptr)) {\n+    assert(instruction->exception_state() == nullptr\n@@ -2484,1 +2484,1 @@\n-  ValueStack* prev_state = NULL;\n+  ValueStack* prev_state = nullptr;\n@@ -2487,1 +2487,1 @@\n-  assert(cur_state != NULL, \"state_before must be set\");\n+  assert(cur_state != nullptr, \"state_before must be set\");\n@@ -2514,1 +2514,1 @@\n-        assert(entry->state() == NULL || cur_state->total_locks_size() == entry->state()->total_locks_size(), \"locks do not match\");\n+        assert(entry->state() == nullptr || cur_state->total_locks_size() == entry->state()->total_locks_size(), \"locks do not match\");\n@@ -2520,1 +2520,1 @@\n-        if (instruction->exception_state() == NULL) {\n+        if (instruction->exception_state() == nullptr) {\n@@ -2572,1 +2572,1 @@\n-      if (prev_state != NULL) {\n+      if (prev_state != nullptr) {\n@@ -2575,1 +2575,1 @@\n-      if (instruction->exception_state() == NULL) {\n+      if (instruction->exception_state() == nullptr) {\n@@ -2596,1 +2596,1 @@\n-  } while (cur_scope_data != NULL);\n+  } while (cur_scope_data != nullptr);\n@@ -2623,1 +2623,1 @@\n-  if (phi == NULL) {\n+  if (phi == nullptr) {\n@@ -2644,1 +2644,1 @@\n-    Value subst = NULL;\n+    Value subst = nullptr;\n@@ -2648,1 +2648,1 @@\n-      assert(opd != NULL, \"Operand must exist!\");\n+      assert(opd != nullptr, \"Operand must exist!\");\n@@ -2658,1 +2658,1 @@\n-      assert(new_opd != NULL, \"Simplified operand must exist!\");\n+      assert(new_opd != nullptr, \"Simplified operand must exist!\");\n@@ -2661,1 +2661,1 @@\n-        if (subst == NULL) {\n+        if (subst == nullptr) {\n@@ -2673,1 +2673,1 @@\n-    assert(subst != NULL, \"illegal phi function\");\n+    assert(subst != nullptr, \"illegal phi function\");\n@@ -2702,1 +2702,1 @@\n-    assert(phi == NULL || phi->block() != b, \"must not have phi function to simplify in caller state\");\n+    assert(phi == nullptr || phi->block() != b, \"must not have phi function to simplify in caller state\");\n@@ -2737,1 +2737,1 @@\n-  assert(state() != NULL, \"ValueStack missing!\");\n+  assert(state() != nullptr, \"ValueStack missing!\");\n@@ -2747,1 +2747,1 @@\n-  if (block()->is_set(BlockBegin::exception_entry_flag) && block()->next() == NULL) {\n+  if (block()->is_set(BlockBegin::exception_entry_flag) && block()->next() == nullptr) {\n@@ -2754,1 +2754,1 @@\n-  while (!bailed_out() && last()->as_BlockEnd() == NULL &&\n+  while (!bailed_out() && last()->as_BlockEnd() == nullptr &&\n@@ -2756,1 +2756,1 @@\n-         (block_at(s.cur_bci()) == NULL || block_at(s.cur_bci()) == block())) {\n+         (block_at(s.cur_bci()) == nullptr || block_at(s.cur_bci()) == block())) {\n@@ -2759,1 +2759,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -2954,1 +2954,1 @@\n-      case Bytecodes::_return         : method_return(NULL  , ignore_return); break;\n+      case Bytecodes::_return         : method_return(nullptr, ignore_return); break;\n@@ -2979,1 +2979,1 @@\n-      case Bytecodes::_breakpoint     : BAILOUT_(\"concurrent setting of breakpoint\", NULL);\n+      case Bytecodes::_breakpoint     : BAILOUT_(\"concurrent setting of breakpoint\", nullptr);\n@@ -2983,1 +2983,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -2990,1 +2990,1 @@\n-  CHECK_BAILOUT_(NULL);\n+  CHECK_BAILOUT_(nullptr);\n@@ -2999,1 +2999,1 @@\n-  if (end == NULL) {\n+  if (end == nullptr) {\n@@ -3006,2 +3006,2 @@\n-  assert(end->state() != NULL, \"state must already be present\");\n-  assert(end->as_Return() == NULL || end->as_Throw() == NULL || end->state()->stack_size() == 0, \"stack not needed for return and throw\");\n+  assert(end->state() != nullptr, \"state must already be present\");\n+  assert(end->as_Return() == nullptr || end->as_Throw() == nullptr || end->state()->stack_size() == 0, \"stack not needed for return and throw\");\n@@ -3017,1 +3017,1 @@\n-    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", NULL);\n+    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", nullptr);\n@@ -3021,1 +3021,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -3035,1 +3035,1 @@\n-      while ((b = scope_data()->remove_from_work_list()) != NULL) {\n+      while ((b = scope_data()->remove_from_work_list()) != nullptr) {\n@@ -3169,1 +3169,1 @@\n-  if (base->std_entry()->state() == NULL) {\n+  if (base->std_entry()->state() == nullptr) {\n@@ -3174,1 +3174,1 @@\n-  assert(base->std_entry()->state() != NULL, \"\");\n+  assert(base->std_entry()->state() != nullptr, \"\");\n@@ -3193,1 +3193,1 @@\n-  assert(target != NULL && target->is_set(BlockBegin::osr_entry_flag), \"must be there\");\n+  assert(target != nullptr && target->is_set(BlockBegin::osr_entry_flag), \"must be there\");\n@@ -3249,1 +3249,1 @@\n-  assert(state->caller_state() == NULL, \"should be top scope\");\n+  assert(state->caller_state() == nullptr, \"should be top scope\");\n@@ -3256,1 +3256,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -3261,1 +3261,1 @@\n-  ValueStack* state = new ValueStack(scope(), NULL);\n+  ValueStack* state = new ValueStack(scope(), nullptr);\n@@ -3285,1 +3285,1 @@\n-    state->lock(NULL);\n+    state->lock(nullptr);\n@@ -3293,1 +3293,1 @@\n-  : _scope_data(NULL)\n+  : _scope_data(nullptr)\n@@ -3296,1 +3296,1 @@\n-  , _inline_bailout_msg(NULL)\n+  , _inline_bailout_msg(nullptr)\n@@ -3298,1 +3298,1 @@\n-  , _osr_entry(NULL)\n+  , _osr_entry(nullptr)\n@@ -3421,1 +3421,1 @@\n-  \/\/All blocks reachable from start_block have _end != NULL\n+  \/\/ For all blocks reachable from start_block: _end must be non-null\n@@ -3428,2 +3428,2 @@\n-      assert(current != NULL, \"Should not happen.\");\n-      assert(current->end() != NULL, \"All blocks reachable from start_block should have end() != NULL.\");\n+      assert(current != nullptr, \"Should not happen.\");\n+      assert(current->end() != nullptr, \"All blocks reachable from start_block should have end() != nullptr.\");\n@@ -3481,1 +3481,1 @@\n-  if (!has_handler()) return NULL;\n+  if (!has_handler()) return nullptr;\n@@ -3487,1 +3487,1 @@\n-  if (s == NULL) {\n+  if (s == nullptr) {\n@@ -3499,1 +3499,1 @@\n-  for (IRScope* s = scope(); s != NULL; s = s->caller()) {\n+  for (IRScope* s = scope(); s != nullptr; s = s->caller()) {\n@@ -3509,1 +3509,1 @@\n-  const char* msg = NULL;\n+  const char* msg = nullptr;\n@@ -3516,1 +3516,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -3547,1 +3547,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -3577,1 +3577,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3580,1 +3580,1 @@\n-\/\/ negative filter: should callee NOT be inlined?  returns NULL, ok to inline, or rejection msg\n+\/\/ negative filter: should callee NOT be inlined?  returns null, ok to inline, or rejection msg\n@@ -3584,1 +3584,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3665,1 +3665,1 @@\n-        Value recv = NULL;\n+        Value recv = nullptr;\n@@ -3670,1 +3670,1 @@\n-        profile_call(callee, recv, NULL, collect_args_for_profiling(args, callee, true), true);\n+        profile_call(callee, recv, nullptr, collect_args_for_profiling(args, callee, true), true);\n@@ -3719,1 +3719,1 @@\n-  assert(cont != NULL, \"continuation must exist (BlockListBuilder starts a new block after a jsr\");\n+  assert(cont != nullptr, \"continuation must exist (BlockListBuilder starts a new block after a jsr\");\n@@ -3732,1 +3732,1 @@\n-  assert(jsr_start_block != NULL, \"jsr start block must exist\");\n+  assert(jsr_start_block != nullptr, \"jsr start block must exist\");\n@@ -3736,1 +3736,1 @@\n-  assert(jsr_start_block->state() == NULL, \"should have fresh jsr starting block\");\n+  assert(jsr_start_block->state() == nullptr, \"should have fresh jsr starting block\");\n@@ -3743,1 +3743,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -3758,1 +3758,1 @@\n-  if (cont->state() != NULL) {\n+  if (cont->state() != nullptr) {\n@@ -3786,1 +3786,1 @@\n-  assert(lock != NULL && sync_handler != NULL, \"lock or handler missing\");\n+  assert(lock != nullptr && sync_handler != nullptr, \"lock or handler missing\");\n@@ -3789,1 +3789,1 @@\n-  assert(_last->as_MonitorEnter() != NULL, \"monitor enter expected\");\n+  assert(_last->as_MonitorEnter() != nullptr, \"monitor enter expected\");\n@@ -3814,1 +3814,1 @@\n-  assert(sync_handler != NULL, \"handler missing\");\n+  assert(sync_handler != nullptr, \"handler missing\");\n@@ -3817,1 +3817,1 @@\n-  assert(lock != NULL || default_handler, \"lock or handler missing\");\n+  assert(lock != nullptr || default_handler, \"lock or handler missing\");\n@@ -3893,1 +3893,1 @@\n-  Value recv = NULL;\n+  Value recv = nullptr;\n@@ -3931,1 +3931,1 @@\n-      while (top->caller() != NULL) {\n+      while (top->caller() != nullptr) {\n@@ -3970,1 +3970,1 @@\n-      if (obj_args != NULL) {\n+      if (obj_args != nullptr) {\n@@ -3982,1 +3982,1 @@\n-      profile_call(callee, recv, holder_known ? callee->holder() : NULL, obj_args, true);\n+      profile_call(callee, recv, holder_known ? callee->holder() : nullptr, obj_args, true);\n@@ -3993,1 +3993,1 @@\n-  if (cont == NULL) {\n+  if (cont == nullptr) {\n@@ -4035,2 +4035,2 @@\n-  Value lock = NULL;\n-  BlockBegin* sync_handler = NULL;\n+  Value lock = nullptr;\n+  BlockBegin* sync_handler = nullptr;\n@@ -4057,1 +4057,1 @@\n-  if (callee_start_block != NULL) {\n+  if (callee_start_block != nullptr) {\n@@ -4072,1 +4072,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -4076,1 +4076,1 @@\n-  if (log != NULL) log->head(\"parse method='%d'\", log->identify(callee));\n+  if (log != nullptr) log->head(\"parse method='%d'\", log->identify(callee));\n@@ -4080,1 +4080,1 @@\n-  iterate_all_blocks(callee_start_block == NULL);\n+  iterate_all_blocks(callee_start_block == nullptr);\n@@ -4082,1 +4082,1 @@\n-  if (log != NULL) log->done(\"parse\");\n+  if (log != nullptr) log->done(\"parse\");\n@@ -4131,1 +4131,1 @@\n-  if (callee->is_synchronized() && sync_handler->state() != NULL) {\n+  if (callee->is_synchronized() && sync_handler->state() != nullptr) {\n@@ -4208,1 +4208,1 @@\n-            if (obj->exact_type() == NULL &&\n+            if (obj->exact_type() == nullptr &&\n@@ -4221,1 +4221,1 @@\n-              if (obj->exact_type() == NULL &&\n+              if (obj->exact_type() == nullptr &&\n@@ -4260,1 +4260,1 @@\n-  assert(msg != NULL, \"inline bailout msg must exist\");\n+  assert(msg != nullptr, \"inline bailout msg must exist\");\n@@ -4266,1 +4266,1 @@\n-  _inline_bailout_msg = NULL;\n+  _inline_bailout_msg = nullptr;\n@@ -4271,1 +4271,1 @@\n-  ScopeData* data = new ScopeData(NULL);\n+  ScopeData* data = new ScopeData(nullptr);\n@@ -4289,1 +4289,1 @@\n-    blb.bci2block()->at_put(0, NULL);\n+    blb.bci2block()->at_put(0, nullptr);\n@@ -4414,1 +4414,1 @@\n-    Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));\n+    Instruction* store = append(new StoreIndexed(array, index, nullptr, T_CHAR, value, state_before, false, true));\n@@ -4418,1 +4418,1 @@\n-    Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));\n+    Instruction* load = append(new LoadIndexed(array, index, nullptr, T_CHAR, state_before, true));\n@@ -4426,2 +4426,2 @@\n-  if (log != NULL) {\n-    assert(msg != NULL, \"inlining msg should not be null!\");\n+  if (log != nullptr) {\n+    assert(msg != nullptr, \"inlining msg should not be null!\");\n@@ -4471,1 +4471,1 @@\n-  assert(known_holder == NULL || (known_holder->is_instance_klass() &&\n+  assert(known_holder == nullptr || (known_holder->is_instance_klass() &&\n@@ -4474,2 +4474,2 @@\n-  if (known_holder != NULL) {\n-    if (known_holder->exact_klass() == NULL) {\n+  if (known_holder != nullptr) {\n+    if (known_holder->exact_klass() == nullptr) {\n@@ -4484,2 +4484,2 @@\n-  assert((m == NULL) == (invoke_bci < 0), \"invalid method and invalid bci together\");\n-  if (m == NULL) {\n+  assert((m == nullptr) == (invoke_bci < 0), \"invalid method and invalid bci together\");\n+  if (m == nullptr) {\n@@ -4493,1 +4493,1 @@\n-  if (data != NULL && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n+  if (data != nullptr && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":224,"deletions":224,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-    \/\/ How to remove the next block to be parsed; returns NULL if none left\n+    \/\/ How to remove the next block to be parsed; returns null if none left\n@@ -240,1 +240,1 @@\n-  void arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before = NULL);\n+  void arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before = nullptr);\n@@ -312,1 +312,1 @@\n-  ValueStack* copy_state_if_bb(bool is_bb) { return (is_bb || compilation()->is_optimistic()) ? copy_state_before() : NULL; }\n+  ValueStack* copy_state_if_bb(bool is_bb) { return (is_bb || compilation()->is_optimistic()) ? copy_state_before() : nullptr; }\n@@ -353,1 +353,1 @@\n-  bool try_inline(           ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = NULL);\n+  bool try_inline(           ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = nullptr);\n@@ -355,1 +355,1 @@\n-  bool try_inline_full(      ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = NULL);\n+  bool try_inline_full(      ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = nullptr);\n@@ -386,1 +386,1 @@\n-  void profile_return_type(Value ret, ciMethod* callee, ciMethod* m = NULL, int bci = -1);\n+  void profile_return_type(Value ret, ciMethod* callee, ciMethod* m = nullptr, int bci = -1);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-  if (others == NULL) return false;\n+  if (others == nullptr) return false;\n@@ -130,1 +130,1 @@\n-  if (compilation->bailed_out()) return NULL;\n+  if (compilation->bailed_out()) return nullptr;\n@@ -141,1 +141,1 @@\n-  _level              = caller == NULL ?  0 : caller->level() + 1;\n+  _level              = caller == nullptr ?  0 : caller->level() + 1;\n@@ -149,1 +149,1 @@\n-  _start              = NULL;\n+  _start              = nullptr;\n@@ -176,1 +176,1 @@\n-  if (cur_method != NULL && cur_bci != SynchronizationEntryBCI) {\n+  if (cur_method != nullptr && cur_bci != SynchronizationEntryBCI) {\n@@ -188,1 +188,1 @@\n-  : _scope_debug_info(NULL)\n+  : _scope_debug_info(nullptr)\n@@ -191,1 +191,1 @@\n-  , _oop_map(NULL)\n+  , _oop_map(nullptr)\n@@ -196,1 +196,1 @@\n-  assert(_stack != NULL, \"must be non null\");\n+  assert(_stack != nullptr, \"must be non null\");\n@@ -201,1 +201,1 @@\n-  : _scope_debug_info(NULL)\n+  : _scope_debug_info(nullptr)\n@@ -203,3 +203,3 @@\n-  , _exception_handlers(NULL)\n-  , _oop_map(NULL)\n-  , _stack(stack == NULL ? info->_stack : stack)\n+  , _exception_handlers(nullptr)\n+  , _oop_map(nullptr)\n+  , _stack(stack == nullptr ? info->_stack : stack)\n@@ -211,1 +211,1 @@\n-  if (info->_exception_handlers != NULL) {\n+  if (info->_exception_handlers != nullptr) {\n@@ -227,1 +227,1 @@\n-  assert(_oop_map != NULL, \"oop map must already exist\");\n+  assert(_oop_map != nullptr, \"oop map must already exist\");\n@@ -244,1 +244,1 @@\n-  while (state != NULL) {\n+  while (state != nullptr) {\n@@ -273,2 +273,2 @@\n-  _top_scope   = new IRScope(compilation, NULL, -1, method, osr_bci, true);\n-  _code        = NULL;\n+  _top_scope   = new IRScope(compilation, nullptr, -1, method, osr_bci, true);\n+  _code        = nullptr;\n@@ -339,1 +339,1 @@\n-    BlockPair* last_pair = NULL;\n+    BlockPair* last_pair = nullptr;\n@@ -343,1 +343,1 @@\n-      if (last_pair != NULL && pair->is_same(last_pair)) continue;\n+      if (last_pair != nullptr && pair->is_same(last_pair)) continue;\n@@ -400,1 +400,1 @@\n-      if ((*n)->as_BlockEnd() != NULL) {\n+      if ((*n)->as_BlockEnd() != nullptr) {\n@@ -413,1 +413,1 @@\n-    for (Instruction* n = b; n != NULL; n = n->next()) {\n+    for (Instruction* n = b; n != nullptr; n = n->next()) {\n@@ -534,1 +534,1 @@\n-  _linear_scan_order(NULL), \/\/ initialized later with correct size\n+  _linear_scan_order(nullptr), \/\/ initialized later with correct size\n@@ -546,1 +546,1 @@\n-  count_edges(start_block, NULL);\n+  count_edges(start_block, nullptr);\n@@ -552,1 +552,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -577,2 +577,2 @@\n-  TRACE_LINEAR_SCAN(3, tty->print_cr(\"Enter count_edges for block B%d coming from B%d\", cur->block_id(), parent != NULL ? parent->block_id() : -1));\n-  assert(cur->dominator() == NULL, \"dominator already initialized\");\n+  TRACE_LINEAR_SCAN(3, tty->print_cr(\"Enter count_edges for block B%d coming from B%d\", cur->block_id(), parent != nullptr ? parent->block_id() : -1));\n+  assert(cur->dominator() == nullptr, \"dominator already initialized\");\n@@ -583,1 +583,1 @@\n-    assert(parent != NULL, \"must have parent\");\n+    assert(parent != nullptr, \"must have parent\");\n@@ -760,1 +760,1 @@\n-  assert(a != NULL && b != NULL, \"must have input blocks\");\n+  assert(a != nullptr && b != nullptr, \"must have input blocks\");\n@@ -763,1 +763,1 @@\n-  while (a != NULL) {\n+  while (a != nullptr) {\n@@ -765,1 +765,1 @@\n-    assert(a->dominator() != NULL || a == _linear_scan_order->at(0), \"dominator must be initialized\");\n+    assert(a->dominator() != nullptr || a == _linear_scan_order->at(0), \"dominator must be initialized\");\n@@ -768,2 +768,2 @@\n-  while (b != NULL && !_dominator_blocks.at(b->block_id())) {\n-    assert(b->dominator() != NULL || b == _linear_scan_order->at(0), \"dominator must be initialized\");\n+  while (b != nullptr && !_dominator_blocks.at(b->block_id())) {\n+    assert(b->dominator() != nullptr || b == _linear_scan_order->at(0), \"dominator must be initialized\");\n@@ -773,1 +773,1 @@\n-  assert(b != NULL, \"could not find dominator\");\n+  assert(b != nullptr, \"could not find dominator\");\n@@ -786,1 +786,1 @@\n-  if (cur->dominator() == NULL) {\n+  if (cur->dominator() == nullptr) {\n@@ -812,1 +812,1 @@\n-  BlockBegin* single_sux = NULL;\n+  BlockBegin* single_sux = nullptr;\n@@ -840,2 +840,2 @@\n-  INC_WEIGHT_IF(cur->end()->as_Throw() == NULL  && (single_sux == NULL || single_sux->end()->as_Throw()  == NULL));\n-  INC_WEIGHT_IF(cur->end()->as_Return() == NULL && (single_sux == NULL || single_sux->end()->as_Return() == NULL));\n+  INC_WEIGHT_IF(cur->end()->as_Throw() == nullptr  && (single_sux == nullptr || single_sux->end()->as_Throw()  == nullptr));\n+  INC_WEIGHT_IF(cur->end()->as_Return() == nullptr && (single_sux == nullptr || single_sux->end()->as_Return() == nullptr));\n@@ -883,1 +883,1 @@\n-  _work_list.append(NULL); \/\/ provide space for new element\n+  _work_list.append(nullptr); \/\/ provide space for new element\n@@ -921,1 +921,1 @@\n-  assert(start_block->end()->as_Base() != NULL, \"start block must end with Base-instruction\");\n+  assert(start_block->end()->as_Base() != nullptr, \"start block must end with Base-instruction\");\n@@ -925,2 +925,2 @@\n-  BlockBegin* sux_of_osr_entry = NULL;\n-  if (osr_entry != NULL) {\n+  BlockBegin* sux_of_osr_entry = nullptr;\n+  if (osr_entry != nullptr) {\n@@ -986,1 +986,1 @@\n-  assert(_linear_scan_order->at(0)->dominator() == NULL, \"must not have dominator\");\n+  assert(_linear_scan_order->at(0)->dominator() == nullptr, \"must not have dominator\");\n@@ -1080,1 +1080,1 @@\n-      if (cur->dominator() != NULL) {\n+      if (cur->dominator() != nullptr) {\n@@ -1083,1 +1083,1 @@\n-        tty->print(\"    dom: NULL \");\n+        tty->print(\"    dom: null \");\n@@ -1159,1 +1159,1 @@\n-      assert(cur->dominator() == NULL, \"first block has no dominator\");\n+      assert(cur->dominator() == nullptr, \"first block has no dominator\");\n@@ -1161,1 +1161,1 @@\n-      assert(cur->dominator() != NULL, \"all but first block must have dominator\");\n+      assert(cur->dominator() != nullptr, \"all but first block must have dominator\");\n@@ -1272,1 +1272,1 @@\n-    assert(block->end() != NULL, \"Expect block end to exist.\");\n+    assert(block->end() != nullptr, \"Expect block end to exist.\");\n@@ -1307,1 +1307,1 @@\n-    _predecessors = new BlockListList(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL);\n+    _predecessors = new BlockListList(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), nullptr);\n@@ -1311,1 +1311,1 @@\n-    if (hir->code() != NULL) {\n+    if (hir->code() != nullptr) {\n@@ -1340,2 +1340,2 @@\n-    BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n-    if (preds == NULL) {\n+    BlockList* preds = _predecessors->at_grow(sux->block_id(), nullptr);\n+    if (preds == nullptr) {\n@@ -1350,1 +1350,1 @@\n-    if (preds == NULL) {\n+    if (preds == nullptr) {\n@@ -1373,1 +1373,1 @@\n-    for (Instruction* cur = block; cur != NULL; cur = cur->next()) {\n+    for (Instruction* cur = block; cur != nullptr; cur = cur->next()) {\n@@ -1391,2 +1391,2 @@\n-      assert(block->pred_at(i) != NULL, \"Predecessor must exist\");\n-      assert(block->pred_at(i)->end() != NULL, \"Predecessor end must exist\");\n+      assert(block->pred_at(i) != nullptr, \"Predecessor must exist\");\n+      assert(block->pred_at(i)->end() != nullptr, \"Predecessor end must exist\");\n@@ -1477,2 +1477,2 @@\n-  Instruction* last = NULL;\n-  for (Instruction* n = block; n != NULL;) {\n+  Instruction* last = nullptr;\n+  for (Instruction* n = block; n != nullptr;) {\n@@ -1482,1 +1482,1 @@\n-      guarantee(last != NULL, \"must have last\");\n+      guarantee(last != nullptr, \"must have last\");\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":59,"deletions":59,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-    , _entry_block(NULL)\n-    , _entry_code(NULL)\n+    , _entry_block(nullptr)\n+    , _entry_code(nullptr)\n@@ -140,1 +140,1 @@\n-  IRScope*      _caller;                         \/\/ the caller scope, or NULL\n+  IRScope*      _caller;                         \/\/ the caller scope, or null\n@@ -172,1 +172,1 @@\n-  bool          is_top_scope() const             { return _caller == NULL; }\n+  bool          is_top_scope() const             { return _caller == nullptr; }\n@@ -178,1 +178,1 @@\n-  bool          is_valid() const                 { return start() != NULL; }\n+  bool          is_valid() const                 { return start() != nullptr; }\n@@ -236,1 +236,1 @@\n-    if (caller() != NULL) {\n+    if (caller() != nullptr) {\n@@ -276,1 +276,1 @@\n-  CodeEmitInfo(CodeEmitInfo* info, ValueStack* stack = NULL);\n+  CodeEmitInfo(CodeEmitInfo* info, ValueStack* stack = nullptr);\n@@ -334,1 +334,1 @@\n-  BlockList* linear_scan_order() {  assert(_code != NULL, \"not computed\"); return _code; }\n+  BlockList* linear_scan_order() {  assert(_code != nullptr, \"not computed\"); return _code; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-  if (state != NULL && (state->kind() == ValueStack::EmptyExceptionState || state->kind() == ValueStack::ExceptionState)) {\n+  if (state != nullptr && (state->kind() == ValueStack::EmptyExceptionState || state->kind() == ValueStack::ExceptionState)) {\n@@ -83,1 +83,1 @@\n-    _exception_state = NULL;\n+    _exception_state = nullptr;\n@@ -89,1 +89,1 @@\n-  Instruction* p = NULL;\n+  Instruction* p = nullptr;\n@@ -92,1 +92,1 @@\n-    assert(q != NULL, \"this is not in the block's instruction list\");\n+    assert(q != nullptr, \"this is not in the block's instruction list\");\n@@ -100,1 +100,1 @@\n-  if (state_before() != NULL) {\n+  if (state_before() != nullptr) {\n@@ -103,1 +103,1 @@\n-  if (exception_state() != NULL){\n+  if (exception_state() != nullptr) {\n@@ -110,1 +110,1 @@\n-  if (t != NULL && t->is_klass()) {\n+  if (t != nullptr && t->is_klass()) {\n@@ -113,1 +113,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -119,1 +119,1 @@\n-  if (state != NULL) {\n+  if (state != nullptr) {\n@@ -171,1 +171,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -176,1 +176,1 @@\n-  if (array_type != NULL) {\n+  if (array_type != nullptr) {\n@@ -193,2 +193,2 @@\n-  if (array_type == NULL || !array_type->is_loaded()) {\n-    return NULL;\n+  if (array_type == nullptr || !array_type->is_loaded()) {\n+    return nullptr;\n@@ -307,1 +307,1 @@\n-  if (state() != NULL) state()->values_do(f);\n+  if (state() != nullptr) state()->values_do(f);\n@@ -336,1 +336,1 @@\n-  assert(args != NULL, \"args must exist\");\n+  assert(args != nullptr, \"args must exist\");\n@@ -357,2 +357,2 @@\n-  if (state_before() != NULL) state_before()->values_do(f);\n-  if (state()        != NULL) state()->values_do(f);\n+  if (state_before() != nullptr) state_before()->values_do(f);\n+  if (state()        != nullptr) state()->values_do(f);\n@@ -370,1 +370,1 @@\n-  if (state_before() == NULL) {\n+  if (state_before() == nullptr) {\n@@ -402,1 +402,1 @@\n-  if (v->as_Constant() == NULL) return false;\n+  if (v->as_Constant() == nullptr) return false;\n@@ -409,1 +409,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -416,1 +416,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -423,1 +423,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -430,1 +430,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -437,1 +437,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -445,1 +445,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -457,1 +457,1 @@\n-  if (rc == NULL) return not_comparable;\n+  if (rc == nullptr) return not_comparable;\n@@ -495,1 +495,1 @@\n-    assert(xvalue != NULL && yvalue != NULL, \"not constants\");\n+    assert(xvalue != nullptr && yvalue != nullptr, \"not constants\");\n@@ -508,1 +508,1 @@\n-    assert(xvalue != NULL && yvalue != NULL, \"not constants\");\n+    assert(xvalue != nullptr && yvalue != nullptr, \"not constants\");\n@@ -528,1 +528,1 @@\n-  assert(new_end != NULL, \"Should not reset block new_end to NULL\");\n+  assert(new_end != nullptr, \"Should not reset block new_end to null\");\n@@ -532,1 +532,1 @@\n-  if (_end != NULL) {\n+  if (_end != nullptr) {\n@@ -659,1 +659,1 @@\n-  assert(b != NULL && (b->is_set(exception_entry_flag)), \"exception handler must exist\");\n+  assert(b != nullptr && (b->is_set(exception_entry_flag)), \"exception handler must exist\");\n@@ -666,1 +666,1 @@\n-  if (_exception_states == NULL) {\n+  if (_exception_states == nullptr) {\n@@ -711,1 +711,1 @@\n-  for (Instruction* n = this; n != NULL; n = n->next()) n->values_do(f);\n+  for (Instruction* n = this; n != nullptr; n = n->next()) n->values_do(f);\n@@ -730,1 +730,1 @@\n-  if (existing_state == NULL) {\n+  if (existing_state == nullptr) {\n@@ -792,1 +792,1 @@\n-        if (new_value == NULL || new_value->type()->tag() != existing_value->type()->tag()) {\n+        if (new_value == nullptr || new_value->type()->tag() != existing_value->type()->tag()) {\n@@ -794,1 +794,1 @@\n-          if (existing_phi == NULL) {\n+          if (existing_phi == nullptr) {\n@@ -805,1 +805,1 @@\n-        if (existing_value != new_state->local_at(index) && existing_value->as_Phi() == NULL) {\n+        if (existing_value != new_state->local_at(index) && existing_value->as_Phi() == nullptr) {\n@@ -814,1 +814,1 @@\n-        assert(existing_value->as_Phi() != NULL && existing_value->as_Phi()->block() == this, \"phi function required\");\n+        assert(existing_value->as_Phi() != nullptr && existing_value->as_Phi()->block() == this, \"phi function required\");\n@@ -817,1 +817,1 @@\n-        assert(existing_value == new_state->local_at(index) || (existing_value->as_Phi() != NULL && existing_value->as_Phi()->as_Phi()->block() == this), \"phi function required\");\n+        assert(existing_value == new_state->local_at(index) || (existing_value->as_Phi() != nullptr && existing_value->as_Phi()->as_Phi()->block() == this), \"phi function required\");\n@@ -829,1 +829,1 @@\n-        if (new_value != existing_value && (existing_phi == NULL || existing_phi->block() != this)) {\n+        if (new_value != existing_value && (existing_phi == nullptr || existing_phi->block() != this)) {\n@@ -840,1 +840,1 @@\n-        if (new_value == NULL || new_value->type()->tag() != existing_value->type()->tag()) {\n+        if (new_value == nullptr || new_value->type()->tag() != existing_value->type()->tag()) {\n@@ -843,1 +843,1 @@\n-        } else if (new_value != existing_value && (existing_phi == NULL || existing_phi->block() != this)) {\n+        } else if (new_value != existing_value && (existing_phi == nullptr || existing_phi->block() != this)) {\n@@ -875,1 +875,1 @@\n-  for (Instruction* n = next(); n != NULL; n = n->next()) {\n+  for (Instruction* n = next(); n != nullptr; n = n->next()) {\n@@ -937,1 +937,1 @@\n-  assert(state != NULL, \"\");\n+  assert(state != nullptr, \"\");\n@@ -989,1 +989,1 @@\n-  if (state() != NULL) state()->values_do(f);\n+  if (state() != nullptr) state()->values_do(f);\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-    if (_v == NULL  ) return false;                   \\\n+    if (_v == nullptr) return false;                  \\\n@@ -252,1 +252,1 @@\n-    if (_v == NULL  ) return false;                   \\\n+    if (_v == nullptr) return false;                  \\\n@@ -266,1 +266,1 @@\n-    if (_v == NULL  ) return false;                   \\\n+    if (_v == nullptr) return false;                  \\\n@@ -285,1 +285,1 @@\n-  Instruction* _next;                            \/\/ the next instruction if any (NULL for BlockEnd instructions)\n+  Instruction* _next;                            \/\/ the next instruction if any (null for BlockEnd instructions)\n@@ -290,1 +290,1 @@\n-  ValueStack*  _state_before;                    \/\/ Copy of state with input operands still on stack (or NULL)\n+  ValueStack*  _state_before;                    \/\/ Copy of state with input operands still on stack (or null)\n@@ -302,1 +302,1 @@\n-    assert(type != NULL, \"type must exist\");\n+    assert(type != nullptr, \"type must exist\");\n@@ -398,1 +398,1 @@\n-  Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)\n+  Instruction(ValueType* type, ValueStack* state_before = nullptr, bool type_is_constant = false)\n@@ -406,2 +406,2 @@\n-  , _next(NULL)\n-  , _subst(NULL)\n+  , _next(nullptr)\n+  , _subst(nullptr)\n@@ -411,2 +411,2 @@\n-  , _exception_handlers(NULL)\n-  , _block(NULL)\n+  , _exception_handlers(nullptr)\n+  , _block(nullptr)\n@@ -415,1 +415,1 @@\n-    assert(type != NULL && (!type->is_constant() || type_is_constant), \"type must exist\");\n+    assert(type != nullptr && (!type->is_constant() || type_is_constant), \"type must exist\");\n@@ -434,2 +434,2 @@\n-  bool has_subst() const                         { return _subst != NULL; }\n-  Instruction* subst()                           { return _subst == NULL ? this : _subst->subst(); }\n+  bool has_subst() const                         { return _subst != nullptr; }\n+  Instruction* subst()                           { return _subst == nullptr ? this : _subst->subst(); }\n@@ -441,1 +441,1 @@\n-  bool can_be_linked()                           { return as_Local() == NULL && as_Phi() == NULL; }\n+  bool can_be_linked()                           { return as_Local() == nullptr && as_Phi() == nullptr; }\n@@ -443,1 +443,1 @@\n-  bool is_null_obj()                             { return as_Constant() != NULL && type()->as_ObjectType()->constant_value()->is_null_object(); }\n+  bool is_null_obj()                             { return as_Constant() != nullptr && type()->as_ObjectType()->constant_value()->is_null_object(); }\n@@ -459,2 +459,2 @@\n-    assert(next != NULL, \"must not be NULL\");\n-    assert(as_BlockEnd() == NULL, \"BlockEnd instructions must have no next\");\n+    assert(next != nullptr, \"must not be null\");\n+    assert(as_BlockEnd() == nullptr, \"BlockEnd instructions must have no next\");\n@@ -502,1 +502,1 @@\n-    assert(subst == NULL ||\n+    assert(subst == nullptr ||\n@@ -517,50 +517,50 @@\n-  virtual Phi*              as_Phi()             { return NULL; }\n-  virtual Local*            as_Local()           { return NULL; }\n-  virtual Constant*         as_Constant()        { return NULL; }\n-  virtual AccessField*      as_AccessField()     { return NULL; }\n-  virtual LoadField*        as_LoadField()       { return NULL; }\n-  virtual StoreField*       as_StoreField()      { return NULL; }\n-  virtual AccessArray*      as_AccessArray()     { return NULL; }\n-  virtual ArrayLength*      as_ArrayLength()     { return NULL; }\n-  virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }\n-  virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }\n-  virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }\n-  virtual NegateOp*         as_NegateOp()        { return NULL; }\n-  virtual Op2*              as_Op2()             { return NULL; }\n-  virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }\n-  virtual ShiftOp*          as_ShiftOp()         { return NULL; }\n-  virtual LogicOp*          as_LogicOp()         { return NULL; }\n-  virtual CompareOp*        as_CompareOp()       { return NULL; }\n-  virtual IfOp*             as_IfOp()            { return NULL; }\n-  virtual Convert*          as_Convert()         { return NULL; }\n-  virtual NullCheck*        as_NullCheck()       { return NULL; }\n-  virtual OsrEntry*         as_OsrEntry()        { return NULL; }\n-  virtual StateSplit*       as_StateSplit()      { return NULL; }\n-  virtual Invoke*           as_Invoke()          { return NULL; }\n-  virtual NewInstance*      as_NewInstance()     { return NULL; }\n-  virtual NewArray*         as_NewArray()        { return NULL; }\n-  virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }\n-  virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }\n-  virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }\n-  virtual TypeCheck*        as_TypeCheck()       { return NULL; }\n-  virtual CheckCast*        as_CheckCast()       { return NULL; }\n-  virtual InstanceOf*       as_InstanceOf()      { return NULL; }\n-  virtual TypeCast*         as_TypeCast()        { return NULL; }\n-  virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }\n-  virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }\n-  virtual MonitorExit*      as_MonitorExit()     { return NULL; }\n-  virtual Intrinsic*        as_Intrinsic()       { return NULL; }\n-  virtual BlockBegin*       as_BlockBegin()      { return NULL; }\n-  virtual BlockEnd*         as_BlockEnd()        { return NULL; }\n-  virtual Goto*             as_Goto()            { return NULL; }\n-  virtual If*               as_If()              { return NULL; }\n-  virtual TableSwitch*      as_TableSwitch()     { return NULL; }\n-  virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }\n-  virtual Return*           as_Return()          { return NULL; }\n-  virtual Throw*            as_Throw()           { return NULL; }\n-  virtual Base*             as_Base()            { return NULL; }\n-  virtual RoundFP*          as_RoundFP()         { return NULL; }\n-  virtual ExceptionObject*  as_ExceptionObject() { return NULL; }\n-  virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }\n-  virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }\n-  virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }\n+  virtual Phi*              as_Phi()             { return nullptr; }\n+  virtual Local*            as_Local()           { return nullptr; }\n+  virtual Constant*         as_Constant()        { return nullptr; }\n+  virtual AccessField*      as_AccessField()     { return nullptr; }\n+  virtual LoadField*        as_LoadField()       { return nullptr; }\n+  virtual StoreField*       as_StoreField()      { return nullptr; }\n+  virtual AccessArray*      as_AccessArray()     { return nullptr; }\n+  virtual ArrayLength*      as_ArrayLength()     { return nullptr; }\n+  virtual AccessIndexed*    as_AccessIndexed()   { return nullptr; }\n+  virtual LoadIndexed*      as_LoadIndexed()     { return nullptr; }\n+  virtual StoreIndexed*     as_StoreIndexed()    { return nullptr; }\n+  virtual NegateOp*         as_NegateOp()        { return nullptr; }\n+  virtual Op2*              as_Op2()             { return nullptr; }\n+  virtual ArithmeticOp*     as_ArithmeticOp()    { return nullptr; }\n+  virtual ShiftOp*          as_ShiftOp()         { return nullptr; }\n+  virtual LogicOp*          as_LogicOp()         { return nullptr; }\n+  virtual CompareOp*        as_CompareOp()       { return nullptr; }\n+  virtual IfOp*             as_IfOp()            { return nullptr; }\n+  virtual Convert*          as_Convert()         { return nullptr; }\n+  virtual NullCheck*        as_NullCheck()       { return nullptr; }\n+  virtual OsrEntry*         as_OsrEntry()        { return nullptr; }\n+  virtual StateSplit*       as_StateSplit()      { return nullptr; }\n+  virtual Invoke*           as_Invoke()          { return nullptr; }\n+  virtual NewInstance*      as_NewInstance()     { return nullptr; }\n+  virtual NewArray*         as_NewArray()        { return nullptr; }\n+  virtual NewTypeArray*     as_NewTypeArray()    { return nullptr; }\n+  virtual NewObjectArray*   as_NewObjectArray()  { return nullptr; }\n+  virtual NewMultiArray*    as_NewMultiArray()   { return nullptr; }\n+  virtual TypeCheck*        as_TypeCheck()       { return nullptr; }\n+  virtual CheckCast*        as_CheckCast()       { return nullptr; }\n+  virtual InstanceOf*       as_InstanceOf()      { return nullptr; }\n+  virtual TypeCast*         as_TypeCast()        { return nullptr; }\n+  virtual AccessMonitor*    as_AccessMonitor()   { return nullptr; }\n+  virtual MonitorEnter*     as_MonitorEnter()    { return nullptr; }\n+  virtual MonitorExit*      as_MonitorExit()     { return nullptr; }\n+  virtual Intrinsic*        as_Intrinsic()       { return nullptr; }\n+  virtual BlockBegin*       as_BlockBegin()      { return nullptr; }\n+  virtual BlockEnd*         as_BlockEnd()        { return nullptr; }\n+  virtual Goto*             as_Goto()            { return nullptr; }\n+  virtual If*               as_If()              { return nullptr; }\n+  virtual TableSwitch*      as_TableSwitch()     { return nullptr; }\n+  virtual LookupSwitch*     as_LookupSwitch()    { return nullptr; }\n+  virtual Return*           as_Return()          { return nullptr; }\n+  virtual Throw*            as_Throw()           { return nullptr; }\n+  virtual Base*             as_Base()            { return nullptr; }\n+  virtual RoundFP*          as_RoundFP()         { return nullptr; }\n+  virtual ExceptionObject*  as_ExceptionObject() { return nullptr; }\n+  virtual UnsafeOp*         as_UnsafeOp()        { return nullptr; }\n+  virtual ProfileInvoke*    as_ProfileInvoke()   { return nullptr; }\n+  virtual RangeCheckPredicate* as_RangeCheckPredicate() { return nullptr; }\n@@ -569,1 +569,1 @@\n-  virtual Assert*           as_Assert()          { return NULL; }\n+  virtual Assert*           as_Assert()          { return nullptr; }\n@@ -582,1 +582,1 @@\n-  virtual ciType* declared_type() const          { return NULL; }\n+  virtual ciType* declared_type() const          { return nullptr; }\n@@ -618,1 +618,1 @@\n-  void visit(Value* x)             { assert((*x) != NULL, \"value must exist\"); }\n+  void visit(Value* x)             { assert((*x) != nullptr, \"value must exist\"); }\n@@ -717,1 +717,1 @@\n-      Instruction(type, NULL, \/*type_is_constant*\/ true)\n+      Instruction(type, nullptr, \/*type_is_constant*\/ true)\n@@ -725,1 +725,1 @@\n-    assert(state_before != NULL, \"only used for constants which need patching\");\n+    assert(state_before != nullptr, \"only used for constants which need patching\");\n@@ -732,1 +732,1 @@\n-  virtual bool can_trap() const                  { return state_before() != NULL; }\n+  virtual bool can_trap() const                  { return state_before() != nullptr; }\n@@ -749,1 +749,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -756,1 +756,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -777,1 +777,1 @@\n-  , _explicit_null_check(NULL)\n+  , _explicit_null_check(nullptr)\n@@ -887,1 +887,1 @@\n-  , _explicit_null_check(NULL) {}\n+  , _explicit_null_check(nullptr) {}\n@@ -927,1 +927,1 @@\n-  void clear_length()                            { _length = NULL; }\n+  void clear_length()                            { _length = nullptr; }\n@@ -932,1 +932,1 @@\n-  virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f->visit(&_index); if (_length != NULL) f->visit(&_length); }\n+  virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f->visit(&_index); if (_length != nullptr) f->visit(&_length); }\n@@ -944,1 +944,1 @@\n-  , _explicit_null_check(NULL) {}\n+  , _explicit_null_check(nullptr) {}\n@@ -974,1 +974,1 @@\n-  , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)\n+  , _value(value), _profiled_method(nullptr), _profiled_bci(0), _check_boolean(check_boolean)\n@@ -1025,1 +1025,1 @@\n-  Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)\n+  Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = nullptr)\n@@ -1210,1 +1210,1 @@\n-  StateSplit(ValueType* type, ValueStack* state_before = NULL)\n+  StateSplit(ValueType* type, ValueStack* state_before = nullptr)\n@@ -1212,1 +1212,1 @@\n-  , _state(NULL)\n+  , _state(nullptr)\n@@ -1222,1 +1222,1 @@\n-  void set_state(ValueStack* state)              { assert(_state == NULL, \"overwriting existing state\"); check_state(state); _state = state; }\n+  void set_state(ValueStack* state)              { assert(_state == nullptr, \"overwriting existing state\"); check_state(state); _state = state; }\n@@ -1246,1 +1246,1 @@\n-  bool has_receiver() const                      { return receiver() != NULL; }\n+  bool has_receiver() const                      { return receiver() != nullptr; }\n@@ -1310,1 +1310,1 @@\n-    \/\/ Do not ASSERT_VALUES since length is NULL for NewMultiArray\n+    \/\/ Do not ASSERT_VALUES since length is null for NewMultiArray\n@@ -1318,1 +1318,1 @@\n-  ciType* exact_type() const                     { return NULL; }\n+  ciType* exact_type() const                     { return nullptr; }\n@@ -1365,1 +1365,1 @@\n-  NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {\n+  NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(nullptr, state_before), _klass(klass), _dims(dims) {\n@@ -1400,1 +1400,1 @@\n-    _profiled_method(NULL), _profiled_bci(0) {\n+    _profiled_method(nullptr), _profiled_bci(0) {\n@@ -1408,1 +1408,1 @@\n-  bool is_loaded() const                         { return klass() != NULL; }\n+  bool is_loaded() const                         { return klass() != nullptr; }\n@@ -1471,1 +1471,1 @@\n-  AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)\n+  AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = nullptr)\n@@ -1507,1 +1507,1 @@\n-  : AccessMonitor(obj, monitor_no, NULL)\n+  : AccessMonitor(obj, monitor_no, nullptr)\n@@ -1539,1 +1539,1 @@\n-  , _recv(NULL)\n+  , _recv(nullptr)\n@@ -1541,1 +1541,1 @@\n-    assert(args != NULL, \"args must exist\");\n+    assert(args != nullptr, \"args must exist\");\n@@ -1561,1 +1561,1 @@\n-  bool has_receiver() const                      { return (_recv != NULL); }\n+  bool has_receiver() const                      { return (_recv != nullptr); }\n@@ -1655,2 +1655,2 @@\n-  , _dominator(NULL)\n-  , _end(NULL)\n+  , _dominator(nullptr)\n+  , _end(nullptr)\n@@ -1658,1 +1658,1 @@\n-  , _exception_states(NULL)\n+  , _exception_states(nullptr)\n@@ -1660,1 +1660,1 @@\n-  , _lir(NULL)\n+  , _lir(nullptr)\n@@ -1666,1 +1666,1 @@\n-  , _fpu_stack_state(NULL)\n+  , _fpu_stack_state(nullptr)\n@@ -1742,1 +1742,1 @@\n-  int number_of_exception_states()               { assert(is_set(exception_entry_flag), \"only for xhandlers\"); return _exception_states == NULL ? 0 : _exception_states->length(); }\n+  int number_of_exception_states()               { assert(is_set(exception_entry_flag), \"only for xhandlers\"); return _exception_states == nullptr ? 0 : _exception_states->length(); }\n@@ -1804,2 +1804,2 @@\n-    assert(sux != NULL, \"sux must exist\");\n-    for (int i = sux->length() - 1; i >= 0; i--) assert(sux->at(i) != NULL, \"sux must exist\");\n+    assert(sux != nullptr, \"sux must exist\");\n+    for (int i = sux->length() - 1; i >= 0; i--) assert(sux->at(i) != nullptr, \"sux must exist\");\n@@ -1814,1 +1814,1 @@\n-  , _sux(NULL)\n+  , _sux(nullptr)\n@@ -1829,1 +1829,1 @@\n-  int number_of_sux() const                      { return _sux != NULL ? _sux->length() : 0; }\n+  int number_of_sux() const                      { return _sux != nullptr ? _sux->length() : 0; }\n@@ -1831,1 +1831,1 @@\n-  bool is_sux(BlockBegin* sux) const             { return _sux == NULL ? false : _sux->contains(sux); }\n+  bool is_sux(BlockBegin* sux) const             { return _sux == nullptr ? false : _sux->contains(sux); }\n@@ -1851,1 +1851,1 @@\n-    , _profiled_method(NULL)\n+    , _profiled_method(nullptr)\n@@ -1859,2 +1859,2 @@\n-  Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)\n-                                           , _profiled_method(NULL)\n+  Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, nullptr, is_safepoint)\n+                                           , _profiled_method(nullptr)\n@@ -1931,1 +1931,1 @@\n-    _x = _y = NULL;\n+    _x = _y = nullptr;\n@@ -1941,1 +1941,1 @@\n-  void always_fail()                             { _x = _y = NULL; }\n+  void always_fail()                             { _x = _y = nullptr; }\n@@ -1965,1 +1965,1 @@\n-  , _profiled_method(NULL)\n+  , _profiled_method(nullptr)\n@@ -2056,1 +2056,1 @@\n-    assert(keys != NULL, \"keys must exist\");\n+    assert(keys != nullptr, \"keys must exist\");\n@@ -2072,1 +2072,1 @@\n-    BlockEnd(result == NULL ? voidType : result->type()->base(), NULL, true),\n+    BlockEnd(result == nullptr ? voidType : result->type()->base(), nullptr, true),\n@@ -2077,1 +2077,1 @@\n-  bool has_result() const                        { return result() != NULL; }\n+  bool has_result() const                        { return result() != nullptr; }\n@@ -2109,1 +2109,1 @@\n-  Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {\n+  Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, nullptr, false) {\n@@ -2111,1 +2111,1 @@\n-    assert(osr_entry == NULL || osr_entry->is_set(BlockBegin::osr_entry_flag), \"osr entry must be flagged\");\n+    assert(osr_entry == nullptr || osr_entry->is_set(BlockBegin::osr_entry_flag), \"osr entry must be flagged\");\n@@ -2113,1 +2113,1 @@\n-    if (osr_entry != NULL) s->append(osr_entry);\n+    if (osr_entry != nullptr) s->append(osr_entry);\n@@ -2120,1 +2120,1 @@\n-  BlockBegin* osr_entry() const                  { return number_of_sux() < 2 ? NULL : sux_at(0); }\n+  BlockBegin* osr_entry() const                  { return number_of_sux() < 2 ? nullptr : sux_at(0); }\n@@ -2299,1 +2299,1 @@\n-  int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args->length(); }\n+  int nb_profiled_args()         const { return _obj_args == nullptr ? 0 : _obj_args->length(); }\n@@ -2311,1 +2311,1 @@\n-    if (_recv != NULL) {\n+    if (_recv != nullptr) {\n@@ -2346,1 +2346,1 @@\n-    if (_ret != NULL) {\n+    if (_ret != nullptr) {\n@@ -2439,2 +2439,2 @@\n-inline int         BlockBegin::number_of_sux() const            { assert(_end != NULL, \"need end\"); return _end->number_of_sux(); }\n-inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end != NULL , \"need end\"); return _end->sux_at(i); }\n+inline int         BlockBegin::number_of_sux() const            { assert(_end != nullptr, \"need end\"); return _end->number_of_sux(); }\n+inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end != nullptr , \"need end\"); return _end->sux_at(i); }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":128,"deletions":128,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  if (n == NULL || type > T_VOID) {\n+  if (n == nullptr || type > T_VOID) {\n@@ -57,1 +57,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -105,1 +105,1 @@\n-  Phi* phi = v ? v->as_Phi() : NULL;\n+  Phi* phi = v ? v->as_Phi() : nullptr;\n@@ -114,1 +114,1 @@\n-  Phi* phi = v ? v->as_Phi() : NULL;\n+  Phi* phi = v ? v->as_Phi() : nullptr;\n@@ -126,1 +126,1 @@\n-  if (type->as_ObjectConstant() != NULL) {\n+  if (type->as_ObjectConstant() != nullptr) {\n@@ -137,1 +137,1 @@\n-  } else if (type->as_InstanceConstant() != NULL) {\n+  } else if (type->as_InstanceConstant() != nullptr) {\n@@ -146,1 +146,1 @@\n-  } else if (type->as_ArrayConstant() != NULL) {\n+  } else if (type->as_ArrayConstant() != nullptr) {\n@@ -148,1 +148,1 @@\n-  } else if (type->as_ClassConstant() != NULL) {\n+  } else if (type->as_ClassConstant() != nullptr) {\n@@ -155,1 +155,1 @@\n-  } else if (type->as_MethodConstant() != NULL) {\n+  } else if (type->as_MethodConstant() != nullptr) {\n@@ -180,1 +180,1 @@\n-  if (indexed->length() != NULL) {\n+  if (indexed->length() != nullptr) {\n@@ -203,2 +203,2 @@\n-  if (value == NULL) {\n-    output()->print(\"NULL\");\n+  if (value == nullptr) {\n+    output()->print(\"null\");\n@@ -228,1 +228,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -247,1 +247,1 @@\n-      if (t == NULL) {\n+      if (t == nullptr) {\n@@ -283,1 +283,1 @@\n-      else output()->print(\"NULL\");\n+      else output()->print(\"null\");\n@@ -327,1 +327,1 @@\n-  if (split != NULL && split->state() != NULL && !split->state()->stack_is_empty()) {\n+  if (split != nullptr && split->state() != nullptr && !split->state()->stack_is_empty()) {\n@@ -467,1 +467,1 @@\n-  if (x->receiver() != NULL) {\n+  if (x->receiver() != nullptr) {\n@@ -535,2 +535,2 @@\n-  if (strchr(name, '_') == NULL) {\n-    kname = NULL;\n+  if (strchr(name, '_') == nullptr) {\n+    kname = nullptr;\n@@ -539,1 +539,1 @@\n-    if (kptr != NULL)  kname = kptr + 1;\n+    if (kptr != nullptr)  kname = kptr + 1;\n@@ -541,1 +541,1 @@\n-  if (kname == NULL)\n+  if (kname == nullptr)\n@@ -591,1 +591,1 @@\n-  output()->print(\"[%d, %d]\", x->bci(), (end == NULL ? -1 : end->printable_bci()));\n+  output()->print(\"[%d, %d]\", x->bci(), (end == nullptr ? -1 : end->printable_bci()));\n@@ -594,1 +594,1 @@\n-  if (end != NULL && end->number_of_sux() > 0) {\n+  if (end != nullptr && end->number_of_sux() > 0) {\n@@ -611,1 +611,1 @@\n-  if (x->dominator() != NULL) {\n+  if (x->dominator() != nullptr) {\n@@ -648,1 +648,1 @@\n-    } while (state != NULL);\n+    } while (state != nullptr);\n@@ -670,1 +670,1 @@\n-    } while (state != NULL);\n+    } while (state != nullptr);\n@@ -751,1 +751,1 @@\n-  if (x->result() == NULL) {\n+  if (x->result() == nullptr) {\n@@ -810,1 +810,1 @@\n-  if (x->x() != NULL && x->y() != NULL) {\n+  if (x->x() != nullptr && x->y() != nullptr) {\n@@ -834,1 +834,1 @@\n-  if (x->known_holder() != NULL) {\n+  if (x->known_holder() != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n-    if (c != NULL && !c->value()->is_loaded()) {\n-      return LIR_OprFact::metadataConst(NULL);\n-    } else if (c != NULL) {\n+    if (c != nullptr && !c->value()->is_loaded()) {\n+      return LIR_OprFact::metadataConst(nullptr);\n+    } else if (c != nullptr) {\n@@ -62,1 +62,1 @@\n-      assert (m != NULL, \"not a class or a method?\");\n+      assert (m != nullptr, \"not a class or a method?\");\n@@ -239,1 +239,1 @@\n-  : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+  : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)nullptr)\n@@ -242,2 +242,2 @@\n-  , _ublock(NULL)\n-  , _stub(NULL) {\n+  , _ublock(nullptr)\n+  , _stub(nullptr) {\n@@ -247,1 +247,1 @@\n-  LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+  LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)nullptr)\n@@ -249,2 +249,2 @@\n-  , _block(NULL)\n-  , _ublock(NULL)\n+  , _block(nullptr)\n+  , _ublock(nullptr)\n@@ -255,1 +255,1 @@\n-  : LIR_Op2(lir_cond_float_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+  : LIR_Op2(lir_cond_float_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)nullptr)\n@@ -259,1 +259,1 @@\n-  , _stub(NULL)\n+  , _stub(nullptr)\n@@ -264,1 +264,1 @@\n-  assert(_block != NULL, \"must have old block\");\n+  assert(_block != nullptr, \"must have old block\");\n@@ -272,1 +272,1 @@\n-  assert(_ublock != NULL, \"must have old block\");\n+  assert(_ublock != nullptr, \"must have old block\");\n@@ -294,1 +294,1 @@\n-  : LIR_Op(code, result, NULL)\n+  : LIR_Op(code, result, nullptr)\n@@ -305,1 +305,1 @@\n-  , _profiled_method(NULL)\n+  , _profiled_method(nullptr)\n@@ -310,1 +310,1 @@\n-    assert(info_for_exception != NULL, \"checkcast throws exceptions\");\n+    assert(info_for_exception != nullptr, \"checkcast throws exceptions\");\n@@ -312,1 +312,1 @@\n-    assert(info_for_exception == NULL, \"instanceof throws no exceptions\");\n+    assert(info_for_exception == nullptr, \"instanceof throws no exceptions\");\n@@ -321,1 +321,1 @@\n-  : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)\n+  : LIR_Op(code, LIR_OprFact::illegalOpr, nullptr)\n@@ -324,1 +324,1 @@\n-  , _klass(NULL)\n+  , _klass(nullptr)\n@@ -329,1 +329,1 @@\n-  , _info_for_patch(NULL)\n+  , _info_for_patch(nullptr)\n@@ -331,2 +331,2 @@\n-  , _stub(NULL)\n-  , _profiled_method(NULL)\n+  , _stub(nullptr)\n+  , _profiled_method(nullptr)\n@@ -338,1 +338,1 @@\n-    assert(info_for_exception != NULL, \"store_check throws exceptions\");\n+    assert(info_for_exception != nullptr, \"store_check throws exceptions\");\n@@ -360,1 +360,1 @@\n-  : LIR_Op(lir_updatecrc32, res, NULL)\n+  : LIR_Op(lir_updatecrc32, res, nullptr)\n@@ -412,2 +412,2 @@\n-      assert(op->as_Op0() != NULL, \"must be\");\n-      assert(op->_info == NULL, \"info not used by this instruction\");\n+      assert(op->as_Op0() != nullptr, \"must be\");\n+      assert(op->_info == nullptr, \"info not used by this instruction\");\n@@ -423,2 +423,2 @@\n-      assert(op->as_Op0() != NULL, \"must be\");\n-      if (op->_info != NULL)           do_info(op->_info);\n+      assert(op->as_Op0() != nullptr, \"must be\");\n+      if (op->_info != nullptr)           do_info(op->_info);\n@@ -433,2 +433,2 @@\n-      assert(op->as_OpLabel() != NULL, \"must be\");\n-      assert(op->_info == NULL, \"info not used by this instruction\");\n+      assert(op->as_OpLabel() != nullptr, \"must be\");\n+      assert(op->_info == nullptr, \"info not used by this instruction\");\n@@ -450,1 +450,1 @@\n-      assert(op->as_Op1() != NULL, \"must be\");\n+      assert(op->as_Op1() != nullptr, \"must be\");\n@@ -462,1 +462,1 @@\n-      assert(op->as_OpReturn() != NULL, \"must be\");\n+      assert(op->as_OpReturn() != nullptr, \"must be\");\n@@ -468,1 +468,1 @@\n-      if (op_ret->stub() != NULL)      do_stub(op_ret->stub());\n+      if (op_ret->stub() != nullptr)      do_stub(op_ret->stub());\n@@ -475,1 +475,1 @@\n-      assert(op->as_Op1() != NULL, \"must be\");\n+      assert(op->as_Op1() != nullptr, \"must be\");\n@@ -478,1 +478,1 @@\n-      assert(op1->_info != NULL, \"\");  do_info(op1->_info);\n+      assert(op1->_info != nullptr, \"\");  do_info(op1->_info);\n@@ -488,1 +488,1 @@\n-      assert(op->as_OpConvert() != NULL, \"must be\");\n+      assert(op->as_OpConvert() != nullptr, \"must be\");\n@@ -491,1 +491,1 @@\n-      assert(opConvert->_info == NULL, \"must be\");\n+      assert(opConvert->_info == nullptr, \"must be\");\n@@ -503,1 +503,1 @@\n-      assert(op->as_OpBranch() != NULL, \"must be\");\n+      assert(op->as_OpBranch() != nullptr, \"must be\");\n@@ -513,1 +513,1 @@\n-      if (opBranch->_info != NULL)     do_info(opBranch->_info);\n+      if (opBranch->_info != nullptr)  do_info(opBranch->_info);\n@@ -515,1 +515,1 @@\n-      if (opBranch->_stub != NULL)     opBranch->stub()->visit(this);\n+      if (opBranch->_stub != nullptr)  opBranch->stub()->visit(this);\n@@ -524,1 +524,1 @@\n-      assert(op->as_OpAllocObj() != NULL, \"must be\");\n+      assert(op->as_OpAllocObj() != nullptr, \"must be\");\n@@ -543,1 +543,1 @@\n-      assert(op->as_OpRoundFP() != NULL, \"must be\");\n+      assert(op->as_OpRoundFP() != nullptr, \"must be\");\n@@ -546,1 +546,1 @@\n-      assert(op->_info == NULL, \"info not used by this instruction\");\n+      assert(op->_info == nullptr, \"info not used by this instruction\");\n@@ -578,1 +578,1 @@\n-      assert(op->as_Op2() != NULL, \"must be\");\n+      assert(op->as_Op2() != nullptr, \"must be\");\n@@ -603,1 +603,1 @@\n-      assert(op->as_Op4() != NULL, \"must be\");\n+      assert(op->as_Op4() != nullptr, \"must be\");\n@@ -606,1 +606,1 @@\n-      assert(op4->_info == NULL && op4->_tmp1->is_illegal() && op4->_tmp2->is_illegal() &&\n+      assert(op4->_info == nullptr && op4->_tmp1->is_illegal() && op4->_tmp2->is_illegal() &&\n@@ -626,1 +626,1 @@\n-      assert(op->as_Op2() != NULL, \"must be\");\n+      assert(op->as_Op2() != nullptr, \"must be\");\n@@ -629,1 +629,1 @@\n-      assert(op2->_info == NULL, \"not used\");\n+      assert(op2->_info == nullptr, \"not used\");\n@@ -645,1 +645,1 @@\n-      assert(op->as_Op2() != NULL, \"must be\");\n+      assert(op->as_Op2() != nullptr, \"must be\");\n@@ -659,1 +659,1 @@\n-      assert(op->as_Op1() != NULL, \"must be\");\n+      assert(op->as_Op1() != nullptr, \"must be\");\n@@ -662,1 +662,1 @@\n-      assert(op1->_info == NULL, \"no info\");\n+      assert(op1->_info == nullptr, \"no info\");\n@@ -672,1 +672,1 @@\n-      assert(op->as_Op3() != NULL, \"must be\");\n+      assert(op->as_Op3() != nullptr, \"must be\");\n@@ -691,1 +691,1 @@\n-      assert(op->as_Op3() != NULL, \"must be\");\n+      assert(op->as_Op3() != nullptr, \"must be\");\n@@ -693,1 +693,1 @@\n-      assert(op3->_info == NULL, \"no info\");\n+      assert(op3->_info == nullptr, \"no info\");\n@@ -707,1 +707,1 @@\n-      assert(opJavaCall != NULL, \"must be\");\n+      assert(opJavaCall != nullptr, \"must be\");\n@@ -734,1 +734,1 @@\n-      assert(op->as_OpRTCall() != NULL, \"must be\");\n+      assert(op->as_OpRTCall() != nullptr, \"must be\");\n@@ -755,1 +755,1 @@\n-      assert(op->as_OpArrayCopy() != NULL, \"must be\");\n+      assert(op->as_OpArrayCopy() != nullptr, \"must be\");\n@@ -776,1 +776,1 @@\n-      assert(op->as_OpUpdateCRC32() != NULL, \"must be\");\n+      assert(op->as_OpUpdateCRC32() != nullptr, \"must be\");\n@@ -782,1 +782,1 @@\n-      assert(opUp->_info == NULL, \"no info for LIR_OpUpdateCRC32\");\n+      assert(opUp->_info == nullptr, \"no info for LIR_OpUpdateCRC32\");\n@@ -791,1 +791,1 @@\n-      assert(op->as_OpLock() != NULL, \"must be\");\n+      assert(op->as_OpLock() != nullptr, \"must be\");\n@@ -813,1 +813,1 @@\n-      assert(op->as_OpDelay() != NULL, \"must be\");\n+      assert(op->as_OpDelay() != nullptr, \"must be\");\n@@ -824,1 +824,1 @@\n-      assert(op->as_OpTypeCheck() != NULL, \"must be\");\n+      assert(op->as_OpTypeCheck() != nullptr, \"must be\");\n@@ -846,1 +846,1 @@\n-      assert(op->as_OpCompareAndSwap() != NULL, \"must be\");\n+      assert(op->as_OpCompareAndSwap() != nullptr, \"must be\");\n@@ -866,1 +866,1 @@\n-      assert(op->as_OpAllocArray() != NULL, \"must be\");\n+      assert(op->as_OpAllocArray() != nullptr, \"must be\");\n@@ -889,1 +889,1 @@\n-      assert(opLoadKlass != NULL, \"must be\");\n+      assert(opLoadKlass != nullptr, \"must be\");\n@@ -900,1 +900,1 @@\n-      assert(op->as_OpProfileCall() != NULL, \"must be\");\n+      assert(op->as_OpProfileCall() != nullptr, \"must be\");\n@@ -911,1 +911,1 @@\n-      assert(op->as_OpProfileType() != NULL, \"must be\");\n+      assert(op->as_OpProfileType() != nullptr, \"must be\");\n@@ -929,1 +929,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -935,1 +935,1 @@\n-  XHandlers* result = NULL;\n+  XHandlers* result = nullptr;\n@@ -939,1 +939,1 @@\n-    if (info_at(i)->exception_handlers() != NULL) {\n+    if (info_at(i)->exception_handlers() != nullptr) {\n@@ -947,1 +947,1 @@\n-    assert(info_at(i)->exception_handlers() == NULL ||\n+    assert(info_at(i)->exception_handlers() == nullptr ||\n@@ -953,1 +953,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -978,2 +978,2 @@\n-    LIR_Op1(lir_return, opr, (CodeEmitInfo*)NULL \/* info *\/),\n-    _stub(NULL) {\n+    LIR_Op1(lir_return, opr, (CodeEmitInfo*)nullptr \/* info *\/),\n+    _stub(nullptr) {\n@@ -1031,1 +1031,1 @@\n-  if (stub() != NULL) {\n+  if (stub() != nullptr) {\n@@ -1101,1 +1101,1 @@\n-  , _file(NULL)\n+  , _file(nullptr)\n@@ -1114,2 +1114,2 @@\n-  if (f == NULL) f = strrchr(file, '\\\\');\n-  if (f == NULL) {\n+  if (f == nullptr) f = strrchr(file, '\\\\');\n+  if (f == nullptr) {\n@@ -1170,1 +1170,1 @@\n-    _operations.at_grow(n + buffer->number_of_ops() - 1, NULL);\n+    _operations.at_grow(n + buffer->number_of_ops() - 1, nullptr);\n@@ -1435,1 +1435,1 @@\n-                    NULL));\n+                    nullptr));\n@@ -1452,1 +1452,1 @@\n-  if (profiled_method != NULL) {\n+  if (profiled_method != nullptr) {\n@@ -1461,2 +1461,2 @@\n-  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);\n-  if (profiled_method != NULL) {\n+  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, nullptr, info_for_patch, nullptr);\n+  if (profiled_method != nullptr) {\n@@ -1474,1 +1474,1 @@\n-  if (profiled_method != NULL) {\n+  if (profiled_method != nullptr) {\n@@ -1486,1 +1486,1 @@\n-    cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));\n+    cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(nullptr));\n@@ -1627,1 +1627,1 @@\n-  tty->print(\"[%d, %d] \", x->bci(), (end == NULL ? -1 : end->printable_bci()));\n+  tty->print(\"[%d, %d] \", x->bci(), (end == nullptr ? -1 : end->printable_bci()));\n@@ -1637,1 +1637,1 @@\n-  if (end != NULL && x->number_of_sux() > 0) {\n+  if (end != nullptr && x->number_of_sux() > 0) {\n@@ -1683,1 +1683,1 @@\n-  if (info() != NULL) out->print(\" [bci:%d]\", info()->stack()->bci());\n+  if (info() != nullptr) out->print(\" [bci:%d]\", info()->stack()->bci());\n@@ -1685,1 +1685,1 @@\n-  if (Verbose && _file != NULL) {\n+  if (Verbose && _file != nullptr) {\n@@ -1692,1 +1692,1 @@\n-  const char* s = NULL;\n+  const char* s = nullptr;\n@@ -1895,1 +1895,1 @@\n-  if (block() != NULL) {\n+  if (block() != nullptr) {\n@@ -1897,1 +1897,1 @@\n-  } else if (stub() != NULL) {\n+  } else if (stub() != nullptr) {\n@@ -1901,1 +1901,1 @@\n-    if (stub()->info() != NULL) out->print(\" [bci:%d]\", stub()->info()->stack()->bci());\n+    if (stub()->info() != nullptr) out->print(\" [bci:%d]\", stub()->info()->stack()->bci());\n@@ -1905,1 +1905,1 @@\n-  if (ublock() != NULL) {\n+  if (ublock() != nullptr) {\n@@ -2014,1 +2014,1 @@\n-  if (info_for_exception() != NULL) out->print(\" [bci:%d]\", info_for_exception()->stack()->bci());\n+  if (info_for_exception() != nullptr) out->print(\" [bci:%d]\", info_for_exception()->stack()->bci());\n@@ -2080,1 +2080,1 @@\n-  if  (exact_klass() == NULL) {\n+  if (exact_klass() == nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":97,"deletions":97,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-  virtual LIR_Const*  as_constant()              { return NULL; }\n-  virtual LIR_Address* as_address()              { return NULL; }\n+  virtual LIR_Const*  as_constant()              { return nullptr; }\n+  virtual LIR_Address* as_address()              { return nullptr; }\n@@ -387,2 +387,2 @@\n-  bool is_constant() const     { return is_pointer() && pointer()->as_constant() != NULL; }\n-  bool is_address() const      { return is_pointer() && pointer()->as_address() != NULL; }\n+  bool is_constant() const     { return is_pointer() && pointer()->as_constant() != nullptr; }\n+  bool is_address() const      { return is_pointer() && pointer()->as_address() != nullptr; }\n@@ -1088,1 +1088,1 @@\n-      _file(NULL)\n+      _file(nullptr)\n@@ -1094,1 +1094,1 @@\n-    , _info(NULL)\n+    , _info(nullptr)\n@@ -1097,1 +1097,1 @@\n-    , _source(NULL) {}\n+    , _source(nullptr) {}\n@@ -1102,1 +1102,1 @@\n-      _file(NULL)\n+      _file(nullptr)\n@@ -1111,1 +1111,1 @@\n-    , _source(NULL) {}\n+    , _source(nullptr) {}\n@@ -1144,24 +1144,24 @@\n-  virtual LIR_OpCall* as_OpCall() { return NULL; }\n-  virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }\n-  virtual LIR_OpLabel* as_OpLabel() { return NULL; }\n-  virtual LIR_OpDelay* as_OpDelay() { return NULL; }\n-  virtual LIR_OpLock* as_OpLock() { return NULL; }\n-  virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }\n-  virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }\n-  virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }\n-  virtual LIR_OpBranch* as_OpBranch() { return NULL; }\n-  virtual LIR_OpReturn* as_OpReturn() { return NULL; }\n-  virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }\n-  virtual LIR_OpConvert* as_OpConvert() { return NULL; }\n-  virtual LIR_Op0* as_Op0() { return NULL; }\n-  virtual LIR_Op1* as_Op1() { return NULL; }\n-  virtual LIR_Op2* as_Op2() { return NULL; }\n-  virtual LIR_Op3* as_Op3() { return NULL; }\n-  virtual LIR_Op4* as_Op4() { return NULL; }\n-  virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }\n-  virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }\n-  virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }\n-  virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }\n-  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return NULL; }\n-  virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }\n-  virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }\n+  virtual LIR_OpCall* as_OpCall() { return nullptr; }\n+  virtual LIR_OpJavaCall* as_OpJavaCall() { return nullptr; }\n+  virtual LIR_OpLabel* as_OpLabel() { return nullptr; }\n+  virtual LIR_OpDelay* as_OpDelay() { return nullptr; }\n+  virtual LIR_OpLock* as_OpLock() { return nullptr; }\n+  virtual LIR_OpAllocArray* as_OpAllocArray() { return nullptr; }\n+  virtual LIR_OpAllocObj* as_OpAllocObj() { return nullptr; }\n+  virtual LIR_OpRoundFP* as_OpRoundFP() { return nullptr; }\n+  virtual LIR_OpBranch* as_OpBranch() { return nullptr; }\n+  virtual LIR_OpReturn* as_OpReturn() { return nullptr; }\n+  virtual LIR_OpRTCall* as_OpRTCall() { return nullptr; }\n+  virtual LIR_OpConvert* as_OpConvert() { return nullptr; }\n+  virtual LIR_Op0* as_Op0() { return nullptr; }\n+  virtual LIR_Op1* as_Op1() { return nullptr; }\n+  virtual LIR_Op2* as_Op2() { return nullptr; }\n+  virtual LIR_Op3* as_Op3() { return nullptr; }\n+  virtual LIR_Op4* as_Op4() { return nullptr; }\n+  virtual LIR_OpArrayCopy* as_OpArrayCopy() { return nullptr; }\n+  virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return nullptr; }\n+  virtual LIR_OpTypeCheck* as_OpTypeCheck() { return nullptr; }\n+  virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return nullptr; }\n+  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return nullptr; }\n+  virtual LIR_OpProfileCall* as_OpProfileCall() { return nullptr; }\n+  virtual LIR_OpProfileType* as_OpProfileType() { return nullptr; }\n@@ -1169,1 +1169,1 @@\n-  virtual LIR_OpAssert* as_OpAssert() { return NULL; }\n+  virtual LIR_OpAssert* as_OpAssert() { return nullptr; }\n@@ -1184,1 +1184,1 @@\n-             LIR_OprList* arguments, CodeEmitInfo* info = NULL)\n+             LIR_OprList* arguments, CodeEmitInfo* info = nullptr)\n@@ -1253,1 +1253,1 @@\n-   : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)\n+   : LIR_Op(lir_label, LIR_OprFact::illegalOpr, nullptr)\n@@ -1340,2 +1340,2 @@\n-   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)  { assert(is_in_range(code, begin_op0, end_op0), \"code check\"); }\n-  LIR_Op0(LIR_Code code, LIR_Opr result, CodeEmitInfo* info = NULL)\n+   : LIR_Op(code, LIR_OprFact::illegalOpr, nullptr)  { assert(is_in_range(code, begin_op0, end_op0), \"code check\"); }\n+  LIR_Op0(LIR_Code code, LIR_Opr result, CodeEmitInfo* info = nullptr)\n@@ -1370,1 +1370,1 @@\n-  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result = LIR_OprFact::illegalOpr, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = NULL)\n+  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result = LIR_OprFact::illegalOpr, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = nullptr)\n@@ -1420,1 +1420,1 @@\n-               LIR_Opr result, LIR_OprList* arguments, CodeEmitInfo* info = NULL)\n+               LIR_Opr result, LIR_OprList* arguments, CodeEmitInfo* info = nullptr)\n@@ -1581,1 +1581,1 @@\n-  virtual bool is_patching() { return _info_for_patch != NULL; }\n+  virtual bool is_patching() { return _info_for_patch != nullptr; }\n@@ -1607,1 +1607,1 @@\n-  LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = NULL, BasicType type = T_ILLEGAL)\n+  LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = nullptr, BasicType type = T_ILLEGAL)\n@@ -1623,1 +1623,1 @@\n-    : LIR_Op(code, result, NULL)\n+    : LIR_Op(code, result, nullptr)\n@@ -1639,1 +1639,1 @@\n-          CodeEmitInfo* info = NULL, BasicType type = T_ILLEGAL)\n+          CodeEmitInfo* info = nullptr, BasicType type = T_ILLEGAL)\n@@ -1656,1 +1656,1 @@\n-    : LIR_Op(code, result, NULL)\n+    : LIR_Op(code, result, nullptr)\n@@ -1707,1 +1707,1 @@\n-    : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*) NULL)\n+    : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*) nullptr)\n@@ -1709,3 +1709,3 @@\n-    , _block(NULL)\n-    , _ublock(NULL)\n-    , _stub(NULL) { }\n+    , _block(nullptr)\n+    , _ublock(nullptr)\n+    , _stub(nullptr) { }\n@@ -1756,1 +1756,1 @@\n-    : LIR_Op(lir_alloc_array, result, NULL)\n+    : LIR_Op(lir_alloc_array, result, nullptr)\n@@ -1790,1 +1790,1 @@\n-  LIR_Op3(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr opr3, LIR_Opr result, CodeEmitInfo* info = NULL)\n+  LIR_Op3(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr opr3, LIR_Opr result, CodeEmitInfo* info = nullptr)\n@@ -1822,1 +1822,1 @@\n-    : LIR_Op(code, result, NULL)\n+    : LIR_Op(code, result, nullptr)\n@@ -1977,1 +1977,1 @@\n-    : LIR_Op(code, result, NULL)  \/\/ no result, no info\n+    : LIR_Op(code, result, nullptr)  \/\/ no result, no info\n@@ -2011,1 +2011,1 @@\n-    : LIR_Op(lir_profile_call, LIR_OprFact::illegalOpr, NULL)  \/\/ no result, no info\n+    : LIR_Op(lir_profile_call, LIR_OprFact::illegalOpr, nullptr)  \/\/ no result, no info\n@@ -2047,1 +2047,1 @@\n-  ciKlass*     _exact_klass;   \/\/ non NULL if we know the klass statically (no need to load it from _obj)\n+  ciKlass*     _exact_klass;   \/\/ non null if we know the klass statically (no need to load it from _obj)\n@@ -2050,1 +2050,1 @@\n-  bool         _no_conflict;   \/\/ true if we're profling parameters, _exact_klass is not NULL and we know\n+  bool         _no_conflict;   \/\/ true if we're profling parameters, _exact_klass is not null and we know\n@@ -2056,1 +2056,1 @@\n-    : LIR_Op(lir_profile_type, LIR_OprFact::illegalOpr, NULL)  \/\/ no result, no info\n+    : LIR_Op(lir_profile_type, LIR_OprFact::illegalOpr, nullptr)  \/\/ no result, no info\n@@ -2107,1 +2107,1 @@\n-    if (op->source() == NULL)\n+    if (op->source() == nullptr)\n@@ -2127,1 +2127,1 @@\n-    _file = NULL;\n+    _file = nullptr;\n@@ -2132,1 +2132,1 @@\n-  LIR_List(Compilation* compilation, BlockBegin* block = NULL);\n+  LIR_List(Compilation* compilation, BlockBegin* block = nullptr);\n@@ -2198,1 +2198,1 @@\n-  void leal(LIR_Opr from, LIR_Opr result_reg, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_leal, from, result_reg, T_ILLEGAL, patch_code, info)); }\n+  void leal(LIR_Opr from, LIR_Opr result_reg, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_leal, from, result_reg, T_ILLEGAL, patch_code, info)); }\n@@ -2203,4 +2203,4 @@\n-  void move(LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n-  void move(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, src->type(), lir_patch_none, info)); }\n-  void move(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst->type(), lir_patch_none, info)); }\n-  void move_wide(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = NULL) {\n+  void move(LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n+  void move(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, src->type(), lir_patch_none, info)); }\n+  void move(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst->type(), lir_patch_none, info)); }\n+  void move_wide(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = nullptr) {\n@@ -2213,1 +2213,1 @@\n-  void move_wide(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) {\n+  void move_wide(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = nullptr) {\n@@ -2220,1 +2220,1 @@\n-  void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }\n+  void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = nullptr, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }\n@@ -2231,1 +2231,1 @@\n-  void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = NULL\/*, bool is_32bit = false*\/) { append(new LIR_OpConvert(code, left, dst, stub)); }\n+  void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = nullptr\/*, bool is_32bit = false*\/) { append(new LIR_OpConvert(code, left, dst, stub)); }\n@@ -2248,1 +2248,1 @@\n-  void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL) {\n+  void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = nullptr) {\n@@ -2251,1 +2251,1 @@\n-  void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = NULL) {\n+  void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = nullptr) {\n@@ -2281,1 +2281,1 @@\n-  void sub (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL) { append(new LIR_Op2(lir_sub, left, right, res, info)); }\n+  void sub (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = nullptr) { append(new LIR_Op2(lir_sub, left, right, res, info)); }\n@@ -2284,1 +2284,1 @@\n-  void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL)      { append(new LIR_Op2(lir_div, left, right, res, info)); }\n+  void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = nullptr)      { append(new LIR_Op2(lir_div, left, right, res, info)); }\n@@ -2286,1 +2286,1 @@\n-  void rem (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL)      { append(new LIR_Op2(lir_rem, left, right, res, info)); }\n+  void rem (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = nullptr)      { append(new LIR_Op2(lir_rem, left, right, res, info)); }\n@@ -2291,1 +2291,1 @@\n-  void load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none);\n+  void load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info = nullptr, LIR_PatchCode patch_code = lir_patch_none);\n@@ -2295,1 +2295,1 @@\n-  void store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none);\n+  void store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info = nullptr, LIR_PatchCode patch_code = lir_patch_none);\n@@ -2389,1 +2389,1 @@\n-  LIR_List*   _lir;   \/\/ the lir list where ops of this buffer should be inserted later (NULL when uninitialized)\n+  LIR_List*   _lir;   \/\/ the lir list where ops of this buffer should be inserted later (null when uninitialized)\n@@ -2407,1 +2407,1 @@\n-  LIR_InsertionBuffer() : _lir(NULL), _index_and_count(8), _ops(8) { }\n+  LIR_InsertionBuffer() : _lir(nullptr), _index_and_count(8), _ops(8) { }\n@@ -2411,1 +2411,1 @@\n-  bool initialized() const  { return _lir != NULL; }\n+  bool initialized() const  { return _lir != nullptr; }\n@@ -2413,1 +2413,1 @@\n-  void finish()             { _lir = NULL; }\n+  void finish()             { _lir = nullptr; }\n@@ -2428,1 +2428,1 @@\n-  void move(int index, LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(index, new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n+  void move(int index, LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = nullptr) { append(index, new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n@@ -2477,1 +2477,1 @@\n-      if (address != NULL) {\n+      if (address != nullptr) {\n@@ -2505,1 +2505,1 @@\n-    assert(info != NULL, \"should not call this otherwise\");\n+    assert(info != nullptr, \"should not call this otherwise\");\n@@ -2520,1 +2520,1 @@\n-    _op = NULL;\n+    _op = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n- , _current_block(NULL)\n- , _pending_non_safepoint(NULL)\n+ , _current_block(nullptr)\n+ , _pending_non_safepoint(nullptr)\n@@ -198,1 +198,1 @@\n-      assert(handler->entry_code() == NULL ||\n+      assert(handler->entry_code() == nullptr ||\n@@ -204,1 +204,1 @@\n-        if (handler->entry_code() != NULL && handler->entry_code()->instructions_list()->length() > 1) {\n+        if (handler->entry_code() != nullptr && handler->entry_code()->instructions_list()->length() > 1) {\n@@ -258,1 +258,1 @@\n-  assert(block->lir() != NULL, \"must have LIR\");\n+  assert(block->lir() != nullptr, \"must have LIR\");\n@@ -338,1 +338,1 @@\n-  if (info->exception_handlers() != NULL) {\n+  if (info->exception_handlers() != nullptr) {\n@@ -347,1 +347,1 @@\n-  if (cinfo->exception_handlers() != NULL) {\n+  if (cinfo->exception_handlers() != nullptr) {\n@@ -354,1 +354,1 @@\n-  if (ss != NULL) return ss->state();\n+  if (ss != nullptr) return ss->state();\n@@ -360,1 +360,1 @@\n-  if (src == NULL)  return;\n+  if (src == nullptr)  return;\n@@ -367,2 +367,2 @@\n-  if (vstack == NULL)  return;\n-  if (_pending_non_safepoint != NULL) {\n+  if (vstack == nullptr)  return;\n+  if (_pending_non_safepoint != nullptr) {\n@@ -377,1 +377,1 @@\n-    _pending_non_safepoint = NULL;\n+    _pending_non_safepoint = nullptr;\n@@ -387,1 +387,1 @@\n-\/\/ Return NULL if n is too large.\n+\/\/ Return null if n is too large.\n@@ -392,1 +392,1 @@\n-    if (t == NULL)  break;\n+    if (t == nullptr)  break;\n@@ -395,1 +395,1 @@\n-  if (t == NULL)  return NULL;\n+  if (t == nullptr)  return nullptr;\n@@ -398,1 +398,1 @@\n-    if (tc == NULL)  return s;\n+    if (tc == nullptr)  return s;\n@@ -419,1 +419,1 @@\n-    if (s == NULL)  break;\n+    if (s == nullptr)  break;\n@@ -531,1 +531,1 @@\n-      assert(op->as_OpReturn() != NULL, \"sanity\");\n+      assert(op->as_OpReturn() != nullptr, \"sanity\");\n@@ -534,1 +534,1 @@\n-      if (ret_op->stub() != NULL) {\n+      if (ret_op->stub() != nullptr) {\n@@ -601,1 +601,1 @@\n-      assert(op->info() == NULL, \"not supported\");\n+      assert(op->info() == nullptr, \"not supported\");\n@@ -686,1 +686,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -793,1 +793,1 @@\n-      assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+      assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n@@ -796,1 +796,1 @@\n-      assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+      assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n@@ -805,1 +805,1 @@\n-    assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+    assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n@@ -818,1 +818,1 @@\n-      assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+      assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    if (_pending_non_safepoint != NULL) {\n+    if (_pending_non_safepoint != nullptr) {\n@@ -66,1 +66,1 @@\n-      _pending_non_safepoint = NULL;\n+      _pending_non_safepoint = nullptr;\n@@ -242,1 +242,1 @@\n-  void leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL);\n+  void leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = nullptr);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-\/\/ Call graph: move(NULL, c) -> move(c, b) -> move(b, a)\n+\/\/ Call graph: move(null, c) -> move(c, b) -> move(b, a)\n@@ -114,1 +114,1 @@\n-\/\/ Call graph: move(NULL, a) -> move(a, b) -> move(b, a)\n+\/\/ Call graph: move(null, a) -> move(a, b) -> move(b, a)\n@@ -124,1 +124,1 @@\n-    assert(_loop == NULL, \"only one loop valid!\");\n+    assert(_loop == nullptr, \"only one loop valid!\");\n@@ -134,1 +134,1 @@\n-    } else if (src != NULL) {\n+    } else if (src != nullptr) {\n@@ -148,2 +148,2 @@\n-      _loop = NULL;\n-      move(NULL, node);\n+      _loop = nullptr;\n+      move(nullptr, node);\n@@ -169,3 +169,3 @@\n-    node = vreg_table().at_grow(vreg_num, NULL);\n-    assert(node == NULL || node->operand() == opr, \"\");\n-    if (node == NULL) {\n+    node = vreg_table().at_grow(vreg_num, nullptr);\n+    assert(node == nullptr || node->operand() == opr, \"\");\n+    if (node == nullptr) {\n@@ -207,1 +207,1 @@\n-    _gen->_instruction_for_operand.at_put_grow(opr->vreg_number(), value(), NULL);\n+    _gen->_instruction_for_operand.at_put_grow(opr->vreg_number(), value(), nullptr);\n@@ -262,1 +262,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -267,2 +267,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_IntConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_IntConstant() != nullptr, \"type check\");\n@@ -274,2 +274,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_AddressConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_AddressConstant() != nullptr, \"type check\");\n@@ -281,2 +281,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_FloatConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_FloatConstant() != nullptr, \"type check\");\n@@ -288,2 +288,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_DoubleConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_DoubleConstant() != nullptr, \"type check\");\n@@ -295,2 +295,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_LongConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_LongConstant() != nullptr, \"type check\");\n@@ -313,1 +313,1 @@\n-  assert(block->lir() == NULL, \"LIR list already computed for this block\");\n+  assert(block->lir() == nullptr, \"LIR list already computed for this block\");\n@@ -354,1 +354,1 @@\n-  for (Instruction* instr = block; instr != NULL; instr = instr->next()) {\n+  for (Instruction* instr = block; instr != nullptr; instr = instr->next()) {\n@@ -358,1 +358,1 @@\n-  set_block(NULL);\n+  set_block(nullptr);\n@@ -377,1 +377,1 @@\n-         instr->as_Constant() != NULL || bailed_out(), \"invalid item set\");\n+         instr->as_Constant() != nullptr || bailed_out(), \"invalid item set\");\n@@ -385,2 +385,2 @@\n-  if ((instr->is_pinned() && instr->as_Phi() == NULL) || instr->operand()->is_valid()) {\n-    assert(instr->operand() != LIR_OprFact::illegalOpr || instr->as_Constant() != NULL, \"this root has not yet been visited\");\n+  if ((instr->is_pinned() && instr->as_Phi() == nullptr) || instr->operand()->is_valid()) {\n+    assert(instr->operand() != LIR_OprFact::illegalOpr || instr->as_Constant() != nullptr, \"this root has not yet been visited\");\n@@ -390,1 +390,1 @@\n-    \/\/ assert(instr->use_count() > 0 || instr->as_Phi() != NULL, \"leaf instruction must have a use\");\n+    \/\/ assert(instr->use_count() > 0 || instr->as_Phi() != nullptr, \"leaf instruction must have a use\");\n@@ -396,1 +396,1 @@\n-  assert(state != NULL, \"state must be defined\");\n+  assert(state != nullptr, \"state must be defined\");\n@@ -413,1 +413,1 @@\n-      if (!value->is_pinned() && value->as_Constant() == NULL && value->as_Local() == NULL) {\n+      if (!value->is_pinned() && value->as_Constant() == nullptr && value->as_Local() == nullptr) {\n@@ -440,1 +440,1 @@\n-          if (!value->is_pinned() && value->as_Constant() == NULL && value->as_Local() == NULL) {\n+          if (!value->is_pinned() && value->as_Constant() == nullptr && value->as_Local() == nullptr) {\n@@ -445,1 +445,1 @@\n-          \/\/ NULL out this local so that linear scan can assume that all non-NULL values are live.\n+          \/\/ null out this local so that linear scan can assume that all non-null values are live.\n@@ -452,1 +452,1 @@\n-  return new CodeEmitInfo(state, ignore_xhandler ? NULL : x->exception_handlers(), x->check_flag(Instruction::DeoptimizeOnException));\n+  return new CodeEmitInfo(state, ignore_xhandler ? nullptr : x->exception_handlers(), x->check_flag(Instruction::DeoptimizeOnException));\n@@ -466,2 +466,2 @@\n-    assert(info != NULL, \"info must be set if class is not loaded\");\n-    __ klass2reg_patch(NULL, r, info);\n+    assert(info != nullptr, \"info must be set if class is not loaded\");\n+    __ klass2reg_patch(nullptr, r, info);\n@@ -682,1 +682,1 @@\n-  if (type != NULL && type->is_array_klass() && type->is_loaded()) {\n+  if (type != nullptr && type->is_array_klass() && type->is_loaded()) {\n@@ -685,1 +685,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -691,2 +691,2 @@\n-  if (t == NULL) {\n-    return NULL;\n+  if (t == nullptr) {\n+    return nullptr;\n@@ -696,1 +696,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -710,1 +710,1 @@\n-  ciArrayKlass* expected_type = NULL;\n+  ciArrayKlass* expected_type = nullptr;\n@@ -716,1 +716,1 @@\n-    if (src_declared_type == NULL && (phi = src->as_Phi()) != NULL) {\n+    if (src_declared_type == nullptr && (phi = src->as_Phi()) != nullptr) {\n@@ -721,1 +721,1 @@\n-    if (dst_declared_type == NULL && (phi = dst->as_Phi()) != NULL) {\n+    if (dst_declared_type == nullptr && (phi = dst->as_Phi()) != nullptr) {\n@@ -725,1 +725,1 @@\n-    if (src_exact_type != NULL && src_exact_type == dst_exact_type) {\n+    if (src_exact_type != nullptr && src_exact_type == dst_exact_type) {\n@@ -729,1 +729,1 @@\n-    } else if (dst_exact_type != NULL && dst_exact_type->is_obj_array_klass()) {\n+    } else if (dst_exact_type != nullptr && dst_exact_type->is_obj_array_klass()) {\n@@ -731,2 +731,2 @@\n-      ciArrayKlass* src_type = NULL;\n-      if (src_exact_type != NULL && src_exact_type->is_obj_array_klass()) {\n+      ciArrayKlass* src_type = nullptr;\n+      if (src_exact_type != nullptr && src_exact_type->is_obj_array_klass()) {\n@@ -734,1 +734,1 @@\n-      } else if (src_declared_type != NULL && src_declared_type->is_obj_array_klass()) {\n+      } else if (src_declared_type != nullptr && src_declared_type->is_obj_array_klass()) {\n@@ -737,1 +737,1 @@\n-      if (src_type != NULL) {\n+      if (src_type != nullptr) {\n@@ -745,3 +745,3 @@\n-    if (expected_type == NULL) expected_type = dst_exact_type;\n-    if (expected_type == NULL) expected_type = src_declared_type;\n-    if (expected_type == NULL) expected_type = dst_declared_type;\n+    if (expected_type == nullptr) expected_type = dst_exact_type;\n+    if (expected_type == nullptr) expected_type = src_declared_type;\n+    if (expected_type == nullptr) expected_type = dst_declared_type;\n@@ -768,2 +768,2 @@\n-  if (expected_type != NULL) {\n-    Value length_limit = NULL;\n+  if (expected_type != nullptr) {\n+    Value length_limit = nullptr;\n@@ -772,1 +772,1 @@\n-    if (ifop != NULL) {\n+    if (ifop != nullptr) {\n@@ -784,1 +784,1 @@\n-    if (src_array != NULL) {\n+    if (src_array != nullptr) {\n@@ -786,1 +786,1 @@\n-      if (length_limit != NULL &&\n+      if (length_limit != nullptr &&\n@@ -794,1 +794,1 @@\n-    if (dst_array != NULL) {\n+    if (dst_array != nullptr) {\n@@ -796,1 +796,1 @@\n-      if (length_limit != NULL &&\n+      if (length_limit != nullptr &&\n@@ -814,1 +814,1 @@\n-    if (al != NULL) {\n+    if (al != nullptr) {\n@@ -843,1 +843,1 @@\n-    if (expected_type != NULL) {\n+    if (expected_type != nullptr) {\n@@ -911,1 +911,1 @@\n-    assert(method != NULL, \"method should be set if branch is profiled\");\n+    assert(method != nullptr, \"method should be set if branch is profiled\");\n@@ -913,1 +913,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -915,1 +915,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -966,1 +966,1 @@\n-  if (phi != NULL && cur_val != NULL && cur_val != phi && !phi->is_illegal()) {\n+  if (phi != nullptr && cur_val != nullptr && cur_val != phi && !phi->is_illegal()) {\n@@ -970,1 +970,1 @@\n-        if (op != NULL && op->type()->is_illegal()) {\n+        if (op != nullptr && op->type()->is_illegal()) {\n@@ -976,1 +976,1 @@\n-    if (cur_phi != NULL && cur_phi->is_illegal()) {\n+    if (cur_phi != nullptr && cur_phi->is_illegal()) {\n@@ -985,1 +985,1 @@\n-      assert(cur_val->as_Constant() != NULL || cur_val->as_Local() != NULL,\n+      assert(cur_val->as_Constant() != nullptr || cur_val->as_Local() != nullptr,\n@@ -1084,1 +1084,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1100,1 +1100,1 @@\n-  __ move_wide(LIR_OprFact::oopConst(NULL),\n+  __ move_wide(LIR_OprFact::oopConst(nullptr),\n@@ -1102,1 +1102,1 @@\n-  __ move_wide(LIR_OprFact::oopConst(NULL),\n+  __ move_wide(LIR_OprFact::oopConst(nullptr),\n@@ -1129,1 +1129,1 @@\n-  if (x->state_before() != NULL) {\n+  if (x->state_before() != nullptr) {\n@@ -1133,1 +1133,1 @@\n-    __ oop2reg_patch(NULL, reg, info);\n+    __ oop2reg_patch(nullptr, reg, info);\n@@ -1176,1 +1176,1 @@\n-    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), voidType, NULL);\n+    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), voidType, nullptr);\n@@ -1203,1 +1203,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1239,1 +1239,1 @@\n-                                     NULL); \/\/ NULL CodeEmitInfo results in a leaf call\n+                                     nullptr); \/\/ null CodeEmitInfo results in a leaf call\n@@ -1257,1 +1257,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1279,1 +1279,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1297,1 +1297,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1333,1 +1333,1 @@\n-  load_klass(value.result(), klass, NULL);\n+  load_klass(value.result(), klass, nullptr);\n@@ -1476,1 +1476,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -1479,1 +1479,1 @@\n-      assert(x->as_Phi() || x->as_Local() != NULL, \"only for Phi and Local\");\n+      assert(x->as_Phi() || x->as_Local() != nullptr, \"only for Phi and Local\");\n@@ -1482,1 +1482,1 @@\n-      _instruction_for_operand.at_put_grow(x->operand()->vreg_number(), x, NULL);\n+      _instruction_for_operand.at_put_grow(x->operand()->vreg_number(), x, nullptr);\n@@ -1493,1 +1493,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1501,1 +1501,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1616,1 +1616,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1618,1 +1618,1 @@\n-    assert(x->explicit_null_check() == NULL, \"can't fold null check into patching field access\");\n+    assert(x->explicit_null_check() == nullptr, \"can't fold null check into patching field access\");\n@@ -1622,1 +1622,1 @@\n-    if (nc == NULL) {\n+    if (nc == nullptr) {\n@@ -1661,1 +1661,1 @@\n-    \/\/ If the class is not loaded and the object is NULL, we need to deoptimize to throw a\n+    \/\/ If the class is not loaded and the object is null, we need to deoptimize to throw a\n@@ -1675,1 +1675,1 @@\n-                  value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);\n+                  value.result(), info != nullptr ? new CodeEmitInfo(info) : nullptr, info);\n@@ -1681,1 +1681,1 @@\n-  bool use_length = x->length() != NULL;\n+  bool use_length = x->length() != nullptr;\n@@ -1683,1 +1683,1 @@\n-  bool needs_store_check = obj_store && (x->value()->as_Constant() == NULL ||\n+  bool needs_store_check = obj_store && (x->value()->as_Constant() == nullptr ||\n@@ -1712,1 +1712,1 @@\n-  CodeEmitInfo* null_check_info = NULL;\n+  CodeEmitInfo* null_check_info = nullptr;\n@@ -1724,1 +1724,1 @@\n-      null_check_info = NULL;\n+      null_check_info = nullptr;\n@@ -1739,1 +1739,1 @@\n-                  NULL, null_check_info);\n+                  nullptr, null_check_info);\n@@ -1825,1 +1825,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1827,1 +1827,1 @@\n-    assert(x->explicit_null_check() == NULL, \"can't fold null check into patching field access\");\n+    assert(x->explicit_null_check() == nullptr, \"can't fold null check into patching field access\");\n@@ -1831,1 +1831,1 @@\n-    if (nc == NULL) {\n+    if (nc == nullptr) {\n@@ -1857,1 +1857,1 @@\n-      __ move(LIR_OprFact::oopConst(NULL), obj);\n+      __ move(LIR_OprFact::oopConst(nullptr), obj);\n@@ -1860,1 +1860,1 @@\n-    \/\/ If the class is not loaded and the object is NULL, we need to deoptimize to throw a\n+    \/\/ If the class is not loaded and the object is null, we need to deoptimize to throw a\n@@ -1876,1 +1876,1 @@\n-                 info ? new CodeEmitInfo(info) : NULL, info);\n+                 info ? new CodeEmitInfo(info) : nullptr, info);\n@@ -1952,1 +1952,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1955,1 +1955,1 @@\n-    if (nc == NULL) {\n+    if (nc == nullptr) {\n@@ -1962,1 +1962,1 @@\n-      __ move(LIR_OprFact::oopConst(NULL), obj);\n+      __ move(LIR_OprFact::oopConst(nullptr), obj);\n@@ -1971,1 +1971,1 @@\n-  bool use_length = x->length() != NULL;\n+  bool use_length = x->length() != nullptr;\n@@ -1991,1 +1991,1 @@\n-  CodeEmitInfo* null_check_info = NULL;\n+  CodeEmitInfo* null_check_info = nullptr;\n@@ -1994,1 +1994,1 @@\n-    if (nc != NULL) {\n+    if (nc != nullptr) {\n@@ -2001,1 +2001,1 @@\n-      __ move(LIR_OprFact::oopConst(NULL), obj);\n+      __ move(LIR_OprFact::oopConst(nullptr), obj);\n@@ -2017,1 +2017,1 @@\n-      null_check_info = NULL;\n+      null_check_info = nullptr;\n@@ -2026,1 +2026,1 @@\n-                 NULL, null_check_info);\n+                 nullptr, null_check_info);\n@@ -2070,1 +2070,1 @@\n-    if (throw_type == NULL) {\n+    if (throw_type == nullptr) {\n@@ -2074,1 +2074,1 @@\n-    if (throw_type != NULL && throw_type->is_instance_klass()) {\n+    if (throw_type != nullptr && throw_type->is_instance_klass()) {\n@@ -2084,1 +2084,1 @@\n-  if (x->exception()->as_NewInstance() == NULL && x->exception()->as_ExceptionObject() == NULL) {\n+  if (x->exception()->as_NewInstance() == nullptr && x->exception()->as_ExceptionObject() == nullptr) {\n@@ -2322,1 +2322,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2324,1 +2324,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -2380,1 +2380,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2382,1 +2382,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -2448,1 +2448,1 @@\n-    assert(method != NULL, \"method should be set if branch is profiled\");\n+    assert(method != nullptr, \"method should be set if branch is profiled\");\n@@ -2450,1 +2450,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2452,1 +2452,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -2497,1 +2497,1 @@\n-  ciKlass* result = NULL;\n+  ciKlass* result = nullptr;\n@@ -2506,1 +2506,1 @@\n-  ciKlass* exact_klass = NULL;\n+  ciKlass* exact_klass = nullptr;\n@@ -2512,1 +2512,1 @@\n-    if (type == NULL) {\n+    if (type == nullptr) {\n@@ -2516,2 +2516,2 @@\n-    assert(type == NULL || type->is_klass(), \"type should be class\");\n-    exact_klass = (type != NULL && type->is_loaded()) ? (ciKlass*)type : NULL;\n+    assert(type == nullptr || type->is_klass(), \"type should be class\");\n+    exact_klass = (type != nullptr && type->is_loaded()) ? (ciKlass*)type : nullptr;\n@@ -2519,1 +2519,1 @@\n-    do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n+    do_update = exact_klass == nullptr || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n@@ -2526,1 +2526,1 @@\n-  ciKlass* exact_signature_k = NULL;\n+  ciKlass* exact_signature_k = nullptr;\n@@ -2530,1 +2530,1 @@\n-    if (exact_signature_k == NULL) {\n+    if (exact_signature_k == nullptr) {\n@@ -2538,1 +2538,1 @@\n-    \/\/ exact_klass and exact_signature_k can be both non NULL but\n+    \/\/ exact_klass and exact_signature_k can be both non null but\n@@ -2541,1 +2541,1 @@\n-    if (exact_klass == NULL && exact_signature_k != NULL && exact_klass != exact_signature_k) {\n+    if (exact_klass == nullptr && exact_signature_k != nullptr && exact_klass != exact_signature_k) {\n@@ -2546,1 +2546,1 @@\n-    if (callee_signature_k != NULL &&\n+    if (callee_signature_k != nullptr &&\n@@ -2549,1 +2549,1 @@\n-      if (improved_klass == NULL) {\n+      if (improved_klass == nullptr) {\n@@ -2552,1 +2552,1 @@\n-      if (exact_klass == NULL && improved_klass != NULL && exact_klass != improved_klass) {\n+      if (exact_klass == nullptr && improved_klass != nullptr && exact_klass != improved_klass) {\n@@ -2556,1 +2556,1 @@\n-    do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n+    do_update = exact_klass == nullptr || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n@@ -2575,1 +2575,1 @@\n-                  value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != NULL);\n+                  value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != nullptr);\n@@ -2584,1 +2584,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2586,1 +2586,1 @@\n-    if (md->parameters_type_data() != NULL) {\n+    if (md->parameters_type_data() != nullptr) {\n@@ -2599,1 +2599,1 @@\n-                                        profiled_k, local, mdp, false, local->declared_type()->as_klass(), NULL);\n+                                        profiled_k, local, mdp, false, local->declared_type()->as_klass(), nullptr);\n@@ -2601,1 +2601,1 @@\n-          if (exact != NULL) {\n+          if (exact != nullptr) {\n@@ -2641,1 +2641,1 @@\n-    assert(local != NULL, \"Locals for incoming arguments must have been created\");\n+    assert(local != nullptr, \"Locals for incoming arguments must have been created\");\n@@ -2647,1 +2647,1 @@\n-    _instruction_for_operand.at_put_grow(dest->vreg_number(), local, NULL);\n+    _instruction_for_operand.at_put_grow(dest->vreg_number(), local, nullptr);\n@@ -2660,1 +2660,1 @@\n-    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), voidType, NULL);\n+    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), voidType, nullptr);\n@@ -2670,1 +2670,1 @@\n-      assert(receiver != NULL, \"must already exist\");\n+      assert(receiver != nullptr, \"must already exist\");\n@@ -2679,1 +2679,1 @@\n-      CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, x->check_flag(Instruction::DeoptimizeOnException));\n+      CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), nullptr, x->check_flag(Instruction::DeoptimizeOnException));\n@@ -2682,2 +2682,2 @@\n-      \/\/ receiver is guaranteed non-NULL so don't need CodeEmitInfo\n-      __ lock_object(syncTempOpr(), obj, lock, new_register(T_OBJECT), slow_path, NULL);\n+      \/\/ receiver is guaranteed non-null so don't need CodeEmitInfo\n+      __ lock_object(syncTempOpr(), obj, lock, new_register(T_OBJECT), slow_path, nullptr);\n@@ -2689,1 +2689,1 @@\n-    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, false);\n+    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), nullptr, false);\n@@ -3035,1 +3035,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -3037,1 +3037,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -3056,1 +3056,1 @@\n-        ciSignatureStream callee_signature_stream(callee_signature, has_receiver ? x->callee()->holder() : NULL);\n+        ciSignatureStream callee_signature_stream(callee_signature, has_receiver ? x->callee()->holder() : nullptr);\n@@ -3059,1 +3059,1 @@\n-        ciSignature* signature_at_call = NULL;\n+        ciSignature* signature_at_call = nullptr;\n@@ -3070,1 +3070,1 @@\n-          if (exact != NULL) {\n+          if (exact != nullptr) {\n@@ -3091,1 +3091,1 @@\n-    if (md != NULL) {\n+    if (md != nullptr) {\n@@ -3093,1 +3093,1 @@\n-      if (parameters_type_data != NULL) {\n+      if (parameters_type_data != nullptr) {\n@@ -3098,1 +3098,1 @@\n-        ciSignatureStream sig_stream(sig, has_receiver ? x->callee()->holder() : NULL);\n+        ciSignatureStream sig_stream(sig, has_receiver ? x->callee()->holder() : nullptr);\n@@ -3107,1 +3107,1 @@\n-        if (arg == NULL || !Bytecodes::has_receiver(bc)) {\n+        if (arg == nullptr || !Bytecodes::has_receiver(bc)) {\n@@ -3117,1 +3117,1 @@\n-                                        profiled_k, arg, mdp, not_null, sig_stream.next_klass(), NULL);\n+                                        profiled_k, arg, mdp, not_null, sig_stream.next_klass(), nullptr);\n@@ -3119,1 +3119,1 @@\n-          if (exact != NULL) {\n+          if (exact != nullptr) {\n@@ -3128,1 +3128,1 @@\n-                x->recv() != NULL && Bytecodes::has_receiver(bc)) {\n+                x->recv() != nullptr && Bytecodes::has_receiver(bc)) {\n@@ -3156,1 +3156,1 @@\n-  if (x->recv() != NULL || x->nb_profiled_args() > 0) {\n+  if (x->recv() != nullptr || x->nb_profiled_args() > 0) {\n@@ -3160,1 +3160,1 @@\n-  if (x->recv() != NULL) {\n+  if (x->recv() != nullptr) {\n@@ -3172,1 +3172,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -3174,1 +3174,1 @@\n-  if (data != NULL) {\n+  if (data != nullptr) {\n@@ -3180,1 +3180,1 @@\n-    ciSignature* signature_at_call = NULL;\n+    ciSignature* signature_at_call = nullptr;\n@@ -3191,1 +3191,1 @@\n-    if (exact != NULL) {\n+    if (exact != nullptr) {\n@@ -3263,1 +3263,1 @@\n-    if (counters_adr == NULL) {\n+    if (counters_adr == nullptr) {\n@@ -3276,1 +3276,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -3330,1 +3330,1 @@\n-  LIR_Opr result = call_runtime(signature, args, x->entry(), x->type(), NULL);\n+  LIR_Opr result = call_runtime(signature, args, x->entry(), x->type(), nullptr);\n@@ -3562,1 +3562,1 @@\n-  null_check_info = NULL;\n+  null_check_info = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":169,"deletions":169,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,1 @@\n-      _instruction_for_operand.at_put_grow(opr->vreg_number(), x, NULL);\n+      _instruction_for_operand.at_put_grow(opr->vreg_number(), x, nullptr);\n@@ -292,1 +292,1 @@\n-                       CodeEmitInfo* patch_info = NULL, CodeEmitInfo* store_emit_info = NULL);\n+                       CodeEmitInfo* patch_info = nullptr, CodeEmitInfo* store_emit_info = nullptr);\n@@ -296,1 +296,1 @@\n-                      CodeEmitInfo* patch_info = NULL, CodeEmitInfo* load_emit_info = NULL);\n+                      CodeEmitInfo* patch_info = nullptr, CodeEmitInfo* load_emit_info = nullptr);\n@@ -346,1 +346,1 @@\n-  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp, CodeEmitInfo* info = NULL);\n+  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp, CodeEmitInfo* info = nullptr);\n@@ -358,1 +358,1 @@\n-  void arithmetic_op_long (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL);\n+  void arithmetic_op_long (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = nullptr);\n@@ -623,1 +623,1 @@\n-    set_instruction(NULL);\n+    set_instruction(nullptr);\n@@ -629,1 +629,1 @@\n-    if (_value != NULL) {\n+    if (_value != nullptr) {\n@@ -669,1 +669,1 @@\n-  bool is_constant() const { return value()->as_Constant() != NULL; }\n+  bool is_constant() const { return value()->as_Constant() != nullptr; }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n- , _new_intervals_from_allocation(NULL)\n- , _sorted_intervals(NULL)\n+ , _new_intervals_from_allocation(nullptr)\n+ , _sorted_intervals(nullptr)\n@@ -96,1 +96,1 @@\n- , _fpu_stack_allocator(NULL)\n+ , _fpu_stack_allocator(nullptr)\n@@ -99,4 +99,4 @@\n-  assert(this->ir() != NULL,          \"check if valid\");\n-  assert(this->compilation() != NULL, \"check if valid\");\n-  assert(this->gen() != NULL,         \"check if valid\");\n-  assert(this->frame_map() != NULL,   \"check if valid\");\n+  assert(this->ir() != nullptr,          \"check if valid\");\n+  assert(this->compilation() != nullptr, \"check if valid\");\n+  assert(this->gen() != nullptr,         \"check if valid\");\n+  assert(this->frame_map() != nullptr,   \"check if valid\");\n@@ -271,1 +271,1 @@\n-  assert(_intervals.at(reg_num) == NULL, \"overwriting existing interval\");\n+  assert(_intervals.at(reg_num) == nullptr, \"overwriting existing interval\");\n@@ -289,1 +289,1 @@\n-  if (new_intervals == NULL) {\n+  if (new_intervals == nullptr) {\n@@ -396,1 +396,1 @@\n-  create_unhandled_lists(&interval, &temp_list, must_store_at_definition, NULL);\n+  create_unhandled_lists(&interval, &temp_list, must_store_at_definition, nullptr);\n@@ -399,1 +399,1 @@\n-  Interval* prev = NULL;\n+  Interval* prev = nullptr;\n@@ -403,1 +403,1 @@\n-    if (prev != NULL) {\n+    if (prev != nullptr) {\n@@ -435,1 +435,1 @@\n-        assert(op->as_Op1() != NULL, \"move must be LIR_Op1\");\n+        assert(op->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -444,1 +444,1 @@\n-          instructions->at_put(j, NULL); \/\/ NULL-instructions are deleted by assign_reg_num\n+          instructions->at_put(j, nullptr); \/\/ null-instructions are deleted by assign_reg_num\n@@ -501,2 +501,2 @@\n-  _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);\n-  _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);\n+  _lir_ops = LIR_OpArray(num_instructions, num_instructions, nullptr);\n+  _block_of_op = BlockBeginArray(num_instructions, num_instructions, nullptr);\n@@ -543,2 +543,2 @@\n-  assert(con == NULL || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands\");\n-  assert(con != NULL || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n+  assert(con == nullptr || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands\");\n+  assert(con != nullptr || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n@@ -546,1 +546,1 @@\n-  if ((con == NULL || con->is_pinned()) && opr->is_register()) {\n+  if ((con == nullptr || con->is_pinned()) && opr->is_register()) {\n@@ -842,1 +842,1 @@\n-        tty->print_cr(\"* vreg %d (HIR instruction %c%d)\", i, instr == NULL ? ' ' : instr->type()->tchar(), instr == NULL ? 0 : instr->id());\n+        tty->print_cr(\"* vreg %d (HIR instruction %c%d)\", i, instr == nullptr ? ' ' : instr->type()->tchar(), instr == nullptr ? 0 : instr->id());\n@@ -873,1 +873,1 @@\n-  if ((con == NULL || con->is_pinned()) && opr->is_register()) {\n+  if ((con == nullptr || con->is_pinned()) && opr->is_register()) {\n@@ -943,1 +943,1 @@\n-  if (interval != NULL) {\n+  if (interval != nullptr) {\n@@ -988,1 +988,1 @@\n-  if (interval == NULL) {\n+  if (interval == nullptr) {\n@@ -1003,1 +1003,1 @@\n-  if (interval == NULL) {\n+  if (interval == nullptr) {\n@@ -1022,1 +1022,1 @@\n-    assert(op->as_Op1() != NULL, \"lir_move must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"lir_move must be LIR_Op1\");\n@@ -1058,1 +1058,1 @@\n-    assert(op->as_Op1() != NULL, \"lir_move must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"lir_move must be LIR_Op1\");\n@@ -1103,1 +1103,1 @@\n-          assert(op->as_Op2() != NULL, \"must be LIR_Op2\");\n+          assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n@@ -1121,1 +1121,1 @@\n-          assert(op->as_Op2() != NULL, \"must be LIR_Op2\");\n+          assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n@@ -1145,1 +1145,1 @@\n-        assert(op->as_Op2() != NULL, \"must be LIR_Op2\");\n+        assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n@@ -1169,1 +1169,1 @@\n-    assert(op->as_Op1() != NULL, \"must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"must be LIR_Op1\");\n@@ -1205,1 +1205,1 @@\n-    assert(op->as_Op1() != NULL, \"must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"must be LIR_Op1\");\n@@ -1210,1 +1210,1 @@\n-      if (address != NULL) {\n+      if (address != nullptr) {\n@@ -1226,1 +1226,1 @@\n-      assert(op->as_Op1() != NULL, \"lir_move, lir_convert must be LIR_Op1\");\n+      assert(op->as_Op1() != nullptr, \"lir_move, lir_convert must be LIR_Op1\");\n@@ -1235,1 +1235,1 @@\n-        if (from != NULL && to != NULL) {\n+        if (from != nullptr && to != nullptr) {\n@@ -1243,1 +1243,1 @@\n-      assert(op->as_Op4() != NULL, \"lir_cmove must be LIR_Op4\");\n+      assert(op->as_Op4() != nullptr, \"lir_cmove must be LIR_Op4\");\n@@ -1252,1 +1252,1 @@\n-        if (from != NULL && to != NULL) {\n+        if (from != nullptr && to != nullptr) {\n@@ -1272,1 +1272,1 @@\n-  _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);\n+  _intervals.at_put_grow(num_virtual_regs() - 1, nullptr, nullptr);\n@@ -1424,1 +1424,1 @@\n-    if (interval != NULL) {\n+    if (interval != nullptr) {\n@@ -1434,2 +1434,2 @@\n-  if (*a != NULL) {\n-    if (*b != NULL) {\n+  if (*a != nullptr) {\n+    if (*b != nullptr) {\n@@ -1441,1 +1441,1 @@\n-    if (*b != NULL) {\n+    if (*b != nullptr) {\n@@ -1494,1 +1494,1 @@\n-    if (it != NULL) {\n+    if (it != nullptr) {\n@@ -1508,1 +1508,1 @@\n-    if (interval != NULL) {\n+    if (interval != nullptr) {\n@@ -1516,1 +1516,1 @@\n-      \"Sorted list should contain the same amount of non-NULL intervals as unsorted list\");\n+      \"Sorted list should contain the same amount of non-null intervals as unsorted list\");\n@@ -1523,1 +1523,1 @@\n-  if (*prev != NULL) {\n+  if (*prev != nullptr) {\n@@ -1536,2 +1536,2 @@\n-  Interval* list1_prev = NULL;\n-  Interval* list2_prev = NULL;\n+  Interval* list1_prev = nullptr;\n+  Interval* list2_prev = nullptr;\n@@ -1543,1 +1543,1 @@\n-    if (v == NULL) continue;\n+    if (v == nullptr) continue;\n@@ -1547,1 +1547,1 @@\n-    } else if (is_list2 == NULL || is_list2(v)) {\n+    } else if (is_list2 == nullptr || is_list2(v)) {\n@@ -1552,2 +1552,2 @@\n-  if (list1_prev != NULL) list1_prev->set_next(Interval::end());\n-  if (list2_prev != NULL) list2_prev->set_next(Interval::end());\n+  if (list1_prev != nullptr) list1_prev->set_next(Interval::end());\n+  if (list2_prev != nullptr) list2_prev->set_next(Interval::end());\n@@ -1555,2 +1555,2 @@\n-  assert(list1_prev == NULL || list1_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n-  assert(list2_prev == NULL || list2_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n+  assert(list1_prev == nullptr || list1_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n+  assert(list2_prev == nullptr || list2_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n@@ -1578,1 +1578,1 @@\n-  \/\/ calc number of items for sorted list (sorted list must not contain NULL values)\n+  \/\/ calc number of items for sorted list (sorted list must not contain null values)\n@@ -1580,1 +1580,1 @@\n-    if (unsorted_list->at(unsorted_idx) != NULL) {\n+    if (unsorted_list->at(unsorted_idx) != nullptr) {\n@@ -1584,1 +1584,1 @@\n-  IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);\n+  IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, nullptr);\n@@ -1591,1 +1591,1 @@\n-    if (cur_interval != NULL) {\n+    if (cur_interval != nullptr) {\n@@ -1625,1 +1625,1 @@\n-  int new_len = new_list == NULL ? 0 : new_list->length();\n+  int new_len = new_list == nullptr ? 0 : new_list->length();\n@@ -1638,1 +1638,1 @@\n-  IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);\n+  IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, nullptr);\n@@ -1701,1 +1701,1 @@\n-\/\/ instead of returning NULL\n+\/\/ instead of returning null\n@@ -1704,1 +1704,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1712,1 +1712,1 @@\n-  BAILOUT_(\"LinearScan: interval is NULL\", result);\n+  BAILOUT_(\"LinearScan: interval is null\", result);\n@@ -1718,1 +1718,1 @@\n-  assert(interval_at(reg_num) != NULL, \"no interval found\");\n+  assert(interval_at(reg_num) != nullptr, \"no interval found\");\n@@ -1725,1 +1725,1 @@\n-  assert(interval_at(reg_num) != NULL, \"no interval found\");\n+  assert(interval_at(reg_num) != nullptr, \"no interval found\");\n@@ -1732,1 +1732,1 @@\n-  assert(interval_at(reg_num) != NULL, \"no interval found\");\n+  assert(interval_at(reg_num) != nullptr, \"no interval found\");\n@@ -1766,1 +1766,1 @@\n-    if (branch != NULL) {\n+    if (branch != nullptr) {\n@@ -1777,1 +1777,1 @@\n-    assert(from_block->lir()->instructions_list()->at(0)->as_OpLabel() != NULL, \"block does not start with a label\");\n+    assert(from_block->lir()->instructions_list()->at(0)->as_OpLabel() != nullptr, \"block does not start with a label\");\n@@ -1863,1 +1863,1 @@\n-  if (interval_at(reg_num) == NULL) {\n+  if (interval_at(reg_num) == nullptr) {\n@@ -1936,1 +1936,1 @@\n-  if (interval_at(reg_num) == NULL) {\n+  if (interval_at(reg_num) == nullptr) {\n@@ -1946,1 +1946,1 @@\n-  if (phi != NULL) {\n+  if (phi != nullptr) {\n@@ -1958,1 +1958,1 @@\n-    if (con != NULL && (!con->is_pinned() || con->operand()->is_constant())) {\n+    if (con != nullptr && (!con->is_pinned() || con->operand()->is_constant())) {\n@@ -1986,1 +1986,1 @@\n-  assert(handler->entry_code() == NULL, \"code already present\");\n+  assert(handler->entry_code() == nullptr, \"code already present\");\n@@ -1992,1 +1992,1 @@\n-    resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);\n+    resolve_exception_edge(handler, throwing_op_id, r, nullptr, move_resolver);\n@@ -2218,1 +2218,1 @@\n-  assert(interval != NULL, \"interval must exist\");\n+  assert(interval != nullptr, \"interval must exist\");\n@@ -2228,1 +2228,1 @@\n-      if (branch != NULL) {\n+      if (branch != nullptr) {\n@@ -2268,1 +2268,1 @@\n-  if (values == NULL) {\n+  if (values == nullptr) {\n@@ -2283,1 +2283,1 @@\n-  if (values == NULL) {\n+  if (values == nullptr) {\n@@ -2332,2 +2332,2 @@\n-  if (d1->locals() != NULL) {\n-    assert(d1->locals() != NULL && d2->locals() != NULL, \"not equal\");\n+  if (d1->locals() != nullptr) {\n+    assert(d1->locals() != nullptr && d2->locals() != nullptr, \"not equal\");\n@@ -2339,1 +2339,1 @@\n-    assert(d1->locals() == NULL && d2->locals() == NULL, \"not equal\");\n+    assert(d1->locals() == nullptr && d2->locals() == nullptr, \"not equal\");\n@@ -2342,2 +2342,2 @@\n-  if (d1->expressions() != NULL) {\n-    assert(d1->expressions() != NULL && d2->expressions() != NULL, \"not equal\");\n+  if (d1->expressions() != nullptr) {\n+    assert(d1->expressions() != nullptr && d2->expressions() != nullptr, \"not equal\");\n@@ -2349,1 +2349,1 @@\n-    assert(d1->expressions() == NULL && d2->expressions() == NULL, \"not equal\");\n+    assert(d1->expressions() == nullptr && d2->expressions() == nullptr, \"not equal\");\n@@ -2352,2 +2352,2 @@\n-  if (d1->monitors() != NULL) {\n-    assert(d1->monitors() != NULL && d2->monitors() != NULL, \"not equal\");\n+  if (d1->monitors() != nullptr) {\n+    assert(d1->monitors() != nullptr && d2->monitors() != nullptr, \"not equal\");\n@@ -2359,1 +2359,1 @@\n-    assert(d1->monitors() == NULL && d2->monitors() == NULL, \"not equal\");\n+    assert(d1->monitors() == nullptr && d2->monitors() == nullptr, \"not equal\");\n@@ -2362,2 +2362,2 @@\n-  if (d1->caller() != NULL) {\n-    assert(d1->caller() != NULL && d2->caller() != NULL, \"not equal\");\n+  if (d1->caller() != nullptr) {\n+    assert(d1->caller() != nullptr && d2->caller() != nullptr, \"not equal\");\n@@ -2366,1 +2366,1 @@\n-    assert(d1->caller() == NULL && d2->caller() == NULL, \"not equal\");\n+    assert(d1->caller() == nullptr && d2->caller() == nullptr, \"not equal\");\n@@ -2406,1 +2406,1 @@\n-  create_unhandled_lists(&oop_intervals, &non_oop_intervals, is_oop_interval, NULL);\n+  create_unhandled_lists(&oop_intervals, &non_oop_intervals, is_oop_interval, nullptr);\n@@ -2467,1 +2467,1 @@\n-  assert(info->stack() != NULL, \"CodeEmitInfo must always have a stack\");\n+  assert(info->stack() != nullptr, \"CodeEmitInfo must always have a stack\");\n@@ -2499,1 +2499,1 @@\n-    if (info->_oop_map == NULL) {\n+    if (info->_oop_map == nullptr) {\n@@ -2516,1 +2516,1 @@\n-ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (mtCompiler) ConstantOopWriteValue(NULL);\n+ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (mtCompiler) ConstantOopWriteValue(nullptr);\n@@ -2527,1 +2527,1 @@\n-  _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);\n+  _scope_value_cache = ScopeValueArray(cache_size, cache_size, nullptr);\n@@ -2560,1 +2560,1 @@\n-      if (value == NULL) {\n+      if (value == nullptr) {\n@@ -2620,1 +2620,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -2638,1 +2638,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -2666,1 +2666,1 @@\n-    assert(_fpu_stack_allocator != NULL, \"must be present\");\n+    assert(_fpu_stack_allocator != nullptr, \"must be present\");\n@@ -2713,1 +2713,1 @@\n-      if (!frame_map()->locations_for_slot(opr->double_stack_ix(), loc_type, &loc1, NULL)) {\n+      if (!frame_map()->locations_for_slot(opr->double_stack_ix(), loc_type, &loc1, nullptr)) {\n@@ -2779,1 +2779,1 @@\n-      assert(_fpu_stack_allocator != NULL, \"must be present\");\n+      assert(_fpu_stack_allocator != nullptr, \"must be present\");\n@@ -2811,2 +2811,2 @@\n-      first = NULL;\n-      second = NULL;\n+      first = nullptr;\n+      second = nullptr;\n@@ -2815,1 +2815,1 @@\n-    assert(first != NULL && second != NULL, \"must be set\");\n+    assert(first != nullptr && second != nullptr, \"must be set\");\n@@ -2830,1 +2830,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2834,2 +2834,2 @@\n-    assert(con == NULL || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands (or illegal if constant is optimized away)\");\n-    assert(con != NULL || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n+    assert(con == nullptr || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands (or illegal if constant is optimized away)\");\n+    assert(con != nullptr || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n@@ -2837,1 +2837,1 @@\n-    if (con != NULL && !con->is_pinned() && !opr->is_constant()) {\n+    if (con != nullptr && !con->is_pinned() && !opr->is_constant()) {\n@@ -2855,1 +2855,1 @@\n-        if (block->lir()->instructions_list()->last()->as_OpBranch() != NULL) {\n+        if (block->lir()->instructions_list()->last()->as_OpBranch() != nullptr) {\n@@ -2873,1 +2873,1 @@\n-      assert(value->as_Constant() != NULL, \"all other instructions have only virtual operands\");\n+      assert(value->as_Constant() != nullptr, \"all other instructions have only virtual operands\");\n@@ -2887,1 +2887,1 @@\n-  IRScopeDebugInfo* caller_debug_info = NULL;\n+  IRScopeDebugInfo* caller_debug_info = nullptr;\n@@ -2890,1 +2890,1 @@\n-  if (caller_state != NULL) {\n+  if (caller_state != nullptr) {\n@@ -2898,3 +2898,3 @@\n-  GrowableArray<ScopeValue*>*   locals      = NULL;\n-  GrowableArray<ScopeValue*>*   expressions = NULL;\n-  GrowableArray<MonitorValue*>* monitors    = NULL;\n+  GrowableArray<ScopeValue*>*   locals      = nullptr;\n+  GrowableArray<ScopeValue*>*   expressions = nullptr;\n+  GrowableArray<MonitorValue*>* monitors    = nullptr;\n@@ -2945,1 +2945,1 @@\n-    int lock_offset = cur_state->caller_state() != NULL ? cur_state->caller_state()->total_locks_size() : 0;\n+    int lock_offset = cur_state->caller_state() != nullptr ? cur_state->caller_state()->total_locks_size() : 0;\n@@ -2962,1 +2962,1 @@\n-  assert(innermost_scope != NULL && innermost_state != NULL, \"why is it missing?\");\n+  assert(innermost_scope != nullptr && innermost_state != nullptr, \"why is it missing?\");\n@@ -2966,1 +2966,1 @@\n-  if (info->_scope_debug_info == NULL) {\n+  if (info->_scope_debug_info == nullptr) {\n@@ -2983,1 +2983,1 @@\n-    if (op == NULL) {  \/\/ this can happen when spill-moves are removed in eliminate_spill_moves\n+    if (op == nullptr) { \/\/ this can happen when spill-moves are removed in eliminate_spill_moves\n@@ -3010,2 +3010,2 @@\n-          if (handler->entry_code() != NULL) {\n-            assign_reg_num(handler->entry_code()->instructions_list(), NULL);\n+          if (handler->entry_code() != nullptr) {\n+            assign_reg_num(handler->entry_code()->instructions_list(), nullptr);\n@@ -3019,1 +3019,1 @@\n-      assert(iw != NULL, \"needed for compute_oop_map\");\n+      assert(iw != nullptr, \"needed for compute_oop_map\");\n@@ -3042,1 +3042,1 @@\n-      assert(op->as_Op1() != NULL, \"move must be LIR_Op1\");\n+      assert(op->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -3049,1 +3049,1 @@\n-        instructions->at_put(j, NULL);\n+        instructions->at_put(j, nullptr);\n@@ -3060,1 +3060,1 @@\n-      if (op != NULL) {\n+      if (op != nullptr) {\n@@ -3183,1 +3183,1 @@\n-      if (interval != NULL) {\n+      if (interval != nullptr) {\n@@ -3257,1 +3257,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3291,1 +3291,1 @@\n-    if (i1 == NULL) continue;\n+    if (i1 == nullptr) continue;\n@@ -3338,1 +3338,1 @@\n-      if (i2 == NULL || (i2->from() == 1 && i2->to() == 2)) continue;\n+      if (i2 == nullptr || (i2->from() == 1 && i2->to() == 2)) continue;\n@@ -3360,1 +3360,1 @@\n-  create_unhandled_lists(&fixed_intervals, &other_intervals, is_precolored_cpu_interval, NULL);\n+  create_unhandled_lists(&fixed_intervals, &other_intervals, is_precolored_cpu_interval, nullptr);\n@@ -3388,1 +3388,1 @@\n-        if (branch != NULL && branch->stub() != NULL && branch->stub()->is_exception_throw_stub()) {\n+        if (branch != nullptr && branch->stub() != nullptr && branch->stub()->is_exception_throw_stub()) {\n@@ -3441,1 +3441,1 @@\n-              assert(interval != NULL, \"no interval\");\n+              assert(interval != nullptr, \"no interval\");\n@@ -3480,1 +3480,1 @@\n-      assert(value != NULL, \"all intervals live across block boundaries must have Value\");\n+      assert(value != nullptr, \"all intervals live across block boundaries must have Value\");\n@@ -3483,1 +3483,1 @@\n-      \/\/ TKR assert(value->as_Constant() == NULL || value->is_pinned(), \"only pinned constants can be alive across block boundaries\");\n+      \/\/ TKR assert(value->as_Constant() == nullptr || value->is_pinned(), \"only pinned constants can be alive across block boundaries\");\n@@ -3523,1 +3523,1 @@\n-    , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)\n+    , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), nullptr)\n@@ -3540,1 +3540,1 @@\n-  IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);\n+  IntervalList* input_state = new IntervalList(input_state_len, input_state_len, nullptr);\n@@ -3578,1 +3578,1 @@\n-      if (input_state->at(i) != NULL) {\n+      if (input_state->at(i) != nullptr) {\n@@ -3603,1 +3603,1 @@\n-  if (xhandler->entry_code() != NULL) {\n+  if (xhandler->entry_code() != nullptr) {\n@@ -3612,1 +3612,1 @@\n-  if (saved_state != NULL) {\n+  if (saved_state != nullptr) {\n@@ -3621,1 +3621,1 @@\n-        if (saved_state->at(i) != NULL) {\n+        if (saved_state->at(i) != nullptr) {\n@@ -3626,1 +3626,1 @@\n-          saved_state->at_put(i, NULL);\n+          saved_state->at_put(i, nullptr);\n@@ -3660,1 +3660,1 @@\n-    if (interval != NULL) {\n+    if (interval != nullptr) {\n@@ -3662,2 +3662,2 @@\n-    } else if (input_state->at(reg) != NULL) {\n-      TRACE_LINEAR_SCAN(4, tty->print_cr(\"        reg[%d] = NULL\", reg));\n+    } else if (input_state->at(reg) != nullptr) {\n+      TRACE_LINEAR_SCAN(4, tty->print_cr(\"        reg[%d] = null\", reg));\n@@ -3708,2 +3708,2 @@\n-          state_put(input_state, interval->assigned_reg(),   NULL);\n-          state_put(input_state, interval->assigned_regHi(), NULL);\n+          state_put(input_state, interval->assigned_reg(),   nullptr);\n+          state_put(input_state, interval->assigned_regHi(), nullptr);\n@@ -3717,1 +3717,1 @@\n-        state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);\n+        state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), nullptr);\n@@ -3720,1 +3720,1 @@\n-        state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);\n+        state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), nullptr);\n@@ -3726,1 +3726,1 @@\n-        state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);\n+        state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), nullptr);\n@@ -3738,1 +3738,1 @@\n-    \/\/ set temp operands (some operations use temp operands also as output operands, so can't set them NULL)\n+    \/\/ set temp operands (some operations use temp operands also as output operands, so can't set them null)\n@@ -3779,1 +3779,1 @@\n-  _insert_list(NULL),\n+  _insert_list(nullptr),\n@@ -3807,1 +3807,1 @@\n-  assert(_insert_list != NULL && _insert_idx != -1, \"insert position not set\");\n+  assert(_insert_list != nullptr && _insert_idx != -1, \"insert position not set\");\n@@ -3813,1 +3813,1 @@\n-        assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), \"cannot read from same interval twice\");\n+        assert(_mapping_from.at(i) == nullptr || _mapping_from.at(i) != _mapping_from.at(j), \"cannot read from same interval twice\");\n@@ -3829,1 +3829,1 @@\n-      if (it != NULL) {\n+      if (it != nullptr) {\n@@ -3856,1 +3856,1 @@\n-    if (it != NULL && it->assigned_reg() >= LinearScan::nof_regs) {\n+    if (it != nullptr && it->assigned_reg() >= LinearScan::nof_regs) {\n@@ -3901,1 +3901,1 @@\n-  if (from != NULL) {\n+  if (from != nullptr) {\n@@ -3934,1 +3934,1 @@\n-  _insert_list = NULL;\n+  _insert_list = nullptr;\n@@ -3941,1 +3941,1 @@\n-  assert(_insert_list != NULL && _insert_idx != -1, \"must setup insert position first\");\n+  assert(_insert_list != nullptr && _insert_idx != -1, \"must setup insert position first\");\n@@ -3960,1 +3960,1 @@\n-  assert(_insert_list != NULL && _insert_idx != -1, \"must setup insert position first\");\n+  assert(_insert_list != nullptr && _insert_idx != -1, \"must setup insert position first\");\n@@ -3986,1 +3986,1 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: resolving mappings for Block B%d, index %d\", _insert_list->block() != NULL ? _insert_list->block()->block_id() : -1, _insert_idx));\n+  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: resolving mappings for Block B%d, index %d\", _insert_list->block() != nullptr ? _insert_list->block()->block_id() : -1, _insert_idx));\n@@ -3995,1 +3995,1 @@\n-    if (from_interval != NULL) {\n+    if (from_interval != nullptr) {\n@@ -4010,1 +4010,1 @@\n-        if (from_interval != NULL) {\n+        if (from_interval != nullptr) {\n@@ -4021,1 +4021,1 @@\n-      } else if (from_interval != NULL && from_interval->assigned_reg() < LinearScan::nof_regs) {\n+      } else if (from_interval != nullptr && from_interval->assigned_reg() < LinearScan::nof_regs) {\n@@ -4071,2 +4071,2 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: setting insert position to Block B%d, index %d\", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));\n-  assert(_insert_list == NULL && _insert_idx == -1, \"use move_insert_position instead of set_insert_position when data already set\");\n+  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: setting insert position to Block B%d, index %d\", insert_list->block() != nullptr ? insert_list->block()->block_id() : -1, insert_idx));\n+  assert(_insert_list == nullptr && _insert_idx == -1, \"use move_insert_position instead of set_insert_position when data already set\");\n@@ -4080,1 +4080,1 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: moving insert position to Block B%d, index %d\", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));\n+  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: moving insert position to Block B%d, index %d\", insert_list->block() != nullptr ? insert_list->block()->block_id() : -1, insert_idx));\n@@ -4082,1 +4082,1 @@\n-  if (_insert_list != NULL && (insert_list != _insert_list || insert_idx != _insert_idx)) {\n+  if (_insert_list != nullptr && (insert_list != _insert_list || insert_idx != _insert_idx)) {\n@@ -4111,1 +4111,1 @@\n-  _mapping_from.append(NULL);\n+  _mapping_from.append(nullptr);\n@@ -4135,1 +4135,1 @@\n-Range* Range::_end = NULL;\n+Range* Range::_end = nullptr;\n@@ -4139,1 +4139,1 @@\n-  _end = ::new(static_cast<void*>(end_storage)) Range(max_jint, max_jint, NULL);\n+  _end = ::new(static_cast<void*>(end_storage)) Range(max_jint, max_jint, nullptr);\n@@ -4145,1 +4145,1 @@\n-  assert(r1 != NULL && r2 != NULL, \"null ranges not allowed\");\n+  assert(r1 != nullptr && r2 != nullptr, \"null ranges not allowed\");\n@@ -4184,1 +4184,1 @@\n-Interval* Interval::_end = NULL;\n+Interval* Interval::_end = nullptr;\n@@ -4205,1 +4205,1 @@\n-  _split_children(NULL),\n+  _split_children(nullptr),\n@@ -4210,1 +4210,1 @@\n-  _register_hint(NULL)\n+  _register_hint(nullptr)\n@@ -4230,1 +4230,1 @@\n-  if (_split_children != NULL && _split_children->length() > 0) {\n+  if (_split_children != nullptr && _split_children->length() > 0) {\n@@ -4262,1 +4262,1 @@\n-  if (_register_hint != NULL) {\n+  if (_register_hint != nullptr) {\n@@ -4268,1 +4268,1 @@\n-    } else if (_register_hint->_split_children != NULL && _register_hint->_split_children->length() > 0) {\n+    } else if (_register_hint->_split_children != nullptr && _register_hint->_split_children->length() > 0) {\n@@ -4282,1 +4282,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4291,1 +4291,1 @@\n-  if (_split_children == NULL || _split_children->length() == 0) {\n+  if (_split_children == nullptr || _split_children->length() == 0) {\n@@ -4294,1 +4294,1 @@\n-    result = NULL;\n+    result = nullptr;\n@@ -4329,1 +4329,1 @@\n-  assert(result != NULL, \"no matching interval found\");\n+  assert(result != nullptr, \"no matching interval found\");\n@@ -4341,1 +4341,1 @@\n-  Interval* result = NULL;\n+  Interval* result = nullptr;\n@@ -4343,1 +4343,1 @@\n-  assert(parent->_split_children != NULL, \"no split children available\");\n+  assert(parent->_split_children != nullptr, \"no split children available\");\n@@ -4349,1 +4349,1 @@\n-    if (cur->to() <= op_id && (result == NULL || result->to() < cur->to())) {\n+    if (cur->to() <= op_id && (result == nullptr || result->to() < cur->to())) {\n@@ -4354,1 +4354,1 @@\n-  assert(result != NULL, \"no split child found\");\n+  assert(result != nullptr, \"no split child found\");\n@@ -4463,1 +4463,1 @@\n-  if (parent->_split_children == NULL) {\n+  if (parent->_split_children == nullptr) {\n@@ -4491,1 +4491,1 @@\n-  Range* prev = NULL;\n+  Range* prev = nullptr;\n@@ -4505,1 +4505,1 @@\n-    assert(prev != NULL, \"split before start of first range\");\n+    assert(prev != nullptr, \"split before start of first range\");\n@@ -4626,1 +4626,1 @@\n-  if (interval->_split_children != NULL) {\n+  if (interval->_split_children != nullptr) {\n@@ -4670,1 +4670,1 @@\n-  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n+  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != nullptr ? register_hint(false)->reg_num() : -1));\n@@ -4677,1 +4677,1 @@\n-    assert(cur != NULL, \"range list not closed with range sentinel\");\n+    assert(cur != nullptr, \"range list not closed with range sentinel\");\n@@ -4704,1 +4704,1 @@\n-  if (_split_children == NULL) {\n+  if (_split_children == nullptr) {\n@@ -4732,1 +4732,1 @@\n-  _current = NULL;\n+  _current = nullptr;\n@@ -4739,1 +4739,1 @@\n-  Interval* prev = NULL;\n+  Interval* prev = nullptr;\n@@ -4744,1 +4744,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -4755,1 +4755,1 @@\n-  Interval* prev = NULL;\n+  Interval* prev = nullptr;\n@@ -4760,1 +4760,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -4865,1 +4865,1 @@\n-    _current = NULL; return;\n+    _current = nullptr; return;\n@@ -4877,1 +4877,1 @@\n-  while (current() != NULL) {\n+  while (current() != nullptr) {\n@@ -5303,1 +5303,1 @@\n-    while (parent != NULL && parent->is_split_child()) {\n+    while (parent != nullptr && parent->is_split_child()) {\n@@ -5313,1 +5313,1 @@\n-          parent = NULL;\n+          parent = nullptr;\n@@ -5483,1 +5483,1 @@\n-  if (register_hint != NULL) {\n+  if (register_hint != nullptr) {\n@@ -5799,1 +5799,1 @@\n-  assert(op->as_Op1() != NULL, \"move must be LIR_Op1\");\n+  assert(op->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -5815,1 +5815,1 @@\n-  if (register_hint == NULL) {\n+  if (register_hint == nullptr) {\n@@ -5922,1 +5922,1 @@\n-    assert(cur->current_split_child() != NULL, \"must be\");\n+    assert(cur->current_split_child() != nullptr, \"must be\");\n@@ -5979,1 +5979,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5996,1 +5996,1 @@\n-  if (op1 == NULL || op2 == NULL) {\n+  if (op1 == nullptr || op2 == nullptr) {\n@@ -6002,2 +6002,2 @@\n-    assert(op1->as_Op1() != NULL, \"move must be LIR_Op1\");\n-    assert(op2->as_Op1() != NULL, \"move must be LIR_Op1\");\n+    assert(op1->as_Op1() != nullptr, \"move must be LIR_Op1\");\n+    assert(op2->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -6012,2 +6012,2 @@\n-    assert(op1->as_Op1() != NULL, \"fxch must be LIR_Op1\");\n-    assert(op2->as_Op1() != NULL, \"fxch must be LIR_Op1\");\n+    assert(op1->as_Op1() != nullptr, \"fxch must be LIR_Op1\");\n+    assert(op2->as_Op1() != nullptr, \"fxch must be LIR_Op1\");\n@@ -6058,1 +6058,1 @@\n-    assert(pred_instructions->last()->as_OpBranch() != NULL, \"branch must be LIR_OpBranch\");\n+    assert(pred_instructions->last()->as_OpBranch() != nullptr, \"branch must be LIR_OpBranch\");\n@@ -6061,1 +6061,1 @@\n-    if (pred_instructions->last()->info() != NULL) {\n+    if (pred_instructions->last()->info() != nullptr) {\n@@ -6105,1 +6105,1 @@\n-  assert(cur_instructions->last()->as_OpBranch() != NULL, \"branch must be LIR_OpBranch\");\n+  assert(cur_instructions->last()->as_OpBranch() != nullptr, \"branch must be LIR_OpBranch\");\n@@ -6108,1 +6108,1 @@\n-  if (cur_instructions->last()->info() != NULL) {\n+  if (cur_instructions->last()->info() != nullptr) {\n@@ -6114,1 +6114,1 @@\n-  if (branch->info() != NULL || (branch->code() != lir_branch && branch->code() != lir_cond_float_branch)) {\n+  if (branch->info() != nullptr || (branch->code() != lir_branch && branch->code() != lir_cond_float_branch)) {\n@@ -6129,1 +6129,1 @@\n-    if ((op->code() == lir_branch || op->code() == lir_cond_float_branch) && ((LIR_OpBranch*)op)->block() != NULL) {\n+    if ((op->code() == lir_branch || op->code() == lir_cond_float_branch) && ((LIR_OpBranch*)op)->block() != nullptr) {\n@@ -6258,1 +6258,1 @@\n-  assert(instructions->last()->as_OpBranch() != NULL, \"last instruction must always be a branch\");\n+  assert(instructions->last()->as_OpBranch() != nullptr, \"last instruction must always be a branch\");\n@@ -6264,1 +6264,1 @@\n-  if (instructions->length() == 2 && instructions->last()->info() == NULL) {\n+  if (instructions->length() == 2 && instructions->last()->info() == nullptr) {\n@@ -6281,1 +6281,1 @@\n-      assert(op->as_OpBranch() != NULL, \"branch must be of type LIR_OpBranch\");\n+      assert(op->as_OpBranch() != nullptr, \"branch must be of type LIR_OpBranch\");\n@@ -6350,1 +6350,1 @@\n-      assert(last_op->as_OpBranch() != NULL, \"branch must be of type LIR_OpBranch\");\n+      assert(last_op->as_OpBranch() != nullptr, \"branch must be of type LIR_OpBranch\");\n@@ -6353,1 +6353,1 @@\n-      assert(last_branch->block() != NULL, \"last branch must always have a block as target\");\n+      assert(last_branch->block() != nullptr, \"last branch must always have a block as target\");\n@@ -6356,1 +6356,1 @@\n-      if (last_branch->info() == NULL) {\n+      if (last_branch->info() == nullptr) {\n@@ -6367,1 +6367,1 @@\n-            assert(prev_op->as_OpBranch() != NULL, \"branch must be of type LIR_OpBranch\");\n+            assert(prev_op->as_OpBranch() != nullptr, \"branch must be of type LIR_OpBranch\");\n@@ -6370,1 +6370,1 @@\n-            if (prev_branch->stub() == NULL) {\n+            if (prev_branch->stub() == nullptr) {\n@@ -6372,1 +6372,1 @@\n-              LIR_Op2* prev_cmp = NULL;\n+              LIR_Op2* prev_cmp = nullptr;\n@@ -6376,1 +6376,1 @@\n-              LIR_Op4* prev_cmove = NULL;\n+              LIR_Op4* prev_cmove = nullptr;\n@@ -6378,1 +6378,1 @@\n-              for(int j = instructions->length() - 3; j >= 0 && prev_cmp == NULL; j--) {\n+              for(int j = instructions->length() - 3; j >= 0 && prev_cmp == nullptr; j--) {\n@@ -6382,1 +6382,1 @@\n-                  assert(prev_op->as_Op4() != NULL, \"cmove must be of type LIR_Op4\");\n+                  assert(prev_op->as_Op4() != nullptr, \"cmove must be of type LIR_Op4\");\n@@ -6387,1 +6387,1 @@\n-                  assert(prev_op->as_Op2() != NULL, \"branch must be of type LIR_Op2\");\n+                  assert(prev_op->as_Op2() != nullptr, \"branch must be of type LIR_Op2\");\n@@ -6393,2 +6393,2 @@\n-              guarantee(prev_cmp != NULL, \"should have found comp instruction for branch\");\n-              if (prev_branch->block() == code->at(i + 1) && prev_branch->info() == NULL) {\n+              guarantee(prev_cmp != nullptr, \"should have found comp instruction for branch\");\n+              if (prev_branch->block() == code->at(i + 1) && prev_branch->info() == nullptr) {\n@@ -6404,1 +6404,1 @@\n-                if (prev_cmove != NULL) {\n+                if (prev_cmove != nullptr) {\n@@ -6441,1 +6441,1 @@\n-      assert(cur_last_op->info() == NULL, \"return instructions do not have debug information\");\n+      assert(cur_last_op->info() == nullptr, \"return instructions do not have debug information\");\n@@ -6446,1 +6446,1 @@\n-      assert(cur_last_op->as_Op1() != NULL, \"return must be LIR_Op1\");\n+      assert(cur_last_op->as_Op1() != nullptr, \"return must be LIR_Op1\");\n@@ -6455,1 +6455,1 @@\n-          assert(pred_last_op->as_OpBranch() != NULL, \"branch must be LIR_OpBranch\");\n+          assert(pred_last_op->as_OpBranch() != nullptr, \"branch must be LIR_OpBranch\");\n@@ -6458,1 +6458,1 @@\n-          if (pred_last_branch->block() == block && pred_last_branch->cond() == lir_cond_always && pred_last_branch->info() == NULL) {\n+          if (pred_last_branch->block() == block && pred_last_branch->cond() == lir_cond_always && pred_last_branch->info() == nullptr) {\n@@ -6483,3 +6483,3 @@\n-      if (op_branch != NULL) {\n-        assert(op_branch->block() == NULL || code->find(op_branch->block()) != -1, \"branch target not valid\");\n-        assert(op_branch->ublock() == NULL || code->find(op_branch->ublock()) != -1, \"branch target not valid\");\n+      if (op_branch != nullptr) {\n+        assert(op_branch->block() == nullptr || code->find(op_branch->block()) != -1, \"branch target not valid\");\n+        assert(op_branch->ublock() == nullptr || code->find(op_branch->ublock()) != -1, \"branch target not valid\");\n@@ -6633,1 +6633,1 @@\n-    if (cur != NULL) {\n+    if (cur != nullptr) {\n@@ -6720,1 +6720,1 @@\n-          if (branch->block() == NULL) {\n+          if (branch->block() == nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":241,"deletions":241,"binary":false,"changes":482,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -65,1 +65,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -99,1 +99,1 @@\n-  if (if_ == NULL) return;\n+  if (if_ == nullptr) return;\n@@ -114,3 +114,3 @@\n-  Value t_const = NULL;\n-  Value f_const = NULL;\n-  if (t_cur->as_Constant() != NULL && !t_cur->can_trap()) {\n+  Value t_const = nullptr;\n+  Value f_const = nullptr;\n+  if (t_cur->as_Constant() != nullptr && !t_cur->can_trap()) {\n@@ -120,1 +120,1 @@\n-  if (f_cur->as_Constant() != NULL && !f_cur->can_trap()) {\n+  if (f_cur->as_Constant() != nullptr && !f_cur->can_trap()) {\n@@ -127,1 +127,1 @@\n-  if (t_goto == NULL) return;\n+  if (t_goto == nullptr) return;\n@@ -129,1 +129,1 @@\n-  if (f_goto == NULL) return;\n+  if (f_goto == nullptr) return;\n@@ -142,1 +142,1 @@\n-      assert(if_state != NULL, \"states do not match up\");\n+      assert(if_state != nullptr, \"states do not match up\");\n@@ -147,1 +147,1 @@\n-      assert(sux_state != NULL, \"states do not match up\");\n+      assert(sux_state != nullptr, \"states do not match up\");\n@@ -156,1 +156,1 @@\n-  if (sux_phi == NULL || sux_phi->as_Phi() == NULL || sux_phi->as_Phi()->block() != sux) return;\n+  if (sux_phi == nullptr || sux_phi->as_Phi() == nullptr || sux_phi->as_Phi()->block() != sux) return;\n@@ -222,1 +222,1 @@\n-  assert(result != NULL, \"make_ifop must return a non-null instruction\");\n+  assert(result != nullptr, \"make_ifop must return a non-null instruction\");\n@@ -292,1 +292,1 @@\n-  if (y_const != NULL) {\n+  if (y_const != nullptr) {\n@@ -294,1 +294,1 @@\n-    if (x_ifop != NULL) {                 \/\/ x is an ifop, y is a constant\n+    if (x_ifop != nullptr) {                 \/\/ x is an ifop, y is a constant\n@@ -298,1 +298,1 @@\n-      if (x_tval_const != NULL && x_fval_const != NULL) {\n+      if (x_tval_const != nullptr && x_fval_const != nullptr) {\n@@ -319,1 +319,1 @@\n-      if (x_const != NULL) {         \/\/ x and y are constants\n+      if (x_const != nullptr) { \/\/ x and y are constants\n@@ -363,1 +363,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -369,1 +369,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -375,1 +375,1 @@\n-    if (end->as_Goto() == NULL) return false;\n+    if (end->as_Goto() == nullptr) return false;\n@@ -407,1 +407,1 @@\n-      if (sux_phi != NULL && sux_phi->is_illegal()) continue;\n+      if (sux_phi != nullptr && sux_phi->is_illegal()) continue;\n@@ -422,1 +422,1 @@\n-    assert(prev->as_BlockEnd() == NULL, \"must not be a BlockEnd\");\n+    assert(prev->as_BlockEnd() == nullptr, \"must not be a BlockEnd\");\n@@ -475,1 +475,1 @@\n-          \/\/ becomes NULL In such (rare) cases it is not\n+          \/\/ becomes null In such (rare) cases it is not\n@@ -478,1 +478,1 @@\n-          while (prev != NULL && prev->next() != if_) {\n+          while (prev != nullptr && prev->next() != if_) {\n@@ -482,1 +482,1 @@\n-          if (prev != NULL) {\n+          if (prev != nullptr) {\n@@ -610,1 +610,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -614,1 +614,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -618,1 +618,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -622,1 +622,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -631,3 +631,3 @@\n-  bool set_contains(Value x)                      { assert(_set != NULL, \"check\"); return _set->contains(x); }\n-  void set_put     (Value x)                      { assert(_set != NULL, \"check\"); _set->put(x); }\n-  void set_remove  (Value x)                      { assert(_set != NULL, \"check\"); _set->remove(x); }\n+  bool set_contains(Value x)                      { assert(_set != nullptr, \"check\"); return _set->contains(x); }\n+  void set_put     (Value x)                      { assert(_set != nullptr, \"check\"); _set->put(x); }\n+  void set_remove  (Value x)                      { assert(_set != nullptr, \"check\"); _set->remove(x); }\n@@ -654,2 +654,2 @@\n-    , _block_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)\n-    , _last_explicit_null_check(NULL) {\n+    , _block_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), nullptr)\n+    , _last_explicit_null_check(nullptr) {\n@@ -659,1 +659,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -665,1 +665,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -688,1 +688,1 @@\n-                                                                         : NULL); }\n+                                                                         : nullptr); }\n@@ -694,1 +694,1 @@\n-  void        clear_last_explicit_null_check()               { _last_explicit_null_check = NULL; }\n+  void        clear_last_explicit_null_check()               { _last_explicit_null_check = nullptr; }\n@@ -782,1 +782,1 @@\n-  assert(*p != NULL, \"should not find NULL instructions\");\n+  assert(*p != nullptr, \"should not find null instructions\");\n@@ -791,1 +791,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -815,1 +815,1 @@\n-  set_last_explicit_null_check(NULL);\n+  set_last_explicit_null_check(nullptr);\n@@ -826,1 +826,1 @@\n-  if (state_for(block) == NULL) {\n+  if (state_for(block) == nullptr) {\n@@ -836,1 +836,1 @@\n-      assert(local0 != NULL, \"must be\");\n+      assert(local0 != nullptr, \"must be\");\n@@ -839,1 +839,1 @@\n-      if (local0 != NULL) {\n+      if (local0 != nullptr) {\n@@ -861,1 +861,1 @@\n-  assert(e != NULL, \"incomplete graph\");\n+  assert(e != nullptr, \"incomplete graph\");\n@@ -879,1 +879,1 @@\n-  for (Instruction* instr = block; instr != NULL; instr = instr->next()) {\n+  for (Instruction* instr = block; instr != nullptr; instr = instr->next()) {\n@@ -885,1 +885,1 @@\n-    if (instr->is_pinned() || instr->can_trap() || (instr->as_NullCheck() != NULL)) {\n+    if (instr->is_pinned() || instr->can_trap() || (instr->as_NullCheck() != nullptr)) {\n@@ -911,1 +911,1 @@\n-    if (x->as_LoadField() != NULL) {\n+    if (x->as_LoadField() != nullptr) {\n@@ -947,1 +947,1 @@\n-      x->set_explicit_null_check(NULL);\n+      x->set_explicit_null_check(nullptr);\n@@ -960,1 +960,1 @@\n-    x->set_explicit_null_check(NULL);\n+    x->set_explicit_null_check(nullptr);\n@@ -978,1 +978,1 @@\n-      x->set_explicit_null_check(NULL);\n+      x->set_explicit_null_check(nullptr);\n@@ -991,1 +991,1 @@\n-    x->set_explicit_null_check(NULL);\n+    x->set_explicit_null_check(nullptr);\n@@ -1009,1 +1009,1 @@\n-      x->set_explicit_null_check(NULL);\n+      x->set_explicit_null_check(nullptr);\n@@ -1022,1 +1022,1 @@\n-    x->set_explicit_null_check(NULL);\n+    x->set_explicit_null_check(nullptr);\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,2 @@\n-  _bounds(Instruction::number_of_instructions(), Instruction::number_of_instructions(), NULL),\n-  _access_indexed_info(Instruction::number_of_instructions(), Instruction::number_of_instructions(), NULL)\n+  _bounds(Instruction::number_of_instructions(), Instruction::number_of_instructions(), nullptr),\n+  _access_indexed_info(Instruction::number_of_instructions(), Instruction::number_of_instructions(), nullptr)\n@@ -95,1 +95,1 @@\n-  calc_bounds(ir->start(), NULL);\n+  calc_bounds(ir->start(), nullptr);\n@@ -106,1 +106,1 @@\n-  if (ic != NULL) {\n+  if (ic != nullptr) {\n@@ -108,1 +108,1 @@\n-    _bound = new Bound(value, NULL, value, NULL);\n+    _bound = new Bound(value, nullptr, value, nullptr);\n@@ -117,1 +117,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -123,1 +123,1 @@\n-      _bound = new Bound(0, NULL, constant, NULL);\n+      _bound = new Bound(0, nullptr, constant, nullptr);\n@@ -137,1 +137,1 @@\n-  Bound *bound = NULL;\n+  Bound* bound = nullptr;\n@@ -147,1 +147,1 @@\n-    if (op2 != NULL) {\n+    if (op2 != nullptr) {\n@@ -156,1 +156,1 @@\n-        if (ao != NULL && ao->op() == Bytecodes::_iadd) {\n+        if (ao != nullptr && ao->op() == Bytecodes::_iadd) {\n@@ -160,1 +160,1 @@\n-            if (c != NULL) {\n+            if (c != nullptr) {\n@@ -187,1 +187,1 @@\n-      cur_value = NULL;\n+      cur_value = nullptr;\n@@ -202,1 +202,1 @@\n-      bound = NULL;\n+      bound = nullptr;\n@@ -229,2 +229,2 @@\n-    if (x_bound->lower() >= 0 && x_bound->lower_instr() == NULL && y->as_ArrayLength() != NULL) {\n-      _bound = new Bound(0, NULL, -1, y);\n+    if (x_bound->lower() >= 0 && x_bound->lower_instr() == nullptr && y->as_ArrayLength() != nullptr) {\n+      _bound = new Bound(0, nullptr, -1, y);\n@@ -245,1 +245,1 @@\n-        _bound = new Bound(0, NULL, y->type()->as_IntConstant()->value() - 1, NULL);\n+        _bound = new Bound(0, nullptr, y->type()->as_IntConstant()->value() - 1, nullptr);\n@@ -296,1 +296,1 @@\n-          _bound = new Bound(Instruction::geq, NULL, bound->lower());\n+          _bound = new Bound(Instruction::geq, nullptr, bound->lower());\n@@ -319,1 +319,1 @@\n-    _bound = new Bound(min, NULL, max, NULL);\n+    _bound = new Bound(min, nullptr, max, nullptr);\n@@ -325,2 +325,2 @@\n-  \/\/ Wrong type or NULL -> No bound\n-  if (!v || (!v->type()->as_IntType() && !v->type()->as_ObjectType())) return NULL;\n+  \/\/ Wrong type or null -> No bound\n+  if (!v || (!v->type()->as_IntType() && !v->type()->as_ObjectType())) return nullptr;\n@@ -369,1 +369,1 @@\n-  for (BlockBegin *d = loop_header->dominator(); d != NULL; d = d->dominator()) {\n+  for (BlockBegin* d = loop_header->dominator(); d != nullptr; d = d->dominator()) {\n@@ -387,1 +387,1 @@\n-  Bound *top = NULL;\n+  Bound* top = nullptr;\n@@ -402,1 +402,1 @@\n-  if (aii == NULL) {\n+  if (aii == nullptr) {\n@@ -442,1 +442,1 @@\n-      if (c != NULL) {\n+      if (c != nullptr) {\n@@ -459,1 +459,1 @@\n-        while (ao != NULL && (ao->x()->as_Constant() || ao->y()->as_Constant()) && (ao->op() == Bytecodes::_iadd || ao->op() == Bytecodes::_isub)) {\n+        while (ao != nullptr && (ao->x()->as_Constant() || ao->y()->as_Constant()) && (ao->op() == Bytecodes::_iadd || ao->op() == Bytecodes::_isub)) {\n@@ -492,1 +492,1 @@\n-        assert(info != NULL, \"Info must not be null\");\n+        assert(info != nullptr, \"Info must not be null\");\n@@ -511,1 +511,1 @@\n-          Constant *min_constant = NULL;\n+          Constant *min_constant = nullptr;\n@@ -519,1 +519,1 @@\n-          Constant *max_constant = NULL;\n+          Constant *max_constant = nullptr;\n@@ -539,1 +539,1 @@\n-            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, NULL);\n+            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, nullptr);\n@@ -547,1 +547,1 @@\n-            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, NULL);\n+            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, nullptr);\n@@ -592,1 +592,1 @@\n-      _access_indexed_info.at_put(index_instruction->id(), NULL);\n+      _access_indexed_info.at_put(index_instruction->id(), nullptr);\n@@ -603,1 +603,1 @@\n-    process |= (cur->as_AccessIndexed() != NULL);\n+    process |= (cur->as_AccessIndexed() != nullptr);\n@@ -669,1 +669,1 @@\n-  ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, NULL);\n+  ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, nullptr);\n@@ -758,1 +758,1 @@\n-  if (c != NULL) {\n+  if (c != nullptr) {\n@@ -760,2 +760,2 @@\n-    instr_value = NULL;\n-  } else if (ao != NULL &&  (!ao->x()->as_Constant() || !ao->y()->as_Constant()) && ((ao->op() == Bytecodes::_isub && ao->y()->as_Constant()) || ao->op() == Bytecodes::_iadd)) {\n+    instr_value = nullptr;\n+  } else if (ao != nullptr &&  (!ao->x()->as_Constant() || !ao->y()->as_Constant()) && ((ao->op() == Bytecodes::_isub && ao->y()->as_Constant()) || ao->op() == Bytecodes::_iadd)) {\n@@ -765,1 +765,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -770,1 +770,1 @@\n-      if (c != NULL) {\n+      if (c != nullptr) {\n@@ -812,1 +812,1 @@\n-    tty->print_cr(\"Access indexed: index=%d length=%d\", ai->index()->id(), (ai->length() != NULL ? ai->length()->id() :-1 ))\n+    tty->print_cr(\"Access indexed: index=%d length=%d\", ai->index()->id(), (ai->length() != nullptr ? ai->length()->id() :-1 ))\n@@ -895,1 +895,1 @@\n-        length_instr = NULL;\n+        length_instr = nullptr;\n@@ -904,1 +904,1 @@\n-      assert(pred_block != NULL, \"Every loop header has a dominator!\");\n+      assert(pred_block != nullptr, \"Every loop header has a dominator!\");\n@@ -908,1 +908,1 @@\n-      if (pred_block_end->as_Goto() && state == NULL) state = pred_block_end->state();\n+      if (pred_block_end->as_Goto() && state == nullptr) state = pred_block_end->state();\n@@ -953,1 +953,1 @@\n-      cur_value = NULL;\n+      cur_value = nullptr;\n@@ -955,1 +955,1 @@\n-    Bound *new_index_bound = new Bound(0, NULL, cur_constant, cur_value);\n+    Bound* new_index_bound = new Bound(0, nullptr, cur_constant, cur_value);\n@@ -975,1 +975,1 @@\n-  if (parent != NULL) {\n+  if (parent != nullptr) {\n@@ -977,1 +977,1 @@\n-    if (cond != NULL) {\n+    if (cond != nullptr) {\n@@ -992,1 +992,1 @@\n-      if (ai != NULL) {\n+      if (ai != nullptr) {\n@@ -1001,1 +1001,1 @@\n-          update_bound(pushed, ai->index(), Instruction::geq, NULL, 0);\n+          update_bound(pushed, ai->index(), Instruction::geq, nullptr, 0);\n@@ -1006,1 +1006,1 @@\n-            update_bound(pushed, ai->index(), Instruction::lss, NULL, value);\n+            update_bound(pushed, ai->index(), Instruction::lss, nullptr, value);\n@@ -1010,1 +1010,1 @@\n-            if (instr == NULL) instr = ai->array();\n+            if (instr == nullptr) instr = ai->array();\n@@ -1102,2 +1102,2 @@\n-      BlockBegin *sux = block->sux_at(i);\n-      BlockBegin *pred = NULL;\n+      BlockBegin* sux = block->sux_at(i);\n+      BlockBegin* pred = nullptr;\n@@ -1106,1 +1106,1 @@\n-        assert(cur != NULL, \"Predecessor must not be null\");\n+        assert(cur != nullptr, \"Predecessor must not be null\");\n@@ -1225,1 +1225,1 @@\n-bool RangeCheckEliminator::Verification::can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use \/* = NULL *\/) {\n+bool RangeCheckEliminator::Verification::can_reach(BlockBegin* start, BlockBegin* end, BlockBegin* dont_use \/* = nullptr *\/) {\n@@ -1264,1 +1264,1 @@\n-      assert(sux != NULL, \"Successor must not be NULL!\");\n+      assert(sux != nullptr, \"Successor must not be null!\");\n@@ -1288,2 +1288,2 @@\n-  this->_lower_instr = NULL;\n-  this->_upper_instr = NULL;\n+  this->_lower_instr = nullptr;\n+  this->_upper_instr = nullptr;\n@@ -1315,3 +1315,3 @@\n-    _lower_instr = NULL;\n-    _upper_instr = NULL;\n-    if (v == NULL) {\n+    _lower_instr = nullptr;\n+    _upper_instr = nullptr;\n+    if (v == nullptr) {\n@@ -1329,1 +1329,1 @@\n-    _upper_instr = NULL;\n+    _upper_instr = nullptr;\n@@ -1332,1 +1332,1 @@\n-    _lower_instr = NULL;\n+    _lower_instr = nullptr;\n@@ -1365,1 +1365,1 @@\n-    _lower_instr = NULL;\n+    _lower_instr = nullptr;\n@@ -1372,1 +1372,1 @@\n-    _upper_instr = NULL;\n+    _upper_instr = nullptr;\n@@ -1387,1 +1387,1 @@\n-    if (_lower_instr != NULL && b->_lower_instr != NULL) {\n+    if (_lower_instr != nullptr && b->_lower_instr != nullptr) {\n@@ -1401,1 +1401,1 @@\n-    if (_upper_instr != NULL && b->_upper_instr != NULL) {\n+    if (_upper_instr != nullptr && b->_upper_instr != nullptr) {\n@@ -1413,1 +1413,1 @@\n-  return _upper_instr != NULL || _upper < max_jint;\n+  return _upper_instr != nullptr || _upper < max_jint;\n@@ -1426,1 +1426,1 @@\n-  return _lower_instr != NULL || _lower > min_jint;\n+  return _lower_instr != nullptr || _lower > min_jint;\n@@ -1432,3 +1432,3 @@\n-  assert(array != NULL, \"Must not be null!\");\n-  assert(bound != NULL, \"Must not be null!\");\n-  if (bound->lower() >=0 && bound->lower_instr() == NULL && bound->upper() < 0 && bound->upper_instr() != NULL) {\n+  assert(array != nullptr, \"Must not be null!\");\n+  assert(bound != nullptr, \"Must not be null!\");\n+  if (bound->lower() >=0 && bound->lower_instr() == nullptr && bound->upper() < 0 && bound->upper_instr() != nullptr) {\n@@ -1436,1 +1436,1 @@\n-    if (bound->upper_instr() == array || (len != NULL && len->array() == array)) {\n+    if (bound->upper_instr() == array || (len != nullptr && len->array() == array)) {\n@@ -1446,1 +1446,1 @@\n-  _lower_instr = NULL;\n+  _lower_instr = nullptr;\n@@ -1452,1 +1452,1 @@\n-  _upper_instr = NULL;\n+  _upper_instr = nullptr;\n@@ -1522,3 +1522,3 @@\n-  Instruction *result = position;\n-  Instruction *compare_with = NULL;\n-  ValueStack *state = position->state_before();\n+  Instruction* result = position;\n+  Instruction* compare_with = nullptr;\n+  ValueStack* state = position->state_before();\n@@ -1528,1 +1528,1 @@\n-  Instruction *instruction_before = position->prev();\n+  Instruction* instruction_before = position->prev();\n@@ -1534,1 +1534,1 @@\n-  Constant *constant = NULL;\n+  Constant* constant = nullptr;\n@@ -1558,1 +1558,1 @@\n-      ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, NULL);\n+      ArithmeticOp* ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, nullptr);\n@@ -1565,2 +1565,2 @@\n-  assert(compare_with != NULL, \"You have to compare with something!\");\n-  assert(instruction != NULL, \"Instruction must not be null!\");\n+  assert(compare_with != nullptr, \"You have to compare with something!\");\n+  assert(instruction != nullptr, \"Instruction must not be null!\");\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    bool can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use = NULL);\n+    bool can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use = nullptr);\n@@ -118,1 +118,1 @@\n-    void clear_bound() { _bound = NULL; }\n+    void clear_bound() { _bound = nullptr; }\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -218,1 +218,1 @@\n-  assert(oop_maps == NULL || sasm->frame_size() != no_frame_size,\n+  assert(oop_maps == nullptr || sasm->frame_size() != no_frame_size,\n@@ -220,1 +220,1 @@\n-  assert(!expect_oop_map || oop_maps != NULL, \"must have an oopmap\");\n+  assert(!expect_oop_map || oop_maps != nullptr, \"must have an oopmap\");\n@@ -236,1 +236,1 @@\n-  assert(blob != NULL, \"blob must exist\");\n+  assert(blob != nullptr, \"blob must exist\");\n@@ -275,1 +275,1 @@\n-      if (_blobs[id]->oop_maps() != NULL) {\n+      if (_blobs[id]->oop_maps() != nullptr) {\n@@ -445,1 +445,1 @@\n-  nmethod* osr_nm = NULL;\n+  nmethod* osr_nm = nullptr;\n@@ -454,1 +454,1 @@\n-  assert(nm!= NULL && nm->is_nmethod(), \"Sanity check\");\n+  assert(nm!= nullptr && nm->is_nmethod(), \"Sanity check\");\n@@ -489,1 +489,1 @@\n-    if (osr_nm != NULL) {\n+    if (osr_nm != nullptr) {\n@@ -498,1 +498,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -536,1 +536,1 @@\n-  assert(nm != NULL, \"this is not an nmethod\");\n+  assert(nm != nullptr, \"this is not an nmethod\");\n@@ -548,1 +548,1 @@\n-  assert(exception.not_null(), \"NULL exceptions should be handled by throw_exception\");\n+  assert(exception.not_null(), \"null exceptions should be handled by throw_exception\");\n@@ -558,1 +558,1 @@\n-    assert(nm->method() != NULL, \"Unexpected NULL method()\");\n+    assert(nm->method() != nullptr, \"Unexpected null method()\");\n@@ -600,1 +600,1 @@\n-    if (fast_continuation != NULL) {\n+    if (fast_continuation != nullptr) {\n@@ -609,2 +609,2 @@\n-  \/\/ skip the exception cache update (i.e., just leave continuation==NULL).\n-  address continuation = NULL;\n+  \/\/ skip the exception cache update (i.e., just leave continuation as null).\n+  address continuation = nullptr;\n@@ -633,1 +633,1 @@\n-    if (continuation != NULL && !recursive_exception) {\n+    if (continuation != nullptr && !recursive_exception) {\n@@ -662,2 +662,2 @@\n-  nmethod* nm = NULL;\n-  address continuation = NULL;\n+  nmethod* nm = nullptr;\n+  address continuation = nullptr;\n@@ -673,1 +673,1 @@\n-  if (nm != NULL && caller_is_deopted(current)) {\n+  if (nm != nullptr && caller_is_deopted(current)) {\n@@ -677,1 +677,1 @@\n-  assert(continuation != NULL, \"no handler found\");\n+  assert(continuation != nullptr, \"no handler found\");\n@@ -774,1 +774,1 @@\n-  assert(oopDesc::is_oop(obj), \"must be NULL or an object\");\n+  assert(oopDesc::is_oop(obj), \"must be null or an object\");\n@@ -789,1 +789,1 @@\n-  assert(nm != NULL, \"Sanity check\");\n+  assert(nm != nullptr, \"Sanity check\");\n@@ -799,1 +799,1 @@\n-        if (trap_mdo != NULL) {\n+        if (trap_mdo != nullptr) {\n@@ -894,1 +894,1 @@\n-\/\/ NULL, so the next thread to execute this code will fail the test,\n+\/\/ null, so the next thread to execute this code will fail the test,\n@@ -957,4 +957,4 @@\n-  Klass* init_klass = NULL; \/\/ klass needed by load_klass_patching code\n-  Klass* load_klass = NULL; \/\/ klass needed by load_klass_patching code\n-  Handle mirror(current, NULL);                    \/\/ oop needed by load_mirror_patching code\n-  Handle appendix(current, NULL);                  \/\/ oop needed by appendix_patching code\n+  Klass* init_klass = nullptr; \/\/ klass needed by load_klass_patching code\n+  Klass* load_klass = nullptr; \/\/ klass needed by load_klass_patching code\n+  Handle mirror(current, nullptr); \/\/ oop needed by load_mirror_patching code\n+  Handle appendix(current, nullptr); \/\/ oop needed by appendix_patching code\n@@ -1000,1 +1000,1 @@\n-    Klass* k = NULL;\n+    Klass* k = nullptr;\n@@ -1091,1 +1091,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1137,1 +1137,1 @@\n-          assert(caller_code != NULL, \"nmethod not found\");\n+          assert(caller_code != nullptr, \"nmethod not found\");\n@@ -1143,1 +1143,1 @@\n-          assert(map != NULL, \"null check\");\n+          assert(map != nullptr, \"null check\");\n@@ -1178,1 +1178,1 @@\n-              assert(load_klass != NULL, \"klass not set\");\n+              assert(load_klass != nullptr, \"klass not set\");\n@@ -1211,2 +1211,2 @@\n-            address addr = NULL;\n-            assert(nm != NULL, \"invalid nmethod_pc\");\n+            address addr = nullptr;\n+            assert(nm != nullptr, \"invalid nmethod_pc\");\n@@ -1228,1 +1228,1 @@\n-            assert(addr != NULL, \"metadata relocation must exist\");\n+            assert(addr != nullptr, \"metadata relocation must exist\");\n@@ -1252,1 +1252,1 @@\n-            assert(nm != NULL, \"invalid nmethod_pc\");\n+            assert(nm != nullptr, \"invalid nmethod_pc\");\n@@ -1275,1 +1275,1 @@\n-    guarantee(nm != NULL, \"only nmethods can contain non-perm oops\");\n+    guarantee(nm != nullptr, \"only nmethods can contain non-perm oops\");\n@@ -1343,1 +1343,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1455,1 +1455,1 @@\n-  assert(mirror != NULL, \"should null-check on mirror before calling\");\n+  assert(mirror != nullptr, \"should null-check on mirror before calling\");\n@@ -1457,1 +1457,1 @@\n-  return (k != NULL && obj != NULL && obj->is_a(k)) ? 1 : 0;\n+  return (k != nullptr && obj != nullptr && obj->is_a(k)) ? 1 : 0;\n@@ -1471,1 +1471,1 @@\n-  assert (nm != NULL, \"no more nmethod?\");\n+  assert (nm != nullptr, \"no more nmethod?\");\n@@ -1477,1 +1477,1 @@\n-  if (mdo == NULL && !HAS_PENDING_EXCEPTION) {\n+  if (mdo == nullptr && !HAS_PENDING_EXCEPTION) {\n@@ -1489,1 +1489,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  , _entries(ValueMapInitialSize, ValueMapInitialSize, NULL)\n+  , _entries(ValueMapInitialSize, ValueMapInitialSize, nullptr)\n@@ -59,1 +59,1 @@\n-  , _entries(old->_entries.length(), old->_entries.length(), NULL)\n+  , _entries(old->_entries.length(), old->_entries.length(), nullptr)\n@@ -75,1 +75,1 @@\n-  ValueMapEntryArray new_entries(new_size, new_size, NULL);\n+  ValueMapEntryArray new_entries(new_size, new_size, nullptr);\n@@ -82,1 +82,1 @@\n-    for (entry = entry_at(i); entry != NULL; entry = entry->next()) {\n+    for (entry = entry_at(i); entry != nullptr; entry = entry->next()) {\n@@ -96,1 +96,1 @@\n-        entry = new ValueMapEntry(entry->hash(), entry->value(), entry->nesting(), NULL);\n+        entry = new ValueMapEntry(entry->hash(), entry->value(), entry->nesting(), nullptr);\n@@ -115,1 +115,1 @@\n-    for (ValueMapEntry* entry = entry_at(entry_index(hash, size())); entry != NULL; entry = entry->next()) {\n+    for (ValueMapEntry* entry = entry_at(entry_index(hash, size())); entry != nullptr; entry = entry->next()) {\n@@ -123,1 +123,1 @@\n-          if (entry->nesting() != nesting() && f->as_Constant() == NULL) {\n+          if (entry->nesting() != nesting() && f->as_Constant() == nullptr) {\n@@ -155,2 +155,2 @@\n-    ValueMapEntry* prev_entry = NULL;                                                    \\\n-    for (ValueMapEntry* entry = entry_at(i); entry != NULL; entry = entry->next()) {     \\\n+    ValueMapEntry* prev_entry = nullptr;                                                 \\\n+    for (ValueMapEntry* entry = entry_at(i); entry != nullptr; entry = entry->next()) {  \\\n@@ -164,1 +164,1 @@\n-        if (prev_entry == NULL) {                                                        \\\n+        if (prev_entry == nullptr) {                                                     \\\n@@ -182,1 +182,1 @@\n-  bool must_kill = value->as_LoadField() != NULL || value->as_LoadIndexed() != NULL;\n+  bool must_kill = value->as_LoadField() != nullptr || value->as_LoadIndexed() != nullptr;\n@@ -185,1 +185,1 @@\n-  bool must_kill = value->as_LoadIndexed() != NULL                                       \\\n+  bool must_kill = value->as_LoadIndexed() != nullptr                                    \\\n@@ -191,1 +191,1 @@\n-  bool must_kill = lf != NULL                                                            \\\n+  bool must_kill = lf != nullptr                                                         \\\n@@ -216,1 +216,1 @@\n-    _entries.at_put(i, NULL);\n+    _entries.at_put(i, nullptr);\n@@ -229,1 +229,1 @@\n-    if (entry_at(i) != NULL) {\n+    if (entry_at(i) != nullptr) {\n@@ -231,1 +231,1 @@\n-      for (ValueMapEntry* entry = entry_at(i); entry != NULL; entry = entry->next()) {\n+      for (ValueMapEntry* entry = entry_at(i); entry != nullptr; entry = entry->next()) {\n@@ -236,1 +236,1 @@\n-      tty->print_cr(\"NULL\");\n+      tty->print_cr(\"null\");\n@@ -330,1 +330,1 @@\n-  : _gvn(gvn), _short_loop_optimizer(slo), _insertion_point(NULL), _state(NULL), _insert_is_pred(false) {\n+  : _gvn(gvn), _short_loop_optimizer(slo), _insertion_point(nullptr), _state(nullptr), _insert_is_pred(false) {\n@@ -340,1 +340,1 @@\n-  assert(insertion_block->end()->as_Base() == NULL, \"cannot insert into entry block\");\n+  assert(insertion_block->end()->as_Base() == nullptr, \"cannot insert into entry block\");\n@@ -368,1 +368,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -373,1 +373,1 @@\n-    if (cur->as_Constant() != NULL) {\n+    if (cur->as_Constant() != nullptr) {\n@@ -375,2 +375,2 @@\n-    } else if (cur->as_ArithmeticOp() != NULL || cur->as_LogicOp() != NULL || cur->as_ShiftOp() != NULL) {\n-      assert(cur->as_Op2() != NULL, \"must be Op2\");\n+    } else if (cur->as_ArithmeticOp() != nullptr || cur->as_LogicOp() != nullptr || cur->as_ShiftOp() != nullptr) {\n+      assert(cur->as_Op2() != nullptr, \"must be Op2\");\n@@ -379,1 +379,1 @@\n-    } else if (cur->as_LoadField() != NULL) {\n+    } else if (cur->as_LoadField() != nullptr) {\n@@ -383,1 +383,1 @@\n-    } else if (cur->as_ArrayLength() != NULL) {\n+    } else if (cur->as_ArrayLength() != nullptr) {\n@@ -386,1 +386,1 @@\n-    } else if (cur->as_LoadIndexed() != NULL) {\n+    } else if (cur->as_LoadIndexed() != nullptr) {\n@@ -389,1 +389,1 @@\n-    } else if (cur->as_NegateOp() != NULL) {\n+    } else if (cur->as_NegateOp() != nullptr) {\n@@ -392,1 +392,1 @@\n-    } else if (cur->as_Convert() != NULL) {\n+    } else if (cur->as_Convert() != nullptr) {\n@@ -401,1 +401,1 @@\n-      if (cur->as_Constant() == NULL) {\n+      if (cur->as_Constant() == nullptr) {\n@@ -416,1 +416,1 @@\n-      cur->set_exception_handlers(NULL);\n+      cur->set_exception_handlers(nullptr);\n@@ -421,1 +421,1 @@\n-      if (cur->state_before() != NULL) {\n+      if (cur->state_before() != nullptr) {\n@@ -424,1 +424,1 @@\n-      if (cur->exception_state() != NULL) {\n+      if (cur->exception_state() != nullptr) {\n@@ -461,1 +461,1 @@\n-      if (pred_map != NULL) {\n+      if (pred_map != nullptr) {\n@@ -472,1 +472,1 @@\n-    for (Value instr = block->next(); instr != NULL; instr = instr->next()) {\n+    for (Value instr = block->next(); instr != nullptr; instr = instr->next()) {\n@@ -493,2 +493,2 @@\n-  , _current_map(NULL)\n-  , _value_maps(ir->linear_scan_order()->length(), ir->linear_scan_order()->length(), NULL)\n+  , _current_map(nullptr)\n+  , _value_maps(ir->linear_scan_order()->length(), ir->linear_scan_order()->length(), nullptr)\n@@ -505,2 +505,2 @@\n-  assert(start_block == ir->start() && start_block->number_of_preds() == 0 && start_block->dominator() == NULL, \"must be start block\");\n-  assert(start_block->next()->as_Base() != NULL && start_block->next()->next() == NULL, \"start block must not have instructions\");\n+  assert(start_block == ir->start() && start_block->number_of_preds() == 0 && start_block->dominator() == nullptr, \"must be start block\");\n+  assert(start_block->next()->as_Base() != nullptr && start_block->next()->next() == nullptr, \"start block must not have instructions\");\n@@ -510,1 +510,1 @@\n-     assert(value->as_Local() != NULL, \"only method parameters allowed\");\n+     assert(value->as_Local() != nullptr, \"only method parameters allowed\");\n@@ -525,2 +525,2 @@\n-    assert(dominator != NULL, \"dominator must exist\");\n-    assert(value_map_of(dominator) != NULL, \"value map of dominator must exist\");\n+    assert(dominator != nullptr, \"dominator must exist\");\n+    assert(value_map_of(dominator) != nullptr, \"value map of dominator must exist\");\n@@ -549,1 +549,1 @@\n-        if (pred_map != NULL) {\n+        if (pred_map != nullptr) {\n@@ -568,1 +568,1 @@\n-    for (Value instr = block->next(); instr != NULL; instr = instr->next()) {\n+    for (Value instr = block->next(); instr != nullptr; instr = instr->next()) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-  void          set_value_map_of(BlockBegin* block, ValueMap* map)   { assert(value_map_of(block) == NULL, \"\"); _value_maps.at_put(block->linear_scan_number(), map); }\n+  void          set_value_map_of(BlockBegin* block, ValueMap* map) { assert(value_map_of(block) == nullptr, \"\"); _value_maps.at_put(block->linear_scan_number(), map); }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-, _locals(scope->method()->max_locals(), scope->method()->max_locals(), NULL)\n+, _locals(scope->method()->max_locals(), scope->method()->max_locals(), nullptr)\n@@ -40,1 +40,1 @@\n-, _locks(NULL)\n+, _locks(nullptr)\n@@ -52,1 +52,1 @@\n-  , _locks(copy_from->locks_size() == 0 ? NULL : new Values(copy_from->locks_size()))\n+  , _locks(copy_from->locks_size() == 0 ? nullptr : new Values(copy_from->locks_size()))\n@@ -106,1 +106,1 @@\n-    if (value != NULL && value != s->lock_at(i)) {\n+    if (value != nullptr && value != s->lock_at(i)) {\n@@ -115,1 +115,1 @@\n-    _locals.at_put(i, NULL);\n+    _locals.at_put(i, nullptr);\n@@ -122,1 +122,1 @@\n-    if (v->as_Constant() == NULL && v->as_Local() == NULL) {\n+    if (v->as_Constant() == nullptr && v->as_Local() == nullptr) {\n@@ -134,1 +134,1 @@\n-    if (v0 != NULL && !v0->type()->is_illegal()) {\n+    if (v0 != nullptr && !v0->type()->is_illegal()) {\n@@ -139,1 +139,1 @@\n-      assert(!v1->type()->is_double_word() || list.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+      assert(!v1->type()->is_double_word() || list.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -152,1 +152,1 @@\n-    if (state->_locks != NULL) {\n+    if (state->_locks != nullptr) {\n@@ -179,1 +179,1 @@\n-  if (_locks == NULL) {\n+  if (_locks == nullptr) {\n@@ -197,1 +197,1 @@\n-  assert(stack_at(index)->as_Phi() == NULL || stack_at(index)->as_Phi()->block() != b, \"phi function already created\");\n+  assert(stack_at(index)->as_Phi() == nullptr || stack_at(index)->as_Phi()->block() != b, \"phi function already created\");\n@@ -203,1 +203,1 @@\n-  assert(!t->is_double_word() || _stack.at(index + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+  assert(!t->is_double_word() || _stack.at(index + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -207,1 +207,1 @@\n-  assert(local_at(index)->as_Phi() == NULL || local_at(index)->as_Phi()->block() != b, \"phi function already created\");\n+  assert(local_at(index)->as_Phi() == nullptr || local_at(index)->as_Phi()->block() != b, \"phi function already created\");\n@@ -236,1 +236,1 @@\n-      if (t == NULL) {\n+      if (t == nullptr) {\n@@ -250,1 +250,1 @@\n-      if (l == NULL) {\n+      if (l == nullptr) {\n@@ -262,1 +262,1 @@\n-  if (caller_state() != NULL) {\n+  if (caller_state() != nullptr) {\n@@ -269,2 +269,2 @@\n-  assert(scope() != NULL, \"scope must exist\");\n-  if (caller_state() != NULL) {\n+  assert(scope() != nullptr, \"scope must exist\");\n+  if (caller_state() != nullptr) {\n@@ -287,2 +287,2 @@\n-    if (v == NULL) {\n-      assert(_stack.at(i - 1)->type()->is_double_word(), \"only hi-words are NULL on stack\");\n+    if (v == nullptr) {\n+      assert(_stack.at(i - 1)->type()->is_double_word(), \"only hi-words are null on stack\");\n@@ -290,1 +290,1 @@\n-      assert(_stack.at(i + 1) == NULL, \"hi-word must be NULL\");\n+      assert(_stack.at(i + 1) == nullptr, \"hi-word must be null\");\n@@ -296,2 +296,2 @@\n-    if (v != NULL && v->type()->is_double_word()) {\n-      assert(_locals.at(i + 1) == NULL, \"hi-word must be NULL\");\n+    if (v != nullptr && v->type()->is_double_word()) {\n+      assert(_locals.at(i + 1) == nullptr, \"hi-word must be null\");\n@@ -302,1 +302,1 @@\n-    assert(v != NULL, \"just test if state-iteration succeeds\");\n+    assert(v != nullptr, \"just test if state-iteration succeeds\");\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    assert(h == NULL, \"hi-word of doubleword value must be NULL\");\n+    assert(h == nullptr, \"hi-word of doubleword value must be null\");\n@@ -95,1 +95,1 @@\n-  int locks_size() const                         { return _locks == NULL ? 0 : _locks->length(); }\n+  int locks_size() const                         { return _locks == nullptr ? 0 : _locks->length(); }\n@@ -97,1 +97,1 @@\n-  bool no_active_locks() const                   { return _locks == NULL || _locks->is_empty(); }\n+  bool no_active_locks() const                   { return _locks == nullptr || _locks->is_empty(); }\n@@ -101,1 +101,1 @@\n-  void clear_locals();                           \/\/ sets all locals to NULL;\n+  void clear_locals();                           \/\/ sets all locals to null;\n@@ -105,2 +105,2 @@\n-           _locals.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n-    _locals.at_put(i, NULL);\n+           _locals.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n+    _locals.at_put(i, nullptr);\n@@ -111,2 +111,2 @@\n-    assert(x == NULL || !x->type()->is_double_word() ||\n-           _locals.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+    assert(x == nullptr || !x->type()->is_double_word() ||\n+           _locals.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -121,2 +121,2 @@\n-      if (prev != NULL && prev->type()->is_double_word()) {\n-        _locals.at_put(i - 1, NULL);\n+      if (prev != nullptr && prev->type()->is_double_word()) {\n+        _locals.at_put(i - 1, nullptr);\n@@ -128,2 +128,2 @@\n-      \/\/ hi-word of doubleword value is always NULL\n-      _locals.at_put(i + 1, NULL);\n+      \/\/ hi-word of doubleword value is always null\n+      _locals.at_put(i + 1, nullptr);\n@@ -137,1 +137,1 @@\n-           _stack.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+           _stack.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -167,2 +167,2 @@\n-  void lpush(Value t)                            { _stack.push(check(longTag   , t)); _stack.push(NULL); }\n-  void dpush(Value t)                            { _stack.push(check(doubleTag , t)); _stack.push(NULL); }\n+  void lpush(Value t)                            { _stack.push(check(longTag   , t)); _stack.push(nullptr); }\n+  void dpush(Value t)                            { _stack.push(check(doubleTag , t)); _stack.push(nullptr); }\n@@ -197,1 +197,1 @@\n-      default        : ShouldNotReachHere(); return NULL;\n+      default        : ShouldNotReachHere(); return nullptr;\n@@ -240,1 +240,1 @@\n-\/\/ as an invariant, state is NULL now\n+\/\/ as an invariant, state is null now\n@@ -249,1 +249,1 @@\n-  for (; state != NULL; state = state->caller_state())\n+  for (; state != nullptr; state = state->caller_state())\n@@ -255,2 +255,2 @@\n-       index += (value == NULL || value->type()->is_illegal() ? 1 : value->type()->size()))    \\\n-    if (value != NULL)\n+       index += (value == nullptr || value->type()->is_illegal() ? 1 : value->type()->size())) \\\n+    if (value != nullptr)\n@@ -271,1 +271,1 @@\n-    if (value != NULL)\n+    if (value != nullptr)\n@@ -321,1 +321,1 @@\n-      if (v_phi != NULL && v_phi->block() == v_block) {                                        \\\n+      if (v_phi != nullptr && v_phi->block() == v_block) {                                     \\\n@@ -329,1 +329,1 @@\n-      if (v_phi != NULL && v_phi->block() == v_block) {                                        \\\n+      if (v_phi != nullptr && v_phi->block() == v_block) {                                     \\\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,11 +34,11 @@\n-VoidType*       voidType     = NULL;\n-IntType*        intType      = NULL;\n-LongType*       longType     = NULL;\n-FloatType*      floatType    = NULL;\n-DoubleType*     doubleType   = NULL;\n-ObjectType*     objectType   = NULL;\n-ArrayType*      arrayType    = NULL;\n-InstanceType*   instanceType = NULL;\n-ClassType*      classType    = NULL;\n-AddressType*    addressType  = NULL;\n-IllegalType*    illegalType  = NULL;\n+VoidType*       voidType     = nullptr;\n+IntType*        intType      = nullptr;\n+LongType*       longType     = nullptr;\n+FloatType*      floatType    = nullptr;\n+DoubleType*     doubleType   = nullptr;\n+ObjectType*     objectType   = nullptr;\n+ArrayType*      arrayType    = nullptr;\n+InstanceType*   instanceType = nullptr;\n+ClassType*      classType    = nullptr;\n+AddressType*    addressType  = nullptr;\n+IllegalType*    illegalType  = nullptr;\n@@ -48,3 +48,3 @@\n-IntConstant*    intZero      = NULL;\n-IntConstant*    intOne       = NULL;\n-ObjectConstant* objectNull   = NULL;\n+IntConstant*    intZero      = nullptr;\n+IntConstant*    intOne       = nullptr;\n+ObjectConstant* objectNull   = nullptr;\n@@ -92,1 +92,1 @@\n-  return (c != NULL && !c->is_null_object()) ? c->klass() : NULL;\n+  return (c != nullptr && !c->is_null_object()) ? c->klass() : nullptr;\n@@ -96,1 +96,1 @@\n-  return (c != NULL && !c->is_null_object()) ? c->klass() : NULL;\n+  return (c != nullptr && !c->is_null_object()) ? c->klass() : nullptr;\n@@ -100,1 +100,1 @@\n-  return (c != NULL && !c->is_null_object()) ? c->klass() : NULL;\n+  return (c != nullptr && !c->is_null_object()) ? c->klass() : nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,6 +127,6 @@\n-  bool is_object()                               { return as_ObjectType()   != NULL; }\n-  bool is_array()                                { return as_ArrayType()    != NULL; }\n-  bool is_instance()                             { return as_InstanceType() != NULL; }\n-  bool is_class()                                { return as_ClassType()    != NULL; }\n-  bool is_method()                               { return as_MethodType()   != NULL; }\n-  bool is_address()                              { return as_AddressType()  != NULL; }\n+  bool is_object()                               { return as_ObjectType()   != nullptr; }\n+  bool is_array()                                { return as_ArrayType()    != nullptr; }\n+  bool is_instance()                             { return as_InstanceType() != nullptr; }\n+  bool is_class()                                { return as_ClassType()    != nullptr; }\n+  bool is_method()                               { return as_MethodType()   != nullptr; }\n+  bool is_address()                              { return as_AddressType()  != nullptr; }\n@@ -143,24 +143,24 @@\n-  virtual VoidType*         as_VoidType()        { return NULL; }\n-  virtual IntType*          as_IntType()         { return NULL; }\n-  virtual LongType*         as_LongType()        { return NULL; }\n-  virtual FloatType*        as_FloatType()       { return NULL; }\n-  virtual DoubleType*       as_DoubleType()      { return NULL; }\n-  virtual ObjectType*       as_ObjectType()      { return NULL; }\n-  virtual ArrayType*        as_ArrayType()       { return NULL; }\n-  virtual InstanceType*     as_InstanceType()    { return NULL; }\n-  virtual ClassType*        as_ClassType()       { return NULL; }\n-  virtual MetadataType*     as_MetadataType()    { return NULL; }\n-  virtual MethodType*       as_MethodType()      { return NULL; }\n-  virtual AddressType*      as_AddressType()     { return NULL; }\n-  virtual IllegalType*      as_IllegalType()     { return NULL; }\n-  virtual IntConstant*      as_IntConstant()     { return NULL; }\n-  virtual LongConstant*     as_LongConstant()    { return NULL; }\n-  virtual FloatConstant*    as_FloatConstant()   { return NULL; }\n-  virtual DoubleConstant*   as_DoubleConstant()  { return NULL; }\n-  virtual ObjectConstant*   as_ObjectConstant()  { return NULL; }\n-  virtual InstanceConstant* as_InstanceConstant(){ return NULL; }\n-  virtual ClassConstant*    as_ClassConstant()   { return NULL; }\n-  virtual MethodConstant*   as_MethodConstant()  { return NULL; }\n-  virtual ArrayConstant*    as_ArrayConstant()   { return NULL; }\n-  virtual StableArrayConstant* as_StableArrayConstant()   { return NULL; }\n-  virtual AddressConstant*  as_AddressConstant() { return NULL; }\n+  virtual VoidType*         as_VoidType()        { return nullptr; }\n+  virtual IntType*          as_IntType()         { return nullptr; }\n+  virtual LongType*         as_LongType()        { return nullptr; }\n+  virtual FloatType*        as_FloatType()       { return nullptr; }\n+  virtual DoubleType*       as_DoubleType()      { return nullptr; }\n+  virtual ObjectType*       as_ObjectType()      { return nullptr; }\n+  virtual ArrayType*        as_ArrayType()       { return nullptr; }\n+  virtual InstanceType*     as_InstanceType()    { return nullptr; }\n+  virtual ClassType*        as_ClassType()       { return nullptr; }\n+  virtual MetadataType*     as_MetadataType()    { return nullptr; }\n+  virtual MethodType*       as_MethodType()      { return nullptr; }\n+  virtual AddressType*      as_AddressType()     { return nullptr; }\n+  virtual IllegalType*      as_IllegalType()     { return nullptr; }\n+  virtual IntConstant*      as_IntConstant()     { return nullptr; }\n+  virtual LongConstant*     as_LongConstant()    { return nullptr; }\n+  virtual FloatConstant*    as_FloatConstant()   { return nullptr; }\n+  virtual DoubleConstant*   as_DoubleConstant()  { return nullptr; }\n+  virtual ObjectConstant*   as_ObjectConstant()  { return nullptr; }\n+  virtual InstanceConstant* as_InstanceConstant(){ return nullptr; }\n+  virtual ClassConstant*    as_ClassConstant()   { return nullptr; }\n+  virtual MethodConstant*   as_MethodConstant()  { return nullptr; }\n+  virtual ArrayConstant*    as_ArrayConstant()   { return nullptr; }\n+  virtual StableArrayConstant* as_StableArrayConstant()   { return nullptr; }\n+  virtual AddressConstant*  as_AddressConstant() { return nullptr; }\n@@ -289,2 +289,2 @@\n-  virtual ciObject* constant_value() const       { ShouldNotReachHere(); return NULL; }\n-  virtual ciType* exact_type() const             { return NULL; }\n+  virtual ciObject* constant_value() const       { ShouldNotReachHere(); return nullptr; }\n+  virtual ciType* exact_type() const             { return nullptr; }\n@@ -379,1 +379,1 @@\n-  virtual ciMetadata* constant_value() const            { ShouldNotReachHere(); return NULL;  }\n+  virtual ciMetadata* constant_value() const            { ShouldNotReachHere(); return nullptr;  }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.hpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  address src_obj = src_info->obj();\n+  address src_obj = src_info->source_addr();\n@@ -179,2 +179,0 @@\n-  clean_up_src_obj_table();\n-\n@@ -430,1 +428,0 @@\n-  ref->set_keep_after_pushing();\n@@ -592,2 +589,1 @@\n-  MetaspaceClosure::Ref* ref = src_info->ref();\n-  address src = ref->obj();\n+  address src = src_info->source_addr();\n@@ -600,1 +596,1 @@\n-  if (ref->msotype() == MetaspaceObj::ClassType) {\n+  if (src_info->msotype() == MetaspaceObj::ClassType) {\n@@ -624,1 +620,1 @@\n-  intptr_t* archived_vtable = CppVtables::get_archived_vtable(ref->msotype(), (address)dest);\n+  intptr_t* archived_vtable = CppVtables::get_archived_vtable(src_info->msotype(), (address)dest);\n@@ -633,1 +629,1 @@\n-  _alloc_stats.record(ref->msotype(), int(newtop - oldtop), src_info->read_only());\n+  _alloc_stats.record(src_info->msotype(), int(newtop - oldtop), src_info->read_only());\n@@ -1100,5 +1096,0 @@\n-void ArchiveBuilder::clean_up_src_obj_table() {\n-  SrcObjTableCleaner cleaner;\n-  _src_obj_table.iterate(&cleaner);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    MetaspaceClosure::Ref* _ref; \/\/ The object that's copied into the buffer\n@@ -133,4 +132,2 @@\n-    address _source_addr;    \/\/ The value of the source object (_ref->obj()) when this\n-                             \/\/ SourceObjInfo was created. Note that _ref->obj() may change\n-                             \/\/ later if _ref is relocated.\n-    address _buffered_addr;  \/\/ The copy of _ref->obj() insider the buffer.\n+    address _source_addr;    \/\/ The source object to be copied.\n+    address _buffered_addr;  \/\/ The copy of this object insider the buffer.\n@@ -139,1 +136,1 @@\n-      _ref(ref), _ptrmap_start(0), _ptrmap_end(0), _read_only(read_only), _follow_mode(follow_mode),\n+      _ptrmap_start(0), _ptrmap_end(0), _read_only(read_only), _follow_mode(follow_mode),\n@@ -150,1 +147,0 @@\n-    MetaspaceClosure::Ref* ref() const { return  _ref; }\n@@ -164,1 +160,6 @@\n-    address buffered_addr() const  { return _buffered_addr; }\n+    address buffered_addr() const  {\n+      if (_follow_mode != set_to_null) {\n+        assert(_buffered_addr != nullptr, \"must be initialized\");\n+      }\n+      return _buffered_addr;\n+    }\n@@ -166,3 +167,0 @@\n-\n-    \/\/ convenience accessor\n-    address obj() const { return ref()->obj(); }\n@@ -190,8 +188,0 @@\n-  class SrcObjTableCleaner {\n-  public:\n-    bool do_entry(address key, const SourceObjInfo& value) {\n-      delete value.ref();\n-      return true;\n-    }\n-  };\n-\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,45 +34,0 @@\n-\/\/ This constructor is used only by SystemDictionaryShared::clone_dumptime_tables().\n-\/\/ See comments there about the need for making a deep copy.\n-DumpTimeClassInfo::DumpTimeClassInfo(const DumpTimeClassInfo& src) {\n-  assert(DynamicDumpSharedSpaces, \"must be\");\n-\n-  _klass = src._klass;\n-  _nest_host = src._nest_host;\n-  _failed_verification = src._failed_verification;\n-  _is_archived_lambda_proxy = src._is_archived_lambda_proxy;\n-  _has_checked_exclusion = src._has_checked_exclusion;\n-  _id = src._id;\n-  _clsfile_size = src._clsfile_size;\n-  _clsfile_crc32 = src._clsfile_crc32;\n-  _excluded = src._excluded;\n-  _is_early_klass = src._is_early_klass;\n-  _verifier_constraints = nullptr;\n-  _verifier_constraint_flags = nullptr;\n-  _loader_constraints = nullptr;\n-\n-  assert(src._enum_klass_static_fields == nullptr, \"This should not happen with dynamic dump.\");\n-  _enum_klass_static_fields = nullptr;\n-\n-  {\n-    int n = src.num_verifier_constraints();\n-    if (n > 0) {\n-      _verifier_constraints = new (mtClass) GrowableArray<DTVerifierConstraint>(n, mtClass);\n-      _verifier_constraint_flags = new (mtClass) GrowableArray<char>(n, mtClass);\n-      for (int i = 0; i < n; i++) {\n-        _verifier_constraints->append(src._verifier_constraints->at(i));\n-        _verifier_constraint_flags->append(src._verifier_constraint_flags->at(i));\n-      }\n-    }\n-  }\n-\n-  {\n-    int n = src.num_loader_constraints();\n-    if (n > 0) {\n-      _loader_constraints = new (mtClass) GrowableArray<DTLoaderConstraint>(n, mtClass);\n-      for (int i = 0; i < n; i++) {\n-        _loader_constraints->append(src._loader_constraints->at(i));\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-  DumpTimeClassInfo(const DumpTimeClassInfo& src);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,3 +120,0 @@\n-    \/\/ save dumptime tables\n-    SystemDictionaryShared::clone_dumptime_tables();\n-\n@@ -170,3 +167,0 @@\n-    \/\/ Restore dumptime tables\n-    SystemDictionaryShared::restore_dumptime_tables();\n-\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -475,2 +475,0 @@\n-  static void copy_shared_path_table(ClassLoaderData* loader_data, TRAPS);\n-  static void clone_shared_path_table(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,13 +31,0 @@\n-\/\/ This constructor is used only by SystemDictionaryShared::clone_dumptime_tables().\n-\/\/ See comments there about the need for making a deep copy.\n-DumpTimeLambdaProxyClassInfo::DumpTimeLambdaProxyClassInfo(const DumpTimeLambdaProxyClassInfo& src) {\n-  _proxy_klasses = nullptr;\n-  if (src._proxy_klasses != nullptr && src._proxy_klasses->length() > 0) {\n-    int n = src._proxy_klasses->length();\n-    _proxy_klasses = new (mtClassShared) GrowableArray<InstanceKlass*>(n, mtClassShared);\n-    for (int i = 0; i < n; i++) {\n-      _proxy_klasses->append(src._proxy_klasses->at(i));\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-  DumpTimeLambdaProxyClassInfo(const DumpTimeLambdaProxyClassInfo& src);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -797,1 +797,1 @@\n-                                        int index) {\n+                                        int index, Bytecodes::Code bc) {\n@@ -800,1 +800,1 @@\n-    ciField* field = new (arena()) ciField(accessor, index);\n+    ciField* field = new (arena()) ciField(accessor, index, bc);\n@@ -805,1 +805,1 @@\n-      field = new (arena()) ciField(accessor, index);\n+      field = new (arena()) ciField(accessor, index, bc);\n@@ -817,2 +817,2 @@\n-                                   int index) {\n-  GUARDED_VM_ENTRY(return get_field_by_index_impl(accessor, index);)\n+                                   int index, Bytecodes::Code bc) {\n+  GUARDED_VM_ENTRY(return get_field_by_index_impl(accessor, index, bc);)\n@@ -885,1 +885,1 @@\n-    ciSymbol*        signature = get_symbol(cpool->signature_ref_at(index));\n+    ciSymbol*        signature = get_symbol(cpool->signature_ref_at(index, bc));\n@@ -888,1 +888,1 @@\n-    const int holder_index = cpool->klass_ref_index_at(index);\n+    const int holder_index = cpool->klass_ref_index_at(index, bc);\n@@ -893,2 +893,2 @@\n-    Symbol* name_sym = cpool->name_ref_at(index);\n-    Symbol* sig_sym  = cpool->signature_ref_at(index);\n+    Symbol* name_sym = cpool->name_ref_at(index, bc);\n+    Symbol* sig_sym  = cpool->signature_ref_at(index, bc);\n@@ -920,1 +920,1 @@\n-      constantTag tag = cpool->tag_ref_at(index);\n+      constantTag tag = cpool->tag_ref_at(index, bc);\n@@ -1536,1 +1536,1 @@\n-  const int holder_index = cp->klass_ref_index_at(index);\n+  const int holder_index = cp->klass_ref_index_at(index, Bytecodes::_invokehandle);\n@@ -1541,1 +1541,1 @@\n-  Symbol* name = cp->name_ref_at(index);\n+  Symbol* name = cp->name_ref_at(index, Bytecodes::_invokehandle);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-                                int field_index);\n+                                int field_index, Bytecodes::Code bc);\n@@ -152,1 +152,1 @@\n-                                     int field_index);\n+                                     int field_index, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-ciField::ciField(ciInstanceKlass* klass, int index) :\n+ciField::ciField(ciInstanceKlass* klass, int index, Bytecodes::Code bc) :\n@@ -85,1 +85,1 @@\n-  Symbol* name  = cpool->name_ref_at(index);\n+  Symbol* name  = cpool->name_ref_at(index, bc);\n@@ -88,1 +88,1 @@\n-  int nt_index = cpool->name_and_type_ref_index_at(index);\n+  int nt_index = cpool->name_and_type_ref_index_at(index, bc);\n@@ -112,1 +112,1 @@\n-  int holder_index = cpool->klass_ref_index_at(index);\n+  int holder_index = cpool->klass_ref_index_at(index, bc);\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  ciField(ciInstanceKlass* klass, int index);\n+  ciField(ciInstanceKlass* klass, int index, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1181,1 +1181,1 @@\n-bool ciMethod::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {\n+bool ciMethod::is_klass_loaded(int refinfo_index, Bytecodes::Code bc, bool must_be_resolved) const {\n@@ -1183,1 +1183,1 @@\n-  return get_Method()->is_klass_loaded(refinfo_index, must_be_resolved);\n+  return get_Method()->is_klass_loaded(refinfo_index, bc, must_be_resolved);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-  bool is_klass_loaded(int refinfo_index, bool must_be_resolved) const;\n+  bool is_klass_loaded(int refinfo_index, Bytecodes::Code bc, bool must_be_resolved) const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -431,2 +431,2 @@\n-        Klass* holder = cp->klass_ref_at(index, CHECK_NULL);\n-        Symbol* name = cp->name_ref_at(index);\n+        Klass* holder = cp->klass_ref_at(index, bytecode.code(), CHECK_NULL);\n+        Symbol* name = cp->name_ref_at(index, bytecode.code());\n@@ -1104,0 +1104,1 @@\n+          parse_klass(CHECK); \/\/ eat up the array class name\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  ciField* f = CURRENT_ENV->get_field_by_index(_holder, get_field_index());\n+  ciField* f = CURRENT_ENV->get_field_by_index(_holder, get_field_index(), _bc);\n@@ -346,1 +346,1 @@\n-    return cpool->klass_ref_index_at(get_field_index());\n+    return cpool->klass_ref_index_at(get_field_index(), _bc);\n@@ -530,1 +530,1 @@\n-  return cpool->klass_ref_index_at(get_method_index());\n+  return cpool->klass_ref_index_at(get_method_index(), _bc);\n@@ -542,1 +542,1 @@\n-    const int name_and_type_index = cpool->name_and_type_ref_index_at(method_index);\n+    const int name_and_type_index = cpool->name_and_type_ref_index_at(method_index, _bc);\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -306,2 +306,2 @@\n-  static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }\n-  static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }\n+  static ByteSize holder_offset()     { return byte_offset_of(ClassLoaderData, _holder); }\n+  static ByteSize keep_alive_offset() { return byte_offset_of(ClassLoaderData, _keep_alive); }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1367,1 +1367,9 @@\n-  assert(Universe::java_mirror(type) == java_class, \"must be consistent\");\n+#ifdef ASSERT\n+  if (DumpSharedSpaces) {\n+    oop mirror = Universe::java_mirror(type);\n+    oop scratch_mirror = HeapShared::scratch_java_mirror(type);\n+    assert(java_class == mirror || java_class == scratch_mirror, \"must be consistent\");\n+  } else {\n+    assert(Universe::java_mirror(type) == java_class, \"must be consistent\");\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -1128,1 +1129,2 @@\n-  assert(!ik->is_unshareable_info_restored(), \"shared class can be loaded only once\");\n+  assert(!ik->is_unshareable_info_restored(), \"shared class can be restored only once\");\n+  assert(Atomic::add(&ik->_shared_class_load_count, 1) == 1, \"shared class loaded more than once\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = nullptr;\n@@ -82,1 +81,0 @@\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -1443,81 +1441,0 @@\n-class CloneDumpTimeClassTable: public StackObj {\n-  DumpTimeSharedClassTable* _table;\n-  DumpTimeSharedClassTable* _cloned_table;\n- public:\n-  CloneDumpTimeClassTable(DumpTimeSharedClassTable* table, DumpTimeSharedClassTable* clone) :\n-                      _table(table), _cloned_table(clone) {\n-    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n-    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n-  }\n-  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n-    bool created;\n-    _cloned_table->put_if_absent(k, info, &created);\n-    assert(created, \"must be\");\n-  }\n-};\n-\n-class CloneDumpTimeLambdaProxyClassTable: StackObj {\n-  DumpTimeLambdaProxyClassDictionary* _table;\n-  DumpTimeLambdaProxyClassDictionary* _cloned_table;\n- public:\n-  CloneDumpTimeLambdaProxyClassTable(DumpTimeLambdaProxyClassDictionary* table,\n-                                     DumpTimeLambdaProxyClassDictionary* clone) :\n-                      _table(table), _cloned_table(clone) {\n-    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n-    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n-  }\n-\n-  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    assert_lock_strong(DumpTimeTable_lock);\n-    bool created;\n-    \/\/ make copies then store in _clone_table\n-    LambdaProxyClassKey keyCopy = key;\n-    _cloned_table->put_if_absent(keyCopy, info, &created);\n-    assert(created, \"must be\");\n-    ++ _cloned_table->_count;\n-    return true; \/\/ keep on iterating\n-  }\n-};\n-\n-\/\/ When dumping the CDS archive, the ArchiveBuilder will irrecoverably modify the\n-\/\/ _dumptime_table and _dumptime_lambda_proxy_class_dictionary (e.g., metaspace\n-\/\/ pointers are changed to use \"buffer\" addresses.)\n-\/\/\n-\/\/ We save a copy of these tables and restore them after the dumping is finished.\n-\/\/ This makes it possible to repeat the dumping operation (e.g., use\n-\/\/ \"jcmd VM.cds dynamic_dump\" multiple times on the same JVM process).\n-\/\/\n-\/\/ We use the copy constructors to clone the values in these tables. The copy constructors\n-\/\/ must make a deep copy, as internal data structures such as the contents of\n-\/\/ DumpTimeClassInfo::_loader_constraints are also modified by the ArchiveBuilder.\n-\n-void SystemDictionaryShared::clone_dumptime_tables() {\n-  Arguments::assert_is_dumping_archive();\n-  assert_lock_strong(DumpTimeTable_lock);\n-\n-  assert(_cloned_dumptime_table == nullptr, \"_cloned_dumptime_table must be cleaned\");\n-  _cloned_dumptime_table = new (mtClass) DumpTimeSharedClassTable;\n-  CloneDumpTimeClassTable copy_classes(_dumptime_table, _cloned_dumptime_table);\n-  _dumptime_table->iterate_all_live_classes(&copy_classes);\n-  _cloned_dumptime_table->update_counts();\n-\n-  assert(_cloned_dumptime_lambda_proxy_class_dictionary == nullptr,\n-         \"_cloned_dumptime_lambda_proxy_class_dictionary must be cleaned\");\n-  _cloned_dumptime_lambda_proxy_class_dictionary =\n-                                        new (mtClass) DumpTimeLambdaProxyClassDictionary;\n-  CloneDumpTimeLambdaProxyClassTable copy_proxy_classes(_dumptime_lambda_proxy_class_dictionary,\n-                                                        _cloned_dumptime_lambda_proxy_class_dictionary);\n-  _dumptime_lambda_proxy_class_dictionary->iterate(&copy_proxy_classes);\n-}\n-\n-void SystemDictionaryShared::restore_dumptime_tables() {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  delete _dumptime_table;\n-  _dumptime_table = _cloned_dumptime_table;\n-  _cloned_dumptime_table = nullptr;\n-\n-  delete _dumptime_lambda_proxy_class_dictionary;\n-  _dumptime_lambda_proxy_class_dictionary = _cloned_dumptime_lambda_proxy_class_dictionary;\n-  _cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static DumpTimeSharedClassTable* _cloned_dumptime_table;\n@@ -169,1 +168,0 @@\n-  static DumpTimeLambdaProxyClassDictionary* _cloned_dumptime_lambda_proxy_class_dictionary;\n@@ -293,9 +291,0 @@\n-  \/\/ For repeatable dumping, we\n-  \/\/   1. clone DumpTimeSharedClassTable, same for DumpTimeLambdaProxyClassDictionary\n-  \/\/      clone SharedClassPathTable\n-  \/\/   2. do dumping\n-  \/\/   3. restore DumpTimeSharedClassTable, DumpTimeLambdaProxyClassDictionary and SharedClassPathTable\n-  \/\/      from cloned versions.\n-  static void clone_dumptime_tables();\n-  static void restore_dumptime_tables();\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -702,3 +702,3 @@\n-  static int verified_entry_point_offset()        { return offset_of(nmethod, _verified_entry_point); }\n-  static int osr_entry_point_offset()             { return offset_of(nmethod, _osr_entry_point); }\n-  static int state_offset()                       { return offset_of(nmethod, _state); }\n+  static ByteSize verified_entry_point_offset() { return byte_offset_of(nmethod, _verified_entry_point); }\n+  static ByteSize osr_entry_point_offset()      { return byte_offset_of(nmethod, _osr_entry_point); }\n+  static ByteSize state_offset()                { return byte_offset_of(nmethod, _state); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -792,1 +792,1 @@\n-  lib_offset = jvm_offset = strlen(buf);\n+  lib_offset = jvm_offset = (int)strlen(buf);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1424,7 +1424,1 @@\n-      _nm_cl() {\n-    ClassLoaderDataGraph_lock->lock();\n-  }\n-\n-  ~ZRemapYoungRootsTask() {\n-    ClassLoaderDataGraph_lock->unlock();\n-  }\n+      _nm_cl() {}\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -832,7 +832,1 @@\n-      _nm_cl() {\n-    ClassLoaderDataGraph_lock->lock();\n-  }\n-\n-  ~ZMarkOldRootsTask() {\n-    ClassLoaderDataGraph_lock->unlock();\n-  }\n+      _nm_cl() {}\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-  JMM_VERSION     = JMM_VERSION_3\n+  JMM_VERSION_4   = 0x20040000, \/\/ JDK 21\n+  JMM_VERSION     = JMM_VERSION_4\n@@ -243,0 +244,2 @@\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n+                                                 (JNIEnv *env);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  return constants()->klass_ref_at_noresolve(index());\n+  return constants()->klass_ref_at_noresolve(index(), _code);\n@@ -139,1 +139,1 @@\n-  return constants()->name_ref_at(index());\n+  return constants()->name_ref_at(index(), _code);\n@@ -144,1 +144,1 @@\n-  return constants()->signature_ref_at(index());\n+  return constants()->signature_ref_at(index(), _code);\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-static void print_method_name(outputStream *os, Method* method, int cp_index) {\n+static void print_method_name(outputStream *os, Method* method, int cp_index, Bytecodes::Code bc) {\n@@ -277,3 +277,3 @@\n-  Symbol* klass     = cp->klass_ref_at_noresolve(cp_index);\n-  Symbol* name      = cp->name_ref_at(cp_index);\n-  Symbol* signature = cp->signature_ref_at(cp_index);\n+  Symbol* klass     = cp->klass_ref_at_noresolve(cp_index, bc);\n+  Symbol* name      = cp->name_ref_at(cp_index, bc);\n+  Symbol* signature = cp->signature_ref_at(cp_index, bc);\n@@ -290,1 +290,1 @@\n-static void print_field_and_class(outputStream *os, Method* method, int cp_index) {\n+static void print_field_and_class(outputStream *os, Method* method, int cp_index, Bytecodes::Code bc) {\n@@ -293,2 +293,2 @@\n-  Symbol* klass    = cp->klass_ref_at_noresolve(cp_index);\n-  Symbol *name     = cp->name_ref_at(cp_index);\n+  Symbol* klass    = cp->klass_ref_at_noresolve(cp_index, bc);\n+  Symbol *name     = cp->name_ref_at(cp_index, bc);\n@@ -301,2 +301,2 @@\n-static char const* get_field_name(Method* method, int cp_index) {\n-  Symbol* name = method->constants()->name_ref_at(cp_index);\n+static char const* get_field_name(Method* method, int cp_index, Bytecodes::Code bc) {\n+  Symbol* name = method->constants()->name_ref_at(cp_index, bc);\n@@ -973,1 +973,1 @@\n-      int name_and_type_index = cp->name_and_type_ref_index_at(cp_index);\n+      int name_and_type_index = cp->name_and_type_ref_index_at(cp_index, code);\n@@ -987,1 +987,1 @@\n-      int name_and_type_index = cp->name_and_type_ref_index_at(cp_index);\n+      int name_and_type_index = cp->name_and_type_ref_index_at(cp_index, code);\n@@ -1009,1 +1009,1 @@\n-      int name_and_type_index = cp->name_and_type_ref_index_at(cp_index);\n+      int name_and_type_index = cp->name_and_type_ref_index_at(cp_index, code);\n@@ -1137,1 +1137,1 @@\n-        int name_and_type_index = cp->name_and_type_ref_index_at(cp_index);\n+        int name_and_type_index = cp->name_and_type_ref_index_at(cp_index, code);\n@@ -1148,1 +1148,1 @@\n-        int name_and_type_index = cp->name_and_type_ref_index_at(cp_index);\n+        int name_and_type_index = cp->name_and_type_ref_index_at(cp_index, code);\n@@ -1330,1 +1330,1 @@\n-      print_field_and_class(os, _method, cp_index);\n+      print_field_and_class(os, _method, cp_index, code);\n@@ -1341,1 +1341,1 @@\n-      os->print(\"%s\", get_field_name(_method, cp_index));\n+      os->print(\"%s\", get_field_name(_method, cp_index, code));\n@@ -1353,1 +1353,1 @@\n-      print_method_name(os, _method, cp_index);\n+      print_method_name(os, _method, cp_index, code);\n@@ -1419,1 +1419,1 @@\n-        int name_and_type_index = cp->name_and_type_ref_index_at(cp_index);\n+        int name_and_type_index = cp->name_and_type_ref_index_at(cp_index, code);\n@@ -1426,1 +1426,1 @@\n-        os->print(\"Cannot assign field \\\"%s\\\"\", get_field_name(_method, cp_index));\n+        os->print(\"Cannot assign field \\\"%s\\\"\", get_field_name(_method, cp_index, code));\n@@ -1433,1 +1433,1 @@\n-        print_method_name(os, _method, cp_index);\n+        print_method_name(os, _method, cp_index, code);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1508,2 +1508,2 @@\n-  Symbol* cname = cpool->klass_name_at(cpool->klass_ref_index_at(cp_index));\n-  Symbol* mname = cpool->name_ref_at(cp_index);\n+  Symbol* cname = cpool->klass_name_at(cpool->klass_ref_index_at(cp_index, code));\n+  Symbol* mname = cpool->name_ref_at(cp_index, code);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-LinkInfo::LinkInfo(const constantPoolHandle& pool, int index, const methodHandle& current_method, TRAPS) {\n+LinkInfo::LinkInfo(const constantPoolHandle& pool, int index, const methodHandle& current_method, Bytecodes::Code code, TRAPS) {\n@@ -233,1 +233,1 @@\n-  _resolved_klass = pool->klass_ref_at(index, CHECK);\n+  _resolved_klass = pool->klass_ref_at(index, code, CHECK);\n@@ -236,3 +236,3 @@\n-  _name          = pool->name_ref_at(index);\n-  _signature     = pool->signature_ref_at(index);\n-  _tag           = pool->tag_ref_at(index);\n+  _name          = pool->name_ref_at(index, code);\n+  _signature     = pool->signature_ref_at(index, code);\n+  _tag           = pool->tag_ref_at(index, code);\n@@ -247,1 +247,1 @@\n-LinkInfo::LinkInfo(const constantPoolHandle& pool, int index, TRAPS) {\n+LinkInfo::LinkInfo(const constantPoolHandle& pool, int index, Bytecodes::Code code, TRAPS) {\n@@ -249,1 +249,1 @@\n-  _resolved_klass = pool->klass_ref_at(index, CHECK);\n+  _resolved_klass = pool->klass_ref_at(index, code, CHECK);\n@@ -252,3 +252,3 @@\n-  _name          = pool->name_ref_at(index);\n-  _signature     = pool->signature_ref_at(index);\n-  _tag           = pool->tag_ref_at(index);\n+  _name          = pool->name_ref_at(index, code);\n+  _signature     = pool->signature_ref_at(index, code);\n+  _tag           = pool->tag_ref_at(index, code);\n@@ -621,1 +621,1 @@\n-    Symbol* method_signature = pool->signature_ref_at(index);\n+    Symbol* method_signature = pool->signature_ref_at(index, code);\n@@ -627,1 +627,1 @@\n-  LinkInfo link_info(pool, index, methodHandle(), CHECK_NULL);\n+  LinkInfo link_info(pool, index, methodHandle(), code, CHECK_NULL);\n@@ -953,1 +953,1 @@\n-  LinkInfo link_info(pool, index, method, CHECK);\n+  LinkInfo link_info(pool, index, method, byte, CHECK);\n@@ -1671,1 +1671,1 @@\n-  LinkInfo link_info(pool, index, CHECK);\n+  LinkInfo link_info(pool, index, Bytecodes::_invokestatic, CHECK);\n@@ -1678,1 +1678,1 @@\n-  LinkInfo link_info(pool, index, CHECK);\n+  LinkInfo link_info(pool, index, Bytecodes::_invokespecial, CHECK);\n@@ -1687,1 +1687,1 @@\n-  LinkInfo link_info(pool, index, CHECK);\n+  LinkInfo link_info(pool, index, Bytecodes::_invokevirtual, CHECK);\n@@ -1694,1 +1694,1 @@\n-  LinkInfo link_info(pool, index, CHECK);\n+  LinkInfo link_info(pool, index, Bytecodes::_invokeinterface, CHECK);\n@@ -1715,1 +1715,1 @@\n-  LinkInfo link_info(pool, index, CHECK);\n+  LinkInfo link_info(pool, index, Bytecodes::_invokehandle, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -149,2 +149,2 @@\n-  LinkInfo(const constantPoolHandle& pool, int index, const methodHandle& current_method, TRAPS);\n-  LinkInfo(const constantPoolHandle& pool, int index, TRAPS);\n+  LinkInfo(const constantPoolHandle& pool, int index, const methodHandle& current_method, Bytecodes::Code code, TRAPS);\n+  LinkInfo(const constantPoolHandle& pool, int index, Bytecodes::Code code, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  static ByteSize trace_id_offset() { return in_ByteSize(offset_of(InstanceKlass, _trace_id)); }\n+  static ByteSize trace_id_offset() { return byte_offset_of(InstanceKlass, _trace_id); }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassExtension.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  static ByteSize jfr_thread_local_offset() { return in_ByteSize(offset_of(Thread, _jfr_thread_local)); }\n+  static ByteSize jfr_thread_local_offset() { return byte_offset_of(Thread, _jfr_thread_local); }\n@@ -39,1 +39,1 @@\n-  static ByteSize trace_id_offset() { return in_ByteSize(offset_of(JfrThreadLocal, _trace_id)); }\n+  static ByteSize trace_id_offset() { return byte_offset_of(JfrThreadLocal, _trace_id); }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadExtension.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  return in_ByteSize(offset_of(JfrThreadLocal, _java_event_writer));\n+  return byte_offset_of(JfrThreadLocal, _java_event_writer);\n@@ -250,1 +250,1 @@\n-  return in_ByteSize(offset_of(JfrThreadLocal, _vthread_id));\n+  return byte_offset_of(JfrThreadLocal, _vthread_id);\n@@ -254,1 +254,1 @@\n-  return in_ByteSize(offset_of(JfrThreadLocal, _vthread));\n+  return byte_offset_of(JfrThreadLocal, _vthread);\n@@ -258,1 +258,1 @@\n-  return in_ByteSize(offset_of(JfrThreadLocal, _vthread_epoch));\n+  return byte_offset_of(JfrThreadLocal, _vthread_epoch);\n@@ -262,1 +262,1 @@\n-  return in_ByteSize(offset_of(JfrThreadLocal, _vthread_excluded));\n+  return byte_offset_of(JfrThreadLocal, _vthread_excluded);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-      if (offset == ConstantPool::pool_holder_offset_in_bytes()) {\n+      if (offset == in_bytes(ConstantPool::pool_holder_offset())) {\n@@ -817,1 +817,1 @@\n-C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jint opcode))\n@@ -819,1 +819,1 @@\n-  return cp->name_and_type_ref_index_at(index);\n+  return cp->name_and_type_ref_index_at(index, (Bytecodes::Code)opcode);\n@@ -822,1 +822,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which, jint opcode))\n@@ -824,1 +824,1 @@\n-  JVMCIObject sym = JVMCIENV->create_string(cp->name_ref_at(which), JVMCI_CHECK_NULL);\n+  JVMCIObject sym = JVMCIENV->create_string(cp->name_ref_at(which, (Bytecodes::Code)opcode), JVMCI_CHECK_NULL);\n@@ -828,1 +828,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which, jint opcode))\n@@ -830,1 +830,1 @@\n-  JVMCIObject sym = JVMCIENV->create_string(cp->signature_ref_at(which), JVMCI_CHECK_NULL);\n+  JVMCIObject sym = JVMCIENV->create_string(cp->signature_ref_at(which, (Bytecodes::Code)opcode), JVMCI_CHECK_NULL);\n@@ -834,1 +834,1 @@\n-C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jint opcode))\n@@ -836,1 +836,1 @@\n-  return cp->klass_ref_index_at(index);\n+  return cp->klass_ref_index_at(index, (Bytecodes::Code)opcode);\n@@ -909,1 +909,1 @@\n-  LinkInfo link_info(cp, index, mh, CHECK_NULL);\n+  LinkInfo link_info(cp, index, mh, code, CHECK_NULL);\n@@ -1595,2 +1595,2 @@\n-  Klass* holder = cp->klass_ref_at(index, CHECK);\n-  Symbol* name = cp->name_ref_at(index);\n+  Klass* holder = cp->klass_ref_at(index, Bytecodes::_invokehandle, CHECK);\n+  Symbol* name = cp->name_ref_at(index, Bytecodes::_invokehandle);\n@@ -1612,1 +1612,1 @@\n-    LinkInfo link_info(cp, index, CATCH);\n+    LinkInfo link_info(cp, index, Bytecodes::_invokehandle, CATCH);\n@@ -1616,1 +1616,1 @@\n-    Symbol* name_sym = cp->name_ref_at(index);\n+    Symbol* name_sym = cp->name_ref_at(index, Bytecodes::_invokehandle);\n@@ -3088,4 +3088,4 @@\n-  {CC \"lookupNameInPool\",                             CC \"(\" HS_CONSTANT_POOL2 \"I)\" STRING,                                                 FN_PTR(lookupNameInPool)},\n-  {CC \"lookupNameAndTypeRefIndexInPool\",              CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(lookupNameAndTypeRefIndexInPool)},\n-  {CC \"lookupSignatureInPool\",                        CC \"(\" HS_CONSTANT_POOL2 \"I)\" STRING,                                                 FN_PTR(lookupSignatureInPool)},\n-  {CC \"lookupKlassRefIndexInPool\",                    CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(lookupKlassRefIndexInPool)},\n+  {CC \"lookupNameInPool\",                             CC \"(\" HS_CONSTANT_POOL2 \"II)\" STRING,                                                FN_PTR(lookupNameInPool)},\n+  {CC \"lookupNameAndTypeRefIndexInPool\",              CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(lookupNameAndTypeRefIndexInPool)},\n+  {CC \"lookupSignatureInPool\",                        CC \"(\" HS_CONSTANT_POOL2 \"II)\" STRING,                                                FN_PTR(lookupSignatureInPool)},\n+  {CC \"lookupKlassRefIndexInPool\",                    CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(lookupKlassRefIndexInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1801,1 +1801,1 @@\n-                                        int index) {\n+                                        int index, Bytecodes::Code bc) {\n@@ -1809,1 +1809,1 @@\n-  Symbol* name  = cpool->name_ref_at(index);\n+  Symbol* name  = cpool->name_ref_at(index, bc);\n@@ -1811,1 +1811,1 @@\n-  int nt_index = cpool->name_and_type_ref_index_at(index);\n+  int nt_index = cpool->name_and_type_ref_index_at(index, bc);\n@@ -1816,1 +1816,1 @@\n-  int holder_index = cpool->klass_ref_index_at(index);\n+  int holder_index = cpool->klass_ref_index_at(index, bc);\n@@ -1841,1 +1841,1 @@\n-void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor& fd, int index) {\n+void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor& fd, int index, Bytecodes::Code bc) {\n@@ -1843,1 +1843,1 @@\n-  return get_field_by_index_impl(accessor, fd, index);\n+  return get_field_by_index_impl(accessor, fd, index, bc);\n@@ -1891,1 +1891,1 @@\n-  int holder_index = cpool->klass_ref_index_at(index);\n+  int holder_index = cpool->klass_ref_index_at(index, bc);\n@@ -1896,2 +1896,2 @@\n-  Symbol* name_sym = cpool->name_ref_at(index);\n-  Symbol* sig_sym  = cpool->signature_ref_at(index);\n+  Symbol* name_sym = cpool->name_ref_at(index, bc);\n+  Symbol* sig_sym  = cpool->signature_ref_at(index, bc);\n@@ -1923,1 +1923,1 @@\n-    constantTag tag = cpool->tag_ref_at(index);\n+    constantTag tag = cpool->tag_ref_at(index, bc);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-                                        int field_index);\n+                                        int field_index, Bytecodes::Code bc);\n@@ -416,1 +416,1 @@\n-                                   int field_index);\n+                                   int field_index, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,3 +38,1 @@\n-    if (!ref->keep_after_pushing()) {\n-      delete ref;\n-    }\n+    delete ref;\n@@ -83,3 +81,1 @@\n-    if (!ref->keep_after_pushing()) {\n-      delete ref;\n-    }\n+    delete ref;\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-    bool _keep_after_pushing;\n@@ -116,1 +115,1 @@\n-    Ref(Writability w) : _writability(w), _keep_after_pushing(false), _next(nullptr), _user_data(nullptr) {}\n+    Ref(Writability w) : _writability(w), _next(nullptr), _user_data(nullptr) {}\n@@ -137,2 +136,0 @@\n-    void set_keep_after_pushing()   { _keep_after_pushing = true; }\n-    bool keep_after_pushing()       { return _keep_after_pushing; }\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,2 @@\n-  static int holder_metadata_offset() { return offset_of(CompiledICHolder, _holder_metadata); }\n-  static int holder_klass_offset()    { return offset_of(CompiledICHolder, _holder_klass); }\n+  static ByteSize holder_metadata_offset() { return byte_offset_of(CompiledICHolder, _holder_metadata); }\n+  static ByteSize holder_klass_offset()    { return byte_offset_of(CompiledICHolder, _holder_klass); }\n","filename":"src\/hotspot\/share\/oops\/compiledICHolder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -678,9 +678,22 @@\n-Symbol* ConstantPool::impl_name_ref_at(int which, bool uncached) {\n-  int name_index = name_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));\n-  return symbol_at(name_index);\n-}\n-\n-\n-Symbol* ConstantPool::impl_signature_ref_at(int which, bool uncached) {\n-  int signature_index = signature_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));\n-  return symbol_at(signature_index);\n+\/\/ Translate index, which could be CPCache index or Indy index, to a constant pool index\n+int ConstantPool::to_cp_index(int index, Bytecodes::Code code) {\n+  assert(cache() != nullptr, \"'index' is a rewritten index so this class must have been rewritten\");\n+  switch(code) {\n+    case Bytecodes::_invokedynamic:\n+      return invokedynamic_bootstrap_ref_index_at(index);\n+    case Bytecodes::_getfield:\n+    case Bytecodes::_getstatic:\n+    case Bytecodes::_putfield:\n+    case Bytecodes::_putstatic:\n+      \/\/ TODO: handle resolved field entries with new structure\n+      \/\/ i = ....\n+    case Bytecodes::_invokeinterface:\n+    case Bytecodes::_invokehandle:\n+    case Bytecodes::_invokespecial:\n+    case Bytecodes::_invokestatic:\n+    case Bytecodes::_invokevirtual:\n+      \/\/ TODO: handle resolved method entries with new structure\n+    default:\n+      \/\/ change byte-ordering and go via cache\n+      return remap_instruction_operand_from_cache(index);\n+  }\n@@ -689,19 +702,5 @@\n-int ConstantPool::impl_name_and_type_ref_index_at(int which, bool uncached) {\n-  int i = which;\n-  if (!uncached) {\n-    assert(cache() != nullptr, \"'which' is a rewritten index so this class must have been rewritten\");\n-    if (ConstantPool::is_invokedynamic_index(which)) {\n-      \/\/ Invokedynamic index is index into the resolved indy array in the constant pool cache\n-      int pool_index = invokedynamic_bootstrap_ref_index_at(which);\n-      pool_index = bootstrap_name_and_type_ref_index_at(pool_index);\n-      assert(tag_at(pool_index).is_name_and_type(), \"\");\n-      return pool_index;\n-    }\n-    \/\/ change byte-ordering and go via cache\n-    i = remap_instruction_operand_from_cache(which);\n-  } else {\n-    if (tag_at(which).has_bootstrap()) {\n-      int pool_index = bootstrap_name_and_type_ref_index_at(which);\n-      assert(tag_at(pool_index).is_name_and_type(), \"\");\n-      return pool_index;\n-    }\n+int ConstantPool::uncached_name_and_type_ref_index_at(int cp_index)  {\n+  if (tag_at(cp_index).has_bootstrap()) {\n+    int pool_index = bootstrap_name_and_type_ref_index_at(cp_index);\n+    assert(tag_at(pool_index).is_name_and_type(), \"\");\n+    return pool_index;\n@@ -709,3 +708,3 @@\n-  assert(tag_at(i).is_field_or_method(), \"Corrupted constant pool\");\n-  assert(!tag_at(i).has_bootstrap(), \"Must be handled above\");\n-  jint ref_index = *int_at_addr(i);\n+  assert(tag_at(cp_index).is_field_or_method(), \"Corrupted constant pool\");\n+  assert(!tag_at(cp_index).has_bootstrap(), \"Must be handled above\");\n+  jint ref_index = *int_at_addr(cp_index);\n@@ -715,1 +714,6 @@\n-constantTag ConstantPool::impl_tag_ref_at(int which, bool uncached) {\n+int ConstantPool::name_and_type_ref_index_at(int index, Bytecodes::Code code) {\n+  return uncached_name_and_type_ref_index_at(to_cp_index(index, code));\n+}\n+\n+constantTag ConstantPool::tag_ref_at(int which, Bytecodes::Code code) {\n+  \/\/ which may be either a Constant Pool index or a rewritten index\n@@ -717,10 +721,2 @@\n-  if (!uncached) {\n-    assert(cache() != nullptr, \"'which' is a rewritten index so this class must have been rewritten\");\n-    if (ConstantPool::is_invokedynamic_index(which)) {\n-      \/\/ Invokedynamic index is index into resolved_references\n-      pool_index = invokedynamic_bootstrap_ref_index_at(which);\n-    } else {\n-      \/\/ change byte-ordering and go via cache\n-      pool_index = remap_instruction_operand_from_cache(which);\n-    }\n-  }\n+  assert(cache() != nullptr, \"'index' is a rewritten index so this class must have been rewritten\");\n+  pool_index = to_cp_index(which, code);\n@@ -730,11 +726,3 @@\n-int ConstantPool::impl_klass_ref_index_at(int which, bool uncached) {\n-  guarantee(!ConstantPool::is_invokedynamic_index(which),\n-            \"an invokedynamic instruction does not have a klass\");\n-  int i = which;\n-  if (!uncached) {\n-    assert(cache() != nullptr, \"'which' is a rewritten index so this class must have been rewritten\");\n-    \/\/ change byte-ordering and go via cache\n-    i = remap_instruction_operand_from_cache(which);\n-  }\n-  assert(tag_at(i).is_field_or_method(), \"Corrupted constant pool\");\n-  jint ref_index = *int_at_addr(i);\n+int ConstantPool::uncached_klass_ref_index_at(int cp_index) {\n+  assert(tag_at(cp_index).is_field_or_method(), \"Corrupted constant pool\");\n+  jint ref_index = *int_at_addr(cp_index);\n@@ -744,0 +732,7 @@\n+int ConstantPool::klass_ref_index_at(int index, Bytecodes::Code code) {\n+  guarantee(!ConstantPool::is_invokedynamic_index(index),\n+            \"an invokedynamic instruction does not have a klass\");\n+  assert(code != Bytecodes::_invokedynamic,\n+            \"an invokedynamic instruction does not have a klass\");\n+  return uncached_klass_ref_index_at(to_cp_index(index, code));\n+}\n@@ -776,2 +771,2 @@\n-Klass* ConstantPool::klass_ref_at(int which, TRAPS) {\n-  return klass_at(klass_ref_index_at(which), THREAD);\n+Klass* ConstantPool::klass_ref_at(int which, Bytecodes::Code code, TRAPS) {\n+  return klass_at(klass_ref_index_at(which, code), THREAD);\n@@ -784,2 +779,2 @@\n-Symbol* ConstantPool::klass_ref_at_noresolve(int which) {\n-  jint ref_index = klass_ref_index_at(which);\n+Symbol* ConstantPool::klass_ref_at_noresolve(int which, Bytecodes::Code code) {\n+  jint ref_index = klass_ref_index_at(which, code);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":52,"deletions":57,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -267,4 +267,4 @@\n-  static int tags_offset_in_bytes()         { return offset_of(ConstantPool, _tags); }\n-  static int cache_offset_in_bytes()        { return offset_of(ConstantPool, _cache); }\n-  static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }\n-  static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }\n+  static ByteSize tags_offset()         { return byte_offset_of(ConstantPool, _tags); }\n+  static ByteSize cache_offset()        { return byte_offset_of(ConstantPool, _cache); }\n+  static ByteSize pool_holder_offset()  { return byte_offset_of(ConstantPool, _pool_holder); }\n+  static ByteSize resolved_klasses_offset()    { return byte_offset_of(ConstantPool, _resolved_klasses); }\n@@ -504,1 +504,1 @@\n-    return impl_name_ref_at(member, true);\n+    return uncached_name_ref_at(member);\n@@ -508,1 +508,1 @@\n-    return impl_signature_ref_at(member, true);\n+    return uncached_signature_ref_at(member);\n@@ -512,1 +512,1 @@\n-    return impl_klass_ref_index_at(member, true);\n+    return uncached_klass_ref_index_at(member);\n@@ -660,4 +660,10 @@\n-  Klass* klass_ref_at(int which, TRAPS);\n-  Symbol* klass_ref_at_noresolve(int which);\n-  Symbol* name_ref_at(int which)                { return impl_name_ref_at(which, false); }\n-  Symbol* signature_ref_at(int which)           { return impl_signature_ref_at(which, false); }\n+  Klass* klass_ref_at(int which, Bytecodes::Code code, TRAPS);\n+  Symbol* klass_ref_at_noresolve(int which, Bytecodes::Code code);\n+  Symbol* name_ref_at(int which, Bytecodes::Code code) {\n+    int name_index = name_ref_index_at(name_and_type_ref_index_at(which, code));\n+    return symbol_at(name_index);\n+  }\n+  Symbol* signature_ref_at(int which, Bytecodes::Code code) {\n+    int signature_index = signature_ref_index_at(name_and_type_ref_index_at(which, code));\n+    return symbol_at(signature_index);\n+  }\n@@ -665,2 +671,2 @@\n-  int klass_ref_index_at(int which)               { return impl_klass_ref_index_at(which, false); }\n-  int name_and_type_ref_index_at(int which)       { return impl_name_and_type_ref_index_at(which, false); }\n+  int klass_ref_index_at(int which, Bytecodes::Code code);\n+  int name_and_type_ref_index_at(int which, Bytecodes::Code code);\n@@ -670,1 +676,3 @@\n-  constantTag tag_ref_at(int cp_cache_index)      { return impl_tag_ref_at(cp_cache_index, false); }\n+  constantTag tag_ref_at(int cp_cache_index, Bytecodes::Code code);\n+\n+  int to_cp_index(int which, Bytecodes::Code code);\n@@ -772,5 +780,11 @@\n-  Symbol* uncached_klass_ref_at_noresolve(int which);\n-  Symbol* uncached_name_ref_at(int which)                 { return impl_name_ref_at(which, true); }\n-  Symbol* uncached_signature_ref_at(int which)            { return impl_signature_ref_at(which, true); }\n-  int       uncached_klass_ref_index_at(int which)          { return impl_klass_ref_index_at(which, true); }\n-  int       uncached_name_and_type_ref_index_at(int which)  { return impl_name_and_type_ref_index_at(which, true); }\n+  Symbol* uncached_klass_ref_at_noresolve(int cp_index);\n+  Symbol* uncached_name_ref_at(int cp_index) {\n+    int name_index = name_ref_index_at(uncached_name_and_type_ref_index_at(cp_index));\n+    return symbol_at(name_index);\n+  }\n+  Symbol* uncached_signature_ref_at(int cp_index) {\n+    int signature_index = signature_ref_index_at(uncached_name_and_type_ref_index_at(cp_index));\n+    return symbol_at(signature_index);\n+  }\n+  int       uncached_klass_ref_index_at(int cp_index);\n+  int       uncached_name_and_type_ref_index_at(int cp_index);\n@@ -803,7 +817,0 @@\n-  Symbol* impl_name_ref_at(int which, bool uncached);\n-  Symbol* impl_signature_ref_at(int which, bool uncached);\n-\n-  int       impl_klass_ref_index_at(int which, bool uncached);\n-  int       impl_name_and_type_ref_index_at(int which, bool uncached);\n-  constantTag impl_tag_ref_at(int which, bool uncached);\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -455,2 +455,2 @@\n-  static int resolved_references_offset_in_bytes() { return offset_of(ConstantPoolCache, _resolved_references); }\n-  static ByteSize invokedynamic_entries_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries); }\n+  static ByteSize resolved_references_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_references); }\n+  static ByteSize invokedynamic_entries_offset() { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries); }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1323,1 +1323,1 @@\n-      int nameAndTypeIdx    = cp->name_and_type_ref_index_at(idx);\n+      int nameAndTypeIdx    = cp->name_and_type_ref_index_at(idx, currentBC->code());\n@@ -1600,4 +1600,4 @@\n-    case Bytecodes::_getstatic:         do_field(true,  true,  itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_putstatic:         do_field(false, true,  itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_getfield:          do_field(true,  false, itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_putfield:          do_field(false, false, itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_getstatic:         do_field(true,  true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_putstatic:         do_field(false, true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_getfield:          do_field(true,  false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_putfield:          do_field(false, false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n@@ -1606,4 +1606,4 @@\n-    case Bytecodes::_invokespecial:     do_method(false, false, itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_invokestatic:      do_method(true,  false, itr->get_index_u2_cpcache(), itr->bci()); break;\n-    case Bytecodes::_invokedynamic:     do_method(true,  false, itr->get_index_u4(),         itr->bci()); break;\n-    case Bytecodes::_invokeinterface:   do_method(false, true,  itr->get_index_u2_cpcache(), itr->bci()); break;\n+    case Bytecodes::_invokespecial:     do_method(false, false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_invokestatic:      do_method(true,  false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_invokedynamic:     do_method(true,  false, itr->get_index_u4(),         itr->bci(), itr->code()); break;\n+    case Bytecodes::_invokeinterface:   do_method(false, true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n@@ -1934,1 +1934,1 @@\n-void GenerateOopMap::do_field(int is_get, int is_static, int idx, int bci) {\n+void GenerateOopMap::do_field(int is_get, int is_static, int idx, int bci, Bytecodes::Code bc) {\n@@ -1937,1 +1937,1 @@\n-  int nameAndTypeIdx     = cp->name_and_type_ref_index_at(idx);\n+  int nameAndTypeIdx     = cp->name_and_type_ref_index_at(idx, bc);\n@@ -1960,1 +1960,1 @@\n-void GenerateOopMap::do_method(int is_static, int is_interface, int idx, int bci) {\n+void GenerateOopMap::do_method(int is_static, int is_interface, int idx, int bci, Bytecodes::Code bc) {\n@@ -1963,1 +1963,1 @@\n-  Symbol* signature   = cp->signature_ref_at(idx);\n+  Symbol* signature   = cp->signature_ref_at(idx, bc);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -399,2 +399,2 @@\n-  void  do_field                            (int is_get, int is_static, int idx, int bci);\n-  void  do_method                           (int is_static, int is_interface, int idx, int bci);\n+  void  do_field                            (int is_get, int is_static, int idx, int bci, Bytecodes::Code bc);\n+  void  do_method                           (int is_static, int is_interface, int idx, int bci, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  NOT_PRODUCT(volatile int _shared_class_load_count;) \/\/ ensure a shared class is loaded only once\n@@ -549,1 +550,1 @@\n-  static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }\n+  static ByteSize reference_type_offset() { return byte_offset_of(InstanceKlass, _reference_type); }\n@@ -868,1 +869,1 @@\n-  static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }\n+  static ByteSize init_state_offset()  { return byte_offset_of(InstanceKlass, _init_state); }\n@@ -870,1 +871,1 @@\n-  static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }\n+  static ByteSize init_thread_offset() { return byte_offset_of(InstanceKlass, _init_thread); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -387,10 +387,10 @@\n-  static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }\n-  static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }\n-  static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }\n-  static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }\n-  static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }\n-  static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }\n-  static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }\n-  static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }\n-  static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }\n-  static ByteSize access_flags_offset()          { return in_ByteSize(offset_of(Klass, _access_flags)); }\n+  static ByteSize super_offset()                 { return byte_offset_of(Klass, _super); }\n+  static ByteSize super_check_offset_offset()    { return byte_offset_of(Klass, _super_check_offset); }\n+  static ByteSize primary_supers_offset()        { return byte_offset_of(Klass, _primary_supers); }\n+  static ByteSize secondary_super_cache_offset() { return byte_offset_of(Klass, _secondary_super_cache); }\n+  static ByteSize secondary_supers_offset()      { return byte_offset_of(Klass, _secondary_supers); }\n+  static ByteSize java_mirror_offset()           { return byte_offset_of(Klass, _java_mirror); }\n+  static ByteSize class_loader_data_offset()     { return byte_offset_of(Klass, _class_loader_data); }\n+  static ByteSize modifier_flags_offset()        { return byte_offset_of(Klass, _modifier_flags); }\n+  static ByteSize layout_helper_offset()         { return byte_offset_of(Klass, _layout_helper); }\n+  static ByteSize access_flags_offset()          { return byte_offset_of(Klass, _access_flags); }\n@@ -398,2 +398,2 @@\n-  static ByteSize subklass_offset()              { return in_ByteSize(offset_of(Klass, _subklass)); }\n-  static ByteSize next_sibling_offset()          { return in_ByteSize(offset_of(Klass, _next_sibling)); }\n+  static ByteSize subklass_offset()              { return byte_offset_of(Klass, _subklass); }\n+  static ByteSize next_sibling_offset()          { return byte_offset_of(Klass, _next_sibling); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-  static int method_offset_in_bytes() { return offset_of(vtableEntry, _method); }\n+  static ByteSize method_offset() { return byte_offset_of(vtableEntry, _method); }\n@@ -233,3 +233,3 @@\n-  static int size()                       { return sizeof(itableOffsetEntry) \/ wordSize; }    \/\/ size in words\n-  static int interface_offset_in_bytes()  { return offset_of(itableOffsetEntry, _interface); }\n-  static int offset_offset_in_bytes()     { return offset_of(itableOffsetEntry, _offset); }\n+  static int size()                            { return sizeof(itableOffsetEntry) \/ wordSize; }    \/\/ size in words\n+  static ByteSize interface_offset()  { return byte_offset_of(itableOffsetEntry, _interface); }\n+  static ByteSize offset_offset()     { return byte_offset_of(itableOffsetEntry, _offset); }\n@@ -255,1 +255,1 @@\n-  static int method_offset_in_bytes()       { return offset_of(itableMethodEntry, _method); }\n+  static ByteSize method_offset()  { return byte_offset_of(itableMethodEntry, _method); }\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -981,2 +981,2 @@\n-bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {\n-  int klass_index = constants()->klass_ref_index_at(refinfo_index);\n+bool Method::is_klass_loaded(int refinfo_index, Bytecodes::Code bc, bool must_be_resolved) const {\n+  int klass_index = constants()->klass_ref_index_at(refinfo_index, bc);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -669,3 +669,1 @@\n-  static ByteSize method_data_offset()           {\n-    return byte_offset_of(Method, _method_data);\n-  }\n+\n@@ -685,2 +683,2 @@\n-  static int method_data_offset_in_bytes()       { return offset_of(Method, _method_data); }\n-  static int intrinsic_id_offset_in_bytes()      { return offset_of(Method, _intrinsic_id); }\n+  static ByteSize method_data_offset()  { return byte_offset_of(Method, _method_data); }\n+  static ByteSize intrinsic_id_offset() { return byte_offset_of(Method, _intrinsic_id); }\n@@ -846,1 +844,1 @@\n-  bool is_klass_loaded(int refinfo_index, bool must_be_resolved = false) const;\n+  bool is_klass_loaded(int refinfo_index, Bytecodes::Code bc, bool must_be_resolved = false) const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2256,2 +2256,2 @@\n-  static int rtm_state_offset_in_bytes() {\n-    return offset_of(MethodData, _rtm_state);\n+  static ByteSize rtm_state_offset() {\n+    return byte_offset_of(MethodData, _rtm_state);\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ObjArrayKlass, _element_klass)); }\n+  static ByteSize element_klass_offset() { return byte_offset_of(ObjArrayKlass, _element_klass); }\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,2 +312,2 @@\n-  static int mark_offset_in_bytes()      { return offset_of(oopDesc, _mark); }\n-  static int klass_offset_in_bytes()     { return offset_of(oopDesc, _metadata._klass); }\n+  static int mark_offset_in_bytes()      { return (int)offset_of(oopDesc, _mark); }\n+  static int klass_offset_in_bytes()     { return (int)offset_of(oopDesc, _metadata._klass); }\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -512,1 +512,1 @@\n-      if (!caller_method->is_klass_loaded(index, true)) {\n+      if (!caller_method->is_klass_loaded(index, call_bc, true)) {\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4240,1 +4240,1 @@\n-                     vtableEntry::method_offset_in_bytes();\n+                     in_bytes(vtableEntry::method_offset());\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,7 +336,0 @@\n-  \/\/ When called from beautify_loops() idom is not constructed yet.\n-  if (_idom != nullptr) {\n-    Node* ridom = idom(rgn);\n-    Node* nrdom = dom_lca_internal(ridom, new_iff);\n-    set_idom(rgn, nrdom, dom_depth(rgn));\n-  }\n-\n@@ -380,0 +373,8 @@\n+\n+  \/\/ When called from beautify_loops() idom is not constructed yet.\n+  if (_idom != nullptr) {\n+    Node* ridom = idom(rgn);\n+    Node* nrdom = dom_lca_internal(ridom, new_iff);\n+    set_idom(rgn, nrdom, dom_depth(rgn));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1926,0 +1926,4 @@\n+  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n+  if (mask_t == nullptr || phase->type(shift)->isa_integer(bt) == nullptr) {\n+    return false;\n+  }\n@@ -1930,3 +1934,1 @@\n-  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n-  const TypeInteger* shift_t = phase->type(shift)->isa_integer(bt);\n-  if (mask_t == nullptr || shift_t == nullptr) {\n+  if (phase->type(shift)->isa_integer(bt) == nullptr) {\n@@ -1949,0 +1951,3 @@\n+      if (phase->type(shift)->isa_integer(bt) == nullptr) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2174,1 +2174,1 @@\n-    int offset = MethodData::rtm_state_offset_in_bytes();\n+    int offset = in_bytes(MethodData::rtm_state_offset());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2961,0 +2961,4 @@\n+              The <functionlink id=\"PopFrame\"><\/functionlink> function may be used to\n+              pop the current frame of a virtual thread when it is suspended at an event.\n+              An implementation may support popping the current frame of a suspended\n+              virtual thread in other cases.\n@@ -2970,2 +2974,2 @@\n-          The thread is a virtual thread and the implementation is unable\n-          to pop this frame.\n+          The thread is a suspended virtual thread and the implementation\n+          was unable to pop the current frame.\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1886,4 +1886,0 @@\n-  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {\n-    \/\/ No support for virtual threads (yet).\n-    return JVMTI_ERROR_OPAQUE_FRAME;\n-  }\n@@ -1893,0 +1889,17 @@\n+  bool is_virtual = thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass());\n+\n+  if (is_virtual) {\n+    if (!is_JavaThread_current(java_thread, thread_obj)) {\n+      if (!is_vthread_suspended(thread_obj, java_thread)) {\n+        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      }\n+      if (java_thread == nullptr) { \/\/ unmounted virtual thread\n+        return JVMTI_ERROR_OPAQUE_FRAME;\n+      }\n+    }\n+  } else { \/\/ platform thread\n+    if (java_thread != current_thread && !java_thread->is_suspended() &&\n+        !java_thread->is_carrier_thread_suspended()) {\n+      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2214,5 +2214,0 @@\n-  if (!self && !java_thread->is_suspended() && !java_thread->is_carrier_thread_suspended()) {\n-    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2595,2 +2595,0 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,3 +99,3 @@\n-    if ((old_cp->klass_ref_at_noresolve(cpci_old) != new_cp->klass_ref_at_noresolve(cpci_new)) ||\n-        (old_cp->name_ref_at(cpci_old) != new_cp->name_ref_at(cpci_new)) ||\n-        (old_cp->signature_ref_at(cpci_old) != new_cp->signature_ref_at(cpci_new)))\n+    if ((old_cp->klass_ref_at_noresolve(cpci_old, c_old) != new_cp->klass_ref_at_noresolve(cpci_new, c_old)) ||\n+        (old_cp->name_ref_at(cpci_old, c_old) != new_cp->name_ref_at(cpci_new, c_old)) ||\n+        (old_cp->signature_ref_at(cpci_old, c_old) != new_cp->signature_ref_at(cpci_new, c_old)))\n@@ -117,2 +117,2 @@\n-    if ((old_cp->name_ref_at(index_old) != new_cp->name_ref_at(index_new)) ||\n-        (old_cp->signature_ref_at(index_old) != new_cp->signature_ref_at(index_new)))\n+    if ((old_cp->name_ref_at(index_old, c_old) != new_cp->name_ref_at(index_new, c_old)) ||\n+        (old_cp->signature_ref_at(index_old, c_old) != new_cp->signature_ref_at(index_new, c_old)))\n","filename":"src\/hotspot\/share\/prims\/methodComparator.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1285,1 +1285,1 @@\n-            Symbol* name = caller->constants()->name_ref_at(bss_index_in_pool);\n+            Symbol* name = caller->constants()->name_ref_at(bss_index_in_pool, Bytecodes::_invokedynamic);\n@@ -1292,1 +1292,1 @@\n-            Symbol* type = caller->constants()->signature_ref_at(bss_index_in_pool);\n+            Symbol* type = caller->constants()->signature_ref_at(bss_index_in_pool, Bytecodes::_invokedynamic);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,0 +119,8 @@\n+#ifndef VENDOR_PADDING\n+# define VENDOR_PADDING 64\n+#endif\n+#ifndef VENDOR\n+# define VENDOR  \"Oracle Corporation\"\n+#endif\n+\n+static const char vm_vendor_string[sizeof(VENDOR) < VENDOR_PADDING ? VENDOR_PADDING : sizeof(VENDOR)] = VENDOR;\n@@ -121,5 +129,1 @@\n-#ifdef VENDOR\n-  return VENDOR;\n-#else\n-  return \"Oracle Corporation\";\n-#endif\n+  return vm_vendor_string;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -51,1 +52,1 @@\n-  static int displaced_header_offset_in_bytes()       { return offset_of(BasicLock, _displaced_header); }\n+  static int displaced_header_offset_in_bytes() { return (int)offset_of(BasicLock, _displaced_header); }\n@@ -82,2 +83,2 @@\n-  static int obj_offset_in_bytes()                    { return offset_of(BasicObjectLock, _obj);  }\n-  static int lock_offset_in_bytes()                   { return offset_of(BasicObjectLock, _lock); }\n+  static ByteSize obj_offset()                { return byte_offset_of(BasicObjectLock, _obj);  }\n+  static ByteSize lock_offset()               { return byte_offset_of(BasicObjectLock, _lock); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -267,10 +267,10 @@\n-    static int size_of_deoptimized_frame_offset_in_bytes() { return offset_of(UnrollBlock, _size_of_deoptimized_frame); }\n-    static int caller_adjustment_offset_in_bytes()         { return offset_of(UnrollBlock, _caller_adjustment);         }\n-    static int number_of_frames_offset_in_bytes()          { return offset_of(UnrollBlock, _number_of_frames);          }\n-    static int frame_sizes_offset_in_bytes()               { return offset_of(UnrollBlock, _frame_sizes);               }\n-    static int total_frame_sizes_offset_in_bytes()         { return offset_of(UnrollBlock, _total_frame_sizes);         }\n-    static int frame_pcs_offset_in_bytes()                 { return offset_of(UnrollBlock, _frame_pcs);                 }\n-    static int counter_temp_offset_in_bytes()              { return offset_of(UnrollBlock, _counter_temp);              }\n-    static int initial_info_offset_in_bytes()              { return offset_of(UnrollBlock, _initial_info);              }\n-    static int unpack_kind_offset_in_bytes()               { return offset_of(UnrollBlock, _unpack_kind);               }\n-    static int sender_sp_temp_offset_in_bytes()            { return offset_of(UnrollBlock, _sender_sp_temp);            }\n+    static ByteSize size_of_deoptimized_frame_offset() { return byte_offset_of(UnrollBlock, _size_of_deoptimized_frame); }\n+    static ByteSize caller_adjustment_offset()         { return byte_offset_of(UnrollBlock, _caller_adjustment);         }\n+    static ByteSize number_of_frames_offset()          { return byte_offset_of(UnrollBlock, _number_of_frames);          }\n+    static ByteSize frame_sizes_offset()               { return byte_offset_of(UnrollBlock, _frame_sizes);               }\n+    static ByteSize total_frame_sizes_offset()         { return byte_offset_of(UnrollBlock, _total_frame_sizes);         }\n+    static ByteSize frame_pcs_offset()                 { return byte_offset_of(UnrollBlock, _frame_pcs);                 }\n+    static ByteSize counter_temp_offset()              { return byte_offset_of(UnrollBlock, _counter_temp);              }\n+    static ByteSize initial_info_offset()              { return byte_offset_of(UnrollBlock, _initial_info);              }\n+    static ByteSize unpack_kind_offset()               { return byte_offset_of(UnrollBlock, _unpack_kind);               }\n+    static ByteSize sender_sp_temp_offset()            { return byte_offset_of(UnrollBlock, _sender_sp_temp);            }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  static int top_offset_in_bytes()                { return offset_of(JNIHandleBlock, _top); }\n+  static ByteSize top_offset()           { return byte_offset_of(JNIHandleBlock, _top); }\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,7 +220,5 @@\n-  \/\/ TODO-FIXME: the \"offset\" routines should return a type of off_t instead of int ...\n-  \/\/ ByteSize would also be an appropriate type.\n-  static int owner_offset_in_bytes()       { return offset_of(ObjectMonitor, _owner); }\n-  static int recursions_offset_in_bytes()  { return offset_of(ObjectMonitor, _recursions); }\n-  static int cxq_offset_in_bytes()         { return offset_of(ObjectMonitor, _cxq); }\n-  static int succ_offset_in_bytes()        { return offset_of(ObjectMonitor, _succ); }\n-  static int EntryList_offset_in_bytes()   { return offset_of(ObjectMonitor, _EntryList); }\n+  static ByteSize owner_offset()       { return byte_offset_of(ObjectMonitor, _owner); }\n+  static ByteSize recursions_offset()  { return byte_offset_of(ObjectMonitor, _recursions); }\n+  static ByteSize cxq_offset()         { return byte_offset_of(ObjectMonitor, _cxq); }\n+  static ByteSize succ_offset()        { return byte_offset_of(ObjectMonitor, _succ); }\n+  static ByteSize EntryList_offset()   { return byte_offset_of(ObjectMonitor, _EntryList); }\n@@ -240,1 +238,1 @@\n-    ((ObjectMonitor::f ## _offset_in_bytes()) - markWord::monitor_value)\n+    ((in_bytes(ObjectMonitor::f ## _offset())) - markWord::monitor_value)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1225,1 +1225,1 @@\n-      rk = constants->klass_ref_at(bytecode_index, CHECK_NH);\n+      rk = constants->klass_ref_at(bytecode_index, bc, CHECK_NH);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n@@ -458,2 +456,0 @@\n-#if INCLUDE_MANAGEMENT\n-\n@@ -2098,1 +2094,19 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n+\n+\/\/ Gets the amount of memory allocated on the Java heap since JVM launch.\n+JVM_ENTRY(jlong, jmm_GetTotalThreadAllocatedMemory(JNIEnv *env))\n+    \/\/ A thread increments exited_allocated_bytes in ThreadService::remove_thread\n+    \/\/ only after it removes itself from the threads list, and once a TLH is\n+    \/\/ created, no thread it references can remove itself from the threads\n+    \/\/ list, so none can update exited_allocated_bytes. We therefore initialize\n+    \/\/ result with exited_allocated_bytes after after we create the TLH so that\n+    \/\/ the final result can only be short due to (1) threads that start after\n+    \/\/ the TLH is created, or (2) terminating threads that escape TLH creation\n+    \/\/ and don't update exited_allocated_bytes before we initialize result.\n+    JavaThreadIteratorWithHandle jtiwh;\n+    jlong result = ThreadService::exited_allocated_bytes();\n+    for (; JavaThread* thread = jtiwh.next();) {\n+      jlong size = thread->cooked_allocated_bytes();\n+      result += size;\n+    }\n+    return result;\n+JVM_END\n@@ -2231,3 +2245,0 @@\n-\n-\n-#if INCLUDE_MANAGEMENT\n@@ -2244,0 +2255,1 @@\n+  jmm_GetTotalThreadAllocatedMemory,\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -73,0 +74,2 @@\n+volatile jlong ThreadService::_exited_allocated_bytes = 0;\n+\n@@ -160,0 +163,3 @@\n+  \/\/ Include hidden thread allcations in exited_allocated_bytes\n+  ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n+\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+  \/\/ As could this...\n+  \/\/ Number of heap bytes allocated by terminated threads.\n+  static volatile jlong _exited_allocated_bytes;\n+\n@@ -105,0 +109,8 @@\n+  static jlong exited_allocated_bytes()       { return Atomic::load(&_exited_allocated_bytes); }\n+  static void incr_exited_allocated_bytes(jlong size) {\n+    \/\/ No need for an atomic add because called under the Threads_lock,\n+    \/\/ but because _exited_allocated_bytes is read concurrently, need\n+    \/\/ atomic store to avoid readers seeing a partial update.\n+    Atomic::store(&_exited_allocated_bytes, _exited_allocated_bytes + size);\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  free(map(), size());\n+  free(map(), size_in_words());\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+#ifndef PRAGMA_INFINITE_RECURSION_IGNORED\n+#define PRAGMA_INFINITE_RECURSION_IGNORED\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\/\/ Disable -Wdangling-pointer which is introduced in GCC 12.\n@@ -44,0 +43,1 @@\n+\/\/ Disable -Wdangling-pointer which is introduced in GCC 12.\n@@ -45,0 +45,3 @@\n+\n+\/\/ Disable -Winfinite-recursion which is introduced in GCC 12.\n+#define PRAGMA_INFINITE_RECURSION_IGNORED PRAGMA_DISABLE_GCC_WARNING(\"-Winfinite-recursion\")\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+constexpr bool     operator == (ByteSize x, int     y) { return in_bytes(x) == y; }\n+constexpr bool     operator != (ByteSize x, int     y) { return in_bytes(x) != y; }\n+\n","filename":"src\/hotspot\/share\/utilities\/sizes.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -193,0 +193,2 @@\n+PRAGMA_DIAG_PUSH\n+PRAGMA_INFINITE_RECURSION_IGNORED\n@@ -223,0 +225,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1064,31 +1064,0 @@\n-    \/**\n-     * Expand an int[(ROUNDS+1)][4] into int[(ROUNDS+1)*4].\n-     * For decryption round keys, need to rotate right by 4 ints.\n-     * @param kr The round keys for encryption or decryption.\n-     * @param decrypting True if 'kr' is for decryption and false otherwise.\n-     *\/\n-    private static final int[] expandToSubKey(int[][] kr, boolean decrypting) {\n-        int total = kr.length;\n-        int[] expK = new int[total*4];\n-        if (decrypting) {\n-            \/\/ decrypting, rotate right by 4 ints\n-            \/\/ i.e. i==0\n-            for(int j=0; j<4; j++) {\n-                expK[j] = kr[total-1][j];\n-            }\n-            for(int i=1; i<total; i++) {\n-                for(int j=0; j<4; j++) {\n-                    expK[i*4 + j] = kr[i-1][j];\n-                }\n-            }\n-        } else {\n-            \/\/ encrypting, straight expansion\n-            for(int i=0; i<total; i++) {\n-                for(int j=0; j<4; j++) {\n-                    expK[i*4 + j] = kr[i][j];\n-                }\n-            }\n-        }\n-        return expK;\n-    }\n-\n@@ -1364,0 +1333,2 @@\n+        final int BC = 4;\n+\n@@ -1365,1 +1336,1 @@\n-        int ROUND_KEY_COUNT = (ROUNDS + 1) * 4;\n+        int ROUND_KEY_COUNT = (ROUNDS + 1) * BC;\n@@ -1367,3 +1338,2 @@\n-        int BC = 4;\n-        int[][] Ke = new int[ROUNDS + 1][4]; \/\/ encryption round keys\n-        int[][] Kd = new int[ROUNDS + 1][4]; \/\/ decryption round keys\n+        int[] Ke = new int[ROUND_KEY_COUNT]; \/\/ encryption round keys\n+        int[] Kd = new int[ROUND_KEY_COUNT]; \/\/ decryption round keys\n@@ -1387,2 +1357,2 @@\n-            Ke[t \/ 4][t % 4] = tk[j];\n-            Kd[ROUNDS - (t \/ 4)][t % 4] = tk[j];\n+            Ke[t] = tk[j];\n+            Kd[(ROUNDS - (t \/ BC))*BC + (t % BC)] = tk[j];\n@@ -1412,2 +1382,2 @@\n-                Ke[t \/ 4][t % 4] = tk[j];\n-                Kd[ROUNDS - (t \/ 4)][t % 4] = tk[j];\n+                Ke[t] = tk[j];\n+                Kd[(ROUNDS - (t \/ BC))*BC + (t % BC)] = tk[j];\n@@ -1419,5 +1389,6 @@\n-                tt = Kd[r][j];\n-                Kd[r][j] = U1[(tt >>> 24) & 0xFF] ^\n-                           U2[(tt >>> 16) & 0xFF] ^\n-                           U3[(tt >>>  8) & 0xFF] ^\n-                           U4[ tt         & 0xFF];\n+                int idx = r*BC + j;\n+                tt = Kd[idx];\n+                Kd[idx] = U1[(tt >>> 24) & 0xFF] ^\n+                          U2[(tt >>> 16) & 0xFF] ^\n+                          U3[(tt >>>  8) & 0xFF] ^\n+                          U4[ tt         & 0xFF];\n@@ -1427,4 +1398,12 @@\n-        \/\/ assemble the encryption (Ke) and decryption (Kd) round keys\n-        \/\/ and expand them into arrays of ints.\n-        int[] expandedKe = expandToSubKey(Ke, false); \/\/ decrypting==false\n-        int[] expandedKd = expandToSubKey(Kd, true);  \/\/ decrypting==true\n+        \/\/ For decryption round keys, need to rotate right by 4 ints.\n+        \/\/ Do that without allocating and zeroing the small buffer.\n+        int KdTail_0 = Kd[Kd.length - 4];\n+        int KdTail_1 = Kd[Kd.length - 3];\n+        int KdTail_2 = Kd[Kd.length - 2];\n+        int KdTail_3 = Kd[Kd.length - 1];\n+        System.arraycopy(Kd, 0, Kd, 4, Kd.length - 4);\n+        Kd[0] = KdTail_0;\n+        Kd[1] = KdTail_1;\n+        Kd[2] = KdTail_2;\n+        Kd[3] = KdTail_3;\n+\n@@ -1432,6 +1411,0 @@\n-        for (int[] ia: Ke) {\n-            Arrays.fill(ia, 0);\n-        }\n-        for (int[] ia: Kd) {\n-            Arrays.fill(ia, 0);\n-        }\n@@ -1447,0 +1420,2 @@\n+        } else {\n+            sessionK = new int[2][];\n@@ -1448,1 +1423,2 @@\n-        sessionK = new int[][] { expandedKe, expandedKd };\n+        sessionK[0] = Ke;\n+        sessionK[1] = Kd;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCrypt.java","additions":31,"deletions":55,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -33,3 +31,6 @@\n- * <p>{@code MatchException} may be thrown when an exhaustive pattern matching language construct\n- * (such as a switch expression) encounters a value that does not match any of the provided\n- * patterns at runtime. This can arise from a number of cases:\n+ * <p>{@code MatchException} may be thrown when an exhaustive pattern matching\n+ * language construct (such as a {@code switch} expression) encounters a value\n+ * that does not match any of the specified patterns at run time, even though\n+ * the construct has been deemed exhaustive. This is intentional and can arise\n+ * from a number of cases:\n+ *\n@@ -37,13 +38,7 @@\n- *    <li>Separate compilation anomalies, where a sealed interface has a different set of permitted\n- *        subtypes at runtime than it had at compilation time, an enum has a different set of\n- *        constants at runtime than it had at compilation time, or the type hierarchy has changed\n- *        in incompatible ways between compile time and run time.<\/li>\n- *    <li>{@code null} values and nested patterns using sealed types. If an interface or abstract\n- *        class {@code C} is sealed to permit {@code A} and {@code B}, then the set of record\n- *        patterns {@code R(A a)} and {@code R(B b)} are exhaustive on a record {@code R} whose\n- *        sole component is of type {@code C}, but neither of these patterns will match\n- *        {@code new R(null)}.<\/li>\n- *    <li>Null targets and nested record patterns. Given a record type {@code R} whose sole\n- *        component is {@code S}, which in turn is a record whose sole component is {@code String},\n- *        then the nested record pattern {@code R(S(String s))} will not match {@code new R(null)}.<\/li>\n- * <\/ul>\n+ *     <li>Separate compilation anomalies, where parts of the type hierarchy that\n+ *         the patterns reference have been changed, but the pattern matching\n+ *         construct has not been recompiled. For example, if a sealed interface\n+ *         has a different set of permitted subtypes at run time than it had at\n+ *         compile time, or if an enum class has a different set of enum constants\n+ *         at runtime than it had at compile time, or if the type hierarchy has\n+ *         been changed in some incompatible way between compile time and run time.<\/li>\n@@ -51,3 +46,16 @@\n- * <p>Match failures arising from unexpected inputs will generally throw {@code MatchException} only\n- * after all patterns have been tried; even if {@code R(S(String s))} does not match\n- * {@code new R(null)}, a later pattern (such as {@code R r}) may still match the target.\n+ *     <li>{@code null} values and nested patterns involving sealed classes. If,\n+ *         for example, an interface {@code I} is {@code sealed} with two permitted\n+ *         subclasses {@code A} and {@code B}, and a record class {@code R} has a\n+ *         single component of type {@code I}, then the two record patterns {@code\n+ *         R(A a)} and {@code R(B b)} together are considered to be exhaustive for\n+ *         the type {@code R}, but neither of these patterns will match against the\n+ *         result of {@code new R(null)}.<\/li>\n+ *\n+ *     <li>{@code null} values and nested record patterns. Given a record class\n+ *         {@code S} with a single component of type {@code T}, where {@code T} is\n+ *         another record class with a single component of type {@code String},\n+ *         then the nested record pattern {@code R(S(var s))} is considered\n+ *         exhaustive for the type {@code R} but it does not match against the\n+ *         result of {@code new R(null)} (whereas it does match against the result\n+ *         of {@code new R(new S(null))} does).<\/li>\n+ * <\/ul>\n@@ -55,7 +63,9 @@\n- * <p>MatchException may also be thrown when operations performed as part of pattern matching throw\n- * an unexpected exception. For example, pattern matching may cause methods such as record component\n- * accessors to be implicitly invoked in order to extract pattern bindings. If these methods throw\n- * an exception, execution of the pattern matching construct may fail with {@code MatchException}.\n- * The original exception will be set as a {@link Throwable#getCause() cause} of\n- * the {@code MatchException}. No {@link Throwable#addSuppressed(java.lang.Throwable) suppressed}\n- * exceptions will be recorded.\n+ * <p>{@code MatchException} may also be thrown by the process of pattern matching\n+ * a value against a pattern. For example, pattern matching involving a record\n+ * pattern may require accessor methods to be implicitly invoked in order to\n+ * extract the component values. If any of these accessor methods throws an\n+ * exception, pattern matching completes abruptly and throws {@code\n+ * MatchException}. The original exception will be set as a {@link\n+ * Throwable#getCause() cause} of the {@code MatchException}. No {@link\n+ * Throwable#addSuppressed(java.lang.Throwable) suppressed} exceptions will be\n+ * recorded.\n@@ -63,1 +73,1 @@\n- * @jls 14.11.3 Execution of a switch Statement\n+ * @jls 14.11.3 Execution of a {@code switch} Statement\n@@ -65,1 +75,1 @@\n- * @jls 15.28.2 Run-Time Evaluation of switch Expressions\n+ * @jls 15.28.2 Run-Time Evaluation of {@code switch} Expressions\n@@ -67,1 +77,1 @@\n- * @since 19\n+ * @since 21\n@@ -69,1 +79,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MatchException.java","additions":41,"deletions":32,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 64 bits).\n+ * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 8 bytes).\n@@ -77,1 +77,1 @@\n-    AddressLayout withBitAlignment(long bitAlignment);\n+    AddressLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is less than {@code M}, where {@code M} is the maximum alignment\n+     * @throws IllegalArgumentException if {@code byteAlignment} is less than {@code M}, where {@code M} is the maximum alignment\n@@ -75,1 +75,1 @@\n-    GroupLayout withBitAlignment(long bitAlignment);\n+    GroupLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- *         MemoryLayout.paddingLayout(24),\n+ *         MemoryLayout.paddingLayout(3),\n@@ -87,1 +87,1 @@\n- * always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed\n+ * always has the same size in bytes, regardless of the platform in which it is used. For derived layouts, the size is computed\n@@ -107,1 +107,1 @@\n- * A layout's natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe\n+ * A layout's natural alignment can be overridden if needed (see {@link MemoryLayout#withByteAlignment(long)}), which can be useful to describe\n@@ -118,1 +118,1 @@\n- * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#bitOffset(PathElement...) offsets} of\n+ * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#byteOffset(PathElement...) offsets} of\n@@ -125,1 +125,1 @@\n- * in bits, of the member layout named <code>value<\/code> in the <em>first<\/em> sequence element, as follows:\n+ * in bytes, of the member layout named <code>value<\/code> in the <em>first<\/em> sequence element, as follows:\n@@ -127,2 +127,2 @@\n- * long valueOffset = taggedValues.bitOffset(PathElement.sequenceElement(0),\n- *                                           PathElement.groupElement(\"value\")); \/\/ yields 32\n+ * long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+ *                                           PathElement.groupElement(\"value\")); \/\/ yields 4\n@@ -154,1 +154,1 @@\n- * {@link #bitOffset(PathElement...)} or {@link #byteOffsetHandle(PathElement...)} method. Again, free dimensions are\n+ * {@link #byteOffset(PathElement...)} or {@link #byteOffsetHandle(PathElement...)} method. Again, free dimensions are\n@@ -175,5 +175,0 @@\n-    \/**\n-     * {@return the layout size, in bits}\n-     *\/\n-    long bitSize();\n-\n@@ -182,1 +177,0 @@\n-     * @throws UnsupportedOperationException if {@code bitSize()} is not a multiple of 8.\n@@ -213,18 +207,0 @@\n-    \/**\n-     * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power\n-     * of two {@code A} which is the bit-wise alignment of the layout. If {@code A <= 8} then {@code A\/8} is the number of\n-     * bytes that must be aligned for any pointer that correctly points to this layout. Thus:\n-     *\n-     * <ul>\n-     * <li>{@code A=8} means unaligned (in the usual sense), which is common in packets.<\/li>\n-     * <li>{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.<\/li>\n-     * <li>{@code A=512} is the most strict alignment required by the x86\/SV ABI (for AVX-512 data).<\/li>\n-     * <\/ul>\n-     *\n-     * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),\n-     * then this method returns the <a href=\"#layout-align\">natural alignment<\/a> constraint (in bits) associated with this layout.\n-     *\n-     * @return the layout alignment constraint, in bits.\n-     *\/\n-    long bitAlignment();\n-\n@@ -242,1 +218,1 @@\n-     * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),\n+     * If no explicit alignment constraint was set on this layout (see {@link #withByteAlignment(long)}),\n@@ -246,1 +222,0 @@\n-     * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.\n@@ -250,0 +225,1 @@\n+\n@@ -252,1 +228,1 @@\n-     * but with the specified alignment constraint (in bits).\n+     * but with the specified alignment constraint (in bytes).\n@@ -254,1 +230,1 @@\n-     * @param bitAlignment the layout alignment constraint, expressed in bits.\n+     * @param byteAlignment the layout alignment constraint, expressed in bytes.\n@@ -256,1 +232,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than 8.\n+     * @throws IllegalArgumentException if {@code byteAlignment} is not a power of two, or if it's less than 1.\n@@ -258,1 +234,1 @@\n-    MemoryLayout withBitAlignment(long bitAlignment);\n+    MemoryLayout withByteAlignment(long byteAlignment);\n@@ -260,52 +236,0 @@\n-    \/**\n-     * Computes the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this\n-     * layout.\n-     *\n-     * @param elements the layout path elements.\n-     * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.\n-     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the\n-     * layout path contains one or more path elements that select multiple sequence element indices\n-     * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n-     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n-     * in {@code elements} is {@code null}.\n-     *\/\n-    default long bitOffset(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n-    }\n-\n-    \/**\n-     * Creates a method handle that can be used to compute the offset, in bits, of the layout selected\n-     * by the given layout path, where the path is considered rooted in this layout.\n-     *\n-     * <p>The returned method handle has a return type of {@code long}, and features as many {@code long}\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n-     * where the order of the parameters corresponds to the order of the path elements.\n-     * The returned method handle can be used to compute a layout offset similar to {@link #bitOffset(PathElement...)},\n-     * but where some sequence indices are specified only when invoking the method handle.\n-     *\n-     * <p>The final offset returned by the method handle is computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n-     *\n-     * @param elements the layout path elements.\n-     * @return a method handle that can be used to compute the bit offset of the layout element\n-     * specified by the given layout path elements, when supplied with the missing sequence element indices.\n-     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n-     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n-     *\/\n-    default MethodHandle bitOffsetHandle(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n-                EnumSet.of(PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n-    }\n@@ -324,1 +248,0 @@\n-     * @throws UnsupportedOperationException if {@code bitOffset(elements)} is not a multiple of 8.\n@@ -329,1 +252,2 @@\n-        return Utils.bitsToBytes(bitOffset(elements));\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -345,2 +269,1 @@\n-     * bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * offset = bitOffset \/ 8\n+     * byteOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -354,3 +277,0 @@\n-     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n-     * offset in bits is not a multiple of 8.\n-     *\n@@ -366,3 +286,2 @@\n-        MethodHandle mh = bitOffsetHandle(elements);\n-        mh = MethodHandles.filterReturnValue(mh, Utils.BITS_TO_BYTES);\n-        return mh;\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n+                EnumSet.of(PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -451,2 +370,1 @@\n-     * bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * offset = bitOffset \/ 8\n+     * byteOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -468,3 +386,0 @@\n-     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n-     * offset in bits is not a multiple of 8.\n-     *\n@@ -473,1 +388,0 @@\n-     * @throws UnsupportedOperationException if the size of the selected layout in bits is not a multiple of 8.\n@@ -690,1 +604,1 @@\n-     * Creates a padding layout with the given bitSize and a bit-alignment of eight.\n+     * Creates a padding layout with the given byte size and a byte-alignment of one.\n@@ -692,1 +606,1 @@\n-     * @param bitSize the padding size in bits.\n+     * @param byteSize the padding size (expressed in bytes).\n@@ -694,1 +608,1 @@\n-     * @throws IllegalArgumentException if {@code bitSize <= 0} or {@code bitSize % 8 != 0}\n+     * @throws IllegalArgumentException if {@code byteSize <= 0}.\n@@ -696,2 +610,2 @@\n-    static PaddingLayout paddingLayout(long bitSize) {\n-        return PaddingLayoutImpl.of(MemoryLayoutUtil.requireBitSizeValid(bitSize, false));\n+    static PaddingLayout paddingLayout(long byteSize) {\n+        return PaddingLayoutImpl.of(MemoryLayoutUtil.requireByteSizeValid(byteSize, false));\n@@ -707,1 +621,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n@@ -723,1 +637,1 @@\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n@@ -728,1 +642,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n@@ -732,1 +646,1 @@\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n@@ -740,1 +654,1 @@\n-     * @throws IllegalArgumentException if the sum of the {@linkplain #bitSize() bit sizes} of the member layouts\n+     * @throws IllegalArgumentException if the sum of the {@linkplain #byteSize() byte sizes} of the member layouts\n@@ -755,1 +669,1 @@\n-     * structLayout(JAVA_SHORT, MemoryLayout.ofPadding(16), JAVA_INT)\n+     * structLayout(JAVA_SHORT, MemoryLayout.ofPadding(2), JAVA_INT)\n@@ -762,1 +676,1 @@\n-     * structLayout(JAVA_SHORT, JAVA_INT.withBitAlignment(16))\n+     * structLayout(JAVA_SHORT, JAVA_INT.withByteAlignment(2))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":32,"deletions":118,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -267,6 +267,0 @@\n- * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000), so that successive long elements\n- * occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) A heap segment backed by a {@code long[]} array\n- * can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment can be\n- * accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses\n- * (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2, 4, 6, etc under a\n- * 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n@@ -281,0 +275,12 @@\n+ * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000) on 64-bit platforms,\n+ * so that successive long elements occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) On 64-bit platforms,\n+ * a heap segment backed by a {@code long[]} array can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment\n+ * constraint. In addition, the segment can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets\n+ * 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n+ * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned (e.g. 1000) on 32-bit platforms,\n+ * so that successive long elements occur at 4-byte aligned addresses (e.g., 1004, 1008, 1012, 1016, etc.) On 32-bit\n+ * platforms, a heap segment backed by a {@code long[]} array can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte\n+ * alignment constraint, because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment\n+ * can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses\n+ * (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n@@ -283,2 +289,2 @@\n- * In other words, heap segments feature a <em>maximum<\/em> alignment which is derived from the size of the elements of\n- * the Java array backing the segment, as shown in the following table:\n+ * In other words, heap segments feature a (platform-dependent) <em>maximum<\/em> alignment which is derived from the\n+ * size of the elements of the Java array backing the segment, as shown in the following table:\n@@ -296,1 +302,1 @@\n- *     <td style=\"text-align:center;\">{@code 1}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_BOOLEAN.byteAlignment()}<\/td><\/tr>\n@@ -298,1 +304,1 @@\n- *     <td style=\"text-align:center;\">{@code 1}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_BYTE.byteAlignment()}<\/td><\/tr>\n@@ -300,1 +306,1 @@\n- *     <td style=\"text-align:center;\">{@code 2}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_CHAR.byteAlignment()}<\/td><\/tr>\n@@ -302,1 +308,1 @@\n- *     <td style=\"text-align:center;\">{@code 2}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_SHORT.byteAlignment()}<\/td><\/tr>\n@@ -304,1 +310,1 @@\n- *     <td style=\"text-align:center;\">{@code 4}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_INT.byteAlignment()}<\/td><\/tr>\n@@ -306,1 +312,1 @@\n- *     <td style=\"text-align:center;\">{@code 4}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_FLOAT.byteAlignment()}<\/td><\/tr>\n@@ -308,1 +314,1 @@\n- *     <td style=\"text-align:center;\">{@code 8}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_LONG.byteAlignment()}<\/td><\/tr>\n@@ -310,1 +316,1 @@\n- *     <td style=\"text-align:center;\">{@code 8}<\/td><\/tr>\n+ *     <td style=\"text-align:center;\">{@code ValueLayout.JAVA_DOUBLE.byteAlignment()}<\/td><\/tr>\n@@ -321,1 +327,1 @@\n- * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: layout alignment is 4, segment max alignment is 1\n+ * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: ValueLayout.JAVA_INT.byteAlignment() > ValueLayout.JAVA_BYTE.byteAlignment()\n@@ -325,1 +331,4 @@\n- * type (e.g. {@code long[]}), capable of supporting greater maximum alignment:\n+ * type (e.g. {@code long[]}), capable of supporting greater maximum alignment. More specifically, the maximum alignment\n+ * associated with {@code long[]} is set to {@code ValueLayout.JAVA_LONG.byteAlignment()} which is a platform-dependent\n+ * value (set to {@code ValueLayout.ADDRESS.byteSize()}). That is, {@code long[]}) is guaranteed to provide at least\n+ * 8-byte alignment in 64-bit platforms, but only 4-byte alignment in 32-bit platforms:\n@@ -329,1 +338,1 @@\n- * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: layout alignment is 4, segment max alignment is 8\n+ * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: ValueLayout.JAVA_INT.byteAlignment() <= ValueLayout.JAVA_LONG.byteAlignment()\n@@ -336,1 +345,1 @@\n- * byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: ValueLayout.JAVA_INT_UNALIGNED.byteAlignment() == ValueLayout.JAVA_BYTE.byteAlignment()\n@@ -373,1 +382,1 @@\n- * to be read. For instance on a 64-bit platform, the size of an address layout is 64 bits. The access operation\n+ * to be read. For instance on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n@@ -464,1 +473,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n@@ -481,1 +490,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -59,2 +59,1 @@\n-    @Override\n-    PaddingLayout withBitAlignment(long bitAlignment);\n+    PaddingLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment < elementLayout().bitAlignment()}.\n+     * @throws IllegalArgumentException if {@code byteAlignment < elementLayout().byteAlignment()}.\n@@ -148,1 +148,1 @@\n-    SequenceLayout withBitAlignment(long bitAlignment);\n+    SequenceLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    StructLayout withBitAlignment(long bitAlignment);\n+    StructLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,0 +132,22 @@\n+    \/**\n+     * {@return a composed symbol lookup that returns result of finding the symbol with this lookup if found,\n+     * otherwise returns the result of finding the symbol with the other lookup}\n+     *\n+     * @apiNote This method could be used to chain multiple symbol lookups together, e.g. so that symbols could\n+     * be retrieved, in order, from multiple libraries:\n+     * {@snippet lang = java:\n+     * var lookup = SymbolLookup.libraryLookup(\"foo\", arena)\n+     *         .or(SymbolLookup.libraryLookup(\"bar\", arena))\n+     *         .or(SymbolLookup.loaderLookup());\n+     *}\n+     * The above code creates a symbol lookup that first searches for symbols in the \"foo\" library. If no symbol is found\n+     * in \"foo\" then \"bar\" is searched. Finally, if a symbol is not found in neither \"foo\" nor \"bar\", the {@linkplain\n+     * SymbolLookup#loaderLookup() loader lookup} is used.\n+     *\n+     * @param other the symbol lookup that should be used to look for symbols not found in this lookup.\n+     *\/\n+    default SymbolLookup or(SymbolLookup other) {\n+        Objects.requireNonNull(other);\n+        return name -> find(name).or(() -> other.find(name));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    UnionLayout withBitAlignment(long bitAlignment);\n+    UnionLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * Each value layout has a size, an alignment (in bits),\n+ * Each value layout has a size, an alignment (both expressed in bytes),\n@@ -132,1 +132,1 @@\n-     * @throws UnsupportedOperationException if {@code bitAlignment() > bitSize()}.\n+     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n@@ -155,1 +155,1 @@\n-    ValueLayout withBitAlignment(long bitAlignment);\n+    ValueLayout withByteAlignment(long byteAlignment);\n@@ -183,1 +183,1 @@\n-        OfBoolean withBitAlignment(long bitAlignment);\n+        OfBoolean withByteAlignment(long byteAlignment);\n@@ -219,1 +219,1 @@\n-        OfByte withBitAlignment(long bitAlignment);\n+        OfByte withByteAlignment(long byteAlignment);\n@@ -256,1 +256,1 @@\n-        OfChar withBitAlignment(long bitAlignment);\n+        OfChar withByteAlignment(long byteAlignment);\n@@ -293,1 +293,1 @@\n-        OfShort withBitAlignment(long bitAlignment);\n+        OfShort withByteAlignment(long byteAlignment);\n@@ -330,1 +330,1 @@\n-        OfInt withBitAlignment(long bitAlignment);\n+        OfInt withByteAlignment(long byteAlignment);\n@@ -366,1 +366,1 @@\n-        OfFloat withBitAlignment(long bitAlignment);\n+        OfFloat withByteAlignment(long byteAlignment);\n@@ -403,1 +403,1 @@\n-        OfLong withBitAlignment(long bitAlignment);\n+        OfLong withByteAlignment(long byteAlignment);\n@@ -440,1 +440,1 @@\n-        OfDouble withBitAlignment(long bitAlignment);\n+        OfDouble withByteAlignment(long byteAlignment);\n@@ -452,1 +452,1 @@\n-     * bit alignment set to {@code sizeof(size_t) * 8}, byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to {@code sizeof(size_t)}, byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -458,1 +458,1 @@\n-     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 1, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -464,1 +464,1 @@\n-     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 1, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -470,1 +470,1 @@\n-     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 2, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -476,1 +476,1 @@\n-     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 2, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -482,1 +482,1 @@\n-     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 4, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -488,1 +488,2 @@\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * (platform-dependent) byte alignment set to {@code ADDRESS.byteSize()},\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -494,1 +495,1 @@\n-     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 4, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -500,1 +501,2 @@\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * (platform-dependent) byte alignment set to {@code ADDRESS.byteSize()},\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -509,1 +511,1 @@\n-     * ADDRESS.withBitAlignment(8);\n+     * ADDRESS.withByteAlignment(1);\n@@ -514,1 +516,1 @@\n-    AddressLayout ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+    AddressLayout ADDRESS_UNALIGNED = ADDRESS.withByteAlignment(1);\n@@ -521,1 +523,1 @@\n-     * JAVA_CHAR.withBitAlignment(8);\n+     * JAVA_CHAR.withByteAlignment(1);\n@@ -526,1 +528,1 @@\n-    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withByteAlignment(1);\n@@ -533,1 +535,1 @@\n-     * JAVA_SHORT.withBitAlignment(8);\n+     * JAVA_SHORT.withByteAlignment(1);\n@@ -538,1 +540,1 @@\n-    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withByteAlignment(1);\n@@ -545,1 +547,1 @@\n-     * JAVA_INT.withBitAlignment(8);\n+     * JAVA_INT.withByteAlignment(1);\n@@ -550,1 +552,1 @@\n-    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withByteAlignment(1);\n@@ -557,1 +559,1 @@\n-     * JAVA_LONG.withBitAlignment(8);\n+     * JAVA_LONG.withByteAlignment(1);\n@@ -562,1 +564,1 @@\n-    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withByteAlignment(1);\n@@ -569,1 +571,1 @@\n-     * JAVA_FLOAT.withBitAlignment(8);\n+     * JAVA_FLOAT.withByteAlignment(1);\n@@ -574,1 +576,1 @@\n-    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withByteAlignment(1);\n@@ -581,1 +583,1 @@\n-     * JAVA_DOUBLE.withBitAlignment(8);\n+     * JAVA_DOUBLE.withByteAlignment(1);\n@@ -586,1 +588,1 @@\n-    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n+    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withByteAlignment(1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":36,"deletions":34,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -7967,1 +7967,1 @@\n-     *             MemoryLayout.paddingLayout(32),\n+     *             MemoryLayout.paddingLayout(4),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.Enum.EnumDesc;\n@@ -34,0 +35,1 @@\n+import java.util.Objects;\n@@ -36,2 +38,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -46,1 +47,1 @@\n- * @since 17\n+ * @since 21\n@@ -48,1 +49,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n@@ -63,1 +63,2 @@\n-                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class));\n+                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class,\n+                                                                 MethodHandles.Lookup.class, Class.class, ResolvedEnumLabels.class));\n@@ -74,1 +75,1 @@\n-     * {@code String} or {@code Integer} or {@code Class}.\n+     * {@code String} or {@code Integer} or {@code Class} or {@code EnumDesc}.\n@@ -92,0 +93,2 @@\n+     *   <li>the element is of type {@code EnumDesc}, that describes a constant that is\n+     *       equals to the target.<\/li>\n@@ -96,0 +99,4 @@\n+     * <p>\n+     * The value of the {@code restart} index must be between {@code 0} (inclusive) and\n+     * the length of the {@code labels} array (inclusive),\n+     * both  or an {@link IndexOutOfBoundsException} is thrown.\n@@ -104,1 +111,1 @@\n-     *               and {@code Class} instances, in any combination\n+     *               and {@code Class} and {@code EnumDesc} instances, in any combination\n@@ -112,1 +119,1 @@\n-     * {@code Integer} or {@code Class}.\n+     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n@@ -141,1 +148,2 @@\n-            labelClass != Integer.class) {\n+            labelClass != Integer.class &&\n+            labelClass != EnumDesc.class) {\n@@ -147,0 +155,2 @@\n+        Objects.checkIndex(startIndex, labels.length + 1);\n+\n@@ -163,0 +173,5 @@\n+            } else if (label instanceof EnumDesc<?> enumDesc) {\n+                if (target.getClass().isEnum() &&\n+                    ((Enum<?>) target).describeConstable().stream().anyMatch(d -> d.equals(enumDesc))) {\n+                    return i;\n+                }\n@@ -203,0 +218,4 @@\n+     * <p>\n+     * The value of the {@code restart} index must be between {@code 0} (inclusive) and\n+     * the length of the {@code labels} array (inclusive),\n+     * both  or an {@link IndexOutOfBoundsException} is thrown.\n@@ -238,1 +257,4 @@\n-        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();\n+        Stream.of(labels).forEach(l -> validateEnumLabel(enumClass, l));\n+        MethodHandle temporary =\n+                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, labels, lookup, enumClass, new ResolvedEnumLabels());\n+        temporary = temporary.asType(invocationType);\n@@ -240,3 +262,2 @@\n-        MethodHandle target =\n-                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, (Object) labels);\n-        target = target.asType(invocationType);\n+        return new ConstantCallSite(temporary);\n+    }\n@@ -244,1 +265,14 @@\n-        return new ConstantCallSite(target);\n+    private static <E extends Enum<E>> void validateEnumLabel(Class<?> enumClassTemplate, Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass == Class.class) {\n+            if (label != enumClassTemplate) {\n+                throw new IllegalArgumentException(\"the Class label: \" + label +\n+                                                   \", expected the provided enum class: \" + enumClassTemplate);\n+            }\n+        } else if (labelClass != String.class) {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass +\n+                                               \", expected label of type either String or Class\");\n+        }\n@@ -272,1 +306,5 @@\n-    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] labels) {\n+    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] unresolvedLabels,\n+                                    MethodHandles.Lookup lookup, Class<?> enumClass,\n+                                    ResolvedEnumLabels resolvedLabels) {\n+        Objects.checkIndex(startIndex, unresolvedLabels.length + 1);\n+\n@@ -276,0 +314,8 @@\n+        if (resolvedLabels.resolvedLabels == null) {\n+            resolvedLabels.resolvedLabels = Stream.of(unresolvedLabels)\n+                                                  .map(l -> convertEnumConstants(lookup, enumClass, l))\n+                                                  .toArray();\n+        }\n+\n+        Object[] labels = resolvedLabels.resolvedLabels;\n+\n@@ -291,0 +337,4 @@\n+    private static final class ResolvedEnumLabels {\n+        @Stable\n+        public Object[] resolvedLabels;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":65,"deletions":15,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,1 +373,1 @@\n-            domain = pattern.toLowerCase();\n+            domain = pattern.toLowerCase(Locale.ROOT);\n@@ -746,2 +746,2 @@\n-        int h1 = name.toLowerCase().hashCode();\n-        int h2 = (domain!=null) ? domain.toLowerCase().hashCode() : 0;\n+        int h1 = name.toLowerCase(Locale.ROOT).hashCode();\n+        int h2 = (domain!=null) ? domain.toLowerCase(Locale.ROOT).hashCode() : 0;\n@@ -980,1 +980,1 @@\n-        CookieAttributeAssignor assignor = assignors.get(attrName.toLowerCase());\n+        CookieAttributeAssignor assignor = assignors.get(attrName.toLowerCase(Locale.ROOT));\n@@ -1082,1 +1082,1 @@\n-        header = header.toLowerCase();\n+        header = header.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpCookie.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Locale;\n@@ -140,1 +141,1 @@\n-                return hostname.toLowerCase().hashCode() + port;\n+                return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetSocketAddress.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Locale;\n@@ -463,1 +464,1 @@\n-                cname = host.substring(1).toLowerCase();\n+                cname = host.substring(1).toLowerCase(Locale.ROOT);\n@@ -673,1 +674,1 @@\n-                cname = addresses[0].getHostName(false).toLowerCase();\n+                cname = addresses[0].getHostName(false).toLowerCase(Locale.ROOT);\n@@ -676,1 +677,1 @@\n-                                              getHostName(false).toLowerCase();\n+                                              getHostName(false).toLowerCase(Locale.ROOT);\n@@ -699,2 +700,2 @@\n-        String a = checkForIDN(cname.toLowerCase());\n-        String b = checkForIDN(hname.toLowerCase());\n+        String a = checkForIDN(cname.toLowerCase(Locale.ROOT));\n+        String b = checkForIDN(hname.toLowerCase(Locale.ROOT));\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.Locale;\n@@ -1457,1 +1458,1 @@\n-        contentType = contentType.toLowerCase();\n+        contentType = contentType.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLConnection.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Locale;\n@@ -377,1 +378,1 @@\n-                h += host.toLowerCase().hashCode();\n+                h += host.toLowerCase(Locale.ROOT).hashCode();\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLStreamHandler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,10 +277,7 @@\n-        return toMatchResult(text.toString());\n-    }\n-\n-    private MatchResult toMatchResult(String text) {\n-        return new ImmutableMatchResult(this.first,\n-                                        this.last,\n-                                        groupCount(),\n-                                        this.groups.clone(),\n-                                        text,\n-                                        namedGroups());\n+        String capturedText = hasMatch()\n+                ? text.subSequence(first, last).toString()\n+                : null;\n+        return new ImmutableMatchResult(first, last, groupCount(),\n+                groups.clone(), capturedText,\n+                namedGroups()\n+        );\n@@ -292,1 +289,0 @@\n-        private final int[] groups;\n@@ -294,0 +290,1 @@\n+        private final int[] groups;\n@@ -299,2 +296,1 @@\n-                             Map<String, Integer> namedGroups)\n-        {\n+                             Map<String, Integer> namedGroups) {\n@@ -352,1 +348,1 @@\n-            return text.subSequence(groups[group * 2], groups[group * 2 + 1]).toString();\n+            return text.substring(groups[group * 2] - first, groups[group * 2 + 1] - first);\n@@ -373,1 +369,0 @@\n-\n@@ -1078,1 +1073,2 @@\n-                        if (!namedGroups().containsKey(gname))\n+                        Integer number = namedGroups().get(gname);\n+                        if (number == null)\n@@ -1081,1 +1077,1 @@\n-                        refNum = namedGroups().get(gname);\n+                        refNum = number;\n@@ -1321,3 +1317,0 @@\n-            \/\/ The input sequence as a string, set once only after first find\n-            \/\/ Avoids repeated conversion from CharSequence for each match\n-            String textAsString;\n@@ -1334,1 +1327,1 @@\n-                return toMatchResult(textAsString);\n+                return toMatchResult();\n@@ -1349,3 +1342,0 @@\n-                \/\/ Capture the input sequence as a string on first find\n-                if (found && state < 0)\n-                    textAsString = text.toString();\n@@ -1374,3 +1364,0 @@\n-                \/\/ Capture the input sequence as a string on first find\n-                textAsString = text.toString();\n-\n@@ -1379,1 +1366,1 @@\n-                    action.accept(toMatchResult(textAsString));\n+                    action.accept(toMatchResult());\n@@ -1822,1 +1809,2 @@\n-        if (!namedGroups().containsKey(name))\n+        Integer number = namedGroups().get(name);\n+        if (number == null)\n@@ -1824,1 +1812,1 @@\n-        return namedGroups().get(name);\n+        return number;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Matcher.java","additions":18,"deletions":30,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2715,1 +2715,2 @@\n-            if (!namedGroupsMap().containsKey(name))\n+            Integer number = namedGroupsMap().get(name);\n+            if (number == null)\n@@ -2720,1 +2721,1 @@\n-                    root = new CIBackRef(namedGroupsMap().get(name), has(UNICODE_CASE));\n+                    root = new CIBackRef(number, has(UNICODE_CASE));\n@@ -2722,1 +2723,1 @@\n-                    root = new BackRef(namedGroupsMap().get(name));\n+                    root = new BackRef(number);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -84,1 +85,1 @@\n-        return enclosingMethodType().map(n -> MethodTypeDesc.ofDescriptor(n.stringValue()));\n+        return enclosingMethod().map(Util::methodTypeSymbol);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -27,7 +26,0 @@\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicCallSiteDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.util.List;\n@@ -36,5 +28,0 @@\n-import jdk.internal.classfile.Annotation;\n-import jdk.internal.classfile.AnnotationElement;\n-import jdk.internal.classfile.AnnotationValue;\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.ClassElement;\n@@ -42,1 +29,0 @@\n-import jdk.internal.classfile.ClassSignature;\n@@ -45,3 +31,0 @@\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n-import jdk.internal.classfile.CodeModel;\n@@ -49,3 +32,0 @@\n-import jdk.internal.classfile.FieldBuilder;\n-import jdk.internal.classfile.FieldElement;\n-import jdk.internal.classfile.FieldModel;\n@@ -53,13 +33,0 @@\n-import jdk.internal.classfile.Interfaces;\n-import jdk.internal.classfile.MethodBuilder;\n-import jdk.internal.classfile.MethodElement;\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n-import jdk.internal.classfile.instruction.FieldInstruction;\n-import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n-import jdk.internal.classfile.instruction.InvokeInstruction;\n-import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n-import jdk.internal.classfile.instruction.NewObjectInstruction;\n-import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n-import jdk.internal.classfile.instruction.TypeCheckInstruction;\n-import jdk.internal.classfile.MethodModel;\n-import jdk.internal.classfile.MethodSignature;\n@@ -67,28 +34,1 @@\n-import jdk.internal.classfile.Signature;\n-import jdk.internal.classfile.Superclass;\n-import jdk.internal.classfile.TypeAnnotation;\n-import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n-import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n-import jdk.internal.classfile.attribute.ExceptionsAttribute;\n-import jdk.internal.classfile.attribute.InnerClassInfo;\n-import jdk.internal.classfile.attribute.InnerClassesAttribute;\n-import jdk.internal.classfile.attribute.ModuleAttribute;\n-import jdk.internal.classfile.attribute.ModuleProvideInfo;\n-import jdk.internal.classfile.attribute.NestHostAttribute;\n-import jdk.internal.classfile.attribute.NestMembersAttribute;\n-import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n-import jdk.internal.classfile.attribute.RecordAttribute;\n-import jdk.internal.classfile.attribute.RecordComponentInfo;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.instruction.ExceptionCatch;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.LocalVariableType;\n-import jdk.internal.classfile.impl.Util;\n-import jdk.internal.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n+import jdk.internal.classfile.impl.ClassRemapperImpl;\n@@ -112,1 +52,1 @@\n-public sealed interface ClassRemapper extends ClassTransform {\n+public sealed interface ClassRemapper extends ClassTransform permits ClassRemapperImpl {\n@@ -138,1 +78,1 @@\n-     * @return class target class\n+     * @return target class\n@@ -143,2 +83,1 @@\n-     * Returns this {@code ClassRemapper} as {@link FieldTransform} instance\n-     * @return this {@code ClassRemapper} as {@link FieldTransform} instance\n+     * {@return this {@code ClassRemapper} as {@link FieldTransform} instance}\n@@ -149,2 +88,1 @@\n-     * Returns this {@code ClassRemapper} as {@link MethodTransform} instance\n-     * @return this {@code ClassRemapper} as {@link MethodTransform} instance\n+     * {@return this {@code ClassRemapper} as {@link MethodTransform} instance}\n@@ -155,2 +93,1 @@\n-     * Returns this {@code ClassRemapper} as {@link CodeTransform} instance\n-     * @return this {@code ClassRemapper} as {@link CodeTransform} instance\n+     * {@return this {@code ClassRemapper} as {@link CodeTransform} instance}\n@@ -169,326 +106,0 @@\n-\n-    record ClassRemapperImpl(Function<ClassDesc, ClassDesc> mapFunction) implements ClassRemapper {\n-\n-        @Override\n-        public void accept(ClassBuilder clb, ClassElement cle) {\n-            switch (cle) {\n-                case FieldModel fm ->\n-                    clb.withField(fm.fieldName().stringValue(), map(\n-                            fm.fieldTypeSymbol()), fb ->\n-                                    fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n-                case MethodModel mm ->\n-                    clb.withMethod(mm.methodName().stringValue(), mapMethodDesc(\n-                            mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n-                                    mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n-                case Superclass sc ->\n-                    clb.withSuperclass(map(sc.superclassEntry().asSymbol()));\n-                case Interfaces ins ->\n-                    clb.withInterfaceSymbols(Util.mappedList(ins.interfaces(), in ->\n-                            map(in.asSymbol())));\n-                case SignatureAttribute sa ->\n-                    clb.with(SignatureAttribute.of(mapClassSignature(sa.asClassSignature())));\n-                case InnerClassesAttribute ica ->\n-                    clb.with(InnerClassesAttribute.of(ica.classes().stream().map(ici ->\n-                            InnerClassInfo.of(map(ici.innerClass().asSymbol()),\n-                                    ici.outerClass().map(oc -> map(oc.asSymbol())),\n-                                    ici.innerName().map(Utf8Entry::stringValue),\n-                                    ici.flagsMask())).toList()));\n-                case EnclosingMethodAttribute ema ->\n-                    clb.with(EnclosingMethodAttribute.of(map(ema.enclosingClass().asSymbol()),\n-                            ema.enclosingMethodName().map(Utf8Entry::stringValue),\n-                            ema.enclosingMethodTypeSymbol().map(this::mapMethodDesc)));\n-                case RecordAttribute ra ->\n-                    clb.with(RecordAttribute.of(ra.components().stream()\n-                            .map(this::mapRecordComponent).toList()));\n-                case ModuleAttribute ma ->\n-                    clb.with(ModuleAttribute.of(ma.moduleName(), ma.moduleFlagsMask(),\n-                            ma.moduleVersion().orElse(null),\n-                            ma.requires(), ma.exports(), ma.opens(),\n-                            ma.uses().stream().map(ce ->\n-                                    clb.constantPool().classEntry(map(ce.asSymbol()))).toList(),\n-                            ma.provides().stream().map(mp ->\n-                                    ModuleProvideInfo.of(map(mp.provides().asSymbol()),\n-                                            mp.providesWith().stream().map(pw ->\n-                                                    map(pw.asSymbol())).toList())).toList()));\n-                case NestHostAttribute nha ->\n-                    clb.with(NestHostAttribute.of(map(nha.nestHost().asSymbol())));\n-                case NestMembersAttribute nma ->\n-                    clb.with(NestMembersAttribute.ofSymbols(nma.nestMembers().stream()\n-                            .map(nm -> map(nm.asSymbol())).toList()));\n-                case PermittedSubclassesAttribute psa ->\n-                    clb.with(PermittedSubclassesAttribute.ofSymbols(\n-                            psa.permittedSubclasses().stream().map(ps ->\n-                                    map(ps.asSymbol())).toList()));\n-                case RuntimeVisibleAnnotationsAttribute aa ->\n-                    clb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                            mapAnnotations(aa.annotations())));\n-                case RuntimeInvisibleAnnotationsAttribute aa ->\n-                    clb.with(RuntimeInvisibleAnnotationsAttribute.of(\n-                            mapAnnotations(aa.annotations())));\n-                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                    clb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                            mapTypeAnnotations(aa.annotations())));\n-                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                    clb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                            mapTypeAnnotations(aa.annotations())));\n-                default ->\n-                    clb.with(cle);\n-            }\n-        }\n-\n-        @Override\n-        public FieldTransform asFieldTransform() {\n-            return (FieldBuilder fb, FieldElement fe) -> {\n-                switch (fe) {\n-                    case SignatureAttribute sa ->\n-                        fb.with(SignatureAttribute.of(\n-                                mapSignature(sa.asTypeSignature())));\n-                    case RuntimeVisibleAnnotationsAttribute aa ->\n-                        fb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleAnnotationsAttribute aa ->\n-                        fb.with(RuntimeInvisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                        fb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                        fb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    default ->\n-                        fb.with(fe);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public MethodTransform asMethodTransform() {\n-            return (MethodBuilder mb, MethodElement me) -> {\n-                switch (me) {\n-                    case AnnotationDefaultAttribute ada ->\n-                        mb.with(AnnotationDefaultAttribute.of(\n-                                mapAnnotationValue(ada.defaultValue())));\n-                    case CodeModel com ->\n-                        mb.transformCode(com, asCodeTransform());\n-                    case ExceptionsAttribute ea ->\n-                        mb.with(ExceptionsAttribute.ofSymbols(\n-                                ea.exceptions().stream().map(ce ->\n-                                        map(ce.asSymbol())).toList()));\n-                    case SignatureAttribute sa ->\n-                        mb.with(SignatureAttribute.of(\n-                                mapMethodSignature(sa.asMethodSignature())));\n-                    case RuntimeVisibleAnnotationsAttribute aa ->\n-                        mb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleAnnotationsAttribute aa ->\n-                        mb.with(RuntimeInvisibleAnnotationsAttribute.of(\n-                                mapAnnotations(aa.annotations())));\n-                    case RuntimeVisibleParameterAnnotationsAttribute paa ->\n-                        mb.with(RuntimeVisibleParameterAnnotationsAttribute.of(\n-                                paa.parameterAnnotations().stream()\n-                                        .map(this::mapAnnotations).toList()));\n-                    case RuntimeInvisibleParameterAnnotationsAttribute paa ->\n-                        mb.with(RuntimeInvisibleParameterAnnotationsAttribute.of(\n-                                paa.parameterAnnotations().stream()\n-                                        .map(this::mapAnnotations).toList()));\n-                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                        mb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                        mb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    default ->\n-                        mb.with(me);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public CodeTransform asCodeTransform() {\n-            return (CodeBuilder cob, CodeElement coe) -> {\n-                switch (coe) {\n-                    case FieldInstruction fai ->\n-                        cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n-                                fai.name().stringValue(), map(fai.typeSymbol()));\n-                    case InvokeInstruction ii ->\n-                        cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n-                                ii.name().stringValue(), mapMethodDesc(ii.typeSymbol()),\n-                                ii.isInterface());\n-                    case InvokeDynamicInstruction idi ->\n-                        cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n-                                idi.bootstrapMethod(), idi.name().stringValue(),\n-                                mapMethodDesc(idi.typeSymbol()),\n-                                idi.bootstrapArgs().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new)));\n-                    case NewObjectInstruction c ->\n-                        cob.newObjectInstruction(map(c.className().asSymbol()));\n-                    case NewReferenceArrayInstruction c ->\n-                        cob.anewarray(map(c.componentType().asSymbol()));\n-                    case NewMultiArrayInstruction c ->\n-                        cob.multianewarray(map(c.arrayType().asSymbol()), c.dimensions());\n-                    case TypeCheckInstruction c ->\n-                        cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n-                    case ExceptionCatch c ->\n-                        cob.exceptionCatch(c.tryStart(), c.tryEnd(), c.handler(),c.catchType()\n-                                .map(d -> TemporaryConstantPool.INSTANCE.classEntry(map(d.asSymbol()))));\n-                    case LocalVariable c ->\n-                        cob.localVariable(c.slot(), c.name().stringValue(), map(c.typeSymbol()),\n-                                c.startScope(), c.endScope());\n-                    case LocalVariableType c ->\n-                        cob.localVariableType(c.slot(), c.name().stringValue(),\n-                                mapSignature(c.signatureSymbol()), c.startScope(), c.endScope());\n-                    case LoadConstantInstruction ldc ->\n-                        cob.constantInstruction(ldc.opcode(),\n-                                mapConstantValue(ldc.constantValue()));\n-                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                        cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                        cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                mapTypeAnnotations(aa.annotations())));\n-                    default ->\n-                        cob.with(coe);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public ClassDesc map(ClassDesc desc) {\n-            if (desc == null) return null;\n-            if (desc.isArray()) return map(desc.componentType()).arrayType();\n-            if (desc.isPrimitive()) return desc;\n-            return mapFunction.apply(desc);\n-        }\n-\n-        MethodTypeDesc mapMethodDesc(MethodTypeDesc desc) {\n-            return MethodTypeDesc.of(map(desc.returnType()),\n-                    desc.parameterList().stream().map(this::map).toArray(ClassDesc[]::new));\n-        }\n-\n-        ClassSignature mapClassSignature(ClassSignature signature) {\n-            return ClassSignature.of(mapTypeParams(signature.typeParameters()),\n-                    mapSignature(signature.superclassSignature()),\n-                    signature.superinterfaceSignatures().stream()\n-                            .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n-        }\n-\n-        MethodSignature mapMethodSignature(MethodSignature signature) {\n-            return MethodSignature.of(mapTypeParams(signature.typeParameters()),\n-                    signature.throwableSignatures().stream().map(this::mapSignature).toList(),\n-                    mapSignature(signature.result()),\n-                    signature.arguments().stream()\n-                            .map(this::mapSignature).toArray(Signature[]::new));\n-        }\n-\n-        RecordComponentInfo mapRecordComponent(RecordComponentInfo component) {\n-            return RecordComponentInfo.of(component.name().stringValue(),\n-                    map(component.descriptorSymbol()),\n-                    component.attributes().stream().map(atr ->\n-                        switch (atr) {\n-                            case SignatureAttribute sa ->\n-                                SignatureAttribute.of(\n-                                        mapSignature(sa.asTypeSignature()));\n-                            case RuntimeVisibleAnnotationsAttribute aa ->\n-                                RuntimeVisibleAnnotationsAttribute.of(\n-                                        mapAnnotations(aa.annotations()));\n-                            case RuntimeInvisibleAnnotationsAttribute aa ->\n-                                RuntimeInvisibleAnnotationsAttribute.of(\n-                                        mapAnnotations(aa.annotations()));\n-                            case RuntimeVisibleTypeAnnotationsAttribute aa ->\n-                                RuntimeVisibleTypeAnnotationsAttribute.of(\n-                                        mapTypeAnnotations(aa.annotations()));\n-                            case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n-                                RuntimeInvisibleTypeAnnotationsAttribute.of(\n-                                        mapTypeAnnotations(aa.annotations()));\n-                            default -> atr;\n-                        }).toList());\n-        }\n-\n-        DirectMethodHandleDesc mapDirectMethodHandle(DirectMethodHandleDesc dmhd) {\n-            return switch (dmhd.kind()) {\n-                case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER ->\n-                    MethodHandleDesc.ofField(dmhd.kind(), map(dmhd.owner()),\n-                            dmhd.methodName(),\n-                            map(ClassDesc.ofDescriptor(dmhd.lookupDescriptor())));\n-                default ->\n-                    MethodHandleDesc.ofMethod(dmhd.kind(), map(dmhd.owner()),\n-                            dmhd.methodName(),\n-                            mapMethodDesc(MethodTypeDesc.ofDescriptor(dmhd.lookupDescriptor())));\n-            };\n-        }\n-\n-        ConstantDesc mapConstantValue(ConstantDesc value) {\n-            return switch (value) {\n-                case ClassDesc cd ->\n-                    map(cd);\n-                case DynamicConstantDesc<?> dcd ->\n-                    mapDynamicConstant(dcd);\n-                case DirectMethodHandleDesc dmhd ->\n-                    mapDirectMethodHandle(dmhd);\n-                case MethodTypeDesc mtd ->\n-                    mapMethodDesc(mtd);\n-                default -> value;\n-            };\n-        }\n-\n-        DynamicConstantDesc<?> mapDynamicConstant(DynamicConstantDesc<?> dcd) {\n-            return DynamicConstantDesc.ofNamed(mapDirectMethodHandle(dcd.bootstrapMethod()),\n-                    dcd.constantName(),\n-                    map(dcd.constantType()),\n-                    dcd.bootstrapArgsList().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new));\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        <S extends Signature> S mapSignature(S signature) {\n-            return (S) switch (signature) {\n-                case Signature.ArrayTypeSig ats ->\n-                    Signature.ArrayTypeSig.of(mapSignature(ats.componentSignature()));\n-                case Signature.ClassTypeSig cts ->\n-                    Signature.ClassTypeSig.of(\n-                            cts.outerType().map(this::mapSignature).orElse(null),\n-                            map(cts.classDesc()),\n-                            cts.typeArgs().stream()\n-                                    .map(ta -> Signature.TypeArg.of(\n-                                            ta.wildcardIndicator(),\n-                                            ta.boundType().map(this::mapSignature)))\n-                                    .toArray(Signature.TypeArg[]::new));\n-                default -> signature;\n-            };\n-        }\n-\n-        List<Annotation> mapAnnotations(List<Annotation> annotations) {\n-            return annotations.stream().map(this::mapAnnotation).toList();\n-        }\n-\n-        Annotation mapAnnotation(Annotation a) {\n-            return Annotation.of(map(a.classSymbol()), a.elements().stream().map(el ->\n-                    AnnotationElement.of(el.name(), mapAnnotationValue(el.value()))).toList());\n-        }\n-\n-        AnnotationValue mapAnnotationValue(AnnotationValue val) {\n-            return switch (val) {\n-                case AnnotationValue.OfAnnotation oa ->\n-                    AnnotationValue.ofAnnotation(mapAnnotation(oa.annotation()));\n-                case AnnotationValue.OfArray oa ->\n-                    AnnotationValue.ofArray(oa.values().stream().map(this::mapAnnotationValue).toList());\n-                case AnnotationValue.OfConstant oc -> oc;\n-                case AnnotationValue.OfClass oc ->\n-                    AnnotationValue.ofClass(map(oc.classSymbol()));\n-                case AnnotationValue.OfEnum oe ->\n-                    AnnotationValue.ofEnum(map(oe.classSymbol()), oe.constantName().stringValue());\n-            };\n-        }\n-\n-        List<TypeAnnotation> mapTypeAnnotations(List<TypeAnnotation> typeAnnotations) {\n-            return typeAnnotations.stream().map(a -> TypeAnnotation.of(a.targetInfo(),\n-                    a.targetPath(), map(a.classSymbol()),\n-                    a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                            mapAnnotationValue(el.value()))).toList())).toList();\n-        }\n-\n-        List<Signature.TypeParam> mapTypeParams(List<Signature.TypeParam> typeParams) {\n-            return typeParams.stream().map(tp -> Signature.TypeParam.of(tp.identifier(),\n-                    tp.classBound().map(this::mapSignature),\n-                    tp.interfaceBounds().stream()\n-                            .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new))).toList();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassRemapper.java","additions":7,"deletions":396,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -27,2 +26,0 @@\n-import java.util.Arrays;\n-\n@@ -31,2 +28,0 @@\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n@@ -34,5 +29,0 @@\n-import jdk.internal.classfile.Signature;\n-import jdk.internal.classfile.instruction.IncrementInstruction;\n-import jdk.internal.classfile.instruction.LoadInstruction;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.StoreInstruction;\n@@ -40,1 +30,1 @@\n-import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.impl.CodeLocalsShifterImpl;\n@@ -48,1 +38,1 @@\n-public sealed interface CodeLocalsShifter extends CodeTransform {\n+public sealed interface CodeLocalsShifter extends CodeTransform permits CodeLocalsShifterImpl {\n@@ -52,1 +42,1 @@\n-     * with fixed local slots calculated from provided method information\n+     * with fixed local slots calculated from provided method information.\n@@ -63,61 +53,0 @@\n-\n-    final static class CodeLocalsShifterImpl implements CodeLocalsShifter {\n-\n-        private int[] locals = new int[0];\n-        private final int fixed;\n-\n-        private CodeLocalsShifterImpl(int fixed) {\n-            this.fixed = fixed;\n-        }\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            switch (coe) {\n-                case LoadInstruction li ->\n-                    cob.loadInstruction(\n-                            li.typeKind(),\n-                            shift(cob, li.slot(), li.typeKind()));\n-                case StoreInstruction si ->\n-                    cob.storeInstruction(\n-                            si.typeKind(),\n-                            shift(cob, si.slot(), si.typeKind()));\n-                case IncrementInstruction ii ->\n-                    cob.incrementInstruction(\n-                            shift(cob, ii.slot(), TypeKind.IntType),\n-                            ii.constant());\n-                case LocalVariable lv ->\n-                    cob.localVariable(\n-                            shift(cob, lv.slot(), TypeKind.fromDescriptor(lv.type().stringValue())),\n-                            lv.name(),\n-                            lv.type(),\n-                            lv.startScope(),\n-                            lv.endScope());\n-                case LocalVariableType lvt ->\n-                    cob.localVariableType(\n-                            shift(cob, lvt.slot(),\n-                                    (lvt.signatureSymbol() instanceof Signature.BaseTypeSig bsig)\n-                                            ? TypeKind.fromDescriptor(bsig.signatureString())\n-                                            : TypeKind.ReferenceType),\n-                            lvt.name(),\n-                            lvt.signature(),\n-                            lvt.startScope(),\n-                            lvt.endScope());\n-                default -> cob.with(coe);\n-            }\n-        }\n-\n-        private int shift(CodeBuilder cob, int slot, TypeKind tk) {\n-            if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n-            if (slot >= fixed) {\n-                int key = 2*slot - fixed + tk.slotSize() - 1;\n-                if (key >= locals.length) locals = Arrays.copyOf(locals, key + 20);\n-                slot = locals[key] - 1;\n-                if (slot < 0) {\n-                    slot = cob.allocateLocal(tk);\n-                    locals[key] = slot + 1;\n-                    if (tk.slotSize() == 2) locals[key - 1] = slot + 1;\n-                }\n-            }\n-            return slot;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeLocalsShifter.java","additions":4,"deletions":75,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -30,1 +29,0 @@\n-import jdk.internal.classfile.CodeElement;\n@@ -32,4 +30,0 @@\n-import jdk.internal.classfile.instruction.BranchInstruction;\n-import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n-import jdk.internal.classfile.instruction.SwitchCase;\n-import jdk.internal.classfile.instruction.TableSwitchInstruction;\n@@ -37,5 +31,1 @@\n-import jdk.internal.classfile.instruction.CharacterRange;\n-import jdk.internal.classfile.instruction.ExceptionCatch;\n-import jdk.internal.classfile.instruction.LabelTarget;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.impl.CodeRelabelerImpl;\n@@ -53,1 +43,1 @@\n-public sealed interface CodeRelabeler extends CodeTransform {\n+public sealed interface CodeRelabeler extends CodeTransform permits CodeRelabelerImpl {\n@@ -56,2 +46,2 @@\n-     * Creates new instance of CodeRelabeler\n-     * @return new instance of CodeRelabeler\n+     * Creates a new instance of CodeRelabeler.\n+     * @return a new instance of CodeRelabeler\n@@ -64,1 +54,1 @@\n-     * Creates new instance of CodeRelabeler storing the label mapping into the provided map\n+     * Creates a new instance of CodeRelabeler storing the label mapping into the provided map.\n@@ -66,1 +56,1 @@\n-     * @return new instance of CodeRelabeler\n+     * @return a new instance of CodeRelabeler\n@@ -73,1 +63,1 @@\n-     * Creates new instance of CodeRelabeler using provided {@link java.util.function.BiFunction}\n+     * Creates a new instance of CodeRelabeler using provided {@link java.util.function.BiFunction}\n@@ -76,1 +66,1 @@\n-     * @return\n+     * @return a new instance of CodeRelabeler\n@@ -89,66 +79,0 @@\n-\n-    record CodeRelabelerImpl(BiFunction<Label, CodeBuilder, Label> mapFunction) implements  CodeRelabeler {\n-\n-        @Override\n-        public Label relabel(Label label, CodeBuilder cob) {\n-            return mapFunction.apply(label, cob);\n-        }\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            switch (coe) {\n-                case BranchInstruction bi ->\n-                    cob.branchInstruction(\n-                            bi.opcode(),\n-                            relabel(bi.target(), cob));\n-                case LookupSwitchInstruction lsi ->\n-                    cob.lookupSwitchInstruction(\n-                            relabel(lsi.defaultTarget(), cob),\n-                            lsi.cases().stream().map(c ->\n-                                    SwitchCase.of(\n-                                            c.caseValue(),\n-                                            relabel(c.target(), cob))).toList());\n-                case TableSwitchInstruction tsi ->\n-                    cob.tableSwitchInstruction(\n-                            tsi.lowValue(),\n-                            tsi.highValue(),\n-                            relabel(tsi.defaultTarget(), cob),\n-                            tsi.cases().stream().map(c ->\n-                                    SwitchCase.of(\n-                                            c.caseValue(),\n-                                            relabel(c.target(), cob))).toList());\n-                case LabelTarget lt ->\n-                    cob.labelBinding(\n-                            relabel(lt.label(), cob));\n-                case ExceptionCatch ec ->\n-                    cob.exceptionCatch(\n-                            relabel(ec.tryStart(), cob),\n-                            relabel(ec.tryEnd(), cob),\n-                            relabel(ec.handler(), cob),\n-                            ec.catchType());\n-                case LocalVariable lv ->\n-                    cob.localVariable(\n-                            lv.slot(),\n-                            lv.name().stringValue(),\n-                            lv.typeSymbol(),\n-                            relabel(lv.startScope(), cob),\n-                            relabel(lv.endScope(), cob));\n-                case LocalVariableType lvt ->\n-                    cob.localVariableType(\n-                            lvt.slot(),\n-                            lvt.name().stringValue(),\n-                            lvt.signatureSymbol(),\n-                            relabel(lvt.startScope(), cob),\n-                            relabel(lvt.endScope(), cob));\n-                case CharacterRange chr ->\n-                    cob.characterRange(\n-                            relabel(chr.startScope(), cob),\n-                            relabel(chr.endScope(), cob),\n-                            chr.characterRangeStart(),\n-                            chr.characterRangeEnd(),\n-                            chr.flags());\n-                default ->\n-                    cob.with(coe);\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeRelabeler.java","additions":9,"deletions":85,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n- *\n@@ -26,1 +25,0 @@\n-import java.util.AbstractCollection;\n@@ -28,4 +26,0 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n@@ -33,3 +27,0 @@\n-import java.util.function.Consumer;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n@@ -38,1 +29,0 @@\n-import jdk.internal.classfile.Opcode;\n@@ -40,1 +30,1 @@\n-import jdk.internal.classfile.instruction.*;\n+import jdk.internal.classfile.impl.CodeStackTrackerImpl;\n@@ -60,1 +50,1 @@\n-public sealed interface CodeStackTracker extends CodeTransform {\n+public sealed interface CodeStackTracker extends CodeTransform permits CodeStackTrackerImpl {\n@@ -63,1 +53,1 @@\n-     * Creates new instance of {@link CodeStackTracker} initialized with provided stack items\n+     * Creates new instance of {@link CodeStackTracker} initialized with provided stack items.\n@@ -75,1 +65,1 @@\n-      *\n+      * <p>\n@@ -87,1 +77,1 @@\n-      *\n+      * <p>\n@@ -94,280 +84,0 @@\n-\n-    final static class CodeStackTrackerImpl implements CodeStackTracker {\n-\n-        private static record Item(TypeKind type, Item next) {\n-        }\n-\n-        private final class Stack extends AbstractCollection<TypeKind> {\n-\n-            private Item top;\n-            private int count, realSize;\n-\n-            Stack(Item top, int count, int realSize) {\n-                this.top = top;\n-                this.count = count;\n-                this.realSize = realSize;\n-            }\n-\n-            @Override\n-            public Iterator<TypeKind> iterator() {\n-                return new Iterator<TypeKind>() {\n-                    Item i = top;\n-\n-                    @Override\n-                    public boolean hasNext() {\n-                        return i != null;\n-                    }\n-\n-                    @Override\n-                    public TypeKind next() {\n-                        if (i == null) {\n-                            throw new NoSuchElementException();\n-                        }\n-                        var t = i.type;\n-                        i = i.next;\n-                        return t;\n-                    }\n-                };\n-            }\n-\n-            @Override\n-            public int size() {\n-                return count;\n-            }\n-\n-            private void push(TypeKind type) {\n-                top = new Item(type, top);\n-                realSize += type.slotSize();\n-                count++;\n-                if (maxSize != null && realSize > maxSize) maxSize = realSize;\n-            }\n-\n-            private TypeKind pop() {\n-                var t = top.type;\n-                realSize -= t.slotSize();\n-                count--;\n-                top = top.next;\n-                return t;\n-            }\n-        }\n-\n-        private Stack stack = new Stack(null, 0, 0);\n-        private Integer maxSize = 0;\n-\n-        CodeStackTrackerImpl(TypeKind... initialStack) {\n-            for (int i = initialStack.length - 1; i >= 0; i--)\n-                push(initialStack[i]);\n-        }\n-\n-        @Override\n-        public Optional<Collection<TypeKind>> stack() {\n-            return Optional.ofNullable(fork());\n-        }\n-\n-        @Override\n-        public Optional<Integer> maxStackSize() {\n-            return Optional.ofNullable(maxSize);\n-        }\n-\n-        private final Map<Label, Stack> map = new HashMap<>();\n-\n-        private void push(TypeKind type) {\n-            if (stack != null) {\n-                if (type != TypeKind.VoidType) stack.push(type);\n-            } else {\n-                maxSize = null;\n-            }\n-        }\n-\n-        private void pop(int i) {\n-            if (stack != null) {\n-                while (i-- > 0) stack.pop();\n-            } else {\n-                maxSize = null;\n-            }\n-        }\n-\n-        private Stack fork() {\n-            return stack == null ? null : new Stack(stack.top, stack.count, stack.realSize);\n-        }\n-\n-        private void withStack(Consumer<Stack> c) {\n-            if (stack != null) c.accept(stack);\n-            else maxSize = null;\n-        }\n-\n-        @Override\n-        public void accept(CodeBuilder cb, CodeElement el) {\n-            cb.with(el);\n-            switch (el) {\n-                case ArrayLoadInstruction i -> {\n-                    pop(2);push(i.typeKind());\n-                }\n-                case ArrayStoreInstruction i ->\n-                    pop(3);\n-                case BranchInstruction i -> {\n-                    if (i.opcode() == Opcode.GOTO || i.opcode() == Opcode.GOTO_W) {\n-                        map.put(i.target(), stack);\n-                        stack = null;\n-                    } else {\n-                        pop(1);\n-                        map.put(i.target(), fork());\n-                    }\n-                }\n-                case ConstantInstruction i ->\n-                    push(i.typeKind());\n-                case ConvertInstruction i -> {\n-                    pop(1);push(i.toType());\n-                }\n-                case FieldInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case GETSTATIC ->\n-                            push(TypeKind.fromDescriptor(i.type().stringValue()));\n-                        case GETFIELD -> {\n-                            pop(1);push(TypeKind.fromDescriptor(i.type().stringValue()));\n-                        }\n-                        case PUTSTATIC ->\n-                            pop(1);\n-                        case PUTFIELD ->\n-                            pop(2);\n-                    }\n-                }\n-                case InvokeDynamicInstruction i -> {\n-                    var type = i.typeSymbol();\n-                    pop(type.parameterCount());\n-                    push(TypeKind.from(type.returnType()));\n-                }\n-                case InvokeInstruction i -> {\n-                    var type = i.typeSymbol();\n-                    pop(type.parameterCount());\n-                    if (i.opcode() != Opcode.INVOKESTATIC) pop(1);\n-                    push(TypeKind.from(type.returnType()));\n-                }\n-                case LoadInstruction i ->\n-                    push(i.typeKind());\n-                case StoreInstruction i ->\n-                    pop(1);\n-                case LookupSwitchInstruction i -> {\n-                    map.put(i.defaultTarget(), stack);\n-                    for (var c : i.cases()) map.put(c.target(), fork());\n-                    stack = null;\n-                }\n-                case MonitorInstruction i ->\n-                    pop(1);\n-                case NewMultiArrayInstruction i -> {\n-                    pop(i.dimensions());push(TypeKind.ReferenceType);\n-                }\n-                case NewObjectInstruction i ->\n-                    push(TypeKind.ReferenceType);\n-                case NewPrimitiveArrayInstruction i -> {\n-                    pop(1);push(TypeKind.ReferenceType);\n-                }\n-                case NewReferenceArrayInstruction i -> {\n-                    pop(1);push(TypeKind.ReferenceType);\n-                }\n-                case NopInstruction i -> {}\n-                case OperatorInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> pop(1);\n-                        default -> pop(2);\n-                    }\n-                    push(i.typeKind());\n-                }\n-                case ReturnInstruction i ->\n-                    stack = null;\n-                case StackInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case POP -> pop(1);\n-                        case POP2 -> withStack(s -> {\n-                            if (s.pop().slotSize() == 1) s.pop();\n-                        });\n-                        case DUP ->  withStack(s -> {\n-                            var v = s.pop();s.push(v);s.push(v);\n-                        });\n-                        case DUP2 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            if (v1.slotSize() == 1) {\n-                                var v2 = s.pop();\n-                                s.push(v2);s.push(v1);\n-                                s.push(v2);s.push(v1);\n-                            } else {\n-                                s.push(v1);s.push(v1);\n-                            }\n-                        });\n-                        case DUP_X1 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            s.push(v1);s.push(v2);s.push(v1);\n-                        });\n-                        case DUP_X2 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            if (v2.slotSize() == 1) {\n-                                var v3 = s.pop();\n-                                s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                            } else {\n-                                s.push(v1);s.push(v2);s.push(v1);\n-                            }\n-                        });\n-                        case DUP2_X1 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            if (v1.slotSize() == 1) {\n-                                var v3 = s.pop();\n-                                s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                            } else {\n-                                s.push(v1);s.push(v2);s.push(v1);\n-                            }\n-                        });\n-                        case DUP2_X2 -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            if (v1.slotSize() == 1) {\n-                                var v3 = s.pop();\n-                                if (v3.slotSize() == 1) {\n-                                    var v4 = s.pop();\n-                                    s.push(v2);s.push(v1);s.push(v4);s.push(v3);s.push(v2);s.push(v1);\n-                                } else {\n-                                    s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                                }\n-                            } else {\n-                                if (v2.slotSize() == 1) {\n-                                    var v3 = s.pop();\n-                                    s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n-                                } else {\n-                                    s.push(v1);s.push(v2);s.push(v1);\n-                                }\n-                            }\n-                        });\n-                        case SWAP -> withStack(s -> {\n-                            var v1 = s.pop();\n-                            var v2 = s.pop();\n-                            s.push(v1);s.push(v2);\n-                        });\n-                    }\n-                }\n-                case TableSwitchInstruction i -> {\n-                    map.put(i.defaultTarget(), stack);\n-                    for (var c : i.cases()) map.put(c.target(), fork());\n-                    stack = null;\n-                }\n-                case ThrowInstruction i ->\n-                    stack = null;\n-                case TypeCheckInstruction i -> {\n-                    switch (i.opcode()) {\n-                        case CHECKCAST -> {\n-                            pop(1);push(TypeKind.ReferenceType);\n-                        }\n-                        case INSTANCEOF -> {\n-                            pop(1);push(TypeKind.IntType);\n-                        }\n-                    }\n-                }\n-                case ExceptionCatch i ->\n-                    map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n-                case LabelTarget i ->\n-                    stack = map.getOrDefault(i.label(), stack);\n-                default -> {}\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeStackTracker.java","additions":6,"deletions":296,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.impl.Util;\n@@ -53,1 +53,1 @@\n-                                           ClassDesc.ofDescriptor(type().stringValue()),\n+                                           Util.fieldTypeSymbol(nameAndType()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry.ClassEntryImpl;\n+import jdk.internal.classfile.impl.AbstractPoolEntry.NameAndTypeEntryImpl;\n@@ -163,1 +165,3 @@\n-        return classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ClassEntryImpl ret = (ClassEntryImpl)classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ret.sym = classDesc;\n+        return ret;\n@@ -236,1 +240,3 @@\n-        return nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        var ret = (NameAndTypeEntryImpl)nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        ret.typeSym = type;\n+        return ret;\n@@ -249,1 +255,3 @@\n-        return nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        var ret = (NameAndTypeEntryImpl)nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        ret.typeSym = type;\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -32,0 +31,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -46,1 +46,1 @@\n-                                      MethodTypeDesc.ofDescriptor(type().stringValue()),\n+                                      Util.methodTypeSymbol(nameAndType()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/InvokeDynamicEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,3 +53,1 @@\n-    default MethodTypeDesc asSymbol() {\n-        return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n-    }\n+    MethodTypeDesc asSymbol();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodTypeEntry.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-            return Util.parameterSlots(type().stringValue());\n+            return Util.parameterSlots(Util.methodTypeSymbol(method().nameAndType()));\n@@ -1062,1 +1062,1 @@\n-                   ? Util.parameterSlots(methodEntry.nameAndType().type().stringValue()) + 1\n+                   ? Util.parameterSlots(Util.methodTypeSymbol(methodEntry.nameAndType())) + 1\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.TypeDescriptor;\n@@ -166,0 +167,4 @@\n+            this(cpm, index, s, hashString(s.hashCode()));\n+        }\n+\n+        Utf8EntryImpl(ConstantPool cpm, int index, String s, int hash) {\n@@ -173,1 +178,1 @@\n-            this.hash = hashString(s.hashCode());\n+            this.hash = hash;\n@@ -559,0 +564,2 @@\n+        public ClassDesc sym = null;\n+\n@@ -565,1 +572,7 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                ClassEntryImpl ret = (ClassEntryImpl)cp.classEntry(ref1);\n+                ret.sym = sym;\n+                return ret;\n+            }\n@@ -570,1 +583,5 @@\n-            return Util.toClassDesc(asInternalName());\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym;\n+            }\n+            return this.sym = Util.toClassDesc(asInternalName());\n@@ -640,0 +657,2 @@\n+        public TypeDescriptor typeSym = null;\n+\n@@ -654,0 +673,16 @@\n+        public ClassDesc fieldTypeSymbol() {\n+            if (typeSym instanceof ClassDesc cd) {\n+                return cd;\n+            } else {\n+                return (ClassDesc)(typeSym = ClassDesc.ofDescriptor(ref2.stringValue()));\n+            }\n+        }\n+\n+        public MethodTypeDesc methodTypeSymbol() {\n+            if (typeSym instanceof MethodTypeDesc mtd) {\n+                return mtd;\n+            } else {\n+                return (MethodTypeDesc)(typeSym = MethodTypeDesc.ofDescriptor(ref2.stringValue()));\n+            }\n+        }\n+\n@@ -656,1 +691,7 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.nameAndTypeEntry(ref1, ref2);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                var ret = (NameAndTypeEntryImpl)cp.nameAndTypeEntry(ref1, ref2);\n+                ret.typeSym = typeSym;\n+                return ret;\n+            }\n@@ -921,0 +962,2 @@\n+        public MethodTypeDesc sym = null;\n+\n@@ -932,1 +975,16 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodTypeEntry(ref1);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                var ret = (MethodTypeEntryImpl)cp.methodTypeEntry(ref1);\n+                ret.sym = sym;\n+                return ret;\n+            }\n+        }\n+\n+        @Override\n+        public MethodTypeDesc asSymbol() {\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym;\n+            }\n+            return this.sym = MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":63,"deletions":5,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        this.maxLocals = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodType().stringValue());\n+        this.maxLocals = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -54,0 +55,1 @@\n+    MethodTypeDesc mDesc;\n@@ -94,0 +96,12 @@\n+    @Override\n+    public MethodTypeDesc methodTypeSymbol() {\n+        if (mDesc == null) {\n+            if (original instanceof MethodInfo mi) {\n+                mDesc = mi.methodTypeSymbol();\n+            } else {\n+                mDesc = MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+            }\n+        }\n+        return mDesc;\n+    }\n+\n@@ -102,1 +116,1 @@\n-            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodTypeSymbol());\n@@ -161,0 +175,5 @@\n+        @Override\n+        public MethodTypeDesc methodTypeSymbol() {\n+            return BufferedMethodBuilder.this.methodTypeSymbol();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.FieldTransform;\n+import jdk.internal.classfile.Interfaces;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.Superclass;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleProvideInfo;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public record ClassRemapperImpl(Function<ClassDesc, ClassDesc> mapFunction) implements ClassRemapper {\n+\n+    @Override\n+    public void accept(ClassBuilder clb, ClassElement cle) {\n+        switch (cle) {\n+            case FieldModel fm ->\n+                clb.withField(fm.fieldName().stringValue(), map(\n+                        fm.fieldTypeSymbol()), fb ->\n+                                fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n+            case MethodModel mm ->\n+                clb.withMethod(mm.methodName().stringValue(), mapMethodDesc(\n+                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n+                                mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n+            case Superclass sc ->\n+                clb.withSuperclass(map(sc.superclassEntry().asSymbol()));\n+            case Interfaces ins ->\n+                clb.withInterfaceSymbols(Util.mappedList(ins.interfaces(), in ->\n+                        map(in.asSymbol())));\n+            case SignatureAttribute sa ->\n+                clb.with(SignatureAttribute.of(mapClassSignature(sa.asClassSignature())));\n+            case InnerClassesAttribute ica ->\n+                clb.with(InnerClassesAttribute.of(ica.classes().stream().map(ici ->\n+                        InnerClassInfo.of(map(ici.innerClass().asSymbol()),\n+                                ici.outerClass().map(oc -> map(oc.asSymbol())),\n+                                ici.innerName().map(Utf8Entry::stringValue),\n+                                ici.flagsMask())).toList()));\n+            case EnclosingMethodAttribute ema ->\n+                clb.with(EnclosingMethodAttribute.of(map(ema.enclosingClass().asSymbol()),\n+                        ema.enclosingMethodName().map(Utf8Entry::stringValue),\n+                        ema.enclosingMethodTypeSymbol().map(this::mapMethodDesc)));\n+            case RecordAttribute ra ->\n+                clb.with(RecordAttribute.of(ra.components().stream()\n+                        .map(this::mapRecordComponent).toList()));\n+            case ModuleAttribute ma ->\n+                clb.with(ModuleAttribute.of(ma.moduleName(), ma.moduleFlagsMask(),\n+                        ma.moduleVersion().orElse(null),\n+                        ma.requires(), ma.exports(), ma.opens(),\n+                        ma.uses().stream().map(ce ->\n+                                clb.constantPool().classEntry(map(ce.asSymbol()))).toList(),\n+                        ma.provides().stream().map(mp ->\n+                                ModuleProvideInfo.of(map(mp.provides().asSymbol()),\n+                                        mp.providesWith().stream().map(pw ->\n+                                                map(pw.asSymbol())).toList())).toList()));\n+            case NestHostAttribute nha ->\n+                clb.with(NestHostAttribute.of(map(nha.nestHost().asSymbol())));\n+            case NestMembersAttribute nma ->\n+                clb.with(NestMembersAttribute.ofSymbols(nma.nestMembers().stream()\n+                        .map(nm -> map(nm.asSymbol())).toList()));\n+            case PermittedSubclassesAttribute psa ->\n+                clb.with(PermittedSubclassesAttribute.ofSymbols(\n+                        psa.permittedSubclasses().stream().map(ps ->\n+                                map(ps.asSymbol())).toList()));\n+            case RuntimeVisibleAnnotationsAttribute aa ->\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        mapAnnotations(aa.annotations())));\n+            case RuntimeInvisibleAnnotationsAttribute aa ->\n+                clb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                        mapAnnotations(aa.annotations())));\n+            case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                clb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                        mapTypeAnnotations(aa.annotations())));\n+            case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                clb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                        mapTypeAnnotations(aa.annotations())));\n+            default ->\n+                clb.with(cle);\n+        }\n+    }\n+\n+    @Override\n+    public FieldTransform asFieldTransform() {\n+        return (FieldBuilder fb, FieldElement fe) -> {\n+            switch (fe) {\n+                case SignatureAttribute sa ->\n+                    fb.with(SignatureAttribute.of(\n+                            mapSignature(sa.asTypeSignature())));\n+                case RuntimeVisibleAnnotationsAttribute aa ->\n+                    fb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeInvisibleAnnotationsAttribute aa ->\n+                    fb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    fb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    fb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    fb.with(fe);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public MethodTransform asMethodTransform() {\n+        return (MethodBuilder mb, MethodElement me) -> {\n+            switch (me) {\n+                case AnnotationDefaultAttribute ada ->\n+                    mb.with(AnnotationDefaultAttribute.of(\n+                            mapAnnotationValue(ada.defaultValue())));\n+                case CodeModel com ->\n+                    mb.transformCode(com, asCodeTransform());\n+                case ExceptionsAttribute ea ->\n+                    mb.with(ExceptionsAttribute.ofSymbols(\n+                            ea.exceptions().stream().map(ce ->\n+                                    map(ce.asSymbol())).toList()));\n+                case SignatureAttribute sa ->\n+                    mb.with(SignatureAttribute.of(\n+                            mapMethodSignature(sa.asMethodSignature())));\n+                case RuntimeVisibleAnnotationsAttribute aa ->\n+                    mb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeInvisibleAnnotationsAttribute aa ->\n+                    mb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeVisibleParameterAnnotationsAttribute paa ->\n+                    mb.with(RuntimeVisibleParameterAnnotationsAttribute.of(\n+                            paa.parameterAnnotations().stream()\n+                                    .map(this::mapAnnotations).toList()));\n+                case RuntimeInvisibleParameterAnnotationsAttribute paa ->\n+                    mb.with(RuntimeInvisibleParameterAnnotationsAttribute.of(\n+                            paa.parameterAnnotations().stream()\n+                                    .map(this::mapAnnotations).toList()));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    mb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    mb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    mb.with(me);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public CodeTransform asCodeTransform() {\n+        return (CodeBuilder cob, CodeElement coe) -> {\n+            switch (coe) {\n+                case FieldInstruction fai ->\n+                    cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n+                            fai.name().stringValue(), map(fai.typeSymbol()));\n+                case InvokeInstruction ii ->\n+                    cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n+                            ii.name().stringValue(), mapMethodDesc(ii.typeSymbol()),\n+                            ii.isInterface());\n+                case InvokeDynamicInstruction idi ->\n+                    cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n+                            idi.bootstrapMethod(), idi.name().stringValue(),\n+                            mapMethodDesc(idi.typeSymbol()),\n+                            idi.bootstrapArgs().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new)));\n+                case NewObjectInstruction c ->\n+                    cob.newObjectInstruction(map(c.className().asSymbol()));\n+                case NewReferenceArrayInstruction c ->\n+                    cob.anewarray(map(c.componentType().asSymbol()));\n+                case NewMultiArrayInstruction c ->\n+                    cob.multianewarray(map(c.arrayType().asSymbol()), c.dimensions());\n+                case TypeCheckInstruction c ->\n+                    cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n+                case ExceptionCatch c ->\n+                    cob.exceptionCatch(c.tryStart(), c.tryEnd(), c.handler(),c.catchType()\n+                            .map(d -> TemporaryConstantPool.INSTANCE.classEntry(map(d.asSymbol()))));\n+                case LocalVariable c ->\n+                    cob.localVariable(c.slot(), c.name().stringValue(), map(c.typeSymbol()),\n+                            c.startScope(), c.endScope());\n+                case LocalVariableType c ->\n+                    cob.localVariableType(c.slot(), c.name().stringValue(),\n+                            mapSignature(c.signatureSymbol()), c.startScope(), c.endScope());\n+                case LoadConstantInstruction ldc ->\n+                    cob.constantInstruction(ldc.opcode(),\n+                            mapConstantValue(ldc.constantValue()));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    cob.with(coe);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public ClassDesc map(ClassDesc desc) {\n+        if (desc == null) return null;\n+        if (desc.isArray()) return map(desc.componentType()).arrayType();\n+        if (desc.isPrimitive()) return desc;\n+        return mapFunction.apply(desc);\n+    }\n+\n+    MethodTypeDesc mapMethodDesc(MethodTypeDesc desc) {\n+        return MethodTypeDesc.of(map(desc.returnType()),\n+                desc.parameterList().stream().map(this::map).toArray(ClassDesc[]::new));\n+    }\n+\n+    ClassSignature mapClassSignature(ClassSignature signature) {\n+        return ClassSignature.of(mapTypeParams(signature.typeParameters()),\n+                mapSignature(signature.superclassSignature()),\n+                signature.superinterfaceSignatures().stream()\n+                        .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n+    }\n+\n+    MethodSignature mapMethodSignature(MethodSignature signature) {\n+        return MethodSignature.of(mapTypeParams(signature.typeParameters()),\n+                signature.throwableSignatures().stream().map(this::mapSignature).toList(),\n+                mapSignature(signature.result()),\n+                signature.arguments().stream()\n+                        .map(this::mapSignature).toArray(Signature[]::new));\n+    }\n+\n+    RecordComponentInfo mapRecordComponent(RecordComponentInfo component) {\n+        return RecordComponentInfo.of(component.name().stringValue(),\n+                map(component.descriptorSymbol()),\n+                component.attributes().stream().map(atr ->\n+                    switch (atr) {\n+                        case SignatureAttribute sa ->\n+                            SignatureAttribute.of(\n+                                    mapSignature(sa.asTypeSignature()));\n+                        case RuntimeVisibleAnnotationsAttribute aa ->\n+                            RuntimeVisibleAnnotationsAttribute.of(\n+                                    mapAnnotations(aa.annotations()));\n+                        case RuntimeInvisibleAnnotationsAttribute aa ->\n+                            RuntimeInvisibleAnnotationsAttribute.of(\n+                                    mapAnnotations(aa.annotations()));\n+                        case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                            RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                    mapTypeAnnotations(aa.annotations()));\n+                        case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                            RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                    mapTypeAnnotations(aa.annotations()));\n+                        default -> atr;\n+                    }).toList());\n+    }\n+\n+    DirectMethodHandleDesc mapDirectMethodHandle(DirectMethodHandleDesc dmhd) {\n+        return switch (dmhd.kind()) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER ->\n+                MethodHandleDesc.ofField(dmhd.kind(), map(dmhd.owner()),\n+                        dmhd.methodName(),\n+                        map(ClassDesc.ofDescriptor(dmhd.lookupDescriptor())));\n+            default ->\n+                MethodHandleDesc.ofMethod(dmhd.kind(), map(dmhd.owner()),\n+                        dmhd.methodName(),\n+                        mapMethodDesc(MethodTypeDesc.ofDescriptor(dmhd.lookupDescriptor())));\n+        };\n+    }\n+\n+    ConstantDesc mapConstantValue(ConstantDesc value) {\n+        return switch (value) {\n+            case ClassDesc cd ->\n+                map(cd);\n+            case DynamicConstantDesc<?> dcd ->\n+                mapDynamicConstant(dcd);\n+            case DirectMethodHandleDesc dmhd ->\n+                mapDirectMethodHandle(dmhd);\n+            case MethodTypeDesc mtd ->\n+                mapMethodDesc(mtd);\n+            default -> value;\n+        };\n+    }\n+\n+    DynamicConstantDesc<?> mapDynamicConstant(DynamicConstantDesc<?> dcd) {\n+        return DynamicConstantDesc.ofNamed(mapDirectMethodHandle(dcd.bootstrapMethod()),\n+                dcd.constantName(),\n+                map(dcd.constantType()),\n+                dcd.bootstrapArgsList().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <S extends Signature> S mapSignature(S signature) {\n+        return (S) switch (signature) {\n+            case Signature.ArrayTypeSig ats ->\n+                Signature.ArrayTypeSig.of(mapSignature(ats.componentSignature()));\n+            case Signature.ClassTypeSig cts ->\n+                Signature.ClassTypeSig.of(\n+                        cts.outerType().map(this::mapSignature).orElse(null),\n+                        map(cts.classDesc()),\n+                        cts.typeArgs().stream()\n+                                .map(ta -> Signature.TypeArg.of(\n+                                        ta.wildcardIndicator(),\n+                                        ta.boundType().map(this::mapSignature)))\n+                                .toArray(Signature.TypeArg[]::new));\n+            default -> signature;\n+        };\n+    }\n+\n+    List<Annotation> mapAnnotations(List<Annotation> annotations) {\n+        return annotations.stream().map(this::mapAnnotation).toList();\n+    }\n+\n+    Annotation mapAnnotation(Annotation a) {\n+        return Annotation.of(map(a.classSymbol()), a.elements().stream().map(el ->\n+                AnnotationElement.of(el.name(), mapAnnotationValue(el.value()))).toList());\n+    }\n+\n+    AnnotationValue mapAnnotationValue(AnnotationValue val) {\n+        return switch (val) {\n+            case AnnotationValue.OfAnnotation oa ->\n+                AnnotationValue.ofAnnotation(mapAnnotation(oa.annotation()));\n+            case AnnotationValue.OfArray oa ->\n+                AnnotationValue.ofArray(oa.values().stream().map(this::mapAnnotationValue).toList());\n+            case AnnotationValue.OfConstant oc -> oc;\n+            case AnnotationValue.OfClass oc ->\n+                AnnotationValue.ofClass(map(oc.classSymbol()));\n+            case AnnotationValue.OfEnum oe ->\n+                AnnotationValue.ofEnum(map(oe.classSymbol()), oe.constantName().stringValue());\n+        };\n+    }\n+\n+    List<TypeAnnotation> mapTypeAnnotations(List<TypeAnnotation> typeAnnotations) {\n+        return typeAnnotations.stream().map(a -> TypeAnnotation.of(a.targetInfo(),\n+                a.targetPath(), map(a.classSymbol()),\n+                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n+                        mapAnnotationValue(el.value()))).toList())).toList();\n+    }\n+\n+    List<Signature.TypeParam> mapTypeParams(List<Signature.TypeParam> typeParams) {\n+        return typeParams.stream().map(tp -> Signature.TypeParam.of(tp.identifier(),\n+                tp.classBound().map(this::mapSignature),\n+                tp.interfaceBounds().stream()\n+                        .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new))).toList();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+\n+import java.util.Arrays;\n+\n+public final class CodeLocalsShifterImpl implements CodeLocalsShifter {\n+\n+    private int[] locals = new int[0];\n+    private final int fixed;\n+\n+    public CodeLocalsShifterImpl(int fixed) {\n+        this.fixed = fixed;\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        switch (coe) {\n+            case LoadInstruction li ->\n+                cob.loadInstruction(\n+                        li.typeKind(),\n+                        shift(cob, li.slot(), li.typeKind()));\n+            case StoreInstruction si ->\n+                cob.storeInstruction(\n+                        si.typeKind(),\n+                        shift(cob, si.slot(), si.typeKind()));\n+            case IncrementInstruction ii ->\n+                cob.incrementInstruction(\n+                        shift(cob, ii.slot(), TypeKind.IntType),\n+                        ii.constant());\n+            case LocalVariable lv ->\n+                cob.localVariable(\n+                        shift(cob, lv.slot(), TypeKind.fromDescriptor(lv.type().stringValue())),\n+                        lv.name(),\n+                        lv.type(),\n+                        lv.startScope(),\n+                        lv.endScope());\n+            case LocalVariableType lvt ->\n+                cob.localVariableType(\n+                        shift(cob, lvt.slot(),\n+                                (lvt.signatureSymbol() instanceof Signature.BaseTypeSig bsig)\n+                                        ? TypeKind.fromDescriptor(bsig.signatureString())\n+                                        : TypeKind.ReferenceType),\n+                        lvt.name(),\n+                        lvt.signature(),\n+                        lvt.startScope(),\n+                        lvt.endScope());\n+            default -> cob.with(coe);\n+        }\n+    }\n+\n+    private int shift(CodeBuilder cob, int slot, TypeKind tk) {\n+        if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n+        if (slot >= fixed) {\n+            int key = 2*slot - fixed + tk.slotSize() - 1;\n+            if (key >= locals.length) locals = Arrays.copyOf(locals, key + 20);\n+            slot = locals[key] - 1;\n+            if (slot < 0) {\n+                slot = cob.allocateLocal(tk);\n+                locals[key] = slot + 1;\n+                if (tk.slotSize() == 2) locals[key - 1] = slot + 1;\n+            }\n+        }\n+        return slot;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.CharacterRange;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.SwitchCase;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+\n+import java.util.function.BiFunction;\n+\n+public record CodeRelabelerImpl(BiFunction<Label, CodeBuilder, Label> mapFunction) implements CodeRelabeler {\n+\n+    @Override\n+    public Label relabel(Label label, CodeBuilder cob) {\n+        return mapFunction.apply(label, cob);\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        switch (coe) {\n+            case BranchInstruction bi ->\n+                cob.branchInstruction(\n+                        bi.opcode(),\n+                        relabel(bi.target(), cob));\n+            case LookupSwitchInstruction lsi ->\n+                cob.lookupSwitchInstruction(\n+                        relabel(lsi.defaultTarget(), cob),\n+                        lsi.cases().stream().map(c ->\n+                                SwitchCase.of(\n+                                        c.caseValue(),\n+                                        relabel(c.target(), cob))).toList());\n+            case TableSwitchInstruction tsi ->\n+                cob.tableSwitchInstruction(\n+                        tsi.lowValue(),\n+                        tsi.highValue(),\n+                        relabel(tsi.defaultTarget(), cob),\n+                        tsi.cases().stream().map(c ->\n+                                SwitchCase.of(\n+                                        c.caseValue(),\n+                                        relabel(c.target(), cob))).toList());\n+            case LabelTarget lt ->\n+                cob.labelBinding(\n+                        relabel(lt.label(), cob));\n+            case ExceptionCatch ec ->\n+                cob.exceptionCatch(\n+                        relabel(ec.tryStart(), cob),\n+                        relabel(ec.tryEnd(), cob),\n+                        relabel(ec.handler(), cob),\n+                        ec.catchType());\n+            case LocalVariable lv ->\n+                cob.localVariable(\n+                        lv.slot(),\n+                        lv.name().stringValue(),\n+                        lv.typeSymbol(),\n+                        relabel(lv.startScope(), cob),\n+                        relabel(lv.endScope(), cob));\n+            case LocalVariableType lvt ->\n+                cob.localVariableType(\n+                        lvt.slot(),\n+                        lvt.name().stringValue(),\n+                        lvt.signatureSymbol(),\n+                        relabel(lvt.startScope(), cob),\n+                        relabel(lvt.endScope(), cob));\n+            case CharacterRange chr ->\n+                cob.characterRange(\n+                        relabel(chr.startScope(), cob),\n+                        relabel(chr.endScope(), cob),\n+                        chr.characterRangeStart(),\n+                        chr.characterRangeEnd(),\n+                        chr.flags());\n+            default ->\n+                cob.with(coe);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.components.CodeStackTracker;\n+import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n+import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.ConvertInstruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.MonitorInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StackInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.instruction.ThrowInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+\n+import java.util.AbstractCollection;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public final class CodeStackTrackerImpl implements CodeStackTracker {\n+\n+    private static record Item(TypeKind type, Item next) {\n+    }\n+\n+    private final class Stack extends AbstractCollection<TypeKind> {\n+\n+        private Item top;\n+        private int count, realSize;\n+\n+        Stack(Item top, int count, int realSize) {\n+            this.top = top;\n+            this.count = count;\n+            this.realSize = realSize;\n+        }\n+\n+        @Override\n+        public Iterator<TypeKind> iterator() {\n+            return new Iterator<TypeKind>() {\n+                Item i = top;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return i != null;\n+                }\n+\n+                @Override\n+                public TypeKind next() {\n+                    if (i == null) {\n+                        throw new NoSuchElementException();\n+                    }\n+                    var t = i.type;\n+                    i = i.next;\n+                    return t;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int size() {\n+            return count;\n+        }\n+\n+        private void push(TypeKind type) {\n+            top = new Item(type, top);\n+            realSize += type.slotSize();\n+            count++;\n+            if (maxSize != null && realSize > maxSize) maxSize = realSize;\n+        }\n+\n+        private TypeKind pop() {\n+            var t = top.type;\n+            realSize -= t.slotSize();\n+            count--;\n+            top = top.next;\n+            return t;\n+        }\n+    }\n+\n+    private Stack stack = new Stack(null, 0, 0);\n+    private Integer maxSize = 0;\n+\n+    public CodeStackTrackerImpl(TypeKind... initialStack) {\n+        for (int i = initialStack.length - 1; i >= 0; i--)\n+            push(initialStack[i]);\n+    }\n+\n+    @Override\n+    public Optional<Collection<TypeKind>> stack() {\n+        return Optional.ofNullable(fork());\n+    }\n+\n+    @Override\n+    public Optional<Integer> maxStackSize() {\n+        return Optional.ofNullable(maxSize);\n+    }\n+\n+    private final Map<Label, Stack> map = new HashMap<>();\n+\n+    private void push(TypeKind type) {\n+        if (stack != null) {\n+            if (type != TypeKind.VoidType) stack.push(type);\n+        } else {\n+            maxSize = null;\n+        }\n+    }\n+\n+    private void pop(int i) {\n+        if (stack != null) {\n+            while (i-- > 0) stack.pop();\n+        } else {\n+            maxSize = null;\n+        }\n+    }\n+\n+    private Stack fork() {\n+        return stack == null ? null : new Stack(stack.top, stack.count, stack.realSize);\n+    }\n+\n+    private void withStack(Consumer<Stack> c) {\n+        if (stack != null) c.accept(stack);\n+        else maxSize = null;\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cb, CodeElement el) {\n+        cb.with(el);\n+        switch (el) {\n+            case ArrayLoadInstruction i -> {\n+                pop(2);push(i.typeKind());\n+            }\n+            case ArrayStoreInstruction i ->\n+                pop(3);\n+            case BranchInstruction i -> {\n+                if (i.opcode() == Opcode.GOTO || i.opcode() == Opcode.GOTO_W) {\n+                    map.put(i.target(), stack);\n+                    stack = null;\n+                } else {\n+                    pop(1);\n+                    map.put(i.target(), fork());\n+                }\n+            }\n+            case ConstantInstruction i ->\n+                push(i.typeKind());\n+            case ConvertInstruction i -> {\n+                pop(1);push(i.toType());\n+            }\n+            case FieldInstruction i -> {\n+                switch (i.opcode()) {\n+                    case GETSTATIC ->\n+                        push(TypeKind.fromDescriptor(i.type().stringValue()));\n+                    case GETFIELD -> {\n+                        pop(1);push(TypeKind.fromDescriptor(i.type().stringValue()));\n+                    }\n+                    case PUTSTATIC ->\n+                        pop(1);\n+                    case PUTFIELD ->\n+                        pop(2);\n+                }\n+            }\n+            case InvokeDynamicInstruction i -> {\n+                var type = i.typeSymbol();\n+                pop(type.parameterCount());\n+                push(TypeKind.from(type.returnType()));\n+            }\n+            case InvokeInstruction i -> {\n+                var type = i.typeSymbol();\n+                pop(type.parameterCount());\n+                if (i.opcode() != Opcode.INVOKESTATIC) pop(1);\n+                push(TypeKind.from(type.returnType()));\n+            }\n+            case LoadInstruction i ->\n+                push(i.typeKind());\n+            case StoreInstruction i ->\n+                pop(1);\n+            case LookupSwitchInstruction i -> {\n+                map.put(i.defaultTarget(), stack);\n+                for (var c : i.cases()) map.put(c.target(), fork());\n+                stack = null;\n+            }\n+            case MonitorInstruction i ->\n+                pop(1);\n+            case NewMultiArrayInstruction i -> {\n+                pop(i.dimensions());push(TypeKind.ReferenceType);\n+            }\n+            case NewObjectInstruction i ->\n+                push(TypeKind.ReferenceType);\n+            case NewPrimitiveArrayInstruction i -> {\n+                pop(1);push(TypeKind.ReferenceType);\n+            }\n+            case NewReferenceArrayInstruction i -> {\n+                pop(1);push(TypeKind.ReferenceType);\n+            }\n+            case NopInstruction i -> {}\n+            case OperatorInstruction i -> {\n+                switch (i.opcode()) {\n+                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> pop(1);\n+                    default -> pop(2);\n+                }\n+                push(i.typeKind());\n+            }\n+            case ReturnInstruction i ->\n+                stack = null;\n+            case StackInstruction i -> {\n+                switch (i.opcode()) {\n+                    case POP -> pop(1);\n+                    case POP2 -> withStack(s -> {\n+                        if (s.pop().slotSize() == 1) s.pop();\n+                    });\n+                    case DUP ->  withStack(s -> {\n+                        var v = s.pop();s.push(v);s.push(v);\n+                    });\n+                    case DUP2 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        if (v1.slotSize() == 1) {\n+                            var v2 = s.pop();\n+                            s.push(v2);s.push(v1);\n+                            s.push(v2);s.push(v1);\n+                        } else {\n+                            s.push(v1);s.push(v1);\n+                        }\n+                    });\n+                    case DUP_X1 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        s.push(v1);s.push(v2);s.push(v1);\n+                    });\n+                    case DUP_X2 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        if (v2.slotSize() == 1) {\n+                            var v3 = s.pop();\n+                            s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                        } else {\n+                            s.push(v1);s.push(v2);s.push(v1);\n+                        }\n+                    });\n+                    case DUP2_X1 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        if (v1.slotSize() == 1) {\n+                            var v3 = s.pop();\n+                            s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                        } else {\n+                            s.push(v1);s.push(v2);s.push(v1);\n+                        }\n+                    });\n+                    case DUP2_X2 -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        if (v1.slotSize() == 1) {\n+                            var v3 = s.pop();\n+                            if (v3.slotSize() == 1) {\n+                                var v4 = s.pop();\n+                                s.push(v2);s.push(v1);s.push(v4);s.push(v3);s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                            }\n+                        } else {\n+                            if (v2.slotSize() == 1) {\n+                                var v3 = s.pop();\n+                                s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v1);s.push(v2);s.push(v1);\n+                            }\n+                        }\n+                    });\n+                    case SWAP -> withStack(s -> {\n+                        var v1 = s.pop();\n+                        var v2 = s.pop();\n+                        s.push(v1);s.push(v2);\n+                    });\n+                }\n+            }\n+            case TableSwitchInstruction i -> {\n+                map.put(i.defaultTarget(), stack);\n+                for (var c : i.cases()) map.put(c.target(), fork());\n+                stack = null;\n+            }\n+            case ThrowInstruction i ->\n+                stack = null;\n+            case TypeCheckInstruction i -> {\n+                switch (i.opcode()) {\n+                    case CHECKCAST -> {\n+                        pop(1);push(TypeKind.ReferenceType);\n+                    }\n+                    case INSTANCEOF -> {\n+                        pop(1);push(TypeKind.IntType);\n+                    }\n+                }\n+            }\n+            case ExceptionCatch i ->\n+                map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n+            case LabelTarget i ->\n+                stack = map.getOrDefault(i.label(), stack);\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -133,1 +133,1 @@\n-        this.topLocal = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodType().stringValue());\n+        this.topLocal = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -49,0 +50,1 @@\n+    MethodTypeDesc mDesc;\n@@ -80,0 +82,12 @@\n+    @Override\n+    public MethodTypeDesc methodTypeSymbol() {\n+        if (mDesc == null) {\n+            if (original instanceof MethodInfo mi) {\n+                mDesc = mi.methodTypeSymbol();\n+            } else {\n+                mDesc = MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+            }\n+        }\n+        return mDesc;\n+    }\n+\n@@ -88,1 +102,1 @@\n-            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,0 +43,1 @@\n+    private MethodTypeDesc mDesc;\n@@ -73,0 +75,8 @@\n+    @Override\n+    public MethodTypeDesc methodTypeSymbol() {\n+        if (mDesc == null) {\n+            mDesc = MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+        }\n+        return mDesc;\n+    }\n+\n@@ -81,1 +91,1 @@\n-            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +35,1 @@\n+    MethodTypeDesc methodTypeSymbol();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+        this.doneFullScan = true;\n@@ -383,2 +384,3 @@\n-        var ce = tryFindUtf8(AbstractPoolEntry.hashString(s.hashCode()), s);\n-        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s)) : ce;\n+        int hash = AbstractPoolEntry.hashString(s.hashCode());\n+        var ce = tryFindUtf8(hash, s);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, hash)) : ce;\n@@ -462,1 +464,3 @@\n-        return methodTypeEntry(utf8Entry(descriptor.descriptorString()));\n+        var ret = (AbstractPoolEntry.MethodTypeEntryImpl)methodTypeEntry(utf8Entry(descriptor.descriptorString()));\n+        ret.sym = descriptor;\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                dcb.methodInfo.methodTypeSymbol(),\n@@ -109,1 +109,1 @@\n-            maxLocals += TypeKind.from(cd).slotSize();\n+            maxLocals += Util.slotSize(cd);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                method.methodType().stringValue(),\n+                method.methodTypeSymbol(),\n@@ -70,2 +70,1 @@\n-    public static List<VerificationTypeInfo> initFrameLocals(ClassEntry thisClass, String methodName, String methodType, boolean isStatic) {\n-        var mdesc = MethodTypeDesc.ofDescriptor(methodType);\n+    public static List<VerificationTypeInfo> initFrameLocals(ClassEntry thisClass, String methodName, MethodTypeDesc methodType, boolean isStatic) {\n@@ -75,1 +74,1 @@\n-            vtis = new VerificationTypeInfo[mdesc.parameterCount() + 1];\n+            vtis = new VerificationTypeInfo[methodType.parameterCount() + 1];\n@@ -82,1 +81,1 @@\n-            vtis = new VerificationTypeInfo[mdesc.parameterCount()];\n+            vtis = new VerificationTypeInfo[methodType.parameterCount()];\n@@ -84,7 +83,7 @@\n-        for(var arg : mdesc.parameterList()) {\n-            vtis[i++] = switch (arg.descriptorString()) {\n-                case \"I\", \"S\", \"C\" ,\"B\", \"Z\" ->  SimpleVerificationTypeInfo.ITEM_INTEGER;\n-                case \"J\" -> SimpleVerificationTypeInfo.ITEM_LONG;\n-                case \"F\" -> SimpleVerificationTypeInfo.ITEM_FLOAT;\n-                case \"D\" -> SimpleVerificationTypeInfo.ITEM_DOUBLE;\n-                case \"V\" -> throw new IllegalArgumentException(\"Illegal method argument type: \" + arg);\n+        for(var arg : methodType.parameterList()) {\n+            vtis[i++] = switch (arg.descriptorString().charAt(0)) {\n+                case 'I', 'S', 'C' ,'B', 'Z' -> SimpleVerificationTypeInfo.ITEM_INTEGER;\n+                case 'J' -> SimpleVerificationTypeInfo.ITEM_LONG;\n+                case 'F' -> SimpleVerificationTypeInfo.ITEM_FLOAT;\n+                case 'D' -> SimpleVerificationTypeInfo.ITEM_DOUBLE;\n+                case 'V' -> throw new IllegalArgumentException(\"Illegal method argument type: \" + arg);\n@@ -103,1 +102,1 @@\n-                mi.methodType().stringValue(),\n+                mi.methodTypeSymbol(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                dcb.methodInfo.methodTypeSymbol(),\n@@ -184,0 +184,2 @@\n+    static record RawExceptionCatch(int start, int end, int handler, Type catchType) {}\n+\n@@ -191,1 +193,2 @@\n-    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> exceptionTable;\n+    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers;\n+    private final List<RawExceptionCatch> rawHandlers;\n@@ -229,1 +232,2 @@\n-        this.exceptionTable = handlers;\n+        this.handlers = handlers;\n+        this.rawHandlers = new ArrayList<>(handlers.size());\n@@ -252,6 +256,13 @@\n-    private int getFrameIndexFromOffset(int offset) {\n-        int i = 0;\n-        for (; i < frames.size(); i++) {\n-            if (frames.get(i).offset == offset) {\n-                return i;\n-            }\n+    private Frame getFrame(int offset) {\n+        \/\/binary search over frames ordered by offset\n+        int low = 0;\n+        int high = frames.size() - 1;\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            var f = frames.get(mid);\n+            if (f.offset < offset)\n+                low = mid + 1;\n+            else if (f.offset > offset)\n+                high = mid - 1;\n+            else\n+                return f;\n@@ -259,1 +270,1 @@\n-        return i;\n+        return null;\n@@ -263,2 +274,1 @@\n-        int index = getFrameIndexFromOffset(target);\n-        frame.checkAssignableTo(frames.get(index));\n+        frame.checkAssignableTo(getFrame(target));\n@@ -279,1 +289,1 @@\n-        for (var exhandler : exceptionTable) {\n+        for (var exhandler : handlers) {\n@@ -282,2 +292,9 @@\n-            if (start_pc < exMin) exMin = start_pc;\n-            if (end_pc > exMax) exMax = end_pc;\n+            int handler_pc = labelContext.labelToBci(exhandler.handler());\n+            if (start_pc >= 0 && end_pc >= 0 && end_pc > start_pc && handler_pc >= 0) {\n+                if (start_pc < exMin) exMin = start_pc;\n+                if (end_pc > exMax) exMax = end_pc;\n+                var catchType = exhandler.catchType();\n+                rawHandlers.add(new RawExceptionCatch(start_pc, end_pc, handler_pc,\n+                        catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp)\n+                                              : Type.THROWABLE_TYPE));\n+            }\n@@ -321,1 +338,1 @@\n-        var it = exceptionTable.listIterator();\n+        var it = handlers.listIterator();\n@@ -382,4 +399,0 @@\n-    private static boolean isDoubleSlot(ClassDesc desc) {\n-        return CD_double.equals(desc) || CD_long.equals(desc);\n-    }\n-\n@@ -654,2 +667,2 @@\n-        for (var exhandler : exceptionTable) {\n-            if (bci >= labelContext.labelToBci(exhandler.tryStart()) && bci < labelContext.labelToBci(exhandler.tryEnd())) {\n+        for (var ex : rawHandlers) {\n+            if (bci == ex.start || (currentFrame.localsChanged && bci > ex.start && bci < ex.end)) {\n@@ -658,5 +671,2 @@\n-                Frame newFrame = currentFrame.frameInExceptionHandler(flags);\n-                var catchType = exhandler.catchType();\n-                newFrame.pushStack(catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp) : Type.THROWABLE_TYPE);\n-                int handler = labelContext.labelToBci(exhandler.handler());\n-                if (handler != -1) checkJumpTarget(newFrame, handler);\n+                Frame newFrame = currentFrame.frameInExceptionHandler(flags, ex.catchType);\n+                checkJumpTarget(newFrame, ex.handler);\n@@ -665,0 +675,1 @@\n+        currentFrame.localsChanged = false;\n@@ -735,1 +746,1 @@\n-        var desc = ClassDesc.ofDescriptor(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType().type().stringValue());\n+        var desc = Util.fieldTypeSymbol(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType());\n@@ -741,1 +752,1 @@\n-                if (isDoubleSlot(desc)) currentFrame.popStack();\n+                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n@@ -750,1 +761,1 @@\n-                if (isDoubleSlot(desc)) currentFrame.popStack();\n+                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n@@ -762,28 +773,1 @@\n-\n-        var mDesc = nameAndType.type().stringValue();\n-        \/\/faster counting of method descriptor argument slots instead of full parsing\n-        int nargs = 0, pos = 0, descLen = mDesc.length();\n-        if (descLen < 3 || mDesc.charAt(0) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n-        char ch;\n-        while (++pos < descLen && (ch = mDesc.charAt(pos)) != ')') {\n-            switch (ch) {\n-                case '[' -> {\n-                    nargs++;\n-                    while (++pos < descLen && mDesc.charAt(pos) == '[');\n-                    if (mDesc.charAt(pos) == 'L')\n-                        while (++pos < descLen && mDesc.charAt(pos) != ';');\n-                }\n-                case 'D', 'J' -> nargs += 2;\n-                case 'B', 'C', 'F', 'I', 'S', 'Z' -> nargs++;\n-                case 'L' -> {\n-                    nargs++;\n-                    while (++pos < descLen && mDesc.charAt(pos) != ';');\n-                }\n-                default ->\n-                    throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n-            }\n-        }\n-        if (++pos >= descLen)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n-\n+        var mDesc = Util.methodTypeSymbol(nameAndType);\n@@ -791,1 +775,1 @@\n-        currentFrame.decStack(nargs);\n+        currentFrame.decStack(Util.parameterSlots(mDesc));\n@@ -816,1 +800,1 @@\n-        currentFrame.pushStack(ClassDesc.ofDescriptor(mDesc.substring(pos)));\n+        currentFrame.pushStack(mDesc.returnType());\n@@ -947,2 +931,2 @@\n-        for (var exhandler : exceptionTable) try {\n-            offsets.set(labelContext.labelToBci(exhandler.handler()));\n+        for (var exhandler : rawHandlers) try {\n+             offsets.set(exhandler.handler());\n@@ -963,0 +947,1 @@\n+        boolean localsChanged = false;\n@@ -992,2 +977,2 @@\n-            return switch (desc.descriptorString()) {\n-                case \"J\" ->\n+            return switch (desc.descriptorString().charAt(0)) {\n+                case 'J' ->\n@@ -995,1 +980,1 @@\n-                case \"D\" ->\n+                case 'D' ->\n@@ -997,1 +982,1 @@\n-                case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -999,1 +984,1 @@\n-                case \"F\" ->\n+                case 'F' ->\n@@ -1001,1 +986,1 @@\n-                case \"V\" ->\n+                case 'V' ->\n@@ -1032,2 +1017,2 @@\n-        Frame frameInExceptionHandler(int flags) {\n-            return new Frame(offset, flags, localsSize, 0, locals, new Type[] {Type.TOP_TYPE}, classHierarchy);\n+        Frame frameInExceptionHandler(int flags, Type excType) {\n+            return new Frame(offset, flags, localsSize, 1, locals, new Type[] {excType}, classHierarchy);\n@@ -1041,0 +1026,1 @@\n+                    localsChanged = true;\n@@ -1080,0 +1066,1 @@\n+            localsChanged |= !type.equals(locals[index]);\n@@ -1098,2 +1085,2 @@\n-                } else switch (desc.descriptorString()) {\n-                    case \"J\" -> {\n+                } else switch (desc.descriptorString().charAt(0)) {\n+                    case 'J' -> {\n@@ -1103,1 +1090,1 @@\n-                    case \"D\" -> {\n+                    case 'D' -> {\n@@ -1107,1 +1094,1 @@\n-                    case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                    case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -1109,1 +1096,1 @@\n-                    case \"F\" ->\n+                    case 'F' ->\n@@ -1126,0 +1113,1 @@\n+            localsChanged = true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":63,"deletions":75,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -38,0 +39,1 @@\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n@@ -59,31 +61,1 @@\n-    public static BitSet findParams(String type) {\n-        BitSet bs = new BitSet();\n-        if (type.charAt(0) != '(')\n-            throw new IllegalArgumentException();\n-        loop: for (int i = 1; i < type.length(); ++i) {\n-            switch (type.charAt(i)) {\n-                case '[':\n-                    bs.set(i);\n-                    while (type.charAt(++i) == '[')\n-                        ;\n-                    if (type.charAt(i) == 'L') {\n-                        while (type.charAt(++i) != ';')\n-                            ;\n-                    }\n-                    break;\n-                case ')':\n-                    break loop;\n-                default:\n-                    bs.set(i);\n-                    if (type.charAt(i) == 'L') {\n-                        while (type.charAt(++i) != ';')\n-                            ;\n-                    }\n-            }\n-        }\n-        return bs;\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    public static int parameterSlots(String type) {\n-        BitSet bs = findParams(type);\n+    public static int parameterSlots(MethodTypeDesc mDesc) {\n@@ -91,2 +63,2 @@\n-        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n-            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        for (int i = 0; i < mDesc.parameterCount(); i++) {\n+            count += slotSize(mDesc.parameterType(i));\n@@ -97,4 +69,2 @@\n-    public static int[] parseParameterSlots(int flags, String type) {\n-        BitSet bs = findParams(type);\n-        int[] result = new int[bs.cardinality()];\n-        int index = 0;\n+    public static int[] parseParameterSlots(int flags, MethodTypeDesc mDesc) {\n+        int[] result = new int[mDesc.parameterCount()];\n@@ -102,3 +72,3 @@\n-        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n-            result[index++] = count;\n-            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = count;\n+            count += slotSize(mDesc.parameterType(i));\n@@ -109,2 +79,1 @@\n-    public static int maxLocals(int flags, String type) {\n-        BitSet bs = findParams(type);\n+    public static int maxLocals(int flags, MethodTypeDesc mDesc) {\n@@ -112,2 +81,3 @@\n-        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1))\n-            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        for (int i = 0; i < mDesc.parameterCount(); i++) {\n+            count += slotSize(mDesc.parameterType(i));\n+        }\n@@ -190,1 +160,1 @@\n-            result[i] = TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(toInternalName(list.get(i))));\n+            result[i] = TemporaryConstantPool.INSTANCE.classEntry(list.get(i));\n@@ -234,0 +204,21 @@\n+\n+    public static ClassDesc fieldTypeSymbol(NameAndTypeEntry nat) {\n+        return ((AbstractPoolEntry.NameAndTypeEntryImpl)nat).fieldTypeSymbol();\n+    }\n+\n+    public static MethodTypeDesc methodTypeSymbol(NameAndTypeEntry nat) {\n+        return ((AbstractPoolEntry.NameAndTypeEntryImpl)nat).methodTypeSymbol();\n+    }\n+\n+    public static int slotSize(ClassDesc desc) {\n+        return switch (desc.descriptorString().charAt(0)) {\n+            case 'V' -> 0;\n+            case 'D','J' -> 2;\n+            default -> 1;\n+        };\n+    }\n+\n+    public static boolean isDoubleSlot(ClassDesc desc) {\n+        char ch = desc.descriptorString().charAt(0);\n+        return ch == 'D' || ch == 'J';\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":36,"deletions":45,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -79,1 +80,1 @@\n-        return ClassDesc.ofDescriptor(type().stringValue());\n+        return Util.fieldTypeSymbol(field().nameAndType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/FieldInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -72,1 +73,1 @@\n-        return MethodTypeDesc.ofDescriptor(type().stringValue());\n+        return Util.methodTypeSymbol(invokedynamic().nameAndType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeDynamicInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -92,1 +93,1 @@\n-        return MethodTypeDesc.ofDescriptor(type().stringValue());\n+        return Util.methodTypeSymbol(method().nameAndType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            long addressSize = ADDRESS.bitSize();\n+            long addressSize = ADDRESS.byteSize();\n@@ -60,1 +60,1 @@\n-            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 64) {\n+            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 8) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -55,4 +56,4 @@\n-    private static final long MAX_ALIGN_1 = 1;\n-    private static final long MAX_ALIGN_2 = 2;\n-    private static final long MAX_ALIGN_4 = 4;\n-    private static final long MAX_ALIGN_8 = 8;\n+    private static final long MAX_ALIGN_1 = ValueLayout.JAVA_BYTE.byteAlignment();\n+    private static final long MAX_ALIGN_2 = ValueLayout.JAVA_SHORT.byteAlignment();\n+    private static final long MAX_ALIGN_4 = ValueLayout.JAVA_INT.byteAlignment();\n+    private static final long MAX_ALIGN_8 = ValueLayout.JAVA_LONG.byteAlignment();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), derefAdapters, this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(elem.byteSize()), addBound(seq.elementCount()), derefAdapters, this);\n@@ -108,1 +108,1 @@\n-        long elemSize = elem.bitSize();\n+        long elemSize = elem.byteSize();\n@@ -121,1 +121,1 @@\n-        long elemSize = seq.elementLayout().bitSize();\n+        long elemSize = seq.elementLayout().byteSize();\n@@ -138,1 +138,1 @@\n-                offset += l.bitSize();\n+                offset += l.byteSize();\n@@ -159,1 +159,1 @@\n-                offset += elem.bitSize();\n+                offset += elem.byteSize();\n@@ -199,1 +199,1 @@\n-                    Utils.bitsToBytes(strides[i]),\n+                    strides[i],\n@@ -206,1 +206,1 @@\n-                Utils.bitsToBytes(offset));\n+                offset);\n@@ -235,2 +235,1 @@\n-        MethodHandle offsetHandle = offsetHandle(); \/\/ bit offset\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.BITS_TO_BYTES); \/\/ byte offset\n+        MethodHandle offsetHandle = offsetHandle(); \/\/ byte offset\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    \/\/ The maximum alignment supported by malloc - typically 16 on\n-    \/\/ 64-bit platforms and 8 on 32-bit platforms.\n+    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n+    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-    public static final MethodHandle BITS_TO_BYTES;\n@@ -79,2 +78,0 @@\n-            BITS_TO_BYTES = lookup.findStatic(Utils.class, \"bitsToBytes\",\n-                    MethodType.methodType(long.class, long.class));\n@@ -95,5 +92,0 @@\n-    public static long bitsToBytes(long bits) {\n-        assert Utils.isAligned(bits, 8);\n-        return bits \/ Byte.SIZE;\n-    }\n-\n@@ -180,1 +172,1 @@\n-        assert isPowerOfTwo(layout.bitSize());\n+        assert isPowerOfTwo(layout.byteSize());\n@@ -239,1 +231,1 @@\n-            long padding = computePadding(offset, l.bitAlignment());\n+            long padding = computePadding(offset, l.byteAlignment());\n@@ -245,2 +237,2 @@\n-            align = Math.max(align, l.bitAlignment());\n-            offset += l.bitSize();\n+            align = Math.max(align, l.byteAlignment());\n+            offset += l.byteSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-                offset += member.bitSize();\n+                offset += member.byteSize();\n@@ -174,1 +174,1 @@\n-                    maxUnpaddedLayout = Long.max(maxUnpaddedLayout, member.bitSize());\n+                    maxUnpaddedLayout = Long.max(maxUnpaddedLayout, member.byteSize());\n@@ -185,2 +185,2 @@\n-        long expectedSize = Utils.alignUp(maxUnpaddedOffset, gl.bitAlignment());\n-        if (gl.bitSize() != expectedSize) {\n+        long expectedSize = Utils.alignUp(maxUnpaddedOffset, gl.byteAlignment());\n+        if (gl.byteSize() != expectedSize) {\n@@ -188,1 +188,1 @@\n-                    + gl.bitSize() + \" != \" + expectedSize);\n+                    + gl.byteSize() + \" != \" + expectedSize);\n@@ -196,1 +196,1 @@\n-        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, memberLayout.bitAlignment());\n+        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, memberLayout.byteAlignment());\n@@ -205,1 +205,1 @@\n-            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \" + layout);\n+            throw new IllegalArgumentException(\"Layout alignment must be natural alignment: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-            .withBitAlignment(64)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,3 +483,1 @@\n-                    for (StorageCalculator.StructStorage(\n-                            long offset, Class<?> ca, int byteWidth, VMStorage storage\n-                    ) : structStorages) {\n+                    for (StorageCalculator.StructStorage structStorage : structStorages) {\n@@ -487,2 +485,2 @@\n-                        bindings.vmLoad(storage, ca)\n-                                .bufferStore(offset, ca, byteWidth);\n+                        bindings.vmLoad(structStorage.storage(), structStorage.carrier())\n+                                .bufferStore(structStorage.offset(), structStorage.carrier(), structStorage.byteWidth());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n+        return type.byteSize() <= MAX_AGGREGATE_REGS_SIZE * 8;\n@@ -109,2 +109,2 @@\n-            if (elem.bitSize() != baseType.bitSize() ||\n-                    elem.bitAlignment() != baseType.bitAlignment() ||\n+            if (elem.byteSize() != baseType.byteSize() ||\n+                    elem.byteAlignment() != baseType.byteAlignment() ||\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.bitSize()) {\n-            case 64 -> JAVA_LONG;\n-            case 32 -> JAVA_INT;\n+    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n+            case 8 -> JAVA_LONG;\n+            case 4 -> JAVA_INT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n+        return type.byteSize() <= MAX_AGGREGATE_REGS_SIZE * 8;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.function.LongBinaryOperator;\n@@ -52,1 +51,1 @@\n-    final long minBitAlignment;\n+    final long minByteAlignment;\n@@ -54,2 +53,2 @@\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n-        super(bitSize, bitAlignment, name); \/\/ Subclassing creates toctou problems here\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long byteSize, long byteAlignment, long minByteAlignment, Optional<String> name) {\n+        super(byteSize, byteAlignment, name); \/\/ Subclassing creates toctou problems here\n@@ -58,1 +57,1 @@\n-        this.minBitAlignment = minBitAlignment;\n+        this.minByteAlignment = minByteAlignment;\n@@ -85,2 +84,2 @@\n-    public L withBitAlignment(long bitAlignment) {\n-        if (bitAlignment < minBitAlignment) {\n+    public L withByteAlignment(long byteAlignment) {\n+        if (byteAlignment < minByteAlignment) {\n@@ -89,1 +88,1 @@\n-        return super.withBitAlignment(bitAlignment);\n+        return super.withByteAlignment(byteAlignment);\n@@ -114,1 +113,1 @@\n-        return bitAlignment() == minBitAlignment;\n+        return byteAlignment() == minByteAlignment;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,3 +46,3 @@\n-    AbstractLayout(long bitSize, long bitAlignment, Optional<String> name) {\n-        this.byteSize = MemoryLayoutUtil.requireBitSizeValid(bitSize, true) \/ 8;\n-        this.byteAlignment = requirePowerOfTwoAndGreaterOrEqualToEight(bitAlignment) \/ 8;\n+    AbstractLayout(long byteSize, long byteAlignment, Optional<String> name) {\n+        this.byteSize = MemoryLayoutUtil.requireByteSizeValid(byteSize, true);\n+        this.byteAlignment = requirePowerOfTwoAndGreaterOrEqualToOne(byteAlignment);\n@@ -53,1 +53,1 @@\n-        return dup(bitAlignment(), Optional.of(name));\n+        return dup(byteAlignment(), Optional.of(name));\n@@ -57,1 +57,1 @@\n-        return dup(bitAlignment(), Optional.empty());\n+        return dup(byteAlignment(), Optional.empty());\n@@ -64,6 +64,2 @@\n-    public L withBitAlignment(long bitAlignment) {\n-        return dup(bitAlignment, name);\n-    }\n-\n-    public final long bitAlignment() {\n-        return byteAlignment * 8;\n+    public L withByteAlignment(long byteAlignment) {\n+        return dup(byteAlignment, name);\n@@ -80,4 +76,0 @@\n-    public final long bitSize() {\n-        return byteSize * 8;\n-    }\n-\n@@ -130,1 +122,1 @@\n-    abstract L dup(long bitAlignment, Optional<String> name);\n+    abstract L dup(long byteAlignment, Optional<String> name);\n@@ -137,1 +129,1 @@\n-            s = bitAlignment() + \"%\" + s;\n+            s = byteAlignment() + \"%\" + s;\n@@ -142,1 +134,1 @@\n-    private static long requirePowerOfTwoAndGreaterOrEqualToEight(long value) {\n+    private static long requirePowerOfTwoAndGreaterOrEqualToOne(long value) {\n@@ -144,1 +136,1 @@\n-                value < 8) { \/\/ value must be greater or equal to 8\n+                value < 1) { \/\/ value must be greater or equal to 1\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-    public static long requireBitSizeValid(long bitSize, boolean allowZero) {\n-        if ((bitSize == 0 && !allowZero) || bitSize < 0 || bitSize % 8 != 0) {\n-            throw new IllegalArgumentException(\"Invalid bitSize: \" + bitSize);\n+    public static long requireByteSizeValid(long byteSize, boolean allowZero) {\n+        if ((byteSize == 0 && !allowZero) || byteSize < 0) {\n+            throw new IllegalArgumentException(\"Invalid byte size: \" + byteSize);\n@@ -44,1 +44,1 @@\n-        return bitSize;\n+        return byteSize;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private PaddingLayoutImpl(long bitSize) {\n-        this(bitSize, 8, Optional.empty());\n+    private PaddingLayoutImpl(long byteSize) {\n+        this(byteSize, 1, Optional.empty());\n@@ -38,2 +38,2 @@\n-    private PaddingLayoutImpl(long bitSize, long bitAlignment, Optional<String> name) {\n-        super(bitSize, bitAlignment, name);\n+    private PaddingLayoutImpl(long byteSize, long byteAlignment, Optional<String> name) {\n+        super(byteSize, byteAlignment, name);\n@@ -44,1 +44,1 @@\n-        return decorateLayoutString(\"x\" + bitSize());\n+        return decorateLayoutString(\"x\" + byteSize());\n@@ -52,1 +52,1 @@\n-                bitSize() == otherPadding.bitSize();\n+                byteSize() == otherPadding.byteSize();\n@@ -57,1 +57,1 @@\n-        return Objects.hash(super.hashCode(), bitSize());\n+        return Objects.hash(super.hashCode(), byteSize());\n@@ -61,2 +61,2 @@\n-    PaddingLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new PaddingLayoutImpl(bitSize(), bitAlignment, name);\n+    PaddingLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new PaddingLayoutImpl(byteSize(), byteAlignment, name);\n@@ -70,2 +70,2 @@\n-    public static PaddingLayout of(long bitSize) {\n-        return new PaddingLayoutImpl(bitSize);\n+    public static PaddingLayout of(long byteSize) {\n+        return new PaddingLayoutImpl(byteSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n+        this(elemCount, elementLayout, elementLayout.byteAlignment(), Optional.empty());\n@@ -42,2 +42,2 @@\n-    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long bitAlignment, Optional<String> name) {\n-        super(Math.multiplyExact(elemCount, elementLayout.bitSize()), bitAlignment, name);\n+    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long byteAlignment, Optional<String> name) {\n+        super(Math.multiplyExact(elemCount, elementLayout.byteSize()), byteAlignment, name);\n@@ -71,1 +71,1 @@\n-        return new SequenceLayoutImpl(elementCount, elementLayout, bitAlignment(), name());\n+        return new SequenceLayoutImpl(elementCount, elementLayout, byteAlignment(), name());\n@@ -179,1 +179,1 @@\n-        boolean max = (Long.MAX_VALUE \/ elementLayout.bitSize()) == elemCount;\n+        boolean max = (Long.MAX_VALUE \/ elementLayout.byteSize()) == elemCount;\n@@ -199,2 +199,2 @@\n-    SequenceLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new SequenceLayoutImpl(elementCount(), elementLayout, bitAlignment, name);\n+    SequenceLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new SequenceLayoutImpl(elementCount(), elementLayout, byteAlignment, name);\n@@ -204,2 +204,2 @@\n-    public SequenceLayoutImpl withBitAlignment(long bitAlignment) {\n-        if (bitAlignment < elementLayout.bitAlignment()) {\n+    public SequenceLayoutImpl withByteAlignment(long byteAlignment) {\n+        if (byteAlignment < elementLayout.byteAlignment()) {\n@@ -208,1 +208,1 @@\n-        return super.withBitAlignment(bitAlignment);\n+        return super.withByteAlignment(byteAlignment);\n@@ -213,1 +213,1 @@\n-        return bitAlignment() == elementLayout.bitAlignment();\n+        return byteAlignment() == elementLayout.byteAlignment();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private StructLayoutImpl(List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n-        super(Kind.STRUCT, elements, bitSize, bitAlignment, minBitAlignment, name);\n+    private StructLayoutImpl(List<MemoryLayout> elements, long byteSize, long byteAlignment, long minByteAlignment, Optional<String> name) {\n+        super(Kind.STRUCT, elements, byteSize, byteAlignment, minByteAlignment, name);\n@@ -40,2 +40,2 @@\n-    StructLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new StructLayoutImpl(memberLayouts(), bitSize(), bitAlignment, minBitAlignment, name);\n+    StructLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new StructLayoutImpl(memberLayouts(), byteSize(), byteAlignment, minByteAlignment, name);\n@@ -46,1 +46,1 @@\n-        long align = 8;\n+        long align = 1;\n@@ -48,1 +48,1 @@\n-            if (size % elem.bitAlignment() != 0) {\n+            if (size % elem.byteAlignment() != 0) {\n@@ -51,2 +51,2 @@\n-            size = Math.addExact(size, elem.bitSize());\n-            align = Math.max(align, elem.bitAlignment());\n+            size = Math.addExact(size, elem.byteSize());\n+            align = Math.max(align, elem.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private UnionLayoutImpl(List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n-        super(Kind.UNION, elements, bitSize, bitAlignment, minBitAlignment, name);\n+    private UnionLayoutImpl(List<MemoryLayout> elements, long byteSize, long byteAlignment, long minByteAlignment, Optional<String> name) {\n+        super(Kind.UNION, elements, byteSize, byteAlignment, minByteAlignment, name);\n@@ -40,2 +40,2 @@\n-    UnionLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new UnionLayoutImpl(memberLayouts(), bitSize(), bitAlignment, minBitAlignment, name);\n+    UnionLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new UnionLayoutImpl(memberLayouts(), byteSize(), byteAlignment, minByteAlignment, name);\n@@ -46,1 +46,1 @@\n-        long align = 8;\n+        long align = 1;\n@@ -48,2 +48,2 @@\n-            size = Math.max(size, elem.bitSize());\n-            align = Math.max(align, elem.bitAlignment());\n+            size = Math.max(size, elem.byteSize());\n+            align = Math.max(align, elem.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (in bits),\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (expressed in bytes),\n@@ -67,1 +67,1 @@\n-        static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+        static final int ADDRESS_SIZE_BYTES = Unsafe.ADDRESS_SIZE;\n@@ -74,2 +74,2 @@\n-        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize, long bitAlignment, Optional<String> name) {\n-            super(bitSize, bitAlignment, name);\n+        AbstractValueLayout(Class<?> carrier, ByteOrder order, long byteSize, long byteAlignment, Optional<String> name) {\n+            super(byteSize, byteAlignment, name);\n@@ -78,1 +78,1 @@\n-            assertCarrierSize(carrier, bitSize);\n+            assertCarrierSize(carrier, byteSize);\n@@ -97,1 +97,1 @@\n-            return dup(order, bitAlignment(), name());\n+            return dup(order, byteAlignment(), name());\n@@ -106,1 +106,1 @@\n-            return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+            return decorateLayoutString(String.format(\"%s%d\", descriptor, byteSize()));\n@@ -146,2 +146,2 @@\n-        final V dup(long bitAlignment, Optional<String> name) {\n-            return dup(order(), bitAlignment, name);\n+        final V dup(long byteAlignment, Optional<String> name) {\n+            return dup(order(), byteAlignment, name);\n@@ -150,1 +150,1 @@\n-        abstract V dup(ByteOrder order, long bitAlignment, Optional<String> name);\n+        abstract V dup(ByteOrder order, long byteAlignment, Optional<String> name);\n@@ -152,1 +152,1 @@\n-        static void assertCarrierSize(Class<?> carrier, long bitSize) {\n+        static void assertCarrierSize(Class<?> carrier, long byteSize) {\n@@ -155,2 +155,2 @@\n-                    \/\/ MemorySegment bitSize must always equal ADDRESS_SIZE_BITS\n-                    || bitSize == ADDRESS_SIZE_BITS;\n+                    \/\/ MemorySegment byteSize must always equal ADDRESS_SIZE_BYTES\n+                    || byteSize == ADDRESS_SIZE_BYTES;\n@@ -158,2 +158,3 @@\n-                    \/\/ Primitive class bitSize must always correspond\n-                    bitSize == (carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth());\n+                    \/\/ Primitive class byteSize must always correspond\n+                    byteSize == (carrier == boolean.class ? 1 :\n+                            Utils.byteWidthOfPrimitive(carrier));\n@@ -192,2 +193,2 @@\n-        private OfBooleanImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(boolean.class, order, Byte.SIZE, bitAlignment, name);\n+        private OfBooleanImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(boolean.class, order, Byte.BYTES, byteAlignment, name);\n@@ -197,2 +198,2 @@\n-        OfBooleanImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfBooleanImpl(order, bitAlignment, name);\n+        OfBooleanImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfBooleanImpl(order, byteAlignment, name);\n@@ -202,1 +203,1 @@\n-            return new OfBooleanImpl(order, Byte.SIZE, Optional.empty());\n+            return new OfBooleanImpl(order, Byte.BYTES, Optional.empty());\n@@ -208,2 +209,2 @@\n-        private OfByteImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(byte.class, order, Byte.SIZE, bitAlignment, name);\n+        private OfByteImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(byte.class, order, Byte.BYTES, byteAlignment, name);\n@@ -213,2 +214,2 @@\n-        OfByteImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfByteImpl(order, bitAlignment, name);\n+        OfByteImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfByteImpl(order, byteAlignment, name);\n@@ -218,1 +219,1 @@\n-            return new OfByteImpl(order, Byte.SIZE, Optional.empty());\n+            return new OfByteImpl(order, Byte.BYTES, Optional.empty());\n@@ -224,2 +225,2 @@\n-        private OfCharImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(char.class, order, Character.SIZE, bitAlignment, name);\n+        private OfCharImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(char.class, order, Character.BYTES, byteAlignment, name);\n@@ -229,2 +230,2 @@\n-        OfCharImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfCharImpl(order, bitAlignment, name);\n+        OfCharImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfCharImpl(order, byteAlignment, name);\n@@ -234,1 +235,1 @@\n-            return new OfCharImpl(order, Character.SIZE, Optional.empty());\n+            return new OfCharImpl(order, Character.BYTES, Optional.empty());\n@@ -240,2 +241,2 @@\n-        private OfShortImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(short.class, order, Short.SIZE, bitAlignment, name);\n+        private OfShortImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(short.class, order, Short.BYTES, byteAlignment, name);\n@@ -245,2 +246,2 @@\n-        OfShortImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfShortImpl(order, bitAlignment, name);\n+        OfShortImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfShortImpl(order, byteAlignment, name);\n@@ -250,1 +251,1 @@\n-            return new OfShortImpl(order, Short.SIZE, Optional.empty());\n+            return new OfShortImpl(order, Short.BYTES, Optional.empty());\n@@ -256,2 +257,2 @@\n-        private OfIntImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(int.class, order, Integer.SIZE, bitAlignment, name);\n+        private OfIntImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(int.class, order, Integer.BYTES, byteAlignment, name);\n@@ -261,2 +262,2 @@\n-        OfIntImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfIntImpl(order, bitAlignment, name);\n+        OfIntImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfIntImpl(order, byteAlignment, name);\n@@ -266,1 +267,1 @@\n-            return new OfIntImpl(order, Integer.SIZE, Optional.empty());\n+            return new OfIntImpl(order, Integer.BYTES, Optional.empty());\n@@ -272,2 +273,2 @@\n-        private OfFloatImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(float.class, order, Float.SIZE, bitAlignment, name);\n+        private OfFloatImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(float.class, order, Float.BYTES, byteAlignment, name);\n@@ -277,2 +278,2 @@\n-        OfFloatImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfFloatImpl(order, bitAlignment, name);\n+        OfFloatImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfFloatImpl(order, byteAlignment, name);\n@@ -282,1 +283,1 @@\n-            return new OfFloatImpl(order, Float.SIZE, Optional.empty());\n+            return new OfFloatImpl(order, Float.BYTES, Optional.empty());\n@@ -288,2 +289,2 @@\n-        private OfLongImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(long.class, order, Long.SIZE, bitAlignment, name);\n+        private OfLongImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(long.class, order, Long.BYTES, byteAlignment, name);\n@@ -293,2 +294,2 @@\n-        OfLongImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfLongImpl(order, bitAlignment, name);\n+        OfLongImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfLongImpl(order, byteAlignment, name);\n@@ -298,1 +299,1 @@\n-            return new OfLongImpl(order, Long.SIZE, Optional.empty());\n+            return new OfLongImpl(order, ADDRESS_SIZE_BYTES, Optional.empty());\n@@ -304,2 +305,2 @@\n-        private OfDoubleImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(double.class, order, Double.SIZE, bitAlignment, name);\n+        private OfDoubleImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(double.class, order, Double.BYTES, byteAlignment, name);\n@@ -309,2 +310,2 @@\n-        OfDoubleImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfDoubleImpl(order, bitAlignment, name);\n+        OfDoubleImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfDoubleImpl(order, byteAlignment, name);\n@@ -314,1 +315,1 @@\n-            return new OfDoubleImpl(order, Double.SIZE, Optional.empty());\n+            return new OfDoubleImpl(order, ADDRESS_SIZE_BYTES, Optional.empty());\n@@ -323,2 +324,2 @@\n-        private OfAddressImpl(ByteOrder order, long bitSize, long bitAlignment, MemoryLayout targetLayout, Optional<String> name) {\n-            super(MemorySegment.class, order, bitSize, bitAlignment, name);\n+        private OfAddressImpl(ByteOrder order, long byteSize, long byteAlignment, MemoryLayout targetLayout, Optional<String> name) {\n+            super(MemorySegment.class, order, byteSize, byteAlignment, name);\n@@ -329,2 +330,2 @@\n-        OfAddressImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfAddressImpl(order, bitSize(), bitAlignment,targetLayout, name);\n+        OfAddressImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfAddressImpl(order, byteSize(), byteAlignment,targetLayout, name);\n@@ -349,1 +350,1 @@\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment(), layout, name());\n+            return new OfAddressImpl(order(), byteSize(), byteAlignment(), layout, name());\n@@ -354,1 +355,1 @@\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment(), null, name());\n+            return new OfAddressImpl(order(), byteSize(), byteAlignment(), null, name());\n@@ -363,1 +364,1 @@\n-            return new OfAddressImpl(order, ADDRESS_SIZE_BITS, ADDRESS_SIZE_BITS, null, Optional.empty());\n+            return new OfAddressImpl(order, ADDRESS_SIZE_BYTES, ADDRESS_SIZE_BYTES, null, Optional.empty());\n@@ -372,1 +373,1 @@\n-            String str = decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+            String str = decorateLayoutString(String.format(\"%s%d\", descriptor, byteSize()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":64,"deletions":63,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -67,4 +67,0 @@\n-        @JEP(number=433, title=\"Pattern Matching for switch\", status=\"Fourth Preview\")\n-        SWITCH_PATTERN_MATCHING(),\n-        @JEP(number=432, title=\"Record Patterns\", status=\"Second Preview\")\n-        RECORD_PATTERNS,\n@@ -77,0 +73,2 @@\n+        @JEP(number=443, title=\"Unnamed Patterns and Variables\")\n+        UNNAMED,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    ARM,\n@@ -88,0 +89,8 @@\n+    \/**\n+     * {@return {@code true} if the current architecture is ARM}\n+     *\/\n+    @ForceInline\n+    public static boolean isARM() {\n+        return PlatformProps.TARGET_ARCH_IS_ARM;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Architecture.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    static final boolean TARGET_ARCH_IS_ARM     = \"@@OPENJDK_TARGET_CPU@@\" == \"arm\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/PlatformProps.java.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Locale;\n@@ -276,1 +277,1 @@\n-        facts.put(fact.toLowerCase(), value);\n+        facts.put(fact.toLowerCase(Locale.ROOT), value);\n@@ -288,1 +289,1 @@\n-        return facts.get(fact.toLowerCase());\n+        return facts.get(fact.toLowerCase(Locale.ROOT));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ftp\/FtpDirEntry.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.Locale;\n@@ -208,1 +209,1 @@\n-        final String urlhost = host.toLowerCase();\n+        final String urlhost = host.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/spi\/DefaultProxySelector.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Locale;\n@@ -58,1 +59,1 @@\n-                protocol = protocol.toLowerCase();\n+                protocol = protocol.toLowerCase(Locale.ROOT);\n@@ -68,1 +69,1 @@\n-                strForm.append(host.toLowerCase());\n+                strForm.append(host.toLowerCase(Locale.ROOT));\n@@ -91,1 +92,1 @@\n-        String urlStringLowerCase = url.toString().toLowerCase();\n+        String urlStringLowerCase = url.toString().toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/URLUtil.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Locale;\n@@ -97,1 +98,1 @@\n-                    tab[i][0] = new String(ca, beg, end-beg).toLowerCase();\n+                    tab[i][0] = new String(ca, beg, end-beg).toLowerCase(Locale.ROOT);\n@@ -120,1 +121,1 @@\n-                        tab[i++][0] = (new String(ca, beg, end-beg)).toLowerCase();\n+                        tab[i++][0] = (new String(ca, beg, end-beg)).toLowerCase(Locale.ROOT);\n@@ -148,1 +149,1 @@\n-                    tab[i++][0] = (new String(ca, beg, end-beg+1)).toLowerCase();\n+                    tab[i++][0] = (new String(ca, beg, end-beg+1)).toLowerCase(Locale.ROOT);\n@@ -158,1 +159,1 @@\n-                    tab[i++][0] = String.valueOf(ca[end]).toLowerCase();\n+                    tab[i++][0] = String.valueOf(ca[end]).toLowerCase(Locale.ROOT);\n@@ -185,1 +186,1 @@\n-        k = k.toLowerCase();\n+        k = k.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/HeaderParser.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Locale;\n@@ -69,1 +70,1 @@\n-        this.typeName = typeName.toLowerCase();\n+        this.typeName = typeName.toLowerCase(Locale.ROOT);\n@@ -84,1 +85,1 @@\n-        typeName = type.toLowerCase();\n+        typeName = type.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MimeEntry.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.Locale;\n@@ -167,1 +168,1 @@\n-            ext = fname.substring(i).toLowerCase();\n+            ext = fname.substring(i).toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MimeTable.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,1 +267,1 @@\n-        proxiedHosts.put(host.toLowerCase(), null);\n+        proxiedHosts.put(host.toLowerCase(Locale.ROOT), null);\n@@ -271,1 +271,1 @@\n-        return proxiedHosts.containsKey(host.toLowerCase());\n+        return proxiedHosts.containsKey(host.toLowerCase(Locale.ROOT));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/URLConnection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Locale;\n@@ -109,1 +110,1 @@\n-            authPref = authPref.toLowerCase();\n+            authPref = authPref.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationHeader.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Locale;\n@@ -222,1 +223,1 @@\n-        this.host = host.toLowerCase();\n+        this.host = host.toLowerCase(Locale.ROOT);\n@@ -244,2 +245,2 @@\n-        this.protocol = url.getProtocol().toLowerCase();\n-        this.host = url.getHost().toLowerCase();\n+        this.protocol = url.getProtocol().toLowerCase(Locale.ROOT);\n+        this.host = url.getHost().toLowerCase(Locale.ROOT);\n@@ -287,2 +288,2 @@\n-        String key = SERVER_AUTHENTICATION + \":\" + url.getProtocol().toLowerCase()\n-                + \":\" + url.getHost().toLowerCase() + \":\" + port;\n+        String key = SERVER_AUTHENTICATION + \":\" + url.getProtocol().toLowerCase(Locale.ROOT)\n+                + \":\" + url.getHost().toLowerCase(Locale.ROOT) + \":\" + port;\n@@ -304,2 +305,2 @@\n-                     + url.getProtocol().toLowerCase()\n-                     + \":\" + url.getHost().toLowerCase()\n+                     + url.getProtocol().toLowerCase(Locale.ROOT)\n+                     + \":\" + url.getHost().toLowerCase(Locale.ROOT)\n@@ -339,1 +340,1 @@\n-        String key = PROXY_AUTHENTICATION + \"::\" + host.toLowerCase() + \":\" + port;\n+        String key = PROXY_AUTHENTICATION + \"::\" + host.toLowerCase(Locale.ROOT) + \":\" + port;\n@@ -351,1 +352,1 @@\n-                        + \"::\" + host.toLowerCase()\n+                        + \"::\" + host.toLowerCase(Locale.ROOT)\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-                        + authMethod.substring(1).toLowerCase();\n+                        + authMethod.substring(1).toLowerCase(Locale.ROOT);\n@@ -516,1 +516,1 @@\n-            ncstring = Integer.toHexString (nccount).toLowerCase();\n+            ncstring = Integer.toHexString(nccount);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/DigestAuthentication.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                restrictedHeaderSet.add(restrictedHeaders[i].toLowerCase());\n+                restrictedHeaderSet.add(restrictedHeaders[i].toLowerCase(Locale.ROOT));\n@@ -488,1 +488,1 @@\n-        key = key.toLowerCase();\n+        key = key.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Locale;\n@@ -113,1 +114,1 @@\n-            hostname = hostname.toLowerCase();\n+            hostname = hostname.toLowerCase(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,5 @@\n-        decode(new ByteArrayInputStream(input));\n+        try {\n+            decode(new DerValue(input));\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Unable to decode key\", e);\n+        }\n@@ -98,2 +102,1 @@\n-    private void decode(InputStream is) throws InvalidKeyException {\n-        DerValue val = null;\n+    private void decode(DerValue val) throws InvalidKeyException {\n@@ -101,1 +104,0 @@\n-            val = new DerValue(is);\n@@ -135,1 +137,1 @@\n-            throw new InvalidKeyException(\"IOException : \" + e.getMessage());\n+            throw new InvalidKeyException(\"Unable to decode key\", e);\n@@ -244,1 +246,1 @@\n-            decode(stream);\n+            decode(new DerValue(stream));\n@@ -246,2 +248,1 @@\n-            throw new IOException(\"deserialized key is invalid: \" +\n-                                  e.getMessage());\n+            throw new IOException(\"deserialized key is invalid\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,2 +337,1 @@\n-     * Initialize an X509Key object from an input stream.  The data on that\n-     * input stream must be encoded using DER, obeying the X.509\n+     * Initialize an X509Key object from a DerValue, obeying the X.509\n@@ -353,2 +352,1 @@\n-     * @param in an input stream with a DER-encoded X.509\n-     *          SubjectPublicKeyInfo value\n+     * @param val a DER-encoded X.509 SubjectPublicKeyInfo value\n@@ -357,5 +355,1 @@\n-    public void decode(InputStream in)\n-    throws InvalidKeyException\n-    {\n-        DerValue        val;\n-\n+    void decode(DerValue val) throws InvalidKeyException {\n@@ -363,1 +357,0 @@\n-            val = new DerValue(in);\n@@ -374,2 +367,1 @@\n-            throw new InvalidKeyException(\"IOException: \" +\n-                                          e.getMessage());\n+            throw new InvalidKeyException(\"Unable to decode key\", e);\n@@ -380,1 +372,5 @@\n-        decode(new ByteArrayInputStream(encodedKey));\n+        try {\n+            decode(new DerValue(encodedKey));\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Unable to decode key\", e);\n+        }\n@@ -399,1 +395,1 @@\n-            decode(stream);\n+            decode(new DerValue(stream));\n@@ -401,3 +397,1 @@\n-            e.printStackTrace();\n-            throw new IOException(\"deserialized key is invalid: \" +\n-                                  e.getMessage());\n+            throw new IOException(\"deserialized key is invalid\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1004,0 +1004,17 @@\n+#\n+# Support for the here() function\n+#\n+# This security property determines whether the here() XPath function is\n+# supported in XML Signature generation and verification.\n+#\n+# If this property is set to false, the here() function is not supported.\n+# Generating an XML Signature that uses the here() function will throw an\n+# XMLSignatureException. Validating an existing XML Signature that uses the\n+# here() function will also throw an XMLSignatureException.\n+#\n+# The default value for this property is true.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+#jdk.xml.dsig.hereFunctionSupported=true\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-File-Date: 2023-04-13\n+File-Date: 2023-05-11\n@@ -47615,0 +47615,17 @@\n+Subtag: bciav\n+Description: BCI Blissymbolics AV\n+Added: 2023-05-11\n+Prefix: zbl\n+Comments: Name given to a subset of the variety of Blissymbolics curated\n+  by Blissymbolics Communication International, as represented by\n+  entries in the BCI Authorized Vocabulary\n+%%\n+Type: variant\n+Subtag: bcizbl\n+Description: BCI Blissymbolics\n+Added: 2023-05-11\n+Prefix: zbl\n+Comments: Name given to the variety of Blissymbolics curated by\n+  Blissymbolics Communication International\n+%%\n+Type: variant\n","filename":"src\/java.base\/share\/data\/lsrdata\/language-subtag-registry.txt","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+    permission java.security.SecurityPermission\n+                   \"getProperty.jdk.xml.dsig.hereFunctionSupported\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1010,1 +1010,1 @@\n-    while ((arg = *argv) != 0 && *arg == '-') {\n+    while (argc > 0 && *(arg = *argv) == '-') {\n@@ -1208,1 +1208,1 @@\n-    char *arg;\n+    char *arg = NULL;\n@@ -1212,1 +1212,1 @@\n-    while ((arg = *argv) != 0 && *arg == '-') {\n+    while (argc > 0 && *(arg = *argv) == '-') {\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-    char *buf, buf1[16];\n+    char *buf, buf1[(2 * 11) + 2]; \/\/ \"%d:%d\\0\"\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,3 @@\n-     *  21: tbd\n+     *  21: pattern matching for switch and record patterns (string\n+     *      templates in preview, unnamed patterns and variables in\n+     *      preview, unnamed classes and instance main methods in preview)\n@@ -387,0 +389,4 @@\n+     * @see <a href=\"https:\/\/openjdk.org\/jeps\/440\">\n+     * Record Patterns<\/a>\n+     * @see <a href=\"https:\/\/openjdk.org\/jeps\/441\">\n+     * Pattern Matching for switch<\/a>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,3 +134,4 @@\n-     * PackageElement#getSimpleName package} or unnamed {@linkplain\n-     * ModuleElement#getSimpleName module}, an {@linkplain\n-     * Name##empty_name empty name} is returned.\n+     * PackageElement#getSimpleName package}, an unnamed {@linkplain\n+     * ModuleElement#getSimpleName module} or an unnamed {@linkplain\n+     * VariableElement#getSimpleName variable}, an {@linkplain Name##empty_name empty name}\n+     * is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -84,0 +86,3 @@\n+     *\n+     * <p>For variables, the name of each variable is returned, or an empty name\n+     * if the variable is unnamed.\n@@ -96,0 +101,17 @@\n+\n+    \/**\n+     * {@return {@code true} if this is an unnamed variable and {@code\n+     * false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method calls {@code\n+     * getSimpleName()} and returns {@code true} if the result is\n+     * empty and {@code false} otherwise.\n+     *\n+     * @jls 6.1 Declarations\n+     * @jls 14.4 Local Variable Declarations\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED, reflective = true)\n+    default boolean isUnnamed() { return getSimpleName().isEmpty(); }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,37 @@\n+ * <p>\n+ * Platforms and desktop environments may impose restrictions or limitations\n+ * on the access required to implement all functionality in the Robot class.\n+ * For example:\n+ * <ul>\n+ * <li> preventing access to the contents of any part of a desktop\n+ * or Window on the desktop that is not owned by the running application.<\/li>\n+ * <li> treating window decorations as non-owned content.<\/li>\n+ * <li> ignoring or limiting specific requests to manipulate windows.<\/li>\n+ * <li> ignoring or limiting specific requests for Robot generated (synthesized)\n+ * events related to keyboard and mouse etc.<\/li>\n+ * <li> requiring specific or global permissions to any access to window\n+ * contents, even application owned content,or to perform even limited\n+ * synthesizing of events.<\/li>\n+ * <\/ul>\n+ *\n+ * The Robot API specification requires that approvals for these be granted\n+ * for full operation.\n+ * If they are not granted, the API will be degraded as discussed here.\n+ * Relevant specific API methods may document more specific limitations\n+ * and requirements.\n+ * Depending on the policies of the desktop environment,\n+ * the approvals mentioned above may:\n+ * <ul>\n+ * <li>be required every time<\/li>\n+ * <li>or persistent for the lifetime of an application,<\/li>\n+ * <li>or persistent across multiple user desktop sessions<\/li>\n+ * <li>be fine-grained permissions<\/li>\n+ * <li>be associated with a specific binary application,\n+ * or a class of binary applications.<\/li>\n+ * <\/ul>\n+ *\n+ * When such approvals need to given interactively, it may impede the normal\n+ * operation of the application until approved, and if approval is denied\n+ * or not possible, or cannot be made persistent then it will degrade\n+ * the functionality of this class and in turn any part of the operation\n+ * of the application which is dependent on it.\n@@ -192,0 +229,5 @@\n+     * <p>\n+     * The mouse pointer may not visually move on some platforms,\n+     * while the subsequent mousePress and mouseRelease can be\n+     * delivered to the correct location\n+     *\n@@ -386,0 +428,11 @@\n+     * <p>\n+     * If the desktop environment requires that permissions be granted\n+     * to capture screen content, and the required permissions are not granted,\n+     * then a {@code SecurityException} may be thrown,\n+     * or the content of the returned {@code Color} is undefined.\n+     * <\/p>\n+     * @apiNote It is recommended to avoid calling this method on\n+     * the AWT Event Dispatch Thread since screen capture may be a lengthy\n+     * operation, particularly if acquiring permissions is needed and involves\n+     * user interaction.\n+     *\n@@ -388,0 +441,3 @@\n+     * @throws  SecurityException if {@code readDisplayPixels} permission\n+     *          is not granted, or access to the screen is denied\n+     *          by the desktop environment\n@@ -398,2 +454,12 @@\n-     * Creates an image containing pixels read from the screen.  This image does\n-     * not include the mouse cursor.\n+     * Creates an image containing pixels read from the screen.\n+     * <p>\n+     * If the desktop environment requires that permissions be granted\n+     * to capture screen content, and the required permissions are not granted,\n+     * then a {@code SecurityException} may be thrown,\n+     * or the contents of the returned {@code BufferedImage} are undefined.\n+     * <\/p>\n+     * @apiNote It is recommended to avoid calling this method on\n+     * the AWT Event Dispatch Thread since screen capture may be a lengthy\n+     * operation, particularly if acquiring permissions is needed and involves\n+     * user interaction.\n+     *\n@@ -402,2 +468,5 @@\n-     * @throws  IllegalArgumentException if {@code screenRect} width and height are not greater than zero\n-     * @throws  SecurityException if {@code readDisplayPixels} permission is not granted\n+     * @throws  IllegalArgumentException if {@code screenRect} width and height\n+     *          are not greater than zero\n+     * @throws  SecurityException if {@code readDisplayPixels} permission\n+     *          is not granted, or access to the screen is denied\n+     *          by the desktop environment\n@@ -413,1 +482,0 @@\n-     * This image does not include the mouse cursor.\n@@ -446,2 +514,5 @@\n-     * @throws  IllegalArgumentException if {@code screenRect} width and height are not greater than zero\n-     * @throws  SecurityException if {@code readDisplayPixels} permission is not granted\n+     * @throws  IllegalArgumentException if {@code screenRect} width and height\n+     *          are not greater than zero\n+     * @throws  SecurityException if {@code readDisplayPixels} permission\n+     *          is not granted, or access to the screen is denied\n+     *          by the desktop environment\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Robot.java","additions":79,"deletions":8,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.awt.Window;\n@@ -761,0 +762,10 @@\n+    private Window getMenuInvoker() {\n+        if (invoker instanceof Window menuInvoker) {\n+            return menuInvoker;\n+        } else {\n+            return invoker == null\n+                    ? null\n+                    : SwingUtilities.getWindowAncestor(invoker);\n+        }\n+    }\n+\n@@ -802,1 +813,1 @@\n-        if(b) {\n+        if (b) {\n@@ -804,0 +815,5 @@\n+\n+            if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+                sunToolkit.dismissPopupOnFocusLostIfNeeded(getMenuInvoker());\n+            }\n+\n@@ -808,1 +824,1 @@\n-        } else if(popup != null) {\n+        } else if (popup != null) {\n@@ -810,0 +826,5 @@\n+\n+            if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+                sunToolkit.dismissPopupOnFocusLostIfNeededCleanUp(getMenuInvoker());\n+            }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1886,0 +1886,9 @@\n+    public boolean isRunningOnWayland() {\n+        return false;\n+    }\n+\n+    public void dismissPopupOnFocusLostIfNeeded(Window invoker) {}\n+\n+    public void dismissPopupOnFocusLostIfNeededCleanUp(Window invoker) {}\n+\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,9 @@\n-import static java.awt.RenderingHints.*;\n+\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HBGR;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_VBGR;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_VRGB;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;\n+\n@@ -30,1 +38,12 @@\n-import java.awt.image.*;\n+\n+import java.awt.Window;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowFocusListener;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n@@ -33,0 +52,1 @@\n+import java.util.Arrays;\n@@ -34,0 +54,1 @@\n+import sun.awt.X11.XBaseWindow;\n@@ -433,0 +454,87 @@\n+\n+    private static volatile Boolean isOnWayland = null;\n+\n+    @SuppressWarnings(\"removal\")\n+    public static boolean isOnWayland() {\n+        Boolean result = isOnWayland;\n+        if (result == null) {\n+            synchronized (GTK_LOCK) {\n+                result = isOnWayland;\n+                if (result == null) {\n+                    isOnWayland\n+                            = result\n+                            = AccessController.doPrivileged(\n+                            (PrivilegedAction<Boolean>) () -> {\n+                                final String display =\n+                                        System.getenv(\"WAYLAND_DISPLAY\");\n+\n+                                return display != null\n+                                        && !display.trim().isEmpty();\n+                            }\n+                    );\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean isRunningOnWayland() {\n+        return isOnWayland();\n+    }\n+\n+    \/\/ We rely on the X11 input grab mechanism, but for the Wayland session\n+    \/\/ it only works inside the XWayland server, so mouse clicks outside of it\n+    \/\/ will not be detected.\n+    \/\/ (window decorations, pure Wayland applications, desktop, etc.)\n+    \/\/\n+    \/\/ As a workaround, we can dismiss menus when the window loses focus.\n+    \/\/\n+    \/\/ However, there are \"blind spots\" though, which, when clicked, don't\n+    \/\/ transfer the focus away and don't dismiss the menu\n+    \/\/ (e.g. the window's own title or the area in the side dock without\n+    \/\/ application icons).\n+    private static final WindowFocusListener waylandWindowFocusListener;\n+\n+    static {\n+        if (isOnWayland()) {\n+            waylandWindowFocusListener = new WindowAdapter() {\n+                @Override\n+                public void windowLostFocus(WindowEvent e) {\n+                    Window window = e.getWindow();\n+                    window.removeWindowFocusListener(this);\n+\n+                    \/\/ AWT\n+                    XBaseWindow.ungrabInput();\n+\n+                    \/\/ Swing\n+                    window.dispatchEvent(new UngrabEvent(window));\n+                }\n+            };\n+        } else {\n+            waylandWindowFocusListener = null;\n+        }\n+    }\n+\n+    @Override\n+    public void dismissPopupOnFocusLostIfNeeded(Window invoker) {\n+        if (!isOnWayland()\n+                || invoker == null\n+                || Arrays\n+                    .asList(invoker.getWindowFocusListeners())\n+                    .contains(waylandWindowFocusListener)\n+        ) {\n+            return;\n+        }\n+\n+        invoker.addWindowFocusListener(waylandWindowFocusListener);\n+    }\n+\n+    @Override\n+    public void dismissPopupOnFocusLostIfNeededCleanUp(Window invoker) {\n+        if (!isOnWayland() || invoker == null) {\n+            return;\n+        }\n+\n+        invoker.removeWindowFocusListener(waylandWindowFocusListener);\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/UNIXToolkit.java","additions":110,"deletions":2,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,7 @@\n-import java.awt.*;\n-import sun.awt.*;\n-import java.util.*;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import sun.awt.SunToolkit;\n@@ -915,1 +919,1 @@\n-    static void ungrabInput() {\n+    public static void ungrabInput() {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XBaseWindow.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,7 @@\n-import java.awt.*;\n-import java.awt.peer.*;\n-import java.awt.event.*;\n-\n-import java.awt.image.BufferedImage;\n-import java.awt.geom.Point2D;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.MenuItem;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n@@ -35,0 +36,2 @@\n+\n+import sun.awt.SunToolkit;\n@@ -37,0 +40,2 @@\n+import javax.swing.SwingUtilities;\n+\n@@ -392,0 +397,10 @@\n+    protected Window getMenuTarget() {\n+        if (target instanceof Window targetWindow) {\n+            return targetWindow;\n+        } else {\n+            return target == null\n+                    ? null\n+                    : SwingUtilities.getWindowAncestor(target);\n+        }\n+    }\n+\n@@ -408,0 +423,3 @@\n+            if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+                sunToolkit.dismissPopupOnFocusLostIfNeeded(getMenuTarget());\n+            }\n@@ -424,0 +442,3 @@\n+        if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+            sunToolkit.dismissPopupOnFocusLostIfNeededCleanUp(getMenuTarget());\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMenuWindow.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,16 @@\n-import java.awt.*;\n-import java.awt.peer.*;\n-import java.awt.event.*;\n-\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Event;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.MenuItem;\n+import java.awt.Point;\n+import java.awt.PopupMenu;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+\n+import java.awt.peer.PopupMenuPeer;\n@@ -33,0 +45,1 @@\n+import sun.awt.SunToolkit;\n@@ -128,0 +141,3 @@\n+            if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+                sunToolkit.dismissPopupOnFocusLostIfNeeded(getMenuTarget());\n+            }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XPopupMenuPeer.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -345,0 +345,7 @@\n+    protected long getTotalThreadAllocatedBytes() {\n+        if (isThreadAllocatedMemoryEnabled()) {\n+            return getTotalThreadAllocatedMemory();\n+        }\n+        return -1;\n+    }\n+\n@@ -528,0 +535,1 @@\n+    private static native long getTotalThreadAllocatedMemory();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n+    return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n@@ -111,0 +111,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_ThreadImpl_getTotalThreadAllocatedMemory\n+  (JNIEnv *env, jclass cls)\n+{\n+    return jmm_interface->GetTotalThreadAllocatedMemory(env);\n+}\n+\n","filename":"src\/java.management\/share\/native\/libmanagement\/ThreadImpl.c","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Locale;\n@@ -93,1 +94,1 @@\n-        String peerName = \"HTTP@\" + hci.host.toLowerCase();\n+        String peerName = \"HTTP@\" + hci.host.toLowerCase(Locale.ROOT);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,0 +212,8 @@\n+        algorithmsMap.put(\n+            XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED25519,\n+            new Algorithm(\"Ed25519\", \"Ed25519\", \"Signature\")\n+        );\n+        algorithmsMap.put(\n+            XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED448,\n+            new Algorithm(\"Ed448\", \"Ed448\", \"Signature\")\n+        );\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/JCEMapper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,4 +34,1 @@\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.IntegrityHmac;\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureBaseRSA;\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureDSA;\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureECDSA;\n+import com.sun.org.apache.xml.internal.security.algorithms.implementations.*;\n@@ -499,0 +496,6 @@\n+        algorithmHash.put(\n+                XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED25519, SignatureEDDSA.SignatureEd25519.class\n+        );\n+        algorithmHash.put(\n+                XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED448, SignatureEDDSA.SignatureEd448.class\n+        );\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/SignatureAlgorithm.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Iterator;\n@@ -789,3 +788,1 @@\n-        Iterator<ECCurveDefinition> ecCurveDefinitionIterator = ecCurveDefinitions.iterator();\n-        while (ecCurveDefinitionIterator.hasNext()) {\n-            ECCurveDefinition ecCurveDefinition = ecCurveDefinitionIterator.next();\n+        for (ECCurveDefinition ecCurveDefinition : ecCurveDefinitions) {\n@@ -801,3 +798,1 @@\n-        Iterator<ECCurveDefinition> ecCurveDefinitionIterator = ecCurveDefinitions.iterator();\n-        while (ecCurveDefinitionIterator.hasNext()) {\n-            ECCurveDefinition ecCurveDefinition = ecCurveDefinitionIterator.next();\n+        for (ECCurveDefinition ecCurveDefinition : ecCurveDefinitions) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/ECDSAUtils.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package com.sun.org.apache.xml.internal.security.algorithms.implementations;\n+\n+import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;\n+import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithmSpi;\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignature;\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignatureException;\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n+\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ *\n+ *\/\n+public abstract class SignatureEDDSA extends SignatureAlgorithmSpi {\n+\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+        com.sun.org.slf4j.internal.LoggerFactory.getLogger(SignatureEDDSA.class);\n+\n+    private final Signature signatureAlgorithm;\n+\n+\n+    \/**\n+     * Constructor SignatureEDDSA\n+     *\n+     * @throws XMLSignatureException\n+     *\/\n+    public SignatureEDDSA() throws XMLSignatureException {\n+        this(null);\n+    }\n+\n+    public SignatureEDDSA(Provider provider) throws XMLSignatureException {\n+        String algorithmID = JCEMapper.translateURItoJCEID(this.engineGetURI());\n+        LOG.debug(\"Created SignatureEDDSA using {}\", algorithmID);\n+\n+        try {\n+            if (provider == null) {\n+                String providerId = JCEMapper.getProviderId();\n+                if (providerId == null) {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+\n+                } else {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID, providerId);\n+                }\n+\n+            } else {\n+                this.signatureAlgorithm = Signature.getInstance(algorithmID, provider);\n+            }\n+\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException ex) {\n+            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n+            throw new XMLSignatureException(\"algorithms.NoSuchAlgorithm\", exArgs);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+        throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.setParameter(params);\n+        } catch (InvalidAlgorithmParameterException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected boolean engineVerify(byte[] signature) throws XMLSignatureException {\n+        try {\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Called SignatureEDDSA.verify() on \" + XMLUtils.encodeToString(signature));\n+            }\n+\n+            return this.signatureAlgorithm.verify(signature);\n+        } catch (SignatureException  ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitVerify(Key publicKey) throws XMLSignatureException {\n+        engineInitVerify(publicKey, signatureAlgorithm);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected byte[] engineSign() throws XMLSignatureException {\n+        try {\n+            return this.signatureAlgorithm.sign();\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitSign(Key privateKey, SecureRandom secureRandom)\n+        throws XMLSignatureException {\n+\n+        engineInitSign(privateKey, secureRandom, this.signatureAlgorithm);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitSign(Key privateKey) throws XMLSignatureException {\n+        engineInitSign(privateKey, (SecureRandom)null);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineUpdate(byte[] input) throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.update(input);\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineUpdate(byte input) throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.update(input);\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineUpdate(byte[] buf, int offset, int len) throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.update(buf, offset, len);\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected String engineGetJCEAlgorithmString() {\n+        return this.signatureAlgorithm.getAlgorithm();\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected String engineGetJCEProviderName() {\n+        return this.signatureAlgorithm.getProvider().getName();\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineSetHMACOutputLength(int HMACOutputLength)\n+        throws XMLSignatureException {\n+        throw new XMLSignatureException(\"algorithms.HMACOutputLengthOnlyForHMAC\");\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitSign(\n+        Key signingKey, AlgorithmParameterSpec algorithmParameterSpec\n+    ) throws XMLSignatureException {\n+        throw new XMLSignatureException(\"algorithms.CannotUseAlgorithmParameterSpecOnEdDSA\");\n+    }\n+\n+    \/**\n+     * Class SignatureEd25519\n+     *\n+     *\/\n+    public static class SignatureEd25519 extends SignatureEDDSA {\n+        \/**\n+         * Constructor SignatureEd25519\n+         *\n+         * @throws XMLSignatureException\n+         *\/\n+        public SignatureEd25519() throws XMLSignatureException {\n+            super();\n+        }\n+\n+        public SignatureEd25519(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n+        \/** {@inheritDoc} *\/\n+        @Override\n+        public String engineGetURI() {\n+            return XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED25519;\n+        }\n+    }\n+\n+    \/**\n+     * Class SignatureEd448\n+     *\/\n+    public static class SignatureEd448 extends SignatureEDDSA {\n+\n+        \/**\n+         * Constructor SignatureEd448\n+         *\n+         * @throws XMLSignatureException\n+         *\/\n+        public SignatureEd448() throws XMLSignatureException {\n+            super();\n+        }\n+\n+        public SignatureEd448(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n+        \/** {@inheritDoc} *\/\n+        @Override\n+        public String engineGetURI() {\n+            return XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED448;\n+        }\n+    }\n+}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureEDDSA.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Iterator;\n@@ -461,1 +460,2 @@\n-    protected int isVisibleDO(Node currentNode, int level) {\n+    protected int isVisibleDO(Node currentNode, int level)\n+            throws CanonicalizationException {\n@@ -463,5 +463,8 @@\n-            Iterator<NodeFilter> it = nodeFilter.iterator();\n-            while (it.hasNext()) {\n-                int i = it.next().isNodeIncludeDO(currentNode, level);\n-                if (i != 1) {\n-                    return i;\n+            for (NodeFilter filter : nodeFilter) {\n+                try {\n+                    int i = filter.isNodeIncludeDO(currentNode, level);\n+                    if (i != 1) {\n+                        return i;\n+                    }\n+                } catch (Exception e) {\n+                    throw new CanonicalizationException(e);\n@@ -477,1 +480,2 @@\n-    protected int isVisibleInt(Node currentNode) {\n+    protected int isVisibleInt(Node currentNode)\n+            throws CanonicalizationException {\n@@ -479,5 +483,8 @@\n-            Iterator<NodeFilter> it = nodeFilter.iterator();\n-            while (it.hasNext()) {\n-                int i = it.next().isNodeInclude(currentNode);\n-                if (i != 1) {\n-                    return i;\n+            for (NodeFilter filter : nodeFilter) {\n+                try {\n+                    int i = filter.isNodeInclude(currentNode);\n+                    if (i != 1) {\n+                        return i;\n+                    }\n+                } catch (Exception e) {\n+                    throw new CanonicalizationException(e);\n@@ -493,1 +500,1 @@\n-    protected boolean isVisible(Node currentNode) {\n+    protected boolean isVisible(Node currentNode) throws CanonicalizationException {\n@@ -495,4 +502,7 @@\n-            Iterator<NodeFilter> it = nodeFilter.iterator();\n-            while (it.hasNext()) {\n-                if (it.next().isNodeInclude(currentNode) != 1) {\n-                    return false;\n+            for (NodeFilter filter : nodeFilter) {\n+                try {\n+                    if (filter.isNodeInclude(currentNode) != 1) {\n+                        return false;\n+                    }\n+                } catch (Exception e) {\n+                    throw new CanonicalizationException(e);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/CanonicalizerBase.java","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Iterator;\n@@ -53,1 +52,1 @@\n-    \/**The map betwen prefix-> entry table. *\/\n+    \/**The map between prefix-> entry table. *\/\n@@ -61,1 +60,1 @@\n-     * Default constractor\n+     * Default constructor\n@@ -78,3 +77,1 @@\n-        Iterator<NameSpaceSymbEntry> it = symb.entrySet().iterator();\n-        while (it.hasNext()) {\n-            NameSpaceSymbEntry n = it.next();\n+        for (NameSpaceSymbEntry n : symb.entrySet()) {\n@@ -173,1 +170,1 @@\n-        \/\/ Return the node for outputing.\n+        \/\/ Return the node for outputting.\n@@ -180,1 +177,1 @@\n-     * @param prefix The prefix whose definition is neaded.\n+     * @param prefix The prefix whose definition is needed.\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/NameSpaceSymbTable.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-                Iterator<Attr> it = col.iterator();\n@@ -135,2 +134,1 @@\n-                while (it.hasNext()) {\n-                    Attr n = it.next();\n+                for (Attr n : col) {\n@@ -143,3 +141,1 @@\n-                it = baseAttrs.iterator();\n-                while (it.hasNext()) {\n-                    Attr n = it.next();\n+                for (Attr n : baseAttrs) {\n@@ -165,3 +161,1 @@\n-                Iterator<Attr> it = e.nodes.iterator();\n-                while (it.hasNext()) {\n-                    Attr n = it.next();\n+                for (Attr n : e.nodes) {\n@@ -355,1 +349,1 @@\n-                \/\/ else delte it.; otherwise,\n+                \/\/ else delete it.; otherwise,\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/XmlAttrStack.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * @return the managment data\n+     * @return the management data\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/MgmtData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Iterator;\n@@ -286,1 +285,0 @@\n-        Iterator<Node> it = set.iterator();\n@@ -288,2 +286,1 @@\n-        while (it.hasNext()) {\n-            Node currentNode = it.next();\n+        for (Node currentNode : set) {\n@@ -297,1 +294,1 @@\n-        \/\/ Obtain all the parents of the elemnt\n+        \/\/ Obtain all the parents of the element\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/RetrievalMethodResolver.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+\n+      <SignatureAlgorithm URI=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\"\n+                          JAVACLASS=\"com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureEDDSA$SignatureEd25519\" \/>\n+      <SignatureAlgorithm URI=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\"\n+                          JAVACLASS=\"com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureEDDSA$SignatureEd448\" \/>\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/config.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Iterator;\n@@ -360,4 +359,0 @@\n-                        Iterator<Node> nlIterator = nl.iterator();\n-\n-                        while (nlIterator.hasNext()) {\n-                            Node n = nlIterator.next();\n@@ -365,0 +360,1 @@\n+                        for (Node n : nl) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/Manifest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import com.sun.org.apache.xml.internal.security.transforms.TransformationException;\n@@ -40,1 +41,1 @@\n-    int isNodeInclude(Node n);\n+    int isNodeInclude(Node n) throws TransformationException;\n@@ -53,1 +54,1 @@\n-    int isNodeIncludeDO(Node n, int level);\n+    int isNodeIncludeDO(Node n, int level) throws TransformationException;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/NodeFilter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * $todo$ if we remove childen, the boolean values are not updated\n+ * $todo$ if we remove children, the boolean values are not updated\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/ObjectContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     * Constructs {@link SignatureProperty} using sepcified {@code target} attribute and\n+     * Constructs {@link SignatureProperty} using specified {@code target} attribute and\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/SignatureProperty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-     * of verified referenes associated with this Manifest\n+     * of verified references associated with this Manifest\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/VerifiedReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,0 +204,8 @@\n+    \/**Signature - EDDSA ED25519 *\/\n+    public static final String ALGO_ID_SIGNATURE_EDDSA_ED25519 =\n+            \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\";\n+\n+    \/**Signature - EDDSA ED448 *\/\n+    public static final String ALGO_ID_SIGNATURE_EDDSA_ED448 =\n+            \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\";\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignature.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-     * @param xmlSignatureInput the signatur to pretty print\n+     * @param xmlSignatureInput the signature to pretty print\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignatureInputDebugger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-     * @param input input {@link XMLSignatureInput} which can supplied Octect\n+     * @param input input {@link XMLSignatureInput} which can supplied Octet\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/Transform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,0 +23,3 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n@@ -27,0 +30,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.Security;\n@@ -36,4 +42,1 @@\n-import com.sun.org.apache.xml.internal.security.utils.Constants;\n-import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n-import com.sun.org.apache.xml.internal.security.utils.XPathAPI;\n-import com.sun.org.apache.xml.internal.security.utils.XPathFactory;\n+import com.sun.org.apache.xml.internal.security.utils.*;\n@@ -55,2 +58,19 @@\n-    private static final com.sun.org.slf4j.internal.Logger LOG =\n-            com.sun.org.slf4j.internal.LoggerFactory.getLogger(TransformXPath.class);\n+    \/\/ Whether the here() XPath function is supported.\n+    static final boolean HEREFUNC;\n+\n+    static {\n+        @SuppressWarnings(\"removal\")\n+        String prop =\n+                AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(\"jdk.xml.dsig.hereFunctionSupported\"));\n+        if (prop == null) {\n+            HEREFUNC = true; \/\/ default true\n+        } else if (prop.equals(\"true\")) {\n+            HEREFUNC = true;\n+        } else if (prop.equals(\"false\")) {\n+            HEREFUNC = false;\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"Invalid jdk.xml.dsig.hereFunctionSupported setting: \" + prop);\n+        }\n+    }\n@@ -115,1 +135,3 @@\n-        return XPathFactory.newInstance();\n+        return HEREFUNC\n+                ? XPathFactory.newInstance()\n+                : new JDKXPathFactory();\n@@ -143,1 +165,1 @@\n-        public int isNodeInclude(Node currentNode) {\n+        public int isNodeInclude(Node currentNode) throws TransformationException {\n@@ -150,3 +172,2 @@\n-            } catch (TransformerException e) {\n-                LOG.debug(\"Error evaluating XPath expression\", e);\n-                return 0;\n+            } catch (TransformerException ex) {\n+                throw new TransformationException(ex);\n@@ -156,1 +177,1 @@\n-        public int isNodeIncludeDO(Node n, int level) {\n+        public int isNodeIncludeDO(Node n, int level) throws TransformationException {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.JDKXPathFactory;\n@@ -97,1 +98,3 @@\n-            XPathFactory xpathFactory = XPathFactory.newInstance();\n+            XPathFactory xpathFactory = TransformXPath.HEREFUNC\n+                    ? XPathFactory.newInstance()\n+                    : new JDKXPathFactory();\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath2Filter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * translates a message ID into an internationalized String, see alse\n+     * translates a message ID into an internationalized String, see also\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/I18n.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,2 +471,2 @@\n-        String trimed = str.trim();\n-        int i = str.indexOf(trimed) + trimed.length();\n+        String trimmed = str.trim();\n+        int i = str.indexOf(trimmed) + trimmed.length();\n@@ -474,3 +474,3 @@\n-        if (str.length() > i && trimed.endsWith(\"\\\\\")\n-            && !trimed.endsWith(\"\\\\\\\\\") && str.charAt(i) == ' ') {\n-            trimed = trimed + \" \";\n+        if (str.length() > i && trimmed.endsWith(\"\\\\\")\n+            && !trimmed.endsWith(\"\\\\\\\\\") && str.charAt(i) == ' ') {\n+            trimmed = trimmed + \" \";\n@@ -479,1 +479,1 @@\n-        return trimed;\n+        return trimmed;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/RFC2253Parser.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * defined in the <a href=\"http:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * defined in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n@@ -54,0 +54,6 @@\n+ * <p>\n+ * The digest method algorithm URIs defined in this class are specified\n+ * in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * W3C Recommendation for XML-Signature Syntax and Processing<\/a>\n+ * and <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9231\">\n+ * RFC 9231: Additional XML Security Uniform Resource Identifiers (URIs)<\/a>\n@@ -62,2 +68,0 @@\n-    \/\/ All methods can be found in RFC 6931.\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/DigestMethod.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * as defined in the <a href=\"http:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * as defined in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n@@ -55,0 +55,6 @@\n+ * <p>\n+ * The signature method algorithm URIs defined in this class are specified\n+ * in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * W3C Recommendation for XML-Signature Syntax and Processing<\/a>\n+ * and <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9231\">\n+ * RFC 9231: Additional XML Security Uniform Resource Identifiers (URIs)<\/a>\n@@ -63,2 +69,0 @@\n-    \/\/ All methods can be found in RFC 6931.\n-\n@@ -258,0 +262,16 @@\n+    \/**\n+     * The <a href=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\">\n+     * ED25519<\/a> signature method algorithm URI.\n+     *\n+     * @since 21\n+     *\/\n+    String ED25519 = \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\";\n+\n+    \/**\n+     * The <a href=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\">\n+     * ED448<\/a> signature method algorithm URI.\n+     *\n+     * @since 21\n+     *\/\n+    String ED448 = \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\";\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/SignatureMethod.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    enum Type { DSA, RSA, ECDSA, HMAC }\n+    enum Type { DSA, RSA, ECDSA, EDDSA, HMAC }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/AbstractDOMSignatureMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+import com.sun.org.apache.xml.internal.security.transforms.TransformationException;\n@@ -49,4 +51,0 @@\n-        if (xi.getNodeFilters() != null && !xi.getNodeFilters().isEmpty()) {\n-            return Collections.unmodifiableSet\n-                (getNodeSet(xi.getNodeFilters())).iterator();\n-        }\n@@ -54,0 +52,4 @@\n+            if (xi.getNodeFilters() != null && !xi.getNodeFilters().isEmpty()) {\n+                return Collections.unmodifiableSet\n+                        (getNodeSet(xi.getNodeFilters())).iterator();\n+            }\n@@ -66,1 +68,2 @@\n-    private Set<Node> getNodeSet(List<NodeFilter> nodeFilters) {\n+    private Set<Node> getNodeSet(List<NodeFilter> nodeFilters)\n+            throws TransformationException {\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheNodeSetData.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -85,0 +85,6 @@\n+    \/\/ see RFC 9231 for these algorithm definitions\n+    static final String ED25519 =\n+        \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\";\n+    static final String ED448 =\n+        \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\";\n+\n@@ -223,0 +229,4 @@\n+        } else if (alg.equals(ED25519)) {\n+            return new EDDSA_ED25519(smElem);\n+        } else if (alg.equals(ED448)) {\n+            return new EDDSA_ED448(smElem);\n@@ -545,0 +555,33 @@\n+    abstract static class AbstractEDDSASignatureMethod\n+            extends DOMSignatureMethod {\n+\n+\n+        AbstractEDDSASignatureMethod(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        AbstractEDDSASignatureMethod(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+\n+        \/**\n+         * Returns {@code sig}. No extra formatting is necessary for EDDSA\n+         * See the RFC8032\n+         *\/\n+        @Override\n+        byte[] postSignFormat(Key key, byte[] sig) {\n+            return sig;\n+        }\n+\n+        \/**\n+         * Returns {@code sig}. No extra formatting is necessary for EDDSA\n+         * See the RFC8032\n+         *\/\n+        @Override\n+        byte[] preVerifyFormat(Key key, byte[] sig) {\n+            return sig;\n+        }\n+\n+    }\n+\n@@ -1024,0 +1067,52 @@\n+    static final class EDDSA_ED25519 extends AbstractEDDSASignatureMethod {\n+\n+        EDDSA_ED25519(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        EDDSA_ED25519(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return ED25519;\n+        }\n+\n+        @Override\n+        String getJCAAlgorithm() {\n+            return \"Ed25519\";\n+        }\n+\n+        @Override\n+        Type getAlgorithmType() {\n+            return Type.EDDSA;\n+        }\n+    }\n+\n+    static final class EDDSA_ED448 extends AbstractEDDSASignatureMethod {\n+        EDDSA_ED448(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        EDDSA_ED448(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return ED448;\n+        }\n+\n+        @Override\n+        String getJCAAlgorithm() {\n+            return \"Ed448\";\n+        }\n+\n+        @Override\n+        Type getAlgorithmType() {\n+            return Type.EDDSA;\n+        }\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignatureMethod.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -305,0 +305,4 @@\n+        } else if (algorithm.equals(DOMSignatureMethod.ED25519)) {\n+            return new DOMSignatureMethod.EDDSA_ED25519(params);\n+        } else if (algorithm.equals(DOMSignatureMethod.ED448)) {\n+            return new DOMSignatureMethod.EDDSA_ED448(params);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXMLSignatureFactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        \/\/ Apache Santuario XML Security for Java, version 2.3.0\n+        \/\/ Apache Santuario XML Security for Java, version 3.0.2\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/XMLDSigRI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,18 +1,1 @@\n-## Apache Santuario v2.3.0\n-\n-### Apache Santuario Notice\n-<pre>\n-\n-  Apache Santuario - XML Security for Java\n-  Copyright 1999-2021 The Apache Software Foundation\n-\n-  This product includes software developed at\n-  The Apache Software Foundation (http:\/\/www.apache.org\/).\n-\n-  It was originally based on software copyright (c) 2001, Institute for\n-  Data Communications Systems, <http:\/\/www.nue.et-inf.uni-siegen.de\/>.\n-\n-  The development of this software was partly funded by the European\n-  Commission in the <WebSig> project in the ISIS Programme.\n-\n-<\/pre>\n+## Apache Santuario v3.0.2\n@@ -21,1 +4,1 @@\n-<pre>\n+```\n@@ -225,1 +208,20 @@\n-<\/pre>\n+```\n+\n+### Apache Santuario Notice\n+```\n+\n+Apache Santuario - XML Security for Java\n+Copyright 1999-2023 The Apache Software Foundation\n+\n+This product includes software developed at\n+The Apache Software Foundation (http:\/\/www.apache.org\/).\n+\n+It was originally based on software copyright (c) 2001, Institute for\n+Data Communications Systems, <http:\/\/www.nue.et-inf.uni-siegen.de\/>.\n+\n+The development of this software was partly funded by the European\n+Commission in the <WebSig> project in the ISIS Programme.\n+\n+This product contains software that is\n+copyright (c) 2021, Oracle and\/or its affiliates.\n+```\n","filename":"src\/java.xml.crypto\/share\/legal\/santuario.md","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a binding pattern that matches a pattern\n+ * with a variable of any name and a type of the match candidate;\n+ * an unnamed pattern.\n+ *\n+ * For example the use of underscore {@code _} below:\n+ * <pre>\n+ *   if (r instanceof R(_)) {}\n+ * <\/pre>\n+ *\n+ * @jls 14.30.1 Kinds of Patterns\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+public interface AnyPatternTree extends PatternTree {\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/AnyPatternTree.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -33,1 +31,1 @@\n- * @since 17\n+ * @since 21\n@@ -35,1 +33,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseLabelTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -75,1 +73,1 @@\n-     * @since 17\n+     * @since 21\n@@ -77,1 +75,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -80,0 +77,8 @@\n+    \/**\n+     * The guard for the case.\n+     *\n+     * @return the guard\n+     * @since 21\n+     *\/\n+    ExpressionTree getGuard();\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseTree.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -32,1 +30,1 @@\n- * @since 19\n+ * @since 21\n@@ -34,1 +32,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ConstantCaseLabelTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -34,1 +33,1 @@\n- * @since 19\n+ * @since 21\n@@ -36,1 +35,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -32,1 +30,1 @@\n- * @since 17\n+ * @since 21\n@@ -34,1 +32,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultCaseLabelTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -46,17 +44,0 @@\n-    \/**\n-     * \"Enhanced\" {@code for} declarations come in two forms:\n-     * <ul>\n-     * <li> local variable declarations and\n-     * <li> record patterns\n-     * <\/ul>\n-     *\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    public enum DeclarationKind {\n-        \/** enum constant for local variable declarations *\/\n-        VARIABLE,\n-        \/** enum constant for record pattern declarations *\/\n-        PATTERN\n-    }\n-\n@@ -65,1 +46,1 @@\n-     * @return the control variable, or {@code null} if this \"enhanced\" {@code for} uses a pattern\n+     * @return the control variable\n@@ -69,8 +50,0 @@\n-    \/**\n-     * Returns the control variable or pattern for the loop.\n-     * @return the control variable or pattern\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    Tree getVariableOrRecordPattern();\n-\n@@ -88,8 +61,0 @@\n-\n-    \/**\n-     * Returns the kind of the declaration of the \"enhanced\" {@code for}.\n-     * @return the kind of the declaration\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    DeclarationKind getDeclarationKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/EnhancedForLoopTree.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -46,16 +44,0 @@\n-    \/**\n-     * Two possible variants of instanceof expressions:\n-     * <ul>\n-     * <li> testing types, and\n-     * <li> performing pattern matching\n-     * <\/ul>\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    public enum TestKind {\n-        \/** instanceof only testing a type *\/\n-        TYPE,\n-        \/** instanceof doing a pattern matching *\/\n-        PATTERN\n-    }\n-\n@@ -96,8 +78,0 @@\n-    \/**\n-     * Returns the kind of this instanceof expression.\n-     *\n-     * @return the kind of this instanceof expression\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    TestKind getTestKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/InstanceOfTree.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * A tree node for a parenthesized pattern.\n- *\n- * For example:\n- * <pre>\n- *   ( <em>pattern<\/em> )\n- * <\/pre>\n- *\n- * @jls 14.30.1 Kinds of Patterns\n- *\n- * @since 17\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-public interface ParenthesizedPatternTree extends PatternTree {\n-    \/**\n-     * Returns the pattern within the parentheses.\n-     * @return the pattern\n-     *\/\n-    PatternTree getPattern();\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ParenthesizedPatternTree.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -32,1 +30,1 @@\n- * @since 19\n+ * @since 21\n@@ -34,1 +32,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -44,7 +41,0 @@\n-    \/**\n-     * The guard for the case.\n-     *\n-     * @return the guard\n-     *\/\n-    ExpressionTree getGuard();\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternCaseLabelTree.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-         * @since 16\n+         * @since 21\n@@ -235,1 +235,2 @@\n-        BINDING_PATTERN(BindingPatternTree.class),\n+        @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+        ANY_PATTERN(AnyPatternTree.class),\n@@ -238,1 +239,1 @@\n-         * Used for instances of {@link ParenthesizedPatternTree}.\n+         * Used for instances of {@link BindingPatternTree}.\n@@ -240,1 +241,1 @@\n-         * @since 17\n+         * @since 16\n@@ -242,2 +243,1 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-        PARENTHESIZED_PATTERN(ParenthesizedPatternTree.class),\n+        BINDING_PATTERN(BindingPatternTree.class),\n@@ -248,1 +248,1 @@\n-         * @since 17\n+         * @since 21\n@@ -250,1 +250,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -256,1 +255,1 @@\n-         * @since 19\n+         * @since 21\n@@ -258,1 +257,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -264,1 +262,1 @@\n-         * @since 19\n+         * @since 21\n@@ -266,1 +264,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -272,1 +269,1 @@\n-         * @since 19\n+         * @since 21\n@@ -274,1 +271,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -271,0 +271,10 @@\n+    \/**\n+     * Visits a {@code AnyPatternTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+    R visitAnyPattern(AnyPatternTree node, P p);\n+\n@@ -285,1 +295,1 @@\n-     * @since 17\n+     * @since 21\n@@ -287,1 +297,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -295,1 +304,1 @@\n-     * @since 19\n+     * @since 21\n@@ -297,1 +306,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -305,1 +313,1 @@\n-     * @since 19\n+     * @since 21\n@@ -307,1 +315,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -315,1 +322,1 @@\n-     * @since 19\n+     * @since 21\n@@ -317,1 +324,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n@@ -344,10 +350,0 @@\n-    \/**\n-     * Visits a {@code ParenthesizedPatternTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     * @since 17\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    R visitParenthesizedPattern(ParenthesizedPatternTree node, P p);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-     * Returns the name of the variable being declared.\n+     * Returns the name of the variable being declared or empty name if both the variable\n+     * is unnamed and the preview features are enabled (Unnamed Patterns and Variables).\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/VariableTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -652,1 +652,1 @@\n-     * @since 14\n+     * @since 21\n@@ -655,1 +655,2 @@\n-    public R visitBindingPattern(BindingPatternTree node, P p) {\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+    public R visitAnyPattern(AnyPatternTree node, P p) {\n@@ -667,1 +668,1 @@\n-     * @since 17\n+     * @since 14\n@@ -670,2 +671,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+    public R visitBindingPattern(BindingPatternTree node, P p) {\n@@ -683,1 +683,1 @@\n-     * @since 19\n+     * @since 21\n@@ -686,2 +686,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitConstantCaseLabel(ConstantCaseLabelTree node, P p) {\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n@@ -699,1 +698,1 @@\n-     * @since 19\n+     * @since 21\n@@ -702,2 +701,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+    public R visitConstantCaseLabel(ConstantCaseLabelTree node, P p) {\n@@ -715,1 +713,1 @@\n-     * @since 19\n+     * @since 21\n@@ -718,2 +716,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitPatternCaseLabel(PatternCaseLabelTree node, P p) {\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n@@ -731,0 +728,1 @@\n+     * @since 21\n@@ -733,1 +731,1 @@\n-    public R visitArrayAccess(ArrayAccessTree node, P p) {\n+    public R visitPatternCaseLabel(PatternCaseLabelTree node, P p) {\n@@ -747,1 +745,1 @@\n-    public R visitMemberSelect(MemberSelectTree node, P p) {\n+    public R visitArrayAccess(ArrayAccessTree node, P p) {\n@@ -759,1 +757,0 @@\n-     * @since 17\n@@ -762,2 +759,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+    public R visitMemberSelect(MemberSelectTree node, P p) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-        R r = scan(node.getVariableOrRecordPattern(), p);\n+        R r = scan(node.getVariable(), p);\n@@ -400,0 +400,1 @@\n+        r = scanAndReduce(node.getGuard(), p, r);\n@@ -762,0 +763,15 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 21\n+     *\/\n+    @Override\n+    public R visitAnyPattern(AnyPatternTree node, P p) {\n+        return null;\n+    }\n+\n@@ -802,1 +818,1 @@\n-     * @since 17\n+     * @since 21\n@@ -805,1 +821,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -818,1 +833,1 @@\n-     * @since 19\n+     * @since 21\n@@ -821,1 +836,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -834,1 +848,1 @@\n-     * @since 19\n+     * @since 21\n@@ -837,1 +851,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -839,3 +852,1 @@\n-        R r = scan(node.getPattern(), p);\n-        r = scanAndReduce(node.getGuard(), p, r);\n-        return r;\n+        return scan(node.getPattern(), p);\n@@ -852,1 +863,1 @@\n-     * @since 19\n+     * @since 21\n@@ -855,1 +866,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n@@ -896,16 +906,0 @@\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     * @since 17\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n-        return scan(node.getPattern(), p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":22,"deletions":28,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -212,2 +212,0 @@\n-            case CASE_NULL -> true;\n-            case PATTERN_SWITCH -> true;\n@@ -215,3 +213,1 @@\n-            case UNCONDITIONAL_PATTERN_IN_INSTANCEOF -> true;\n-            case RECORD_PATTERNS -> true;\n-\n+            case UNNAMED_VARIABLES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -235,2 +235,2 @@\n-        CASE_NULL(JDK17, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n-        PATTERN_SWITCH(JDK17, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n+        CASE_NULL(JDK21, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n+        PATTERN_SWITCH(JDK21, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n@@ -238,0 +238,2 @@\n+        UNCONDITIONAL_PATTERN_IN_INSTANCEOF(JDK21, Fragments.FeatureUnconditionalPatternsInInstanceof, DiagKind.PLURAL),\n+        RECORD_PATTERNS(JDK21, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n@@ -239,2 +241,0 @@\n-        UNCONDITIONAL_PATTERN_IN_INSTANCEOF(JDK19, Fragments.FeatureUnconditionalPatternsInInstanceof, DiagKind.PLURAL),\n-        RECORD_PATTERNS(JDK19, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n@@ -242,0 +242,1 @@\n+        UNNAMED_VARIABLES(JDK21, Fragments.FeatureUnnamedVariables, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1644,0 +1644,1 @@\n+    @SuppressWarnings(\"preview\")\n@@ -1786,0 +1787,4 @@\n+\n+        public boolean isUnnamedVariable() {\n+            return name.isEmpty();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    public final Type nullPointerExceptionType;\n@@ -227,0 +226,1 @@\n+    public final Type constantBootstrapsType;\n@@ -229,0 +229,2 @@\n+    public final Type classDescType;\n+    public final Type enumDescType;\n@@ -568,1 +570,0 @@\n-        nullPointerExceptionType = enterClass(\"java.lang.NullPointerException\");\n@@ -612,0 +613,1 @@\n+        constantBootstrapsType = enterClass(\"java.lang.invoke.ConstantBootstraps\");\n@@ -614,0 +616,2 @@\n+        classDescType = enterClass(\"java.lang.constant.ClassDesc\");\n+        enumDescType = enterClass(\"java.lang.Enum$EnumDesc\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -429,2 +428,1 @@\n-            return tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE &&\n-                    !isImplicitlyTyped((JCVariableDecl) tree.varOrRecordPattern);\n+            return !isImplicitlyTyped(tree.var);\n@@ -434,2 +432,0 @@\n-            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n@@ -437,1 +433,1 @@\n-            newTree.varOrRecordPattern = rewriteVarType((JCVariableDecl) oldTree.varOrRecordPattern);\n+            newTree.var = rewriteVarType(oldTree.var);\n@@ -443,4 +439,1 @@\n-            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n-            processVar((JCVariableDecl) oldTree.varOrRecordPattern,\n-                           (JCVariableDecl) newTree.varOrRecordPattern, hasErrors);\n+            processVar(oldTree.var, newTree.var, hasErrors);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -174,2 +173,2 @@\n-        allowUnconditionalPatternsInstanceOf = (preview.isEnabled() || !preview.isPreview(Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF)) &&\n-                                     Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.allowedInSource(source);\n+        allowUnconditionalPatternsInstanceOf =\n+                             Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.allowedInSource(source);\n@@ -1517,1 +1516,0 @@\n-\n@@ -1524,2 +1522,2 @@\n-            tree.elementType = types.elemtype(exprType); \/\/ perhaps expr is an array?\n-            if (tree.elementType == null) {\n+            Type elemtype = types.elemtype(exprType); \/\/ perhaps expr is an array?\n+            if (elemtype == null) {\n@@ -1532,1 +1530,1 @@\n-                    tree.elementType = types.createErrorType(exprType);\n+                    elemtype = types.createErrorType(exprType);\n@@ -1535,1 +1533,1 @@\n-                    tree.elementType = iterableParams.isEmpty()\n+                    elemtype = iterableParams.isEmpty()\n@@ -1549,33 +1547,3 @@\n-            if (tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                if (jcVariableDecl.isImplicitlyTyped()) {\n-                    Type inferredType = chk.checkLocalVarType(jcVariableDecl, tree.elementType, jcVariableDecl.name);\n-                    setSyntheticVariableType(jcVariableDecl, inferredType);\n-                }\n-                attribStat(jcVariableDecl, loopEnv);\n-                chk.checkType(tree.expr.pos(), tree.elementType, jcVariableDecl.sym.type);\n-\n-                loopEnv.tree = tree; \/\/ before, we were not in loop!\n-                attribStat(tree.body, loopEnv);\n-            } else {\n-                Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN);\n-                JCRecordPattern jcRecordPattern = (JCRecordPattern) tree.varOrRecordPattern;\n-\n-                attribExpr(jcRecordPattern, loopEnv, tree.elementType);\n-\n-                \/\/ for(<pattern> x : xs) { y }\n-                \/\/ we include x's bindings when true in y\n-                \/\/ we don't do anything with x's bindings when false\n-\n-                MatchBindings forWithRecordPatternBindings = matchBindings;\n-                Env<AttrContext> recordPatternEnv = bindingEnv(loopEnv, forWithRecordPatternBindings.bindingsWhenTrue);\n-\n-                Type clazztype = jcRecordPattern.type;\n-\n-                checkCastablePattern(tree.expr.pos(), tree.elementType, clazztype);\n-\n-                recordPatternEnv.tree = tree; \/\/ before, we were not in loop!\n-                try {\n-                    attribStat(tree.body, recordPatternEnv);\n-                } finally {\n-                    recordPatternEnv.info.scope.leave();\n-                }\n+            if (tree.var.isImplicitlyTyped()) {\n+                Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);\n+                setSyntheticVariableType(tree.var, inferredType);\n@@ -1583,0 +1551,4 @@\n+            attribStat(tree.var, loopEnv);\n+            chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);\n+            loopEnv.tree = tree; \/\/ before, we were not in loop!\n+            attribStat(tree.body, loopEnv);\n@@ -1719,2 +1691,3 @@\n-                boolean wasUnconditionalPattern = hasUnconditionalPattern;\n-                for (JCCaseLabel label : c.labels) {\n+                MatchBindings guardBindings = null;\n+                for (List<JCCaseLabel> labels = c.labels; labels.nonEmpty(); labels = labels.tail) {\n+                    JCCaseLabel label = labels.head;\n@@ -1734,1 +1707,5 @@\n-                                log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                if (allowPatternSwitch) {\n+                                    attribTree(expr, switchEnv, caseLabelResultInfo(seltype));\n+                                } else {\n+                                    log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                }\n@@ -1750,4 +1727,1 @@\n-                            ResultInfo valTypInfo = new ResultInfo(KindSelector.VAL_TYP,\n-                                                                   !seltype.hasTag(ERROR) ? seltype\n-                                                                                          : Type.noType);\n-                            Type pattype = attribTree(expr, switchEnv, valTypInfo);\n+                            Type pattype = attribTree(expr, switchEnv, caseLabelResultInfo(seltype));\n@@ -1760,1 +1734,1 @@\n-                                    } else {\n+                                    } else if ((s != null && !s.isEnum()) || !allowPatternSwitch) {\n@@ -1789,2 +1763,2 @@\n-                        JCExpression guard = patternlabel.guard;\n-                        if (guard != null) {\n+                        JCExpression guard = c.guard;\n+                        if (guardBindings == null && guard != null) {\n@@ -1798,1 +1772,3 @@\n-                            matchBindings = matchBindingsComputer.caseGuard(c, afterPattern, matchBindings);\n+\n+                            guardBindings = matchBindings;\n+                            matchBindings = afterPattern;\n@@ -1804,1 +1780,1 @@\n-                        boolean unguarded = TreeInfo.unguardedCaseLabel(label) && !pat.hasTag(RECORDPATTERN);\n+                        boolean unguarded = TreeInfo.unguardedCase(c) && !pat.hasTag(RECORDPATTERN);\n@@ -1825,0 +1801,4 @@\n+                if (guardBindings != null) {\n+                    currentBindings = matchBindingsComputer.caseGuard(c, currentBindings, guardBindings);\n+                }\n+\n@@ -1857,0 +1837,5 @@\n+        private ResultInfo caseLabelResultInfo(Type seltype) {\n+            return new ResultInfo(KindSelector.VAL_TYP,\n+                                  !seltype.hasTag(ERROR) ? seltype\n+                                                         : Type.noType);\n+        }\n@@ -4104,1 +4089,0 @@\n-            tree.pattern.getTag() == PARENTHESIZEDPATTERN ||\n@@ -4112,3 +4096,2 @@\n-                    log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(exprtype, clazztype));\n-                } else if (preview.isPreview(Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF)) {\n-                    preview.warnPreview(tree.pattern.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF);\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                              Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n@@ -4171,0 +4154,5 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree.type = resultInfo.pt;\n+    }\n+\n@@ -4192,1 +4180,5 @@\n-        matchBindings = new MatchBindings(List.of(v), List.nil());\n+        if (v.isUnnamedVariable()) {\n+            matchBindings = MatchBindingsComputer.EMPTY;\n+        } else {\n+            matchBindings = new MatchBindings(List.of(v), List.nil());\n+        }\n@@ -4256,5 +4248,0 @@\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        attribExpr(tree.pattern, env);\n-        result = tree.type = tree.pattern.type;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":50,"deletions":63,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -4575,2 +4575,5 @@\n-            } else {\n-                if (c.labels.tail.nonEmpty()) {\n+            } else if (c.labels.tail.nonEmpty()) {\n+                var patterCaseLabels = c.labels.stream().filter(ll -> ll instanceof JCPatternCaseLabel).map(cl -> (JCPatternCaseLabel)cl);\n+                var allUnderscore = patterCaseLabels.allMatch(pcl -> !hasBindings(pcl.getPattern()));\n+\n+                if (!allUnderscore) {\n@@ -4611,1 +4614,1 @@\n-                bindings[0] = true;\n+                bindings[0] = !tree.var.sym.isUnnamedVariable();\n@@ -4629,1 +4632,1 @@\n-        List<JCCaseLabel> caseLabels = List.nil();\n+        List<Pair<JCCase, JCCaseLabel>> caseLabels = List.nil();\n@@ -4656,1 +4659,3 @@\n-                for (JCCaseLabel testCaseLabel : caseLabels) {\n+                for (Pair<JCCase, JCCaseLabel> caseAndLabel : caseLabels) {\n+                    JCCase testCase = caseAndLabel.fst;\n+                    JCCaseLabel testCaseLabel = caseAndLabel.snd;\n@@ -4666,1 +4671,1 @@\n-                                   TreeInfo.unguardedCaseLabel(testCaseLabel)) {\n+                                   TreeInfo.unguardedCase(testCase)) {\n@@ -4675,1 +4680,1 @@\n-                caseLabels = caseLabels.prepend(label);\n+                caseLabels = caseLabels.prepend(Pair.of(c, label));\n@@ -4700,6 +4705,0 @@\n-            while (existingPattern instanceof JCParenthesizedPattern parenthesized) {\n-                existingPattern = parenthesized.pattern;\n-            }\n-            while (currentPattern instanceof JCParenthesizedPattern parenthesized) {\n-                currentPattern = parenthesized.pattern;\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.StreamSupport;\n@@ -38,0 +36,1 @@\n+import com.sun.source.tree.CaseTree;\n@@ -41,1 +40,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -55,0 +53,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -58,1 +57,0 @@\n-import static com.sun.tools.javac.code.TypeTag.NONE;\n@@ -60,1 +58,0 @@\n-import com.sun.tools.javac.code.Types.UniqueType;\n@@ -64,0 +61,8 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.groupingBy;\n@@ -214,0 +219,1 @@\n+    private final Infer infer;\n@@ -337,0 +343,1 @@\n+        infer = Infer.instance(context);\n@@ -650,15 +657,1 @@\n-            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                visitVarDef(jcVariableDecl);\n-            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                visitRecordPattern(jcRecordPattern);\n-\n-                Set<Symbol> coveredSymbols =\n-                        coveredSymbols(jcRecordPattern.pos(), List.of(jcRecordPattern));\n-\n-                boolean isExhaustive =\n-                        isExhaustive(jcRecordPattern.pos(), tree.elementType, coveredSymbols);\n-\n-                if (!isExhaustive) {\n-                    log.error(tree, Errors.ForeachNotExhaustiveOnType(jcRecordPattern.type, tree.elementType));\n-                }\n-            }\n+            visitVarDef(tree.var);\n@@ -708,2 +701,1 @@\n-                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n-                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n+                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n@@ -743,1 +735,0 @@\n-            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -746,1 +737,1 @@\n-                                isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n+                                exhausts(tree.selector, tree.cases);\n@@ -754,23 +745,22 @@\n-        private Set<Symbol> coveredSymbolsForCases(DiagnosticPosition pos,\n-                                                   List<JCCase> cases) {\n-            HashSet<JCTree> labelValues = cases.stream()\n-                                               .flatMap(c -> c.labels.stream())\n-                                               .filter(TreeInfo::unguardedCaseLabel)\n-                                               .filter(l -> !l.hasTag(DEFAULTCASELABEL))\n-                                               .map(l -> l.hasTag(CONSTANTCASELABEL) ? ((JCConstantCaseLabel) l).expr\n-                                                                                     : ((JCPatternCaseLabel) l).pat)\n-                                               .collect(Collectors.toCollection(HashSet::new));\n-            return coveredSymbols(pos, labelValues);\n-        }\n-\n-        private Set<Symbol> coveredSymbols(DiagnosticPosition pos,\n-                                           Iterable<? extends JCTree> labels) {\n-            Set<Symbol> coveredSymbols = new HashSet<>();\n-            Map<UniqueType, List<JCRecordPattern>> deconstructionPatternsByType = new HashMap<>();\n-\n-            for (JCTree labelValue : labels) {\n-                switch (labelValue.getTag()) {\n-                    case BINDINGPATTERN, PARENTHESIZEDPATTERN -> {\n-                        Type primaryPatternType = TreeInfo.primaryPatternType((JCPattern) labelValue);\n-                        if (!primaryPatternType.hasTag(NONE)) {\n-                            coveredSymbols.add(primaryPatternType.tsym);\n+        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+            Set<PatternDescription> patternSet = new HashSet<>();\n+            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n+            for (JCCase c : cases) {\n+                if (!TreeInfo.unguardedCase(c))\n+                    continue;\n+\n+                for (var l : c.labels) {\n+                    if (l instanceof JCPatternCaseLabel patternLabel) {\n+                        for (Type component : components(selector.type)) {\n+                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n+                        }\n+                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n+                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                        if (s != null && s.isEnum()) {\n+                            enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                Set<Symbol> result = new HashSet<>();\n+                                s.owner.members()\n+                                       .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                       .forEach(result::add);\n+                                return result;\n+                            }).remove(s);\n@@ -779,8 +769,19 @@\n-                    case RECORDPATTERN -> {\n-                        JCRecordPattern dpat = (JCRecordPattern) labelValue;\n-                        UniqueType type = new UniqueType(dpat.type, types);\n-                        List<JCRecordPattern> augmentedPatterns =\n-                                deconstructionPatternsByType.getOrDefault(type, List.nil())\n-                                                                 .prepend(dpat);\n-\n-                        deconstructionPatternsByType.put(type, augmentedPatterns);\n+                }\n+            }\n+            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n+                if (e.getValue().isEmpty()) {\n+                    patternSet.add(new BindingPattern(e.getKey().type));\n+                }\n+            }\n+            List<PatternDescription> patterns = List.from(patternSet);\n+            try {\n+                boolean repeat = true;\n+                while (repeat) {\n+                    List<PatternDescription> updatedPatterns;\n+                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns);\n+                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                    repeat = updatedPatterns != patterns;\n+                    patterns = updatedPatterns;\n+                    if (checkCovered(selector.type, patterns)) {\n+                        return true;\n@@ -788,0 +789,7 @@\n+                }\n+                return checkCovered(selector.type, patterns);\n+            } catch (CompletionFailure cf) {\n+                chk.completionError(selector.pos(), cf);\n+                return true; \/\/error recovery\n+            }\n+        }\n@@ -789,5 +797,6 @@\n-                    default -> {\n-                        Assert.check(labelValue instanceof JCExpression, labelValue.getTag().name());\n-                        JCExpression expr = (JCExpression) labelValue;\n-                        if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n-                            coveredSymbols.add(((JCIdent) expr).sym);\n+        private boolean checkCovered(Type seltype, List<PatternDescription> patterns) {\n+            for (Type seltypeComponent : components(seltype)) {\n+                for (PatternDescription pd : patterns) {\n+                    if (pd instanceof BindingPattern bp &&\n+                        types.isSubtype(seltypeComponent, types.erasure(bp.type))) {\n+                        return true;\n@@ -797,57 +806,14 @@\n-            for (Entry<UniqueType, List<JCRecordPattern>> e : deconstructionPatternsByType.entrySet()) {\n-                if (e.getValue().stream().anyMatch(r -> r.nested.size() != r.record.getRecordComponents().size())) {\n-                    coveredSymbols.add(syms.errSymbol);\n-                } else if (coversDeconstructionFromComponent(pos, e.getKey().type, e.getValue(), 0)) {\n-                    coveredSymbols.add(e.getKey().type.tsym);\n-                }\n-            }\n-            return coveredSymbols;\n-        }\n-\n-        private boolean coversDeconstructionFromComponent(DiagnosticPosition pos,\n-                                                          Type recordType,\n-                                                          List<JCRecordPattern> deconstructionPatterns,\n-                                                          int component) {\n-            \/\/Given a set of record patterns for the same record, and a starting component,\n-            \/\/this method checks, whether the nested patterns for the components are exhaustive,\n-            \/\/i.e. represent all possible combinations.\n-            \/\/This is done by categorizing the patterns based on the type covered by the given\n-            \/\/starting component.\n-            \/\/For each such category, it is then checked if the nested patterns starting at the next\n-            \/\/component are exhaustive, by recursivelly invoking this method. If these nested patterns\n-            \/\/are exhaustive, the given covered type is accepted.\n-            \/\/All such covered types are then checked whether they cover the declared type of\n-            \/\/the starting component's declaration. If yes, the given set of patterns starting at\n-            \/\/the given component cover the given record exhaustivelly, and true is returned.\n-            List<? extends RecordComponent> components =\n-                    deconstructionPatterns.head.record.getRecordComponents();\n-\n-            if (components.size() == component) {\n-                \/\/no components remain to be checked:\n-                return true;\n-            }\n-\n-            \/\/for the first tested component, gather symbols covered by the nested patterns:\n-            Type instantiatedComponentType = types.memberType(recordType, components.get(component));\n-            List<JCPattern> nestedComponentPatterns = deconstructionPatterns.map(d -> d.nested.get(component));\n-            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos,\n-                                                                    nestedComponentPatterns);\n-\n-            \/\/for each of the symbols covered by the starting component, find all deconstruction patterns\n-            \/\/that have the given type, or its supertype, as a type of the starting nested pattern:\n-            Map<Symbol, List<JCRecordPattern>> coveredSymbol2Patterns = new HashMap<>();\n-\n-            for (JCRecordPattern deconstructionPattern : deconstructionPatterns) {\n-                JCPattern nestedPattern = deconstructionPattern.nested.get(component);\n-                Symbol componentPatternType;\n-                switch (nestedPattern.getTag()) {\n-                    case BINDINGPATTERN, PARENTHESIZEDPATTERN -> {\n-                        Type primaryPatternType =\n-                                TreeInfo.primaryPatternType(nestedPattern);\n-                        componentPatternType = primaryPatternType.tsym;\n-                    }\n-                    case RECORDPATTERN -> {\n-                        componentPatternType = ((JCRecordPattern) nestedPattern).record;\n-                    }\n-                    default -> {\n-                        throw Assert.error(\"Unexpected tree kind: \" + nestedPattern.getTag());\n+            return false;\n+        }\n+\n+        private List<Type> components(Type seltype) {\n+            return switch (seltype.getTag()) {\n+                case CLASS -> {\n+                    if (seltype.isCompound()) {\n+                        if (seltype.isIntersection()) {\n+                            yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                        .stream()\n+                                                                        .flatMap(t -> components(t).stream())\n+                                                                        .collect(List.collector());\n+                        }\n+                        yield List.nil();\n@@ -855,0 +821,1 @@\n+                    yield List.of(types.erasure(seltype));\n@@ -856,7 +823,91 @@\n-                for (Symbol currentType : coveredSymbolsForComponent) {\n-                    if (types.isSubtype(types.erasure(currentType.type),\n-                                        types.erasure(componentPatternType.type))) {\n-                        coveredSymbol2Patterns.put(currentType,\n-                                                   coveredSymbol2Patterns.getOrDefault(currentType,\n-                                                                                       List.nil())\n-                                              .prepend(deconstructionPattern));\n+                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n+                default -> List.of(types.erasure(seltype));\n+            };\n+        }\n+\n+        \/* In a set of patterns, search for a sub-set of binding patterns that\n+         * in combination exhaust their sealed supertype. If such a sub-set\n+         * is found, it is removed, and replaced with a binding pattern\n+         * for the sealed supertype.\n+         *\/\n+        private List<PatternDescription> reduceBindingPatterns(Type selectorType, List<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+\n+            for (PatternDescription pdOne : patterns) {\n+                if (pdOne instanceof BindingPattern bpOne) {\n+                    Set<PatternDescription> toRemove = new HashSet<>();\n+                    Set<PatternDescription> toAdd = new HashSet<>();\n+\n+                    for (Type sup : types.directSupertypes(bpOne.type)) {\n+                        ClassSymbol clazz = (ClassSymbol) sup.tsym;\n+\n+                        if (clazz.isSealed() && clazz.isAbstract() &&\n+                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                            !existingBindings.contains(clazz)) {\n+                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n+                            \/\/do not reduce to types unrelated to the selector type:\n+                            Type clazzErasure = types.erasure(clazz.type);\n+                            if (components(selectorType).stream()\n+                                                        .map(types::erasure)\n+                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                continue;\n+                            }\n+\n+                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n+                                Type instantiated;\n+                                if (csym.type.allparams().isEmpty()) {\n+                                    instantiated = csym.type;\n+                                } else {\n+                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n+                                }\n+\n+                                return instantiated != null && types.isCastable(selectorType, instantiated);\n+                            });\n+\n+                            for (PatternDescription pdOther : patterns) {\n+                                if (pdOther instanceof BindingPattern bpOther) {\n+                                    boolean reduces = false;\n+                                    Set<Symbol> currentPermittedSubTypes =\n+                                            allPermittedSubTypes((ClassSymbol) bpOther.type.tsym, s -> true);\n+\n+                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                        Symbol perm = it.next();\n+\n+                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                                types.erasure(perm.type))) {\n+                                                it.remove();\n+                                                continue PERMITTED;\n+                                            }\n+                                        }\n+                                        if (types.isSubtype(types.erasure(perm.type),\n+                                                            types.erasure(bpOther.type))) {\n+                                            it.remove();\n+                                            reduces = true;\n+                                        }\n+                                    }\n+\n+                                    if (reduces) {\n+                                        bindings.append(pdOther);\n+                                    }\n+                                }\n+                            }\n+\n+                            if (permitted.isEmpty()) {\n+                                toRemove.addAll(bindings);\n+                                toAdd.add(new BindingPattern(clazz.type));\n+                            }\n+                        }\n+                    }\n+\n+                    if (!toAdd.isEmpty() || !toRemove.isEmpty()) {\n+                        for (PatternDescription pd : toRemove) {\n+                            patterns = List.filter(patterns, pd);\n+                        }\n+                        for (PatternDescription pd : toAdd) {\n+                            patterns = patterns.prepend(pd);\n+                        }\n+                        return patterns;\n@@ -866,0 +917,11 @@\n+            return patterns;\n+        }\n+\n+        private Set<Symbol> allPermittedSubTypes(ClassSymbol root, Predicate<ClassSymbol> accept) {\n+            Set<Symbol> permitted = new HashSet<>();\n+            List<ClassSymbol> permittedSubtypesClosure = List.of(root);\n+\n+            while (permittedSubtypesClosure.nonEmpty()) {\n+                ClassSymbol current = permittedSubtypesClosure.head;\n+\n+                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n@@ -867,4 +929,3 @@\n-            \/\/Check the components following the starting component, for each of the covered symbol,\n-            \/\/if they are exhaustive. If yes, the given covered symbol should be part of the following\n-            \/\/exhaustiveness check:\n-            Set<Symbol> covered = new HashSet<>();\n+                if (current.isSealed() && current.isAbstract()) {\n+                    for (Symbol sym : current.permitted) {\n+                        ClassSymbol csym = (ClassSymbol) sym;\n@@ -872,3 +933,5 @@\n-            for (Entry<Symbol, List<JCRecordPattern>> e : coveredSymbol2Patterns.entrySet()) {\n-                if (coversDeconstructionFromComponent(pos, recordType, e.getValue(), component + 1)) {\n-                    covered.add(e.getKey());\n+                        if (accept.test(csym)) {\n+                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                            permitted.add(csym);\n+                        }\n+                    }\n@@ -878,2 +941,1 @@\n-            \/\/verify whether the filtered symbols cover the given record's declared type:\n-            return isExhaustive(pos, instantiatedComponentType, covered);\n+            return permitted;\n@@ -882,13 +944,58 @@\n-        private void transitiveCovers(DiagnosticPosition pos, Type seltype, Set<Symbol> covered) {\n-            List<Symbol> todo = List.from(covered);\n-            while (todo.nonEmpty()) {\n-                Symbol sym = todo.head;\n-                todo = todo.tail;\n-                switch (sym.kind) {\n-                    case VAR -> {\n-                        Iterable<Symbol> constants = sym.owner\n-                                                        .members()\n-                                                        .getSymbols(s -> s.isEnum() &&\n-                                                                         s.kind == VAR);\n-                        boolean hasAll = StreamSupport.stream(constants.spliterator(), false)\n-                                                      .allMatch(covered::contains);\n+        \/* Among the set of patterns, find sub-set of patterns such:\n+         * $record($prefix$, $nested, $suffix$)\n+         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n+         * in the set, and the patterns only differ in one \"column\" in\n+         * the $nested pattern.\n+         * Then, the set of $nested patterns is taken, and passed recursively\n+         * to reduceNestedPatterns and to reduceBindingPatterns, to\n+         * simplify the pattern. If that succeeds, the original found sub-set\n+         * of patterns is replaced with a new set of patterns of the form:\n+         * $record($prefix$, $resultOfReduction, $suffix$)\n+         *\/\n+        private List<PatternDescription> reduceNestedPatterns(List<PatternDescription> patterns) {\n+            \/* implementation note:\n+             * finding a sub-set of patterns that only differ in a single\n+             * column is time-consuming task, so this method speeds it up by:\n+             * - group the patterns by their record class\n+             * - for each column (nested pattern) do:\n+             * -- group patterns by their hash\n+             * -- in each such by-hash group, find sub-sets that only differ in\n+             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+             *    on patterns in the chosen column, as described above\n+             *\/\n+            var groupByRecordClass =\n+                    patterns.stream()\n+                            .filter(pd -> pd instanceof RecordPattern)\n+                            .map(pd -> (RecordPattern) pd)\n+                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n+\n+            for (var e : groupByRecordClass.entrySet()) {\n+                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n+\n+                for (int mismatchingCandidate = 0;\n+                     mismatchingCandidate < nestedPatternsCount;\n+                     mismatchingCandidate++) {\n+                    int mismatchingCandidateFin = mismatchingCandidate;\n+                    var groupByHashes =\n+                            e.getValue()\n+                             .stream()\n+                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n+                             .collect(groupingBy(pd -> pd.hashCode(mismatchingCandidateFin)));\n+                    for (var candidates : groupByHashes.values()) {\n+                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n+\n+                        for (int firstCandidate = 0;\n+                             firstCandidate < candidatesArr.length;\n+                             firstCandidate++) {\n+                            RecordPattern rpOne = candidatesArr[firstCandidate];\n+                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n+\n+                            join.append(rpOne);\n+\n+                            NEXT_PATTERN: for (int nextCandidate = 0;\n+                                               nextCandidate < candidatesArr.length;\n+                                               nextCandidate++) {\n+                                if (firstCandidate == nextCandidate) {\n+                                    continue;\n+                                }\n@@ -896,4 +1003,23 @@\n-                        if (hasAll && covered.add(sym.owner)) {\n-                            todo = todo.prepend(sym.owner);\n-                        }\n-                    }\n+                                RecordPattern rpOther = candidatesArr[nextCandidate];\n+                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n+                                    for (int i = 0; i < rpOne.nested.length; i++) {\n+                                        if (i != mismatchingCandidate &&\n+                                            !rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                            continue NEXT_PATTERN;\n+                                        }\n+                                    }\n+                                    join.append(rpOther);\n+                                }\n+                            }\n+\n+                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(List.collector());\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns);\n+\n+                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n+\n+                            if (nestedPatterns != updatedPatterns) {\n+                                ListBuffer<PatternDescription> result = new ListBuffer<>();\n+                                Set<PatternDescription> toRemove = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+                                toRemove.addAll(join);\n@@ -901,6 +1027,13 @@\n-                    case TYP -> {\n-                        for (Type sup : types.directSupertypes(sym.type)) {\n-                            if (sup.tsym.kind == TYP) {\n-                                if (isTransitivelyCovered(pos, seltype, sup.tsym, covered) &&\n-                                    covered.add(sup.tsym)) {\n-                                    todo = todo.prepend(sup.tsym);\n+                                for (PatternDescription p : patterns) {\n+                                    if (!toRemove.contains(p)) {\n+                                        result.append(p);\n+                                    }\n+                                }\n+\n+                                for (PatternDescription nested : updatedPatterns) {\n+                                    PatternDescription[] newNested =\n+                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                    newNested[mismatchingCandidateFin] = nested;\n+                                    result.append(new RecordPattern(rpOne.recordType(),\n+                                                                    rpOne.fullComponentTypes(),\n+                                                                    newNested));\n@@ -908,0 +1041,1 @@\n+                                return result.toList();\n@@ -913,0 +1047,1 @@\n+            return patterns;\n@@ -915,17 +1050,18 @@\n-        private boolean isTransitivelyCovered(DiagnosticPosition pos, Type seltype,\n-                                              Symbol sealed, Set<Symbol> covered) {\n-            try {\n-                if (covered.stream().anyMatch(c -> sealed.isSubClass(c, types)))\n-                    return true;\n-                if (sealed.kind == TYP && sealed.isAbstract() && sealed.isSealed()) {\n-                    return ((ClassSymbol) sealed).permitted\n-                                                 .stream()\n-                                                 .filter(s -> {\n-                                                     return types.isCastable(seltype, s.type\/*, types.noWarnings*\/);\n-                                                 })\n-                                                 .allMatch(s -> isTransitivelyCovered(pos, seltype, s, covered));\n-                }\n-                return false;\n-            } catch (CompletionFailure cf) {\n-                chk.completionError(pos, cf);\n-                return true;\n+        \/* In the set of patterns, find those for which, given:\n+         * $record($nested1, $nested2, ...)\n+         * all the $nestedX pattern cover the given record component,\n+         * and replace those with a simple binding pattern over $record.\n+         *\/\n+        private List<PatternDescription> reduceRecordPatterns(List<PatternDescription> patterns) {\n+            var newPatterns = new ListBuffer<PatternDescription>();\n+            boolean modified = false;\n+            for (PatternDescription pd : patterns) {\n+                if (pd instanceof RecordPattern rpOne) {\n+                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                    if (reducedPattern != rpOne) {\n+                        newPatterns.append(reducedPattern);\n+                        modified = true;\n+                        continue;\n+                    }\n+                }\n+                newPatterns.append(pd);\n@@ -933,1 +1069,2 @@\n-        }\n+            return modified ? newPatterns.toList() : patterns;\n+                }\n@@ -935,9 +1072,14 @@\n-        private boolean isExhaustive(DiagnosticPosition pos, Type seltype, Set<Symbol> covered) {\n-            transitiveCovers(pos, seltype, covered);\n-            return switch (seltype.getTag()) {\n-                case CLASS -> {\n-                    if (seltype.isCompound()) {\n-                        if (seltype.isIntersection()) {\n-                            yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                        .stream()\n-                                                                        .anyMatch(t -> isExhaustive(pos, t, covered));\n+        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+            if (pattern instanceof RecordPattern rpOne) {\n+                Type[] componentType = rpOne.fullComponentTypes();\n+                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                if (componentType.length != rpOne.nested.length) {\n+                    return pattern;\n+                }\n+                PatternDescription[] reducedNestedPatterns = null;\n+                boolean covered = true;\n+                for (int i = 0; i < componentType.length; i++) {\n+                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                    if (newNested != rpOne.nested[i]) {\n+                        if (reducedNestedPatterns == null) {\n+                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n@@ -945,1 +1087,1 @@\n-                        yield false;\n+                        reducedNestedPatterns[i] = newNested;\n@@ -947,4 +1089,3 @@\n-                    yield covered.stream()\n-                                 .filter(coveredSym -> coveredSym.kind == TYP)\n-                                 .anyMatch(coveredSym -> types.isSubtype(types.erasure(seltype),\n-                                                                         types.erasure(coveredSym.type)));\n+\n+                    covered &= newNested instanceof BindingPattern bp &&\n+                               types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n@@ -952,3 +1093,4 @@\n-                case TYPEVAR -> isExhaustive(pos, ((TypeVar) seltype).getUpperBound(), covered);\n-                default -> {\n-                    yield covered.contains(types.erasure(seltype).tsym);\n+                if (covered) {\n+                    return new BindingPattern(rpOne.recordType);\n+                } else if (reducedNestedPatterns != null) {\n+                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n@@ -956,1 +1098,2 @@\n-            };\n+            }\n+            return pattern;\n@@ -1377,5 +1520,1 @@\n-            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                visitVarDef(jcVariableDecl);\n-            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                visitRecordPattern(jcRecordPattern);\n-            }\n+            visitVarDef(tree.var);\n@@ -2180,4 +2319,0 @@\n-            if (inits.isReset()) {\n-                inits.assign(initsWhenTrue);\n-                uninits.assign(uninitsWhenTrue);\n-            }\n@@ -2562,0 +2697,2 @@\n+            visitVarDef(tree.var);\n+\n@@ -2570,7 +2707,1 @@\n-            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                visitVarDef(jcVariableDecl);\n-                letInit(tree.pos(), jcVariableDecl.sym);\n-            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                visitRecordPattern(jcRecordPattern);\n-            }\n-\n+            letInit(tree.pos(), tree.var.sym);\n@@ -2628,11 +2759,4 @@\n-                if (l.head.stats.isEmpty() &&\n-                    l.tail.nonEmpty() &&\n-                    l.tail.head.labels.size() == 1 &&\n-                    TreeInfo.isNullCaseLabel(l.tail.head.labels.head)) {\n-                    \/\/handling:\n-                    \/\/case Integer i:\n-                    \/\/case null:\n-                    \/\/joining these two cases together - processing Integer i pattern,\n-                    \/\/but statements from case null:\n-                    l = l.tail;\n-                    c = l.head;\n+                scan(c.guard);\n+                if (inits.isReset()) {\n+                    inits.assign(initsWhenTrue);\n+                    uninits.assign(uninitsWhenTrue);\n@@ -2703,1 +2827,1 @@\n-                    if (unrefdResources.includes(resVar.sym)) {\n+                    if (unrefdResources.includes(resVar.sym) && !resVar.sym.isUnnamedVariable()) {\n@@ -3031,6 +3155,0 @@\n-        @Override\n-        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n-            scan(tree.pat);\n-            scan(tree.guard);\n-        }\n-\n@@ -3107,0 +3225,1 @@\n+        WriteableScope declaredInsideGuard;\n@@ -3120,1 +3239,1 @@\n-                    case PATTERNCASELABEL:\n+                    case CASE:\n@@ -3134,4 +3253,1 @@\n-                if (currentTree != null &&\n-                        sym.kind == VAR &&\n-                        sym.owner.kind == MTH &&\n-                        ((VarSymbol)sym).pos < currentTree.getStartPosition()) {\n+                if (currentTree != null) {\n@@ -3139,4 +3255,12 @@\n-                        case CLASSDEF:\n-                        case CASE:\n-                        case LAMBDA:\n-                            reportEffectivelyFinalError(tree, sym);\n+                        case CLASSDEF, LAMBDA -> {\n+                            if (sym.kind == VAR &&\n+                                sym.owner.kind == MTH &&\n+                                ((VarSymbol)sym).pos < currentTree.getStartPosition()) {\n+                                reportEffectivelyFinalError(tree, sym);\n+                            }\n+                        }\n+                        case CASE -> {\n+                            if (!declaredInsideGuard.includes(sym)) {\n+                                log.error(tree.pos(), Errors.CannotAssignNotDeclaredGuard(sym));\n+                            }\n+                        }\n@@ -3151,1 +3275,1 @@\n-                case PATTERNCASELABEL -> Fragments.Guard;\n+                case CASE -> Fragments.Guard;\n@@ -3191,13 +3315,13 @@\n-        public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-            scan(tree.pattern);\n-        }\n-\n-        @Override\n-        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n-             scan(tree.pat);\n-            JCTree prevTree = currentTree;\n-            try {\n-                currentTree = tree;\n-                scan(tree.guard);\n-            } finally {\n-                currentTree = prevTree;\n+        public void visitCase(JCCase tree) {\n+            scan(tree.labels);\n+            if (tree.guard != null) {\n+                JCTree prevTree = currentTree;\n+                WriteableScope prevDeclaredInsideGuard = declaredInsideGuard;\n+                try {\n+                    currentTree = tree;\n+                    declaredInsideGuard = WriteableScope.create(attrEnv.enclClass.sym);\n+                    scan(tree.guard);\n+                } finally {\n+                    currentTree = prevTree;\n+                    declaredInsideGuard = prevDeclaredInsideGuard;\n+                }\n@@ -3205,0 +3329,1 @@\n+            scan(tree.stats);\n@@ -3259,0 +3384,8 @@\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            if (declaredInsideGuard != null) {\n+                declaredInsideGuard.enter(tree.sym);\n+            }\n+            super.visitVarDef(tree);\n+        }\n+\n@@ -3343,0 +3476,81 @@\n+    sealed interface PatternDescription { }\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                    .map(r -> types.memberType(record.type, r))\n+                    .toArray(s -> new Type[s]);\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentTypes[i]), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            Type type = types.isSubtype(selectorType, syms.objectType)\n+                    ? selectorType : syms.objectType;\n+            return new BindingPattern(type);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type) implements PatternDescription {\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":463,"deletions":249,"binary":false,"changes":712,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-            cases.add(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(make.Literal(entry.getKey()))), stmts, null));\n+            cases.add(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(make.Literal(entry.getKey()))), null, stmts, null));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -3561,9 +3560,5 @@\n-\n-            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-            JCVariableDecl jcVariableDecl = (JCVariableDecl) tree.varOrRecordPattern;\n-\n-            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(jcVariableDecl.mods,\n-                    jcVariableDecl.name,\n-                    jcVariableDecl.vartype,\n-                    loopvarinit).setType(jcVariableDecl.type);\n-            loopvardef.sym = jcVariableDecl.sym;\n+            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,\n+                                                  tree.var.name,\n+                                                  tree.var.vartype,\n+                                                  loopvarinit).setType(tree.var.type);\n+            loopvardef.sym = tree.var.sym;\n@@ -3571,2 +3566,1 @@\n-                    Block(0, List.of(loopvardef, tree.body));\n-\n+                Block(0, List.of(loopvardef, tree.body));\n@@ -3651,5 +3645,1 @@\n-\n-            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n-            JCVariableDecl var = (JCVariableDecl) tree.varOrRecordPattern;\n-            if (var.type.isPrimitive())\n+            if (tree.var.type.isPrimitive())\n@@ -3658,6 +3648,6 @@\n-                vardefinit = make.TypeCast(var.type, vardefinit);\n-            JCVariableDecl indexDef = (JCVariableDecl) make.VarDef(var.mods,\n-                    var.name,\n-                    var.vartype,\n-                    vardefinit).setType(var.type);\n-            indexDef.sym = var.sym;\n+                vardefinit = make.TypeCast(tree.var.type, vardefinit);\n+            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,\n+                                                  tree.var.name,\n+                                                  tree.var.vartype,\n+                                                  vardefinit).setType(tree.var.type);\n+            indexDef.sym = tree.var.sym;\n@@ -3667,4 +3657,4 @@\n-                    ForLoop(List.of(init),\n-                            cond,\n-                            List.nil(),\n-                            body));\n+                ForLoop(List.of(init),\n+                        cond,\n+                        List.nil(),\n+                        body));\n@@ -3756,1 +3746,1 @@\n-            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n+            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), null, List.of(thr), null);\n@@ -3783,0 +3773,1 @@\n+                                                           null,\n@@ -3877,1 +3868,1 @@\n-                newCases.append(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(pat)), c.stats, null));\n+                newCases.append(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(pat)), null, c.stats, null));\n@@ -4049,0 +4040,1 @@\n+                                            null,\n@@ -4084,0 +4076,1 @@\n+                                    null,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-            case PARENTHESIZEDPATTERN: case TYPETEST:\n+            case TYPETEST:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -58,0 +59,2 @@\n+    \/** The Source language setting. *\/\n+    private final Source source;\n@@ -65,0 +68,1 @@\n+    private final Names names;\n@@ -84,0 +88,2 @@\n+        source = Source.instance(context);\n+        names = Names.instance(context);\n@@ -288,1 +294,2 @@\n-        VarSymbol v = new VarSymbol(0, tree.name, vartype, enclScope.owner);\n+        Name name = tree.name;\n+        VarSymbol v = new VarSymbol(0, name, vartype, enclScope.owner);\n@@ -300,6 +307,9 @@\n-        if (chk.checkUnique(tree.pos(), v, enclScope)) {\n-            chk.checkTransparentVar(tree.pos(), v, enclScope);\n-            enclScope.enter(v);\n-        } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {\n-            \/\/ if this is a parameter or a field obtained from a record component, enter it\n-            enclScope.enter(v);\n+\n+        if(!(Feature.UNNAMED_VARIABLES.allowedInSource(source) && tree.sym.isUnnamedVariable())) {\n+            if (chk.checkUnique(tree.pos(), v, enclScope)) {\n+                chk.checkTransparentVar(tree.pos(), v, enclScope);\n+                enclScope.enter(v);\n+            } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {\n+                \/\/ if this is a parameter or a field obtained from a record component, enter it\n+                enclScope.enter(v);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -960,4 +960,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n@@ -46,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCAnyPattern;\n@@ -58,1 +61,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCThrow;\n@@ -97,1 +99,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n@@ -108,0 +109,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -199,2 +202,1 @@\n-            \/\/first, resolve any parenthesized and record patterns:\n-            pattern = TreeInfo.skipParens(pattern);\n+            \/\/first, resolve any record patterns:\n@@ -263,0 +265,5 @@\n+    @Override\n+    public void visitAnyPattern(JCTree.JCAnyPattern that) {\n+        result = make.Literal(true);\n+    }\n+\n@@ -270,1 +277,1 @@\n-        if (bindingVar != null) {\n+        if (bindingVar != null && !bindingVar.isUnnamedVariable()) {\n@@ -283,5 +290,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        result = translate(tree.pattern);\n-    }\n-\n@@ -317,2 +319,2 @@\n-            JCPattern nestedPattern = TreeInfo.skipParens(nestedPatterns.head);\n-            JCBindingPattern nestedBinding;\n+            JCPattern nestedPattern = nestedPatterns.head;\n+            JCPattern nestedBinding;\n@@ -332,1 +334,5 @@\n-            } else {\n+            } else if (nestedPattern instanceof JCAnyPattern nestedAnyPattern) {\n+                allowNull = true;\n+                nestedBinding = nestedAnyPattern;\n+            }\n+            else {\n@@ -393,2 +399,0 @@\n-            Assert.check(preview.isEnabled());\n-            Assert.check(preview.usesPreview(env.toplevel.sourcefile));\n@@ -439,1 +443,2 @@\n-                c.head.labels = c.head.labels.map(l -> {\n+                JCCase cse = c.head;\n+                cse.labels = cse.labels.map(l -> {\n@@ -441,1 +446,1 @@\n-                        JCPattern pattern = TreeInfo.skipParens(patternLabel.pat);\n+                        JCPattern pattern = patternLabel.pat;\n@@ -445,4 +450,5 @@\n-                            if (patternLabel.guard != null) {\n-                                guard = mergeConditions(guard, patternLabel.guard);\n-                            }\n-                            return make.PatternCaseLabel(deconstructed.primaryPattern(), guard);\n+\n+                            JCPatternCaseLabel newPatternCaseLabel = make.PatternCaseLabel(deconstructed.primaryPattern());\n+                            newPatternCaseLabel.syntheticGuard = guard;\n+\n+                            return newPatternCaseLabel;\n@@ -530,2 +536,10 @@\n-                if (clearedPatterns.size() == 1 && clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL) && !previousCompletesNormally) {\n-                    JCPatternCaseLabel label = (JCPatternCaseLabel) clearedPatterns.head;\n+\n+                boolean validCaseLabelList;\n+                if (clearedPatterns.size() > 1) {\n+                    validCaseLabelList = clearedPatterns.stream().allMatch(cP -> cP.hasTag(Tag.PATTERNCASELABEL));\n+                } else {\n+                    validCaseLabelList = clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL);\n+                }\n+\n+                if (validCaseLabelList && !previousCompletesNormally) {\n+                    List<JCPatternCaseLabel> labels = clearedPatterns.stream().map(cp -> (JCPatternCaseLabel)cp).collect(List.collector());\n@@ -536,4 +550,33 @@\n-                        JCExpression test = (JCExpression) this.<JCTree>translate(label.pat);\n-                        if (label.guard != null) {\n-                            JCExpression guard = translate(label.guard);\n-                            test = makeBinary(Tag.AND, test, guard);\n+                        JCExpression test = null;\n+                        JCExpression accTest = null;\n+                        boolean first = true;\n+\n+                        \/\/ if all patterns are the same we do not need an extra test for the first (it is covered by the BSM)\n+                        boolean multiplePatternsAndDifferent = labels.size() > 1 &&\n+                                !labels.stream().map(l -> l.pat.type.tsym).allMatch(labels.get(0).pat.type.tsym::equals);\n+\n+                        for (JCPatternCaseLabel label: labels) {\n+                            test = (JCExpression) this.<JCTree>translate(label.pat);\n+\n+                            if (multiplePatternsAndDifferent) {\n+                                test = makeBinary(Tag.AND, makeTypeTest(make.Ident(temp), make.Type(label.pat.type)), test);\n+                            }\n+\n+                            if (label.syntheticGuard != null) {\n+                                JCExpression guard = translate(label.syntheticGuard);\n+                                test = makeBinary(Tag.AND, test, guard);\n+                            }\n+\n+                            if (!first) {\n+                                accTest = makeBinary(Tag.OR, accTest, test);\n+                            } else {\n+                                accTest = test;\n+                                first = false;\n+                            }\n+                        }\n+\n+                        if (c.guard != null) {\n+                            test = makeBinary(Tag.AND, accTest, translate(c.guard));\n+                            c.guard = null;\n+                        } else {\n+                            test = accTest;\n@@ -541,0 +584,1 @@\n+\n@@ -546,1 +590,1 @@\n-                                                                                                       makeLit(syms.intType, i + 1))\n+                                                                                                       makeLit(syms.intType, i + labels.length()))\n@@ -562,1 +606,4 @@\n-                for (var p : c.labels) {\n+                List<JCCaseLabel> labels = c.labels;\n+                boolean defaultAdded = false;\n+                for (int j = 0; j < labels.size() && !defaultAdded; j++) {\n+                    var p = labels.get(j);\n@@ -567,1 +614,1 @@\n-                               c == lastCase && p.hasTag(Tag.PATTERNCASELABEL)) {\n+                            c == lastCase && p.hasTag(Tag.PATTERNCASELABEL)) {\n@@ -572,0 +619,1 @@\n+                        defaultAdded = true;\n@@ -704,1 +752,1 @@\n-                    JCExpression lastGuard = null;\n+                    boolean hasGuard = false;\n@@ -719,1 +767,1 @@\n-                        if (accummulatedFirstLabel.guard instanceof JCBinary binOp) {\n+                        if (accummulatedFirstLabel.syntheticGuard instanceof JCBinary binOp) {\n@@ -724,1 +772,1 @@\n-                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.guard;\n+                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.syntheticGuard;\n@@ -731,0 +779,4 @@\n+\n+                        JCPatternCaseLabel jcPatternCaseLabelWithGuard = make.PatternCaseLabel(binding);\n+                        jcPatternCaseLabelWithGuard.syntheticGuard = newGuard;\n+\n@@ -733,1 +785,1 @@\n-                                    make.PatternCaseLabel(binding, newGuard));\n+                                    jcPatternCaseLabelWithGuard);\n@@ -735,1 +787,1 @@\n-                            newLabel = List.of(make.PatternCaseLabel(binding, newGuard));\n+                            newLabel = List.of(jcPatternCaseLabelWithGuard);\n@@ -737,2 +789,3 @@\n-                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.stats, null));\n-                        lastGuard = newGuard;\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.guard,\n+                                                  accummulated.stats, null));\n+                        hasGuard = newGuard != null || accummulated.guard != null;\n@@ -740,1 +793,1 @@\n-                    if (lastGuard != null || !hasUnconditional) {\n+                    if (hasGuard || !hasUnconditional) {\n@@ -748,0 +801,1 @@\n+                                                  null,\n@@ -755,1 +809,1 @@\n-                    leadingTest.guard = null;\n+                    leadingTest.syntheticGuard = null;\n@@ -758,0 +812,1 @@\n+                                         null,\n@@ -779,1 +834,1 @@\n-                if (patternLabel.guard instanceof JCBinary binOp &&\n+                if (patternLabel.syntheticGuard instanceof JCBinary binOp &&\n@@ -786,1 +841,1 @@\n-                } else if (patternLabel.guard instanceof JCInstanceOf instanceofCheck &&\n+                } else if (patternLabel.syntheticGuard instanceof JCInstanceOf instanceofCheck &&\n@@ -838,1 +893,1 @@\n-        } else if (l.hasTag(Tag.CONSTANTCASELABEL)&& !TreeInfo.isNullCaseLabel(l)) {\n+        } else if (l.hasTag(Tag.CONSTANTCASELABEL) && !TreeInfo.isNullCaseLabel(l)) {\n@@ -840,2 +895,7 @@\n-            if ((expr.type.tsym.flags_field & Flags.ENUM) != 0) {\n-                return LoadableConstant.String(((JCIdent) expr).name.toString());\n+            Symbol sym = TreeInfo.symbol(expr);\n+            if (sym != null && sym.isEnum() && sym.kind == Kind.VAR) {\n+                if (selector.tsym.isEnum()) {\n+                    return LoadableConstant.String(sym.getSimpleName().toString());\n+                } else {\n+                    return createEnumDesc(l.pos(), (ClassSymbol) sym.owner, sym.getSimpleName());\n+                }\n@@ -857,0 +917,32 @@\n+    private LoadableConstant createEnumDesc(DiagnosticPosition pos, ClassSymbol enumClass, Name constant) {\n+        MethodSymbol classDesc = rs.resolveInternalMethod(pos, env, syms.classDescType, names.of, List.of(syms.stringType), List.nil());\n+        MethodSymbol enumDesc = rs.resolveInternalMethod(pos, env, syms.enumDescType, names.of, List.of(syms.classDescType, syms.stringType), List.nil());\n+        return invokeMethodWrapper(pos,\n+                                   enumDesc.asHandle(),\n+                                   invokeMethodWrapper(pos,\n+                                                       classDesc.asHandle(),\n+                                                       LoadableConstant.String(enumClass.flatname.toString())),\n+                                   LoadableConstant.String(constant.toString()));\n+    }\n+\n+    private LoadableConstant invokeMethodWrapper(DiagnosticPosition pos, MethodHandleSymbol toCall, LoadableConstant... params) {\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                                            syms.stringType,\n+                                            new ClassType(syms.classType.getEnclosingType(),\n+                                                          List.of(syms.botType), \/\/XXX - botType\n+                                                          syms.classType.tsym),\n+                                            syms.methodHandleType,\n+                                            types.makeArrayType(syms.objectType));\n+\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                names.invoke, bsm_staticArgs, List.nil());\n+\n+        LoadableConstant[] actualParams = new LoadableConstant[params.length + 1];\n+\n+        actualParams[0] = toCall;\n+\n+        System.arraycopy(params, 0, actualParams, 1, params.length);\n+\n+        return new DynamicVarSymbol(bsm.name, bsm.owner, bsm.asHandle(), toCall.getReturnType(), actualParams);\n+    }\n+\n@@ -901,71 +993,0 @@\n-    @Override\n-    public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n-        bindingContext = new BasicBindingContext();\n-        VarSymbol prevCurrentValue = currentValue;\n-        try {\n-            if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                \/**\n-                 * A statement of the form\n-                 *\n-                 * <pre>\n-                 *     for (<pattern> : coll ) stmt ;\n-                 * <\/pre>\n-                 *\n-                 * (where coll implements {@code Iterable<R>}) gets translated to\n-                 *\n-                 * <pre>{@code\n-                 *     for (<type-of-coll-item> N$temp : coll) {\n-                 *     switch (N$temp) {\n-                 *         case <pattern>: stmt;\n-                 *         case null: throw new MatchException();\n-                 *     }\n-                 * }<\/pre>\n-                 *\n-                 *\/\n-                Type selectorType = types.classBound(tree.elementType);\n-\n-                currentValue = new VarSymbol(Flags.FINAL | Flags.SYNTHETIC,\n-                        names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n-                        selectorType,\n-                        currentMethodSym);\n-\n-                JCStatement newForVariableDeclaration =\n-                        make.at(tree.pos).VarDef(currentValue, null).setType(selectorType);\n-\n-                List<JCExpression> nestedNPEParams = List.of(makeNull());\n-                JCNewClass nestedNPE = makeNewClass(syms.nullPointerExceptionType, nestedNPEParams);\n-\n-                List<JCExpression> matchExParams = List.of(makeNull(), nestedNPE);\n-                JCThrow thr = make.Throw(makeNewClass(syms.matchExceptionType, matchExParams));\n-\n-                JCCase caseNull = make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(makeNull())), List.of(thr), null);\n-\n-                JCCase casePattern = make.Case(CaseTree.CaseKind.STATEMENT,\n-                        List.of(make.PatternCaseLabel(jcRecordPattern, null)),\n-                        List.of(translate(tree.body)),\n-                        null);\n-\n-                JCSwitch switchBody =\n-                        make.Switch(make.Ident(currentValue).setType(selectorType),\n-                                List.of(caseNull, casePattern));\n-\n-                switchBody.patternSwitch = true;\n-\n-                \/\/ re-using the same node to eliminate the need to re-patch targets (break\/continue)\n-                tree.varOrRecordPattern = newForVariableDeclaration.setType(selectorType);\n-                tree.expr = translate(tree.expr);\n-                tree.body = translate(switchBody);\n-\n-                JCTree.JCEnhancedForLoop newForEach = tree;\n-\n-                result = bindingContext.decorateStatement(newForEach);\n-            } else {\n-                super.visitForeachLoop(tree);\n-                result = bindingContext.decorateStatement(tree);\n-            }\n-        } finally {\n-            currentValue = prevCurrentValue;\n-            bindingContext.pop();\n-        }\n-    }\n-\n@@ -1411,0 +1432,6 @@\n+\n+        @Override\n+        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+            super.visitPatternCaseLabel(tree);\n+            scan(tree.syntheticGuard);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":142,"deletions":115,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-        tree.varOrRecordPattern = translate(tree.varOrRecordPattern, null);\n+        tree.var = translate(tree.var, null);\n@@ -554,0 +554,1 @@\n+        tree.guard = translate(tree.guard, syms.booleanType);\n@@ -558,0 +559,5 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree;\n+    }\n+\n@@ -572,1 +578,0 @@\n-        tree.guard = translate(tree.guard, syms.booleanType);\n@@ -587,6 +592,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        tree.pattern = translate(tree.pattern, null);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -300,1 +300,3 @@\n-        result = scan(tree.labels, that.labels) && scan(tree.stats, that.stats);\n+        result = scan(tree.labels, that.labels) &&\n+                 scan(tree.guard, that.guard) &&\n+                 scan(tree.stats, that.stats);\n@@ -312,1 +314,1 @@\n-        result = scan(tree.pat, that.pat) && scan(tree.guard, that.guard);\n+        result = scan(tree.pat, that.pat);\n@@ -391,1 +393,1 @@\n-                scan(tree.varOrRecordPattern, that.varOrRecordPattern)\n+                scan(tree.var, that.var)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-            sr.mergeWith(csp(tree.varOrRecordPattern));\n+            sr.mergeWith(csp(tree.var));\n@@ -326,0 +326,1 @@\n+            sr.mergeWith(csp(tree.guard));\n@@ -346,1 +347,0 @@\n-            sr.mergeWith(csp(tree.guard));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -944,0 +944,9 @@\n+        int lastBootstrapMethods;\n+        do {\n+            lastBootstrapMethods = poolWriter.bootstrapMethods.size();\n+            for (BsmKey bsmKey : java.util.List.copyOf(poolWriter.bootstrapMethods.keySet())) {\n+                for (LoadableConstant arg : bsmKey.staticArgs) {\n+                    poolWriter.putConstant(arg);\n+                }\n+            }\n+        } while (lastBootstrapMethods < poolWriter.bootstrapMethods.size());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1538,5 +1538,0 @@\n-            public void visitParenthesizedPattern(JCTree.JCParenthesizedPattern tree) {\n-                hasPatterns = true;\n-                super.visitParenthesizedPattern(tree);\n-            }\n-            @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-    PROC(\"-proc:\", \"opt.proc.none.only\", STANDARD, BASIC,  ONEOF, \"none\", \"only\"),\n+    PROC(\"-proc:\", \"opt.proc.none.only\", STANDARD, BASIC, ONEOF, \"none\", \"only\", \"full\"),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import java.util.function.BiFunction;\n@@ -593,0 +592,8 @@\n+        return ident(allowClass, false);\n+    }\n+\n+    public Name identOrUnderscore() {\n+        return ident(false, true);\n+    }\n+\n+    protected Name ident(boolean allowClass, boolean asVariable) {\n@@ -618,0 +625,2 @@\n+            } else if (asVariable) {\n+                checkSourceLevel(Feature.UNNAMED_VARIABLES);\n@@ -619,1 +628,5 @@\n-                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+                if (preview.isEnabled() && Feature.UNNAMED_VARIABLES.allowedInSource(source)) {\n+                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UseOfUnderscoreNotAllowed);\n+                } else {\n+                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+                }\n@@ -836,10 +849,7 @@\n-        if (token.kind == LPAREN && parsedType == null) {\n-            \/\/parenthesized pattern:\n-            int startPos = token.pos;\n-            accept(LPAREN);\n-            JCPattern p = parsePattern(token.pos, null, null, true, false);\n-            accept(RPAREN);\n-            pattern = toP(F.at(startPos).ParenthesizedPattern(p));\n-        } else {\n-            mods = mods != null ? mods : optFinal(0);\n-            JCExpression e;\n+        mods = mods != null ? mods : optFinal(0);\n+        JCExpression e;\n+        if (token.kind == UNDERSCORE && parsedType == null) {\n+            nextToken();\n+            pattern = toP(F.at(token.pos).AnyPattern());\n+        }\n+        else {\n@@ -870,0 +880,9 @@\n+                if (mods.annotations.nonEmpty()) {\n+                    log.error(mods.annotations.head.pos(), Errors.RecordPatternsAnnotationsNotAllowed);\n+                }\n+                new TreeScanner() {\n+                    @Override\n+                    public void visitAnnotatedType(JCAnnotatedType tree) {\n+                        log.error(tree.pos(), Errors.RecordPatternsAnnotationsNotAllowed);\n+                    }\n+                }.scan(e);\n@@ -872,1 +891,8 @@\n-                JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n+                int varPos = token.pos;\n+                JCVariableDecl var = variableDeclaratorRest(varPos, mods, e, identOrUnderscore(), false, null, false, false, true);\n+                if (e == null) {\n+                    var.startPos = pos;\n+                    if (var.name == names.underscore && !allowVar) {\n+                        log.error(DiagnosticFlag.SYNTAX, varPos, Errors.UseOfUnderscoreNotAllowed);\n+                    }\n+                }\n@@ -879,1 +905,0 @@\n-\n@@ -1076,0 +1101,3 @@\n+                    } else if (token.kind == UNDERSCORE) {\n+                        checkSourceLevel(token.pos, Feature.UNNAMED_VARIABLES);\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n@@ -1623,0 +1651,1 @@\n+        JCExpression guard = parseGuard(pats.last());\n@@ -1648,1 +1677,1 @@\n-        caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));\n+        caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), guard, stats, body)));\n@@ -2050,1 +2079,0 @@\n-\n@@ -2053,1 +2081,0 @@\n-        List<JCVariableDecl> params;\n@@ -2055,0 +2082,11 @@\n+        \/**\n+         * analyzeParens() has already classified the lambda as EXPLICIT_LAMBDA, due to\n+         * two consecutive identifiers. Because of that {@code (<explicit lambda>)}, the\n+         * parser will always attempt to parse a type, followed by a name. If the lambda\n+         * contains an illegal mix of implicit and explicit parameters, it is possible\n+         * for the parser to see a {@code ,} when expecting a name, in which case the\n+         * variable is created with an erroneous name. The logic below makes sure that\n+         * the lambda parameters are all declared with either an explicit type (e.g.\n+         * {@code String x}), or with an inferred type (using {@code var x}). Any other\n+         * combination is rejected.\n+         * *\/\n@@ -2056,9 +2094,3 @@\n-            if (param.vartype != null && param.name != names.empty) {\n-                if (restrictedTypeName(param.vartype, false) != null) {\n-                    reduce(LambdaParameterKind.VAR);\n-                } else {\n-                    reduce(LambdaParameterKind.EXPLICIT);\n-                }\n-            }\n-            if (param.vartype == null && param.name != names.empty ||\n-                param.vartype != null && param.name == names.empty) {\n+            Assert.check(param.vartype != null);\n+\n+            if (param.name == names.error) {\n@@ -2067,0 +2099,5 @@\n+            else if (restrictedTypeName(param.vartype, false) != null) {\n+                reduce(LambdaParameterKind.VAR);\n+            } else {\n+                reduce(LambdaParameterKind.EXPLICIT);\n+            }\n@@ -2913,15 +2950,6 @@\n-            JCTree pattern;\n-\n-            ForInitResult initResult = analyzeForInit();\n-\n-            if (initResult == ForInitResult.RecordPattern) {\n-                int patternPos = token.pos;\n-                JCModifiers mods = optFinal(0);\n-                int typePos = token.pos;\n-                JCExpression type = unannotatedType(false);\n-\n-                pattern = parsePattern(patternPos, mods, type, false, false);\n-\n-                if (pattern != null) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n-                }\n+            List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n+            if (inits.length() == 1 &&\n+                inits.head.hasTag(VARDEF) &&\n+                ((JCVariableDecl) inits.head).init == null &&\n+                token.kind == COLON) {\n+                JCVariableDecl var = (JCVariableDecl)inits.head;\n@@ -2932,1 +2960,1 @@\n-                return F.at(pos).ForeachLoop(pattern, expr, body);\n+                return F.at(pos).ForeachLoop(var, expr, body);\n@@ -2934,20 +2962,7 @@\n-                List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n-                if (inits.length() == 1 &&\n-                        inits.head.hasTag(VARDEF) &&\n-                        ((JCVariableDecl) inits.head).init == null &&\n-                        token.kind == COLON) {\n-                    JCVariableDecl var = (JCVariableDecl) inits.head;\n-                    accept(COLON);\n-                    JCExpression expr = parseExpression();\n-                    accept(RPAREN);\n-                    JCStatement body = parseStatementAsBlock();\n-                    return F.at(pos).ForeachLoop(var, expr, body);\n-                } else {\n-                    accept(SEMI);\n-                    JCExpression cond = token.kind == SEMI ? null : parseExpression();\n-                    accept(SEMI);\n-                    List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n-                    accept(RPAREN);\n-                    JCStatement body = parseStatementAsBlock();\n-                    return F.at(pos).ForLoop(inits, cond, steps, body);\n-                }\n+                accept(SEMI);\n+                JCExpression cond = token.kind == SEMI ? null : parseExpression();\n+                accept(SEMI);\n+                List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n+                accept(RPAREN);\n+                JCStatement body = parseStatementAsBlock();\n+                return F.at(pos).ForLoop(inits, cond, steps, body);\n@@ -3070,85 +3085,0 @@\n-    private enum ForInitResult {\n-        LocalVarDecl,\n-        RecordPattern\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    ForInitResult analyzeForInit() {\n-        boolean inType = false;\n-        boolean inSelectionAndParenthesis = false;\n-        int typeParameterPossibleStart = -1;\n-        outer: for (int lookahead = 0; ; lookahead++) {\n-            TokenKind tk = S.token(lookahead).kind;\n-            switch (tk) {\n-                case DOT:\n-                    if (inType) break; \/\/ in qualified type\n-                case COMMA:\n-                    typeParameterPossibleStart = lookahead;\n-                    break;\n-                case QUES:\n-                    \/\/ \"?\" only allowed in a type parameter position - otherwise it's an expression\n-                    if (typeParameterPossibleStart == lookahead - 1) break;\n-                    else return ForInitResult.LocalVarDecl;\n-                case EXTENDS: case SUPER: case AMP:\n-                case GTGTGT: case GTGT: case GT:\n-                case FINAL: case ELLIPSIS:\n-                    break;\n-                case BYTE: case SHORT: case INT: case LONG: case FLOAT:\n-                case DOUBLE: case BOOLEAN: case CHAR: case VOID:\n-                    if (peekToken(lookahead, IDENTIFIER)) {\n-                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n-                                                         : ForInitResult.LocalVarDecl;\n-                    }\n-                    break;\n-                case LPAREN:\n-                    if (lookahead != 0 && inType) {\n-                        inSelectionAndParenthesis = true;\n-                        inType = false;\n-                    }\n-                    break;\n-                case RPAREN:\n-                    \/\/ a method call in the init part or a record pattern?\n-                    if (inSelectionAndParenthesis) {\n-                        if (peekToken(lookahead, DOT)  ||\n-                                peekToken(lookahead, SEMI) ||\n-                                peekToken(lookahead, ARROW)) {\n-                            return ForInitResult.LocalVarDecl;\n-                        }\n-                        else if(peekToken(lookahead, COLON)) {\n-                            return ForInitResult.RecordPattern;\n-                        }\n-                        break;\n-                    }\n-                case UNDERSCORE:\n-                case ASSERT:\n-                case ENUM:\n-                case IDENTIFIER:\n-                    if (lookahead == 0) {\n-                        inType = true;\n-                    }\n-                    break;\n-                case MONKEYS_AT: {\n-                    int prevLookahead = lookahead;\n-                    lookahead = skipAnnotation(lookahead);\n-                    if (typeParameterPossibleStart == prevLookahead - 1) {\n-                        \/\/ move possible start of type param after the anno\n-                        typeParameterPossibleStart = lookahead;\n-                    }\n-                    break;\n-                }\n-                case LBRACKET:\n-                    if (peekToken(lookahead, RBRACKET)) {\n-                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n-                                                         : ForInitResult.LocalVarDecl;\n-                    }\n-                    return ForInitResult.LocalVarDecl;\n-                case LT:\n-                    typeParameterPossibleStart = lookahead;\n-                    break;\n-                default:\n-                    \/\/this includes EOF\n-                    return ForInitResult.LocalVarDecl;\n-            }\n-        }\n-    }\n-\n@@ -3179,1 +3109,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, true, false, false);\n@@ -3237,0 +3167,1 @@\n+            JCExpression guard = parseGuard(pats.last());\n@@ -3254,1 +3185,1 @@\n-            c = F.at(pos).Case(caseKind, pats.toList(), stats, body);\n+            c = F.at(pos).Case(caseKind, pats.toList(), guard, stats, body);\n@@ -3262,0 +3193,1 @@\n+            JCExpression guard = parseGuard(defaultPattern);\n@@ -3279,1 +3211,1 @@\n-            c = F.at(pos).Case(caseKind, List.of(defaultPattern), stats, body);\n+            c = F.at(pos).Case(caseKind, List.of(defaultPattern), guard, stats, body);\n@@ -3307,6 +3239,1 @@\n-                JCExpression guard = null;\n-                if (token.kind == IDENTIFIER && token.name() == names.when) {\n-                    nextToken();\n-                    guard = term(EXPR | NOLAMBDA);\n-                }\n-                return toP(F.at(patternPos).PatternCaseLabel(p, guard));\n+                return toP(F.at(patternPos).PatternCaseLabel(p));\n@@ -3322,0 +3249,16 @@\n+    private JCExpression parseGuard(JCCaseLabel label) {\n+        JCExpression guard = null;\n+\n+        if (token.kind == IDENTIFIER && token.name() == names.when) {\n+            int pos = token.pos;\n+\n+            nextToken();\n+            guard = term(EXPR | NOLAMBDA);\n+\n+            if (!(label instanceof JCPatternCaseLabel)) {\n+                guard = syntaxError(pos, List.of(guard), Errors.GuardNotAllowed);\n+            }\n+        }\n+\n+        return guard;\n+    }\n@@ -3332,1 +3275,1 @@\n-                case ASSERT, ENUM, IDENTIFIER, UNDERSCORE:\n+                case ASSERT, ENUM, IDENTIFIER:\n@@ -3341,0 +3284,12 @@\n+                case UNDERSCORE:\n+                    \/\/ TODO: REFACTOR to remove the code duplication\n+                    if (typeDepth == 0 && peekToken(lookahead, tk -> tk == RPAREN || tk == COMMA)) {\n+                        return PatternResult.PATTERN;\n+                    } else if (typeDepth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) {\n+                        if (parenDepth == 0) {\n+                            return PatternResult.PATTERN;\n+                        } else {\n+                            pendingResult = PatternResult.PATTERN;\n+                        }\n+                    }\n+                    break;\n@@ -3648,1 +3603,1 @@\n-        return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);\n+        return variableDeclaratorsRest(token.pos, mods, type, identOrUnderscore(), false, null, vdefs, localDecl);\n@@ -3666,1 +3621,1 @@\n-        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);\n+        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false, false);\n@@ -3681,1 +3636,1 @@\n-        return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);\n+        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true, false);\n@@ -3691,1 +3646,1 @@\n-                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound) {\n+                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound, boolean isTypePattern) {\n@@ -3695,0 +3650,8 @@\n+\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+            if (!localDecl && !isTypePattern) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.UseOfUnderscoreNotAllowed);\n+            }\n+            name = names.empty;\n+        }\n+\n@@ -3700,20 +3663,31 @@\n-        JCTree elemType = TreeInfo.innermostType(type, true);\n-        int startPos = Position.NOPOS;\n-        if (elemType.hasTag(IDENT)) {\n-            Name typeName = ((JCIdent)elemType).name;\n-            if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n-                if (typeName != names.var) {\n-                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n-                } else if (type.hasTag(TYPEARRAY) && !compound) {\n-                    \/\/error - 'var' and arrays\n-                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n-                } else {\n-                    declaredUsingVar = true;\n-                    if(compound)\n-                        \/\/error - 'var' in compound local var decl\n-                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n-                    startPos = TreeInfo.getStartPos(mods);\n-                    if (startPos == Position.NOPOS)\n-                        startPos = TreeInfo.getStartPos(type);\n-                    \/\/implicit type\n-                    type = null;\n+\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.empty\n+                && localDecl\n+                && init == null\n+                && token.kind != COLON) { \/\/ if its unnamed local variable, it needs to have an init unless in enhanced-for\n+            syntaxError(token.pos, Errors.Expected(EQ));\n+        }\n+\n+        JCVariableDecl result;\n+        if (!isTypePattern) {\n+            int startPos = Position.NOPOS;\n+            JCTree elemType = TreeInfo.innermostType(type, true);\n+            if (elemType.hasTag(IDENT)) {\n+                Name typeName = ((JCIdent) elemType).name;\n+                if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n+                    if (typeName != names.var) {\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n+                    } else if (type.hasTag(TYPEARRAY) && !compound) {\n+                        \/\/error - 'var' and arrays\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n+                    } else {\n+                        declaredUsingVar = true;\n+                        if (compound)\n+                            \/\/error - 'var' in compound local var decl\n+                            reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n+                        startPos = TreeInfo.getStartPos(mods);\n+                        if (startPos == Position.NOPOS)\n+                            startPos = TreeInfo.getStartPos(type);\n+                        \/\/implicit type\n+                        type = null;\n+                    }\n@@ -3722,0 +3696,5 @@\n+            result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n+            attach(result, dc);\n+            result.startPos = startPos;\n+        } else {\n+            result = toP(F.at(pos).VarDef(mods, name, type, null));\n@@ -3723,4 +3702,1 @@\n-        JCVariableDecl result =\n-            toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n-        attach(result, dc);\n-        result.startPos = startPos;\n+\n@@ -3782,5 +3758,1 @@\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {\n-        return variableDeclaratorId(mods, type, false, false);\n-    }\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean catchParameter, boolean lambdaParameter, boolean recordComponent) {\n@@ -3789,32 +3761,8 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n-            log.error(pos, Errors.UnderscoreAsIdentifierInLambda);\n-            name = token.name();\n-            nextToken();\n-        } else {\n-            if (allowThisIdent ||\n-                !lambdaParameter ||\n-                LAX_IDENTIFIER.test(token.kind) ||\n-                mods.flags != Flags.PARAMETER ||\n-                mods.annotations.nonEmpty()) {\n-                JCExpression pn = qualident(false);\n-                if (pn.hasTag(Tag.IDENT) && ((JCIdent)pn).name != names._this) {\n-                    name = ((JCIdent)pn).name;\n-                } else if (lambdaParameter && type == null) {\n-                    \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n-                    type = pn;\n-                    name = names.empty;\n-                    reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n-                } else {\n-                    if (allowThisIdent) {\n-                        if ((mods.flags & Flags.VARARGS) != 0) {\n-                            log.error(token.pos, Errors.VarargsAndReceiver);\n-                        }\n-                        if (token.kind == LBRACKET) {\n-                            log.error(token.pos, Errors.ArrayAndReceiver);\n-                        }\n-                        if (pn.hasTag(Tag.SELECT) && ((JCFieldAccess)pn).name != names._this) {\n-                            log.error(token.pos, Errors.WrongReceiver);\n-                        }\n-                    }\n-                    return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n-                }\n+        if (allowThisIdent ||\n+            !lambdaParameter ||\n+            LAX_IDENTIFIER.test(token.kind) ||\n+            mods.flags != Flags.PARAMETER ||\n+            mods.annotations.nonEmpty()) {\n+            JCExpression pn;\n+            if (token.kind == UNDERSCORE && (catchParameter || lambdaParameter)) {\n+                pn = toP(F.at(token.pos).Ident(identOrUnderscore()));\n@@ -3822,7 +3770,7 @@\n-                \/** if it is a lambda parameter and the token kind is not an identifier,\n-                 *  and there are no modifiers or annotations, then this means that the compiler\n-                 *  supposed the lambda to be explicit but it can contain a mix of implicit,\n-                 *  var or explicit parameters. So we assign the error name to the parameter name\n-                 *  instead of issuing an error and analyze the lambda parameters as a whole at\n-                 *  a higher level.\n-                 *\/\n+                pn = qualident(false);\n+            }\n+            if (pn.hasTag(Tag.IDENT) && ((JCIdent)pn).name != names._this) {\n+                name = ((JCIdent)pn).name;\n+            } else if (lambdaParameter && type == null) {\n+                \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n+                type = pn;\n@@ -3830,0 +3778,14 @@\n+                reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n+            } else {\n+                if (allowThisIdent) {\n+                    if ((mods.flags & Flags.VARARGS) != 0) {\n+                        log.error(token.pos, Errors.VarargsAndReceiver);\n+                    }\n+                    if (token.kind == LBRACKET) {\n+                        log.error(token.pos, Errors.ArrayAndReceiver);\n+                    }\n+                    if (pn.hasTag(Tag.SELECT) && ((JCFieldAccess)pn).name != names._this) {\n+                        log.error(token.pos, Errors.WrongReceiver);\n+                    }\n+                }\n+                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n@@ -3831,0 +3793,9 @@\n+        } else {\n+            \/** if it is a lambda parameter and the token kind is not an identifier,\n+             *  and there are no modifiers or annotations, then this means that the compiler\n+             *  supposed the lambda to be explicit but it can contain a mix of implicit,\n+             *  var or explicit parameters. So we assign the error name to the parameter name\n+             *  instead of issuing an error and analyze the lambda parameters as a whole at\n+             *  a higher level.\n+             *\/\n+            name = names.error;\n@@ -3841,0 +3812,4 @@\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+            name = names.empty;\n+        }\n+\n@@ -3871,1 +3846,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);\n+            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false, false);\n@@ -3876,1 +3851,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false, false);\n@@ -5028,1 +5003,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, false, lambdaParameter, recordComponent);\n@@ -5033,1 +5008,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, false, true, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":208,"deletions":233,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-                writer.print(e.asType().toString() + \" \" + e.getSimpleName() );\n+                writer.print(e.asType().toString() + \" \" + (e.getSimpleName().isEmpty() ? \"_\" : e.getSimpleName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,0 +531,3 @@\n+compiler.err.guard.not.allowed=\\\n+    guards are only allowed for case with a pattern\n+\n@@ -534,0 +537,4 @@\n+# 0: symbol\n+compiler.err.cannot.assign.not.declared.guard=\\\n+    cannot assign to {0}, as it was not declared inside the guard\n+\n@@ -622,4 +629,0 @@\n-# 0: type, 1: type\n-compiler.err.foreach.not.exhaustive.on.type=\\\n-    Pattern {0} is not exhaustive on {1}\n-\n@@ -1503,4 +1506,0 @@\n-# 0: type, 1: type\n-compiler.err.instanceof.pattern.no.subtype=\\\n-    expression type {0} is a subtype of pattern type {1}\n-\n@@ -3135,0 +3134,3 @@\n+compiler.misc.feature.unnamed.variables=\\\n+    unnamed variables\n+\n@@ -3159,3 +3161,3 @@\n-compiler.err.underscore.as.identifier.in.lambda=\\\n-    ''_'' used as an identifier\\n\\\n-    (use of ''_'' as an identifier is forbidden for lambda parameters)\n+compiler.err.use.of.underscore.not.allowed=\\\n+    as of release 21, the underscore keyword ''_'' is only allowed to declare\\n\\\n+    unnamed patterns, local variables, exception parameters or lambda parameters\n@@ -3857,0 +3859,3 @@\n+compiler.err.record.patterns.annotations.not.allowed=\\\n+    annotations not allowed on record patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+        ANYPATTERN,\n@@ -243,1 +244,0 @@\n-        PARENTHESIZEDPATTERN,\n@@ -1225,1 +1225,1 @@\n-        public JCTree varOrRecordPattern;\n+        public JCVariableDecl var;\n@@ -1228,4 +1228,2 @@\n-        public Type elementType;\n-\n-        protected JCEnhancedForLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n-            this.varOrRecordPattern = varOrRecordPattern;\n+        protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n+            this.var = var;\n@@ -1241,5 +1239,1 @@\n-        public JCVariableDecl getVariable() {\n-            return varOrRecordPattern instanceof JCVariableDecl var ? var : null;\n-        }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCTree getVariableOrRecordPattern() { return varOrRecordPattern; }\n+        public JCVariableDecl getVariable() { return var; }\n@@ -1258,4 +1252,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public EnhancedForLoopTree.DeclarationKind getDeclarationKind() {\n-            return varOrRecordPattern.hasTag(VARDEF) ? DeclarationKind.VARIABLE : DeclarationKind.PATTERN;\n-        }\n@@ -1337,0 +1327,1 @@\n+        public JCExpression guard;\n@@ -1341,0 +1332,1 @@\n+                         JCExpression guard,\n@@ -1346,0 +1338,1 @@\n+            this.guard = guard;\n@@ -1368,0 +1361,2 @@\n+        public JCExpression getGuard() { return guard; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n@@ -2255,4 +2250,0 @@\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public TestKind getTestKind() {\n-            return pattern instanceof JCPatternCaseLabel ? TestKind.PATTERN : TestKind.TYPE;\n-        }\n@@ -2276,0 +2267,28 @@\n+    public static class JCAnyPattern extends JCPattern\n+            implements AnyPatternTree {\n+\n+        protected JCAnyPattern() {\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitAnyPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.ANY_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitAnyPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return ANYPATTERN;\n+        }\n+    }\n+\n@@ -2381,1 +2400,1 @@\n-        public JCExpression guard;\n+        public JCExpression syntheticGuard;\n@@ -2383,1 +2402,1 @@\n-        protected JCPatternCaseLabel(JCPattern pat, JCExpression guard) {\n+        protected JCPatternCaseLabel(JCPattern pat) {\n@@ -2385,1 +2404,0 @@\n-            this.guard = guard;\n@@ -2393,5 +2411,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getGuard() {\n-            return guard;\n-        }\n-\n@@ -2421,35 +2434,0 @@\n-    public static class JCParenthesizedPattern extends JCPattern\n-            implements ParenthesizedPatternTree {\n-        public JCPattern pattern;\n-\n-        public JCParenthesizedPattern(JCPattern pattern) {\n-            this.pattern = pattern;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public PatternTree getPattern() {\n-            return pattern;\n-        }\n-\n-        @Override\n-        public void accept(Visitor v) {\n-            v.visitParenthesizedPattern(this);\n-        }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() {\n-            return Kind.PARENTHESIZED_PATTERN;\n-        }\n-\n-        @Override\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n-            return v.visitParenthesizedPattern(this, d);\n-        }\n-\n-        @Override\n-        public Tag getTag() {\n-            return PARENTHESIZEDPATTERN;\n-        }\n-    }\n-\n@@ -3490,1 +3468,1 @@\n-        JCEnhancedForLoop ForeachLoop(JCTree var, JCExpression expr, JCStatement body);\n+        JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);\n@@ -3494,1 +3472,1 @@\n-        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n+        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels, JCExpression guard,\n@@ -3600,0 +3578,1 @@\n+        public void visitAnyPattern(JCAnyPattern that)       { visitTree(that); }\n@@ -3604,1 +3583,0 @@\n-        public void visitParenthesizedPattern(JCParenthesizedPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":43,"deletions":65,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -718,1 +718,5 @@\n-                    print(tree.name);\n+                    if (tree.name.isEmpty()) {\n+                        print('_');\n+                    } else {\n+                        print(tree.name);\n+                    }\n@@ -817,1 +821,1 @@\n-            printExpr(tree.varOrRecordPattern);\n+            printExpr(tree.var);\n@@ -865,0 +869,4 @@\n+            if (tree.guard != null) {\n+                print(\" when \");\n+                print(tree.guard);\n+            }\n@@ -907,4 +915,0 @@\n-            if (tree.guard != null) {\n-                print(\" when \");\n-                print(tree.guard);\n-            }\n@@ -944,2 +948,1 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern patt) {\n+    public void visitAnyPattern(JCAnyPattern patt) {\n@@ -947,3 +950,1 @@\n-            print('(');\n-            printExpr(patt.pattern);\n-            print(')');\n+            print('_');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+        JCExpression guard = copy(t.guard, p);\n@@ -164,1 +165,1 @@\n-        return M.at(t.pos).Case(t.caseKind, labels, stats, body);\n+        return M.at(t.pos).Case(t.caseKind, labels, guard, stats, body);\n@@ -226,1 +227,1 @@\n-        JCTree varOrRecordPattern = copy(t.varOrRecordPattern, p);\n+        JCVariableDecl var = copy(t.var, p);\n@@ -229,1 +230,1 @@\n-        return M.at(t.pos).ForeachLoop(varOrRecordPattern, expr, body);\n+        return M.at(t.pos).ForeachLoop(var, expr, body);\n@@ -501,0 +502,6 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitAnyPattern(AnyPatternTree node, P p) {\n+        JCAnyPattern t = (JCAnyPattern) node;\n+        return M.at(t.pos).AnyPattern();\n+    }\n+\n@@ -508,7 +515,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n-        JCParenthesizedPattern t = (JCParenthesizedPattern) node;\n-        JCPattern pattern = copy(t.pattern, p);\n-        return M.at(t.pos).ParenthesizedPattern(pattern);\n-    }\n-\n@@ -532,2 +532,1 @@\n-        JCExpression guard = copy(t.guard, p);\n-        return M.at(t.pos).PatternCaseLabel(pat, guard);\n+        return M.at(t.pos).PatternCaseLabel(pat);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -651,4 +651,0 @@\n-            case PARENTHESIZEDPATTERN: {\n-                JCParenthesizedPattern node = (JCParenthesizedPattern) tree;\n-                return getEndPos(node.pattern, endPosTable);\n-            }\n@@ -858,9 +854,0 @@\n-    \/** Skip parens and return the enclosed expression\n-     *\/\n-    public static JCPattern skipParens(JCPattern tree) {\n-        while (tree.hasTag(PARENTHESIZEDPATTERN)) {\n-            tree = ((JCParenthesizedPattern) tree).pattern;\n-        }\n-        return tree;\n-    }\n-\n@@ -1361,1 +1348,0 @@\n-            case PARENTHESIZEDPATTERN -> primaryPatternType(((JCParenthesizedPattern) pat).pattern);\n@@ -1363,0 +1349,1 @@\n+            case ANYPATTERN -> ((JCAnyPattern) pat).type;\n@@ -1370,1 +1357,0 @@\n-            case PARENTHESIZEDPATTERN -> primaryPatternTypeTree(((JCParenthesizedPattern) pat).pattern);\n@@ -1383,5 +1369,2 @@\n-    public static boolean unguardedCaseLabel(JCCaseLabel cse) {\n-        if (!cse.hasTag(PATTERNCASELABEL)) {\n-            return true;\n-        }\n-        JCExpression guard = ((JCPatternCaseLabel) cse).guard;\n+    public static boolean unguardedCase(JCCase cse) {\n+        JCExpression guard = cse.guard;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -277,2 +277,2 @@\n-    public JCEnhancedForLoop ForeachLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n-        JCEnhancedForLoop tree = new JCEnhancedForLoop(varOrRecordPattern, expr, body);\n+    public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n+        JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);\n@@ -296,2 +296,2 @@\n-                       List<JCStatement> stats, JCTree body) {\n-        JCCase tree = new JCCase(caseKind, labels, stats, body);\n+                       JCExpression guard, List<JCStatement> stats, JCTree body) {\n+        JCCase tree = new JCCase(caseKind, labels, guard, stats, body);\n@@ -486,0 +486,6 @@\n+    public JCAnyPattern AnyPattern() {\n+        JCAnyPattern tree = new JCAnyPattern();\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -504,8 +510,2 @@\n-    public JCPatternCaseLabel PatternCaseLabel(JCPattern pat, JCExpression guard) {\n-        JCPatternCaseLabel tree = new JCPatternCaseLabel(pat, guard);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n-    public JCParenthesizedPattern ParenthesizedPattern(JCPattern pattern) {\n-        JCParenthesizedPattern tree = new JCParenthesizedPattern(pattern);\n+    public JCPatternCaseLabel PatternCaseLabel(JCPattern pat) {\n+        JCPatternCaseLabel tree = new JCPatternCaseLabel(pat);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -165,1 +166,1 @@\n-        scan(tree.varOrRecordPattern);\n+        scan(tree.var);\n@@ -181,0 +182,1 @@\n+        scan(tree.guard);\n@@ -322,1 +324,0 @@\n-        scan(tree.guard);\n@@ -326,2 +327,2 @@\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        scan(tree.pattern);\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n+    public void visitAnyPattern(JCAnyPattern that) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        tree.varOrRecordPattern = translate(tree.varOrRecordPattern);\n+        tree.var = translate(tree.var);\n@@ -211,0 +211,1 @@\n+        tree.guard = translate(tree.guard);\n@@ -366,0 +367,4 @@\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree;\n+    }\n+\n@@ -380,7 +385,0 @@\n-        tree.guard = translate(tree.guard);\n-        result = tree;\n-    }\n-\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        tree.pattern = translate(tree.pattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    public final Name underscore;\n@@ -95,0 +96,1 @@\n+    public final Name invoke;\n@@ -98,0 +100,1 @@\n+    public final Name of;\n@@ -224,0 +227,1 @@\n+    public final Name enumConstant;\n@@ -262,0 +266,1 @@\n+        underscore = fromString(\"_\");\n@@ -285,0 +290,1 @@\n+        invoke = fromString(\"invoke\");\n@@ -288,0 +294,1 @@\n+        of = fromString(\"of\");\n@@ -418,0 +425,1 @@\n+        enumConstant = fromString(\"enumConstant\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        protocol = protocol.toLowerCase();\n+        protocol = protocol.toLowerCase(Locale.ROOT);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ContextList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        this.protocol = protocol.toLowerCase();\n+        this.protocol = protocol.toLowerCase(Locale.ROOT);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/HttpContextImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n@@ -3305,1 +3305,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n@@ -2988,1 +2988,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_DOUBLE.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_DOUBLE.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n@@ -2994,1 +2994,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_FLOAT.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_FLOAT.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n@@ -3150,1 +3150,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n@@ -3029,1 +3029,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n@@ -3299,1 +3299,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n@@ -4101,1 +4101,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import java.io.IOException;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+class JDKNativePty {\n+\n+    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n+        return LinuxNativePty.current(console);\n+    }\n+\n+    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n+        return LinuxNativePty.open(attr, size);\n+    }\n+\n+    static int isatty(int fd) {\n+        return LinuxNativePty.isatty(fd);\n+    }\n+\n+    static String ttyname(int fd) {\n+        return LinuxNativePty.ttyname(fd);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.linux;\n+\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+\/\/import com.sun.jna.LastErrorException;\n+\/\/import com.sun.jna.Platform;\n+\/\/import com.sun.jna.Structure;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n+import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n+import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n+import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n+import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n+\n+public interface CLibrary {\/\/extends com.sun.jna.Library {\n+\n+    void tcgetattr(int fd, termios termios) throws LastErrorException;\n+\n+    void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n+\n+    void ioctl(int fd, int cmd, winsize data) throws LastErrorException;\n+\n+    int isatty(int fd);\n+\n+    void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n+\n+    class winsize { \/\/extends Structure {\n+        public short ws_row;\n+        public short ws_col;\n+        public short ws_xpixel;\n+        public short ws_ypixel;\n+\n+        public winsize() {\n+        }\n+\n+        public winsize(Size ws) {\n+            ws_row = (short) ws.getRows();\n+            ws_col = (short) ws.getColumns();\n+        }\n+\n+        public Size toSize() {\n+            return new Size(ws_col, ws_row);\n+        }\n+\n+\/\/        @Override\n+\/\/        protected List<String> getFieldOrder() {\n+\/\/            return Arrays.asList(\/\/\n+\/\/                    \"ws_row\",\/\/\n+\/\/                    \"ws_col\",\/\/\n+\/\/                    \"ws_xpixel\",\/\/\n+\/\/                    \"ws_ypixel\"\/\/\n+\/\/            );\n+\/\/        }\n+\n+    }\n+\n+    class termios {\/\/ extends Structure {\n+\n+        public int c_iflag;\n+        public int c_oflag;\n+        public int c_cflag;\n+        public int c_lflag;\n+        public byte c_line;\n+        public byte[] c_cc = new byte[32];\n+        public int c_ispeed;\n+        public int c_ospeed;\n+\n+\/\/        @Override\n+\/\/        protected List<String> getFieldOrder() {\n+\/\/            return Arrays.asList(\/\/\n+\/\/                    \"c_iflag\",\/\/\n+\/\/                    \"c_oflag\",\/\/\n+\/\/                    \"c_cflag\",\/\/\n+\/\/                    \"c_lflag\",\/\/\n+\/\/                    \"c_line\",\/\/\n+\/\/                    \"c_cc\",\/\/\n+\/\/                    \"c_ispeed\",\/\/\n+\/\/                    \"c_ospeed\"\/\/\n+\/\/            );\n+\/\/        }\n+\n+        public termios() {\n+        }\n+\n+        public termios(Attributes t) {\n+            \/\/ Input flags\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNBRK),           IGNBRK,     c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.BRKINT),           BRKINT,     c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNPAR),           IGNPAR,     c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.PARMRK),           PARMRK,     c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.INPCK),            INPCK,      c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.ISTRIP),           ISTRIP,     c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.INLCR),            INLCR,      c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNCR),            IGNCR,      c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.ICRNL),            ICRNL,      c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IXON),             IXON,       c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IXOFF),            IXOFF,      c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IXANY),            IXANY,      c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IMAXBEL),          IMAXBEL,    c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(InputFlag.IUTF8),            IUTF8,      c_iflag);\n+            \/\/ Output flags\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OPOST),          OPOST,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONLCR),          ONLCR,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OCRNL),          OCRNL,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONOCR),          ONOCR,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONLRET),         ONLRET,     c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OFILL),          OFILL,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.NLDLY),          NLDLY,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.TABDLY),         TABDLY,     c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.CRDLY),          CRDLY,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.FFDLY),          FFDLY,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.BSDLY),          BSDLY,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.VTDLY),          VTDLY,      c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OFDEL),          OFDEL,      c_oflag);\n+            \/\/ Control flags\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS5),          CS5,        c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS6),          CS6,        c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS7),          CS7,        c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS8),          CS8,        c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CSTOPB),       CSTOPB,     c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CREAD),        CREAD,      c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.PARENB),       PARENB,     c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.PARODD),       PARODD,     c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.HUPCL),        HUPCL,      c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(ControlFlag.CLOCAL),       CLOCAL,     c_cflag);\n+            \/\/ Local flags\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOKE),           ECHOKE,     c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOE),            ECHOE,      c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOK),            ECHOK,      c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHO),             ECHO,       c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHONL),           ECHONL,     c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOPRT),          ECHOPRT,    c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOCTL),          ECHOCTL,    c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ISIG),             ISIG,       c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ICANON),           ICANON,     c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.EXTPROC),          EXTPROC,    c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.TOSTOP),           TOSTOP,     c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.FLUSHO),           FLUSHO,     c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(LocalFlag.NOFLSH),           NOFLSH,     c_lflag);\n+            \/\/ Control chars\n+            c_cc[VEOF]      = (byte) t.getControlChar(ControlChar.VEOF);\n+            c_cc[VEOL]      = (byte) t.getControlChar(ControlChar.VEOL);\n+            c_cc[VEOL2]     = (byte) t.getControlChar(ControlChar.VEOL2);\n+            c_cc[VERASE]    = (byte) t.getControlChar(ControlChar.VERASE);\n+            c_cc[VWERASE]   = (byte) t.getControlChar(ControlChar.VWERASE);\n+            c_cc[VKILL]     = (byte) t.getControlChar(ControlChar.VKILL);\n+            c_cc[VREPRINT]  = (byte) t.getControlChar(ControlChar.VREPRINT);\n+            c_cc[VINTR]     = (byte) t.getControlChar(ControlChar.VINTR);\n+            c_cc[VQUIT]     = (byte) t.getControlChar(ControlChar.VQUIT);\n+            c_cc[VSUSP]     = (byte) t.getControlChar(ControlChar.VSUSP);\n+            c_cc[VSTART]    = (byte) t.getControlChar(ControlChar.VSTART);\n+            c_cc[VSTOP]     = (byte) t.getControlChar(ControlChar.VSTOP);\n+            c_cc[VLNEXT]    = (byte) t.getControlChar(ControlChar.VLNEXT);\n+            c_cc[VDISCARD]  = (byte) t.getControlChar(ControlChar.VDISCARD);\n+            c_cc[VMIN]      = (byte) t.getControlChar(ControlChar.VMIN);\n+            c_cc[VTIME]     = (byte) t.getControlChar(ControlChar.VTIME);\n+        }\n+\n+        private int setFlag(boolean flag, int value, int org) {\n+            return flag ? (org | value) : org;\n+        }\n+\n+        public Attributes toAttributes() {\n+            Attributes attr = new Attributes();\n+            \/\/ Input flags\n+            EnumSet<InputFlag> iflag = attr.getInputFlags();\n+            addFlag(c_iflag, iflag, InputFlag.IGNBRK,   IGNBRK);\n+            addFlag(c_iflag, iflag, InputFlag.IGNBRK, IGNBRK);\n+            addFlag(c_iflag, iflag, InputFlag.BRKINT, BRKINT);\n+            addFlag(c_iflag, iflag, InputFlag.IGNPAR, IGNPAR);\n+            addFlag(c_iflag, iflag, InputFlag.PARMRK, PARMRK);\n+            addFlag(c_iflag, iflag, InputFlag.INPCK, INPCK);\n+            addFlag(c_iflag, iflag, InputFlag.ISTRIP, ISTRIP);\n+            addFlag(c_iflag, iflag, InputFlag.INLCR, INLCR);\n+            addFlag(c_iflag, iflag, InputFlag.IGNCR, IGNCR);\n+            addFlag(c_iflag, iflag, InputFlag.ICRNL, ICRNL);\n+            addFlag(c_iflag, iflag, InputFlag.IXON, IXON);\n+            addFlag(c_iflag, iflag, InputFlag.IXOFF, IXOFF);\n+            addFlag(c_iflag, iflag, InputFlag.IXANY, IXANY);\n+            addFlag(c_iflag, iflag, InputFlag.IMAXBEL, IMAXBEL);\n+            addFlag(c_iflag, iflag, InputFlag.IUTF8, IUTF8);\n+            \/\/ Output flags\n+            EnumSet<OutputFlag> oflag = attr.getOutputFlags();\n+            addFlag(c_oflag, oflag, OutputFlag.OPOST, OPOST);\n+            addFlag(c_oflag, oflag, OutputFlag.ONLCR, ONLCR);\n+            addFlag(c_oflag, oflag, OutputFlag.OCRNL, OCRNL);\n+            addFlag(c_oflag, oflag, OutputFlag.ONOCR, ONOCR);\n+            addFlag(c_oflag, oflag, OutputFlag.ONLRET, ONLRET);\n+            addFlag(c_oflag, oflag, OutputFlag.OFILL, OFILL);\n+            addFlag(c_oflag, oflag, OutputFlag.NLDLY, NLDLY);\n+            addFlag(c_oflag, oflag, OutputFlag.TABDLY, TABDLY);\n+            addFlag(c_oflag, oflag, OutputFlag.CRDLY, CRDLY);\n+            addFlag(c_oflag, oflag, OutputFlag.FFDLY, FFDLY);\n+            addFlag(c_oflag, oflag, OutputFlag.BSDLY, BSDLY);\n+            addFlag(c_oflag, oflag, OutputFlag.VTDLY, VTDLY);\n+            addFlag(c_oflag, oflag, OutputFlag.OFDEL, OFDEL);\n+            \/\/ Control flags\n+            EnumSet<ControlFlag> cflag = attr.getControlFlags();\n+            addFlag(c_cflag, cflag, ControlFlag.CS5, CS5);\n+            addFlag(c_cflag, cflag, ControlFlag.CS6, CS6);\n+            addFlag(c_cflag, cflag, ControlFlag.CS7, CS7);\n+            addFlag(c_cflag, cflag, ControlFlag.CS8, CS8);\n+            addFlag(c_cflag, cflag, ControlFlag.CSTOPB, CSTOPB);\n+            addFlag(c_cflag, cflag, ControlFlag.CREAD, CREAD);\n+            addFlag(c_cflag, cflag, ControlFlag.PARENB, PARENB);\n+            addFlag(c_cflag, cflag, ControlFlag.PARODD, PARODD);\n+            addFlag(c_cflag, cflag, ControlFlag.HUPCL, HUPCL);\n+            addFlag(c_cflag, cflag, ControlFlag.CLOCAL, CLOCAL);\n+            \/\/ Local flags\n+            EnumSet<LocalFlag> lflag = attr.getLocalFlags();\n+            addFlag(c_lflag, lflag, LocalFlag.ECHOKE, ECHOKE);\n+            addFlag(c_lflag, lflag, LocalFlag.ECHOE, ECHOE);\n+            addFlag(c_lflag, lflag, LocalFlag.ECHOK, ECHOK);\n+            addFlag(c_lflag, lflag, LocalFlag.ECHO, ECHO);\n+            addFlag(c_lflag, lflag, LocalFlag.ECHONL, ECHONL);\n+            addFlag(c_lflag, lflag, LocalFlag.ECHOPRT, ECHOPRT);\n+            addFlag(c_lflag, lflag, LocalFlag.ECHOCTL, ECHOCTL);\n+            addFlag(c_lflag, lflag, LocalFlag.ISIG, ISIG);\n+            addFlag(c_lflag, lflag, LocalFlag.ICANON, ICANON);\n+            addFlag(c_lflag, lflag, LocalFlag.EXTPROC, EXTPROC);\n+            addFlag(c_lflag, lflag, LocalFlag.TOSTOP, TOSTOP);\n+            addFlag(c_lflag, lflag, LocalFlag.FLUSHO, FLUSHO);\n+            addFlag(c_lflag, lflag, LocalFlag.NOFLSH, NOFLSH);\n+            \/\/ Control chars\n+            EnumMap<ControlChar, Integer> cc = attr.getControlChars();\n+            cc.put(ControlChar.VEOF,        (int) c_cc[VEOF]);\n+            cc.put(ControlChar.VEOL,        (int) c_cc[VEOL]);\n+            cc.put(ControlChar.VEOL2,       (int) c_cc[VEOL2]);\n+            cc.put(ControlChar.VERASE,      (int) c_cc[VERASE]);\n+            cc.put(ControlChar.VWERASE,     (int) c_cc[VWERASE]);\n+            cc.put(ControlChar.VKILL,       (int) c_cc[VKILL]);\n+            cc.put(ControlChar.VREPRINT,    (int) c_cc[VREPRINT]);\n+            cc.put(ControlChar.VINTR,       (int) c_cc[VINTR]);\n+            cc.put(ControlChar.VQUIT,       (int) c_cc[VQUIT]);\n+            cc.put(ControlChar.VSUSP,       (int) c_cc[VSUSP]);\n+            cc.put(ControlChar.VSTART,      (int) c_cc[VSTART]);\n+            cc.put(ControlChar.VSTOP,       (int) c_cc[VSTOP]);\n+            cc.put(ControlChar.VLNEXT,      (int) c_cc[VLNEXT]);\n+            cc.put(ControlChar.VDISCARD,    (int) c_cc[VDISCARD]);\n+            cc.put(ControlChar.VMIN,        (int) c_cc[VMIN]);\n+            cc.put(ControlChar.VTIME,       (int) c_cc[VTIME]);\n+            \/\/ Return\n+            return attr;\n+        }\n+\n+        private <T extends Enum<T>> void addFlag(int value, EnumSet<T> flags, T flag, int v) {\n+            if ((value & v) != 0) {\n+                flags.add(flag);\n+            }\n+        }\n+    }\n+\n+    \/\/ CONSTANTS\n+\n+    int TIOCGWINSZ = \/*Platform.isMIPS() || Platform.isPPC() || Platform.isSPARC() ? 0x40087468 : *\/0x00005413;\n+    int TIOCSWINSZ = \/*Platform.isMIPS() || Platform.isPPC() || Platform.isSPARC() ? 0x80087467 : *\/0x00005414;\n+\n+    int VINTR       = 0;\n+    int VQUIT       = 1;\n+    int VERASE      = 2;\n+    int VKILL       = 3;\n+    int VEOF        = 4;\n+    int VTIME       = 5;\n+    int VMIN        = 6;\n+    int VSWTC       = 7;\n+    int VSTART      = 8;\n+    int VSTOP       = 9;\n+    int VSUSP       = 10;\n+    int VEOL        = 11;\n+    int VREPRINT    = 12;\n+    int VDISCARD    = 13;\n+    int VWERASE     = 14;\n+    int VLNEXT      = 15;\n+    int VEOL2       = 16;\n+\n+    int IGNBRK =   0x0000001;\n+    int BRKINT =   0x0000002;\n+    int IGNPAR =   0x0000004;\n+    int PARMRK =   0x0000008;\n+    int INPCK =    0x0000010;\n+    int ISTRIP =   0x0000020;\n+    int INLCR =    0x0000040;\n+    int IGNCR =    0x0000080;\n+    int ICRNL =    0x0000100;\n+    int IUCLC =    0x0000200;\n+    int IXON =     0x0000400;\n+    int IXANY =    0x0000800;\n+    int IXOFF =    0x0001000;\n+    int IMAXBEL =  0x0002000;\n+    int IUTF8 =    0x0004000;\n+\n+    int OPOST =    0x0000001;\n+    int OLCUC =    0x0000002;\n+    int ONLCR =    0x0000004;\n+    int OCRNL =    0x0000008;\n+    int ONOCR =    0x0000010;\n+    int ONLRET =   0x0000020;\n+    int OFILL =    0x0000040;\n+    int OFDEL =    0x0000080;\n+    int NLDLY =    0x0000100;\n+      int NL0 =    0x0000000;\n+      int NL1 =    0x0000100;\n+    int CRDLY =    0x0000600;\n+      int CR0 =    0x0000000;\n+      int CR1 =    0x0000200;\n+      int CR2 =    0x0000400;\n+      int CR3 =    0x0000600;\n+    int TABDLY =   0x0001800;\n+      int TAB0 =   0x0000000;\n+      int TAB1 =   0x0000800;\n+      int TAB2 =   0x0001000;\n+      int TAB3 =   0x0001800;\n+      int XTABS =  0x0001800;\n+    int BSDLY =    0x0002000;\n+      int BS0 =    0x0000000;\n+      int BS1 =    0x0002000;\n+    int VTDLY =    0x0004000;\n+      int VT0 =    0x0000000;\n+      int VT1 =    0x0004000;\n+    int FFDLY =    0x0008000;\n+      int FF0 =    0x0000000;\n+      int FF1 =    0x0008000;\n+\n+    int CBAUD =    0x000100f;\n+     int B0 =      0x0000000;\n+     int B50 =     0x0000001;\n+     int B75 =     0x0000002;\n+     int B110 =    0x0000003;\n+     int B134 =    0x0000004;\n+     int B150 =    0x0000005;\n+     int B200 =    0x0000006;\n+     int B300 =    0x0000007;\n+     int B600 =    0x0000008;\n+     int B1200 =   0x0000009;\n+     int B1800 =   0x000000a;\n+     int B2400 =   0x000000b;\n+     int B4800 =   0x000000c;\n+     int B9600 =   0x000000d;\n+     int B19200 =  0x000000e;\n+     int B38400 =  0x000000f;\n+    int EXTA =  B19200;\n+    int EXTB =  B38400;\n+    int CSIZE =    0x0000030;\n+      int CS5 =    0x0000000;\n+      int CS6 =    0x0000010;\n+      int CS7 =    0x0000020;\n+      int CS8 =    0x0000030;\n+    int CSTOPB =   0x0000040;\n+    int CREAD =    0x0000080;\n+    int PARENB =   0x0000100;\n+    int PARODD =   0x0000200;\n+    int HUPCL =    0x0000400;\n+    int CLOCAL =   0x0000800;\n+\n+    int ISIG =     0x0000001;\n+    int ICANON =   0x0000002;\n+    int XCASE =    0x0000004;\n+    int ECHO =     0x0000008;\n+    int ECHOE =    0x0000010;\n+    int ECHOK =    0x0000020;\n+    int ECHONL =   0x0000040;\n+    int NOFLSH =   0x0000080;\n+    int TOSTOP =   0x0000100;\n+    int ECHOCTL =  0x0000200;\n+    int ECHOPRT =  0x0000400;\n+    int ECHOKE =   0x0000800;\n+    int FLUSHO =   0x0001000;\n+    int PENDIN =   0x0002000;\n+    int IEXTEN =   0x0008000;\n+    int EXTPROC =  0x0010000;\n+\n+    int TCSANOW =          0x0;\n+    int TCSADRAIN =        0x1;\n+    int TCSAFLUSH =        0x2;\n+\n+}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.linux;\n+\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n+\n+public final class CLibraryImpl implements CLibrary {\n+\n+    static {\n+        System.loadLibrary(\"le\");\n+        initIDs();\n+    }\n+\n+    private static native void initIDs();\n+\n+    @Override\n+    public native void tcgetattr(int fd, termios termios) throws LastErrorException;\n+\n+    @Override\n+    public native void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n+\n+    @Override\n+    public void ioctl(int fd, int cmd, winsize data) throws LastErrorException {\n+        if (cmd == CLibrary.TIOCGWINSZ || cmd == CLibrary.TIOCSWINSZ) {\n+            ioctl0(fd, cmd, data);\n+        } else {\n+            throw new UnsupportedOperationException(\"Command: \" + cmd + \", not supported.\");\n+        }\n+    }\n+\n+    private native void ioctl0(int fd, int cmd, winsize data) throws LastErrorException;\n+\n+    @Override\n+    public native int isatty(int fd);\n+\n+    @Override\n+    public native void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n+\n+}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibraryImpl.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.linux;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+\/\/import com.sun.jna.LastErrorException;\n+\/\/import com.sun.jna.Native;\n+\/\/import com.sun.jna.Platform;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.jna.JnaNativePty;\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TCSADRAIN;\n+import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TIOCGWINSZ;\n+import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TIOCSWINSZ;\n+import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.termios;\n+import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.winsize;\n+\n+public class LinuxNativePty extends JnaNativePty {\n+\n+\/\/    private static final CLibrary C_LIBRARY = Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n+    private static final CLibrary C_LIBRARY = new CLibraryImpl();\n+\n+    public interface UtilLibrary {\/\/ extends com.sun.jna.Library {\n+\n+        void openpty(int[] master, int[] slave, byte[] name, CLibrary.termios t, CLibrary.winsize s) throws LastErrorException;\n+\n+\/\/        UtilLibrary INSTANCE = Native.load(\"util\", UtilLibrary.class);\n+        UtilLibrary INSTANCE = new UtilLibraryImpl();\n+    }\n+\n+    public static LinuxNativePty current(TerminalProvider.Stream consoleStream) throws IOException {\n+        switch (consoleStream) {\n+            case Output:\n+                return new LinuxNativePty(-1, null, 0, FileDescriptor.in, 1, FileDescriptor.out, ttyname(0));\n+            case Error:\n+                return new LinuxNativePty(-1, null, 0, FileDescriptor.in, 2, FileDescriptor.err, ttyname(0));\n+            default:\n+                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n+        }\n+    }\n+\n+    public static LinuxNativePty open(Attributes attr, Size size) throws IOException {\n+        int[] master = new int[1];\n+        int[] slave = new int[1];\n+        byte[] buf = new byte[64];\n+        UtilLibrary.INSTANCE.openpty(master, slave, buf,\n+                attr != null ? new termios(attr) : null,\n+                size != null ? new winsize(size) : null);\n+        int len = 0;\n+        while (buf[len] != 0) {\n+            len++;\n+        }\n+        String name = new String(buf, 0, len);\n+        return new LinuxNativePty(master[0], newDescriptor(master[0]), slave[0], newDescriptor(slave[0]), name);\n+    }\n+\n+    public LinuxNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n+        super(master, masterFD, slave, slaveFD, name);\n+    }\n+\n+    public LinuxNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n+        super(master, masterFD, slave, slaveFD, slaveOut, slaveOutFD, name);\n+    }\n+\n+    @Override\n+    public Attributes getAttr() throws IOException {\n+        termios termios = new termios();\n+        C_LIBRARY.tcgetattr(getSlave(), termios);\n+        return termios.toAttributes();\n+    }\n+\n+    @Override\n+    protected void doSetAttr(Attributes attr) throws IOException {\n+        termios termios = new termios(attr);\n+        termios org = new termios();\n+        C_LIBRARY.tcgetattr(getSlave(), org);\n+        org.c_iflag = termios.c_iflag;\n+        org.c_oflag = termios.c_oflag;\n+        org.c_lflag = termios.c_lflag;\n+        System.arraycopy(termios.c_cc, 0, org.c_cc, 0, termios.c_cc.length);\n+        C_LIBRARY.tcsetattr(getSlave(), TCSADRAIN, org);\n+    }\n+\n+    @Override\n+    public Size getSize() throws IOException {\n+        winsize sz = new winsize();\n+        C_LIBRARY.ioctl(getSlave(), TIOCGWINSZ, sz);\n+        return sz.toSize();\n+    }\n+\n+    @Override\n+    public void setSize(Size size) throws IOException {\n+        winsize sz = new winsize(size);\n+        C_LIBRARY.ioctl(getSlave(), TIOCSWINSZ, sz);\n+    }\n+\n+    public static int isatty(int fd) {\n+        return C_LIBRARY.isatty(fd);\n+    }\n+\n+    public static String ttyname(int slave) {\n+        byte[] buf = new byte[64];\n+        C_LIBRARY.ttyname_r(slave, buf, buf.length);\n+        int len = 0;\n+        while (buf[len] != 0) {\n+            len++;\n+        }\n+        return new String(buf, 0, len);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/LinuxNativePty.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.linux;\n+\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n+import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty.UtilLibrary;\n+\n+public final class UtilLibraryImpl implements UtilLibrary {\n+\n+    @Override\n+    public void openpty(int[] master, int[] slave, byte[] name, CLibrary.termios t, CLibrary.winsize s) throws LastErrorException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/UtilLibraryImpl.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <termios.h>\n+#include <unistd.h>\n+#include <sys\/ioctl.h>\n+\n+static jclass lastErrorExceptionClass;\n+static jmethodID lastErrorExceptionConstructor;\n+\n+static jclass termios_j;\n+static jfieldID c_iflag;\n+static jfieldID c_oflag;\n+static jfieldID c_cflag;\n+static jfieldID c_lflag;\n+static jfieldID c_line;\n+static jfieldID c_cc;\n+static jfieldID c_ispeed;\n+static jfieldID c_ospeed;\n+\n+static jclass winsize_j;\n+static jfieldID ws_row;\n+static jfieldID ws_col;\n+static jfieldID ws_xpixel;\n+static jfieldID ws_ypixel;\n+\n+static void throw_errno(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_initIDs\n+  (JNIEnv *env, jclass unused) {\n+    jclass cls;\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n+    CHECK_NULL(cls);\n+    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n+    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n+    CHECK_NULL(lastErrorExceptionConstructor);\n+\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary$termios\");\n+    CHECK_NULL(cls);\n+    termios_j = (jclass) env->NewGlobalRef(cls);\n+    c_iflag = env->GetFieldID(termios_j, \"c_iflag\", \"I\");\n+    CHECK_NULL(c_iflag);\n+    c_oflag = env->GetFieldID(termios_j, \"c_oflag\", \"I\");\n+    CHECK_NULL(c_oflag);\n+    c_cflag = env->GetFieldID(termios_j, \"c_cflag\", \"I\");\n+    CHECK_NULL(c_cflag);\n+    c_lflag = env->GetFieldID(termios_j, \"c_lflag\", \"I\");\n+    CHECK_NULL(c_lflag);\n+    c_line = env->GetFieldID(termios_j, \"c_line\", \"B\");\n+    CHECK_NULL(c_line);\n+    c_cc = env->GetFieldID(termios_j, \"c_cc\", \"[B\");\n+    CHECK_NULL(c_cc);\n+    c_ispeed = env->GetFieldID(termios_j, \"c_ispeed\", \"I\");\n+    CHECK_NULL(c_ispeed);\n+    c_ospeed = env->GetFieldID(termios_j, \"c_ospeed\", \"I\");\n+    CHECK_NULL(c_ospeed);\n+\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary$winsize\");\n+    CHECK_NULL(cls);\n+    winsize_j = (jclass) env->NewGlobalRef(cls);\n+    ws_row = env->GetFieldID(winsize_j, \"ws_row\", \"S\");\n+    CHECK_NULL(ws_row);\n+    ws_col = env->GetFieldID(winsize_j, \"ws_col\", \"S\");\n+    CHECK_NULL(ws_col);\n+    ws_xpixel= env->GetFieldID(winsize_j, \"ws_xpixel\", \"S\");\n+    CHECK_NULL(ws_xpixel);\n+    ws_ypixel= env->GetFieldID(winsize_j, \"ws_ypixel\", \"S\");\n+    CHECK_NULL(ws_ypixel);\n+}\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_tcgetattr\n+  (JNIEnv *env, jobject, jint fd, jobject result) {\n+    termios data;\n+\n+    if (tcgetattr(fd, &data) != 0) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    env->SetIntField(result, c_iflag, data.c_iflag);\n+    env->SetIntField(result, c_oflag, data.c_oflag);\n+    env->SetIntField(result, c_cflag, data.c_cflag);\n+    env->SetIntField(result, c_lflag, data.c_lflag);\n+    env->SetIntField(result, c_line, data.c_line);\n+    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(result, c_cc);\n+    env->SetByteArrayRegion(c_ccValue, 0, NCCS, (signed char *) data.c_cc);\/\/TODO: cast?\n+    env->SetIntField(result, c_ispeed, data.c_ispeed);\n+    env->SetIntField(result, c_ospeed, data.c_ospeed);\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n+ * Method:    tcsetattr\n+ * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary\/termios;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_tcsetattr\n+  (JNIEnv *env, jobject, jint fd, jint cmd, jobject input) {\n+    termios data;\n+\n+    data.c_iflag = env->GetIntField(input, c_iflag);\n+    data.c_oflag = env->GetIntField(input, c_oflag);\n+    data.c_cflag = env->GetIntField(input, c_cflag);\n+    data.c_lflag = env->GetIntField(input, c_lflag);\n+    data.c_line = env->GetIntField(input, c_line);\n+    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(input, c_cc);\n+    env->GetByteArrayRegion(c_ccValue, 0, NCCS, (jbyte *) data.c_cc);\n+    data.c_ispeed = env->GetIntField(input, c_ispeed);\n+    data.c_ospeed = env->GetIntField(input, c_ospeed);\n+\n+    if (tcsetattr(fd, cmd, &data) != 0) {\n+        throw_errno(env);\n+    }\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n+ * Method:    ioctl0\n+ * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary\/winsize;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_ioctl0\n+  (JNIEnv *env, jobject, jint fd, jint cmd, jobject data) {\n+    winsize ws;\n+\n+    ws.ws_row = env->GetIntField(data, ws_row);\n+    ws.ws_col = env->GetIntField(data, ws_col);\n+    ws.ws_xpixel = env->GetIntField(data, ws_xpixel);\n+    ws.ws_ypixel = env->GetIntField(data, ws_ypixel);\n+\n+    if (ioctl(fd, cmd, &ws) != 0) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    env->SetIntField(data, ws_row, ws.ws_row);\n+    env->SetIntField(data, ws_col, ws.ws_col);\n+    env->SetIntField(data, ws_xpixel, ws.ws_xpixel);\n+    env->SetIntField(data, ws_ypixel, ws.ws_ypixel);\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n+ * Method:    isatty\n+ * Signature: (I)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_isatty\n+  (JNIEnv *, jobject, jint fd) {\n+    return isatty(fd);\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n+ * Method:    ttyname_r\n+ * Signature: (I[BI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_ttyname_1r\n+  (JNIEnv *env, jobject, jint fd, jbyteArray buf, jint len) {\n+    char *data = new char[len];\n+    int error = ttyname_r(fd, data, len);\n+\n+    if (error != 0) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    env->SetByteArrayRegion(buf, 0, len, (jbyte *) data);\n+    delete[] data;\n+}\n+\n+\/*\n+ * Throws LastErrorException based on the errno:\n+ *\/\n+static void throw_errno(JNIEnv *env) {\n+    jobject exc = env->NewObject(lastErrorExceptionClass,\n+                                 lastErrorExceptionConstructor,\n+                                 errno);\n+    env->Throw((jthrowable) exc);\n+}\n","filename":"src\/jdk.internal.le\/linux\/native\/lible\/CLibrary.cpp","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import java.io.IOException;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.jna.osx.OsXNativePty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+class JDKNativePty {\n+\n+    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n+        return OsXNativePty.current(console);\n+    }\n+\n+    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n+        return OsXNativePty.open(attr, size);\n+    }\n+\n+    static int isatty(int fd) {\n+        return OsXNativePty.isatty(fd);\n+    }\n+\n+    static String ttyname(int fd) {\n+        return OsXNativePty.ttyname(fd);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.osx;\n+\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+\/\/import com.sun.jna.LastErrorException;\n+\/\/import com.sun.jna.NativeLong;\n+\/\/import com.sun.jna.Structure;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n+import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n+import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n+import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n+import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n+\n+public interface CLibrary {\/\/extends com.sun.jna.Library {\n+\n+    void tcgetattr(int fd, termios termios) throws LastErrorException;\n+\n+    void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n+\n+    void ioctl(int fd, NativeLong cmd, winsize data) throws LastErrorException;\n+\n+    int isatty(int fd);\n+\n+    void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n+\n+    void openpty(int[] master, int[] slave, byte[] name, termios t, winsize s) throws LastErrorException;\n+\n+    class winsize { \/\/extends Structure {\n+        public short ws_row;\n+        public short ws_col;\n+        public short ws_xpixel;\n+        public short ws_ypixel;\n+\n+        public winsize() {\n+        }\n+\n+        public winsize(Size ws) {\n+            ws_row = (short) ws.getRows();\n+            ws_col = (short) ws.getColumns();\n+        }\n+\n+        public Size toSize() {\n+            return new Size(ws_col, ws_row);\n+        }\n+\n+\/\/        @Override\n+\/\/        protected List<String> getFieldOrder() {\n+\/\/            return Arrays.asList(\/\/\n+\/\/                    \"ws_row\",\/\/\n+\/\/                    \"ws_col\",\/\/\n+\/\/                    \"ws_xpixel\",\/\/\n+\/\/                    \"ws_ypixel\"\/\/\n+\/\/            );\n+\/\/        }\n+\n+    }\n+\n+    class termios { \/\/extends Structure {\n+\n+        public NativeLong c_iflag;\n+        public NativeLong c_oflag;\n+        public NativeLong c_cflag;\n+        public NativeLong c_lflag;\n+        public byte[] c_cc = new byte[20];\n+        public NativeLong c_ispeed;\n+        public NativeLong c_ospeed;\n+\n+\/\/        @Override\n+\/\/        protected List<String> getFieldOrder() {\n+\/\/            return Arrays.asList(\/\/\n+\/\/                    \"c_iflag\",\/\/\n+\/\/                    \"c_oflag\",\/\/\n+\/\/                    \"c_cflag\",\/\/\n+\/\/                    \"c_lflag\",\/\/\n+\/\/                    \"c_cc\",\/\/\n+\/\/                    \"c_ispeed\",\/\/\n+\/\/                    \"c_ospeed\"\/\/\n+\/\/            );\n+\/\/        }\n+\n+        {\n+            c_iflag  = new NativeLong(0);\n+            c_oflag  = new NativeLong(0);\n+            c_cflag  = new NativeLong(0);\n+            c_lflag  = new NativeLong(0);\n+            c_ispeed = new NativeLong(0);\n+            c_ospeed = new NativeLong(0);\n+        }\n+\n+        public termios() {\n+        }\n+\n+        public termios(Attributes t) {\n+            \/\/ Input flags\n+            setFlag(t.getInputFlag(InputFlag.IGNBRK),           IGNBRK,     c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.BRKINT),           BRKINT,     c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IGNPAR),           IGNPAR,     c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.PARMRK),           PARMRK,     c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.INPCK),            INPCK,      c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.ISTRIP),           ISTRIP,     c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.INLCR),            INLCR,      c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IGNCR),            IGNCR,      c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.ICRNL),            ICRNL,      c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IXON),             IXON,       c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IXOFF),            IXOFF,      c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IXANY),            IXANY,      c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IMAXBEL),          IMAXBEL,    c_iflag);\n+            setFlag(t.getInputFlag(InputFlag.IUTF8),            IUTF8,      c_iflag);\n+            \/\/ Output flags\n+            setFlag(t.getOutputFlag(OutputFlag.OPOST),          OPOST,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.ONLCR),          ONLCR,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.OXTABS),         OXTABS,     c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.ONOEOT),         ONOEOT,     c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.OCRNL),          OCRNL,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.ONOCR),          ONOCR,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.ONLRET),         ONLRET,     c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.OFILL),          OFILL,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.NLDLY),          NLDLY,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.TABDLY),         TABDLY,     c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.CRDLY),          CRDLY,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.FFDLY),          FFDLY,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.BSDLY),          BSDLY,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.VTDLY),          VTDLY,      c_oflag);\n+            setFlag(t.getOutputFlag(OutputFlag.OFDEL),          OFDEL,      c_oflag);\n+            \/\/ Control flags\n+            setFlag(t.getControlFlag(ControlFlag.CIGNORE),      CIGNORE,    c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CS5),          CS5,        c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CS6),          CS6,        c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CS7),          CS7,        c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CS8),          CS8,        c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CSTOPB),       CSTOPB,     c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CREAD),        CREAD,      c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.PARENB),       PARENB,     c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.PARODD),       PARODD,     c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.HUPCL),        HUPCL,      c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CLOCAL),       CLOCAL,     c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CCTS_OFLOW),   CCTS_OFLOW, c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CRTS_IFLOW),   CRTS_IFLOW, c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CDTR_IFLOW),   CDTR_IFLOW, c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CDSR_OFLOW),   CDSR_OFLOW, c_cflag);\n+            setFlag(t.getControlFlag(ControlFlag.CCAR_OFLOW),   CCAR_OFLOW, c_cflag);\n+            \/\/ Local flags\n+            setFlag(t.getLocalFlag(LocalFlag.ECHOKE),           ECHOKE,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ECHOE),            ECHOE,      c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ECHOK),            ECHOK,      c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ECHO),             ECHO,       c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ECHONL),           ECHONL,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ECHOPRT),          ECHOPRT,    c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ECHOCTL),          ECHOCTL,    c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ISIG),             ISIG,       c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ICANON),           ICANON,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.ALTWERASE),        ALTWERASE,  c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.IEXTEN),           IEXTEN,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.EXTPROC),          EXTPROC,    c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.TOSTOP),           TOSTOP,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.FLUSHO),           FLUSHO,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.NOKERNINFO),       NOKERNINFO, c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.PENDIN),           PENDIN,     c_lflag);\n+            setFlag(t.getLocalFlag(LocalFlag.NOFLSH),           NOFLSH,     c_lflag);\n+            \/\/ Control chars\n+            c_cc[VEOF]      = (byte) t.getControlChar(ControlChar.VEOF);\n+            c_cc[VEOL]      = (byte) t.getControlChar(ControlChar.VEOL);\n+            c_cc[VEOL2]     = (byte) t.getControlChar(ControlChar.VEOL2);\n+            c_cc[VERASE]    = (byte) t.getControlChar(ControlChar.VERASE);\n+            c_cc[VWERASE]   = (byte) t.getControlChar(ControlChar.VWERASE);\n+            c_cc[VKILL]     = (byte) t.getControlChar(ControlChar.VKILL);\n+            c_cc[VREPRINT]  = (byte) t.getControlChar(ControlChar.VREPRINT);\n+            c_cc[VINTR]     = (byte) t.getControlChar(ControlChar.VINTR);\n+            c_cc[VQUIT]     = (byte) t.getControlChar(ControlChar.VQUIT);\n+            c_cc[VSUSP]     = (byte) t.getControlChar(ControlChar.VSUSP);\n+            c_cc[VDSUSP]    = (byte) t.getControlChar(ControlChar.VDSUSP);\n+            c_cc[VSTART]    = (byte) t.getControlChar(ControlChar.VSTART);\n+            c_cc[VSTOP]     = (byte) t.getControlChar(ControlChar.VSTOP);\n+            c_cc[VLNEXT]    = (byte) t.getControlChar(ControlChar.VLNEXT);\n+            c_cc[VDISCARD]  = (byte) t.getControlChar(ControlChar.VDISCARD);\n+            c_cc[VMIN]      = (byte) t.getControlChar(ControlChar.VMIN);\n+            c_cc[VTIME]     = (byte) t.getControlChar(ControlChar.VTIME);\n+            c_cc[VSTATUS]   = (byte) t.getControlChar(ControlChar.VSTATUS);\n+        }\n+\n+        private void setFlag(boolean flag, long value, NativeLong org) {\n+            org.setValue(flag ? org.longValue() | value : org.longValue());\n+        }\n+\n+        public Attributes toAttributes() {\n+            Attributes attr = new Attributes();\n+            \/\/ Input flags\n+            EnumSet<InputFlag> iflag = attr.getInputFlags();\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNBRK,   IGNBRK);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNBRK, IGNBRK);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.BRKINT, BRKINT);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNPAR, IGNPAR);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.PARMRK, PARMRK);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.INPCK, INPCK);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.ISTRIP, ISTRIP);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.INLCR, INLCR);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNCR, IGNCR);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.ICRNL, ICRNL);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IXON, IXON);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IXOFF, IXOFF);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IXANY, IXANY);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IMAXBEL, IMAXBEL);\n+            addFlag(c_iflag.longValue(), iflag, InputFlag.IUTF8, IUTF8);\n+            \/\/ Output flags\n+            EnumSet<OutputFlag> oflag = attr.getOutputFlags();\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.OPOST, OPOST);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONLCR, ONLCR);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.OXTABS, OXTABS);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONOEOT, ONOEOT);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.OCRNL, OCRNL);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONOCR, ONOCR);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONLRET, ONLRET);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.OFILL, OFILL);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.NLDLY, NLDLY);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.TABDLY, TABDLY);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.CRDLY, CRDLY);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.FFDLY, FFDLY);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.BSDLY, BSDLY);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.VTDLY, VTDLY);\n+            addFlag(c_oflag.longValue(), oflag, OutputFlag.OFDEL, OFDEL);\n+            \/\/ Control flags\n+            EnumSet<ControlFlag> cflag = attr.getControlFlags();\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CIGNORE, CIGNORE);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS5, CS5);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS6, CS6);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS7, CS7);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS8, CS8);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CSTOPB, CSTOPB);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CREAD, CREAD);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.PARENB, PARENB);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.PARODD, PARODD);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.HUPCL, HUPCL);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CLOCAL, CLOCAL);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CCTS_OFLOW, CCTS_OFLOW);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CRTS_IFLOW, CRTS_IFLOW);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CDSR_OFLOW, CDSR_OFLOW);\n+            addFlag(c_cflag.longValue(), cflag, ControlFlag.CCAR_OFLOW, CCAR_OFLOW);\n+            \/\/ Local flags\n+            EnumSet<LocalFlag> lflag = attr.getLocalFlags();\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOKE, ECHOKE);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOE, ECHOE);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOK, ECHOK);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHO, ECHO);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHONL, ECHONL);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOPRT, ECHOPRT);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOCTL, ECHOCTL);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ISIG, ISIG);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ICANON, ICANON);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.ALTWERASE, ALTWERASE);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.IEXTEN, IEXTEN);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.EXTPROC, EXTPROC);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.TOSTOP, TOSTOP);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.FLUSHO, FLUSHO);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.NOKERNINFO, NOKERNINFO);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.PENDIN, PENDIN);\n+            addFlag(c_lflag.longValue(), lflag, LocalFlag.NOFLSH, NOFLSH);\n+            \/\/ Control chars\n+            EnumMap<ControlChar, Integer> cc = attr.getControlChars();\n+            cc.put(ControlChar.VEOF,        (int) c_cc[VEOF]);\n+            cc.put(ControlChar.VEOL,        (int) c_cc[VEOL]);\n+            cc.put(ControlChar.VEOL2,       (int) c_cc[VEOL2]);\n+            cc.put(ControlChar.VERASE,      (int) c_cc[VERASE]);\n+            cc.put(ControlChar.VWERASE,     (int) c_cc[VWERASE]);\n+            cc.put(ControlChar.VKILL,       (int) c_cc[VKILL]);\n+            cc.put(ControlChar.VREPRINT,    (int) c_cc[VREPRINT]);\n+            cc.put(ControlChar.VINTR,       (int) c_cc[VINTR]);\n+            cc.put(ControlChar.VQUIT,       (int) c_cc[VQUIT]);\n+            cc.put(ControlChar.VSUSP,       (int) c_cc[VSUSP]);\n+            cc.put(ControlChar.VDSUSP,      (int) c_cc[VDSUSP]);\n+            cc.put(ControlChar.VSTART,      (int) c_cc[VSTART]);\n+            cc.put(ControlChar.VSTOP,       (int) c_cc[VSTOP]);\n+            cc.put(ControlChar.VLNEXT,      (int) c_cc[VLNEXT]);\n+            cc.put(ControlChar.VDISCARD,    (int) c_cc[VDISCARD]);\n+            cc.put(ControlChar.VMIN,        (int) c_cc[VMIN]);\n+            cc.put(ControlChar.VTIME,       (int) c_cc[VTIME]);\n+            cc.put(ControlChar.VSTATUS,     (int) c_cc[VSTATUS]);\n+            \/\/ Return\n+            return attr;\n+        }\n+\n+        private <T extends Enum<T>> void addFlag(long value, EnumSet<T> flags, T flag, int v) {\n+            if ((value & v) != 0) {\n+                flags.add(flag);\n+            }\n+        }\n+    }\n+\n+    \/\/ CONSTANTS\n+\n+     long TIOCGWINSZ = 0x40087468L;\n+     long TIOCSWINSZ = 0x80087467L;\n+\n+     int TCSANOW     = 0x00000000;\n+\n+     int VEOF        = 0;\n+     int VEOL        = 1;\n+     int VEOL2       = 2;\n+     int VERASE      = 3;\n+     int VWERASE     = 4;\n+     int VKILL       = 5;\n+     int VREPRINT    = 6;\n+     int VINTR       = 8;\n+     int VQUIT       = 9;\n+     int VSUSP       = 10;\n+     int VDSUSP      = 11;\n+     int VSTART      = 12;\n+     int VSTOP       = 13;\n+     int VLNEXT      = 14;\n+     int VDISCARD    = 15;\n+     int VMIN        = 16;\n+     int VTIME       = 17;\n+     int VSTATUS     = 18;\n+\n+     int IGNBRK      = 0x00000001;\n+     int BRKINT      = 0x00000002;\n+     int IGNPAR      = 0x00000004;\n+     int PARMRK      = 0x00000008;\n+     int INPCK       = 0x00000010;\n+     int ISTRIP      = 0x00000020;\n+     int INLCR       = 0x00000040;\n+     int IGNCR       = 0x00000080;\n+     int ICRNL       = 0x00000100;\n+     int IXON        = 0x00000200;\n+     int IXOFF       = 0x00000400;\n+     int IXANY       = 0x00000800;\n+     int IMAXBEL     = 0x00002000;\n+     int IUTF8       = 0x00004000;\n+\n+     int OPOST       = 0x00000001;\n+     int ONLCR       = 0x00000002;\n+     int OXTABS      = 0x00000004;\n+     int ONOEOT      = 0x00000008;\n+     int OCRNL       = 0x00000010;\n+     int ONOCR       = 0x00000020;\n+     int ONLRET      = 0x00000040;\n+     int OFILL       = 0x00000080;\n+     int NLDLY       = 0x00000300;\n+     int TABDLY      = 0x00000c04;\n+     int CRDLY       = 0x00003000;\n+     int FFDLY       = 0x00004000;\n+     int BSDLY       = 0x00008000;\n+     int VTDLY       = 0x00010000;\n+     int OFDEL       = 0x00020000;\n+\n+     int CIGNORE     = 0x00000001;\n+     int CS5         = 0x00000000;\n+     int CS6         = 0x00000100;\n+     int CS7         = 0x00000200;\n+     int CS8         = 0x00000300;\n+     int CSTOPB      = 0x00000400;\n+     int CREAD       = 0x00000800;\n+     int PARENB      = 0x00001000;\n+     int PARODD      = 0x00002000;\n+     int HUPCL       = 0x00004000;\n+     int CLOCAL      = 0x00008000;\n+     int CCTS_OFLOW  = 0x00010000;\n+     int CRTS_IFLOW  = 0x00020000;\n+     int CDTR_IFLOW  = 0x00040000;\n+     int CDSR_OFLOW  = 0x00080000;\n+     int CCAR_OFLOW  = 0x00100000;\n+\n+     int ECHOKE      = 0x00000001;\n+     int ECHOE       = 0x00000002;\n+     int ECHOK       = 0x00000004;\n+     int ECHO        = 0x00000008;\n+     int ECHONL      = 0x00000010;\n+     int ECHOPRT     = 0x00000020;\n+     int ECHOCTL     = 0x00000040;\n+     int ISIG        = 0x00000080;\n+     int ICANON      = 0x00000100;\n+     int ALTWERASE   = 0x00000200;\n+     int IEXTEN      = 0x00000400;\n+     int EXTPROC     = 0x00000800;\n+     int TOSTOP      = 0x00400000;\n+     int FLUSHO      = 0x00800000;\n+     int NOKERNINFO  = 0x02000000;\n+     int PENDIN      = 0x20000000;\n+     int NOFLSH      = 0x80000000;\n+\n+}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.osx;\n+\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n+\n+public final class CLibraryImpl implements CLibrary {\n+\n+    static {\n+        System.loadLibrary(\"le\");\n+        initIDs();\n+    }\n+\n+    private static native void initIDs();\n+\n+    @Override\n+    public native void tcgetattr(int fd, termios termios) throws LastErrorException;\n+\n+    @Override\n+    public native void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n+\n+    @Override\n+    public void ioctl(int fd, NativeLong cmd, winsize data) throws LastErrorException {\n+        if (cmd.longValue() == CLibrary.TIOCGWINSZ || cmd.longValue() == CLibrary.TIOCSWINSZ) {\n+            ioctl0(fd, cmd.longValue(), data);\n+        } else {\n+            throw new UnsupportedOperationException(\"Command: \" + cmd + \", not supported.\");\n+        }\n+    }\n+\n+    private native void ioctl0(int fd, long cmd, winsize data) throws LastErrorException;\n+\n+    @Override\n+    public native int isatty(int fd);\n+\n+    @Override\n+    public native void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n+\n+    @Override\n+    public void openpty(int[] master, int[] slave, byte[] name, termios t, winsize s) throws LastErrorException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibraryImpl.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.osx;\n+\n+class NativeLong {\n+\n+    public long value;\n+\n+    public NativeLong(long value) {\n+        this.value = value;\n+    }\n+\n+    public void setValue(long value) {\n+        this.value = value;\n+    }\n+\n+    public long longValue() {\n+        return value;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna.osx;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+\/\/import com.sun.jna.Native;\n+\/\/import com.sun.jna.NativeLong;\n+\/\/import com.sun.jna.Platform;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.jna.JnaNativePty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TCSANOW;\n+import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TIOCGWINSZ;\n+import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TIOCSWINSZ;\n+import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.termios;\n+import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.winsize;\n+\n+public class OsXNativePty extends JnaNativePty {\n+\n+\/\/    private static final CLibrary C_LIBRARY = Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n+    private static final CLibrary C_LIBRARY = new CLibraryImpl();\/\/Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n+\n+    public static OsXNativePty current(TerminalProvider.Stream consoleStream) throws IOException {\n+        switch (consoleStream) {\n+            case Output:\n+                return new OsXNativePty(-1, null, 0, FileDescriptor.in, 1, FileDescriptor.out, ttyname(0));\n+            case Error:\n+                return new OsXNativePty(-1, null, 0, FileDescriptor.in, 2, FileDescriptor.err, ttyname(0));\n+            default:\n+                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n+        }\n+    }\n+\n+    public static OsXNativePty open(Attributes attr, Size size) throws IOException {\n+        int[] master = new int[1];\n+        int[] slave = new int[1];\n+        byte[] buf = new byte[64];\n+        C_LIBRARY.openpty(master, slave, buf,\n+                attr != null ? new termios(attr) : null,\n+                size != null ? new winsize(size) : null);\n+        int len = 0;\n+        while (buf[len] != 0) {\n+            len++;\n+        }\n+        String name = new String(buf, 0, len);\n+        return new OsXNativePty(master[0], newDescriptor(master[0]), slave[0], newDescriptor(slave[0]), name);\n+    }\n+\n+    public OsXNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n+        super(master, masterFD, slave, slaveFD, name);\n+    }\n+\n+    public OsXNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n+        super(master, masterFD, slave, slaveFD, slaveOut, slaveOutFD, name);\n+    }\n+\n+    @Override\n+    public Attributes getAttr() throws IOException {\n+        termios termios = new termios();\n+        C_LIBRARY.tcgetattr(getSlave(), termios);\n+        return termios.toAttributes();\n+    }\n+\n+    @Override\n+    protected void doSetAttr(Attributes attr) throws IOException {\n+        termios termios = new termios(attr);\n+        C_LIBRARY.tcsetattr(getSlave(), TCSANOW, termios);\n+    }\n+\n+    @Override\n+    public Size getSize() throws IOException {\n+        winsize sz = new winsize();\n+        C_LIBRARY.ioctl(getSlave(), new NativeLong(TIOCGWINSZ), sz);\n+        return sz.toSize();\n+    }\n+\n+    @Override\n+    public void setSize(Size size) throws IOException {\n+        winsize sz = new winsize(size);\n+        C_LIBRARY.ioctl(getSlave(), new NativeLong(TIOCSWINSZ), sz);\n+    }\n+\n+    public static int isatty(int fd) {\n+        return C_LIBRARY.isatty(fd);\n+    }\n+\n+    public static String ttyname(int fd) {\n+        byte[] buf = new byte[64];\n+        C_LIBRARY.ttyname_r(fd, buf, buf.length);\n+        int len = 0;\n+        while (buf[len] != 0) {\n+            len++;\n+        }\n+        return new String(buf, 0, len);\n+    }\n+}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/OsXNativePty.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <termios.h>\n+#include <unistd.h>\n+#include <sys\/ioctl.h>\n+\n+static jclass lastErrorExceptionClass;\n+static jmethodID lastErrorExceptionConstructor;\n+\n+static jclass termios_j;\n+static jfieldID c_iflag;\n+static jfieldID c_oflag;\n+static jfieldID c_cflag;\n+static jfieldID c_lflag;\n+static jfieldID c_cc;\n+static jfieldID c_ispeed;\n+static jfieldID c_ospeed;\n+\n+static jclass winsize_j;\n+static jfieldID ws_row;\n+static jfieldID ws_col;\n+static jfieldID ws_xpixel;\n+static jfieldID ws_ypixel;\n+\n+static jclass nativelong_j;\n+static jfieldID nativelong_value;\n+\n+static void throw_errno(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_initIDs\n+  (JNIEnv *env, jclass) {\n+    jclass cls;\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n+    CHECK_NULL(cls);\n+    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n+    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n+    CHECK_NULL(lastErrorExceptionConstructor);\n+\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary$termios\");\n+    CHECK_NULL(cls);\n+    termios_j = (jclass) env->NewGlobalRef(cls);\n+    CHECK_NULL(termios_j);\n+    c_iflag = env->GetFieldID(termios_j, \"c_iflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n+    CHECK_NULL(c_iflag);\n+    c_oflag = env->GetFieldID(termios_j, \"c_oflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n+    CHECK_NULL(c_oflag);\n+    c_cflag = env->GetFieldID(termios_j, \"c_cflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n+    CHECK_NULL(c_cflag);\n+    c_lflag = env->GetFieldID(termios_j, \"c_lflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n+    CHECK_NULL(c_lflag);\n+    c_cc = env->GetFieldID(termios_j, \"c_cc\", \"[B\");\n+    CHECK_NULL(c_cc);\n+    c_ispeed = env->GetFieldID(termios_j, \"c_ispeed\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n+    CHECK_NULL(c_ispeed);\n+    c_ospeed = env->GetFieldID(termios_j, \"c_ospeed\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n+    CHECK_NULL(c_ospeed);\n+\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary$winsize\");\n+    CHECK_NULL(cls);\n+    winsize_j = (jclass) env->NewGlobalRef(cls);\n+    ws_row = env->GetFieldID(winsize_j, \"ws_row\", \"S\");\n+    CHECK_NULL(ws_row);\n+    ws_col = env->GetFieldID(winsize_j, \"ws_col\", \"S\");\n+    CHECK_NULL(ws_col);\n+    ws_xpixel= env->GetFieldID(winsize_j, \"ws_xpixel\", \"S\");\n+    CHECK_NULL(ws_xpixel);\n+    ws_ypixel= env->GetFieldID(winsize_j, \"ws_ypixel\", \"S\");\n+    CHECK_NULL(ws_ypixel);\n+\n+    nativelong_j = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong\");\n+    CHECK_NULL(nativelong_j);\n+    nativelong_value = env->GetFieldID(nativelong_j, \"value\", \"J\");\n+    CHECK_NULL(nativelong_value);\n+}\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_tcgetattr\n+  (JNIEnv *env, jobject, jint fd, jobject result) {\n+    termios data;\n+\n+    if (tcgetattr(fd, &data) != 0) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    env->SetLongField(env->GetObjectField(result, c_iflag), nativelong_value, data.c_iflag);\n+    env->SetLongField(env->GetObjectField(result, c_oflag), nativelong_value, data.c_oflag);\n+    env->SetLongField(env->GetObjectField(result, c_cflag), nativelong_value, data.c_cflag);\n+    env->SetLongField(env->GetObjectField(result, c_lflag), nativelong_value, data.c_lflag);\n+    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(result, c_cc);\n+    env->SetByteArrayRegion(c_ccValue, 0, NCCS, (signed char *) data.c_cc);\n+    env->SetLongField(env->GetObjectField(result, c_ispeed), nativelong_value, data.c_ispeed);\n+    env->SetLongField(env->GetObjectField(result, c_ospeed), nativelong_value, data.c_ospeed);\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n+ * Method:    tcsetattr\n+ * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary\/termios;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_tcsetattr\n+  (JNIEnv *env, jobject, jint fd, jint cmd, jobject input) {\n+    termios data;\n+\n+    data.c_iflag = env->GetLongField(env->GetObjectField(input, c_iflag), nativelong_value);\n+    data.c_oflag = env->GetLongField(env->GetObjectField(input, c_oflag), nativelong_value);\n+    data.c_cflag = env->GetLongField(env->GetObjectField(input, c_cflag), nativelong_value);\n+    data.c_lflag = env->GetLongField(env->GetObjectField(input, c_lflag), nativelong_value);\n+    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(input, c_cc);\n+    env->GetByteArrayRegion(c_ccValue, 0, NCCS, (jbyte *) data.c_cc);\n+    data.c_ispeed = env->GetLongField(env->GetObjectField(input, c_ispeed), nativelong_value);\n+    data.c_ospeed = env->GetLongField(env->GetObjectField(input, c_ospeed), nativelong_value);\n+\n+    if (tcsetattr(fd, cmd, &data) != 0) {\n+        throw_errno(env);\n+    }\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n+ * Method:    ioctl0\n+ * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary\/winsize;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_ioctl0\n+  (JNIEnv *env, jobject, jint fd, jlong cmd, jobject data) {\n+    winsize ws;\n+\n+    ws.ws_row = env->GetIntField(data, ws_row);\n+    ws.ws_col = env->GetIntField(data, ws_col);\n+    ws.ws_xpixel = env->GetIntField(data, ws_xpixel);\n+    ws.ws_ypixel = env->GetIntField(data, ws_ypixel);\n+\n+    if (ioctl(fd, cmd, &ws) != 0) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    env->SetIntField(data, ws_row, ws.ws_row);\n+    env->SetIntField(data, ws_col, ws.ws_col);\n+    env->SetIntField(data, ws_xpixel, ws.ws_xpixel);\n+    env->SetIntField(data, ws_ypixel, ws.ws_ypixel);\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n+ * Method:    isatty\n+ * Signature: (I)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_isatty\n+  (JNIEnv *, jobject, jint fd) {\n+    return isatty(fd);\n+}\n+\n+\/*\n+ * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n+ * Method:    ttyname_r\n+ * Signature: (I[BI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_ttyname_1r\n+  (JNIEnv *env, jobject, jint fd, jbyteArray buf, jint len) {\n+    char *data = new char[len];\n+    int error = ttyname_r(fd, data, len);\n+\n+    if (error != 0) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    env->SetByteArrayRegion(buf, 0, len, (jbyte *) data);\n+    delete[] data;\n+}\n+\n+\/*\n+ * Throws LastErrorException based on the errno:\n+ *\/\n+static void throw_errno(JNIEnv *env) {\n+    jobject exc = env->NewObject(lastErrorExceptionClass,\n+                                 lastErrorExceptionConstructor,\n+                                 errno);\n+    env->Throw((jthrowable) exc);\n+}\n","filename":"src\/jdk.internal.le\/macosx\/native\/lible\/CLibrary.cpp","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -52,1 +52,11 @@\n-        return new JdkConsoleImpl(charset);\n+        try {\n+            Terminal terminal = TerminalBuilder.builder().encoding(charset)\n+                                               .exec(false).build();\n+            return new JdkConsoleImpl(terminal);\n+        } catch (IllegalStateException ise) {\n+            \/\/cannot create a non-dumb, non-exec terminal,\n+            \/\/use the standard Console:\n+            return null;\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n@@ -122,7 +132,3 @@\n-        public JdkConsoleImpl(Charset charset) {\n-            try {\n-                terminal = TerminalBuilder.builder().encoding(charset).build();\n-                jline = LineReaderBuilder.builder().terminal(terminal).build();\n-            } catch (IOException ioe) {\n-                throw new UncheckedIOException(ioe);\n-            }\n+        public JdkConsoleImpl(Terminal terminal) {\n+            this.terminal = terminal;\n+            this.jline = LineReaderBuilder.builder().terminal(terminal).build();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+@SuppressWarnings(\"serial\")\n+public class LastErrorException extends RuntimeException{\n+\n+    public final long lastError;\n+\n+    public LastErrorException(long lastError) {\n+        this.lastError = lastError;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+\n+\/\/import com.sun.jna.Platform;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractPty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+\/\/import jdk.internal.org.jline.terminal.impl.jna.freebsd.FreeBsdNativePty;\n+\/\/import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty;\n+\/\/import jdk.internal.org.jline.terminal.impl.jna.osx.OsXNativePty;\n+\/\/import jdk.internal.org.jline.terminal.impl.jna.solaris.SolarisNativePty;\n+\n+public abstract class JnaNativePty extends AbstractPty implements Pty {\n+\n+    private final int master;\n+    private final int slave;\n+    private final int slaveOut;\n+    private final String name;\n+    private final FileDescriptor masterFD;\n+    private final FileDescriptor slaveFD;\n+    private final FileDescriptor slaveOutFD;\n+\n+    public static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n+\/\/        if (Platform.isMac()) {\n+\/\/            if (Platform.is64Bit() && Platform.isARM()) {\n+\/\/                throw new UnsupportedOperationException();\n+\/\/            }\n+\/\/            return OsXNativePty.current(console);\n+\/\/        } else if (Platform.isLinux()) {\n+\/\/            return LinuxNativePty.current(console);\n+\/\/        } else if (Platform.isSolaris()) {\n+\/\/            return SolarisNativePty.current(console);\n+\/\/        } else if (Platform.isFreeBSD()) {\n+\/\/            return FreeBsdNativePty.current(console);\n+\/\/        } else {\n+\/\/            throw new UnsupportedOperationException();\n+\/\/        }\n+        return JDKNativePty.current(console);\n+    }\n+\n+    public static JnaNativePty open(Attributes attr, Size size) throws IOException {\n+\/\/        if (Platform.isMac()) {\n+\/\/            return OsXNativePty.open(attr, size);\n+\/\/        } else if (Platform.isLinux()) {\n+\/\/            return LinuxNativePty.open(attr, size);\n+\/\/        } else if (Platform.isSolaris()) {\n+\/\/            return SolarisNativePty.open(attr, size);\n+\/\/        } else if (Platform.isFreeBSD()) {\n+\/\/            return FreeBsdNativePty.open(attr, size);\n+\/\/        } else {\n+\/\/            throw new UnsupportedOperationException();\n+\/\/        }\n+        return JDKNativePty.open(attr, size);\n+    }\n+\n+    protected JnaNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n+        this(master, masterFD, slave, slaveFD, slave, slaveFD, name);\n+    }\n+\n+    protected JnaNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n+        this.master = master;\n+        this.slave = slave;\n+        this.slaveOut = slaveOut;\n+        this.name = name;\n+        this.masterFD = masterFD;\n+        this.slaveFD = slaveFD;\n+        this.slaveOutFD = slaveOutFD;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (master > 0) {\n+            getMasterInput().close();\n+        }\n+        if (slave > 0) {\n+            getSlaveInput().close();\n+        }\n+    }\n+\n+    public int getMaster() {\n+        return master;\n+    }\n+\n+    public int getSlave() {\n+        return slave;\n+    }\n+\n+    public int getSlaveOut() {\n+        return slaveOut;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public FileDescriptor getMasterFD() {\n+        return masterFD;\n+    }\n+\n+    public FileDescriptor getSlaveFD() {\n+        return slaveFD;\n+    }\n+\n+    public FileDescriptor getSlaveOutFD() {\n+        return slaveOutFD;\n+    }\n+\n+    public InputStream getMasterInput() {\n+        return new FileInputStream(getMasterFD());\n+    }\n+\n+    public OutputStream getMasterOutput() {\n+        return new FileOutputStream(getMasterFD());\n+    }\n+\n+    protected InputStream doGetSlaveInput() {\n+        return new FileInputStream(getSlaveFD());\n+    }\n+\n+    public OutputStream getSlaveOutput() {\n+        return new FileOutputStream(getSlaveOutFD());\n+    }\n+\n+    protected static FileDescriptor newDescriptor(int fd) {\n+        try {\n+            Constructor<FileDescriptor> cns = FileDescriptor.class.getDeclaredConstructor(int.class);\n+            cns.setAccessible(true);\n+            return cns.newInstance(fd);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to create FileDescriptor\", e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"JnaNativePty[\" + getName() + \"]\";\n+    }\n+\n+    public static boolean isPosixSystemStream(TerminalProvider.Stream stream) {\n+        switch (stream) {\n+            case Input: return isatty(0);\n+            case Output: return isatty(1);\n+            case Error: return isatty(2);\n+            default: return false;\n+        }\n+    }\n+\n+    public static String posixSystemStreamName(TerminalProvider.Stream stream) {\n+        switch (stream) {\n+            case Input: return ttyname(0);\n+            case Output: return ttyname(1);\n+            case Error: return ttyname(2);\n+            default: return null;\n+        }\n+    }\n+\n+    private static boolean isatty(int fd) {\n+\/\/        if (Platform.isMac()) {\n+\/\/            return OsXNativePty.isatty(fd) == 1;\n+\/\/        } else if (Platform.isLinux()) {\n+\/\/            return LinuxNativePty.isatty(fd) == 1;\n+\/\/        } else if (Platform.isSolaris()) {\n+\/\/            return SolarisNativePty.isatty(fd) == 1;\n+\/\/        } else if (Platform.isFreeBSD()) {\n+\/\/            return FreeBsdNativePty.isatty(fd) == 1;\n+\/\/        } else {\n+\/\/            return false;\n+\/\/        }\n+        return JDKNativePty.isatty(fd) == 1;\n+    }\n+\n+    private static String ttyname(int fd) {\n+\/\/        if (Platform.isMac()) {\n+\/\/            return OsXNativePty.ttyname(fd);\n+\/\/        } else if (Platform.isLinux()) {\n+\/\/            return LinuxNativePty.ttyname(fd);\n+\/\/        } else if (Platform.isSolaris()) {\n+\/\/            return SolarisNativePty.ttyname(fd);\n+\/\/        } else if (Platform.isFreeBSD()) {\n+\/\/            return FreeBsdNativePty.ttyname(fd);\n+\/\/        } else {\n+\/\/            return null;\n+\/\/        }\n+        return JDKNativePty.ttyname(fd);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaNativePty.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+\/\/import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+public class JnaTerminalProvider implements TerminalProvider\n+{\n+    @Override\n+    public String name() {\n+        return \"jna\";\n+    }\n+\n+    public Pty current(TerminalProvider.Stream console) throws IOException {\n+        return JnaNativePty.current(console);\n+    }\n+\n+    public Pty open(Attributes attributes, Size size) throws IOException {\n+        return JnaNativePty.open(attributes, size);\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+\/\/        if (OSUtils.IS_WINDOWS) {\n+\/\/            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream );\n+\/\/        } else {\n+            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+\/\/        }\n+    }\n+\n+\/\/    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+\/\/                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+\/\/                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+\/\/        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console);\n+\/\/    }\n+\/\/\n+    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+\/\/        Pty pty = jdk.internal.org.jline.terminal.impl.ExecPty.current(consoleStream);\n+        Pty pty = current(consoleStream);\n+        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+        Pty pty = open(attributes, size);\n+        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+\/\/            if (OSUtils.IS_WINDOWS) {\n+\/\/                return isWindowsSystemStream(stream);\n+\/\/            } else {\n+                return isPosixSystemStream(stream);\n+\/\/            }\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+\/\/    public boolean isWindowsSystemStream(Stream stream) {\n+\/\/        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n+\/\/    }\n+\n+    public boolean isPosixSystemStream(Stream stream) {\n+        return JnaNativePty.isPosixSystemStream(stream);\n+    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+        if (OSUtils.IS_WINDOWS) {\n+            return null;\n+        } else {\n+            return JnaNativePty.posixSystemStreamName(stream);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -15,0 +15,1 @@\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinConsoleWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32Impl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-@SuppressWarnings(\"serial\")\n-class LastErrorException extends RuntimeException{\n-\n-    public final long lastError;\n-\n-    public LastErrorException(long lastError) {\n-        this.lastError = lastError;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/LastErrorException.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -144,1 +144,1 @@\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/LastErrorException\");\n+    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n","filename":"src\/jdk.internal.le\/windows\/native\/lible\/Kernel32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,2 +289,2 @@\n-     * Gets the {@code JVM_CONSTANT_NameAndType} index from the entry at index {@code cpi} in\n-     * {@code constantPool}.\n+     * Gets the {@code JVM_CONSTANT_NameAndType} index referenced by the {@code rawIndex}.\n+     * The meaning of {@code rawIndex} is dependent on the given {@opcode}.\n@@ -292,2 +292,3 @@\n-     * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a\n-     * {@code JVM_CONSTANT_NameAndType} index.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -295,2 +296,2 @@\n-    int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return lookupNameAndTypeRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupNameAndTypeRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -299,1 +300,1 @@\n-    private native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n@@ -302,2 +303,3 @@\n-     * Gets the name of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry\n-     * denoted by {@code which} in {@code constantPool}.\n+     * Gets the name of the {@code JVM_CONSTANT_NameAndType} entry in {@code constantPool}\n+     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * on the given {@opcode}.\n@@ -305,2 +307,3 @@\n-     * The behavior of this method is undefined if {@code which} does not denote a entry that\n-     * references a {@code JVM_CONSTANT_NameAndType} entry.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -308,2 +311,2 @@\n-    String lookupNameInPool(HotSpotConstantPool constantPool, int which) {\n-        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    String lookupNameInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -312,1 +315,1 @@\n-    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n+    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n@@ -315,2 +318,3 @@\n-     * Gets the signature of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry\n-     * denoted by {@code which} in {@code constantPool}.\n+     * Gets the signature of the {@code JVM_CONSTANT_NameAndType} entry in {@code constantPool}\n+     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * on the given {@opcode}.\n@@ -318,2 +322,3 @@\n-     * The behavior of this method is undefined if {@code which} does not denote a entry that\n-     * references a {@code JVM_CONSTANT_NameAndType} entry.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -321,2 +326,2 @@\n-    String lookupSignatureInPool(HotSpotConstantPool constantPool, int which) {\n-        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    String lookupSignatureInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -325,1 +330,1 @@\n-    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n+    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n@@ -328,2 +333,3 @@\n-     * Gets the {@code JVM_CONSTANT_Class} index from the entry at index {@code cpi} in\n-     * {@code constantPool}.\n+     * Gets the {@code JVM_CONSTANT_Class} index from the entry in {@code constantPool}\n+     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * on the given {@opcode}.\n@@ -331,2 +337,3 @@\n-     * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a\n-     * {@code JVM_CONSTANT_Class} index.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -334,2 +341,2 @@\n-    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -338,1 +345,1 @@\n-    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -392,1 +392,2 @@\n-     * @param index constant pool index\n+     * @param rawIndex rewritten index in the bytecode stream\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -395,2 +396,2 @@\n-    private int getNameAndTypeRefIndexAt(int index) {\n-        return compilerToVM().lookupNameAndTypeRefIndexInPool(this, index);\n+    private int getNameAndTypeRefIndexAt(int rawIndex, int opcode) {\n+        return compilerToVM().lookupNameAndTypeRefIndexInPool(this, rawIndex, opcode);\n@@ -403,1 +404,2 @@\n-     * @param which constant pool index or constant pool cache index\n+     * @param rawIndex rewritten index in the bytecode stream\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -406,2 +408,2 @@\n-    private String getNameOf(int which) {\n-        return compilerToVM().lookupNameInPool(this, which);\n+    private String getNameOf(int rawIndex, int opcode) {\n+        return compilerToVM().lookupNameInPool(this, rawIndex, opcode);\n@@ -427,1 +429,2 @@\n-     * @param which constant pool index or constant pool cache index\n+     * @param rawIndex rewritten index in the bytecode stream\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -430,2 +433,2 @@\n-    private String getSignatureOf(int which) {\n-        return compilerToVM().lookupSignatureInPool(this, which);\n+    private String getSignatureOf(int rawIndex, int opcode) {\n+        return compilerToVM().lookupSignatureInPool(this, rawIndex, opcode);\n@@ -450,1 +453,2 @@\n-     * @param index constant pool index\n+     * @param rawIndex rewritten index in the bytecode stream\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -453,2 +457,2 @@\n-    private int getKlassRefIndexAt(int index) {\n-        return compilerToVM().lookupKlassRefIndexInPool(this, index);\n+    private int getKlassRefIndexAt(int rawIndex, int opcode) {\n+        return compilerToVM().lookupKlassRefIndexInPool(this, rawIndex, opcode);\n@@ -713,2 +717,2 @@\n-            String name = getNameOf(index);\n-            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index));\n+            String name = getNameOf(index, opcode);\n+            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index, opcode));\n@@ -718,1 +722,1 @@\n-                final int klassIndex = getKlassRefIndexAt(index);\n+                final int klassIndex = getKlassRefIndexAt(index, opcode);\n@@ -763,1 +767,1 @@\n-                index = getKlassRefIndexAt(index);\n+                index = getKlassRefIndexAt(index, opcode);\n@@ -776,1 +780,1 @@\n-        final int nameAndTypeIndex = getNameAndTypeRefIndexAt(index);\n+        final int nameAndTypeIndex = getNameAndTypeRefIndexAt(index, opcode);\n@@ -781,1 +785,1 @@\n-        final int holderIndex = getKlassRefIndexAt(index);\n+        final int holderIndex = getKlassRefIndexAt(index, opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+        p = skipWhitespace(p); \/\/ no-op on first iteration\n@@ -91,1 +92,0 @@\n-        p = skipWhitespace(p);\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+        archName = archName.replace(\"s390x\", \"S390\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -108,0 +108,36 @@\n+    \/**\n+     * Returns an approximation of the total amount of memory, in bytes, allocated\n+     * in heap memory by all threads since the Java virtual machine started.\n+     * The returned value is an approximation because some Java virtual machine\n+     * implementations may use object allocation mechanisms that result in a\n+     * delay between the time an object is allocated and the time its size is\n+     * recorded.\n+     *\n+     * @implSpec The default implementation throws {@code UnsupportedOperationException}\n+     * if the Java virtual machine implementation does not support thread\n+     * memory allocation measurement, and otherwise acts as though thread\n+     * memory allocation measurement is disabled.\n+     *\n+     * @return an approximation of the total memory allocated, in bytes, in\n+     * heap memory since the Java virtual machine was started,\n+     * if thread memory allocation measurement is enabled;\n+     * {@code -1} otherwise.\n+     *\n+     * @throws UnsupportedOperationException if the Java virtual\n+     *         machine implementation does not support thread memory allocation\n+     *         measurement.\n+     *\n+     * @see #isThreadAllocatedMemorySupported\n+     * @see #isThreadAllocatedMemoryEnabled\n+     * @see #setThreadAllocatedMemoryEnabled\n+     *\n+     * @since 21\n+     *\/\n+    public default long getTotalThreadAllocatedBytes() {\n+        if (!isThreadAllocatedMemorySupported()) {\n+            throw new UnsupportedOperationException(\n+                \"Thread allocated memory measurement is not supported.\");\n+        }\n+        return -1;\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+    @Override\n+    public long getTotalThreadAllocatedBytes() {\n+        return super.getTotalThreadAllocatedBytes();\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/HotSpotThreadImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-   EXPECT_GE((size_t) ObjectMonitor::owner_offset_in_bytes(), cache_line_size)\n+   EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n","filename":"test\/hotspot\/gtest\/runtime\/test_objectMonitor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-vmTestbase\/nsk\/jvmti\/PopFrame\/popframe004\/TestDescription.java           8300708 generic-all\n@@ -122,0 +121,2 @@\n+vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes001\/TestDescription.java 8308237 generic-all\n+\n@@ -144,0 +145,1 @@\n+gc\/g1\/TestSkipRebuildRemsetPhase.java 0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n@@ -60,1 +60,1 @@\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n@@ -63,2 +63,2 @@\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n@@ -107,0 +107,1 @@\n+containers\/docker\/TestMemoryAwareness.java 8303470 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -696,2 +696,1 @@\n-  vmTestbase\/gc\/ArrayJuggle\/ \\\n-  vmTestbase\/gc\/memory\/Array\/ArrayJuggle\n+  vmTestbase\/gc\/ArrayJuggle\/\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1487,5 +1487,1 @@\n-  vmTestbase\/gc\/ArrayJuggle\/Juggle01 \\\n-  vmTestbase\/gc\/ArrayJuggle\/Juggle14 \\\n-  vmTestbase\/gc\/ArrayJuggle\/Juggle22 \\\n-  vmTestbase\/gc\/ArrayJuggle\/Juggle29 \\\n-  vmTestbase\/gc\/ArrayJuggle\/Juggle34 \\\n+  vmTestbase\/gc\/ArrayJuggle\/Juggle3Quick.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,2 +109,2 @@\n-    public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int rawIndex, int opcode) {\n+        return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, rawIndex, opcode);\n@@ -113,2 +113,2 @@\n-    public static String lookupNameInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupNameInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static String lookupNameInPool(ConstantPool constantPool, int rawIndex, int opcode) {\n+        return CTVM.lookupNameInPool((HotSpotConstantPool) constantPool, rawIndex, opcode);\n@@ -117,2 +117,2 @@\n-    public static String lookupSignatureInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupSignatureInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static String lookupSignatureInPool(ConstantPool constantPool, int rawIndex, int opcode) {\n+        return CTVM.lookupSignatureInPool((HotSpotConstantPool) constantPool, rawIndex, opcode);\n@@ -121,2 +121,2 @@\n-    public static int lookupKlassRefIndexInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupKlassRefIndexInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static int lookupKlassRefIndexInPool(ConstantPool constantPool, int rawIndex, int opcode) {\n+        return CTVM.lookupKlassRefIndexInPool((HotSpotConstantPool) constantPool, rawIndex, opcode);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.vm.ci.hotspot.HotSpotConstantPool.Bytecodes;\n@@ -100,0 +101,23 @@\n+    \/**\n+     *\n+     * @param cpType Constant type from the Constant pool\n+     * @return a bytecode that's suitable for passing to the following functions for the given cpType:\n+     *     - CompilerToVMHelper.lookupNameAndTypeRefIndexInPool()\n+     *     - CompilerToVMHelper.lookupNameInPool()\n+     *     - CompilerToVMHelper.lookupSignatureInPool()\n+     *     - CompilerToVMHelper.lookupKlassRefIndexInPool()\n+     *\/\n+    public static int getDummyOpcode(ConstantTypes cpType) {\n+        switch (cpType) {\n+            case CONSTANT_FIELDREF:\n+              return Bytecodes.GETFIELD;\n+          case CONSTANT_METHODREF:\n+              return Bytecodes.INVOKEVIRTUAL;\n+          case CONSTANT_INTERFACEMETHODREF:\n+              return Bytecodes.INVOKEINTERFACE;\n+          case CONSTANT_INVOKEDYNAMIC:\n+              return Bytecodes.INVOKEDYNAMIC;\n+          default:\n+              throw new IllegalArgumentException(\"Unexpected constant pool entry type\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ConstantPoolTestsHelper.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,8 +96,4 @@\n-        int index = cpi;\n-        String cached = \"\";\n-        int cpci = dummyClass.getCPCacheIndex(cpi);\n-        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            index = cpci;\n-            cached = \"cached \";\n-        }\n-        int indexToVerify = CompilerToVMHelper.lookupKlassRefIndexInPool(constantPoolCTVM, index);\n+        int opcode = ConstantPoolTestsHelper.getDummyOpcode(cpType);\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        int indexToVerify = CompilerToVMHelper.lookupKlassRefIndexInPool(constantPoolCTVM, index, opcode);\n@@ -106,3 +102,1 @@\n-                                           + \"applied to %sconstant pool index %d\",\n-                                   cached,\n-                                   index);\n+                                           + \"applied to cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupKlassRefIndexInPoolTest.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,8 +98,4 @@\n-        int index = cpi;\n-        String cached = \"\";\n-        int cpci = dummyClass.getCPCacheIndex(cpi);\n-        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            index = cpci;\n-            cached = \"cached \";\n-        }\n-        int indexToVerify = CompilerToVMHelper.lookupNameAndTypeRefIndexInPool(constantPoolCTVM, index);\n+        int opcode = ConstantPoolTestsHelper.getDummyOpcode(cpType);\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        int indexToVerify = CompilerToVMHelper.lookupNameAndTypeRefIndexInPool(constantPoolCTVM, index, opcode);\n@@ -108,3 +104,1 @@\n-                                           + \" method applied to %sconstant pool index %d\",\n-                                   cached,\n-                                   index);\n+                                           + \" method applied to cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupNameAndTypeRefIndexInPoolTest.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,8 +99,4 @@\n-        int index = cpi;\n-        String cached = \"\";\n-        int cpci = dummyClass.getCPCacheIndex(cpi);\n-        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            index = cpci;\n-            cached = \"cached \";\n-        }\n-        String nameToVerify = CompilerToVMHelper.lookupNameInPool(constantPoolCTVM, index);\n+        int opcode = ConstantPoolTestsHelper.getDummyOpcode(cpType);\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        String nameToVerify = CompilerToVMHelper.lookupNameInPool(constantPoolCTVM, index, opcode);\n@@ -108,1 +104,1 @@\n-        String msg = String.format(\"Wrong name accessed by %sconstant pool index %d\", cached, index);\n+        String msg = String.format(\"Wrong name accessed by cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupNameInPoolTest.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,8 +99,4 @@\n-        int index = cpi;\n-        String cached = \"\";\n-        int cpci = dummyClass.getCPCacheIndex(cpi);\n-        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            index = cpci;\n-            cached = \"cached \";\n-        }\n-        String sigToVerify = CompilerToVMHelper.lookupSignatureInPool(constantPoolCTVM, index);\n+        int opcode = ConstantPoolTestsHelper.getDummyOpcode(cpType);\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        String sigToVerify = CompilerToVMHelper.lookupSignatureInPool(constantPoolCTVM, index, opcode);\n@@ -108,3 +104,1 @@\n-        String msg = String.format(\"Wrong signature accessed by %sconstant pool index %d\",\n-                                   cached,\n-                                   index);\n+        String msg = String.format(\"Wrong signature accessed by cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupSignatureInPoolTest.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpingWithNoCoops.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/DifferentHeapSizes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+ * @requires vm.flagless\n@@ -51,0 +52,1 @@\n+ * @requires vm.flagless\n@@ -62,0 +64,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/IncompatibleOptions.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm ReflectOutOfMemoryError\n+ * @run main\/othervm\/timeout=150 ReflectOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ReflectOutOfMemoryError.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.concurrent.locks.LockSupport;\n@@ -52,0 +53,7 @@\n+        Runnable task = () -> {\n+            String result = \"string\" + System.currentTimeMillis();\n+            \/\/ Park to provoke re-mounting of virtual thread.\n+            LockSupport.parkNanos(1);\n+            Reference.reachabilityFence(result);\n+        };\n+\n@@ -55,5 +63,5 @@\n-                Thread t = new Thread(() -> {\n-                        String result = \"string\" + System.currentTimeMillis();\n-                        Reference.reachabilityFence(result);\n-                });\n-                threads.add(t);\n+                threads.add(Thread.ofVirtual().unstarted(task));\n+                threads.add(Thread.ofPlatform().unstarted(task));\n+            }\n+\n+            for (Thread t: threads) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/DynamicCodeGenerated\/DynamicCodeGeneratedTest.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvmti_common.h\"\n@@ -46,1 +47,1 @@\n-\n+  LOG(\"Event: %s\\n\", name);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/DynamicCodeGenerated\/libDynamicCodeGenerated.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,4 +118,0 @@\n-  LOG(\"Testing PopFrame\\n\");\n-  err = jvmti->PopFrame(vthread);\n-  check_jvmti_error_opaque_frame(jni, \"PopFrame\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/BoundVThreadTest\/libBoundVThreadTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Verifies JVMTI PopFrame support for virtual threads.\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native -agentlib:PopFrameTest PopFrameTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @summary Verifies JVMTI PopFrame support for bound virtual threads.\n+ * @run main\/othervm\/native -agentlib:PopFrameTest -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations PopFrameTest\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @summary Verifies JVMTI PopFrame support for platform threads.\n+ * @run main\/othervm\/native -agentlib:PopFrameTest PopFrameTest platform\n+ *\/\n+\n+import java.lang.AssertionError;\n+\n+\/*\n+ *     The test exercises the JVMTI function PopFrame.\n+ *     The test creates a new virtual or platform thread.\n+ *     Its method run() invokes the following methods:\n+ *      - method A() that is blocked on a monitor\n+ *      - method B() that is stopped at a breakpoint\n+ *      - method C() that forces agent to call PopFrame on its own thread\n+ *     JVMTI PopFrame is called in all cases.\n+ *\/\n+public class PopFrameTest {\n+    private static final String agentLib = \"PopFrameTest\";\n+    static final int JVMTI_ERROR_NONE = 0;\n+    static final int THREAD_NOT_SUSPENDED = 13;\n+    static final int OPAQUE_FRAME = 32;\n+    static final int PASSED = 0;\n+    static final int FAILED = 2;\n+\n+    static void log(String str) { System.out.println(str); }\n+\n+    static native void prepareAgent(Class taskClass, boolean doPopFrame);\n+    static native void suspendThread(Thread thread);\n+    static native void resumeThread(Thread thread);\n+    static native void ensureAtBreakpoint();\n+    static native void notifyAtBreakpoint();\n+    static native int  popFrame(Thread thread);\n+\n+    static int status = PASSED;\n+    static boolean is_virtual = true;\n+\n+    static void setFailed(String msg) {\n+        log(\"\\nFAILED: \" + msg);\n+        status = FAILED;\n+    }\n+\n+    static void throwFailed(String msg) {\n+        log(\"\\nFAILED: \" + msg);\n+        throw new RuntimeException(\"PopFrameTest failed!\");\n+    }\n+\n+    public static void main(String args[]) {\n+        is_virtual = !(args.length > 0 && args[0].equals(\"platform\"));\n+        run();\n+        if (status == FAILED) {\n+            throwFailed(\"PopFrameTest!\");\n+        }\n+        log(\"\\nPopFrameTest passed\");\n+    }\n+\n+    public static void run() {\n+        TestTask testTask = new TestTask();\n+        Thread testTaskThread = null;\n+        int errCode;\n+\n+        log(\"\\nMain #A: method A() must be blocked on entering a synchronized statement\");\n+        if (is_virtual) {\n+            testTaskThread = Thread.ofVirtual().name(\"TestTaskThread\").start(testTask);\n+        } else {\n+            testTaskThread = Thread.ofPlatform().name(\"TestTaskThread\").start(testTask);\n+        }\n+\n+        {\n+            TestTask.ensureAtPointA();\n+\n+            log(\"\\nMain #A.1: unsuspended\");\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != THREAD_NOT_SUSPENDED) {\n+                throwFailed(\"Main #A.1: expected THREAD_NOT_SUSPENDED instead of: \" + errCode);\n+            } else {\n+                log(\"Main #A.1: got expected THREAD_NOT_SUSPENDED\");\n+            }\n+\n+            log(\"\\nMain #A.2: suspended\");\n+            suspendThread(testTaskThread);\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != JVMTI_ERROR_NONE) {\n+                throwFailed(\"Main #A.2: expected JVMTI_ERROR_NONE instead of: \" + errCode);\n+            } else {\n+                log(\"Main #A.2: got expected JVMTI_ERROR_NONE\");\n+            }\n+            resumeThread(testTaskThread);\n+            TestTask.clearDoLoop();\n+            TestTask.sleep(5);\n+        }\n+\n+        log(\"\\nMain #B: method B() must be blocked in a breakpoint event handler\");\n+        {\n+            ensureAtBreakpoint();\n+\n+            log(\"\\nMain #B.1: unsuspended\");\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != THREAD_NOT_SUSPENDED) {\n+                throwFailed(\"Main #B.1: expected THREAD_NOT_SUSPENDED instead of: \" + errCode);\n+            }\n+            log(\"Main #B.1: got expected THREAD_NOT_SUSPENDED\");\n+\n+            log(\"\\nMain #B.2: suspended\");\n+            suspendThread(testTaskThread);\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != JVMTI_ERROR_NONE) {\n+                throwFailed(\"Main #B.2: expected JVMTI_ERROR_NONE\");\n+            }\n+            log(\"Main #B.2: got expected JVMTI_ERROR_NONE\");\n+            resumeThread(testTaskThread);\n+            notifyAtBreakpoint();\n+\n+            log(\"\\nMain #B.3: unsuspended, call PopFrame on own thread\");\n+            ensureAtBreakpoint();\n+            notifyAtBreakpoint();\n+            TestTask.sleep(5);\n+        }\n+\n+        log(\"\\nMain #C: method C() calls PopFrame on its own thread\");\n+        {\n+            \/\/ PopFrame is called from method C() on own thread. Expected to return OPAQUE_FRAME.\n+            \/\/ No suspension of the test task thread is required or can be done in this case.\n+            TestTask.ensureFinished();\n+        }\n+\n+        try {\n+            testTaskThread.join();\n+        } catch (InterruptedException ex) {\n+            throwFailed(\"Unexpected \" + ex);\n+        }\n+    }\n+\n+\n+    static class TestTask implements Runnable {\n+        static void log(String str) { System.out.println(str); }\n+\n+        static volatile boolean doLoop = true;\n+        static volatile boolean atPointA = false;\n+        static volatile boolean finished = false;\n+\n+        static void sleep(long millis) {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Interruption in TestTask.sleep: \\n\\t\" + e);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is ready.\n+        static void ensureAtPointA() {\n+            while (!atPointA) {\n+                sleep(1);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is finished.\n+        static void ensureFinished() {\n+            while (!finished) {\n+                sleep(1);\n+            }\n+        }\n+\n+        static void clearDoLoop() {\n+            doLoop = false;\n+        }\n+\n+        public void run() {\n+            log(\"TestTask.run: started\");\n+\n+            A();\n+            sleep(1); \/\/ to cause yield\n+\n+            prepareAgent(TestTask.class, false); \/\/ No doPopFrame\n+            B();\n+            sleep(1); \/\/ to cause yield\n+\n+            prepareAgent(TestTask.class, true); \/\/ doPopFrame\n+            B();\n+            sleep(1); \/\/ to cause yield\n+\n+            C();\n+            finished = true;\n+        }\n+\n+        \/\/ Method is busy in a while loop.\n+        \/\/ PopFrame is used two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: JVMTI_ERROR_NONE is expected\n+        static void A() {\n+            log(\"TestTask.A: started\");\n+            atPointA = true;\n+            while (doLoop) {\n+            }\n+            log(\"TestTask.A: finished\");\n+        }\n+\n+        \/\/ A breakpoint is set at start of this method.\n+        \/\/ PopFrame is used two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: expected to succeed\n+        static void B() {\n+            log(\"TestTask.B: started\");\n+        }\n+\n+        \/\/ This method uses PopFrame on its own thread. It is expected to return OPAQUE_FRAME.\n+        static void C() {\n+            log(\"TestTask.C: started\");\n+            int errCode = PopFrameTest.popFrame(Thread.currentThread());\n+            if (errCode == OPAQUE_FRAME) {\n+                log(\"TestTask.C: got expected OPAQUE_FRAME\");\n+            } else {\n+                setFailed(\"TestTask.C: expected OPAQUE_FRAME from PopFrame instead of: \" + errCode);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/PopFrameTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti;\n+static jmethodID mid_B;\n+static jrawMonitorID monitor;\n+static jboolean do_pop_frame;\n+static volatile bool bp_sync_reached;\n+\n+static void JNICALL\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jvmtiError err;\n+\n+  if (method != mid_B) {\n+    fatal(jni, \"Breakpoint: Failed with wrong location: expected in method TestTask.B()\");\n+  }\n+  err = jvmti->ClearBreakpoint(mid_B, 0);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in JVMTI ClearBreakpoint\");\n+\n+  LOG(\"Breakpoint: In method TestTask.B(): before sync section\\n\");\n+  {\n+    RawMonitorLocker rml(jvmti, jni, monitor);\n+    bp_sync_reached = true;\n+    rml.wait(0);\n+  }\n+  LOG(\"Breakpoint: In method TestTask.B(): after sync section\\n\");\n+\n+  if (do_pop_frame != 0) {\n+    err = jvmti->PopFrame(thread);\n+    LOG(\"Breakpoint: PopFrame returned code: %s (%d)\\n\", TranslateError(err), err);\n+    check_jvmti_status(jni, err, \"Breakpoint: Failed in PopFrame\");\n+  }\n+  LOG(\"Breakpoint: In method TestTask.B() finished\\n\");\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  static jvmtiCapabilities caps;\n+  static jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  LOG(\"Agent init\\n\");\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    LOG(\"Agent init: Failed in GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetPotentialCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_breakpoint_events) {\n+    LOG(\"Agent init: Failed: Breakpoint event is not implemented\\n\");\n+    return JNI_ERR;\n+  }\n+  callbacks.Breakpoint = &Breakpoint;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  monitor = create_raw_monitor(jvmti, \"Raw monitor to test\");\n+  return JNI_OK;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_prepareAgent(JNIEnv *jni, jclass cls, jclass task_clazz, jboolean do_pop) {\n+  jvmtiError err;\n+\n+  LOG(\"Main: prepareAgent started\\n\");\n+\n+  if (jvmti == NULL) {\n+    fatal(jni, \"prepareAgent: Failed as JVMTI client was not properly loaded!\\n\");\n+  }\n+  do_pop_frame = do_pop;\n+\n+  mid_B = jni->GetStaticMethodID(task_clazz, \"B\", \"()V\");\n+  if (mid_B == NULL) {\n+    fatal(jni, \"prepareAgent: Failed to find Method ID for method: TestTask.B()\\n\");\n+  }\n+  err = jvmti->SetBreakpoint(mid_B, 0);\n+  check_jvmti_status(jni, err, \"prepareAgent: Failed in JVMTI SetBreakpoint\");\n+\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+\n+  LOG(\"Main: prepareAgent finished\\n\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_suspendThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: suspendThread\\n\");\n+  suspend_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_resumeThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: resumeThread\\n\");\n+  resume_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_PopFrameTest_popFrame(JNIEnv *jni, jclass cls, jthread thread) {\n+  jvmtiError err = jvmti->PopFrame(thread);\n+  LOG(\"Main: popFrame: PopFrame returned code: %s (%d)\\n\", TranslateError(err), err);\n+  return (jint)err;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_ensureAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  bool need_stop = false;\n+\n+  LOG(\"Main: ensureAtBreakpoint\\n\");\n+  while (!need_stop) {\n+    RawMonitorLocker rml(jvmti, jni, monitor);\n+    need_stop = bp_sync_reached;\n+    sleep_ms(1); \/\/ 1 millisecond\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_notifyAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  LOG(\"Main: notifyAtBreakpoint\\n\");\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+  bp_sync_reached = false;\n+  rml.notify_all();\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/libPopFrameTest.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -90,4 +90,0 @@\n-  LOG(\"Testing PopFrame\\n\");\n-  err = jvmti->PopFrame(vthread);\n-  check_jvmti_error_opaque_frame(jni, \"PopFrame\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadUnsupportedTest\/libVThreadUnsupportedTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle01.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quick]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp byteArr\n- *      -ms low\n- *\/\n-\n-package gc.ArrayJuggle.Juggle01;\n-\n-import nsk.share.test.*;\n-import nsk.share.gc.*;\n-import nsk.share.gc.gp.*;\n-\n-\/**\n- * This test randomly replaces elements of an array with new\n- * objects using given garbage producer and memory strategy.\n- *\/\n-public class Juggle01 extends ThreadedGCTest implements GarbageProducerAware, MemoryStrategyAware {\n-        private GarbageProducer garbageProducer;\n-        private MemoryStrategy memoryStrategy;\n-        private Object[] array;\n-        private Object[] indexLocks;\n-        long objectSize;\n-\n-        private class Juggler implements Runnable {\n-                public void run() {\n-                        int index = LocalRandom.nextInt(array.length);\n-                        \/\/ Synchronizing to prevent multiple object creation for the same index at the same time.\n-                        synchronized (indexLocks[index]) {\n-                                array[index] = null;\n-                                array[index] = garbageProducer.create(objectSize);\n-                        }\n-                }\n-        }\n-\n-        protected Runnable createRunnable(int i) {\n-                return new Juggler();\n-        }\n-\n-        public void run() {\n-                log.debug(\"Garbage producer: \" + garbageProducer);\n-                log.debug(\"Memory strategy: \" + memoryStrategy);\n-                long memory = runParams.getTestMemory();\n-                int objectCount = memoryStrategy.getCount(memory);\n-                objectSize = memoryStrategy.getSize(memory);\n-                log.debug(\"Object count: \" + objectCount);\n-                log.debug(\"Object size: \" + objectSize);\n-                array = new Object[objectCount - 1];\n-                indexLocks = new Object[objectCount - 1];\n-                for (int i = 0; i < indexLocks.length; i++) {\n-                    indexLocks[i] = new Object();\n-                }\n-                super.run();\n-        }\n-\n-        public void setGarbageProducer(GarbageProducer garbageProducer) {\n-                this.garbageProducer = garbageProducer;\n-        }\n-\n-        public void setMemoryStrategy(MemoryStrategy memoryStrategy) {\n-                this.memoryStrategy = memoryStrategy;\n-        }\n-\n-        public static void main(String[] args) {\n-                GC.runTest(new Juggle01(), args);\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle01\/Juggle01.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle02\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle02.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp byteArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle02\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle03\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle03.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp byteArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle03\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle04\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle04.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp booleanArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle04\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle05\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle05.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp booleanArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle05\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle06\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle06.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp booleanArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle06\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle07\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle07.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp shortArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle07\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle08\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle08.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp shortArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle08\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle09\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle09.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp shortArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle09\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-\n@@ -26,4 +25,1 @@\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/memory\/Array\/ArrayJuggle\/Juggle1.\n+ * summary converted from VM Testbase gc\/memory\/Array\/ArrayJuggle\/Juggle1.\n@@ -31,4 +27,0 @@\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.memory.Array.ArrayJuggle.Juggle1.Juggle1\n@@ -37,1 +29,4 @@\n-package gc.memory.Array.ArrayJuggle.Juggle1;\n+\/* @test @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle1 *\/\n+\/* @test @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle1 -tg *\/\n+\n+package gc.ArrayJuggle;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle1.java","additions":6,"deletions":11,"binary":false,"changes":17,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle1\/Juggle1.java","status":"renamed"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle10\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle10.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp charArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle10\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle11\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle11.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      -Djava.security.manager=allow\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp charArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle11\/TestDescription.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle12\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle12.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp charArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle12\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle13\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle13.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp intArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle13\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle14\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle14.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quick]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp intArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle14\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle15\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle15.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp intArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle15\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle16\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle16.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp longArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle16\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle17\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle17.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp longArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle17\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle18\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle18.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp longArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle18\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle19\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle19.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp floatArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle19\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,1 @@\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/memory\/Array\/ArrayJuggle\/Juggle2.\n+ * summary converted from VM Testbase gc\/memory\/Array\/ArrayJuggle\/Juggle2.\n@@ -31,4 +28,0 @@\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.memory.Array.ArrayJuggle.Juggle2.Juggle2\n@@ -37,1 +30,4 @@\n-package gc.memory.Array.ArrayJuggle.Juggle2;\n+\/* @test @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle2 *\/\n+\/* @test @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle2 -tg *\/\n+\n+package gc.ArrayJuggle;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle2.java","additions":6,"deletions":10,"binary":false,"changes":16,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle2\/Juggle2.java","status":"renamed"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle20\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle20.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp floatArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle20\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle21\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle21.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp floatArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle21\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle22\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle22.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quick]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp doubleArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle22\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle23\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle23.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp doubleArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle23\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle24\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle24.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp doubleArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle24\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle25\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle25.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp objectArr\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle25\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle26\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle26.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp objectArr\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle26\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle27\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle27.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp objectArr\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle27\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle28\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle28.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp hashed(doubleArr)\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle28\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle29\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle29.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quick]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp hashed(doubleArr)\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle29\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n+ *\/\n+\n+\/* @test id=byteArr_medium     @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp byteArr           -ms medium *\/\n+\/* @test id=byteArr_high       @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp byteArr           -ms high *\/\n+\/* @test id=booleanArr_low     @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp booleanArr        -ms low *\/\n+\/* @test id=booleanArr_medium  @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp booleanArr        -ms medium *\/\n+\/* @test id=booleanArr_high    @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp booleanArr        -ms high *\/\n+\/* @test id=shortArr_low       @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp shortArr          -ms low *\/\n+\/* @test id=shortArr_medium    @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp shortArr          -ms medium *\/\n+\/* @test id=shortArr_high      @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp shortArr          -ms high *\/\n+\/* @test id=charArr_low        @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp charArr           -ms low *\/\n+\/* @test id=charArr_medium     @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp charArr           -ms medium *\/\n+\/* @test id=charArr_high       @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp charArr           -ms high *\/\n+\/* @test id=intArr_low         @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp intArr            -ms low *\/\n+\/* @test id=intArr_high        @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp intArr            -ms high *\/\n+\/* @test id=longArr_low        @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp longArr           -ms low *\/\n+\/* @test id=longArr_medium     @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp longArr           -ms medium *\/\n+\/* @test id=longArr_high       @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp longArr           -ms high *\/\n+\/* @test id=floatArr_low       @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp floatArr          -ms low *\/\n+\/* @test id=floatArr_medium    @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp floatArr          -ms medium *\/\n+\/* @test id=floatArr_high      @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp floatArr          -ms high *\/\n+\/* @test id=doubleArr_medium   @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp doubleArr         -ms medium *\/\n+\/* @test id=doubleArr_high     @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp doubleArr         -ms high *\/\n+\/* @test id=objectArr_low      @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp objectArr         -ms low *\/\n+\/* @test id=objectArr_medium   @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp objectArr         -ms medium *\/\n+\/* @test id=objectArr_high     @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp objectArr         -ms high *\/\n+\/* @test id=h_doubleArr_low    @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp hashed(doubleArr) -ms low *\/\n+\/* @test id=h_doubleArr_high   @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp hashed(doubleArr) -ms high *\/\n+\/* @test id=h_objectArr_low    @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp hashed(objectArr) -ms low *\/\n+\/* @test id=h_objectArr_medium @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp hashed(objectArr) -ms medium *\/\n+\/* @test id=h_objectArr_high   @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp hashed(objectArr) -ms high *\/\n+\n+package gc.ArrayJuggle;\n+\n+import nsk.share.test.*;\n+import nsk.share.gc.*;\n+import nsk.share.gc.gp.*;\n+\n+\/**\n+ * This test randomly replaces elements of an array with new objects\n+ * using given garbage producer and memory strategy.  This class was\n+ * renamed from Juggle01 to Juggle3 to better distinguice it from\n+ * Juggle1.\n+ *\/\n+public class Juggle3 extends ThreadedGCTest implements GarbageProducerAware, MemoryStrategyAware {\n+        private GarbageProducer garbageProducer;\n+        private MemoryStrategy memoryStrategy;\n+        private Object[] array;\n+        private Object[] indexLocks;\n+        long objectSize;\n+\n+        private class Juggler implements Runnable {\n+                public void run() {\n+                        int index = LocalRandom.nextInt(array.length);\n+                        \/\/ Synchronizing to prevent multiple object creation for the same index at the same time.\n+                        synchronized (indexLocks[index]) {\n+                                array[index] = null;\n+                                array[index] = garbageProducer.create(objectSize);\n+                        }\n+                }\n+        }\n+\n+        protected Runnable createRunnable(int i) {\n+                return new Juggler();\n+        }\n+\n+        public void run() {\n+                log.debug(\"Garbage producer: \" + garbageProducer);\n+                log.debug(\"Memory strategy: \" + memoryStrategy);\n+                long memory = runParams.getTestMemory();\n+                int objectCount = memoryStrategy.getCount(memory);\n+                objectSize = memoryStrategy.getSize(memory);\n+                log.debug(\"Object count: \" + objectCount);\n+                log.debug(\"Object size: \" + objectSize);\n+                array = new Object[objectCount - 1];\n+                indexLocks = new Object[objectCount - 1];\n+                for (int i = 0; i < indexLocks.length; i++) {\n+                    indexLocks[i] = new Object();\n+                }\n+                super.run();\n+        }\n+\n+        public void setGarbageProducer(GarbageProducer garbageProducer) {\n+                this.garbageProducer = garbageProducer;\n+        }\n+\n+        public void setMemoryStrategy(MemoryStrategy memoryStrategy) {\n+                this.memoryStrategy = memoryStrategy;\n+        }\n+\n+        public static void main(String[] args) {\n+                GC.runTest(new Juggle3(), args);\n+        }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle3.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle30\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle30.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp hashed(doubleArr)\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle30\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle31\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle31.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp hashed(objectArr)\n- *      -ms low\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle31\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle32\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle32.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp hashed(objectArr)\n- *      -ms medium\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle32\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle33\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle33.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp hashed(objectArr)\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle33\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle34\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/ArrayJuggle\/Juggle34.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quick]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      -XX:+HeapDumpOnOutOfMemoryError\n- *      -Xlog:gc=debug:gc.log\n- *      gc.ArrayJuggle.Juggle01.Juggle01\n- *      -gp random(arrays)\n- *      -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle34\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quick]\n+ *\/\n+\n+\/* @test id=byteArr_low        @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp byteArr           -ms low *\/\n+\/* @test id=intArr_medium      @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp intArr            -ms medium *\/\n+\/* @test id=doubleArr_low      @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp doubleArr         -ms low *\/\n+\/* @test id=h_doubleArr_medium @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp hashed(doubleArr) -ms medium *\/\n+\/* @test id=r_arrays_high      @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:+HeapDumpOnOutOfMemoryError -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle3 -gp random(arrays)    -ms high *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle3Quick.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-exclusiveAccess.dirs=.\n+exclusiveAccess.dirs=.\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle01\/TEST.properties","status":"renamed"},{"patch":"@@ -1,95 +0,0 @@\n-Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--- These tests run forever at the current time [8\/14\/97] --\n-\n-\n-\n-ArrayJuggle.README\n-\n-These are a series of tests to exercise the multi-threaded\n-GC part of the JVM.\n-\n-MemoryObjects are objects with a byte array to control their\n-size and next and previous pointers for building up links to\n-other MemoryObjects. These pointers can be used to make linked\n-lists or binary trees or whatever. In these test cases, they are\n-used only to build singly-linked lists.\n-\n-In the main class for each ArrayJuggle test, there is an array of\n-MemoryObjects called the mainArray. This array is acted upon\n-by various threads.\n-\n-MainArrayWalker threads randomly pick a cell in the main array\n-and allocate a new MemoryObject into it. This means that\n-the previous occupant of this cell in the array and anything\n-it points to are candidates for GC.\n-\n-The CopyingThread threads copy parts of the main array into\n-a thread-local array. While it resides in the thread-local array,\n-a MemoryObject and the objects it points to should not be GC'd.\n-\n-The LinkMaker threads add new objects at the head of a linked\n-list. The head of the list is stored in the main array. These\n-links can vary in size.\n-\n-In Juggle1, a single CopyingThread copies the values of the main array to the\n-subarray, a single LinkMaker adds nodes to the main array, and a single\n-MainArrayWalker turns over the main array.\n-\n-Juggle2 is the same as Juggle1, but the CopyingThread puts a reference\n-to the main array cell in the thread-local sub-array instead of\n-copying it. A small difference.\n-\n-Juggle3 is the same as Juggle1, but is configurable for how many\n-of each type of thread exists.\n-\n-Juggle4 is the same as Juggle2, but also has arrays of threads which\n-operate on the array.\n-\n-The \"gc\" versions of these tests all have one or more threads\n-which simply sit in a loop calling System.gc() to stress the system.\n-\n-\n-These programs are designed to have their values adjusted to stress\n-different parts of the system. A simple command interface can be\n-added to adjust these at runtime, or the files can be edited and\n-recompiled.\n-\n-No attempt has been made to synchronize access to the various array\n-structures. This means that the arrays at any given moment inside\n-any given thread may not necessarily be consistent. This is by\n-design.\n-\n-Because there is no synchronization across array accesses, the\n-values given by the dumpStatistics will not be precise, but will\n-instead reflect a rolling average.\n-\n-Currently, all these programs run forever. That is because the\n-curernt 1.1E system eventually fails on these tests. Each of\n-the threads has a mechanism for stopping. The main program can\n-wait for some specified period of time or number of iterations\n-and then set runForever = false on all its child threads and\n-then join() on them and the program should eventually terminate.\n-This will be necessary for adding these to VM Testbase.\n-\n-Also, it will be interesting to run these tests in multiple\n-configurations (varying the number of mutator threads) to\n-help check for problems.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/ArrayJuggle.README","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle1\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle1_gc\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/memory\/Array\/ArrayJuggle\/Juggle1_gc.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.memory.Array.ArrayJuggle.Juggle1.Juggle1 -tg\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle1_gc\/TestDescription.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle2\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle2_gc\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/memory\/Array\/ArrayJuggle\/Juggle2_gc.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.memory.Array.ArrayJuggle.Juggle2.Juggle2 -tg\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Array\/ArrayJuggle\/Juggle2_gc\/TestDescription.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -342,0 +342,1 @@\n+                \"Cleaner-\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/EventFilters.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,6 @@\n+javax\/management\/remote\/mandatory\/loading\/MissingClassTest.java 8145413 windows-x64\n+\n+javax\/management\/remote\/mandatory\/loading\/RMIDownloadTest.java 8308366 windows-x64\n+\n+java\/lang\/instrument\/NativeMethodPrefixAgent.java 8307169 generic-all\n+\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -527,0 +527,2 @@\n+javax\/management\/remote\/mandatory\/connection\/BrokenConnectionTest.java 8262312 linux-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+    com\/sun\/org\/apache\/xml\/internal\/security \\\n@@ -223,1 +224,0 @@\n-    com\/sun\/org\/apache\/xml\/internal\/security \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug     6173675 8231209\n+ * @bug     6173675 8231209 8304074\n@@ -58,0 +58,3 @@\n+        \/\/ Test cumulative Java thread allocation since JVM launch\n+        testGetTotalThreadAllocatedBytes();\n+\n@@ -95,0 +98,2 @@\n+        Thread curThread = Thread.currentThread();\n+\n@@ -96,1 +101,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -101,1 +106,1 @@\n-        checkResult(Thread.currentThread(), size,\n+        checkResult(curThread, size,\n@@ -110,1 +115,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -122,1 +127,2 @@\n-        done = false; done1 = false;\n+        done = false;\n+        done1 = false;\n@@ -131,1 +137,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -155,1 +161,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n+            System.out.println(\"Unexpected exception thrown.\");\n@@ -164,1 +170,2 @@\n-        done = false; done1 = false;\n+        done = false;\n+        done1 = false;\n@@ -175,1 +182,1 @@\n-            ensureValidSize(sizes[i]);\n+            ensureValidSize(threads[i], sizes[i]);\n@@ -204,1 +211,59 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n+                System.out.println(\"Unexpected exception thrown.\");\n+                e.printStackTrace(System.out);\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static void testGetTotalThreadAllocatedBytes()\n+        throws Exception {\n+\n+        \/\/ baseline should be positive\n+        Thread curThread = Thread.currentThread();\n+        long cumulativeSize = mbean.getTotalThreadAllocatedBytes();\n+        if (cumulativeSize <= 0) {\n+            throw new RuntimeException(\n+                \"Invalid allocated bytes returned for \" + curThread.getName() + \" = \" + cumulativeSize);\n+        }\n+\n+        \/\/ start threads\n+        done = false;\n+        done1 = false;\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            threads[i] = new MyThread(\"MyThread-\" + i);\n+            threads[i].start();\n+        }\n+\n+        \/\/ wait for threads to block after doing some allocation\n+        waitUntilThreadsBlocked();\n+\n+        \/\/ check after threads are blocked\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads go to do some more allocation\n+        synchronized (obj) {\n+            done = true;\n+            obj.notifyAll();\n+        }\n+\n+        \/\/ wait for threads to get going again. we don't care if we\n+        \/\/ catch them in mid-execution or if some of them haven't\n+        \/\/ restarted after we're done sleeping.\n+        goSleep(400);\n+\n+        System.out.println(\"Done sleeping\");\n+\n+        \/\/ check while threads are running\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads exit\n+        synchronized (obj) {\n+            done1 = true;\n+            obj.notifyAll();\n+        }\n+\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            try {\n+                threads[i].join();\n+            } catch (InterruptedException e) {\n+                System.out.println(\"Unexpected exception thrown.\");\n@@ -209,0 +274,3 @@\n+\n+        \/\/ check after threads exit\n+        checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n@@ -211,1 +279,1 @@\n-    private static void ensureValidSize(long size) {\n+    private static void ensureValidSize(Thread curThread, long size) {\n@@ -216,1 +284,2 @@\n-                \"Invalid allocated bytes returned = \" + size);\n+                \"Invalid allocated bytes returned for thread \" +\n+                curThread.getName() + \" = \" + size);\n@@ -220,6 +289,2 @@\n-    private static void checkResult(Thread curThread,\n-                                    long prev_size, long curr_size) {\n-        if (curr_size < prev_size) {\n-            throw new RuntimeException(\"Allocated bytes \" + curr_size +\n-                                       \" expected >= \" + prev_size);\n-        }\n+    private static long checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n@@ -227,2 +292,9 @@\n-                           \" Previous allocated bytes = \" + prev_size +\n-                           \" Current allocated bytes = \" + curr_size);\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+        }\n+        return currSize;\n@@ -235,1 +307,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n+            System.out.println(\"Unexpected exception thrown.\");\n@@ -290,1 +362,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown while !done.\");\n@@ -297,1 +369,1 @@\n-            long size1 = mbean.getThreadAllocatedBytes(getId());\n+            long prevSize = mbean.getThreadAllocatedBytes(getId());\n@@ -299,11 +371,2 @@\n-            long size2 = mbean.getThreadAllocatedBytes(getId());\n-\n-            System.out.println(getName() + \": \" +\n-                \"ThreadAllocatedBytes  = \" + size1 +\n-                \" ThreadAllocatedBytes  = \" + size2);\n-\n-            if (size1 > size2) {\n-                throw new RuntimeException(getName() +\n-                    \" ThreadAllocatedBytes = \" + size1 +\n-                    \" > ThreadAllocatedBytes = \" + size2);\n-            }\n+            long currSize = mbean.getThreadAllocatedBytes(getId());\n+            checkResult(this, prevSize, currSize);\n@@ -316,1 +379,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown while !done1.\");\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemory.java","additions":99,"deletions":36,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-\n@@ -62,1 +61,0 @@\n-\n@@ -120,2 +118,1 @@\n-        long[] sizes1 = mbean.getThreadAllocatedBytes(ids);\n-\n+        long[] afterSizes = mbean.getThreadAllocatedBytes(ids);\n@@ -123,10 +120,1 @@\n-            long newSize = sizes1[i];\n-            if (sizes[i] > newSize) {\n-                throw new RuntimeException(\"TEST FAILED: \" +\n-                    threads[i].getName() +\n-                    \" previous allocated bytes = \" + sizes[i] +\n-                    \" > current allocated bytes = \" + newSize);\n-            }\n-            System.out.println(threads[i].getName() +\n-                \" Previous allocated bytes = \" + sizes[i] +\n-                \" Current allocated bytes = \" + newSize);\n+            checkResult(threads[i], sizes[i], afterSizes[i]);\n@@ -150,1 +138,0 @@\n-\n@@ -161,1 +148,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n+                System.out.println(\"Unexpected exception thrown.\");\n@@ -176,0 +163,14 @@\n+    private static void checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n+        System.out.println(curThread.getName() +\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+\n+        }\n+    }\n+\n@@ -180,1 +181,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n+            System.out.println(\"Unexpected exception thrown.\");\n@@ -224,1 +225,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown.\");\n@@ -239,1 +240,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n+                        System.out.println(\"Unexpected exception thrown.\");\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemoryArray.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+\/*\n+  @test\n+  @bug 4388802\n+  @summary tests that dragEnter() is called on a DropTargetListener if its drop\n+           target is associated with a component which initiated the drag\n+  @key headful\n+  @run main MissedDragEnterTest\n+*\/\n+\n+public class MissedDragEnterTest {\n+\n+    static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n+    volatile JFrame frame;\n+    volatile DragSourceDropTargetPanel panel;\n+    volatile Point p;\n+    volatile Dimension d;\n+\n+    public static void main(String[] args) throws Exception {\n+        MissedDragEnterTest test = new MissedDragEnterTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        panel = new DragSourceDropTargetPanel();\n+        frame = new JFrame();\n+        frame.setTitle(\"MissedDragEnterTest\");\n+        frame.setLocation(200, 200);\n+        frame.getContentPane().add(panel);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+\n+        robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+        EventQueue.invokeAndWait(() -> {\n+            p = panel.getLocationOnScreen();\n+            d = panel.getSize();\n+        });\n+\n+        p.translate(d.width \/ 2, d.height \/ 2);\n+        robot.mouseMove(p.x, p.y);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        for (int i = 0; i < d.width; i++) {\n+            p.translate(1, 1);\n+            robot.mouseMove(p.x, p.y);\n+            robot.delay(10);\n+        }\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            if (!panel.getResult()) {\n+                throw new RuntimeException(\"The test failed.\");\n+            }\n+        });\n+    }\n+}\n+\n+class DragSourceDropTargetPanel extends JPanel implements DropTargetListener,\n+                                                          Serializable,\n+                                                          Transferable,\n+                                                          DragGestureListener,\n+                                                          DragSourceListener {\n+    private final DataFlavor dataflavor =\n+        new DataFlavor(JPanel.class, \"panel\");\n+    private final Dimension preferredDimension = new Dimension(200, 100);\n+    private boolean inside = false;\n+    private boolean passed = true;\n+\n+    public DragSourceDropTargetPanel() {\n+        setLayout(new FlowLayout());\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              this);\n+        setDropTarget(new DropTarget(this, this));\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(null, this, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {}\n+\n+    public void dragExit(DragSourceEvent dse) {}\n+\n+    public void dragOver(DragSourceDragEvent dsde) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {}\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {}\n+\n+    public Object getTransferData(DataFlavor flavor)\n+      throws UnsupportedFlavorException, IOException {\n+\n+        if (!isDataFlavorSupported(flavor)) {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+\n+        Object retObj = null;\n+\n+        ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+        ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+        ooStream.writeObject(this);\n+\n+        ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n+        ObjectInputStream ois = new ObjectInputStream(baiStream);\n+        try {\n+            retObj = ois.readObject();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e.toString());\n+        }\n+\n+        return retObj;\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] { dataflavor };\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+        return dataflavor.equals(dflavor);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {\n+        inside = true;\n+    }\n+\n+    public void dragExit(DropTargetEvent dte) {\n+        if (!inside) {\n+            passed = false;\n+            inside = false;\n+            throw new RuntimeException(\"dragEnter() is not called before dragExit()\");\n+\n+        }\n+        inside = false;\n+    }\n+\n+    public void dragOver(DropTargetDragEvent dtde) {\n+        if (!inside) {\n+            passed = false;\n+            throw new RuntimeException(\"dragEnter() is not called before dragOver()\");\n+        }\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {\n+    }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+        Component comp = null;\n+\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+\n+            try {\n+                comp = (Component)transfer.getTransferData(dfs[0]);\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                dtc.dropComplete(false);\n+            }\n+        }\n+        dtc.dropComplete(true);\n+\n+        add(comp);\n+    }\n+\n+    public boolean getResult() {\n+        return passed;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/MissedDragEnterTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+  @test\n+  @bug 4633417\n+  @summary tests that drag operation doesn't cause hang when a modal dialog is\n+           shown\n+  @key headful\n+  @run main ModalDialogDeadlockTest\n+*\/\n+\n+public class ModalDialogDeadlockTest implements AWTEventListener {\n+\n+    volatile Frame frame;\n+    volatile Dialog dialog;\n+    volatile Point dstPoint;\n+    volatile Point srcPoint;\n+    volatile Dimension d;\n+\n+    volatile DragSource dragSource;\n+    volatile Transferable transferable;\n+    volatile DragSourceListener dsl;\n+    volatile DragGestureListener dgl;\n+    volatile DragGestureRecognizer dgr;\n+    volatile DropTarget dt;\n+\n+    static final Object SYNC_LOCK = new Object();\n+    static final int FRAME_ACTIVATION_TIMEOUT = 2000;\n+    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n+\n+    Component clickedComponent = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        ModalDialogDeadlockTest test = new ModalDialogDeadlockTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame(\"ModalDialogDeadlockTest\");\n+        frame.setBounds(100, 100, 200, 200);\n+        dialog = new Dialog(frame, \"Dialog\", true);\n+        dialog.setBounds(350, 100, 200, 200);\n+\n+        dragSource = DragSource.getDefaultDragSource();\n+        transferable = new StringSelection(\"TEXT\");\n+        dsl = new DragSourceAdapter() {\n+            public void dragDropEnd(DragSourceDropEvent dsde) {\n+                synchronized (SYNC_LOCK) {\n+                    SYNC_LOCK.notifyAll();\n+                }\n+            }\n+        };\n+        dgl = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                dge.startDrag(null, transferable, dsl);\n+            }\n+        };\n+        dgr = dragSource.createDefaultDragGestureRecognizer(dialog,\n+                        DnDConstants.ACTION_COPY,\n+                        dgl);\n+        final DropTargetListener dtl = new DropTargetAdapter() {\n+            public void drop(DropTargetDropEvent dtde) {\n+                dtde.rejectDrop();\n+                dialog.dispose();\n+            }\n+        };\n+        dt = new DropTarget(frame, dtl);\n+\n+        frame.getToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n+        frame.setVisible(true);\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void start() throws Exception {\n+        final Robot robot = new Robot();\n+\n+        robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            dstPoint = frame.getLocationOnScreen();\n+            d = frame.getSize();\n+        });\n+        dstPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!pointInComponent(robot, dstPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate frame.\");\n+            return;\n+        }\n+\n+        EventQueue.invokeLater(() -> {\n+            dialog.setVisible(true);\n+        });\n+\n+        robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            srcPoint = dialog.getLocationOnScreen();\n+            d = dialog.getSize();\n+        });\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!pointInComponent(robot, srcPoint, dialog)) {\n+            System.err.println(\"WARNING: Couldn't locate dialog.\");\n+            return;\n+        }\n+\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        for (;!srcPoint.equals(dstPoint);\n+             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            robot.delay(50);\n+        }\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            SYNC_LOCK.wait();\n+        }\n+    }\n+\n+    public void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component)e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    boolean pointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/ModalDialogDeadlockTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+  @test\n+  @bug 4352221\n+  @summary verifies that showing a modal dialog on drag doesn't hang\n+  @key headful\n+  @run main ModalDialogOnDragDeadlockTest\n+*\/\n+\n+public class ModalDialogOnDragDeadlockTest implements AWTEventListener {\n+\n+    volatile Frame frame;\n+    volatile Dialog dialog;\n+    volatile Point srcPoint;\n+    volatile Dimension d;\n+    volatile boolean finished;\n+\n+    static final Object SYNC_LOCK = new Object();\n+    static final int FRAME_ACTIVATION_TIMEOUT = 3000;\n+    static final int DROP_COMPLETION_TIMEOUT = 5000;\n+    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n+\n+    volatile DragSource dragSource;\n+    volatile Transferable transferable;\n+    volatile DragGestureListener dragGestureListener;\n+    volatile DragGestureRecognizer dragGestureRecognizer;\n+    volatile DropTargetListener dropTargetListener;\n+    volatile DropTarget dropTarget;\n+\n+    Component clickedComponent = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        ModalDialogOnDragDeadlockTest test = new ModalDialogOnDragDeadlockTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame(\"ModalDialogOnDragDeadlockTest\");\n+        dialog = new Dialog(frame, \"Modal dialog\", true);\n+        frame.setTitle(\"Test frame\");\n+        frame.setBounds(100, 100, 200, 200);\n+\n+        dragSource = DragSource.getDefaultDragSource();\n+        transferable = new StringSelection(\"TEXT\");\n+        dragGestureListener = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                dge.startDrag(null, transferable);\n+            }\n+        };\n+        dragGestureRecognizer =\n+                dragSource.createDefaultDragGestureRecognizer(frame, DnDConstants.ACTION_COPY,\n+                        dragGestureListener);\n+        dropTargetListener = new DropTargetAdapter() {\n+            public void dragOver(DropTargetDragEvent dtde) {\n+                dialog.setBounds(200, 200, 200, 200);\n+                dialog.setVisible(true);\n+            }\n+            public void drop(DropTargetDropEvent dtde) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+                dtde.dropComplete(true);\n+            }\n+        };\n+        dropTarget = new DropTarget(frame, dropTargetListener);\n+\n+        frame.getToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n+        frame.setVisible(true);\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void start() throws Exception {\n+        finished = false;\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+\n+        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+        EventQueue.invokeAndWait(() -> {\n+            srcPoint = frame.getLocationOnScreen();\n+            d = frame.getSize();\n+        });\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!pointInComponent(robot, srcPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate source frame.\");\n+            return;\n+        }\n+\n+        final Point dstPoint = new Point(srcPoint);\n+        dstPoint.translate(d.width \/ 4, d.height \/ 4);\n+\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        for (;!srcPoint.equals(dstPoint);\n+             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            Thread.sleep(50);\n+        }\n+\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+\n+        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n+    }\n+\n+    public void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component)e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    boolean pointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/dnd\/ModalDialogOnDragDeadlockTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+\n+\/*\n+  @test\n+  @bug 4623377\n+  @summary verifies that showing a modal dialog on drop doesn't hang\n+  @key headful\n+  @run main ModalDialogOnDropDeadlockTest\n+*\/\n+\n+public class ModalDialogOnDropDeadlockTest implements AWTEventListener {\n+\n+    volatile Frame frame;\n+    volatile Dialog dialog;\n+    volatile Point srcPoint;\n+    volatile Dimension d;\n+    volatile boolean finished = false;\n+\n+    static final Object SYNC_LOCK = new Object();\n+    static final int FRAME_ACTIVATION_TIMEOUT = 3000;\n+    static final int DROP_COMPLETION_TIMEOUT = 5000;\n+    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n+\n+    volatile MouseListener mouseListener;\n+\n+    volatile Runnable dialogLocator;\n+    volatile DragSourceListener dragSourceListener;\n+    volatile DragSource dragSource;\n+    volatile Transferable transferable;\n+    volatile DragGestureListener dragGestureListener;\n+    volatile DragGestureRecognizer dragGestureRecognizer;\n+    volatile DropTargetListener dropTargetListener;\n+    volatile DropTarget dropTarget;\n+\n+    Component clickedComponent = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        ModalDialogOnDropDeadlockTest test = new ModalDialogOnDropDeadlockTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+        dialog = new Dialog(frame, \"Modal dialog\", true);\n+        frame.setTitle(\"ModalDialogOnDropDeadlockTest\");\n+        frame.setBounds(100, 100, 200, 200);\n+\n+        mouseListener = new MouseAdapter() {\n+            public void mouseClicked(MouseEvent e) {\n+                dialog.dispose();\n+            }\n+        };\n+        dialogLocator = new Runnable() {\n+            public void run() {\n+                try {\n+                    final Robot robot = new Robot();\n+\n+                    Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+\n+                    final Point srcPoint = dialog.getLocationOnScreen();\n+                    Dimension d = dialog.getSize();\n+                    srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+                    robot.mouseMove(srcPoint.x, srcPoint.y);\n+                    robot.mousePress(InputEvent.BUTTON1_MASK);\n+                    robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    dialog.dispose();\n+                }\n+            }\n+        };\n+        dragSourceListener = new DragSourceAdapter() {\n+            public void dragDropEnd(DragSourceDropEvent dsde) {\n+                finished = true;\n+            }\n+        };\n+        dragSource = DragSource.getDefaultDragSource();\n+        transferable = new StringSelection(\"TEXT\");\n+        dragGestureListener = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                dge.startDrag(null, transferable, dragSourceListener);\n+            }\n+        };\n+        dragGestureRecognizer =\n+                dragSource.createDefaultDragGestureRecognizer(frame, DnDConstants.ACTION_COPY,\n+                        dragGestureListener);\n+        dropTargetListener = new DropTargetAdapter() {\n+            public void drop(DropTargetDropEvent dtde) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+                dialog.addMouseListener(mouseListener);\n+                dialog.setBounds(200, 200, 200, 200);\n+                new Thread(dialogLocator).start();\n+                dialog.setVisible(true);\n+                dtde.dropComplete(true);\n+            }\n+        };\n+        dropTarget = new DropTarget(frame, dropTargetListener);\n+\n+        frame.getToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n+        frame.setVisible(true);\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+\n+        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            srcPoint = frame.getLocationOnScreen();\n+            d = frame.getSize();\n+        });\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!pointInComponent(robot, srcPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate source frame.\");\n+            return;\n+        }\n+\n+        final Point dstPoint = new Point(srcPoint);\n+        dstPoint.translate(d.width \/ 4, d.height \/ 4);\n+\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        for (;!srcPoint.equals(dstPoint);\n+             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            Thread.sleep(50);\n+        }\n+\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+\n+        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n+\n+        if (!finished) {\n+            throw new RuntimeException(\"DnD not finished\");\n+        }\n+    }\n+\n+    public void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component)e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    boolean pointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/ModalDialogOnDropDeadlockTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.*;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng CompositeLookupTest\n+ *\/\n+public class CompositeLookupTest {\n+\n+    @Test(dataProvider = \"testCases\")\n+    public void testLookups(SymbolLookup lookup, List<Result> results) {\n+        for (Result result : results) {\n+            switch (result) {\n+                case Success(String name, long expectedLookupId) -> {\n+                    Optional<MemorySegment> symbol = lookup.find(name);\n+                    assertTrue(symbol.isPresent());\n+                    assertEquals(symbol.get().address(), expectedLookupId);\n+                }\n+                case Failure(String name) -> {\n+                    Optional<MemorySegment> symbol = lookup.find(name);\n+                    assertFalse(symbol.isPresent());\n+                }\n+            }\n+        }\n+    }\n+\n+    static class TestLookup implements SymbolLookup {\n+\n+        private Set<String> symbols;\n+        private long id;\n+\n+        public TestLookup(long id, String... symbols) {\n+            this.id = id;\n+            this.symbols = Set.of(symbols);\n+        }\n+\n+        @Override\n+        public Optional<MemorySegment> find(String name) {\n+            return symbols.contains(name) ?\n+                    Optional.of(MemorySegment.ofAddress(id)) : Optional.empty();\n+        }\n+    }\n+\n+    sealed interface Result { }\n+    record Success(String name, long expectedLookupId) implements Result { }\n+    record Failure(String name) implements Result { }\n+\n+    @DataProvider(name = \"testCases\")\n+    public Object[][] testCases() {\n+        return new Object[][]{\n+                {\n+                    new TestLookup(1, \"a\", \"b\", \"c\")\n+                            .or(new TestLookup(2,\"d\", \"e\", \"f\"))\n+                            .or(new TestLookup(3,\"g\", \"h\", \"i\")),\n+                    List.of(\n+                            new Success(\"a\", 1),\n+                            new Success(\"b\", 1),\n+                            new Success(\"c\", 1),\n+                            new Success(\"d\", 2),\n+                            new Success(\"e\", 2),\n+                            new Success(\"f\", 2),\n+                            new Success(\"g\", 3),\n+                            new Success(\"h\", 3),\n+                            new Success(\"i\", 3),\n+                            new Failure(\"j\")\n+                    )\n+                },\n+                {\n+                        new TestLookup(1, \"a\", \"b\", \"c\")\n+                                .or(new TestLookup(2,\"a\", \"b\", \"c\"))\n+                                .or(new TestLookup(3,\"a\", \"b\", \"c\")),\n+                        List.of(\n+                                new Success(\"a\", 1),\n+                                new Success(\"b\", 1),\n+                                new Success(\"c\", 1),\n+                                new Failure(\"d\")\n+                        )\n+                },\n+                {\n+                        new TestLookup(1 )\n+                                .or(new TestLookup(2))\n+                                .or(new TestLookup(3,\"a\", \"b\", \"c\")),\n+                        List.of(\n+                                new Success(\"a\", 3),\n+                                new Success(\"b\", 3),\n+                                new Success(\"c\", 3),\n+                                new Failure(\"d\")\n+                        )\n+                },\n+                {\n+                        new TestLookup(1, \"a\", \"b\", \"c\")\n+                                .or(new TestLookup(2,\"d\")\n+                                        .or(new TestLookup(3,\"e\"))\n+                                        .or(new TestLookup(4,\"f\")))\n+                                .or(new TestLookup(5,\"g\")\n+                                        .or(new TestLookup(6,\"h\"))\n+                                        .or(new TestLookup(7,\"i\"))),\n+                        List.of(\n+                                new Success(\"a\", 1),\n+                                new Success(\"b\", 1),\n+                                new Success(\"c\", 1),\n+                                new Success(\"d\", 2),\n+                                new Success(\"e\", 3),\n+                                new Success(\"f\", 4),\n+                                new Success(\"g\", 5),\n+                                new Success(\"h\", 6),\n+                                new Success(\"i\", 7),\n+                                new Failure(\"j\")\n+                        )\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/CompositeLookupTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final long BIT_ALIGNMENT = Byte.SIZE;\n+    private static final long BYTE_ALIGNMENT = Byte.BYTES;\n@@ -52,1 +52,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -62,1 +62,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -72,1 +72,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -82,1 +82,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -92,1 +92,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -102,1 +102,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -112,1 +112,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -122,1 +122,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -132,1 +132,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -142,1 +142,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -159,2 +159,2 @@\n-        PaddingLayout v = MemoryLayout.paddingLayout(8)\n-                .withBitAlignment(BIT_ALIGNMENT)\n+        PaddingLayout v = MemoryLayout.paddingLayout(1)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -169,3 +169,3 @@\n-                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n-                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                        JAVA_INT.withByteAlignment(BYTE_ALIGNMENT),\n+                        JAVA_LONG.withByteAlignment(BYTE_ALIGNMENT))\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -180,3 +180,3 @@\n-                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n-                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                        JAVA_INT.withByteAlignment(BYTE_ALIGNMENT),\n+                        JAVA_LONG.withByteAlignment(BYTE_ALIGNMENT))\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -191,3 +191,3 @@\n-                    JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n-                    JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                    JAVA_INT.withByteAlignment(BYTE_ALIGNMENT),\n+                    JAVA_LONG.withByteAlignment(BYTE_ALIGNMENT))\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -209,2 +209,1 @@\n-        assertEquals(v.bitAlignment(), BIT_ALIGNMENT);\n-        assertEquals(v.byteSize() * 8, v.bitSize());\n+        assertEquals(v.byteAlignment(), BYTE_ALIGNMENT);\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n@@ -107,1 +107,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n@@ -112,1 +112,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n@@ -116,1 +116,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n@@ -120,1 +120,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n@@ -124,1 +124,1 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-                    MemoryLayout.paddingLayout(24)\n+                    MemoryLayout.paddingLayout(3)\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_BYTE.withBitAlignment(16), 0, 4);\n+        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_BYTE.withByteAlignment(2), 0, 4);\n@@ -263,1 +263,1 @@\n-        MemorySegment.copy(segment, JAVA_BYTE.withBitAlignment(16), 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n+        MemorySegment.copy(segment, JAVA_BYTE.withByteAlignment(2), 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n@@ -331,1 +331,1 @@\n-            this.elementLayout = (L)elementLayout.withBitAlignment(8);\n+            this.elementLayout = (L)elementLayout.withByteAlignment(1);\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,7 +80,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -105,6 +99,6 @@\n-    static final ValueLayout.OfChar BB_CHAR = JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfShort BB_SHORT = JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfInt BB_INT = JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfLong BB_LONG = JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfFloat BB_FLOAT = JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfDouble BB_DOUBLE = JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n+    static final ValueLayout.OfChar BB_CHAR = JAVA_CHAR_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfShort BB_SHORT = JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfInt BB_INT = JAVA_INT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfLong BB_LONG = JAVA_LONG_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfFloat BB_FLOAT = JAVA_FLOAT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfDouble BB_DOUBLE = JAVA_DOUBLE_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -388,1 +382,1 @@\n-        if (layout.bitSize() > 32\n+        if (layout.byteSize() > 4\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                MemoryLayout.paddingLayout(32));\n+                MemoryLayout.paddingLayout(4));\n@@ -146,1 +146,1 @@\n-        FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(1));\n@@ -151,1 +151,1 @@\n-        FunctionDescriptor.of(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.of(MemoryLayout.paddingLayout(1));\n@@ -156,1 +156,1 @@\n-        FunctionDescriptor.ofVoid().appendArgumentLayouts(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid().appendArgumentLayouts(MemoryLayout.paddingLayout(1));\n@@ -161,1 +161,1 @@\n-        FunctionDescriptor.ofVoid().insertArgumentLayouts(0, MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid().insertArgumentLayouts(0, MemoryLayout.paddingLayout(1));\n@@ -166,1 +166,1 @@\n-        FunctionDescriptor.ofVoid().changeReturnLayout(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid().changeReturnLayout(MemoryLayout.paddingLayout(1));\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -88,8 +88,0 @@\n-    static final ValueLayout.OfChar JAVA_CHAR_ALIGNED = ValueLayout.JAVA_CHAR.withBitAlignment(16);\n-    static final ValueLayout.OfShort JAVA_SHORT_ALIGNED = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n-    static final ValueLayout.OfInt JAVA_INT_ALIGNED = ValueLayout.JAVA_INT.withBitAlignment(32);\n-    static final ValueLayout.OfFloat JAVA_FLOAT_ALIGNED = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n-    static final ValueLayout.OfLong JAVA_LONG_ALIGNED = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-    static final ValueLayout.OfDouble JAVA_DOUBLE_ALIGNED = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n-    static final AddressLayout ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n-\n@@ -121,7 +113,7 @@\n-            layouts.add(new Object[] { testCase.segment, testCase.align, (char) 42, new char[]{42}, JAVA_CHAR_ALIGNED, (Function<char[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, (short) 42, new short[]{42}, JAVA_SHORT_ALIGNED, (Function<short[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42, new int[]{42}, JAVA_INT_ALIGNED, (Function<int[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42f, new float[]{42}, JAVA_FLOAT_ALIGNED, (Function<float[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42L, new long[]{42}, JAVA_LONG_ALIGNED, (Function<long[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42d, new double[]{42}, JAVA_DOUBLE_ALIGNED, (Function<double[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, MemorySegment.ofAddress(42), null, ADDRESS_ALIGNED, null });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (char) 42, new char[]{42}, ValueLayout.JAVA_CHAR, (Function<char[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (short) 42, new short[]{42}, ValueLayout.JAVA_SHORT, (Function<short[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42, new int[]{42}, ValueLayout.JAVA_INT, (Function<int[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42f, new float[]{42}, ValueLayout.JAVA_FLOAT, (Function<float[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42L, new long[]{42}, ValueLayout.JAVA_LONG, (Function<long[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42d, new double[]{42}, ValueLayout.JAVA_DOUBLE, (Function<double[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, MemorySegment.ofAddress(42), null, ValueLayout.ADDRESS, null });\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-                    \"Unsupported layout: [2:i32]\"\n+                    \"Unsupported layout: [2:i4]\"\n@@ -118,1 +118,1 @@\n-                    \"Unsupported layout: [2:i32]\"\n+                    \"Unsupported layout: [2:i4]\"\n@@ -121,2 +121,2 @@\n-                    FunctionDescriptor.ofVoid(C_INT.withBitAlignment(16)),\n-                    \"Layout bit alignment must be natural alignment\"\n+                    FunctionDescriptor.ofVoid(C_INT.withByteAlignment(2)),\n+                    \"Layout alignment must be natural alignment\"\n@@ -125,2 +125,2 @@\n-                    FunctionDescriptor.ofVoid(C_POINTER.withBitAlignment(16)),\n-                    \"Layout bit alignment must be natural alignment\"\n+                    FunctionDescriptor.ofVoid(C_POINTER.withByteAlignment(2)),\n+                    \"Layout alignment must be natural alignment\"\n@@ -129,2 +129,2 @@\n-                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withBitAlignment(32)),\n-                    \"Layout bit alignment must be natural alignment\"\n+                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withByteAlignment(4)),\n+                    \"Layout alignment must be natural alignment\"\n@@ -134,5 +134,5 @@\n-                            C_CHAR.withName(\"x\").withBitAlignment(8),\n-                            C_SHORT.withName(\"y\").withBitAlignment(8),\n-                            C_INT.withName(\"z\").withBitAlignment(8)\n-                            ).withBitAlignment(8)),\n-                    \"Layout bit alignment must be natural alignment\"\n+                            C_CHAR.withName(\"x\").withByteAlignment(1),\n+                            C_SHORT.withName(\"y\").withByteAlignment(1),\n+                            C_INT.withName(\"z\").withByteAlignment(1)\n+                            ).withByteAlignment(1)),\n+                    \"Layout alignment must be natural alignment\"\n@@ -143,3 +143,3 @@\n-                                C_CHAR.withName(\"x\").withBitAlignment(8),\n-                                C_SHORT.withName(\"y\").withBitAlignment(8),\n-                                C_INT.withName(\"z\").withBitAlignment(8)\n+                                C_CHAR.withName(\"x\").withByteAlignment(1),\n+                                C_SHORT.withName(\"y\").withByteAlignment(1),\n+                                C_INT.withName(\"z\").withByteAlignment(1)\n@@ -147,1 +147,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Layout alignment must be natural alignment\"\n@@ -152,1 +152,1 @@\n-                                C_INT.withBitAlignment(8)\n+                                C_INT.withByteAlignment(1)\n@@ -154,1 +154,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Layout alignment must be natural alignment\"\n@@ -159,1 +159,1 @@\n-                            MemoryLayout.paddingLayout(32), \/\/ no excess padding\n+                            MemoryLayout.paddingLayout(4), \/\/ no excess padding\n@@ -184,1 +184,1 @@\n-                            MemoryLayout.paddingLayout(32))), \/\/ too much trailing padding\n+                            MemoryLayout.paddingLayout(4))), \/\/ too much trailing padding\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadBitSelectFromSeq() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(groupElement(\"foo\"));\n-    }\n-\n@@ -61,6 +55,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadBitSelectFromStruct() {\n-        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n-        g.bitOffset(sequenceElement());\n-    }\n-\n@@ -73,6 +61,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadBitSelectFromValue() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(), sequenceElement());\n-    }\n-\n@@ -85,6 +67,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testUnknownBitStructField() {\n-        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n-        g.bitOffset(groupElement(\"foo\"));\n-    }\n-\n@@ -109,6 +85,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitOutOfBoundsSeqIndex() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(6));\n-    }\n-\n@@ -126,6 +96,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitNegativeSeqIndex() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(-2));\n-    }\n-\n@@ -141,1 +105,1 @@\n-        seq.bitOffset(sequenceElement(6, 2));\n+        seq.byteOffset(sequenceElement(6, 2));\n@@ -149,6 +113,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitNegativeSeqRange() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(-2, 2));\n-    }\n-\n@@ -167,6 +125,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitOffsetHandleBadRange() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, MemoryLayout.structLayout(JAVA_INT));\n-        seq.bitOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n-    }\n-\n@@ -184,6 +136,0 @@\n-            try {\n-                seq.bitOffset(e);\n-                fail();\n-            } catch (IllegalArgumentException ex) {\n-                assertTrue(true);\n-            }\n@@ -214,1 +160,1 @@\n-        long[] offsets = { 0, 8, 24, 56 };\n+        long[] offsets = { 0, 1, 3, 7 };\n@@ -217,3 +163,3 @@\n-                ValueLayout.JAVA_CHAR.withBitAlignment(8).withName(\"1\"),\n-                ValueLayout.JAVA_FLOAT.withBitAlignment(8).withName(\"2\"),\n-                ValueLayout.JAVA_LONG.withBitAlignment(8).withName(\"3\")\n+                ValueLayout.JAVA_CHAR_UNALIGNED.withName(\"1\"),\n+                ValueLayout.JAVA_FLOAT_UNALIGNED.withName(\"2\"),\n+                ValueLayout.JAVA_LONG_UNALIGNED.withName(\"3\")\n@@ -232,2 +178,0 @@\n-            long bitOffset = g.bitOffset(groupSelector.apply(i));\n-            assertEquals(offsets[i], bitOffset);\n@@ -235,1 +179,1 @@\n-            assertEquals((offsets[i]) >>> 3, byteOffset);\n+            assertEquals(offsets[i], byteOffset);\n@@ -259,2 +203,0 @@\n-            long bitOffset = g.bitOffset(groupSelector.apply(i));\n-            assertEquals(offsets[i], bitOffset);\n@@ -262,1 +204,1 @@\n-            assertEquals((offsets[i]) >>> 3, byteOffset);\n+            assertEquals(offsets[i], byteOffset);\n@@ -276,1 +218,1 @@\n-        long[] offsets = { 0, 8, 16, 24 };\n+        long[] offsets = { 0, 1, 2, 3 };\n@@ -287,2 +229,0 @@\n-            long bitOffset = g.bitOffset(sequenceElement(i));\n-            assertEquals(offsets[i], bitOffset);\n@@ -290,1 +230,1 @@\n-            assertEquals((offsets[i]) >>> 3, byteOffset);\n+            assertEquals(offsets[i], byteOffset);\n@@ -296,11 +236,5 @@\n-                                 long expectedBitOffset) throws Throwable {\n-        MethodHandle bitOffsetHandle = layout.bitOffsetHandle(pathElements);\n-        bitOffsetHandle = bitOffsetHandle.asSpreader(long[].class, indexes.length);\n-        long actualBitOffset = (long) bitOffsetHandle.invokeExact(indexes);\n-        assertEquals(actualBitOffset, expectedBitOffset);\n-        if (expectedBitOffset % 8 == 0) {\n-            MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n-            byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n-            long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n-            assertEquals(actualByteOffset, expectedBitOffset \/ 8);\n-        }\n+                                 long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        assertEquals(actualByteOffset, expectedByteOffset);\n@@ -317,1 +251,1 @@\n-            JAVA_INT.bitSize() * 4\n+            JAVA_INT.byteSize() * 4\n@@ -323,1 +257,1 @@\n-            (JAVA_INT.bitSize() * 2) * 4 + JAVA_INT.bitSize()\n+            (JAVA_INT.byteSize() * 2) * 4 + JAVA_INT.byteSize()\n@@ -326,1 +260,1 @@\n-            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(4), JAVA_INT.withName(\"y\"))),\n@@ -329,1 +263,1 @@\n-            (JAVA_INT.bitSize() + 32) * 4 + 32\n+            (JAVA_INT.byteSize() + 4) * 4 + 4\n@@ -335,1 +269,1 @@\n-            JAVA_INT.bitSize() * 4\n+            JAVA_INT.byteSize() * 4\n@@ -343,1 +277,1 @@\n-            JAVA_INT.bitSize() * 4\n+            JAVA_INT.byteSize() * 4\n@@ -361,1 +295,1 @@\n-            (JAVA_INT.bitSize() * 2)\n+            (JAVA_INT.byteSize() * 2)\n@@ -367,1 +301,1 @@\n-            (JAVA_INT.bitSize() * 2) * 10\n+            (JAVA_INT.byteSize() * 2) * 10\n@@ -373,1 +307,1 @@\n-            (JAVA_INT.bitSize() * 2) + JAVA_INT.bitSize()\n+            (JAVA_INT.byteSize() * 2) + JAVA_INT.byteSize()\n@@ -379,1 +313,1 @@\n-            (JAVA_INT.bitSize() * 2) * 10 + JAVA_INT.bitSize()\n+            (JAVA_INT.byteSize() * 2) * 10 + JAVA_INT.byteSize()\n@@ -387,4 +321,1 @@\n-                                long expectedBitOffset) throws Throwable {\n-        if (expectedBitOffset % 8 != 0)\n-            throw new SkipException(\"Offset not a multiple of 8\");\n-\n+                                long expectedByteOffset) throws Throwable {\n@@ -398,1 +329,1 @@\n-            assertEquals(slice.address() - segment.address(), expectedBitOffset \/ 8);\n+            assertEquals(slice.address() - segment.address(), expectedByteOffset);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":26,"deletions":95,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        layout.withBitAlignment(alignment);\n+        layout.withByteAlignment(alignment);\n@@ -55,1 +55,1 @@\n-        MemoryLayout differentType = MemoryLayout.paddingLayout(8);\n+        MemoryLayout differentType = MemoryLayout.paddingLayout(1);\n@@ -63,1 +63,1 @@\n-        MemoryLayout differentAlignment = layout.withBitAlignment(layout.bitAlignment() * 2);\n+        MemoryLayout differentAlignment = layout.withByteAlignment(layout.byteAlignment() * 2);\n@@ -81,1 +81,1 @@\n-        MemoryLayout other = layout.withBitAlignment(128).withBitAlignment(layout.bitAlignment());\n+        MemoryLayout other = layout.withByteAlignment(16).withByteAlignment(layout.byteAlignment());\n@@ -127,1 +127,1 @@\n-        layout.withBitAlignment(3);\n+        layout.withByteAlignment(9);\n@@ -131,2 +131,2 @@\n-    public void testGroupIllegalAlignmentNotGreaterOrEqualTo8(MemoryLayout layout) {\n-        layout.withBitAlignment(4);\n+    public void testGroupIllegalAlignmentNotGreaterOrEqualTo1(MemoryLayout layout) {\n+        layout.withByteAlignment(0);\n@@ -137,1 +137,1 @@\n-        PaddingLayout paddingLayout = MemoryLayout.paddingLayout(16);\n+        PaddingLayout paddingLayout = MemoryLayout.paddingLayout(2);\n@@ -139,1 +139,1 @@\n-        PaddingLayout paddingLayout2 = MemoryLayout.paddingLayout(32);\n+        PaddingLayout paddingLayout2 = MemoryLayout.paddingLayout(4);\n@@ -146,2 +146,2 @@\n-        assertEquals(struct.bitSize(), 0);\n-        assertEquals(struct.bitAlignment(), 8);\n+        assertEquals(struct.byteSize(), 0);\n+        assertEquals(struct.byteAlignment(), 1);\n@@ -150,2 +150,2 @@\n-        assertEquals(union.bitSize(), 0);\n-        assertEquals(union.bitAlignment(), 8);\n+        assertEquals(union.byteSize(), 0);\n+        assertEquals(union.byteAlignment(), 1);\n@@ -157,1 +157,1 @@\n-                MemoryLayout.paddingLayout(8),\n+                MemoryLayout.paddingLayout(1),\n@@ -164,1 +164,1 @@\n-        assertEquals(struct.byteAlignment(), 8);\n+        assertEquals(struct.byteAlignment(), ADDRESS.byteSize());\n@@ -169,1 +169,1 @@\n-        assertEquals(MemoryLayout.paddingLayout(layout.bitSize()).bitAlignment(), 8);\n+        assertEquals(MemoryLayout.paddingLayout(layout.byteSize()).byteAlignment(), 1);\n@@ -175,2 +175,2 @@\n-                layout, MemoryLayout.paddingLayout(128 - layout.bitSize()));\n-        assertEquals(struct.bitAlignment(), layout.bitAlignment());\n+                layout, MemoryLayout.paddingLayout(16 - layout.byteSize()));\n+        assertEquals(struct.byteAlignment(), layout.byteAlignment());\n@@ -182,2 +182,2 @@\n-                layout, MemoryLayout.paddingLayout(128 - layout.bitSize()));\n-        assertEquals(struct.bitAlignment(), layout.bitAlignment());\n+                layout, MemoryLayout.paddingLayout(16 - layout.byteSize()));\n+        assertEquals(struct.byteAlignment(), layout.byteAlignment());\n@@ -195,1 +195,1 @@\n-        assertEquals(struct.byteAlignment(), 8);\n+        assertEquals(struct.byteAlignment(), ADDRESS.byteSize());\n@@ -207,1 +207,1 @@\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.bitSize(), layout));\n+                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout));\n@@ -236,1 +236,1 @@\n-        var padding = MemoryLayout.paddingLayout(8);\n+        var padding = MemoryLayout.paddingLayout(1);\n@@ -242,1 +242,1 @@\n-        var padding = MemoryLayout.paddingLayout(8);\n+        var padding = MemoryLayout.paddingLayout(1);\n@@ -248,2 +248,2 @@\n-    public void testPaddingIllegalBitSize() {\n-        for (long bitSize : List.of(-8L, -1L, 0L, 1L, 7L)) {\n+    public void testPaddingIllegalByteSize() {\n+        for (long byteSize : List.of(-1L, 0L)) {\n@@ -251,2 +251,2 @@\n-                MemoryLayout.paddingLayout(bitSize);\n-                fail(\"bitSize cannot be \" + bitSize);\n+                MemoryLayout.paddingLayout(byteSize);\n+                fail(\"byte size cannot be \" + byteSize);\n@@ -262,3 +262,3 @@\n-        assertEquals(padding.toString(), \"[i32](struct)\");\n-        var toStringUnaligned = padding.withBitAlignment(64).toString();\n-        assertEquals(toStringUnaligned, \"64%[i32](struct)\");\n+        assertEquals(padding.toString(), \"[i4](struct)\");\n+        var toStringUnaligned = padding.withByteAlignment(8).toString();\n+        assertEquals(toStringUnaligned, \"8%[i4](struct)\");\n@@ -273,2 +273,2 @@\n-    public void testAlignmentString(MemoryLayout layout, long bitAlign) {\n-        long[] alignments = { 8, 16, 32, 64, 128 };\n+    public void testAlignmentString(MemoryLayout layout, long byteAlign) {\n+        long[] alignments = { 1, 2, 4, 8, 16 };\n@@ -276,1 +276,1 @@\n-            if (layout.bitAlignment() == bitAlign) {\n+            if (layout.byteAlignment() == byteAlign) {\n@@ -278,2 +278,2 @@\n-                if (a >= layout.bitAlignment()) {\n-                    assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+                if (a >= layout.byteAlignment()) {\n+                    assertEquals(layout.withByteAlignment(a).toString().contains(\"%\"), a != byteAlign);\n@@ -286,2 +286,2 @@\n-    public void testBadBitAlignment(MemoryLayout layout, long bitAlign) {\n-        long[] alignments = { 8, 16, 32, 64, 128 };\n+    public void testBadByteAlignment(MemoryLayout layout, long byteAlign) {\n+        long[] alignments = { 1, 2, 4, 8, 16 };\n@@ -289,2 +289,2 @@\n-            if (a < bitAlign && !(layout instanceof ValueLayout)) {\n-                assertThrows(IllegalArgumentException.class, () -> layout.withBitAlignment(a));\n+            if (a < byteAlign && !(layout instanceof ValueLayout)) {\n+                assertThrows(IllegalArgumentException.class, () -> layout.withByteAlignment(a));\n@@ -296,2 +296,2 @@\n-    public void testBadSequenceElementAlignmentTooBig(MemoryLayout layout, long bitAlign) {\n-        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+    public void testBadSequenceElementAlignmentTooBig(MemoryLayout layout, long byteAlign) {\n+        layout = layout.withByteAlignment(layout.byteSize() * 2); \/\/ hyper-align\n@@ -302,1 +302,1 @@\n-    public void testBadSequenceElementSizeNotMultipleOfAlignment(MemoryLayout layout, long bitAlign) {\n+    public void testBadSequenceElementSizeNotMultipleOfAlignment(MemoryLayout layout, long byteAlign) {\n@@ -313,1 +313,1 @@\n-    public void testBadSpliteratorElementSizeNotMultipleOfAlignment(MemoryLayout layout, long bitAlign) {\n+    public void testBadSpliteratorElementSizeNotMultipleOfAlignment(MemoryLayout layout, long byteAlign) {\n@@ -325,1 +325,1 @@\n-    public void testBadElementsElementSizeNotMultipleOfAlignment(MemoryLayout layout, long bitAlign) {\n+    public void testBadElementsElementSizeNotMultipleOfAlignment(MemoryLayout layout, long byteAlign) {\n@@ -337,2 +337,2 @@\n-    public void testBadStruct(MemoryLayout layout, long bitAlign) {\n-        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+    public void testBadStruct(MemoryLayout layout, long byteAlign) {\n+        layout = layout.withByteAlignment(layout.byteSize() * 2); \/\/ hyper-align\n@@ -354,2 +354,2 @@\n-            values[i * 2] = new Object[] { layoutKinds[i].layout, 3 }; \/\/ smaller than 8\n-            values[(i * 2) + 1] = new Object[] { layoutKinds[i].layout, 18 }; \/\/ not a power of 2\n+            values[i * 2] = new Object[] { layoutKinds[i].layout, 0 }; \/\/ smaller than 1\n+            values[(i * 2) + 1] = new Object[] { layoutKinds[i].layout, 5 }; \/\/ not a power of 2\n@@ -371,1 +371,1 @@\n-        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(8)));\n+        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(1)));\n@@ -396,4 +396,4 @@\n-        PADDING(MemoryLayout.paddingLayout(8)),\n-        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(8))),\n-        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8))),\n-        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8)));\n+        PADDING(MemoryLayout.paddingLayout(1)),\n+        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(1))),\n+        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(1), MemoryLayout.paddingLayout(1))),\n+        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(1), MemoryLayout.paddingLayout(1)));\n@@ -434,2 +434,2 @@\n-        for (MemoryLayout l : basicLayouts) {\n-            layoutsAndAlignments.add(new Object[] { l, l.bitAlignment() });\n+        for (MemoryLayout l : basicLayoutsNoLongDouble) {\n+            layoutsAndAlignments.add(new Object[] { l, l.byteAlignment() });\n@@ -438,2 +438,2 @@\n-        for (MemoryLayout l : basicLayouts) {\n-            layoutsAndAlignments.add(new Object[] { MemoryLayout.sequenceLayout(4, l), l.bitAlignment() });\n+        for (MemoryLayout l : basicLayoutsNoLongDouble) {\n+            layoutsAndAlignments.add(new Object[] { MemoryLayout.sequenceLayout(4, l), l.byteAlignment() });\n@@ -442,2 +442,2 @@\n-        for (MemoryLayout l1 : basicLayouts) {\n-            for (MemoryLayout l2 : basicLayouts) {\n+        for (MemoryLayout l1 : basicLayoutsNoLongDouble) {\n+            for (MemoryLayout l2 : basicLayoutsNoLongDouble) {\n@@ -445,1 +445,1 @@\n-                long align = Math.max(l1.bitAlignment(), l2.bitAlignment());\n+                long align = Math.max(l1.byteAlignment(), l2.byteAlignment());\n@@ -450,3 +450,3 @@\n-        for (MemoryLayout l1 : basicLayouts) {\n-            for (MemoryLayout l2 : basicLayouts) {\n-                long align = Math.max(l1.bitAlignment(), l2.bitAlignment());\n+        for (MemoryLayout l1 : basicLayoutsNoLongDouble) {\n+            for (MemoryLayout l2 : basicLayoutsNoLongDouble) {\n+                long align = Math.max(l1.byteAlignment(), l2.byteAlignment());\n@@ -487,1 +487,1 @@\n-                MemoryLayout.structLayout(JAVA_INT, MemoryLayout.paddingLayout(32), JAVA_LONG),\n+                MemoryLayout.structLayout(JAVA_INT, MemoryLayout.paddingLayout(4), JAVA_LONG),\n@@ -492,1 +492,1 @@\n-    static MemoryLayout[] basicLayouts = {\n+    static ValueLayout[] basicLayouts = {\n@@ -501,0 +501,4 @@\n+\n+    static MemoryLayout[] basicLayoutsNoLongDouble = Stream.of(basicLayouts)\n+            .filter(l -> l.carrier() != long.class && l.carrier() != double.class)\n+            .toArray(MemoryLayout[]::new);\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":70,"deletions":66,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -92,4 +92,4 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32).withName(\"x\"), C_LONG_LONG)) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        GroupLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\"));\n+        GroupLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.byteSize()), elemLayout.withName(\"elem\"));\n@@ -77,1 +77,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\")));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.byteSize()), elemLayout.withName(\"elem\")));\n@@ -171,1 +171,1 @@\n-                MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\"))));\n+                MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.byteSize()), elemLayout.withName(\"elem\"))));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                L alignedLayout = (L)layout.withBitAlignment(layout.byteSize() * 8 * 2);\n+                L alignedLayout = (L)layout.withByteAlignment(layout.byteSize() * 2);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-                .withBitAlignment(32)\n@@ -46,3 +45,3 @@\n-        assertEquals(layout.bitAlignment(), 32);\n-        ValueLayout aligned = layout.withBitAlignment(align);\n-        assertEquals(aligned.bitAlignment(), align); \/\/unreasonable alignment here, to make sure access throws\n+        assertEquals(layout.byteAlignment(), 4);\n+        ValueLayout aligned = layout.withByteAlignment(align);\n+        assertEquals(aligned.byteAlignment(), align); \/\/unreasonable alignment here, to make sure access throws\n@@ -61,1 +60,0 @@\n-                .withBitAlignment(32)\n@@ -63,2 +61,2 @@\n-        assertEquals(layout.bitAlignment(), 32);\n-        ValueLayout aligned = layout.withBitAlignment(align);\n+        assertEquals(layout.byteAlignment(), 4);\n+        ValueLayout aligned = layout.withByteAlignment(align);\n@@ -66,2 +64,2 @@\n-            MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n-            assertEquals(alignedGroup.bitAlignment(), align);\n+            MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(1), aligned);\n+            assertEquals(alignedGroup.byteAlignment(), align);\n@@ -80,1 +78,1 @@\n-        MemoryLayout aligned = layout.withBitAlignment(align).withName(\"value\");\n+        MemoryLayout aligned = layout.withByteAlignment(align).withName(\"value\");\n@@ -82,1 +80,1 @@\n-            GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n+            GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(1), aligned);\n@@ -84,1 +82,1 @@\n-            assertEquals(align, 8); \/\/this is the only case where path is aligned\n+            assertEquals(align, 1); \/\/this is the only case where path is aligned\n@@ -86,1 +84,1 @@\n-            assertNotEquals(align, 8); \/\/if align != 8, path is always unaligned\n+            assertNotEquals(align, 1); \/\/if align != 8, path is always unaligned\n@@ -93,1 +91,1 @@\n-            SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n+            SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withByteAlignment(align));\n@@ -102,1 +100,1 @@\n-            assertTrue(align > 32); \/\/if align > 32, access is always unaligned (for some elements)\n+            assertTrue(align > 4); \/\/if align > 4, access is always unaligned (for some elements)\n@@ -112,4 +110,4 @@\n-        GroupLayout g = MemoryLayout.structLayout(vChar.withBitAlignment(8).withName(\"a\"),\n-                               vShort.withBitAlignment(8).withName(\"b\"),\n-                               vInt.withBitAlignment(8).withName(\"c\"));\n-        assertEquals(g.bitAlignment(), 8);\n+        GroupLayout g = MemoryLayout.structLayout(vChar.withByteAlignment(1).withName(\"a\"),\n+                               vShort.withByteAlignment(1).withName(\"b\"),\n+                               vInt.withByteAlignment(1).withName(\"c\"));\n+        assertEquals(g.byteAlignment(), 1);\n@@ -132,1 +130,1 @@\n-        return LongStream.range(3, 32)\n+        return LongStream.range(1, 20)\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-        addDefaultMapping(PaddingLayout.class, MemoryLayout.paddingLayout(32));\n+        addDefaultMapping(PaddingLayout.class, MemoryLayout.paddingLayout(4));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-    final static Class<?> ADDRESS_CARRIER = ValueLayout.ADDRESS.bitSize() == 64 ? long.class : int.class;\n@@ -64,1 +63,1 @@\n-        layout = (L)layout.withBitAlignment(layout.bitSize());\n+        layout = (L)layout.withByteAlignment(layout.byteSize());\n@@ -67,3 +66,3 @@\n-                layout.withBitAlignment(layout.bitAlignment() * 2),\n-                layout.withBitAlignment(layout.bitAlignment() * 4),\n-                layout.withBitAlignment(layout.bitAlignment() * 8)\n+                layout.withByteAlignment(layout.byteAlignment() * 2),\n+                layout.withByteAlignment(layout.byteAlignment() * 4),\n+                layout.withByteAlignment(layout.byteAlignment() * 8)\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        MemorySegment.copy(segment, 0, segment, JAVA_BYTE.withBitAlignment(16), 0, 4);\n+        MemorySegment.copy(segment, 0, segment, JAVA_BYTE.withByteAlignment(2), 0, 4);\n@@ -117,1 +117,1 @@\n-        MemorySegment.copy(segment, JAVA_BYTE.withBitAlignment(16), 0, segment, 0, 4);\n+        MemorySegment.copy(segment, JAVA_BYTE.withByteAlignment(2), 0, segment, 0, 4);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-        segment.elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withBitAlignment(bigByteAlign * 8)));\n+        segment.elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withByteAlignment(bigByteAlign)));\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        MemoryLayout.paddingLayout(32)\n+        MemoryLayout.paddingLayout(4)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        MemoryLayout.paddingLayout(32)\n+        MemoryLayout.paddingLayout(4)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        testAligned(JAVA_BYTE, byte.class, Byte.SIZE);\n+        testAligned(JAVA_BYTE, byte.class, Byte.BYTES);\n@@ -49,1 +49,1 @@\n-        testAligned(JAVA_BOOLEAN, boolean.class, Byte.SIZE);\n+        testAligned(JAVA_BOOLEAN, boolean.class, Byte.BYTES);\n@@ -54,1 +54,1 @@\n-        testAligned(JAVA_SHORT, short.class, Short.SIZE);\n+        testAligned(JAVA_SHORT, short.class, Short.BYTES);\n@@ -59,1 +59,1 @@\n-        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.SIZE);\n+        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.BYTES);\n@@ -64,1 +64,1 @@\n-        testAligned(JAVA_INT, int.class, Integer.SIZE);\n+        testAligned(JAVA_INT, int.class, Integer.BYTES);\n@@ -69,1 +69,1 @@\n-        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.SIZE);\n+        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.BYTES);\n@@ -74,1 +74,1 @@\n-        testAligned(JAVA_LONG, long.class, Long.SIZE);\n+        testAligned(JAVA_LONG, long.class, Long.BYTES, ADDRESS.byteSize());\n@@ -79,1 +79,1 @@\n-        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.SIZE);\n+        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.BYTES);\n@@ -84,1 +84,1 @@\n-        testAligned(JAVA_FLOAT, float.class, Float.SIZE);\n+        testAligned(JAVA_FLOAT, float.class, Float.BYTES);\n@@ -89,1 +89,1 @@\n-        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.SIZE);\n+        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.BYTES);\n@@ -94,1 +94,1 @@\n-        testAligned(JAVA_DOUBLE, double.class, Double.SIZE);\n+        testAligned(JAVA_DOUBLE, double.class, Double.BYTES, ADDRESS.byteSize());\n@@ -99,1 +99,1 @@\n-        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.SIZE);\n+        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.BYTES);\n@@ -104,1 +104,1 @@\n-        testAligned(JAVA_CHAR, char.class, Character.SIZE);\n+        testAligned(JAVA_CHAR, char.class, Character.BYTES);\n@@ -109,1 +109,1 @@\n-        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.SIZE);\n+        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.BYTES);\n@@ -114,1 +114,1 @@\n-        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE);\n@@ -119,1 +119,1 @@\n-        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE);\n@@ -124,2 +124,9 @@\n-                     long bitSize) {\n-        test(layout, carrier, bitSize, bitSize);\n+                     long byteSize) {\n+        test(layout, carrier, byteSize, byteSize);\n+    }\n+\n+    void testAligned(ValueLayout layout,\n+                     Class<?> carrier,\n+                     long byteSize,\n+                     long byteAlignment) {\n+        test(layout, carrier, byteSize, byteAlignment);\n@@ -130,2 +137,2 @@\n-                       long bitSize) {\n-        test(layout, carrier, bitSize, Byte.SIZE);\n+                       long byteSize) {\n+        test(layout, carrier, byteSize, Byte.BYTES);\n@@ -136,2 +143,2 @@\n-              long bitSize,\n-              long bitAlignment) {\n+              long byteSize,\n+              long byteAlignment) {\n@@ -139,1 +146,1 @@\n-        assertEquals(layout.bitSize(), bitSize);\n+        assertEquals(layout.byteSize(), byteSize);\n@@ -141,1 +148,1 @@\n-        assertEquals(layout.bitAlignment(), bitAlignment);\n+        assertEquals(layout.byteAlignment(), byteAlignment);\n@@ -143,2 +150,0 @@\n-        assertEquals(layout.byteSize(), layout.bitSize() \/ 8);\n-        assertEquals(layout.byteAlignment(), layout.bitAlignment() \/ 8);\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n@@ -66,1 +66,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n@@ -76,2 +76,2 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT\n-                .withOrder(ByteOrder.LITTLE_ENDIAN).withBitAlignment(8));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n+                .withOrder(ByteOrder.LITTLE_ENDIAN));\n@@ -87,2 +87,2 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT\n-                .withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n+                .withOrder(ByteOrder.BIG_ENDIAN));\n@@ -103,1 +103,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n+        newLayout = newLayout.withByteAlignment(layout.byteAlignment());\n@@ -59,2 +59,2 @@\n-        assertEquals(newLayout.bitSize(), layout.bitSize());\n-        assertEquals(newLayout.bitAlignment(), layout.bitAlignment());\n+        assertEquals(newLayout.byteSize(), layout.byteSize());\n+        assertEquals(newLayout.byteAlignment(), layout.byteAlignment());\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(4), C_DOUBLE),\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(4), C_DOUBLE),\n@@ -260,1 +260,1 @@\n-        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE);\n+        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(4), C_DOUBLE);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.paddingLayout(4),\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            MemoryLayout.paddingLayout(32)\n+            MemoryLayout.paddingLayout(4)\n@@ -98,1 +98,1 @@\n-            MemoryLayout.paddingLayout(128)\n+            MemoryLayout.paddingLayout(16)\n@@ -110,1 +110,1 @@\n-            MemoryLayout.paddingLayout(48)\n+            MemoryLayout.paddingLayout(6)\n@@ -120,1 +120,1 @@\n-            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.paddingLayout(4),\n@@ -125,1 +125,1 @@\n-            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.paddingLayout(4),\n@@ -142,1 +142,1 @@\n-            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.paddingLayout(4),\n@@ -172,1 +172,1 @@\n-            MemoryLayout.paddingLayout(48),\n+            MemoryLayout.paddingLayout(6),\n@@ -178,1 +178,1 @@\n-            MemoryLayout.paddingLayout(56),\n+            MemoryLayout.paddingLayout(7),\n@@ -181,1 +181,1 @@\n-            MemoryLayout.paddingLayout(56),\n+            MemoryLayout.paddingLayout(7),\n@@ -210,1 +210,1 @@\n-            MemoryLayout.paddingLayout(8)\n+            MemoryLayout.paddingLayout(1)\n@@ -240,1 +240,1 @@\n-            MemoryLayout.paddingLayout(24),\n+            MemoryLayout.paddingLayout(3),\n@@ -243,1 +243,1 @@\n-            MemoryLayout.paddingLayout(56)\n+            MemoryLayout.paddingLayout(7)\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n-    private static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+    private static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    private static final AddressLayout C_POINTER = ValueLayout.ADDRESS;\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.Enum.EnumDesc;\n+import java.lang.constant.ClassDesc;\n@@ -32,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -36,0 +39,2 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -161,0 +166,22 @@\n+    public void testSwitchLabelTypes() throws Throwable {\n+        enum E {A}\n+        try {\n+            testType(E.A, 0, -1, E.A);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK, expected\n+        }\n+    }\n+\n+    public void testSwitchQualifiedEnum() throws Throwable {\n+        enum E {A, B, C}\n+        Object[] labels = new Object[] {\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"A\"),\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"B\"),\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"C\")\n+        };\n+        testType(E.A, 0, 0, labels);\n+        testType(E.B, 0, 1, labels);\n+        testType(E.C, 0, 2, labels);\n+    }\n+\n@@ -191,0 +218,96 @@\n+\n+    private static AtomicBoolean enumInitialized = new AtomicBoolean();\n+    public void testEnumInitialization1() throws Throwable {\n+        enumInitialized.set(false);\n+\n+        enum E {\n+            A;\n+\n+            static {\n+                enumInitialized.set(true);\n+            }\n+        }\n+\n+        MethodType enumSwitchType = MethodType.methodType(int.class, E.class, int.class);\n+\n+        CallSite invocation = (CallSite) BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType, new Object[] {\"A\"});\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(null, 0), -1);\n+        assertFalse(enumInitialized.get());\n+        E e = E.A;\n+        assertTrue(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(e, 0), 0);\n+    }\n+\n+    public void testEnumInitialization2() throws Throwable {\n+        enumInitialized.set(false);\n+\n+        enum E {\n+            A;\n+\n+            static {\n+                enumInitialized.set(true);\n+            }\n+        }\n+\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        Object[] labels = new Object[] {\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"A\"),\n+            \"test\"\n+        };\n+        CallSite invocation = (CallSite) BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels);\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(null, 0), -1);\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(\"test\", 0), 1);\n+        assertFalse(enumInitialized.get());\n+        E e = E.A;\n+        assertTrue(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(e, 0), 0);\n+    }\n+\n+    public void testIncorrectEnumLabels() throws Throwable {\n+        try {\n+            testEnum(E1.B, 0, -1, \"B\", 1);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, \"B\", null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    public void testIncorrectEnumStartIndex() throws Throwable {\n+        try {\n+            testEnum(E1.B, -1, -1, \"B\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 2, -1, \"B\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    public void testIncorrectTypeStartIndex() throws Throwable {\n+        try {\n+            testType(\"\", -1, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testType(\"\", 2, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    static void checkWithin1GB(long expected, long actual) {\n+    static void checkWithin1GB(String space, long expected, long actual) {\n@@ -63,2 +63,3 @@\n-            String msg = String.format(\"|actual %d - expected %d| = %d (%f G)\",\n-                                       actual, expected, diff, (float)diff\/G);\n+            String msg = String.format(\"%s: |actual %d - expected %d| = %d (%f G)\",\n+                                       space, actual, expected, diff,\n+                                       (float)diff\/G);\n@@ -113,3 +114,0 @@\n-        long total = f.getTotalSpace();\n-        long free = f.getFreeSpace();\n-        long usable = f.getUsableSpace();\n@@ -118,3 +116,3 @@\n-        checkWithin1GB(total,  store1.getTotalSpace());\n-        checkWithin1GB(free,   store1.getUnallocatedSpace());\n-        checkWithin1GB(usable, store1.getUsableSpace());\n+        checkWithin1GB(\"total\",  f.getTotalSpace(),  store1.getTotalSpace());\n+        checkWithin1GB(\"free\",   f.getFreeSpace(),   store1.getUnallocatedSpace());\n+        checkWithin1GB(\"usable\", f.getUsableSpace(), store1.getUsableSpace());\n@@ -123,3 +121,6 @@\n-        checkWithin1GB(total,  (Long)store1.getAttribute(\"totalSpace\"));\n-        checkWithin1GB(free,   (Long)store1.getAttribute(\"unallocatedSpace\"));\n-        checkWithin1GB(usable, (Long)store1.getAttribute(\"usableSpace\"));\n+        checkWithin1GB(\"total\",  f.getTotalSpace(),\n+                       (Long)store1.getAttribute(\"totalSpace\"));\n+        checkWithin1GB(\"free\",   f.getFreeSpace(),\n+                       (Long)store1.getAttribute(\"unallocatedSpace\"));\n+        checkWithin1GB(\"usable\", f.getUsableSpace(),\n+                       (Long)store1.getAttribute(\"usableSpace\"));\n","filename":"test\/jdk\/java\/nio\/file\/FileStore\/Basic.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *      8258795 8267038 8287180 8302512 8304761 8306031\n+ *      8258795 8267038 8287180 8302512 8304761 8306031 8308021\n@@ -29,1 +29,1 @@\n- *          (LSR Revision: 2023-04-13) with Locale and Locale.LanguageRange\n+ *          (LSR Revision: 2023-05-11) with Locale and Locale.LanguageRange\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.api.Test;\n+\n+import java.nio.CharBuffer;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8132995\n+ * @key randomness\n+ *\n+ * @summary Tests to exercise the optimization described in the bug report.\n+ * @library \/test\/lib\n+ * @run junit ImmutableMatchResultTest\n+ *\/\n+\n+public class ImmutableMatchResultTest {\n+\n+    private static final int prefixLen;\n+    private static final int infixLen;\n+    private static final int suffixLen;\n+    private static final String group1 = \"abc\";\n+    private static final String group2 = \"wxyz\";\n+    private static final String group0;\n+    private static final String in;\n+    private static final String groupResults = \"(([a-z]+)([0-9]*))\";\n+    private static final String inResults;\n+    private static final String letters1 = \"abcd\";\n+    private static final String digits1 = \"12\";\n+    private static final String letters2 = \"pqr\";\n+    private static final String digits2 = \"\";\n+\n+    static {\n+        Random rnd = RandomFactory.getRandom();\n+        prefixLen = rnd.nextInt(10);\n+        infixLen = rnd.nextInt(10);\n+        suffixLen = rnd.nextInt(10);\n+        group0 = group1 + \"-\".repeat(infixLen) + group2;\n+        in = \"-\".repeat(prefixLen) + group0 + \"-\".repeat(suffixLen);\n+        inResults = \" \".repeat(prefixLen) + letters1 + digits1 + \" \".repeat(infixLen) + letters2 + digits2 + \" \".repeat(suffixLen);\n+    }\n+\n+    private static void test(CharSequence cs) {\n+        Matcher m = Pattern.compile(\"(\" + group1 + \")-*(\" + group2 + \")\").matcher(cs);\n+        assertTrue(m.find());\n+\n+        assertEquals(prefixLen, m.start());\n+        assertEquals(prefixLen + group0.length(), m.end());\n+        assertEquals(group0, m.toMatchResult().group());\n+\n+        assertEquals(prefixLen, m.start(1));\n+        assertEquals(prefixLen + group1.length(), m.end(1));\n+        assertEquals(group1, m.toMatchResult().group(1));\n+\n+        assertEquals(prefixLen + group1.length() + infixLen, m.start(2));\n+        assertEquals(prefixLen + group1.length() + infixLen + group2.length(), m.end(2));\n+        assertEquals(group2, m.toMatchResult().group(2));\n+    }\n+\n+    @Test\n+    void testString() {\n+        test(in);\n+    }\n+\n+    @Test\n+    void testStringBuilder() {\n+        test(new StringBuilder(in));\n+    }\n+\n+    @Test\n+    void testStringBuffer() {\n+        test(new StringBuffer(in));\n+    }\n+\n+    @Test\n+    void testCharBuffer() {\n+        test(CharBuffer.wrap(in));\n+    }\n+\n+    private static void testResultsStream(CharSequence cs) {\n+        Matcher m = Pattern.compile(groupResults).matcher(cs);\n+        List<MatchResult> results = m.results().toList();\n+        assertEquals(2, results.size());\n+\n+        int startLetters1 = prefixLen;\n+        int endLetters1 = startLetters1 + letters1.length();\n+        int startDigits1 = endLetters1;\n+        int endDigits1 = startDigits1 + digits1.length();\n+\n+        assertEquals(startLetters1, results.get(0).start());\n+        assertEquals(startLetters1, results.get(0).start(0));\n+        assertEquals(startLetters1, results.get(0).start(1));\n+        assertEquals(startLetters1, results.get(0).start(2));\n+        assertEquals(startDigits1, results.get(0).start(3));\n+\n+        assertEquals(endDigits1, results.get(0).end());\n+        assertEquals(endDigits1, results.get(0).end(0));\n+        assertEquals(endDigits1, results.get(0).end(1));\n+        assertEquals(endLetters1, results.get(0).end(2));\n+        assertEquals(endDigits1, results.get(0).end(3));\n+\n+        assertEquals(letters1 + digits1, results.get(0).group());\n+        assertEquals(letters1 + digits1, results.get(0).group(0));\n+        assertEquals(letters1 + digits1, results.get(0).group(1));\n+        assertEquals(letters1, results.get(0).group(2));\n+        assertEquals(digits1, results.get(0).group(3));\n+\n+        int startLetters2 = endDigits1 + infixLen;\n+        int endLetters2 = startLetters2 + letters2.length();\n+        int startDigits2 = endLetters2;\n+        int endDigits2 = startDigits2 + digits2.length();\n+\n+        assertEquals(startLetters2, results.get(1).start());\n+        assertEquals(startLetters2, results.get(1).start(0));\n+        assertEquals(startLetters2, results.get(1).start(1));\n+        assertEquals(startLetters2, results.get(1).start(2));\n+        assertEquals(startDigits2, results.get(1).start(3));\n+\n+        assertEquals(endDigits2, results.get(1).end());\n+        assertEquals(endDigits2, results.get(1).end(0));\n+        assertEquals(endDigits2, results.get(1).end(1));\n+        assertEquals(endLetters2, results.get(1).end(2));\n+        assertEquals(endDigits2, results.get(1).end(3));\n+\n+        assertEquals(letters2 + digits2, results.get(1).group());\n+        assertEquals(letters2 + digits2, results.get(1).group(0));\n+        assertEquals(letters2 + digits2, results.get(1).group(1));\n+        assertEquals(letters2, results.get(1).group(2));\n+        assertEquals(digits2, results.get(1).group(3));\n+    }\n+\n+    @Test\n+    void testResultsStreamString() {\n+        testResultsStream(inResults);\n+    }\n+\n+    @Test\n+    void testResultsStreamStringBuilder() {\n+        testResultsStream(new StringBuilder(inResults));\n+    }\n+\n+    @Test\n+    void testResultsStreamStringBuffer() {\n+        testResultsStream(new StringBuffer(inResults));\n+    }\n+\n+    @Test\n+    void testResultsStreamCharBuffer() {\n+        testResultsStream(CharBuffer.wrap(inResults));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/regex\/ImmutableMatchResultTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,320 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @bug 8301381\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n+ * @summary DTLSv10 is now disabled. This test verifies that the server will\n+ *     not negotiate a connection if the client asks for it.\n+ * @run main\/othervm DTLSWontNegotiateV10 DTLS\n+ * @run main\/othervm DTLSWontNegotiateV10 DTLSv1.0\n+ *\/\n+public class DTLSWontNegotiateV10 {\n+\n+    private static final int MTU = 1024;\n+    private static final String DTLSV_1_0 = \"DTLSv1.0\";\n+    private static final String DTLS = \"DTLS\";\n+    private static final String DTLSV_1_2 = \"DTLSv1.2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args[0].equals(DTLSV_1_0)) {\n+            SecurityUtils.removeFromDisabledTlsAlgs(DTLSV_1_0);\n+        }\n+\n+        if (args.length > 1) {\n+            \/\/ running in client child process\n+            \/\/ args: protocol server-port\n+            try (DTLSClient client = new DTLSClient(args[0], Integer.parseInt(args[1]))) {\n+                client.run();\n+            }\n+\n+        } else {\n+            \/\/ server process\n+            \/\/ args: protocol\n+            try (DTLSServer server = new DTLSServer(args[0])) {\n+                List<String> command = List.of(\n+                        Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n+                        \"DTLSWontNegotiateV10\",\n+                        \/\/ if server is \"DTLS\" then the client should be v1.0 and vice versa\n+                        args[0].equals(DTLS) ? DTLSV_1_0 : DTLS,\n+                        Integer.toString(server.getListeningPortNumber())\n+                );\n+\n+                ProcessBuilder builder = new ProcessBuilder(command);\n+                Process p = builder.inheritIO().start();\n+                server.run();\n+                p.destroy();\n+                System.out.println(\"Success: DTLSv1.0 connection was not established.\");\n+            }\n+        }\n+    }\n+\n+    private static class DTLSClient extends DTLSEndpoint {\n+        private final int remotePort;\n+\n+        private final DatagramSocket socket = new DatagramSocket();\n+\n+        public DTLSClient(String protocol, int portNumber) throws Exception {\n+            super(true, protocol);\n+            remotePort = portNumber;\n+            log(\"Enabled protocols: \" + String.join(\" \", engine.getEnabledProtocols()));\n+        }\n+\n+        @Override\n+        public void run() throws Exception {\n+            doHandshake(socket);\n+            log(\"Client done handshaking. Protocol: \" + engine.getSession().getProtocol());\n+        }\n+\n+        @Override\n+        void setRemotePortNumber(int portNumber) {\n+            \/\/ don't do anything; we're using the one we already know\n+        }\n+\n+        @Override\n+        int getRemotePortNumber() {\n+            return remotePort;\n+        }\n+\n+        @Override\n+        public void close () {\n+            socket.close();\n+        }\n+    }\n+\n+    private abstract static class DTLSEndpoint extends SSLContextTemplate implements AutoCloseable {\n+        protected final SSLEngine engine;\n+        protected final SSLContext context;\n+        private final String protocol;\n+        protected final InetAddress LOCALHOST;\n+\n+        private final String tag;\n+\n+        public DTLSEndpoint(boolean useClientMode, String protocol) throws Exception {\n+            this.protocol = protocol;\n+            if (useClientMode) {\n+                tag = \"client\";\n+                context = createClientSSLContext();\n+            } else {\n+                tag = \"server\";\n+                context = createServerSSLContext();\n+            }\n+            engine = context.createSSLEngine();\n+            engine.setUseClientMode(useClientMode);\n+            SSLParameters params = engine.getSSLParameters();\n+            params.setMaximumPacketSize(MTU);\n+            engine.setSSLParameters(params);\n+            if (protocol.equals(DTLS)) {\n+                \/\/ make sure both versions are \"enabled\"; 1.0 should be\n+                \/\/ disabled by policy now and won't be negotiated.\n+                engine.setEnabledProtocols(new String[]{DTLSV_1_0, DTLSV_1_2});\n+            } else {\n+                engine.setEnabledProtocols(new String[]{DTLSV_1_0});\n+            }\n+\n+            LOCALHOST = InetAddress.getByName(\"localhost\");\n+        }\n+\n+        @Override\n+        protected ContextParameters getServerContextParameters() {\n+            return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n+        }\n+\n+        @Override\n+        protected ContextParameters getClientContextParameters() {\n+            return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n+        }\n+\n+\n+        abstract void setRemotePortNumber(int portNumber);\n+\n+        abstract int getRemotePortNumber();\n+\n+        abstract void run() throws Exception;\n+\n+        private boolean runDelegatedTasks() {\n+            log(\"Running delegated tasks.\");\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                runnable.run();\n+            }\n+\n+            SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();\n+            if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                throw new RuntimeException(\n+                        \"Handshake shouldn't need additional tasks\");\n+            }\n+\n+            return true;\n+        }\n+\n+        protected void doHandshake(DatagramSocket socket) throws Exception {\n+            boolean handshaking = true;\n+            engine.beginHandshake();\n+            while (handshaking) {\n+                log(\"Handshake status = \" + engine.getHandshakeStatus());\n+                handshaking = switch (engine.getHandshakeStatus()) {\n+                    case NEED_UNWRAP, NEED_UNWRAP_AGAIN -> readFromServer(socket);\n+                    case NEED_WRAP -> sendHandshakePackets(socket);\n+                    case NEED_TASK -> runDelegatedTasks();\n+                    case NOT_HANDSHAKING, FINISHED -> false;\n+                };\n+            }\n+        }\n+\n+        private boolean readFromServer(DatagramSocket socket) throws IOException {\n+            log(\"Reading data from remote endpoint.\");\n+            ByteBuffer iNet, iApp;\n+            if (engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                byte[] buffer = new byte[MTU];\n+                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n+                socket.receive(packet);\n+                setRemotePortNumber(packet.getPort());\n+                iNet = ByteBuffer.wrap(buffer, 0, packet.getLength());\n+                iApp = ByteBuffer.allocate(MTU);\n+            } else {\n+                iNet = ByteBuffer.allocate(0);\n+                iApp = ByteBuffer.allocate(MTU);\n+            }\n+\n+            SSLEngineResult engineResult;\n+            do {\n+                engineResult = engine.unwrap(iNet, iApp);\n+            } while (iNet.hasRemaining());\n+\n+            return switch (engineResult.getStatus()) {\n+                case CLOSED -> false;\n+                case OK -> true;\n+                case BUFFER_OVERFLOW -> throw new RuntimeException(\"Buffer overflow: \"\n+                        + \"incorrect server maximum fragment size\");\n+                case BUFFER_UNDERFLOW -> throw new RuntimeException(\"Buffer underflow: \"\n+                        + \"incorrect server maximum fragment size\");\n+            };\n+        }\n+\n+        private boolean sendHandshakePackets(DatagramSocket socket) throws Exception {\n+            List<DatagramPacket> packets = generateHandshakePackets();\n+            log(\"Sending handshake packets.\");\n+            packets.forEach((p) -> {\n+                try {\n+                    socket.send(p);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            return true;\n+        }\n+\n+        private List<DatagramPacket> generateHandshakePackets() throws SSLException {\n+            log(\"Generating handshake packets.\");\n+            List<DatagramPacket> packets = new ArrayList<>();\n+            ByteBuffer oNet = ByteBuffer.allocate(engine.getSession().getPacketBufferSize());\n+            ByteBuffer oApp = ByteBuffer.allocate(0);\n+\n+            while (engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                SSLEngineResult result = engine.wrap(oApp, oNet);\n+                oNet.flip();\n+\n+                switch (result.getStatus()) {\n+                    case BUFFER_UNDERFLOW -> {\n+                        if (engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+                            throw new RuntimeException(\"Buffer underflow: \"\n+                                    + \"incorrect server maximum fragment size\");\n+                        }\n+                    }\n+                    case BUFFER_OVERFLOW -> throw new RuntimeException(\"Buffer overflow: \"\n+                            + \"incorrect server maximum fragment size\");\n+                    case CLOSED -> throw new RuntimeException(\"SSLEngine has closed\");\n+                }\n+\n+                if (oNet.hasRemaining()) {\n+                    byte[] packetBuffer = new byte[oNet.remaining()];\n+                    oNet.get(packetBuffer);\n+                    packets.add(new DatagramPacket(packetBuffer, packetBuffer.length,\n+                            LOCALHOST, getRemotePortNumber()));\n+                }\n+\n+                runDelegatedTasks();\n+                oNet.clear();\n+            }\n+\n+            log(\"Generated \" + packets.size() + \" packets.\");\n+            return packets;\n+        }\n+\n+        protected void log(String msg) {\n+            System.out.println(tag + \": \" + msg);\n+        }\n+    }\n+\n+    private static class DTLSServer extends DTLSEndpoint implements AutoCloseable {\n+\n+        private final AtomicInteger portNumber = new AtomicInteger(0);\n+        private final DatagramSocket socket = new DatagramSocket(0);\n+\n+        public DTLSServer(String protocol) throws Exception {\n+            super(false, protocol);\n+            log(\"Enabled protocols: \" + String.join(\" \", engine.getEnabledProtocols()));\n+        }\n+\n+        @Override\n+        public void run() throws Exception {\n+            doHandshake(socket);\n+            if (!engine.getSession().getProtocol().equals(\"NONE\")) {\n+                throw new RuntimeException(\"Negotiated protocol: \"\n+                        + engine.getSession().getProtocol() +\n+                        \". No protocol should be negotated.\");\n+            }\n+        }\n+\n+        public int getListeningPortNumber() {\n+            return socket.getLocalPort();\n+        }\n+\n+        void setRemotePortNumber(int portNumber) {\n+            this.portNumber.compareAndSet(0, portNumber);\n+        }\n+\n+        int getRemotePortNumber() {\n+            return portNumber.get();\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            socket.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSWontNegotiateV10.java","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"},{"patch":"@@ -56,1 +56,0 @@\n-            robot.setAutoDelay(100);\n@@ -72,0 +71,1 @@\n+                frame.setAlwaysOnTop(true);\n@@ -86,1 +86,1 @@\n-                robot.waitForIdle();\n+                robot.delay(100);\n@@ -112,0 +112,2 @@\n+                System.out.println(\"oldColumn \" + oldColumn + \" newColumn \" + newColumn +\n+                        \"header.getCursor \" + header.getCursor() + \" cursor \" + cursor);\n","filename":"test\/jdk\/javax\/swing\/JTableHeader\/6889007\/bug6889007.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.Utils;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+\n+import static jdk.test.lib.security.XMLUtils.*;\n+\/**\n+ * @test\n+ * @bug 8305972\n+ * @summary Basic tests using XMLUtils\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\n+ *\/\n+public class Basic {\n+\n+    public static void main(String[] args) throws Exception {\n+        var x = \"<a><b>c<\/b>x<\/a>\";\n+        var p = Files.write(Path.of(\"x.xml\"), List.of(x));\n+        var b = Path.of(\"\").toUri().toString();\n+        var d = string2doc(x);\n+        var pass = \"changeit\".toCharArray();\n+        for (String alg: List.of(\"DSA\", \"RSA\", \"RSASSA-PSS\", \"EC\", \"EdDSA\", \"Ed25519\", \"Ed448\")) {\n+            SecurityTools.keytool(String.format(\n+                    \"-keystore ks -keyalg %s -storepass changeit -genkeypair -alias %s -dname CN=%s\",\n+                    alg, alg, alg)).shouldHaveExitValue(0);\n+            var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+            var c = (X509Certificate) ks.getCertificate(alg);\n+            var pr = (PrivateKey) ks.getKey(alg, pass);\n+            var pu = c.getPublicKey();\n+\n+            var s0 = signer(pr); \/\/ No KeyInfo\n+            var s1 = signer(pr, c); \/\/ KeyInfo is X509Data\n+            var s2 = signer(ks, alg, pass); \/\/ KeyInfo is KeyName\n+            var v1 = validator(); \/\/ knows nothing\n+            var v2 = validator(ks); \/\/ knows KeyName\n+\n+            Utils.runAndCheckException(() -> v1.validate(s0.sign(d)), IllegalArgumentException.class); \/\/ need PublicKey\n+            s0.sign(string2doc(x));\n+            Asserts.assertTrue(v1.validate(s0.sign(d), pu)); \/\/ need PublicKey\n+            Asserts.assertTrue(v1.validate(s1.sign(d))); \/\/ can read KeyInfo\n+            Asserts.assertTrue(v2.validate(s2.sign(d))); \/\/ can read KeyInfo\n+            Asserts.assertTrue(v2.secureValidation(false).validate(s2.sign(p.toUri()))); \/\/ can read KeyInfo\n+            Asserts.assertTrue(v2.secureValidation(false).baseURI(b).validate(\n+                    s2.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n+\n+            Asserts.assertTrue(v1.validate(s0.sign(\"text\"), pu)); \/\/ plain text\n+            Asserts.assertTrue(v1.validate(s0.sign(\"binary\".getBytes()), pu)); \/\/ raw data\n+            Asserts.assertTrue(v1.validate(s0.signEnveloping(d, \"x\", \"#x\"), pu));\n+            Asserts.assertTrue(v1.validate(s0.signEnveloping(d, \"x\", \"#xpointer(id('x'))\"), pu));\n+\n+            \/\/ No KeyValue defined for RSASSA-PSS or EdDSA yet\n+            if (!alg.startsWith(\"Ed\") && !alg.equals(\"RSASSA-PSS\")) {\n+                var ss = signer(pr, pu); \/\/ KeyInfo is PublicKey\n+                Asserts.assertTrue(v1.validate(ss.sign(d))); \/\/ can read KeyInfo\n+                Asserts.assertTrue(v1.validate(ss.sign(\"text\"))); \/\/ plain text\n+                Asserts.assertTrue(v1.validate(ss.sign(\"binary\".getBytes()))); \/\/ raw data\n+                Asserts.assertTrue(v1.validate(ss.signEnveloping(d, \"x\", \"#x\")));\n+                Asserts.assertTrue(v1.validate(ss.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/Basic.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- *      8046724 8079693 8177334 8205507 8210736 8217878 8241306\n+ *      8046724 8079693 8177334 8205507 8210736 8217878 8241306 8305972\n@@ -59,12 +59,2 @@\n-import java.security.spec.KeySpec;\n-import java.security.spec.DSAPrivateKeySpec;\n-import java.security.spec.DSAPublicKeySpec;\n-import java.security.spec.ECField;\n-import java.security.spec.ECFieldFp;\n-import java.security.spec.ECParameterSpec;\n-import java.security.spec.ECPoint;\n-import java.security.spec.ECPrivateKeySpec;\n-import java.security.spec.ECPublicKeySpec;\n-import java.security.spec.EllipticCurve;\n-import java.security.spec.RSAPrivateKeySpec;\n-import java.security.spec.RSAPublicKeySpec;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.*;\n@@ -113,1 +103,2 @@\n-            rsaSha1mgf1, rsaSha224mgf1, rsaSha256mgf1, rsaSha384mgf1, rsaSha512mgf1, rsaShaPSS;\n+            rsaSha1mgf1, rsaSha224mgf1, rsaSha256mgf1, rsaSha384mgf1, rsaSha512mgf1,\n+            rsaShaPSS, ed25519, ed448;\n@@ -117,1 +108,1 @@\n-                           p256ki, p384ki, p521ki;\n+                           p256ki, p384ki, p521ki, ed25519ki, ed448ki;\n@@ -119,0 +110,1 @@\n+    private static KeySelector x5ks = new KeySelectors.RawX509KeySelector();\n@@ -220,1 +212,2 @@\n-            SignatureMethod.RSA_PSS);\n+            SignatureMethod.RSA_PSS,\n+            SignatureMethod.ED25519);\n@@ -254,1 +247,1 @@\n-        if (allSignatureMethods.length != 23\n+        if (allSignatureMethods.length != 25\n@@ -315,0 +308,2 @@\n+        test_create_signature_enveloping_ed25519();\n+        test_create_signature_enveloping_ed448();\n@@ -362,2 +357,4 @@\n-                                    test_create_detached_signature(c, s, d, t, k,\n-                                            Content.Xml, server.getPort(), false, null);\n+                                    if (!s.contains(\"#eddsa\") || k != KeyInfoType.KeyValue) {\n+                                        test_create_detached_signature(c, s, d, t, k,\n+                                                Content.Xml, server.getPort(), false, null);\n+                                    }\n@@ -373,2 +370,4 @@\n-                                test_create_detached_signature(c, s, d, null, k,\n-                                        Content.Text, server.getPort(), false, null);\n+                                if (!s.contains(\"#eddsa\") || k != KeyInfoType.KeyValue) {\n+                                    test_create_detached_signature(c, s, d, null, k,\n+                                            Content.Text, server.getPort(), false, null);\n+                                }\n@@ -385,3 +384,5 @@\n-                                    test_create_detached_signature(c, s, d, t, k,\n-                                            Content.Base64, server.getPort(),\n-                                            false, null);\n+                                    if (!s.contains(\"#eddsa\") || k != KeyInfoType.KeyValue) {\n+                                        test_create_detached_signature(c, s, d, t, k,\n+                                                Content.Base64, server.getPort(),\n+                                                false, null);\n+                                    }\n@@ -528,0 +529,5 @@\n+        ed25519ki = kifac.newKeyInfo(Collections.singletonList\n+            (kifac.newX509Data(List.of(getEd25519Certificate()))));\n+        ed448ki = kifac.newKeyInfo(Collections.singletonList\n+                (kifac.newX509Data(List.of(getEd448Certificate()))));\n+\n@@ -547,0 +553,3 @@\n+        ed25519 = fac.newSignatureMethod(SignatureMethod.ED25519, null);\n+        ed448 = fac.newSignatureMethod(SignatureMethod.ED448, null);\n+\n@@ -858,0 +867,14 @@\n+    static void test_create_signature_enveloping_ed25519() throws Exception {\n+        System.out.println(\"* Generating signature-enveloping-ed25519.xml\");\n+        test_create_signature_enveloping(sha1, ed25519, ed25519ki,\n+                getEd25519PrivateKey(), x5ks, false, true);\n+        System.out.println();\n+    }\n+\n+    static void test_create_signature_enveloping_ed448() throws Exception {\n+        System.out.println(\"* Generating signature-enveloping-ed448.xml\");\n+        test_create_signature_enveloping(sha1, ed448, ed448ki,\n+                getEd448PrivateKey(), x5ks, false, true);\n+        System.out.println();\n+    }\n+\n@@ -1960,0 +1983,2 @@\n+                    } else if (sm.contains(\"#eddsa-\")) {\n+                        kpg = KeyPairGenerator.getInstance(sm.substring(sm.lastIndexOf('-') + 1));\n@@ -2088,0 +2113,14 @@\n+    private static final String ED25519_CERT =\n+            \"3081d730818aa003020102020822bc4997b1893265300506032b657030123110300e0603550403130745643235353139301e170d3233303431333033303732365a170d3433303430383033303\" +\n+            \"732365a30123110300e0603550403130745643235353139302a300506032b657003210012ecd7383ac90c30035dc531285bdb897faafddfc6969271c2ebd9a82b6078e5300506032b65700341\" +\n+            \"00a3cb7c03bbb3e9fa92eaf3f9a6f2608460d472c6a6ce3bebf0f57f45612e87ebdc6aa6d7527ae9e86c8e10bcccf98963f9b082c0bb44adb240c5fce9bb68b301\";\n+    private static final String ED25519_KEY =\n+            \"b59e57e352fa03b3a643946ae60b7f1e276f9ab41f25accaa63b660ba36168b2\";\n+    private static final String ED448_CERT =\n+            \"3082011f3081a0a003020102020900ceaefd75473d52b2300506032b65713010310e300c060355040313054564343438301e170d3233303431333033303735345a170d3433303430383033303\" +\n+            \"735345a3010310e300c0603550403130545643434383043300506032b6571033a00d605be958f21faf6a1181fa96ebe8580cca3cae9b48dfad5145ee999d9df4ef77c355d33ae8b21e9a3541f\" +\n+            \"b985ae366b9678db1a3fd1fd5c00300506032b65710373000b4dc8de20b261f5ca7cf41777725a2ec6cd107d6b75cd6ad02c00af8096ecf97c7445596aabd70381ce087d2b3b280ca4181566b\" +\n+            \"9230fd6801e22e53f1514989bc5b06cfb5f7cac222ea9a37a0771a3f7cfcbfd1ba9546bbe333d37ee81c3a53d86247d377225114e1e81123f947a391800\";\n+    private static final String ED448_KEY =\n+            \"50b72f081f7f2f3383c4b03975cf49a76ba8b17dec51eaea3cd267b6989b81786e8dd8af4df305eaad60bdd24345b8490548c371d62e926f80\";\n+\n@@ -2161,0 +2200,10 @@\n+    private static X509Certificate getEd25519Certificate() throws Exception {\n+        return (X509Certificate) CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificate(new ByteArrayInputStream(HexFormat.of().parseHex(ED25519_CERT)));\n+    }\n+\n+    private static X509Certificate getEd448Certificate() throws Exception {\n+        return (X509Certificate) CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificate(new ByteArrayInputStream(HexFormat.of().parseHex(ED448_CERT)));\n+    }\n+\n@@ -2214,0 +2263,10 @@\n+    private static PrivateKey getEd25519PrivateKey() throws Exception {\n+        return KeyFactory.getInstance(\"Ed25519\").generatePrivate(new EdECPrivateKeySpec(\n+                NamedParameterSpec.ED25519, HexFormat.of().parseHex(ED25519_KEY)));\n+    }\n+\n+    private static PrivateKey getEd448PrivateKey() throws Exception {\n+        return KeyFactory.getInstance(\"Ed448\").generatePrivate(new EdECPrivateKeySpec(\n+                NamedParameterSpec.ED448, HexFormat.of().parseHex(ED448_KEY)));\n+    }\n+\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":83,"deletions":24,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8305972\n+ * @summary Demonstrate here() support for validating XML Signatures\n+ * @modules java.base\/sun.security.util\n+ *          java.base\/sun.security.x509\n+ *          java.xml.crypto\/org.jcp.xml.dsig.internal.dom\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file KeySelectors.java SignatureValidator.java\n+ *     X509KeySelector.java ValidationTests.java\n+ * @run main\/othervm HereFunction default true\n+ * @run main\/othervm HereFunction true true\n+ * @run main\/othervm HereFunction false false\n+ *\/\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.security.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.xml.crypto.Data;\n+import javax.xml.crypto.KeySelector;\n+import javax.xml.crypto.OctetStreamData;\n+import javax.xml.crypto.URIDereferencer;\n+import javax.xml.crypto.URIReference;\n+import javax.xml.crypto.URIReferenceException;\n+import javax.xml.crypto.XMLCryptoContext;\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.dom.DOMSignContext;\n+import javax.xml.crypto.dsig.dom.DOMValidateContext;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfo;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;\n+import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathFilterParameterSpec;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SecurityUtils;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NodeList;\n+\n+public class HereFunction {\n+\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private final static String DATA_DIR =\n+            DIR + System.getProperty(\"file.separator\") + \"data\";\n+    private final static String KEYSTORE_VERIFY =\n+            DATA_DIR + System.getProperty(\"file.separator\") + \"certs\" +\n+                    System.getProperty(\"file.separator\") + \"xmldsig.jks\";\n+    private final static String KEYSTORE_SIGN =\n+            DATA_DIR + System.getProperty(\"file.separator\") + \"certs\" +\n+                    System.getProperty(\"file.separator\") + \"test.jks\";\n+    private final static String STYLESHEET =\n+            \"http:\/\/www.w3.org\/TR\/xml-stylesheet\";\n+    private final static String STYLESHEET_B64 =\n+            \"http:\/\/www.w3.org\/Signature\/2002\/04\/xml-stylesheet.b64\";\n+    private final static char[] PASS = \"changeit\".toCharArray();\n+\n+    public static void main(String args[]) throws Throwable {\n+        if (!args[0].equals(\"default\")) {\n+            Security.setProperty(\"jdk.xml.dsig.hereFunctionSupported\", args[0]);\n+        }\n+        \/\/ Re-enable sha1 algs\n+        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\");\n+\n+        boolean expected = Boolean.parseBoolean(args[1]);\n+\n+        sign(expected);\n+\n+        \/\/ Validating an old signature signed by JDK < 21\n+        validate(expected);\n+    }\n+\n+    static void validate(boolean expected) throws Exception {\n+        SignatureValidator validator = new SignatureValidator(new File(DATA_DIR));\n+\n+        KeyStore keystore = KeyStore.getInstance(new File(KEYSTORE_VERIFY), PASS);\n+        KeySelector ks = new X509KeySelector(keystore, false);\n+\n+        if (expected) {\n+            Asserts.assertTrue(validator.validate(\n+                    \"signature.xml\", ks, new HttpURIDereferencer(), false));\n+        } else {\n+            Utils.runAndCheckException(() -> validator.validate(\n+                    \"signature.xml\", ks, new HttpURIDereferencer(), false),\n+                    XMLSignatureException.class);\n+        }\n+    }\n+\n+    static void sign(boolean expected) throws Exception {\n+        XMLSignatureFactory fac = XMLSignatureFactory.getInstance();\n+        DigestMethod sha1 = fac.newDigestMethod(DigestMethod.SHA1, null);\n+        CanonicalizationMethod withoutComments = fac.newCanonicalizationMethod\n+                (CanonicalizationMethod.INCLUSIVE, (C14NMethodParameterSpec)null);\n+        SignatureMethod dsaSha1 = fac.newSignatureMethod(SignatureMethod.DSA_SHA1, null);\n+        KeyInfoFactory kifac = fac.getKeyInfoFactory();\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        dbf.setNamespaceAware(true);\n+\n+        String ENVELOPE =\n+                DATA_DIR + System.getProperty(\"file.separator\") + \"envelope.xml\";\n+\n+        var ks = KeyStore.getInstance(new File(KEYSTORE_SIGN), PASS);\n+        var signingKey = ks.getKey(\"user\", PASS);\n+        var signingCert = ks.getCertificate(\"user\");\n+\n+        \/\/ create references\n+        List<Reference> refs = new ArrayList<>();\n+\n+        \/\/ Reference 1\n+        refs.add(fac.newReference(STYLESHEET, sha1));\n+\n+        \/\/ Reference 2\n+        String expr = \"\\n\"\n+                + \" ancestor-or-self::dsig:SignedInfo                  \" + \"\\n\"\n+                + \"  and                                               \" + \"\\n\"\n+                + \" count(ancestor-or-self::dsig:Reference |           \" + \"\\n\"\n+                + \"      here()\/ancestor::dsig:Reference[1]) >         \" + \"\\n\"\n+                + \" count(ancestor-or-self::dsig:Reference)            \" + \"\\n\"\n+                + \"  or                                                \" + \"\\n\"\n+                + \" count(ancestor-or-self::node() |                   \" + \"\\n\"\n+                + \"      id('notaries')) =                             \" + \"\\n\"\n+                + \" count(ancestor-or-self::node())                    \" + \"\\n\";\n+\n+        XPathFilterParameterSpec xfp = new XPathFilterParameterSpec(expr,\n+                Collections.singletonMap(\"dsig\", XMLSignature.XMLNS));\n+        refs.add(fac.newReference(\"\", sha1, Collections.singletonList\n+                        (fac.newTransform(Transform.XPATH, xfp)),\n+                XMLObject.TYPE, null));\n+\n+        \/\/ create SignedInfo\n+        SignedInfo si = fac.newSignedInfo(withoutComments, dsaSha1, refs);\n+\n+        \/\/ create keyinfo\n+        KeyInfo ki = kifac.newKeyInfo(List.of(\n+                kifac.newX509Data(List.of(signingCert))), null);\n+\n+        \/\/ create XMLSignature\n+        XMLSignature sig = fac.newXMLSignature(si, ki, null, \"signature\", null);\n+\n+        dbf.setValidating(false);\n+        Document envDoc = dbf.newDocumentBuilder()\n+                .parse(new FileInputStream(ENVELOPE));\n+        Element ys = (Element)\n+                envDoc.getElementsByTagName(\"YoursSincerely\").item(0);\n+\n+        DOMSignContext dsc = new DOMSignContext(signingKey, ys);\n+        dsc.setURIDereferencer(new HttpURIDereferencer());\n+\n+        if (expected) {\n+            sig.sign(dsc);\n+        } else {\n+            Utils.runAndCheckException(\n+                    () -> sig.sign(dsc), XMLSignatureException.class);\n+            return; \/\/ Signing fails, no need to validate\n+        }\n+\n+\/\/      StringWriter sw = new StringWriter();\n+\/\/        dumpDocument(envDoc, sw);\n+\n+        NodeList nl =\n+                envDoc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n+        if (nl.getLength() == 0) {\n+            throw new Exception(\"Couldn't find signature Element\");\n+        }\n+        Element sigElement = (Element) nl.item(0);\n+\n+        DOMValidateContext dvc = new DOMValidateContext\n+                (new X509KeySelector(ks), sigElement);\n+        dvc.setURIDereferencer(new HttpURIDereferencer());\n+        File f = new File(\n+                System.getProperty(\"dir.test.vector.baltimore\") +\n+                        System.getProperty(\"file.separator\") +\n+                        \"merlin-xmldsig-twenty-three\" +\n+                        System.getProperty(\"file.separator\"));\n+        dvc.setBaseURI(f.toURI().toString());\n+\n+        XMLSignature sig2 = fac.unmarshalXMLSignature(dvc);\n+\n+        if (sig.equals(sig2) == false) {\n+            throw new Exception\n+                    (\"Unmarshalled signature is not equal to generated signature\");\n+        }\n+        if (sig2.validate(dvc) == false) {\n+            throw new Exception(\"Validation of generated signature failed\");\n+        }\n+    }\n+\n+    \/**\n+     * This URIDereferencer returns locally cached copies of http content to\n+     * avoid test failures due to network glitches, etc.\n+     *\/\n+    private static class HttpURIDereferencer implements URIDereferencer {\n+        private final URIDereferencer defaultUd;\n+\n+        HttpURIDereferencer() {\n+            defaultUd = XMLSignatureFactory.getInstance().getURIDereferencer();\n+        }\n+\n+        public Data dereference(final URIReference ref, XMLCryptoContext ctx)\n+                throws URIReferenceException {\n+            String uri = ref.getURI();\n+            if (uri.equals(STYLESHEET) || uri.equals(STYLESHEET_B64)) {\n+                try {\n+                    FileInputStream fis = new FileInputStream(new File\n+                            (DATA_DIR, uri.substring(uri.lastIndexOf('\/'))));\n+                    return new OctetStreamData(fis,ref.getURI(),ref.getType());\n+                } catch (Exception e) { throw new URIReferenceException(e); }\n+            }\n+\n+            \/\/ fallback on builtin deref\n+            return defaultUd.dereference(ref, ctx);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/HereFunction.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ * @run main\/othervm SecureValidation\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/SecureValidation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -40,10 +41,0 @@\n-    @Test\n-    void testFindParams() {\n-        assertEquals(Util.findParams(\"(IIII)V\").cardinality(), 4);\n-        assertEquals(Util.findParams(\"([I[I[I[I)V\").cardinality(), 4);\n-        assertEquals(Util.findParams(\"(IJLFoo;IJ)V\").cardinality(), 5);\n-        assertEquals(Util.findParams(\"([[[[I)V\").cardinality(), 1);\n-        assertEquals(Util.findParams(\"([[[[LFoo;)V\").cardinality(), 1);\n-        assertEquals(Util.findParams(\"([I[LFoo;)V\").cardinality(), 2);\n-        assertEquals(Util.findParams(\"()V\").cardinality(), 0);\n-    }\n@@ -53,18 +44,22 @@\n-        assertEquals(Util.parameterSlots(\"(IIII)V\"), 4);\n-        assertEquals(Util.parameterSlots(\"([I[I[I[I)V\"), 4);\n-        assertEquals(Util.parameterSlots(\"(IJLFoo;IJ)V\"), 7);\n-        assertEquals(Util.parameterSlots(\"([[[[I)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"([[[[LFoo;)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"([I[LFoo;)V\"), 2);\n-        assertEquals(Util.parameterSlots(\"()V\"), 0);\n-        assertEquals(Util.parameterSlots(\"(I)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(S)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(C)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(B)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(Z)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(F)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(LFoo;)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(J)V\"), 2);\n-        assertEquals(Util.parameterSlots(\"(D)V\"), 2);\n-        assertEquals(Util.parameterSlots(\"([J)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"([D)V\"), 1);\n+        assertSlots(\"(IIII)V\", 4);\n+        assertSlots(\"([I[I[I[I)V\", 4);\n+        assertSlots(\"(IJLFoo;IJ)V\", 7);\n+        assertSlots(\"([[[[I)V\", 1);\n+        assertSlots(\"([[[[LFoo;)V\", 1);\n+        assertSlots(\"([I[LFoo;)V\", 2);\n+        assertSlots(\"()V\", 0);\n+        assertSlots(\"(I)V\", 1);\n+        assertSlots(\"(S)V\", 1);\n+        assertSlots(\"(C)V\", 1);\n+        assertSlots(\"(B)V\", 1);\n+        assertSlots(\"(Z)V\", 1);\n+        assertSlots(\"(F)V\", 1);\n+        assertSlots(\"(LFoo;)V\", 1);\n+        assertSlots(\"(J)V\", 2);\n+        assertSlots(\"(D)V\", 2);\n+        assertSlots(\"([J)V\", 1);\n+        assertSlots(\"([D)V\", 1);\n+    }\n+\n+    private void assertSlots(String methodDesc, int slots) {\n+        assertEquals(Util.parameterSlots(MethodTypeDesc.ofDescriptor(methodDesc)), slots);\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import static jdk.internal.util.Architecture.ARM;\n@@ -70,0 +71,1 @@\n+            case \"arm\" -> ARM;\n@@ -87,0 +89,1 @@\n+                Arguments.of(ARM, Architecture.isARM()),\n","filename":"test\/jdk\/jdk\/internal\/util\/ArchTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308010\n+ * @summary X509Key and PKCS8Key allows garbage bytes at the end\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.security.KeyFactory;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+public class LongPKCS8orX509KeySpec {\n+\n+    public static void main(String[] argv) throws Exception {\n+        var g = KeyPairGenerator.getInstance(\"EC\");\n+        var f = KeyFactory.getInstance(\"EC\");\n+        Utils.runAndCheckException(() -> f.generatePublic(new X509EncodedKeySpec(\n+                Arrays.copyOf(g.generateKeyPair().getPublic().getEncoded(), 1000))),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> f.generatePrivate(new PKCS8EncodedKeySpec(\n+                Arrays.copyOf(g.generateKeyPair().getPrivate().getEncoded(), 1000))),\n+                InvalidKeySpecException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/LongPKCS8orX509KeySpec.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8213362 8238225\n+ * @bug 8213362 8238225 8303669\n","filename":"test\/jdk\/tools\/launcher\/JliLaunchTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-main(int argc, char **argv)\n+main(int argc, char **args)\n@@ -38,1 +38,7 @@\n-    return JLI_Launch(argc, argv,\n+    \/\/avoid null-terminated array of arguments to test JDK-8303669\n+    char **argv = malloc(sizeof(char *) * argc);\n+    for (int i = 0; i < argc; i++) {\n+        argv[i] = args[i];\n+    }\n+\n+    int ret = JLI_Launch(argc, argv,\n@@ -44,0 +50,2 @@\n+    free(argv);\n+    return ret;\n","filename":"test\/jdk\/tools\/launcher\/exeJliLaunchTest.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -102,4 +102,1 @@\n-                    })\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\")\n-                .withOption(String.valueOf(Runtime.version().feature()));\n+                    });\n","filename":"test\/langtools\/tools\/javac\/ConditionalExpressionResolvePending.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile\/fail\/ref=T8286797.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW T8286797.java\n+ * @compile\/fail\/ref=T8286797.out -XDrawDiagnostics -XDshould-stop.at=FLOW T8286797.java\n","filename":"test\/langtools\/tools\/javac\/T8286797.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-- compiler.note.preview.filename: T8286797.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/T8286797.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 8290379\n- * @summary Parse error with parenthesized pattern and guard using an array\n- * @enablePreview\n- *\/\n-public class T8290379 {\n-    public static void main(String... args) {\n-        assertEquals(0, test(\"test\"));\n-        assertEquals(1, test(Integer.valueOf(42)));\n-    }\n-\n-    public static int test(Object o)\n-    {\n-        int[] arr = {0, 1};\n-\n-        return switch (o) {\n-            case (String s) when (arr[0] == 0) -> 0;\n-            case (Integer i) when arr[1] == 1 -> 1;\n-            default -> 2;\n-        };\n-    }\n-\n-    static void assertEquals(int expected, int actual) {\n-        if (expected != actual) {\n-            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/T8290379.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile\/fail\/ref=T8295447.out -XDrawDiagnostics --enable-preview -source ${jdk.version} T8295447.java\n+ * @compile\/fail\/ref=T8295447.out -XDrawDiagnostics T8295447.java\n","filename":"test\/langtools\/tools\/javac\/T8295447.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-- compiler.note.preview.filename: T8295447.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/T8295447.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8297602\n- * @summary Compiler crash with type annotation and generic record during pattern matching\n- * @enablePreview\n- * @compile --enable-preview -source ${jdk.version} -XDrawDiagnostics T8297602.java\n- *\/\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-\n-public class T8297602\n-{\n-    void meth(Foo<Integer> p) {\n-        switch(p) {\n-            case Foo<@Annot(field = \"\") Integer>(): {}\n-        };\n-\n-        if (p instanceof Foo<@Annot(field = \"\") Integer>()) {\n-\n-        }\n-    }\n-\n-    @Target({ElementType.TYPE_USE})\n-    @interface Annot {\n-        String field();\n-    }\n-\n-    record Foo<T>() { }\n-}\n","filename":"test\/langtools\/tools\/javac\/T8297602.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -0,0 +1,22 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile\/ref=TwrLintUnderscore.out --enable-preview -source ${jdk.version} -Xlint:try -XDrawDiagnostics TwrLintUnderscore.java\n+ *\/\n+class TwrLintUnderscore implements AutoCloseable {\n+    private static void test1() {\n+        try(TwrLintUnderscore _ = new TwrLintUnderscore()) {\n+            \/\/ _ cannot be referenced so no lint warning for an unused resource should be emitted\n+        }\n+    }\n+\n+    \/**\n+     * The AutoCloseable method of a resource.\n+     *\/\n+    @Override\n+    public void close () {\n+        return;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrLintUnderscore.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+- compiler.note.preview.filename: TwrLintUnderscore.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrLintUnderscore.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-            \":t\",\n+            \"<error>:t\",\n@@ -162,1 +162,1 @@\n-            \":t\",\n+            \"<error>:t\",\n@@ -172,1 +172,1 @@\n-            \":t\",\n+            \"<error>:t\",\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                     List.of(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\")),\n+                     List.of(),\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/RuleSwitchBreaks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+compiler.warn.preview.feature.use                       # preview feature support: not generated currently\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.cannot.assign.not.declared.guard\n+\n+class CannotAssignNotDeclaredGuard {\n+    void test(Object i) {\n+        final boolean b;\n+        switch (i) {\n+            case Object o when b = true -> {}\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CannotAssignNotDeclaredGuard.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefNonEffectivelyFinalVar.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\/\/ key: compiler.err.feature.not.supported.in.source\n@@ -25,2 +26,1 @@\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\/\/ options: -source 20 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CaseNull.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ConstantLabelNotCompatible.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DeconstructionPatternOnlyRecords.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultLabelNotAllowed.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DuplicateUnconditionalPattern.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\/\/ options: --release 20\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumLabelUnqualified.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.feature.not.supported.in.source.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: -source 20 -Xlint:-options\n+\n+class FeatureDeconstructionPatterns {\n+    Object o;\n+    boolean b = o instanceof R(String s);\n+\n+    record R(Object o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureDeconstructionPatterns.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,0 +24,1 @@\n+\/\/ key:  compiler.err.feature.not.supported.in.source.plural\n@@ -25,4 +26,1 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:-options,preview\n-\n-import java.util.*;\n+\/\/ options: -source 20 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureUnconditionalPatternsInInstanceof.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughFromPattern.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,5 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.misc.feature.case.null\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughToPattern.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.err.foreach.not.exhaustive.on.type\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-import java.util.List;\n-\n-class ForeachNotExhaustive {\n-    void m(List<Object> points) {\n-        for (Point(var x, var y): points) {\n-            System.out.println();\n-        }\n-    }\n-\n-    record Point(Integer x, Integer y) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ForeachNotExhaustive.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/GuardHasConstantFalse.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.guard.not.allowed\n+\n+class GuardNotAllowed {\n+    private void doSwitch(int i, boolean b) {\n+        switch (i) {\n+            case 0 when b -> {}\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/GuardNotAllowed.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IncorrectNumberOfNestedPatterns.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.instanceof.pattern.no.subtype\n-\n-class InstanceofPatternNoSubtype {\n-    boolean test(Object o) {\n-        return o instanceof Object obj;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InstanceofPatternNoSubtype.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.case.null\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidCaseLabelCombination.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview --source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotApplicableTypes.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview --source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternDominated.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternExpected.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\/\/ key: compiler.err.feature.not.supported.in.source.plural\n@@ -25,2 +26,1 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\/\/ options: -source 20 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternSwitch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternTypeCannotInfer.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.record.patterns.annotations.not.allowed\n+\n+class RecordPatternsAnnotationsNotAllowed {\n+\n+    public boolean test(Object o) {\n+        return o instanceof @Deprecated R(String s);\n+    }\n+\n+    record R(String s) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordPatternsAnnotationsNotAllowed.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnconditionalPatternAndDefault.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,4 @@\n-\/\/ key: compiler.err.underscore.as.identifier.in.lambda\n+\/\/ key: compiler.misc.feature.unnamed.variables\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreInLambdaExpression.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.use.of.underscore.not.allowed\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+import java.util.function.*;\n+\n+class UseOfUnderscoreNotAllowed {\n+    IntBinaryOperator f = (int x, int y) -> _ + x;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UseOfUnderscoreNotAllowed.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=EnumSwitch2.out -XDrawDiagnostics EnumSwitch2.java\n+ * @compile\/fail\/ref=EnumSwitch2.out -XDrawDiagnostics --release 20 EnumSwitch2.java\n","filename":"test\/langtools\/tools\/javac\/enum\/EnumSwitch2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+ * @compile\/fail\/ref=IdentifierTest21.out -source ${jdk.version} --enable-preview -XDrawDiagnostics IdentifierTest.java\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+IdentifierTest.java:42:11: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:45:16: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:47:22: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:52:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:52:23: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:54:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:56:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:64:67: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:71:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:72:14: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:73:18: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:80:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:80:15: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:82:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:82:15: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:89:10: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:89:38: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:95:14: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:102:17: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:102:26: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:119:20: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:124:10: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:129:17: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:132:17: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:139:24: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:139:33: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:140:39: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:145:15: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:146:13: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:151:15: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:152:17: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:160:25: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:169:5: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:173:26: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:175:19: compiler.err.use.of.underscore.not.allowed\n+IdentifierTest.java:181:11: compiler.err.use.of.underscore.not.allowed\n+- compiler.note.preview.filename: IdentifierTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+36 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest21.out","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,44 +1,44 @@\n-IdentifierTest.java:41:11: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:44:16: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:45:20: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:46:22: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:51:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:51:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:51:23: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:53:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:55:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:61:21: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:62:42: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:63:67: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:70:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:71:14: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:72:18: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:77:22: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:79:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:79:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:81:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:81:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:88:10: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:88:38: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:94:14: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:101:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:101:26: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:118:20: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:123:10: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:128:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:131:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:138:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:138:24: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:138:33: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:139:39: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:143:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:144:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:145:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:150:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:151:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:157:16: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:159:25: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:168:5: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:172:26: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:174:19: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:180:11: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:42:11: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:45:16: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:46:20: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:47:22: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:52:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:52:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:52:23: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:54:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:56:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:62:21: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:63:42: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:64:67: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:71:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:72:14: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:73:18: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:78:22: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:80:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:80:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:82:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:82:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:89:10: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:89:38: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:95:14: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:102:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:102:26: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:119:20: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:124:10: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:129:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:132:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:139:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:139:24: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:139:33: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:140:39: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:144:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:145:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:146:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:151:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:152:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:158:16: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:160:25: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:169:5: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:173:26: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:175:19: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:181:11: compiler.warn.underscore.as.identifier\n@@ -47,1 +47,1 @@\n-44 warnings\n+44 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest8.out","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,45 +1,38 @@\n-IdentifierTest.java:41:11: compiler.err.underscore.as.identifier\n-IdentifierTest.java:44:16: compiler.err.underscore.as.identifier\n-IdentifierTest.java:45:20: compiler.err.underscore.as.identifier\n-IdentifierTest.java:46:22: compiler.err.underscore.as.identifier\n-IdentifierTest.java:51:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:51:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:51:23: compiler.err.underscore.as.identifier\n-IdentifierTest.java:53:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:55:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:61:21: compiler.err.underscore.as.identifier\n-IdentifierTest.java:62:42: compiler.err.underscore.as.identifier\n-IdentifierTest.java:63:67: compiler.err.underscore.as.identifier\n-IdentifierTest.java:70:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:71:14: compiler.err.underscore.as.identifier\n-IdentifierTest.java:72:18: compiler.err.underscore.as.identifier\n-IdentifierTest.java:77:22: compiler.err.underscore.as.identifier\n-IdentifierTest.java:79:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:79:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:81:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:81:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:88:10: compiler.err.underscore.as.identifier\n-IdentifierTest.java:88:38: compiler.err.underscore.as.identifier\n-IdentifierTest.java:94:14: compiler.err.underscore.as.identifier\n-IdentifierTest.java:101:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:101:26: compiler.err.underscore.as.identifier\n-IdentifierTest.java:118:20: compiler.err.underscore.as.identifier\n-IdentifierTest.java:123:10: compiler.err.underscore.as.identifier\n-IdentifierTest.java:128:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:131:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:138:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:138:24: compiler.err.underscore.as.identifier\n-IdentifierTest.java:138:33: compiler.err.underscore.as.identifier\n-IdentifierTest.java:139:39: compiler.err.underscore.as.identifier\n-IdentifierTest.java:143:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:144:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:145:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:150:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:151:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:157:16: compiler.err.underscore.as.identifier\n-IdentifierTest.java:159:25: compiler.err.underscore.as.identifier\n-IdentifierTest.java:168:5: compiler.err.underscore.as.identifier\n-IdentifierTest.java:172:26: compiler.err.underscore.as.identifier\n-IdentifierTest.java:174:19: compiler.err.underscore.as.identifier\n-IdentifierTest.java:180:11: compiler.err.underscore.as.identifier\n-44 errors\n+IdentifierTest.java:42:11: compiler.err.underscore.as.identifier\n+IdentifierTest.java:45:16: compiler.err.underscore.as.identifier\n+IdentifierTest.java:46:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.variables)\n+IdentifierTest.java:47:22: compiler.err.underscore.as.identifier\n+IdentifierTest.java:52:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:52:23: compiler.err.underscore.as.identifier\n+IdentifierTest.java:54:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:56:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:64:67: compiler.err.underscore.as.identifier\n+IdentifierTest.java:71:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:72:14: compiler.err.underscore.as.identifier\n+IdentifierTest.java:73:18: compiler.err.underscore.as.identifier\n+IdentifierTest.java:80:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:80:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:82:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:82:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:89:10: compiler.err.underscore.as.identifier\n+IdentifierTest.java:89:38: compiler.err.underscore.as.identifier\n+IdentifierTest.java:95:14: compiler.err.underscore.as.identifier\n+IdentifierTest.java:102:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:102:26: compiler.err.underscore.as.identifier\n+IdentifierTest.java:119:20: compiler.err.underscore.as.identifier\n+IdentifierTest.java:124:10: compiler.err.underscore.as.identifier\n+IdentifierTest.java:129:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:132:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:139:24: compiler.err.underscore.as.identifier\n+IdentifierTest.java:139:33: compiler.err.underscore.as.identifier\n+IdentifierTest.java:140:39: compiler.err.underscore.as.identifier\n+IdentifierTest.java:145:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:146:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:151:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:152:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:160:25: compiler.err.underscore.as.identifier\n+IdentifierTest.java:169:5: compiler.err.underscore.as.identifier\n+IdentifierTest.java:173:26: compiler.err.underscore.as.identifier\n+IdentifierTest.java:175:19: compiler.err.underscore.as.identifier\n+IdentifierTest.java:181:11: compiler.err.underscore.as.identifier\n+37 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest9.out","additions":38,"deletions":45,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @compile\/fail\/ref=UnderscoreAsIdent21.out -source ${jdk.version} --enable-preview -XDrawDiagnostics UnderscoreAsIdent.java\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,17 @@\n+UnderscoreAsIdent.java:8:9: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:8:11: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:10:8: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:10:10: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:12:7: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:13:12: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:14:10: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:14:19: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:19:25: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:19:33: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:25:9: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:27:19: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:29:9: compiler.err.use.of.underscore.not.allowed\n+UnderscoreAsIdent.java:31:22: compiler.err.use.of.underscore.not.allowed\n+- compiler.note.preview.filename: UnderscoreAsIdent.java, DEFAULT\n+- compiler.note.preview.recompile\n+14 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent21.out","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -1,17 +1,17 @@\n-UnderscoreAsIdent.java:7:9: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:7:11: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:9:8: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:9:10: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:11:7: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:12:12: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:13:10: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:13:19: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:15:16: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:18:18: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:18:25: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:18:33: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:21:34: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:24:9: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:26:19: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:28:9: compiler.warn.underscore.as.identifier\n-UnderscoreAsIdent.java:30:22: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:8:9: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:8:11: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:10:8: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:10:10: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:12:7: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:13:12: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:14:10: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:14:19: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:16:16: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:19:18: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:19:25: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:19:33: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:22:34: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:25:9: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:27:19: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:29:9: compiler.warn.underscore.as.identifier\n+UnderscoreAsIdent.java:31:22: compiler.warn.underscore.as.identifier\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent8.out","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,18 +1,16 @@\n-UnderscoreAsIdent.java:7:9: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:7:11: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:9:8: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:9:10: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:11:7: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:12:12: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:13:10: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:13:19: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:15:16: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:18:18: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:18:25: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:18:33: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:21:34: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:24:9: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:26:19: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:28:9: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:30:22: compiler.err.underscore.as.identifier\n-17 errors\n+UnderscoreAsIdent.java:8:9: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:8:11: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:10:8: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:10:10: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:12:7: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:13:12: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:14:10: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:14:19: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:16:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.variables)\n+UnderscoreAsIdent.java:19:25: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:19:33: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:25:9: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:27:19: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:29:9: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:31:22: compiler.err.underscore.as.identifier\n+15 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent9.out","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-            printTree(\"var\", tree.varOrRecordPattern);\n+            printTree(\"var\", tree.var);\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2345,0 +2345,53 @@\n+    @Test\n+    void testGuardRecovery() throws IOException {\n+        String code = \"\"\"\n+                      package t;\n+                      class Test {\n+                          private int t(Integer i, boolean b) {\n+                              switch (i) {\n+                                  case 0 when b -> {}\n+                                  case null when b -> {}\n+                                  default when b -> {}\n+                              }\n+                              return switch (i) {\n+                                  case 0 when b -> 0;\n+                                  case null when b -> 0;\n+                                  default when b -> 0;\n+                              };\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        new TreeScanner<Void, Void>() {\n+            @Override\n+            public Void visitCase(CaseTree node, Void p) {\n+                assertNotNull(node.getGuard());\n+                assertEquals(\"guard kind\", Kind.ERRONEOUS, node.getGuard().getKind());\n+                assertEquals(\"guard content\",\n+                             List.of(\"b\"),\n+                             ((ErroneousTree) node.getGuard()).getErrorTrees()\n+                                                              .stream()\n+                                                              .map(t -> t.toString()).toList());\n+                return super.visitCase(node, p);\n+            }\n+        }.scan(cut, null);\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" +  d.getCode());\n+        }\n+\n+        assertEquals(\"testUsupportedTextBlock: \" + codes,\n+                List.of(\"5:20:compiler.err.guard.not.allowed\",\n+                        \"6:23:compiler.err.guard.not.allowed\",\n+                        \"7:21:compiler.err.guard.not.allowed\",\n+                        \"10:20:compiler.err.guard.not.allowed\",\n+                        \"11:23:compiler.err.guard.not.allowed\",\n+                        \"12:21:compiler.err.guard.not.allowed\"),\n+                codes);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8300543\n+ * @summary Verify error related to annotations and patterns\n+ * @compile\/fail\/ref=AnnotationErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW AnnotationErrors.java\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+public class AnnotationErrors {\n+\n+    private void test(Object o, G<String> g) {\n+        boolean b1 = o instanceof @DA R(var s);\n+        boolean b2 = o instanceof @DTA R(var s);\n+        boolean b3 = o instanceof @TA R(var s);\n+        boolean b5 = g instanceof G<@DTA String>(var s);\n+        boolean b6 = g instanceof G<@TA String>(var s);\n+        switch (o) {\n+            case @DA R(var s) when b1 -> {}\n+            case @DTA R(var s) when b1 -> {}\n+            case @TA R(var s) when b1 -> {}\n+            default -> {}\n+        }\n+        switch (g) {\n+            case G<@DTA String>(var s) when b1 -> {}\n+            case G<@TA String>(var s) when b1 -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    record R(String s) {}\n+    record G<T>(T t) {}\n+\n+    @Target(ElementType.LOCAL_VARIABLE)\n+    @interface DA {}\n+    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n+    @interface DTA {}\n+    @Target(ElementType.TYPE_USE)\n+    @interface TA {}\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/AnnotationErrors.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+AnnotationErrors.java:14:35: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:15:35: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:16:35: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:17:37: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:18:37: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:20:18: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:21:18: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:22:18: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:26:20: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:27:20: compiler.err.record.patterns.annotations.not.allowed\n+10 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/AnnotationErrors.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-        boolean hasDefault = Arrays.stream(caseLabels).anyMatch(l -> l == CaseLabel.DEFAULT || l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN);\n+        boolean hasDefault = Arrays.stream(caseLabels).anyMatch(l -> l == CaseLabel.DEFAULT || l == CaseLabel.TYPE_PATTERN);\n@@ -91,3 +91,1 @@\n-                .withSourceFromTemplate(MAIN_TEMPLATE.replace(\"#{CASES}\", labels).replace(\"#{DEFAULT}\", hasDefault ? \"\" : \"default: break;\"))\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\").withOption(JAVA_VERSION);\n+                .withSourceFromTemplate(MAIN_TEMPLATE.replace(\"#{CASES}\", labels).replace(\"#{DEFAULT}\", hasDefault ? \"\" : \"default: break;\"));\n@@ -97,1 +95,1 @@\n-            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n+            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN).count();\n@@ -139,1 +137,0 @@\n-        PARENTHESIZED_PATTERN(\"(Integer i)\"),\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} DeconstructionDesugaring.java\n- * @run main\/othervm --enable-preview DeconstructionDesugaring\n+ * @compile DeconstructionDesugaring.java\n+ * @run main DeconstructionDesugaring\n@@ -82,1 +82,1 @@\n-            case (((R1((((R2((((String s))))))))))) -> { return 1; }\n+            case R1(R2(String s)) -> { return 1; }\n@@ -96,1 +96,1 @@\n-            case (((R1((((R2((((String s))))))))))) -> 1;\n+            case R1(R2(String s)) -> 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionDesugaring.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @enablePreview\n@@ -7,0 +6,1 @@\n+\n@@ -15,1 +15,0 @@\n-        if (p instanceof P(_));\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,11 +1,10 @@\n-DeconstructionPatternErrors.java:15:28: compiler.err.underscore.as.identifier\n-DeconstructionPatternErrors.java:15:29: compiler.err.expected: token.identifier\n-DeconstructionPatternErrors.java:43:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:45:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:47:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:47:43: compiler.err.not.stmt\n-DeconstructionPatternErrors.java:16:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n-DeconstructionPatternErrors.java:17:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n-DeconstructionPatternErrors.java:18:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-DeconstructionPatternErrors.java:19:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n-DeconstructionPatternErrors.java:20:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:42:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:44:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:46:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:46:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:15:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n+DeconstructionPatternErrors.java:16:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n+DeconstructionPatternErrors.java:17:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+DeconstructionPatternErrors.java:18:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n+DeconstructionPatternErrors.java:19:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:20:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n@@ -13,20 +12,16 @@\n-DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n-DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n-DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n-DeconstructionPatternErrors.java:25:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n-DeconstructionPatternErrors.java:25:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n-DeconstructionPatternErrors.java:26:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:27:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:28:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-DeconstructionPatternErrors.java:28:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:29:40: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n-DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:32:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:35:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:44:9: compiler.err.not.exhaustive.statement\n-- compiler.note.preview.filename: DeconstructionPatternErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-29 errors\n+DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n+DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n+DeconstructionPatternErrors.java:24:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n+DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n+DeconstructionPatternErrors.java:25:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:26:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:27:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+DeconstructionPatternErrors.java:27:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:28:40: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:29:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n+DeconstructionPatternErrors.java:29:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n+DeconstructionPatternErrors.java:30:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+DeconstructionPatternErrors.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+26 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @enablePreview\n@@ -38,1 +37,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -41,2 +39,0 @@\n-import com.sun.source.tree.PatternTree;\n-import com.sun.source.tree.StatementTree;\n@@ -44,1 +40,0 @@\n-import com.sun.source.tree.Tree.Kind;\n@@ -50,1 +45,0 @@\n-import com.sun.tools.javac.util.Log;\n@@ -52,2 +46,0 @@\n-import java.net.URI;\n-import java.net.URISyntaxException;\n@@ -55,7 +47,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n@@ -71,1 +56,1 @@\n-        test.disambiguationTest(\"(String s)\",\n+        test.disambiguationTest(\"String s\",\n@@ -73,1 +58,1 @@\n-        test.disambiguationTest(\"(@Ann String s)\",\n+        test.disambiguationTest(\"@Ann String s\",\n@@ -75,1 +60,1 @@\n-        test.disambiguationTest(\"((String s))\",\n+        test.disambiguationTest(\"String s\",\n@@ -95,1 +80,1 @@\n-        test.disambiguationTest(\"(a < c.d > b)\",\n+        test.disambiguationTest(\"a < c.d > b\",\n@@ -127,21 +112,0 @@\n-        test.forDisambiguationTest(\"T[] a\", ForType.ENHANCED_FOR);\n-        test.forDisambiguationTest(\"T[].class.getName()\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"T[].class\", ForType.TRADITIONAL_FOR, \"compiler.err.not.stmt\");\n-        test.forDisambiguationTest(\"R(T[] a)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-\n-        test.forDisambiguationTest(\"Point(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"ForEachPatterns.Point(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<Integer>(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"@Annot(field = \\\"test\\\") Point p\", ForType.ENHANCED_FOR);\n-        test.forDisambiguationTest(\"GPoint<Point>(Point(Integer a, Integer b), Point c)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<Point>(Point(var a, Integer b), Point c)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<VoidPoint>(VoidPoint(), VoidPoint())\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"RecordOfLists(List<Integer> lr)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"RecordOfLists2(List<List<Integer>> lr)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<@Annot(field = \\\"\\\") ? extends Point>(var x, var y)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-\n-        test.forDisambiguationTest(\"method()\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"method(), method()\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"method2((Integer a) -> 42)\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"m(cond ? b() : i)\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"m((GPoint<?>)null, cond ? b() : i)\", ForType.TRADITIONAL_FOR);\n@@ -151,1 +115,0 @@\n-    private final List<String> errors = new ArrayList<>();\n@@ -153,1 +116,1 @@\n-    public DisambiguatePatterns() throws URISyntaxException {\n+    public DisambiguatePatterns() {\n@@ -155,5 +118,0 @@\n-        context.put(DiagnosticListener.class, d -> {\n-            if (d.getKind() == Diagnostic.Kind.ERROR) {\n-                errors.add(d.getCode());\n-            }\n-        });\n@@ -162,3 +120,0 @@\n-        SimpleJavaFileObject source =\n-                new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {};\n-        Log.instance(context).useSource(source);\n@@ -195,52 +150,0 @@\n-    void forDisambiguationTest(String snippet, ForType forType, String... expectedErrors) {\n-        errors.clear();\n-\n-        String codeTemplate = switch (forType) {\n-            case TRADITIONAL_FOR ->\n-                \"\"\"\n-                public class Test {\n-                    private void test() {\n-                        for (SNIPPET; ;) {\n-                        }\n-                    }\n-                }\n-                \"\"\";\n-            case ENHANCED_FOR, ENHANCED_FOR_WITH_PATTERNS ->\n-                \"\"\"\n-                public class Test {\n-                    private void test() {\n-                        for (SNIPPET : collection) {\n-                        }\n-                    }\n-                }\n-                \"\"\";\n-        };\n-\n-        String code = codeTemplate.replace(\"SNIPPET\", snippet);\n-        JavacParser parser = factory.newParser(code, false, false, false);\n-        CompilationUnitTree result = parser.parseCompilationUnit();\n-        if (!Arrays.asList(expectedErrors).equals(errors)) {\n-            throw new AssertionError(\"Expected errors: \" + Arrays.asList(expectedErrors) +\n-                                     \", actual: \" + errors +\n-                                     \", for: \" + code);\n-        }\n-        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n-        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n-        StatementTree st = method.getBody().getStatements().get(0);\n-        if (forType == ForType.TRADITIONAL_FOR) {\n-            if (st.getKind() != Kind.FOR_LOOP) {\n-                throw new AssertionError(\"Unpected statement: \" + st);\n-            }\n-        } else {\n-            EnhancedForLoopTree ef = (EnhancedForLoopTree) st;\n-            ForType actualType = switch (ef.getVariableOrRecordPattern()) {\n-                case PatternTree pattern -> ForType.ENHANCED_FOR_WITH_PATTERNS;\n-                default -> ForType.ENHANCED_FOR;\n-            };\n-            if (forType != actualType) {\n-                throw new AssertionError(\"Expected: \" + forType + \", actual: \" + actualType +\n-                                          \", for: \" + code + \", parsed: \" + result);\n-            }\n-        }\n-    }\n-\n@@ -252,5 +155,0 @@\n-    enum ForType {\n-        TRADITIONAL_FOR,\n-        ENHANCED_FOR,\n-        ENHANCED_FOR_WITH_PATTERNS;\n-    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":5,"deletions":107,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -31,0 +30,1 @@\n+\n@@ -183,2 +183,2 @@\n-            case ((R r)): return 1;\n-            case ((R(int a))): return -1;\n+            case R r: return 1;\n+            case R(int a): return -1;\n@@ -192,2 +192,2 @@\n-            case ((R(int a))): return 1;\n-            case ((R(int a))): return -1;\n+            case R(int a): return 1;\n+            case R(int a): return -1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -19,2 +19,0 @@\n-- compiler.note.preview.filename: Domination.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/EmptyRecordClass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile EnumTypeChangesNonPreview.java\n+ * @compile --release 20 EnumTypeChangesNonPreview.java\n@@ -31,1 +31,0 @@\n- * @run main\/othervm --enable-preview EnumTypeChangesNonPreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChangesNonPreview.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n@@ -41,0 +44,2 @@\n+import java.util.Set;\n+import java.util.stream.Collectors;\n@@ -42,1 +47,0 @@\n-import toolbox.TestRunner;\n@@ -45,0 +49,1 @@\n+import toolbox.TestRunner;\n@@ -49,2 +54,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -122,2 +125,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -184,2 +185,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -217,2 +216,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -281,2 +278,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -410,2 +405,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -416,30 +409,1 @@\n-    public void testExhaustiveStatement3(Path base) throws Exception {\n-        doTest(base,\n-               new String[]{\"\"\"\n-                            package lib;\n-                            public sealed interface S permits A, B {}\n-                            \"\"\",\n-                            \"\"\"\n-                            package lib;\n-                            public final class A implements S {}\n-                            \"\"\",\n-                            \"\"\"\n-                            package lib;\n-                            public final class B implements S {}\n-                            \"\"\"},\n-               \"\"\"\n-               package test;\n-               import lib.*;\n-               public class Test {\n-                   private int test(S obj) {\n-                       return switch (obj) {\n-                           case A a -> 0;\n-                           case S s -> 1;\n-                       };\n-                   }\n-               }\n-               \"\"\");\n-    }\n-\n-    @Test\n-    public void testExhaustiveStatement4(Path base) throws Exception {\n+    public void testExhaustiveExpression1(Path base) throws Exception {\n@@ -471,2 +435,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -477,1 +439,1 @@\n-    public void testExhaustiveStatement5(Path base) throws Exception {\n+    public void testExhaustiveExpression2(Path base) throws Exception {\n@@ -581,2 +543,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -587,1 +547,66 @@\n-    public void testExhaustiveIntersection(Path base) throws Exception {\n+    public void testIntersection(Path base) throws Exception {\n+        record TestCase(String snippet, String... expected){}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                         return switch (obj) {\n+                             case A a -> 0;\n+                             case C c when b -> 0;\n+                             case C c -> 0;\n+                             case D d -> 0;\n+                         };\n+                         \"\"\"),\n+            new TestCase(\"\"\"\n+                         return switch (obj) {\n+                             case A a -> 0;\n+                             case C c -> 0;\n+                             case D d when b -> 0;\n+                         };\n+                         \"\"\",\n+                         \"Test.java:5:16: compiler.err.not.exhaustive\",\n+                         \"1 error\")\n+        };\n+        for (TestCase tc : testCases) {\n+            doTest(base,\n+                   new String[]{\"\"\"\n+                                package lib;\n+                                public sealed interface S permits A, B {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public abstract class Base {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public interface Marker {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public final class A extends Base implements S, Marker {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public abstract sealed class B extends Base implements S permits C, D {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public final class C extends B implements Marker {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public final class D extends B implements Marker {}\n+                                \"\"\"},\n+                   \"\"\"\n+                   package test;\n+                   import lib.*;\n+                   public class Test {\n+                       private <T extends Base & S & Marker> int test(T obj, boolean b) {\n+                           ${tc.snippet()}\n+                       }\n+                   }\n+                   \"\"\".replace(\"${tc.snippet()}\", tc.snippet()),\n+                   tc.expected());\n+        }\n+    }\n+\n+    @Test\n+    public void testRecordPatterns(Path base) throws Exception {\n@@ -595,1 +620,1 @@\n-                            public abstract class Base {}\n+                            public final class A implements S {}\n@@ -599,1 +624,1 @@\n-                            public interface Marker {}\n+                            public final class B implements S {}\n@@ -603,1 +628,20 @@\n-                            public final class A extends Base implements S, Marker {}\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B b) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n@@ -607,1 +651,1 @@\n-                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            public final class A implements S {}\n@@ -611,1 +655,1 @@\n-                            public final class C extends B implements Marker {}\n+                            public record B(Object o) implements S {}\n@@ -615,1 +659,1 @@\n-                            public final class D extends B implements Marker {}\n+                            public record R(S a, S b) {}\n@@ -621,6 +665,6 @@\n-                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n-                       return switch (obj) {\n-                           case A a -> 0;\n-                           case C c when b -> 0;\n-                           case C c -> 0;\n-                           case D d -> 0;\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B(String s)) -> 0;\n@@ -630,5 +674,3 @@\n-               \"\"\");\n-    }\n-\n-    @Test\n-    public void testNotExhaustiveIntersection(Path base) throws Exception {\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n@@ -642,1 +684,1 @@\n-                            public abstract class Base {}\n+                            public final class A implements S {}\n@@ -646,1 +688,1 @@\n-                            public interface Marker {}\n+                            public record B(Object o) implements S {}\n@@ -650,1 +692,20 @@\n-                            public final class A extends Base implements S, Marker {}\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B(var o)) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n@@ -654,1 +715,1 @@\n-                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            public final class A implements S {}\n@@ -658,1 +719,1 @@\n-                            public final class C extends B implements Marker {}\n+                            public record B(Object o) implements S {}\n@@ -662,1 +723,1 @@\n-                            public final class D extends B implements Marker {}\n+                            public record R(S a, S b) {}\n@@ -668,5 +729,6 @@\n-                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n-                       return switch (obj) {\n-                           case A a -> 0;\n-                           case C c -> 0;\n-                           case D d when b -> 0;\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B(String s), B b) -> 0;\n@@ -678,2 +740,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -681,4 +741,0 @@\n-    }\n-\n-    @Test\n-    public void testX(Path base) throws Exception {\n@@ -696,1 +752,1 @@\n-                            public final class B implements S {}\n+                            public record B(Object o) implements S {}\n@@ -711,1 +767,1 @@\n-                           case R(B a, B b) -> 0;\n+                           case R(B(Object o), B b) -> 0;\n@@ -741,0 +797,1 @@\n+                           case R(B(String s), B b) -> 0;\n@@ -742,1 +799,0 @@\n-                           case R(B a, B(String s)) -> 0;\n@@ -748,2 +804,18 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public record R(Object o1, Object o2) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(String s, Object o) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n@@ -762,1 +834,1 @@\n-                            public record B(Object o) implements S {}\n+                            public record B(S o) implements S {}\n@@ -766,1 +838,1 @@\n-                            public record R(S a, S b) {}\n+                            public record R(S a, String s, S b) {}\n@@ -774,4 +846,38 @@\n-                           case R(A a, A b) -> 0;\n-                           case R(A a, B b) -> 0;\n-                           case R(B a, A b) -> 0;\n-                           case R(B a, B(var o)) -> 0;\n+                           case R(A a, String s, A b) -> 0;\n+                           case R(A a, String s, B b) -> 0;\n+                           case R(B a, String s, A b) -> 0;\n+                           case R(B(A o), String s, B b) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record B(S o) implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S a, String s, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, String s, A b) -> 0;\n+                           case R(A a, String s, B b) -> 0;\n+                           case R(B a, String s, A b) -> 0;\n+                           case R(B(A o), String s, B b) -> 0;\n+                           case R(B(B o), String s, B b) -> 0;\n@@ -783,0 +889,1 @@\n+\n@@ -820,2 +927,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -828,2 +933,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -836,2 +939,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -846,2 +947,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -856,2 +955,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -866,2 +963,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -965,2 +1060,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1033,2 +1126,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1055,2 +1146,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1109,2 +1198,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1129,2 +1216,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1148,2 +1233,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1168,2 +1251,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1196,1 +1277,679 @@\n-    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+    @Test\n+    public void testEnumExhaustiveness(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface Opt {}\n+                   enum A implements Opt { A, B, C; }\n+                   enum B implements Opt { B, C, D; }\n+\n+                   void test(Opt optValue) {\n+                       switch (optValue) {\n+                           case A.A, A.B -> {}\n+                           case A.C, B.C -> {}\n+                           case B.B, B.D -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    public void testNestedApplicable(Path base) throws Exception {\n+        record TestCase(String cases, String... errors) {}\n+        TestCase[] subCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\"), \/\/OK\n+            new TestCase(\"\"\"\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:12:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:12:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:12:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C1 c) -> {}\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:13:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C1)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C2<?> c) -> {}\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:13:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C2<?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C4<?, ?> c) -> {}\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:13:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C4<?,?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+        };\n+        for (TestCase tc : subCases) {\n+            doTest(base,\n+                   new String[0],\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       sealed interface I<T> {}\n+                       final class C1 implements I<String> {}\n+                       final class C2<T> implements I<String> {}\n+                       final class C3<T> implements I<T> {}\n+                       final class C4<T, E> implements I<String> {}\n+                       final class C5<T, E> implements I<T> {}\n+                       final class C6<T, E> implements I<E> {}\n+                       record R<T>(I<T> i) {}\n+                       void t(R<Integer> i) {\n+                           switch (i) {\n+                   ${cases}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"${cases}\", tc.cases),\n+                   tc.errors);\n+        }\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I permits I1, I2, I3 {}\n+                   sealed interface I1 extends I permits C1 {}\n+                   sealed interface I2 extends I {}\n+                   sealed interface I3 extends I {}\n+                   final class C1 implements I1, I2 {}\n+                   final class C2 implements I3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                           case I3 i3 ->\n+                               System.out.println(\"I3\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I permits I1, I2, I3 {}\n+                   sealed interface I1 extends I permits C1 {}\n+                   sealed interface I2 extends I {}\n+                   sealed interface I3 extends I {}\n+                   sealed abstract class C1 implements I1 {}\n+                   final class C2 extends C1 implements I2 {}\n+                   final class C3 extends C1 implements I3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                           case I3 i3 ->\n+                               System.out.println(\"I3\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface I1 extends I {}\n+                   final class I2 implements I1 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I1 i1 ->\n+                               System.out.println(\"I1\");\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:11:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I permits I1, I2, I3 {}\n+                   sealed interface I1 extends I permits C1 {}\n+                   sealed class I2 implements I {}\n+                   sealed interface I3 extends I {}\n+                   final class C1 extends I2 implements I1 {}\n+                   final class C2 implements I3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                           case I3 i3 ->\n+                               System.out.println(\"I3\");\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Test {\n+                   sealed interface I permits A, B, C { }\n+                   interface I3 { }\n+                   sealed interface I2 extends I3 permits B, C { }\n+                   final class A implements I {}\n+                   final class B implements I, I2 {}\n+                   final class C implements I, I2 {}\n+\n+                   int m(I i) {\n+                       return switch (i) {\n+                           case A a -> 1;\n+                           case I3 e -> 2;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Test {\n+                   sealed interface I0 permits I1, I2 { }\n+                   sealed interface I00 permits I1, I2 { }\n+\n+                   sealed interface I1 extends I0, I00 permits B, C { }\n+                   sealed interface I2 extends I0, I00 permits B, C { }\n+\n+                   static final class B implements I1, I2 { }\n+                   static final class C implements I1, I2 { }\n+\n+                   int test(Object o) {\n+                       return switch (o) {\n+                           case B c -> 2;\n+                           case C d -> 3;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:12:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n+    private static final int NESTING_CONSTANT = 5;\n+\n+    Set<String> createDeeplyNestedVariants() {\n+        Set<String> variants = new HashSet<>();\n+        variants.add(\"C _\");\n+        variants.add(\"R(I _, I _, I _)\");\n+        for (int n = 0; n < NESTING_CONSTANT; n++) {\n+            Set<String> newVariants = new HashSet<>();\n+            for (String variant : variants) {\n+                if (variant.contains(\", I _\")) {\n+                    newVariants.add(variant.replaceFirst(\", I _\", \", C _\"));\n+                    newVariants.add(variant.replaceFirst(\", I _\", \", R(I _, I _, I _)\"));\n+                } else {\n+                    newVariants.add(variant);\n+                }\n+            }\n+            variants = newVariants;\n+        }\n+        for (int n = 0; n < NESTING_CONSTANT; n++) {\n+            Set<String> newVariants = new HashSet<>();\n+            for (String variant : variants) {\n+                if (variant.contains(\"I _\")) {\n+                    newVariants.add(variant.replaceFirst(\"I _\", \"C _\"));\n+                    newVariants.add(variant.replaceFirst(\"I _\", \"R(I _, I _, I _)\"));\n+                } else {\n+                    newVariants.add(variant);\n+                }\n+            }\n+            variants = newVariants;\n+        }\n+        OUTER: for (int i = 0; i < NESTING_CONSTANT; i++) {\n+            Iterator<String> it = variants.iterator();\n+            while (it.hasNext()) {\n+                String current = it.next();\n+                if (current.contains(\"(I _, I _, I _)\")) {\n+                    it.remove();\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(C _, I _, C _)\"));\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(C _, I _, R _)\"));\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(R _, I _, C _)\"));\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(R _, I _, R _)\"));\n+                    continue OUTER;\n+                }\n+            }\n+        }\n+\n+        return variants;\n+    }\n+\n+    String testCodeForVariants(Iterable<String> variants) {\n+        StringBuilder cases = new StringBuilder();\n+\n+        for (String variant : variants) {\n+            cases.append(\"case \");\n+            String[] parts = variant.split(\"_\");\n+            for (int i = 0; i < parts.length; i++) {\n+                cases.append(parts[i]);\n+                if (i + 1 < parts.length || i == 0) {\n+                    cases.append(\"v\" + i);\n+                }\n+            }\n+            cases.append(\" -> System.err.println();\\n\");\n+        }\n+        String code = \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   final class C implements I {}\n+                   record R(I c1, I c2, I c3) implements I {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           ${cases}\n+                       }\n+                   }\n+               }\n+               \"\"\".replace(\"${cases}\", cases);\n+\n+        return code;\n+    }\n+\n+    @Test\n+    public void testDeeplyNestedExhaustive(Path base) throws Exception {\n+        Set<String> variants = createDeeplyNestedVariants();\n+        String code = testCodeForVariants(variants);\n+\n+        System.err.println(\"analyzing:\");\n+        System.err.println(code);\n+        doTest(base,\n+               new String[0],\n+               code,\n+               true);\n+    }\n+\n+    @Test\n+    public void testDeeplyNestedNotExhaustive(Path base) throws Exception {\n+        List<String> variants = createDeeplyNestedVariants().stream().collect(Collectors.toCollection(ArrayList::new));\n+        variants.remove((int) (Math.random() * variants.size()));\n+        String code = testCodeForVariants(variants);\n+\n+        System.err.println(\"analyzing:\");\n+        System.err.println(code);\n+        doTest(base,\n+               new String[0],\n+               code,\n+               new String[] {null});\n+    }\n+\n+    @Test\n+    public void testMultipleSealed(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I1 {}\n+                   sealed interface I2 {}\n+                   final class A_I1 implements I1 {}\n+                   final class B_I2 implements I2 {}\n+                   final class C_I1_I2 implements I1, I2 {}\n+\n+                   <Z extends I1&I2> void test(Z z) {\n+                       switch (z) {\n+                           case C_I1_I2 c ->\n+                               System.out.println(\"C_I1_I2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testOverfitting(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   final class A implements I {}\n+                   final class B implements I {}\n+                   record R(String s, I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(CharSequence s, A a) ->\n+                               System.out.println(\"A\");\n+                           case R(Object o, B b) ->\n+                               System.out.println(\"B\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed abstract class A {}\n+                   final class C extends A implements I {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C c ->\n+                               System.out.println(\"C\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed abstract class A {}\n+                   final class C extends A implements I {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C c) ->\n+                               System.out.println(\"C\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2 c ->\n+                               System.out.println(\"C2\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2 c ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C1 c) ->\n+                               System.out.println(\"C1\");\n+                           case R(C2 c) ->\n+                               System.out.println(\"C2\");\n+                           case R(C12 c) ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C12 c) ->\n+                               System.out.println(\"C12\");\n+                           case R(C1 c) ->\n+                               System.out.println(\"C1\");\n+                           case R(C2 c) ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   sealed interface S3 extends I {}\n+                   final class C13 implements S1, S3 {}\n+                   final class C23 implements S2, S3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C13 c ->\n+                               System.out.println(\"C13\");\n+                           case C23 c ->\n+                               System.out.println(\"C23\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+        doTest(base, libraryCode, testCode, false, expectedErrors);\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, boolean stopAtFlow, String... expectedErrors) throws IOException {\n@@ -1210,2 +1969,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -1226,3 +1983,1 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n+                    .options(\"-XDrawDiagnostics\",\n@@ -1231,1 +1986,3 @@\n-                             \"-XDshould-stop.at=FLOW\")\n+                             \"-XDshould-stop.at=FLOW\",\n+                             stopAtFlow ? \"-XDshould-stop.ifNoError=FLOW\"\n+                                        : \"-XDnoop\")\n@@ -1237,1 +1994,1 @@\n-        if (expectedErrors.length > 0 && !List.of(expectedErrors).equals(log)) {\n+        if (expectedErrors.length > 0 && expectedErrors[0] != null && !List.of(expectedErrors).equals(log)) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":885,"deletions":128,"binary":false,"changes":1013,"status":"modified"},{"patch":"@@ -1,254 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary\n- * @enablePreview\n- *\/\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.function.Function;\n-\n-public class ForEachPatterns {\n-    public static void main(String[] args) {\n-\n-        List<Point>             in                   = List.of(new Point(1, 2), new Point(2, 3));\n-        List<IPoint>            in_iface             = List.of(new Point(1, 2), new Point(2, 3));\n-        List                    inRaw                = List.of(new Point(1, 2), new Point(2, 3), new Frog(3, 4));\n-        List<PointEx>           inWithPointEx        = List.of(new PointEx(1, 2));\n-        byte[]                  inBytes              = { (byte) 127, (byte) 127 };\n-        List<Point>             inWithNullComponent  = List.of(new Point(1, null), new Point(2, 3));\n-        Point[]                 inArray              = in.toArray(Point[]::new);\n-        List<WithPrimitives>    inWithPrimitives     = List.of(new WithPrimitives(1, 2), new WithPrimitives(2, 3));\n-        IParent                 recs []              = { new Rec(1) };\n-        List<Point>             inWithNull           = new ArrayList<>();\n-        {\n-            inWithNull.add(new Point(2, 3));\n-            inWithNull.add(null);\n-        }\n-\n-        assertEquals(8, iteratorEnhancedFor(in));\n-        assertEquals(8, arrayEnhancedFor(inArray));\n-        assertEquals(8, simpleDecostructionPatternWithAccesses(in));\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, null, NullPointerException.class);\n-        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNull, NullPointerException.class);\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNullComponent, NullPointerException.class);\n-        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternException, inWithPointEx, TestPatternFailed.class);\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, (List<Point>) inRaw, ClassCastException.class);\n-        assertEquals(2, simpleDecostructionPatternNoComponentAccess(in));\n-        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternNoComponentAccess, inWithNull, NullPointerException.class);\n-        assertEquals(2, simpleDecostructionPatternNoComponentAccess(inWithNullComponent));\n-        assertEquals(8, varAndConcrete(in));\n-        assertEquals(3, returnFromEnhancedFor(in));\n-        assertEquals(0, breakFromEnhancedFor(in));\n-        assertEquals(254, primitiveWidening(inBytes));\n-        assertEquals(8, sealedRecordPassBaseType(in_iface));\n-        assertEquals(8, withPrimitives(inWithPrimitives));\n-        assertEquals(List.of(Color.RED), JEPExample());\n-        assertEquals(1, arrayWithSealed(recs));\n-    }\n-\n-    static int iteratorEnhancedFor(List<Point> points) {\n-        int result = 0;\n-        for (Point(Integer a, Integer b) : points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int arrayEnhancedFor(Point[] points) {\n-        int result = 0;\n-        for (Point(Integer a, Integer b) : points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int simpleDecostructionPatternWithAccesses(List<Point> points) {\n-        int result = 0;\n-        for (Point(var a, var b): points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int simpleDecostructionPatternException(List<PointEx> points) {\n-        int result = 0;\n-        for (PointEx(var a, var b): points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int simpleDecostructionPatternNoComponentAccess(List<Point> points) {\n-        int result = 0;\n-        for (Point(var a, var b): points) {\n-            result += 1;\n-        }\n-        return result;\n-    }\n-\n-    static int varAndConcrete(List<Point> points) {\n-        int result = 0;\n-        for (Point(Integer a, var b): points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int returnFromEnhancedFor(List<Point> points) {\n-        for (Point(var a, var b): points) {\n-            return a + b;\n-        }\n-        return -1;\n-    }\n-\n-    static int breakFromEnhancedFor(List<Point> points) {\n-        int i = 1;\n-        int result = 0;\n-        for (Point(var a, var b): points) {\n-            if (i == 1) break;\n-            else result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int sealedRecordPassBaseType(List<IPoint> points) {\n-        int result = 0;\n-\n-        for(Point(var x, var y) : points) {\n-            result += (x + y);\n-        }\n-\n-        return result;\n-    }\n-\n-    static int withPrimitives(List<WithPrimitives> points) {\n-        int result = 0;\n-        for (WithPrimitives(int a, double b): points) {\n-            result += a + (int) b;\n-        }\n-        return result;\n-    }\n-\n-    \/\/ Simpler pos tests with local variable declarations\n-    \/\/ Should pass now and in the future if local variable\n-    \/\/ declaration is subsumed by patterns (not just record patterns)\n-    static int primitiveWidening(byte[] inBytes) {\n-        int acc = 0;\n-        for (int i: inBytes) {\n-            acc += i;\n-        }\n-        return acc;\n-    }\n-\n-    static int applicability1(List<Point> points) {\n-        for (IPoint p: points) {\n-            System.out.println(p);\n-        }\n-        return -1;\n-    }\n-\n-    static int applicability2(List<Object> points) {\n-        for (Object p: points) {\n-            System.out.println(p);\n-        }\n-        return -1;\n-    }\n-\n-    static List<Color> JEPExample() {\n-        Rectangle rect = new Rectangle(\n-                new ColoredPoint(new Point(1,2), Color.RED),\n-                new ColoredPoint(new Point(3,4), Color.GREEN)\n-        );\n-        Rectangle[] rArr = {rect};\n-        return printUpperLeftColors(rArr);\n-    }\n-    \/\/where\n-    static List<Color> printUpperLeftColors(Rectangle[] r) {\n-        List<Color> ret = new ArrayList<>();\n-        for (Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr): r) {\n-            ret.add(c);\n-        }\n-        return ret;\n-    }\n-\n-    static int arrayWithSealed(IParent[] recs){\n-        for (Rec(int a) : recs) {\n-            return a;\n-        }\n-        return -1;\n-    }\n-\n-    enum Color { RED, GREEN, BLUE }\n-    record ColoredPoint(Point p, Color c) {}\n-    record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}\n-\n-    sealed interface IParent permits Rec {}\n-    record Rec(int a) implements IParent {}\n-\n-    sealed interface IPoint permits Point {}\n-    record Point(Integer x, Integer y) implements IPoint { }\n-\n-    record GPoint<T>(T x, T y) { }\n-    record VoidPoint() { }\n-    record RecordOfLists(List<Integer> o) {}\n-    record RecordOfLists2(List<List<Integer>> o) {}\n-\n-    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n-    @interface Annot {\n-        String field();\n-    }\n-    record Frog(Integer x, Integer y) { }\n-    record PointEx(Integer x, Integer y) {\n-        @Override\n-        public Integer x() {\n-            throw new TestPatternFailed(EXCEPTION_MESSAGE);\n-        }\n-    }\n-    record WithPrimitives(int x, double y) { }\n-    static final String EXCEPTION_MESSAGE = \"exception-message\";\n-    public static class TestPatternFailed extends AssertionError {\n-        public TestPatternFailed(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    \/\/ error handling\n-    static void fail(String message) {\n-        throw new AssertionError(message);\n-    }\n-\n-    static void assertEquals(Object expected, Object actual) {\n-        if (!Objects.equals(expected, actual)) {\n-            throw new AssertionError(\"Expected: \" + expected + \",\" +\n-                    \"got: \" + actual);\n-        }\n-    }\n-\n-    static <T> void assertMatchExceptionWithNested(Function<List<T>, Integer> f, List<T> points, Class<?> nestedExceptionClass) {\n-        try {\n-            f.apply(points);\n-            fail(\"Expected an exception, but none happened!\");\n-        }\n-        catch(Exception ex) {\n-            assertEquals(MatchException.class, ex.getClass());\n-\n-            MatchException me = (MatchException) ex;\n-\n-            assertEquals(nestedExceptionClass, me.getCause().getClass());\n-        }\n-    }\n-\n-    static <T> void assertEx(Function<List<T>, Integer> f, List<T> points, Class<?> exceptionClass) {\n-        try {\n-            f.apply(points);\n-            fail(\"Expected an exception, but none happened!\");\n-        }\n-        catch(Exception ex) {\n-            assertEquals(exceptionClass, ex.getClass());\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatterns.java","additions":0,"deletions":254,"binary":false,"changes":254,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary\n- * @enablePreview\n- * @compile\/fail\/ref=ForEachPatternsErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW ForEachPatternsErrors.java\n- *\/\n-\n-import java.util.List;\n-\n-public class ForEachPatternsErrors {\n-\n-    static void exhaustivity_error1(List<Object> points) {\n-        for (Point(var x, var y): points) {\n-            System.out.println();\n-        }\n-    }\n-\n-    static void exhaustivity_error2(List points) {\n-        for (Point(var x, var y): points) {\n-            System.out.println();\n-        }\n-    }\n-\n-    static void exhaustivity_error3(List<OPoint> opoints) {\n-        for (OPoint(String s, String t) : opoints) {\n-            System.out.println(s);\n-        }\n-    }\n-\n-    static void exhaustivity_error4(List<?> f) {\n-        for (Rec(var x): f){\n-        }\n-    }\n-\n-    static void applicability_error(List<Object> points) {\n-        for (Interface p: points) {\n-            System.out.println(p);\n-        }\n-    }\n-\n-    record  Rec(String x) { }\n-    interface Interface {}\n-    sealed interface IPoint permits Point {}\n-    record Point(Integer x, Integer y) implements IPoint { }\n-    record OPoint(Object x, Object y) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-ForEachPatternsErrors.java:36:27: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, ForEachPatternsErrors.Interface)\n-ForEachPatternsErrors.java:13:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n-ForEachPatternsErrors.java:19:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n-ForEachPatternsErrors.java:25:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.OPoint, ForEachPatternsErrors.OPoint\n-ForEachPatternsErrors.java:31:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Rec, compiler.misc.type.captureof: 1, ?\n-- compiler.note.preview.filename: ForEachPatternsErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary\n- * @enablePreview\n- * @compile -XDfind=all ForEachTestAllAnalyzers.java\n- *\/\n-public class ForEachTestAllAnalyzers {\n-    private void test(Iterable<? extends R> l) {\n-        for (R(Object a) : l) { }\n-    }\n-    record R(Object a) {}\n-}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachTestAllAnalyzers.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -50,2 +49,0 @@\n-        assertEquals(0, forEachInference(List.of(new Box(\"\"))));\n-        assertEquals(1, forEachInference(List.of(new Box(null))));\n@@ -109,7 +106,0 @@\n-    int forEachInference(Iterable<I<String>> b) {\n-        for (Box(var s) : b) {\n-            return s == null ? 1 : s.length();\n-        }\n-        return -1;\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -137,2 +136,2 @@\n-            case (Integer i) when i == 0: o = String.valueOf(i); return \"true\";\n-            case (Integer i) when i == 2: o = String.valueOf(i); return \"second\";\n+            case Integer i when i == 0: o = String.valueOf(i); return \"true\";\n+            case Integer i when i == 2: o = String.valueOf(i); return \"second\";\n@@ -145,2 +144,2 @@\n-            case (Integer i) when i == 0: o = String.valueOf(i); yield \"true\";\n-            case (Integer i) when i == 2: o = String.valueOf(i); yield \"second\";\n+            case Integer i when i == 0: o = String.valueOf(i); yield \"true\";\n+            case Integer i when i == 2: o = String.valueOf(i); yield \"second\";\n@@ -152,1 +151,1 @@\n-        if (o != null && o instanceof (Integer i) && i == 0) {\n+        if (o != null && o instanceof Integer i && i == 0) {\n@@ -154,1 +153,1 @@\n-        } else if (o != null && o instanceof (Integer i) && i == 2 && (o = i) != null) {\n+        } else if (o != null && o instanceof Integer i && i == 2 && (o = i) != null) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -44,0 +43,31 @@\n+    void variablesInGuards(Object o) {\n+        final int i1;\n+              int i2 = 0;\n+        switch (o) {\n+            case Integer v when (i1 = 0) == 0 -> {}\n+            case Integer v when i2++ == 0 -> {}\n+            case Integer v when ++i2 == 0 -> {}\n+            case Integer v when new Predicate() {\n+                public boolean test() {\n+                    final int i;\n+                    i = 2;\n+                    return i == 2;\n+                }\n+            }.test() -> {}\n+            case Number v1 when v1 instanceof Integer v2 && (v2 = 0) == 0 -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    GuardsErrors(Object o) {\n+        switch (o) {\n+            case Integer v when (f = 0) == 0 -> {}\n+            default -> throw new RuntimeException();\n+        }\n+    }\n+\n+    final int f;\n+\n+    interface Predicate {\n+        public boolean test();\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,4 +1,6 @@\n-GuardsErrors.java:37:38: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n-- compiler.note.preview.filename: GuardsErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-1 error\n+GuardsErrors.java:36:38: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n+GuardsErrors.java:47:34: compiler.err.cannot.assign.not.declared.guard: i1\n+GuardsErrors.java:48:33: compiler.err.cant.ref.non.effectively.final.var: i2, (compiler.misc.guard)\n+GuardsErrors.java:49:35: compiler.err.cant.ref.non.effectively.final.var: i2, (compiler.misc.guard)\n+GuardsErrors.java:64:34: compiler.err.cannot.assign.not.declared.guard: f\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.out","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-InstanceofTotalPattern.java:18:37: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.pattern.matching.instanceof), 15, 16\n+InstanceofTotalPattern.java:19:37: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.pattern.matching.instanceof), 15, 16\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-15.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,3 +1,2 @@\n-InstanceofTotalPattern.java:18:19: compiler.err.instanceof.pattern.no.subtype: java.lang.String, java.lang.String\n-InstanceofTotalPattern.java:22:17: compiler.err.instanceof.pattern.no.subtype: java.lang.String, java.lang.String\n-2 errors\n+InstanceofTotalPattern.java:19:19: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 16, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-16.out","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+InstanceofTotalPattern.java:19:19: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-20.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-InstanceofTotalPattern.java:18:30: compiler.warn.preview.feature.use.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof)\n-InstanceofTotalPattern.java:22:28: compiler.warn.preview.feature.use.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof)\n-2 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-preview.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -6,2 +6,3 @@\n- * @compile\/ref=InstanceofTotalPattern-preview.out --enable-preview -source ${jdk.version} -Xlint:-options,preview -XDrawDiagnostics InstanceofTotalPattern.java\n- * @run main\/othervm --enable-preview InstanceofTotalPattern\n+ * @compile\/fail\/ref=InstanceofTotalPattern-20.out --release 20 -XDrawDiagnostics InstanceofTotalPattern.java\n+ * @compile InstanceofTotalPattern.java\n+ * @run main InstanceofTotalPattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/LambdaCannotCapturePatternVariables.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main\/othervm --enable-preview MatchExceptionTest\n+ * @run main MatchExceptionTest\n@@ -93,3 +93,2 @@\n-            new Setup(false, \"-source\", \"20\"),\n-            new Setup(false, \"-source\", JAVA_VERSION),\n-            new Setup(true, \"-source\", JAVA_VERSION, \"--enable-preview\"),\n+            new Setup(false, \"--release\", \"20\"),\n+            new Setup(true),\n@@ -97,1 +96,1 @@\n-        record Source(String source, boolean needsPreview) {}\n+        record Source(String source, boolean needs21) {}\n@@ -105,2 +104,2 @@\n-                if (source.needsPreview &&\n-                    !Arrays.asList(variant.options).contains(\"--enable-preview\")) {\n+                if (source.needs21 &&\n+                    !Arrays.asList(variant.options).contains(\"21\")) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchExceptionTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedDeconstructionPattern.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-                .options(\"--enable-preview\", \"-source\", JAVA_VERSION)\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPatternVariablesBytecode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPrimitiveDeconstructionPattern.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-                                            \"(String s)\",\n@@ -73,1 +72,0 @@\n-                                            \"(R(int i))\",\n@@ -330,1 +328,1 @@\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -347,2 +345,2 @@\n-                           case (Integer i) when i > 0 -> 0;\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -361,1 +359,1 @@\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -378,1 +376,1 @@\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -434,3 +432,1 @@\n-            .options(\"--enable-preview\",\n-                     \"-source\", JAVA_VERSION,\n-                     \"-XDrawDiagnostics\",\n+            .options(\"-XDrawDiagnostics\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/NewCaseStructureTest.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5,1 +5,5 @@\n- * @compile\/fail\/ref=NoSubtypeCheck.out -XDrawDiagnostics NoSubtypeCheck.java\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main NoSubtypeCheck\n@@ -7,11 +11,89 @@\n-public class NoSubtypeCheck {\n-\n-    public static void main(Object o, String s, List<String> l) {\n-        boolean b1 = o instanceof Object v1;\n-        boolean b2 = o instanceof String v2;\n-        boolean b3 = s instanceof Object v3;\n-        boolean b4 = s instanceof String v4;\n-        boolean b5 = l instanceof List<String> v5;\n-        boolean b6 = l instanceof List2<String> v6;\n-        boolean b7 = undef instanceof String v7;\n-        boolean b8 = o instanceof Undef v7;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class NoSubtypeCheck extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new NoSubtypeCheck().runTests();\n+    }\n+\n+    NoSubtypeCheck() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSimple(Path base) throws Exception {\n+        record TestCase(String test, String expectedError) {}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"boolean b1 = o instanceof Object v1;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b2 = o instanceof String v2;\", null),\n+            new TestCase(\"boolean b3 = s instanceof Object v3;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b4 = s instanceof String v4;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b5 = l instanceof List<String> v5;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b6 = l instanceof List2<String> v6;\", null),\n+            new TestCase(\"boolean b7 = undef instanceof String v7;\",\n+                         \"Test.java:3:22: compiler.err.cant.resolve.location: kindname.variable, undef, , , (compiler.misc.location: kindname.class, Test, null)\"),\n+            new TestCase(\"boolean b8 = o instanceof Undef v7;\",\n+                         \"Test.java:3:35: compiler.err.cant.resolve.location: kindname.class, Undef, , , (compiler.misc.location: kindname.class, Test, null)\"),\n+        };\n+\n+        for (TestCase testCase : testCases) {\n+            System.err.println(\"==running testcase: \" + testCase.test);\n+            Path current = base.resolve(\".\");\n+            Path src = current.resolve(\"src\");\n+\n+            tb.writeJavaFiles(src, \"\"\"\n+                                   public class Test {\n+                                       public static void main(Object o, String s, List<String> l) {\n+                                           {testCase.test}\n+                                       }\n+\n+                                       public interface List<T> {}\n+                                       public interface List2<T> extends List<T> {}\n+                                   }\n+                                   \"\"\".replace(\"{testCase.test}\", testCase.test));\n+\n+            Path classes = current.resolve(\"classes\");\n+\n+            Files.createDirectories(classes);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                         \"--release\", \"20\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(testCase.expectedError != null ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            if (testCase.expectedError != null) {\n+                List<String> expectedOutput = new ArrayList<>();\n+\n+                expectedOutput.add(testCase.expectedError);\n+                expectedOutput.add(\"1 error\");\n+\n+                if (!expectedOutput.equals(log)) {\n+                    throw new AssertionError(\"Unexpected output:\\n\" + log);\n+                }\n+            }\n+        }\n@@ -20,2 +102,0 @@\n-    public interface List<T> {}\n-    public interface List2<T> extends List<T> {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoSubtypeCheck.java","additions":94,"deletions":14,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=NullsInPatterns.out -XDrawDiagnostics NullsInPatterns.java\n+ * @run main NullsInPatterns\n@@ -11,1 +11,1 @@\n-    public static void meth() {\n+    public static void main(String... args) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @enablePreview\n+ * @compile\/fail\/ref=Parenthesized.out -XDrawDiagnostics Parenthesized.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+Parenthesized.java:38:18: compiler.err.illegal.start.of.type\n+Parenthesized.java:42:18: compiler.err.illegal.start.of.type\n+Parenthesized.java:45:26: compiler.err.illegal.start.of.type\n+Parenthesized.java:48:35: compiler.err.illegal.start.of.type\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import combo.ComboInstance;\n-import combo.ComboParameter;\n-import combo.ComboTask;\n-import combo.ComboTestHelper;\n-import toolbox.ToolBox;\n-\n-\/*\n- * @test\n- * @bug 8269674\n- * @summary Improve testing of parenthesized patterns\n- * @library \/tools\/lib \/tools\/javac\/lib\n- * @modules\n- *      jdk.compiler\/com.sun.tools.javac.api\n- *      jdk.compiler\/com.sun.tools.javac.file\n- *      jdk.compiler\/com.sun.tools.javac.main\n- *      jdk.compiler\/com.sun.tools.javac.util\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @build combo.ComboTestHelper\n- * @compile ParenthesizedCombo.java\n- * @run main\/othervm ParenthesizedCombo\n- *\/\n-public class ParenthesizedCombo extends ComboInstance<ParenthesizedCombo> {\n-    protected ToolBox tb;\n-\n-    ParenthesizedCombo() {\n-        super();\n-        tb = new ToolBox();\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        new ComboTestHelper<ParenthesizedCombo>()\n-                .withDimension(\"PATTERN_USE\", (x, patternUse) -> x.patternUse = patternUse, PATTERN_USE.values())\n-                .withDimension(\"CASE_LABEL\", (x, caseLabel) -> x.caseLabel = caseLabel, CASE_LABEL.values())\n-                .withDimension(\"TYPE_PATTERN\", (x, typePattern) -> x.typePattern = typePattern, TYPE_PATTERN.values())\n-                .run(ParenthesizedCombo::new);\n-    }\n-\n-    private PATTERN_USE patternUse;\n-    private CASE_LABEL caseLabel;\n-    private TYPE_PATTERN typePattern;\n-\n-    private static final String MAIN_TEMPLATE =\n-        \"\"\"\n-        public class Test {\n-            record StringBox(String s1) {}\n-            record StringBox2(StringBox s) {}\n-            public static void test(Object o) {\n-                #{PATTERN_USE}\n-            }\n-        }\n-        \"\"\";\n-\n-    @Override\n-    protected void doWork() throws Throwable {\n-        ComboTask task = newCompilationTask()\n-                .withSourceFromTemplate(MAIN_TEMPLATE, pname -> switch (pname) {\n-                    case \"PATTERN_USE\" -> patternUse;\n-                    case \"CASE_LABEL\" -> caseLabel;\n-                    case \"TYPE_PATTERN\" -> typePattern;\n-                    default -> throw new UnsupportedOperationException(pname);\n-                })\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\")\n-                .withOption(String.valueOf(Runtime.version().feature()));\n-        task.generate(result -> {\n-            if (result.hasErrors()) {\n-                throw new AssertionError(\"Unexpected result: \" + result.compilationInfo());\n-            }\n-        });\n-    }\n-\n-    public enum TYPE_PATTERN implements ComboParameter {\n-        SIMPLE(\"String s1\"),\n-        PARENTHESIZED_SIMPLE(\"(String s1)\");\n-\n-        private final String code;\n-\n-        private TYPE_PATTERN(String code) {\n-            this.code = code;\n-        }\n-\n-        @Override\n-        public String expand(String optParameter) {\n-            return code;\n-        }\n-    }\n-\n-    public enum CASE_LABEL implements ComboParameter {\n-        TYPE_PATTERN(\"#{TYPE_PATTERN}\"),\n-        PARENTHESIZED_RECORD_PATTERN(\"(StringBox(#{TYPE_PATTERN}))\"),\n-        PARENTHESIZED_RECORD_PATTERN_DEEP(\"(StringBox2(StringBox(#{TYPE_PATTERN})))\");\n-\n-        private final String code;\n-\n-        private CASE_LABEL(String code) {\n-            this.code = code;\n-        }\n-\n-        @Override\n-        public String expand(String optParameter) {\n-            return code;\n-        }\n-    }\n-\n-    public enum PATTERN_USE implements ComboParameter {\n-        SWITCH_EXPR_VOID(\n-            \"\"\"\n-            switch (o) {\n-                case #{CASE_LABEL} when s1.isEmpty() -> System.err.println(\"OK: \" + s1);\n-                    default -> throw new AssertionError();\n-            }\n-            \"\"\"),\n-        SWITCH_STAT_VOID(\n-            \"\"\"\n-            switch (o) {\n-                case #{CASE_LABEL} when s1.isEmpty():\n-                    System.err.println(\"OK: \" + s1);\n-                    break;\n-                default:\n-                    throw new AssertionError();\n-            }\n-            \"\"\"),\n-        SWITCH_EXPR_STRING(\n-            \"\"\"\n-            System.err.println(switch (o) {\n-                case #{CASE_LABEL} when s1.isEmpty() -> \"OK: \" + s1;\n-                    default -> throw new AssertionError();\n-            });\n-            \"\"\"),\n-        IF_INSTANCEOF(\n-            \"\"\"\n-            if (o instanceof #{CASE_LABEL} && s1.isEmpty()) {\n-                System.err.println(\"OK: \" + s1);\n-            }\n-            \"\"\");\n-        private final String body;\n-\n-        private PATTERN_USE(String body) {\n-            this.body = body;\n-        }\n-\n-        @Override\n-        public String expand(String optParameter) {\n-            return body;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ParenthesizedCombo.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n@@ -8,0 +7,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternCaseErrorRecovery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -59,2 +58,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -168,2 +165,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -184,3 +179,1 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n+                    .options(\"-XDrawDiagnostics\",\n@@ -264,2 +257,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -280,3 +271,1 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n+                    .options(\"-XDrawDiagnostics\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternDesugaring.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-PatternErrorRecovery.java:12:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n-PatternErrorRecovery.java:11:18: compiler.err.const.expr.req\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery-no-preview.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+PatternErrorRecovery.java:12:18: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 20, 21\n+PatternErrorRecovery.java:11:18: compiler.err.const.expr.req\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery-old.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=PatternErrorRecovery.out -XDrawDiagnostics -XDshould-stop.at=FLOW --enable-preview -source ${jdk.version} PatternErrorRecovery.java\n- * @compile\/fail\/ref=PatternErrorRecovery-no-preview.out -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n+ * @compile\/fail\/ref=PatternErrorRecovery.out -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n+ * @compile\/fail\/ref=PatternErrorRecovery-old.out --release 20 -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.preview.filename: PatternErrorRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @enablePreview\n@@ -52,0 +52,1 @@\n+                      \"         boolean _ = true;\\n\" +\n@@ -57,0 +58,3 @@\n+                      \"         b = o instanceof R(String _);\\n\" +\n+                      \"         b = o instanceof R2(R(var _), var _);\\n\" +\n+                      \"         b = o instanceof R2(R(_), var t);\\n\" +\n@@ -63,21 +67,25 @@\n-                          \\n\\\n-                          class Test {\n-                              \\n\\\n-                              boolean t(Object o) {\n-                                  boolean b;\n-                                  b = o instanceof String s;\n-                                  b = o instanceof R(String s);\n-                                  b = o instanceof R(\/*missing*\/ s);\n-                                  b = o instanceof R2(R(\/*missing*\/ s), String t);\n-                                  b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n-                              }\n-                              \\n\\\n-                              class R {\n-                                  private final String s;\n-                              }\n-                              \\n\\\n-                              class R2 {\n-                                  private final R r;\n-                                  private final String s;\n-                              }\n-                          }\"\"\";\n+                \\n\\\n+                class Test {\n+                    \\n\\\n+                    boolean t(Object o) {\n+                        boolean b;\n+                        boolean _ = true;\n+                        b = o instanceof String s;\n+                        b = o instanceof R(String s);\n+                        b = o instanceof R(\/*missing*\/ s);\n+                        b = o instanceof R2(R(\/*missing*\/ s), String t);\n+                        b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                        b = o instanceof R(String _);\n+                        b = o instanceof R2(R(\/*missing*\/ _), \/*missing*\/ _);\n+                        b = o instanceof R2(R(_), \/*missing*\/ t);\n+                    }\n+                    \\n\\\n+                    class R {\n+                        private final String s;\n+                    }\n+                    \\n\\\n+                    class R2 {\n+                        private final R r;\n+                        private final String s;\n+                    }\n+                }\"\"\";\n@@ -96,1 +104,1 @@\n-            List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+            List.of(), null,\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/ProxyMethodLookup.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n@@ -8,0 +7,1 @@\n+\n@@ -17,4 +17,0 @@\n-        switch (o) {\n-            case (RawTypeBindingWarning w) -> {}\n-            default -> {}\n-        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/RawTypeBindingWarning.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,5 +3,2 @@\n-RawTypeBindingWarning.java:18:19: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n-RawTypeBindingWarning.java:22:18: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n-- compiler.note.preview.filename: RawTypeBindingWarning.java, DEFAULT\n-- compiler.note.preview.recompile\n-4 warnings\n\\ No newline at end of file\n+RawTypeBindingWarning.java:18:18: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/RawTypeBindingWarning.out","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleAndGuardPattern.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,3 +3,3 @@\n- * @compile\/fail\/ref=SimpleDeconstructionPatternNoPreview.out -XDrawDiagnostics SimpleDeconstructionPattern.java\n- * @compile --enable-preview -source ${jdk.version} SimpleDeconstructionPattern.java\n- * @run main\/othervm --enable-preview SimpleDeconstructionPattern\n+ * @compile\/fail\/ref=SimpleDeconstructionPatternOld.out --release 20 -XDrawDiagnostics SimpleDeconstructionPattern.java\n+ * @compile SimpleDeconstructionPattern.java\n+ * @run main SimpleDeconstructionPattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-SimpleDeconstructionPattern.java:118:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -0,0 +1,2 @@\n+SimpleDeconstructionPattern.java:118:27: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.deconstruction.patterns), 20, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternOld.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -49,2 +49,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -79,1 +77,1 @@\n-               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:18: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -95,1 +93,1 @@\n-               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:4:26: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -112,1 +110,1 @@\n-               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:18: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -124,1 +122,1 @@\n-                           case default:\n+                           case null, default:\n@@ -129,1 +127,1 @@\n-               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -143,2 +141,1 @@\n-                    .options(\"-source\", \"11\",\n-                             \"-Xlint:-options\",\n+                    .options(\"--release\", \"17\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/SourceLevelChecks.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n@@ -8,0 +7,1 @@\n+\n@@ -192,1 +192,1 @@\n-    void test8269146a2(Integer i) {\n+    void test8269146a2a(Integer i) {\n@@ -195,1 +195,1 @@\n-            case Integer o when o != null, 1:\n+            case Integer o, 1:\n@@ -220,1 +220,1 @@\n-            case 1, Integer o when o != null, default:\n+            case 1, Integer o, default:\n@@ -224,1 +224,1 @@\n-    void test8269301b(Integer i) {\n+    void test8269301ba(Integer i) {\n@@ -227,1 +227,1 @@\n-            case Integer o when o != null, 1, default:\n+            case Integer o, 1, default:\n@@ -255,1 +255,1 @@\n-            case null, ((R r)): break;\n+            case null, R r: break;\n@@ -262,1 +262,1 @@\n-            case null, ((R(var v))): break;\n+            case null, R(var v): break;\n@@ -269,1 +269,1 @@\n-            case ((R r)): case null: break;\n+            case R r: case null: break;\n@@ -276,1 +276,1 @@\n-            case ((R(var v))): case null: break;\n+            case R(var v): case null: break;\n@@ -303,0 +303,23 @@\n+    void test8269146a2b(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case Integer o when o != null, 1:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269301ab(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case 1, Integer o when o != null, default:\n+                break;\n+        }\n+    }\n+    void test8269301bb(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case Integer o when o != null, 1, default:\n+                break;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -9,2 +9,2 @@\n-SwitchErrors.java:220:47: compiler.err.default.label.not.allowed\n-SwitchErrors.java:227:47: compiler.err.default.label.not.allowed\n+SwitchErrors.java:220:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:227:32: compiler.err.default.label.not.allowed\n@@ -13,0 +13,3 @@\n+SwitchErrors.java:306:42: compiler.err.expected2: :, ->\n+SwitchErrors.java:315:45: compiler.err.expected2: :, ->\n+SwitchErrors.java:322:42: compiler.err.expected2: :, ->\n@@ -44,1 +47,2 @@\n-SwitchErrors.java:195:44: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:197:13: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:195:29: compiler.err.flows.through.from.pattern\n@@ -47,1 +51,1 @@\n-SwitchErrors.java:227:44: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:227:29: compiler.err.flows.through.from.pattern\n@@ -58,0 +62,1 @@\n+SwitchErrors.java:315:21: compiler.err.invalid.case.label.combination\n@@ -70,3 +75,1 @@\n-- compiler.note.preview.filename: SwitchErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-69 errors\n+74 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -34,1 +33,0 @@\n- * @enablePreview\n@@ -56,0 +54,1 @@\n+        runEnumTest(this::testEnumWithGuards5);\n@@ -60,0 +59,1 @@\n+        runEnumTest(this::testEnumWithGuardsExpression5);\n@@ -352,0 +352,22 @@\n+    String testEnumWithGuards5(Object e) {\n+        switch (e) {\n+            case E.A: return \"a\";\n+            case E.B: return \"b\";\n+            case Runnable x when \"C\".equals(x.toString()): return \"C\";\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n+            default: throw new AssertionError(\"Unexpected case!\");\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression5(Object e) {\n+        return switch (e) {\n+            case E.A -> \"a\";\n+            case E.B -> \"b\";\n+            case Runnable x when \"C\".equals(x.toString()) -> \"C\";\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n+            default -> throw new AssertionError(\"Unexpected case!\");\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8291657.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -208,2 +206,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -225,3 +221,1 @@\n-            .options(\"--enable-preview\",\n-                     \"-source\", JAVA_VERSION,\n-                     \"-Xlint:-preview\",\n+            .options(\"-Xlint:-preview\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/TranslationTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/TypedDeconstructionPatternExc.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile Unnamed.java\n+ * @run main Unnamed\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class Unnamed {\n+    public static void main(String[] args) throws Throwable {\n+        new Unnamed().run();\n+    }\n+\n+    public void run() {\n+        assertEquals(1, testMultiValuesTopLevel(new R1()));\n+        assertEquals(2, testMultiValuesTopLevel(new R3()));\n+        assertEquals(1, testMultiValuesTopLevel2(new R1()));\n+        assertEquals(2, testMultiValuesTopLevel2(new R2()));\n+        assertEquals(2, testMultiValuesTopLevel2(new R4()));\n+        assertEquals(1, testMultiValuesNested(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNested(new Box<>(new R2())));\n+        assertEquals(2, testMultiValuesNested(new Box<>(new R3())));\n+        assertEquals(3, testMultiValuesNested(new Box<>(new R4())));\n+        assertEquals(1, testMultiValuesNestedUnnamedVarAndPattern(new Box<>(new R1())));\n+        assertEquals(2, testMultiValuesNestedUnnamedVarAndPattern(new Box<>(new R4())));\n+        assertEquals(1, testMultiValuesNestedMix(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix(new Box2<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix2(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix2(\"BOX\"));\n+        assertEquals(2, testMultiValuesNestedMix2(new Box2<>(new R1())));\n+        assertEquals(1, testMultiValuesStatementBlock(42));\n+        assertEquals(1, testMultiValuesStatementBlock(42.0f));\n+        assertEquals(2, testMultiValuesStatementBlock(\"BOX\"));\n+        assertEquals(1, testMultiValuesStatementBlock2(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesStatementBlock2(\"BOX\"));\n+        assertEquals(2, testMultiValuesStatementBlock2(new Box2<>(new R1())));\n+        assertEquals(2, testMultiValuesGuards(new R3(), 1));\n+        assertEquals(3, testMultiValuesGuards(new R4(), 42));\n+        assertEquals(3, testMultiValuesGuards(new R3(), 42));\n+        assertEquals(1, testMultiValuesNestedGuards(new Box(new R2()), 42));\n+        assertEquals(2, testMultiValuesNestedGuards(new Box(new R3()), 1));\n+        assertEquals(1, testMixUnconditionalAndConditional(new R1()));\n+        assertEquals(2, testMixUnconditionalAndConditional(new R2()));\n+        assertEquals(2, testMixUnconditionalAndConditional(new R3()));\n+        assertEquals(1, testMultipleExpr(new Box<>(new R1())));\n+        assertEquals(1, testUnrolledExpr(new Box<>(new R1())));\n+        assertEquals(1, testMultipleStat(new Box<>(new R1())));\n+        assertEquals(1, testUnrolledStat(new Box<>(new R1())));\n+        assertEquals(2, testMixVarWithExplicit(new Box<>(new R2())));\n+        assertEquals(\"binding\", unnamedGuardAddsBindings(\"match1\", \"binding\"));\n+        assertEquals(\"any\", unnamedGuardAddsBindings(42, 42));\n+\n+        unnamedTest();\n+    }\n+\n+    private void unnamedTest() {\n+        int _ = 0;\n+        int _ = 1;\n+        try (Lock _ = null) {\n+            try (Lock _ = null) {\n+            } catch (Exception _) {\n+                try {\n+                } catch (Exception _) {}\n+            }\n+        }\n+        String[] strs = new String[] { \"str1\", \"str2\" };\n+        for (var _ : strs) {\n+            for (var _ : strs) {\n+            }\n+        }\n+        TwoParams p1 = (_, _) -> {};\n+        TwoParams p2 = (var _, var _) -> {};\n+        TwoIntParams p3 = (int _, int b) -> {};\n+        TwoIntParams p4 = (int _, int _) -> {};\n+        TwoIntParamsIntRet p5 = (int _, int _) -> { return 1; };\n+\n+        p1.run(1, 2);\n+        p2.run(1, 2);\n+        p3.run(1, 2);\n+        p4.run(1, 2);\n+        p5.run(1, 2);\n+\n+        R r = new R(null);\n+        if (r instanceof R _) {}\n+        if (r instanceof R(_)) {}\n+        for (int _ = 0, _ = 1, x = 1; x <= 1 ; x++) {}\n+    }\n+\n+    int testMultiValuesTopLevel(Object o) {\n+        return switch (o) {\n+            case R1 _, R2 _ -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesTopLevel2(Base o) {\n+        return switch (o) {\n+            case R1 r -> 1;\n+            case R2 _, R3 _, R4 _ -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNested(Box<?> b) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _) -> 2;\n+            case Box(_)  -> 3;\n+        };\n+    }\n+\n+    int testMultiValuesNestedUnnamedVarAndPattern(Box<?> b) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _), Box(_) -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNestedMix(Object b) {\n+        return switch (b) {\n+            case Box(_), Box2(_) -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNestedMix2(Object b) {\n+        return switch (b) {\n+            case Box(_), String _ -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesStatementBlock(Object o) {\n+        switch (o) {\n+            case Integer _:\n+            case Number _:\n+                return 1;\n+            default:\n+                return 2;\n+        }\n+    }\n+\n+    int testMultiValuesStatementBlock2(Object o) {\n+        switch (o) {\n+            case Box(_):\n+            case String _:\n+                return 1;\n+            default:\n+                return 2;\n+        }\n+    }\n+\n+    int testMultiValuesGuards(Base b, int x) {\n+        return switch (b) {\n+            case R1 r -> 1;\n+            case R2 _, R3 _, R4 _ when x == 1 -> 2;\n+            case R2 _, R3 _, R4 _ -> 3;\n+        };\n+    }\n+\n+    int testMultiValuesNestedGuards(Box<?> b, int x) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _), Box(_) when x == 1 -> 2;\n+            case Box(_) -> 3;\n+        };\n+    }\n+\n+    int testMixUnconditionalAndConditional(Base t) {\n+        return switch(t) {\n+            case R1 _ -> 1;\n+            case R2 _, Base _-> 2;\n+        };\n+    }\n+\n+    int testMultipleExpr(Box<?> t) {\n+        return switch(t) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            default -> -2;\n+        };\n+    }\n+\n+    int testUnrolledExpr(Box<?> t) {\n+        return switch(t) {\n+            case Box(R1 _) -> 1;\n+            case Box(R2 _) -> 0;\n+            default -> -2;\n+        };\n+    }\n+\n+    int testMultipleStat(Box<?> t) {\n+        int ret = -1;\n+        switch(t) {\n+            case Box(R1 _), Box(R2 _):\n+                ret = 1;\n+                break;\n+            default:\n+                ret = -2;\n+        }\n+        return ret;\n+    }\n+\n+    int testUnrolledStat(Box<?> t) {\n+        int ret = -1;\n+        switch(t) {\n+            case Box(R1 _):\n+                ret = 1;\n+                break;\n+            case Box(R2 _):\n+                ret = 0;\n+                break;\n+            default:\n+                ret = -2;\n+        }\n+        return ret;\n+    }\n+\n+    int testMixVarWithExplicit(Box<?> t) {\n+        int success = -1;\n+        success = switch(t) {\n+            case Box(R1 _) : {\n+                yield 1;\n+            }\n+            case Box(R2 _), Box(var _) : {\n+                yield 2;\n+            }\n+            default : {\n+                yield -2;\n+            }\n+        };\n+        return success;\n+    }\n+\n+    String unnamedGuardAddsBindings(Object o1, Object o2) {\n+        return switch (o1) {\n+            case String _, Object _ when o2 instanceof String s: yield s;\n+            case Object _: yield \"any\";\n+        };\n+    }\n+\n+    \/\/ JEP 443 examples\n+    record Point(int x, int y) { }\n+    enum Color { RED, GREEN, BLUE }\n+    record ColoredPoint(Point p, Color c) { }\n+\n+    void jep443examples(ColoredPoint r) {\n+        if (r instanceof ColoredPoint(Point(int x, int y), _)) { }\n+        if (r instanceof ColoredPoint(_, Color c)) { }\n+        if (r instanceof ColoredPoint(Point(int x, _), _)) { }\n+        if (r instanceof ColoredPoint(Point(int x, int _), Color _)) { }\n+        if (r instanceof ColoredPoint _) { }\n+    }\n+\n+    class Lock implements AutoCloseable {\n+        @Override\n+        public void close() {}\n+    }\n+    interface TwoParams {\n+        public void run(Object o1, Object o2);\n+    }\n+    interface TwoIntParams {\n+        public void run(int o1, int o2);\n+    }\n+    interface TwoIntParamsIntRet {\n+        public int run(int a, int b);\n+    }\n+    record R(Object o) {}\n+\n+    sealed abstract class Base permits R1, R2, R3, R4 { }\n+    final  class R1  extends Base { }\n+    final  class R2  extends Base { }\n+    final  class R3  extends Base { }\n+    final  class R4  extends Base { }\n+    record Box<T extends Base>(T content) { }\n+    record Box2<T extends Base>(T content) { }\n+    void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Unnamed.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile\/fail\/ref=UnnamedErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW UnnamedErrors.java\n+ *\/\n+public class UnnamedErrors {\n+    private int _; \/\/ error\n+    private int _, x;  \/\/ error\n+    private int x, _, y, _, z, _;  \/\/ error\n+    private int _ = 0, _ = 1; \/\/ error\n+    private int a = 0, _ = 1; \/\/ error\n+\n+    record R(int _) {} \/\/no record components\n+    UnnamedErrors(int _) {} \/\/no constructor parameters\n+    void test(int _) {} \/\/no method parameters\n+\n+    record RR(int x) {}\n+    void test2() {\n+        Object o = Integer.valueOf(42);\n+        if (o instanceof _) {} \/\/no top level\n+\n+        if (o instanceof _(int x)) {} \/\/no record pattern head\n+\n+        switch (o) {\n+            case _:\n+                System.out.println(\"no underscore top level\");\n+            default:\n+                System.out.println(\"\");\n+        }\n+\n+        switch (o) {\n+            case var _:\n+                System.out.println(\"no var _ top level\");\n+            default:\n+                System.out.println(\"\");\n+        }\n+    }\n+\n+    void dominanceError(Object o) {\n+        switch (o) {\n+            case Number _ ->\n+                    System.out.println(\"A Number\");\n+            case Integer _, String _ ->             \/\/ Error - dominated case pattern: `Integer _`\n+                    System.out.println(\"An Integer or a String\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+    }\n+\n+    void mixedNamedUnnamedError(Object o) {\n+        switch (o) {\n+            case Integer i, String _ ->\n+                    System.out.println(\"named\/unnamed\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+\n+        switch (o) {\n+            case Integer _, String s ->\n+                    System.out.println(\"unnamed\/named\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+\n+        switch (o) {\n+            case PairIS(_, _), String s ->\n+                    System.out.println(\"unnamed patterns\/named\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+    }\n+\n+    private void test1() {\n+        try (Lock _ = null) {\n+        } catch (_) { }\n+    }\n+\n+    int guardErrors(Object o, int x1, int x2) {\n+        return switch (o) {\n+            case Integer _ when x1 == 2, String _ when x2 == 1 -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMixVarWithExplicitDominanceError(Box<?> t) {\n+        int success = -1;\n+        success = switch(t) {\n+            case Box(var _), Box(R2 _) : {\n+                yield 1;\n+            }\n+            default : {\n+                yield -2;\n+            }\n+        };\n+        return success;\n+    }\n+\n+    void testUnderscoreWithoutInitializer() {\n+        int _;\n+        int x1 = 1, _, x2;\n+\n+        for (int x = 1, _; x<=1; x++) {\n+\n+        }\n+    }\n+\n+    class Lock implements AutoCloseable {\n+        @Override\n+        public void close() {}\n+    }\n+    record PairIS(int i, String s) {}\n+    sealed abstract class Base permits R1, R2 { }\n+    final  class R1  extends Base { }\n+    final  class R2  extends Base { }\n+    record Box<T extends Base>(T content) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+UnnamedErrors.java:9:17: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:10:17: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:11:20: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:11:26: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:11:32: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:12:17: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:12:24: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:13:24: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:15:18: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:16:23: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:17:19: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:22:26: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:24:26: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:27:18: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:34:18: compiler.err.restricted.type.not.allowed.here: var\n+UnnamedErrors.java:77:18: compiler.err.use.of.underscore.not.allowed\n+UnnamedErrors.java:77:19: compiler.err.expected: token.identifier\n+UnnamedErrors.java:82:40: compiler.err.expected2: :, ->\n+UnnamedErrors.java:82:51: compiler.err.expected: =\n+UnnamedErrors.java:82:58: compiler.err.expected: ';'\n+UnnamedErrors.java:101:14: compiler.err.expected: =\n+UnnamedErrors.java:102:22: compiler.err.expected: =\n+UnnamedErrors.java:104:26: compiler.err.expected: =\n+UnnamedErrors.java:11:17: compiler.err.already.defined: kindname.variable, x, kindname.class, UnnamedErrors\n+UnnamedErrors.java:36:13: compiler.err.unconditional.pattern.and.default\n+UnnamedErrors.java:45:18: compiler.err.pattern.dominated\n+UnnamedErrors.java:54:29: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:61:29: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:68:32: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:82:56: compiler.err.already.defined: kindname.variable, x2, kindname.method, guardErrors(java.lang.Object,int,int)\n+UnnamedErrors.java:83:13: compiler.err.switch.mixing.case.types\n+UnnamedErrors.java:90:30: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: UnnamedErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+32 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.out","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -4,1 +4,0 @@\n- * @enablePreview\n@@ -7,0 +6,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-- compiler.note.preview.filename: VarErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @compile\/process -processor TestContext -XprintRounds TestContext\n+ * @compile\/process -processor TestContext -XprintRounds -proc:full TestContext\n","filename":"test\/langtools\/tools\/javac\/processing\/environment\/round\/TestContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import javax.lang.model.SourceVersion;\n-import static javax.lang.model.SourceVersion.*;\n@@ -41,4 +39,0 @@\n-import javax.lang.model.util.*;\n-import static javax.lang.model.util.ElementFilter.*;\n-import static javax.tools.Diagnostic.Kind.*;\n-import static javax.tools.StandardLocation.*;\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestNames.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344 8307007\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @enablePreview\n+ * @compile TestUnnamedVariableElement.java\n+ * @compile --enable-preview -source ${jdk.version} -processor TestUnnamedVariableElement -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import java.util.*;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+import java.io.StringWriter;\n+\n+public class TestUnnamedVariableElement extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(processingEnv.getElementUtils(), trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+\n+        private final Elements elements;\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Elements elements, Trees trees) {\n+            super();\n+            this.elements = elements;\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+\n+            if(!node.getName().isEmpty()) {\n+                throw new RuntimeException(\"Expected empty name as the name of the Tree API but got: \" + node.getName());\n+            }\n+\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            VariableElement element = (VariableElement) trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            StringWriter out = new StringWriter();\n+            String expected = \"int _;\";\n+            elements.printElements(out, element);\n+            if (!expected.equals(out.toString().trim())) {\n+                throw new RuntimeException(\"Expected: \" + expected + \", but got: \" + out.toString());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344 8307007\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @compile TestUnnamedVariableElement8.java\n+ * @compile -source 8 -processor TestUnnamedVariableElement8 -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import java.util.Set;\n+\n+public class TestUnnamedVariableElement8 extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Trees trees) {\n+            super();\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            Element element = trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            if (!element.getSimpleName().toString().equals(\"_\")) {\n+                throw new RuntimeException(\"Expected _ for simple name of an unnamed variable, but got: \" +\n+                        element.getSimpleName());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement8.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class TestUnnamedVariableElementData {\n+    private void test() {\n+        int _ = 0;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElementData.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308245\n+ * @summary Test trivial handling of -proc:full option\n+ * @compile -proc:full TestProcOption.java\n+ * @run main TestProcOption\n+ *\/\n+\n+\/*\n+ * The test verifies that compilation takes place when -proc:full is used.\n+ *\/\n+public class TestProcOption {\n+    private TestProcOption(){};\n+\n+    public static void main(String... args) {\n+        ; \/\/ do nothing\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/TestProcOption.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -96,2 +96,0 @@\n-                .options(\"--enable-preview\",\n-                         \"-source\", JAVA_VERSION)\n@@ -132,4 +130,1 @@\n-                        .options(\"--enable-preview\",\n-                                 \"-source\", JAVA_VERSION,\n-                                 \"-XDrawDiagnostics\",\n-                                 \"-Xlint:-preview\",\n+                        .options(\"-XDrawDiagnostics\",\n@@ -146,2 +141,0 @@\n-                   \"- compiler.note.preview.filename: Test1.java, DEFAULT\",\n-                   \"- compiler.note.preview.recompile\",\n@@ -176,4 +169,1 @@\n-                        .options(\"--enable-preview\",\n-                                 \"-source\", JAVA_VERSION,\n-                                 \"-XDrawDiagnostics\",\n-                                 \"-Xlint:-preview\",\n+                        .options(\"-XDrawDiagnostics\",\n","filename":"test\/langtools\/tools\/javac\/sealed\/MissingPermittedSubtypes.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+ * @compile --release 20 ExhaustiveEnumSwitch.java\n+ * @compile ExhaustiveEnumSwitchExtra.java\n+ * @run main ExhaustiveEnumSwitch IncompatibleClassChangeError\n@@ -30,1 +33,1 @@\n- * @run main ExhaustiveEnumSwitch\n+ * @run main ExhaustiveEnumSwitch MatchException\n@@ -34,2 +37,3 @@\n-    public static void main(String... args) {\n-        new ExhaustiveEnumSwitch().run();\n+    public static void main(String... args) throws ClassNotFoundException {\n+        boolean matchException = \"MatchException\".equals(args[0]);\n+        new ExhaustiveEnumSwitch().run(matchException);\n@@ -38,1 +42,1 @@\n-    private void run() {\n+    private void run(boolean matchException) throws ClassNotFoundException {\n@@ -45,1 +49,12 @@\n-            \/\/ok\n+            if (matchException) {\n+                throw new AssertionError(\"Expected IncompatibleClassChangeError, but got MatchException!\");\n+            }\n+        } catch (Exception ex) {\n+            \/\/cannot refer to MatchException directly, as it used to be preview API in JDK 20:\n+            if (ex.getClass() == Class.forName(\"java.lang.MatchException\")) {\n+                if (!matchException) {\n+                    throw new AssertionError(\"Expected MatchException, but got IncompatibleClassChangeError!\");\n+                }\n+            } else {\n+                throw ex;\n+            }\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExhaustiveEnumSwitch.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -100,4 +100,1 @@\n-                    })\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\")\n-                .withOption(String.valueOf(Runtime.version().feature()));\n+                    });\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/SwitchExpressionNoValue.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8300543\n+ * @summary Check switches work correctly with qualified enum constants\n+ * @compile EnumSwitchQualified.java\n+ * @run main EnumSwitchQualified\n+*\/\n+\n+import java.util.Objects;\n+\n+public class EnumSwitchQualified {\n+\n+    public static void main(String... args) {\n+        new EnumSwitchQualified().run();\n+    }\n+\n+    void run() {\n+        assertEquals(1, testPatternMatchingSwitch1(E1.A));\n+        assertEquals(2, testPatternMatchingSwitch1(E1.B));\n+        assertEquals(3, testPatternMatchingSwitch1(E1.C));\n+        assertEquals(4, testPatternMatchingSwitch1(E2.B));\n+        assertEquals(5, testPatternMatchingSwitch1(E2.C));\n+        assertEquals(6, testPatternMatchingSwitch1(E2.D));\n+\n+        assertEquals(1, testPatternMatchingSwitch2(E1.A));\n+        assertEquals(2, testPatternMatchingSwitch2(E1.B));\n+        assertEquals(3, testPatternMatchingSwitch2(E1.C));\n+\n+        assertEquals(1, testPatternMatchingSwitch3(E1.A));\n+        assertEquals(2, testPatternMatchingSwitch3(E1.B));\n+        assertEquals(3, testPatternMatchingSwitch3(E1.C));\n+        assertEquals(4, testPatternMatchingSwitch3(E2.B));\n+        assertEquals(5, testPatternMatchingSwitch3(E2.C));\n+        assertEquals(6, testPatternMatchingSwitch3(E2.D));\n+        assertEquals(7, testPatternMatchingSwitch3(\"\"));\n+    }\n+\n+    int testPatternMatchingSwitch1(I i) {\n+        return switch(i) {\n+            case E1.A -> 1;\n+            case E1.B -> 2;\n+            case E1.C -> 3;\n+            case E2.B -> 4;\n+            case E2.C -> 5;\n+            case E2.D -> 6;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch2(E1 e) {\n+        return switch(e) {\n+            case E1.A -> 1;\n+            case E1.B -> 2;\n+            case E1.C -> 3;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch3(Object o) {\n+        return switch(o) {\n+            case E1.A -> 1;\n+            case E1.B -> 2;\n+            case E1.C -> 3;\n+            case E2.B -> 4;\n+            case E2.C -> 5;\n+            case E2.D -> 6;\n+            default -> 7;\n+        };\n+    }\n+\n+    private void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Incorrect result, expected: \" + expected +\n+                                     \", actual: \" + actual);\n+        }\n+    }\n+\n+    sealed interface I {}\n+    enum E1 implements I { A, B, C; }\n+    enum E2 implements I { B, C, D; }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualified.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8300543\n+ * @summary Check switches work correctly with qualified enum constants\n+ * @compile\/fail\/ref=EnumSwitchQualifiedErrors.out -XDrawDiagnostics EnumSwitchQualifiedErrors.java\n+*\/\n+\n+public class EnumSwitchQualifiedErrors {\n+\n+    int testPatternMatchingSwitch1(I i) {\n+        return switch(i) {\n+            case E1.A -> 1;\n+            case E2.A -> 2;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch2(E1 e) {\n+        return switch(e) {\n+            case E1.A -> 1;\n+            case E2.A -> 4;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch3(Number n) {\n+        return switch(n) {\n+            case E1.A -> 1;\n+            case E2.A -> 2;\n+        };\n+    }\n+\n+    sealed interface I {}\n+    enum E1 implements I { A; }\n+    enum E2 { A; }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+EnumSwitchQualifiedErrors.java:36:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E2, EnumSwitchQualifiedErrors.I)\n+EnumSwitchQualifiedErrors.java:43:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E2, EnumSwitchQualifiedErrors.E1)\n+EnumSwitchQualifiedErrors.java:49:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E1, java.lang.Number)\n+EnumSwitchQualifiedErrors.java:50:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E2, java.lang.Number)\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -98,1 +98,1 @@\n-            List.of(\"--enable-preview\", \"-source\", version), null,\n+            List.of(), null,\n","filename":"test\/langtools\/tools\/javac\/switchextra\/RuleParsingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n@@ -6,1 +5,1 @@\n-5 errors\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-SwitchObject.java:10:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n@@ -4,1 +3,1 @@\n-3 errors\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchObject.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNull.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled-preview.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -4,4 +4,3 @@\n- * @summary Verify \"case null\" is not allowed for --release 16\n- * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics --release 16 SwitchNullDisabled.java\n- * @compile\/fail\/ref=SwitchNullDisabled-preview.out -XDrawDiagnostics SwitchNullDisabled.java\n- * @compile --enable-preview -source ${jdk.version} SwitchNullDisabled.java\n+ * @summary Verify \"case null\" is not allowed for --release 16, 20\n+ * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics --release 20 SwitchNullDisabled.java\n+ * @compile SwitchNullDisabled.java\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n+SwitchNullDisabled.java:12:18: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.case.null), 20, 21\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-        test.run(\"java.util.function.IntBinaryOperator c = (var x, |testType|) -> 1;\",\n-                 \"testType \");\n","filename":"test\/langtools\/tools\/javac\/tree\/VarTree.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        String testQuery = System.getProperty(\"test.query\");\n@@ -86,9 +87,12 @@\n-                try {\n-                    testCount++;\n-                    out.println(\"test: \" + testName);\n-                    m.invoke(this, f.apply(m));\n-                } catch (InvocationTargetException e) {\n-                    errorCount++;\n-                    Throwable cause = e.getCause();\n-                    out.println(\"Exception running test \" + testName + \": \" + e.getCause());\n-                    cause.printStackTrace(out);\n+                if (testQuery == null || testQuery.equals(testName)) {\n+                    try {\n+                        testCount++;\n+                        out.println(\"test: \" + testName);\n+                        m.invoke(this, f.apply(m));\n+                    } catch (InvocationTargetException e) {\n+                        errorCount++;\n+                        Throwable cause = e.getCause();\n+                        out.println(\"Exception running test \" + testName + \": \" + e.getCause());\n+                        cause.printStackTrace(out);\n+                    }\n+                    out.println();\n@@ -96,1 +100,0 @@\n-                out.println();\n","filename":"test\/langtools\/tools\/lib\/toolbox\/TestRunner.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.test.lib.Asserts;\n@@ -52,1 +51,0 @@\n-import java.io.File;\n@@ -56,2 +54,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n@@ -60,0 +56,1 @@\n+import java.security.interfaces.EdECPrivateKey;\n@@ -61,0 +58,1 @@\n+import java.security.spec.NamedParameterSpec;\n@@ -71,31 +69,0 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/ MAIN as TEST \/\/\/\/\/\/\/\/\/\/\/\/\n-    public static void main(String[] args) throws Exception {\n-        var x = \"<a><b>c<\/b>x<\/a>\";\n-        var p = Files.write(Path.of(\"x.xml\"), List.of(x));\n-        var b = Path.of(\"\").toUri().toString();\n-        var d = string2doc(x);\n-        \/\/ keytool -keystore ks -keyalg ec -storepass changeit -genkeypair -alias a -dname CN=a\n-        var pass = \"changeit\".toCharArray();\n-        var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n-        var c = (X509Certificate) ks.getCertificate(\"a\");\n-        var pr = (PrivateKey) ks.getKey(\"a\", pass);\n-        var pu = c.getPublicKey();\n-        var s0 = signer(pr); \/\/ No KeyInfo\n-        var s1 = signer(pr, pu); \/\/ KeyInfo is PublicKey\n-        var s2 = signer(pr, c); \/\/ KeyInfo is X509Data\n-        var s3 = signer(ks, \"a\", pass); \/\/ KeyInfo is KeyName\n-        var v1 = validator(); \/\/ knows nothing\n-        var v2 = validator(ks); \/\/ knows KeyName\n-        Asserts.assertTrue(v1.validate(s0.sign(d), pu)); \/\/ need PublicKey\n-        Asserts.assertTrue(v1.validate(s1.sign(d))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v1.validate(s2.sign(d))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v2.validate(s3.sign(d))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v2.secureValidation(false).validate(s3.sign(p.toUri()))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v2.secureValidation(false).baseURI(b).validate(\n-                s3.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v1.validate(s1.sign(\"text\"))); \/\/ plain text\n-        Asserts.assertTrue(v1.validate(s1.sign(\"binary\".getBytes()))); \/\/ raw data\n-        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#x\")));\n-        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n-    }\n-\n@@ -223,1 +190,2 @@\n-        PrivateKey privateKey;  \/\/ signer key, never null\n+        final PrivateKey privateKey;  \/\/ signer key, never null\n+\n@@ -228,27 +196,8 @@\n-        SignatureMethod sm;     \/\/ default determined by privateKey\n-        DigestMethod dm;        \/\/ default SHA-256\n-        CanonicalizationMethod cm;  \/\/ default EXCLUSIVE\n-        Transform tr;           \/\/ default ENVELOPED\n-\n-        public Signer(PrivateKey privateKey) throws Exception {\n-            this.privateKey = privateKey;\n-            dm(DigestMethod.SHA256);\n-            tr(Transform.ENVELOPED);\n-            cm(CanonicalizationMethod.EXCLUSIVE);\n-            String alg = privateKey.getAlgorithm();\n-            if (alg.equals(\"RSASSA-PSS\")) {\n-                PSSParameterSpec pspec\n-                        = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n-                if (pspec != null) {\n-                    sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n-                } else {\n-                    sm(SignatureMethod.RSA_PSS);\n-                }\n-            } else {\n-                sm(switch (privateKey.getAlgorithm()) {\n-                    case \"RSA\" -> SignatureMethod.RSA_SHA256;\n-                    case \"DSA\" -> SignatureMethod.DSA_SHA256;\n-                    case \"EC\" -> SignatureMethod.ECDSA_SHA256;\n-                    default -> throw new InvalidKeyException();\n-                });\n-            }\n+        String sm = null;       \/\/ default determined by privateKey\n+        SignatureMethodParameterSpec smSpec = null;\n+        String dm = DigestMethod.SHA256;\n+        String cm = CanonicalizationMethod.EXCLUSIVE;\n+        String tr = Transform.ENVELOPED;\n+\n+        public Signer(PrivateKey privateKey) {\n+            this.privateKey = Objects.requireNonNull(privateKey);\n@@ -276,13 +225,2 @@\n-        public Signer tr(String transform) throws Exception {\n-            TransformParameterSpec params = null;\n-            switch (transform) {\n-                case Transform.XPATH:\n-                    params = new XPathFilterParameterSpec(\"\/\/.\");\n-                    break;\n-                case Transform.XPATH2:\n-                    params = new XPathFilter2ParameterSpec(\n-                            Collections.singletonList(new XPathType(\"\/\/.\",\n-                                    XPathType.Filter.INTERSECT)));\n-                    break;\n-            }\n-            tr = FAC.newTransform(transform, params);\n+        public Signer tr(String transform) {\n+            tr = Objects.requireNonNull(transform);\n@@ -292,2 +230,2 @@\n-        public Signer sm(String method) throws Exception {\n-            sm = FAC.newSignatureMethod(method, null);\n+        public Signer dm(String method) {\n+            dm = Objects.requireNonNull(method);\n@@ -297,2 +235,2 @@\n-        public Signer dm(String method) throws Exception {\n-            dm = FAC.newDigestMethod(method, null);\n+        public Signer cm(String method) {\n+            cm = Objects.requireNonNull(method);\n@@ -302,2 +240,3 @@\n-        public Signer cm(String method) throws Exception {\n-            cm = FAC.newCanonicalizationMethod(method, (C14NMethodParameterSpec) null);\n+        public Signer sm(String method, SignatureMethodParameterSpec spec) {\n+            sm = method;\n+            smSpec = spec;\n@@ -307,10 +246,2 @@\n-        public Signer sm(String method, SignatureMethodParameterSpec spec)\n-                throws Exception {\n-            sm = FAC.newSignatureMethod(method, spec);\n-            return this;\n-        }\n-\n-        public Signer dm(String method, DigestMethodParameterSpec spec)\n-                throws Exception {\n-            dm = FAC.newDigestMethod(method, spec);\n-            return this;\n+        public Signer sm(String method) throws Exception {\n+            return sm(method, null);\n@@ -356,1 +287,1 @@\n-                    buildSignedInfo(FAC.newReference(ref, dm)),\n+                    buildSignedInfo(FAC.newReference(ref, FAC.newDigestMethod(dm, null))),\n@@ -371,1 +302,1 @@\n-                    buildSignedInfo(FAC.newReference(\"#object\", dm, List.of\n+                    buildSignedInfo(FAC.newReference(\"#object\", FAC.newDigestMethod(dm, null), List.of\n@@ -389,1 +320,2 @@\n-                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildSignedInfo(\n+                            FAC.newReference(\"#object\", FAC.newDigestMethod(dm, null))),\n@@ -391,1 +323,2 @@\n-                    List.of(FAC.newXMLObject(List.of(new DOMStructure(newDocument.createTextNode(str))),\n+                    List.of(FAC.newXMLObject(\n+                            List.of(new DOMStructure(newDocument.createTextNode(str))),\n@@ -400,5 +333,2 @@\n-        private SignedInfo buildSignedInfo(String ref) {\n-            return FAC.newSignedInfo(\n-                    cm,\n-                    sm,\n-                    List.of(FAC.newReference(\n+        private SignedInfo buildSignedInfo(String ref) throws Exception {\n+            return buildSignedInfo(FAC.newReference(\n@@ -406,3 +336,10 @@\n-                            dm,\n-                            List.of(tr),\n-                            null, null)));\n+                            FAC.newDigestMethod(dm, null),\n+                            List.of(FAC.newTransform(tr, switch (tr) {\n+                                case Transform.XPATH ->\n+                                    new XPathFilterParameterSpec(\"\/\/.\");\n+                                case Transform.XPATH2 -> new XPathFilter2ParameterSpec(\n+                                            Collections.singletonList(new XPathType(\"\/\/.\",\n+                                                    XPathType.Filter.INTERSECT)));\n+                                default -> null;\n+                            })),\n+                            null, null));\n@@ -412,1 +349,36 @@\n-        private SignedInfo buildSignedInfo(Reference ref) {\n+        private SignedInfo buildSignedInfo(Reference ref) throws Exception {\n+            SignatureMethod signatureMethod;\n+            if (sm == null) {\n+                String alg = privateKey.getAlgorithm().toUpperCase(Locale.ROOT);\n+                if (alg.equals(\"RSASSA-PSS\")) {\n+                    PSSParameterSpec pspec\n+                            = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n+                    if (pspec != null) {\n+                        signatureMethod = FAC.newSignatureMethod(\n+                                SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n+                    } else {\n+                        signatureMethod = FAC.newSignatureMethod(SignatureMethod.RSA_PSS, null);\n+                    }\n+                } else {\n+                    signatureMethod = FAC.newSignatureMethod(switch (alg) {\n+                        case \"RSA\" -> SignatureMethod.RSA_SHA256;\n+                        case \"DSA\" -> SignatureMethod.DSA_SHA256;\n+                        case \"EC\" -> SignatureMethod.ECDSA_SHA256;\n+                        case \"ED25519\" -> SignatureMethod.ED25519;\n+                        case \"ED448\" -> SignatureMethod.ED448;\n+                        case \"EDDSA\" -> {\n+                            if (privateKey instanceof EdECPrivateKey edsk) {\n+                                yield edsk.getParams().getName()\n+                                        .equals(NamedParameterSpec.ED25519.getName())\n+                                        ? SignatureMethod.ED25519\n+                                        : SignatureMethod.ED448;\n+                            } else {\n+                                throw new InvalidKeyException();\n+                            }\n+                        }\n+                        default -> throw new InvalidKeyException();\n+                    }, null);\n+                }\n+            } else {\n+                signatureMethod = FAC.newSignatureMethod(sm, smSpec);\n+            }\n@@ -414,2 +386,2 @@\n-                    cm,\n-                    sm,\n+                    FAC.newCanonicalizationMethod(cm, (C14NMethodParameterSpec) null),\n+                    signatureMethod,\n@@ -521,1 +493,3 @@\n-                Objects.requireNonNull(keyInfo, \"Null KeyInfo object!\");\n+                if (keyInfo == null) {\n+                    throw new IllegalArgumentException(\"Null KeyInfo object!\");\n+                }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":83,"deletions":109,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms1g\", \"-Xmx1g\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class AESReinit {\n+\n+    private Cipher cipher;\n+    private Random random;\n+\n+    byte[] key = new byte[16];\n+    byte[] iv  = new byte[16];\n+\n+    @Setup\n+    public void prepare() throws Exception {\n+        random = new Random();\n+        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+        key = new byte[16];\n+        iv = new byte[16];\n+    }\n+\n+    @Benchmark\n+    public void test() throws Exception {\n+        random.nextBytes(key);\n+        random.nextBytes(iv);\n+        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n+        GCMParameterSpec param = new GCMParameterSpec(128, iv);\n+        cipher.init(Cipher.ENCRYPT_MODE, secretKey, param);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/AESReinit.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -48,1 +48,10 @@\n-@Fork(1)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AbstractCorpusBenchmark.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n@@ -58,1 +58,8 @@\n-@Fork(1)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n@@ -78,1 +85,1 @@\n-        data = new LinkedList<>();\n+        data = new ArrayList<>();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.util.Iterator;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.instruction.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\"})\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 4)\n+public class RebuildMethodBodies {\n+\n+    List<ClassModel> shared, unshared;\n+    Iterator<ClassModel> it1, it2;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws IOException {\n+        shared = new ArrayList<>();\n+        unshared = new ArrayList<>();\n+        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\")).forEach(p -> {\n+            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n+                var clm = Classfile.parse(p,\n+                        Classfile.Option.constantPoolSharing(true),\n+                        Classfile.Option.processDebug(false),\n+                        Classfile.Option.processLineNumbers(false));\n+                shared.add(clm);\n+                transform(clm); \/\/dry run to expand model and symbols\n+                clm = Classfile.parse(p,\n+                        Classfile.Option.constantPoolSharing(false),\n+                        Classfile.Option.processDebug(false),\n+                        Classfile.Option.processLineNumbers(false));\n+                unshared.add(clm);\n+                transform(clm); \/\/dry run to expand model and symbols\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    @Benchmark\n+    public void shared() {\n+        if (it1 == null || !it1.hasNext())\n+            it1 = shared.iterator();\n+        \/\/model and symbols were already expanded, so benchmark is focused more on builder performance\n+        transform(it1.next());\n+    }\n+\n+    @Benchmark\n+    public void unshared() {\n+        if (it2 == null || !it2.hasNext())\n+            it2 = unshared.iterator();\n+        \/\/model and symbols were already expanded, so benchmark is focused more on builder performance\n+        transform(it2.next());\n+    }\n+\n+    private static void transform(ClassModel clm) {\n+        clm.transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+            switch (coe) {\n+                case FieldInstruction i ->\n+                    cob.fieldInstruction(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                case InvokeDynamicInstruction i ->\n+                    cob.invokedynamic(i.invokedynamic().asSymbol());\n+                case InvokeInstruction i ->\n+                    cob.invokeInstruction(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+                case NewMultiArrayInstruction i ->\n+                    cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n+                case NewObjectInstruction i ->\n+                    cob.new_(i.className().asSymbol());\n+                case NewReferenceArrayInstruction i ->\n+                    cob.anewarray(i.componentType().asSymbol());\n+                case TypeCheckInstruction i ->\n+                    cob.typeCheckInstruction(i.opcode(), i.type().asSymbol());\n+                default -> cob.with(coe);\n+            }\n+        }));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RebuildMethodBodies.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.util.Iterator;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\"})\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 4)\n+public class RepeatedModelTraversal {\n+\n+    List<ClassModel> models;\n+    Iterator<ClassModel> it;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws IOException {\n+        models = new ArrayList<>();\n+        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\")).forEach(p -> {\n+            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n+                var clm = Classfile.parse(p);\n+                models.add(clm);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    @Benchmark\n+    public void traverseModel() {\n+        if (it == null || !it.hasNext())\n+            it = models.iterator();\n+        ClassPrinter.toTree(it.next(), ClassPrinter.Verbosity.TRACE_ALL);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RepeatedModelTraversal.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -68,1 +68,10 @@\n-@Fork(1)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}