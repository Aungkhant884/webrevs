{"files":[{"patch":"@@ -899,1 +899,1 @@\n-    \/* non-public *\/ static class ViewCollection<E> implements Collection<E> {\n+    \/* non-public *\/ abstract static class ViewCollection<E> implements Collection<E> {\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -446,2 +446,2 @@\n-        int sz = size;\n-        if (sz == 0) {\n+        int last = size - 1;\n+        if (last < 0) {\n@@ -450,1 +450,1 @@\n-            return elementData(sz - 1);\n+            return elementData(last);\n@@ -568,2 +568,2 @@\n-        int sz = size;\n-        if (sz == 0) {\n+        int last = size - 1;\n+        if (last < 0) {\n@@ -573,3 +573,2 @@\n-            sz--;\n-            @SuppressWarnings(\"unchecked\") E oldValue = (E) es[sz];\n-            fastRemove(es, sz);\n+            @SuppressWarnings(\"unchecked\") E oldValue = (E) es[last];\n+            fastRemove(es, last);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1184,1 +1184,1 @@\n-        private SequencedCollection<E> rc() {\n+        private SequencedCollection<E> sc() {\n@@ -1192,1 +1192,1 @@\n-            return new UnmodifiableSequencedCollection<>(rc().reversed());\n+            return new UnmodifiableSequencedCollection<>(sc().reversed());\n@@ -1204,1 +1204,1 @@\n-            return rc().getFirst();\n+            return sc().getFirst();\n@@ -1208,1 +1208,1 @@\n-            return rc().getLast();\n+            return sc().getLast();\n@@ -5904,1 +5904,1 @@\n-        if (! map.isEmpty())\n+        if (! map.isEmpty()) \/\/ implicit null check\n@@ -6014,1 +6014,1 @@\n-        if (! map.isEmpty())\n+        if (! map.isEmpty()) \/\/ implicit null check\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n- * (<i>insertion-order<\/i>).  Note that encounter order is not affected\n+ * (<i>insertion-order<\/i>). The least recently inserted entry (the eldest) is\n+ * first, and the youngest entry is last. Note that encounter order is not affected\n@@ -44,1 +45,3 @@\n- * the invocation.) The encounter order of existing keys can be changed by using\n+ * the invocation.) The reverse-ordered view of this map is in the opposite order, with\n+ * the youngest entry appearing first and the eldest entry appearing last.\n+ * The encounter order of entries already in the map can be changed by using\n@@ -64,1 +67,1 @@\n- * provided to create a linked hash map whose order of iteration is the order\n+ * provided to create a linked hash map whose encounter order is the order\n@@ -75,3 +78,8 @@\n- * <i>No other methods generate entry accesses.<\/i>  In particular, operations\n- * on collection-views do <i>not<\/i> affect the order of iteration of the\n- * backing map.\n+ * <i>No other methods generate entry accesses.<\/i> Invoking these methods on the\n+ * reversed view generates accesses to entries on the backing map. Note that in the\n+ * reversed view, an access to an entry moves it first in encounter order.\n+ * Explicit-positioning methods such as {@code putFirst} or {@code lastEntry}, whether on\n+ * the map or on its reverse-ordered view, perform the positioning operation and\n+ * do not generate entry accesses. Operations on the {@code keySet}, {@code values},\n+ * and {@code entrySet} views or on their sequenced counterparts do <i>not<\/i> affect\n+ * the encounter order of the backing map.\n@@ -1139,7 +1147,1 @@\n-            for (var e : m.entrySet()) {\n-                if (base.containsKey(e.getKey())) {\n-                    base.put(e.getKey(), e.getValue());\n-                } else {\n-                    base.putFirst(e.getKey(), e.getValue());\n-                }\n-            }\n+            base.putAll(m);\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * (<i>insertion-order<\/i>). Note that encounter order is <i>not<\/i> affected\n+ * (<i>insertion-order<\/i>). The least recently inserted element (the eldest) is\n+ * first, and the youngest element is last. Note that encounter order is <i>not<\/i> affected\n@@ -38,2 +39,4 @@\n- * the invocation.) The encounter order of elements already in the set can be changed\n- * by using the {@link #addFirst addFirst} and {@link #addLast addLast} methods.\n+ * the invocation.) The reverse-ordered view of this set is in the opposite order, with\n+ * the youngest element appearing first and the eldest element appearing last. The encounter\n+ * order of elements already in the set can be changed by using the\n+ * {@link #addFirst addFirst} and {@link #addLast addLast} methods.\n@@ -300,0 +303,1 @@\n+            public boolean add(E e)            { return LinkedHashSet.this.add(e); }\n@@ -309,6 +313,0 @@\n-\n-            public boolean add(E e) {\n-                boolean present = LinkedHashSet.this.contains(e);\n-                LinkedHashSet.this.addFirst(e);\n-                return ! present;\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashSet.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -787,0 +787,4 @@\n+     *\n+     * @implSpec\n+     * The implementation in this class calls {@code add(0, e)}.\n+     *\n@@ -789,1 +793,3 @@\n-    default void addFirst(E e) { this.add(0, e); }\n+    default void addFirst(E e) {\n+        this.add(0, e);\n+    }\n@@ -793,0 +799,4 @@\n+     *\n+     * @implSpec\n+     * The implementation in this class calls {@code add(e)}.\n+     *\n@@ -795,1 +805,3 @@\n-    default void addLast(E e) { this.add(e); }\n+    default void addLast(E e) {\n+        this.add(e);\n+    }\n@@ -799,0 +811,5 @@\n+     *\n+     * @implSpec\n+     * If this List is not empty, the implementation in this class returns the result\n+     * of calling {@code get(0)}. Otherwise, it throws {@code NoSuchElementException}.\n+     *\n@@ -802,1 +819,1 @@\n-        if (this.isEmpty())\n+        if (this.isEmpty()) {\n@@ -804,1 +821,3 @@\n-        return this.get(0);\n+        } else {\n+            return this.get(0);\n+        }\n@@ -809,0 +828,5 @@\n+     *\n+     * @implSpec\n+     * If this List is not empty, the implementation in this class returns the result\n+     * of calling {@code get(size() - 1)}. Otherwise, it throws {@code NoSuchElementException}.\n+     *\n@@ -812,1 +836,1 @@\n-        if (this.isEmpty())\n+        if (this.isEmpty()) {\n@@ -814,1 +838,3 @@\n-        return this.get(this.size()-1);\n+        } else {\n+            return this.get(this.size() - 1);\n+        }\n@@ -819,0 +845,5 @@\n+     *\n+     * @implSpec\n+     * If this List is not empty, the implementation in this class returns the result\n+     * of calling {@code remove(0)}. Otherwise, it throws {@code NoSuchElementException}.\n+     *\n@@ -822,1 +853,1 @@\n-        if (this.isEmpty())\n+        if (this.isEmpty()) {\n@@ -824,1 +855,3 @@\n-        return this.remove(0);\n+        } else {\n+            return this.remove(0);\n+        }\n@@ -829,0 +862,5 @@\n+     *\n+     * @implSpec\n+     * If this List is not empty, the implementation in this class returns the result\n+     * of calling {@code remove(size() - 1)}. Otherwise, it throws {@code NoSuchElementException}.\n+     *\n@@ -832,1 +870,1 @@\n-        if (this.isEmpty())\n+        if (this.isEmpty()) {\n@@ -834,1 +872,3 @@\n-        return this.remove(this.size()-1);\n+        } else {\n+            return this.remove(this.size() - 1);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -324,0 +324,34 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * If this set is not empty, the implementation in this class returns the result of calling\n+     * the {@code pollFirst} method. Otherwise, it throws {@code NoSuchElementException}.\n+     *\n+     * @since 21\n+     *\/\n+    default E removeFirst() {\n+        if (this.isEmpty()) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return this.pollFirst();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec\n+     * If this set is not empty, the implementation in this class returns the result of calling\n+     * the {@code pollLast} method. Otherwise, it throws {@code NoSuchElementException}.\n+     *\n+     * @since 21\n+     *\/\n+    default E removeLast() {\n+        if (this.isEmpty()) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return this.pollLast();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/NavigableSet.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-        if (deque instanceof ReverseOrderDequeView) {\n-            return ((ReverseOrderDequeView<T>)deque).base;\n+        if (deque instanceof ReverseOrderDequeView<T> rodv) {\n+            return rodv.base;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderDequeView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-        if (list instanceof ReverseOrderListView) {\n-            return ((ReverseOrderListView<T>)list).base;\n+        if (list instanceof ReverseOrderListView<T> rolv) {\n+            return rolv.base;\n@@ -60,1 +60,1 @@\n-    ReverseOrderListView(List<E> list, boolean modifiable) {\n+    private ReverseOrderListView(List<E> list, boolean modifiable) {\n@@ -75,1 +75,1 @@\n-        if (! modifiable)\n+        if (! modifiable) {\n@@ -77,0 +77,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-        if (map instanceof ReverseOrderSortedMapView) {\n-            return ((ReverseOrderSortedMapView<K, V>)map).base;\n+        if (map instanceof ReverseOrderSortedMapView<K, V> rosmv) {\n+            return rosmv.base;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedMapView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-        if (set instanceof ReverseOrderSortedSetView) {\n-            return ((ReverseOrderSortedSetView<T>)set).base;\n+        if (set instanceof ReverseOrderSortedSetView<T> rossv) {\n+            return rossv.base;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedSetView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,1 +278,3 @@\n-    default void addFirst(E e) { throw new UnsupportedOperationException(); }\n+    default void addFirst(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n@@ -291,1 +293,3 @@\n-    default void addLast(E e) { throw new UnsupportedOperationException(); }\n+    default void addLast(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n@@ -295,0 +299,4 @@\n+     *\n+     * @implSpec\n+     * The implementation in this class returns the result of calling the {@code first} method.\n+     *\n@@ -297,1 +305,3 @@\n-    default E getFirst() { return this.first(); }\n+    default E getFirst() {\n+        return this.first();\n+    }\n@@ -301,0 +311,4 @@\n+     *\n+     * @implSpec\n+     * The implementation in this class returns the result of calling the {@code last} method.\n+     *\n@@ -303,1 +317,3 @@\n-    default E getLast() { return this.last(); }\n+    default E getLast() {\n+        return this.last();\n+    }\n@@ -307,0 +323,6 @@\n+     *\n+     * @implSpec\n+     * The implementation in this class calls the {@code first} method to obtain the first\n+     * element, then it calls {@code remove(element)} to remove the element, and then it returns\n+     * the element.\n+     *\n@@ -317,0 +339,6 @@\n+     *\n+     * @implSpec\n+     * The implementation in this class calls the {@code last} method to obtain the last\n+     * element, then it calls {@code remove(element)} to remove the element, and then it returns\n+     * the element.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedSet.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -312,0 +312,24 @@\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * map's comparison method determines the position of mappings, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+     public V putFirst(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * map's comparison method determines the position of mappings, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    public V putLast(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeMap.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -467,0 +467,24 @@\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * set's comparison method determines the position of elements, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    public void addFirst(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * set's comparison method determines the position of elements, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    public void addLast(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeSet.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1873,0 +1873,24 @@\n+   \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * map's comparison method determines the position of mappings, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+     public V putFirst(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * map's comparison method determines the position of mappings, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    public V putLast(K k, V v) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListMap.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -406,0 +406,24 @@\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * set's comparison method determines the position of elements, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    public void addFirst(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Throws {@code UnsupportedOperationException}. The encounter order induced by this\n+     * set's comparison method determines the position of elements, so explicit positioning\n+     * is not supported.\n+     *\n+     * @throws UnsupportedOperationException always\n+     * @since 21\n+     *\/\n+    public void addLast(E e) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListSet.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -162,0 +162,7 @@\n+    @DataProvider(name=\"unpositionedAdd\")\n+    public Iterator<Object[]> unpositionedAdd() {\n+        return Arrays.<Object[]>asList(\n+            new Object[] { \"LinkedHashSet\", new LinkedHashSet<>(ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n@@ -530,0 +537,16 @@\n+    @Test(dataProvider=\"unpositionedAdd\")\n+    public void testUnpositionedAdd(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(\"x\");\n+        seq.add(\"x\");\n+        checkContents(seq, ref);\n+    }\n+\n+    @Test(dataProvider=\"unpositionedAdd\")\n+    public void testUnpositionedAddRev(String label, SequencedCollection<String> seq, List<String> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(\"x\");\n+        seq.reversed().add(\"x\");\n+        checkContents(seq, ref);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/Basic.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -143,0 +143,8 @@\n+    @DataProvider(name=\"putUnpositioned\")\n+    public Iterator<Object[]> putUnpositioned() {\n+        return Arrays.asList(\n+            new Object[] { \"LinkedHashMap\", false, load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL },\n+            new Object[] { \"LinkedHashMap\", true,  load(new LinkedHashMap<>(), ORIGINAL), ORIGINAL }\n+        ).iterator();\n+    }\n+\n@@ -588,0 +596,48 @@\n+    @Test(dataProvider=\"putUnpositioned\")\n+    public void testUnposPut(String label, boolean rev, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        (rev ? map.reversed() : map).put(\"x\", 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"putUnpositioned\")\n+    public void testUnposPutAll(String label, boolean rev, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        (rev ? map.reversed() : map).putAll(Map.of(\"x\", 99));\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"putUnpositioned\")\n+    public void testUnposPutIfAbsent(String label, boolean rev, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        (rev ? map.reversed() : map).putIfAbsent(\"x\", 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"putUnpositioned\")\n+    public void testUnposCompute(String label, boolean rev, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        (rev ? map.reversed() : map).compute(\"x\", (k, v) -> 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"putUnpositioned\")\n+    public void testUnposComputeIfAbsent(String label, boolean rev, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        (rev ? map.reversed() : map).computeIfAbsent(\"x\", k -> 99);\n+        checkContents(map, ref);\n+    }\n+\n+    @Test(dataProvider=\"putUnpositioned\")\n+    public void testUnposMerge(String label, boolean rev, SequencedMap<String, Integer> map, List<Map.Entry<String, Integer>> baseref) {\n+        var ref = new ArrayList<>(baseref);\n+        ref.add(Map.entry(\"x\", 99));\n+        (rev ? map.reversed() : map).merge(\"x\", 99, \/*unused*\/ (k, v) -> -1);\n+        checkContents(map, ref);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/BasicMap.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"}]}