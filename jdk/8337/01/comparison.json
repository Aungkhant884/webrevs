{"files":[{"patch":"@@ -152,0 +152,2 @@\n+      case Op_VectorMaskToLong:\n+        if (vlen > 64) return false;\n@@ -5475,2 +5477,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  predicate(UseSVE > 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+      case Op_VectorMaskToLong:\n+        if (vlen > 64) return false;\n@@ -3043,2 +3045,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  predicate(UseSVE > 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3812,0 +3812,13 @@\n+\/\/ SVE2 bitwise permute\n+#define INSN(NAME, opc)                                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn,  FloatRegister Zm) {  \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    f(0b01000101, 31, 24), f(T, 23, 22), f(0b0, 21);                                     \\\n+    rf(Zm, 16), f(0b1011, 15, 12), f(opc, 11, 10);                                       \\\n+    rf(Zn, 5), rf(Zd, 0);                                                                \\\n+  }\n+\n+  INSN(sve_bext, 0b00);\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-\/\/ Clobbers: rscratch1\n+\/\/ Clobbers: rscratch1 if hardware doesn't support FEAT_BITPERM.\n@@ -969,0 +969,2 @@\n+  \/\/ Example:   src = 0b01100101 10001101, bt = T_BYTE, lane_cnt = 16\n+  \/\/ Expected:  dst = 0x658D\n@@ -970,1 +972,2 @@\n-  \/\/ Pack the mask into vector with sequential bytes.\n+  \/\/ Convert the mask into vector with sequential bytes.\n+  \/\/ vtmp1 = 0x00010100 0x00010001 0x01000000 0x01010001\n@@ -976,11 +979,50 @@\n-  \/\/ Compress the lowest 8 bytes.\n-  fmovd(dst, vtmp1);\n-  bytemask_compress(dst);\n-  if (lane_cnt <= 8) return;\n-\n-  \/\/ Repeat on higher bytes and join the results.\n-  \/\/ Compress 8 bytes in each iteration.\n-  for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n-    sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n-    bytemask_compress(rscratch1);\n-    orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+  if (UseSVE > 0 && !VM_Version::supports_svebitperm()) {\n+    \/\/ Compress the lowest 8 bytes.\n+    fmovd(dst, vtmp1);\n+    bytemask_compress(dst);\n+    if (lane_cnt <= 8) return;\n+\n+    \/\/ Repeat on higher bytes and join the results.\n+    \/\/ Compress 8 bytes in each iteration.\n+    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n+      sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n+      bytemask_compress(rscratch1);\n+      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+    }\n+  } else if (UseSVE == 2 && VM_Version::supports_svebitperm()) {\n+    \/\/ Given by the vector with value 0x00 or 0x01 in each byte, the basic idea\n+    \/\/ is to compress each significant bit of the byte in a cross-lane way. Due\n+    \/\/ to the lack of cross-lane bit-compress instruction, here we use BEXT\n+    \/\/ (bit-compress in each lane) with the biggest lane size (T = D) and\n+    \/\/ concatenates the results then.\n+\n+    \/\/ The second source input of BEXT, initialized with 0x01 in each byte.\n+    \/\/ vtmp2 = 0x01010101 0x01010101 0x01010101 0x01010101\n+    sve_dup(vtmp2, B, 1);\n+\n+    \/\/ BEXT vtmp1.D, vtmp1.D, vtmp2.D\n+    \/\/ vtmp1 = 0x0001010000010001 | 0x0100000001010001\n+    \/\/ vtmp2 = 0x0101010101010101 | 0x0101010101010101\n+    \/\/         ---------------------------------------\n+    \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n+    sve_bext(vtmp1, D, vtmp1, vtmp2);\n+\n+    \/\/ Concatenate the lowest significant 8 bits in each 8 bytes, and extract the\n+    \/\/ result to dst.\n+    \/\/ vtmp1 = 0x0000000000000000 | 0x000000000000658D\n+    \/\/ dst   = 0x658D\n+    if (lane_cnt <= 8) {\n+      \/\/ No need to concatenate.\n+      umov(dst, vtmp1, B, 0);\n+    } else if (lane_cnt <= 16) {\n+      ins(vtmp1, B, vtmp1, 1, 8);\n+      umov(dst, vtmp1, H, 0);\n+    } else {\n+      \/\/ As the lane count is 64 at most, the final expected value must be in\n+      \/\/ the lowest 64 bits after narrowing vtmp1 from D to B.\n+      sve_vector_narrow(vtmp1, B, vtmp1, D, vtmp2);\n+      umov(dst, vtmp1, D, 0);\n+    }\n+  } else {\n+    assert(false, \"unsupported\");\n+    ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,0 +278,3 @@\n+\/\/\n+CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1897,0 +1897,2 @@\n+                       # SVE2 instructions\n+                       [\"bext\", \"ZZZ\"],\n@@ -1907,2 +1909,3 @@\n-# compile for sve with 8.3 and sha3 because of SHA3 crypto extension.\n-subprocess.check_call([AARCH64_AS, \"-march=armv8.3-a+sha3+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n+# compile for sve with armv9-a+sha3+sve2-bitperm because of SHA3 crypto extension and SVE2 bitperm instructions.\n+# armv9-a enables sve and sve2 by default.\n+subprocess.check_call([AARCH64_AS, \"-march=armv9-a+sha3+sve2-bitperm\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1186,0 +1186,1 @@\n+    __ sve_bext(z21, __ B, z21, z1);                   \/\/       bext    z21.b, z21.b, z1.b\n@@ -1188,9 +1189,9 @@\n-    __ sve_andv(v21, __ B, p5, z1);                    \/\/       andv b21, p5, z1.b\n-    __ sve_orv(v10, __ S, p5, z11);                    \/\/       orv s10, p5, z11.s\n-    __ sve_eorv(v23, __ D, p6, z8);                    \/\/       eorv d23, p6, z8.d\n-    __ sve_smaxv(v17, __ S, p5, z19);                  \/\/       smaxv s17, p5, z19.s\n-    __ sve_sminv(v4, __ D, p5, z13);                   \/\/       sminv d4, p5, z13.d\n-    __ sve_fminv(v22, __ D, p7, z30);                  \/\/       fminv d22, p7, z30.d\n-    __ sve_fmaxv(v17, __ S, p4, z14);                  \/\/       fmaxv s17, p4, z14.s\n-    __ sve_fadda(v12, __ S, p7, z20);                  \/\/       fadda s12, p7, s12, z20.s\n-    __ sve_uaddv(v1, __ B, p3, z13);                   \/\/       uaddv d1, p3, z13.b\n+    __ sve_andv(v10, __ S, p5, z11);                   \/\/       andv s10, p5, z11.s\n+    __ sve_orv(v23, __ D, p6, z8);                     \/\/       orv d23, p6, z8.d\n+    __ sve_eorv(v17, __ S, p5, z19);                   \/\/       eorv s17, p5, z19.s\n+    __ sve_smaxv(v4, __ D, p5, z13);                   \/\/       smaxv d4, p5, z13.d\n+    __ sve_sminv(v22, __ D, p7, z30);                  \/\/       sminv d22, p7, z30.d\n+    __ sve_fminv(v17, __ S, p4, z14);                  \/\/       fminv s17, p4, z14.s\n+    __ sve_fmaxv(v12, __ S, p7, z20);                  \/\/       fmaxv s12, p7, z20.s\n+    __ sve_fadda(v1, __ S, p3, z13);                   \/\/       fadda s1, p3, s1, z13.s\n+    __ sve_uaddv(v7, __ S, p2, z11);                   \/\/       uaddv d7, p2, z11.s\n@@ -1215,7 +1216,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003e4,     0x94000000,\n-    0x97ffffd4,     0x940003e1,     0x3400000a,     0x34fffa2a,\n-    0x34007bca,     0x35000008,     0x35fff9c8,     0x35007b68,\n-    0xb400000b,     0xb4fff96b,     0xb4007b0b,     0xb500001d,\n-    0xb5fff91d,     0xb5007abd,     0x10000013,     0x10fff8b3,\n-    0x10007a53,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363079d6,     0x3758000c,     0x375ff7cc,     0x3758796c,\n+    0x14000000,     0x17ffffd7,     0x140003e5,     0x94000000,\n+    0x97ffffd4,     0x940003e2,     0x3400000a,     0x34fffa2a,\n+    0x34007bea,     0x35000008,     0x35fff9c8,     0x35007b88,\n+    0xb400000b,     0xb4fff96b,     0xb4007b2b,     0xb500001d,\n+    0xb5fff91d,     0xb5007add,     0x10000013,     0x10fff8b3,\n+    0x10007a73,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363079f6,     0x3758000c,     0x375ff7cc,     0x3758798c,\n@@ -1226,13 +1227,13 @@\n-    0x54007740,     0x54000001,     0x54fff541,     0x540076e1,\n-    0x54000002,     0x54fff4e2,     0x54007682,     0x54000002,\n-    0x54fff482,     0x54007622,     0x54000003,     0x54fff423,\n-    0x540075c3,     0x54000003,     0x54fff3c3,     0x54007563,\n-    0x54000004,     0x54fff364,     0x54007504,     0x54000005,\n-    0x54fff305,     0x540074a5,     0x54000006,     0x54fff2a6,\n-    0x54007446,     0x54000007,     0x54fff247,     0x540073e7,\n-    0x54000008,     0x54fff1e8,     0x54007388,     0x54000009,\n-    0x54fff189,     0x54007329,     0x5400000a,     0x54fff12a,\n-    0x540072ca,     0x5400000b,     0x54fff0cb,     0x5400726b,\n-    0x5400000c,     0x54fff06c,     0x5400720c,     0x5400000d,\n-    0x54fff00d,     0x540071ad,     0x5400000e,     0x54ffefae,\n-    0x5400714e,     0x5400000f,     0x54ffef4f,     0x540070ef,\n+    0x54007760,     0x54000001,     0x54fff541,     0x54007701,\n+    0x54000002,     0x54fff4e2,     0x540076a2,     0x54000002,\n+    0x54fff482,     0x54007642,     0x54000003,     0x54fff423,\n+    0x540075e3,     0x54000003,     0x54fff3c3,     0x54007583,\n+    0x54000004,     0x54fff364,     0x54007524,     0x54000005,\n+    0x54fff305,     0x540074c5,     0x54000006,     0x54fff2a6,\n+    0x54007466,     0x54000007,     0x54fff247,     0x54007407,\n+    0x54000008,     0x54fff1e8,     0x540073a8,     0x54000009,\n+    0x54fff189,     0x54007349,     0x5400000a,     0x54fff12a,\n+    0x540072ea,     0x5400000b,     0x54fff0cb,     0x5400728b,\n+    0x5400000c,     0x54fff06c,     0x5400722c,     0x5400000d,\n+    0x54fff00d,     0x540071cd,     0x5400000e,     0x54ffefae,\n+    0x5400716e,     0x5400000f,     0x54ffef4f,     0x5400710f,\n@@ -1462,3 +1463,3 @@\n-    0x05776f59,     0x041a3435,     0x0498356a,     0x04d93917,\n-    0x04883671,     0x04ca35a4,     0x65c73fd6,     0x658631d1,\n-    0x65983e8c,     0x04012da1,\n+    0x05776f59,     0x4501b2b5,     0x049a356a,     0x04d83917,\n+    0x04993671,     0x04c835a4,     0x04ca3fd6,     0x658731d1,\n+    0x65863e8c,     0x65982da1,     0x04812967,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"}]}