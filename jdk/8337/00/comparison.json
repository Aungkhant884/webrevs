{"files":[{"patch":"@@ -152,0 +152,2 @@\n+      case Op_VectorMaskToLong:\n+        if (vlen > 64) return false;\n@@ -5277,2 +5279,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  predicate(UseSVE > 0 && !VM_Version::supports_svebitperm());\n@@ -5293,0 +5294,17 @@\n+instruct vmask_tolong_sve2(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE == 2 && VM_Version::supports_svebitperm());\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP vtmp1, TEMP vtmp2);\n+  ins_cost(9 * SVE_COST);\n+  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve2)\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n+                        \/* no tmp preg required for sve2 *\/ pnoreg);\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+      case Op_VectorMaskToLong:\n+        if (vlen > 64) return false;\n@@ -2868,2 +2870,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  predicate(UseSVE > 0 && !VM_Version::supports_svebitperm());\n@@ -2884,0 +2885,17 @@\n+instruct vmask_tolong_sve2(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE == 2 && VM_Version::supports_svebitperm());\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP vtmp1, TEMP vtmp2);\n+  ins_cost(9 * SVE_COST);\n+  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve2)\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n+                        \/* no tmp preg required for sve2 *\/ pnoreg);\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3752,0 +3752,13 @@\n+\/\/ SVE2 bitwise permute\n+#define INSN(NAME, opc)                                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn,  FloatRegister Zm) {  \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    f(0b01000101, 31, 24), f(T, 23, 22), f(0b0, 21);                                     \\\n+    rf(Zm, 16), f(0b1011, 15, 12); f(opc, 11, 10);                                       \\\n+    rf(Zn, 5), rf(Zd, 0);                                                                \\\n+  }\n+\n+  INSN(sve_bext, 0b00);\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -961,1 +961,2 @@\n-\/\/ Clobbers: rscratch1\n+\/\/ pgtmp would not be used if UseSVE=2 and the hardware supports FEAT_BITPERM.\n+\/\/ Clobbers: rscratch1 if hardware not supports FEAT_BITPERM.\n@@ -964,1 +965,0 @@\n-  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register.\");\n@@ -969,0 +969,2 @@\n+  \/\/ Example:   src = 0b01100101 10001101, bt = T_BYTE, lane_cnt = 16\n+  \/\/ Expected:  dst = 0x658D\n@@ -970,1 +972,2 @@\n-  \/\/ Pack the mask into vector with sequential bytes.\n+  \/\/ Convert the mask into vector with sequential bytes.\n+  \/\/ vtmp1 = 0x00010100 0x00010001 0x01000000 0x01010001\n@@ -976,11 +979,44 @@\n-  \/\/ Compress the lowest 8 bytes.\n-  fmovd(dst, vtmp1);\n-  bytemask_compress(dst);\n-  if (lane_cnt <= 8) return;\n-\n-  \/\/ Repeat on higher bytes and join the results.\n-  \/\/ Compress 8 bytes in each iteration.\n-  for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n-    idx == 1 ? fmovhid(rscratch1, vtmp1) : sve_extract(rscratch1, D, pgtmp, vtmp1, idx);\n-    bytemask_compress(rscratch1);\n-    orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+  if (UseSVE > 0 && !VM_Version::supports_svebitperm()) {\n+    assert(pgtmp->is_governing(), \"This register has to be a governing predicate register.\");\n+    \/\/ Compress the lowest 8 bytes.\n+    fmovd(dst, vtmp1);\n+    bytemask_compress(dst);\n+    if (lane_cnt <= 8) return;\n+\n+    \/\/ Repeat on higher bytes and join the results.\n+    \/\/ Compress 8 bytes in each iteration.\n+    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n+      idx == 1 ? fmovhid(rscratch1, vtmp1) : sve_extract(rscratch1, D, pgtmp, vtmp1, idx);\n+      bytemask_compress(rscratch1);\n+      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+    }\n+  } else if (UseSVE == 2 && VM_Version::supports_svebitperm()) {\n+    \/\/ The second source input of BEXT, initialized with byte 0x01 in each lane.\n+    \/\/ vtmp2 = 0x01010101 0x01010101 0x01010101 0x01010101\n+    sve_dup(vtmp2, B, 1);\n+\n+    \/\/ BEXT vtmp1.D, vtmp1.D, vtmp2.D\n+    \/\/ vtmp1 = 0x0001010000010001 | 0x0100000001010001\n+    \/\/ vtmp2 = 0x0101010101010101 | 0x0101010101010101\n+    \/\/         ---------------------------------------\n+    \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n+    sve_bext(vtmp1, D, vtmp1, vtmp2);\n+\n+    \/\/ Concatenate the lowest significant 8 bits in each lane(T=D), and extract the result to dst.\n+    \/\/ vtmp1 = 0x0000000000000000 | 0x000000000000658D\n+    \/\/ dst   = 0x658D\n+    if (lane_cnt <= 8) {\n+      \/\/ No need to concatenate.\n+      umov(dst, vtmp1, B, 0);\n+    } else if (lane_cnt <= 16) {\n+      ins(vtmp1, B, vtmp1, 1, 8);\n+      umov(dst, vtmp1, H, 0);\n+    } else {\n+      \/\/ As the lane count is LE 64, the final expected value must be in lane[0] after\n+      \/\/ narrowing vtmp1 from D to B.\n+      sve_vector_narrow(vtmp1, B, vtmp1, D, vtmp2);\n+      umov(dst, vtmp1, D, 0);\n+    }\n+  } else {\n+    assert(false, \"unsupported\");\n+    ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":50,"deletions":14,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,0 +278,3 @@\n+\/\/\n+CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1783,0 +1783,5 @@\n+                        # SVE2 instructions\n+                        [\"bext\",    \"__ sve_bext(z16, __ B, z16, z17);\",                  \"bext\\tz16.b, z16.b, z17.b\"],\n+                        [\"bext\",    \"__ sve_bext(z16, __ H, z16, z17);\",                  \"bext\\tz16.h, z16.h, z17.h\"],\n+                        [\"bext\",    \"__ sve_bext(z16, __ S, z16, z17);\",                  \"bext\\tz16.s, z16.s, z17.s\"],\n+                        [\"bext\",    \"__ sve_bext(z16, __ D, z16, z17);\",                  \"bext\\tz16.d, z16.d, z17.d\"],\n@@ -1875,2 +1880,3 @@\n-# compile for sve with 8.3 and sha3 because of SHA3 crypto extension.\n-subprocess.check_call([AARCH64_AS, \"-march=armv8.3-a+sha3+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n+# compile for sve with armv9-a+sha3+sve2-bitperm because of SHA3 crypto extension and SVE2 bitperm instructions.\n+# armv9-a enables sve and sve2 by default.\n+subprocess.check_call([AARCH64_AS, \"-march=armv9-a+sha3+sve2-bitperm\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -942,0 +942,4 @@\n+    __ sve_bext(z16, __ B, z16, z17);                  \/\/       bext    z16.b, z16.b, z17.b\n+    __ sve_bext(z16, __ H, z16, z17);                  \/\/       bext    z16.h, z16.h, z17.h\n+    __ sve_bext(z16, __ S, z16, z17);                  \/\/       bext    z16.s, z16.s, z17.s\n+    __ sve_bext(z16, __ D, z16, z17);                  \/\/       bext    z16.d, z16.d, z17.d\n@@ -1198,7 +1202,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003d5,     0x94000000,\n-    0x97ffffd4,     0x940003d2,     0x3400000a,     0x34fffa2a,\n-    0x340079ea,     0x35000008,     0x35fff9c8,     0x35007988,\n-    0xb400000b,     0xb4fff96b,     0xb400792b,     0xb500001d,\n-    0xb5fff91d,     0xb50078dd,     0x10000013,     0x10fff8b3,\n-    0x10007873,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363077f6,     0x3758000c,     0x375ff7cc,     0x3758778c,\n+    0x14000000,     0x17ffffd7,     0x140003d9,     0x94000000,\n+    0x97ffffd4,     0x940003d6,     0x3400000a,     0x34fffa2a,\n+    0x34007a6a,     0x35000008,     0x35fff9c8,     0x35007a08,\n+    0xb400000b,     0xb4fff96b,     0xb40079ab,     0xb500001d,\n+    0xb5fff91d,     0xb500795d,     0x10000013,     0x10fff8b3,\n+    0x100078f3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307876,     0x3758000c,     0x375ff7cc,     0x3758780c,\n@@ -1209,13 +1213,13 @@\n-    0x54007560,     0x54000001,     0x54fff541,     0x54007501,\n-    0x54000002,     0x54fff4e2,     0x540074a2,     0x54000002,\n-    0x54fff482,     0x54007442,     0x54000003,     0x54fff423,\n-    0x540073e3,     0x54000003,     0x54fff3c3,     0x54007383,\n-    0x54000004,     0x54fff364,     0x54007324,     0x54000005,\n-    0x54fff305,     0x540072c5,     0x54000006,     0x54fff2a6,\n-    0x54007266,     0x54000007,     0x54fff247,     0x54007207,\n-    0x54000008,     0x54fff1e8,     0x540071a8,     0x54000009,\n-    0x54fff189,     0x54007149,     0x5400000a,     0x54fff12a,\n-    0x540070ea,     0x5400000b,     0x54fff0cb,     0x5400708b,\n-    0x5400000c,     0x54fff06c,     0x5400702c,     0x5400000d,\n-    0x54fff00d,     0x54006fcd,     0x5400000e,     0x54ffefae,\n-    0x54006f6e,     0x5400000f,     0x54ffef4f,     0x54006f0f,\n+    0x540075e0,     0x54000001,     0x54fff541,     0x54007581,\n+    0x54000002,     0x54fff4e2,     0x54007522,     0x54000002,\n+    0x54fff482,     0x540074c2,     0x54000003,     0x54fff423,\n+    0x54007463,     0x54000003,     0x54fff3c3,     0x54007403,\n+    0x54000004,     0x54fff364,     0x540073a4,     0x54000005,\n+    0x54fff305,     0x54007345,     0x54000006,     0x54fff2a6,\n+    0x540072e6,     0x54000007,     0x54fff247,     0x54007287,\n+    0x54000008,     0x54fff1e8,     0x54007228,     0x54000009,\n+    0x54fff189,     0x540071c9,     0x5400000a,     0x54fff12a,\n+    0x5400716a,     0x5400000b,     0x54fff0cb,     0x5400710b,\n+    0x5400000c,     0x54fff06c,     0x540070ac,     0x5400000d,\n+    0x54fff00d,     0x5400704d,     0x5400000e,     0x54ffefae,\n+    0x54006fee,     0x5400000f,     0x54ffef4f,     0x54006f8f,\n@@ -1393,1 +1397,2 @@\n-    0x05e14c00,     0x05304001,     0x05314001,     0x1e601000,\n+    0x05e14c00,     0x05304001,     0x05314001,     0x4511b210,\n+    0x4551b210,     0x4591b210,     0x45d1b210,     0x1e601000,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"}]}