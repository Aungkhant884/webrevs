{"files":[{"patch":"@@ -489,1 +489,4 @@\n-        try {\n+        long secs = startInclusive.until(endExclusive, SECONDS);\n+        if (secs == 0) {\n+            \/\/ We don't know which Temporal is earlier, so the adjustment below would not work.\n+            \/\/ But we do know that there's no danger of until(NANOS) overflowing in that case.\n@@ -491,14 +494,0 @@\n-        } catch (DateTimeException | ArithmeticException ex) {\n-            long secs = startInclusive.until(endExclusive, SECONDS);\n-            long nanos;\n-            try {\n-                nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);\n-                if (secs > 0 && nanos < 0) {\n-                    secs++;\n-                } else if (secs < 0 && nanos > 0) {\n-                    secs--;\n-                }\n-            } catch (DateTimeException ex2) {\n-                nanos = 0;\n-            }\n-            return ofSeconds(secs, nanos);\n@@ -506,0 +495,14 @@\n+        long nanos;\n+        try {\n+            nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);\n+        } catch (DateTimeException ex2) {\n+            nanos = 0;\n+        }\n+        if (nanos < 0 && secs > 0) {\n+            \/\/ ofSeconds will subtract one even though until(SECONDS) already gave the correct\n+            \/\/ number of seconds. So compensate. Similarly for the secs < 0 case below.\n+            secs++;\n+        } else if (nanos > 0 && secs < 0) {\n+            secs--;\n+        }\n+        return ofSeconds(secs, nanos);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"}]}