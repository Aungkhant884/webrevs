{"files":[{"patch":"@@ -1857,2 +1857,2 @@\n-        public BindingSymbol(Name name, Type type, Symbol owner) {\n-            super(Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n+        public BindingSymbol(long flags, Name name, Type type, Symbol owner) {\n+            super(flags | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -392,1 +392,2 @@\n-                sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {\n+                sym.getKind() == ElementKind.EXCEPTION_PARAMETER ||\n+                sym.getKind() == ElementKind.BINDING_VARIABLE) {\n@@ -1267,0 +1268,5 @@\n+            } else if (tree.sym.getKind() == ElementKind.BINDING_VARIABLE) {\n+                final TypeAnnotationPosition pos =\n+                    TypeAnnotationPosition.localVariable(currentLambda,\n+                                                         tree.pos);\n+                separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3988,1 +3988,1 @@\n-        BindingSymbol v = new BindingSymbol(tree.var.name, tree.var.vartype.type, env.info.scope.owner);\n+        BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.var.vartype.type, env.info.scope.owner);\n@@ -3994,0 +3994,1 @@\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n@@ -5749,1 +5750,1 @@\n-                that.var.sym = new BindingSymbol(that.var.name, that.var.type, syms.noSymbol);\n+                that.var.sym = new BindingSymbol(0, that.var.name, that.var.type, syms.noSymbol);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -936,1 +936,2 @@\n-                JCExpression type = parseType();\n+                JCModifiers mods = optFinal(0);\n+                JCExpression type = unannotatedType(false);\n@@ -940,1 +941,0 @@\n-                    JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n@@ -946,0 +946,13 @@\n+                    if (mods.annotations.nonEmpty()) {\n+                        checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n+                        List<JCAnnotation> typeAnnos =\n+                                mods.annotations\n+                                    .map(decl -> {\n+                                        JCAnnotation typeAnno = F.at(decl.pos)\n+                                                                 .TypeAnnotation(decl.annotationType,\n+                                                                                  decl.args);\n+                                        endPosTable.replaceTree(decl, typeAnno);\n+                                        return typeAnno;\n+                                    });\n+                        type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256266\n+ * @summary Verify annotations work correctly on binding variables\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build JavacTestingAbstractProcessor\n+ * @compile Annotations.java\n+ * @compile -processor Annotations -proc:only Annotations.java\n+ * @run main Annotations\n+ *\/\n+\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.util.TreePath;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.util.Set;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.tree.BindingPatternTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import com.sun.tools.classfile.*;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+public class Annotations extends JavacTestingAbstractProcessor {\n+    public static void main(String... args) throws Exception {\n+        new Annotations().run();\n+    }\n+\n+    void run() throws Exception {\n+        InputStream annotationsClass =\n+                Annotations.class.getResourceAsStream(\"Annotations.class\");\n+        ClassFile cf = ClassFile.read(annotationsClass);\n+        for (Method m : cf.methods) {\n+            if (\"test\".equals(cf.constant_pool.getUTF8Value(m.name_index))) {\n+                Code_attribute codeAttr =\n+                        (Code_attribute) m.attributes.map.get(Attribute.Code);\n+                Attribute annoAttr =\n+                        codeAttr.attributes.map.get(Attribute.RuntimeInvisibleTypeAnnotations);\n+                RuntimeInvisibleTypeAnnotations_attribute annotations =\n+                        (RuntimeInvisibleTypeAnnotations_attribute) annoAttr;\n+                String expected = \"[@Annotations$DTA; pos: [LOCAL_VARIABLE, {start_pc = 35, length = 7, index = 1}, pos = -1], \" +\n+                                  \"@Annotations$TA; pos: [LOCAL_VARIABLE, {start_pc = 56, length = 7, index = 1}, pos = -1]]\";\n+                String actual = Arrays.toString(annotations.annotations);\n+                if (!expected.equals(actual)) {\n+                    throw new AssertionError(\"Unexpected type annotations: \" +\n+                                              actual);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void test(Object o) {\n+        if (o instanceof @DA String da) {\n+            System.err.println(da);\n+        }\n+        if (o instanceof @DTA String dta) {\n+            System.err.println(dta);\n+        }\n+        if (o instanceof @TA String ta) {\n+            System.err.println(ta);\n+        }\n+    }\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        Trees trees = Trees.instance(processingEnv);\n+\n+        for (Element root : roundEnv.getRootElements()) {\n+            TreePath tp = trees.getPath(root);\n+            new TreePathScanner<Void, Void>() {\n+                @Override\n+                public Void visitInstanceOf(InstanceOfTree node, Void p) {\n+                    BindingPatternTree bpt = (BindingPatternTree) node.getPattern();\n+                    VariableTree var = bpt.getVariable();\n+                    Element varEl = trees.getElement(new TreePath(getCurrentPath(), var));\n+                    String expectedDeclAnnos;\n+                    String expectedType;\n+                    switch (var.getName().toString()) {\n+                        case \"da\" -> {\n+                            expectedDeclAnnos = \"@Annotations.DA\";\n+                            expectedType = \"java.lang.String\";\n+                        }\n+                        case \"dta\" -> {\n+                            expectedDeclAnnos = \"@Annotations.DTA\";\n+                            expectedType = \"@Annotations.DTA java.lang.String\";\n+                        }\n+                        case \"ta\" -> {\n+                            expectedDeclAnnos = \"\";\n+                            expectedType = \"@Annotations.TA java.lang.String\";\n+                        }\n+                        default -> {\n+                            throw new AssertionError(\"Unexpected variable: \" + var);\n+                        }\n+                    }\n+                    String declAnnos = varEl.getAnnotationMirrors().toString();\n+                    if (!expectedDeclAnnos.equals(declAnnos)) {\n+                        throw new AssertionError(\"Unexpected modifiers: \" + declAnnos +\n+                                                  \" for: \" + var.getName());\n+                    }\n+                    TypeMirror varType = varEl.asType();\n+                    String type = varType.toString();\n+                    if (!expectedType.equals(type)) {\n+                        throw new AssertionError(\"Unexpected type: \" + type +\n+                                                  \" for: \" + var.getName());\n+                    }\n+                    return super.visitInstanceOf(node, p);\n+                }\n+            }.scan(tp.getCompilationUnit(), null);\n+        }\n+        return false;\n+    }\n+\n+    @Target(ElementType.LOCAL_VARIABLE)\n+    @interface DA {}\n+    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n+    @interface DTA {}\n+    @Target(ElementType.TYPE_USE)\n+    @interface TA {}\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -188,0 +188,15 @@\n+        if (o1 instanceof final String s) {\n+            Runnable r1 = new Runnable() {\n+                @Override\n+                public void run() {\n+                    s.length();\n+                }\n+            };\n+            r1.run();\n+            Runnable r2 = () -> {\n+                s.length();\n+            };\n+            r2.run();\n+            String s2 = s;\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest1.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -244,0 +244,6 @@\n+\n+        {\n+            if (o1 instanceof final String s) {\n+                s = \"\";\n+            }\n+        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest2.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+BindingsTest2.java:247:17: compiler.err.cant.assign.val.to.final.var: s\n@@ -52,1 +53,1 @@\n-51 errors\n\\ No newline at end of file\n+52 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest2.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @bug 8256266\n+ * @summary Binding variables cannot have (non-annotation) modifiers.\n+ * @compile\/fail\/ref=NoModifiersOnBinding.out -XDrawDiagnostics NoModifiersOnBinding.java\n+ *\/\n+\n+public class NoModifiersOnBinding {\n+\n+    private static void test(Object o) {\n+        if (o instanceof static String s) {\n+            System.err.println(s);\n+        }\n+        if (o instanceof \/**@deprecated*\/ String s) {\n+            System.err.println(s);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoModifiersOnBinding.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+NoModifiersOnBinding.java:10:33: compiler.err.mod.not.allowed.here: static\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoModifiersOnBinding.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}