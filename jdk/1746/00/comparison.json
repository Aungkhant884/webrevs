{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,410 @@\n+\/\/ TODO -- currently, even if all JIT compilers are disabled, the following flags\n+\/\/ are still available in HotSpot. This should eventually be fixed ...\n+\n+#define COMPILER_FLAGS(develop,                                             \\\n+                       develop_pd,                                          \\\n+                       product,                                             \\\n+                       product_pd,                                          \\\n+                       notproduct,                                          \\\n+                       range,                                               \\\n+                       constraint)                                          \\\n+                                                                            \\\n+  \/* compiler interface *\/                                                  \\\n+                                                                            \\\n+  develop(bool, CIPrintCompilerName, false,                                 \\\n+          \"when CIPrint is active, print the name of the active compiler\")  \\\n+                                                                            \\\n+  product(bool, CIPrintCompileQueue, false, DIAGNOSTIC,                     \\\n+          \"display the contents of the compile queue whenever a \"           \\\n+          \"compilation is enqueued\")                                        \\\n+                                                                            \\\n+  develop(bool, CIPrintRequests, false,                                     \\\n+          \"display every request for compilation\")                          \\\n+                                                                            \\\n+  product(bool, CITime, false,                                              \\\n+          \"collect timing information for compilation\")                     \\\n+                                                                            \\\n+  develop(bool, CITimeVerbose, false,                                       \\\n+          \"be more verbose in compilation timings\")                         \\\n+                                                                            \\\n+  develop(bool, CITimeEach, false,                                          \\\n+          \"display timing information after each successful compilation\")   \\\n+                                                                            \\\n+  develop(bool, CICountOSR, false,                                          \\\n+          \"use a separate counter when assigning ids to osr compilations\")  \\\n+                                                                            \\\n+  develop(bool, CICompileNatives, true,                                     \\\n+          \"compile native methods if supported by the compiler\")            \\\n+                                                                            \\\n+  develop_pd(bool, CICompileOSR,                                            \\\n+          \"compile on stack replacement methods if supported by the \"       \\\n+          \"compiler\")                                                       \\\n+                                                                            \\\n+  develop(bool, CIPrintMethodCodes, false,                                  \\\n+          \"print method bytecodes of the compiled code\")                    \\\n+                                                                            \\\n+  develop(bool, CIPrintTypeFlow, false,                                     \\\n+          \"print the results of ciTypeFlow analysis\")                       \\\n+                                                                            \\\n+  develop(bool, CITraceTypeFlow, false,                                     \\\n+          \"detailed per-bytecode tracing of ciTypeFlow analysis\")           \\\n+                                                                            \\\n+  product(bool, CICompilerCountPerCPU, false,                               \\\n+          \"1 compiler thread for log(N CPUs)\")                              \\\n+                                                                            \\\n+  notproduct(intx, CICrashAt, -1,                                           \\\n+          \"id of compilation to trigger assert in compiler thread for \"     \\\n+          \"the purpose of testing, e.g. generation of replay data\")         \\\n+                                                                            \\\n+  notproduct(bool, CIObjectFactoryVerify, false,                            \\\n+          \"enable potentially expensive verification in ciObjectFactory\")   \\\n+                                                                            \\\n+  develop(intx, CIStart, 0,                                                 \\\n+          \"The id of the first compilation to permit\")                      \\\n+                                                                            \\\n+  develop(intx, CIStop, max_jint,                                           \\\n+          \"The id of the last compilation to permit\")                       \\\n+                                                                            \\\n+  develop(intx, CIStartOSR, 0,                                              \\\n+          \"The id of the first osr compilation to permit \"                  \\\n+          \"(CICountOSR must be on)\")                                        \\\n+                                                                            \\\n+  develop(intx, CIStopOSR, max_jint,                                        \\\n+          \"The id of the last osr compilation to permit \"                   \\\n+          \"(CICountOSR must be on)\")                                        \\\n+                                                                            \\\n+  develop(intx, CIBreakAtOSR, -1,                                           \\\n+          \"The id of osr compilation to break at\")                          \\\n+                                                                            \\\n+  develop(intx, CIBreakAt, -1,                                              \\\n+          \"The id of compilation to break at\")                              \\\n+                                                                            \\\n+  \/* recompilation *\/                                                       \\\n+                                                                            \\\n+  product(double, CompileThresholdScaling, 1.0,                             \\\n+          \"Factor to control when first compilation happens \"               \\\n+          \"(both with and without tiered compilation): \"                    \\\n+          \"values greater than 1.0 delay counter overflow, \"                \\\n+          \"values between 0 and 1.0 rush counter overflow, \"                \\\n+          \"value of 1.0 leaves compilation thresholds unchanged \"           \\\n+          \"value of 0.0 is equivalent to -Xint. \"                           \\\n+          \"\"                                                                \\\n+          \"Flag can be set as per-method option. \"                          \\\n+          \"If a value is specified for a method, compilation thresholds \"   \\\n+          \"for that method are scaled by both the value of the global flag \"\\\n+          \"and the value of the per-method flag.\")                          \\\n+          range(0.0, DBL_MAX)                                               \\\n+                                                                            \\\n+  product(intx, Tier0InvokeNotifyFreqLog, 7,                                \\\n+          \"Interpreter (tier 0) invocation notification frequency\")         \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier2InvokeNotifyFreqLog, 11,                               \\\n+          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier3InvokeNotifyFreqLog, 10,                               \\\n+          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n+          \"frequency\")                                                      \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier23InlineeNotifyFreqLog, 20,                             \\\n+          \"Inlinee invocation (tiers 2 and 3) notification frequency\")      \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \\\n+          \"Interpreter (tier 0) invocation notification frequency\")         \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \\\n+          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \\\n+          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n+          \"frequency\")                                                      \\\n+          range(0, 30)                                                      \\\n+                                                                            \\\n+  product(intx, Tier2CompileThreshold, 0,                                   \\\n+          \"threshold at which tier 2 compilation is invoked\")               \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier2BackEdgeThreshold, 0,                                  \\\n+          \"Back edge threshold at which tier 2 compilation is invoked\")     \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3InvocationThreshold, 200,                              \\\n+          \"Compile if number of method invocations crosses this \"           \\\n+          \"threshold\")                                                      \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3MinInvocationThreshold, 100,                           \\\n+          \"Minimum invocation to compile at tier 3\")                        \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3CompileThreshold, 2000,                                \\\n+          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n+          \"minimum must be satisfied)\")                                     \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3BackEdgeThreshold,  60000,                             \\\n+          \"Back edge threshold at which tier 3 OSR compilation is invoked\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3AOTInvocationThreshold, 10000,                         \\\n+          \"Compile if number of method invocations crosses this \"           \\\n+          \"threshold if coming from AOT\")                                   \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \\\n+          \"Minimum invocation to compile at tier 3 if coming from AOT\")     \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3AOTCompileThreshold, 15000,                            \\\n+          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n+          \"minimum must be satisfied) if coming from AOT\")                  \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \\\n+          \"Back edge threshold at which tier 3 OSR compilation is invoked \" \\\n+          \"if coming from AOT\")                                             \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier0AOTInvocationThreshold, 200, DIAGNOSTIC,               \\\n+          \"Switch to interpreter to profile if the number of method \"       \\\n+          \"invocations crosses this threshold if coming from AOT \"          \\\n+          \"(applicable only with \"                                          \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier0AOTMinInvocationThreshold, 100, DIAGNOSTIC,            \\\n+          \"Minimum number of invocations to switch to interpreter \"         \\\n+          \"to profile if coming from AOT \"                                  \\\n+          \"(applicable only with \"                                          \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier0AOTCompileThreshold, 2000, DIAGNOSTIC,                 \\\n+          \"Threshold at which to switch to interpreter to profile \"         \\\n+          \"if coming from AOT \"                                             \\\n+          \"(invocation minimum must be satisfied, \"                         \\\n+          \"applicable only with \"                                           \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier0AOTBackEdgeThreshold,  60000, DIAGNOSTIC,              \\\n+          \"Back edge threshold at which to switch to interpreter \"          \\\n+          \"to profile if coming from AOT \"                                  \\\n+          \"(applicable only with \"                                          \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier4InvocationThreshold, 5000,                             \\\n+          \"Compile if number of method invocations crosses this \"           \\\n+          \"threshold\")                                                      \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier4MinInvocationThreshold, 600,                           \\\n+          \"Minimum invocation to compile at tier 4\")                        \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier4CompileThreshold, 15000,                               \\\n+          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n+          \"minimum must be satisfied)\")                                     \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier4BackEdgeThreshold, 40000,                              \\\n+          \"Back edge threshold at which tier 4 OSR compilation is invoked\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier40InvocationThreshold, 5000, DIAGNOSTIC,                \\\n+          \"Compile if number of method invocations crosses this \"           \\\n+          \"threshold (applicable only with \"                                \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier40MinInvocationThreshold, 600, DIAGNOSTIC,              \\\n+          \"Minimum number of invocations to compile at tier 4 \"             \\\n+          \"(applicable only with \"                                          \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier40CompileThreshold, 10000, DIAGNOSTIC,                  \\\n+          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n+          \"minimum must be satisfied, applicable only with \"                \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier40BackEdgeThreshold, 15000, DIAGNOSTIC,                 \\\n+          \"Back edge threshold at which tier 4 OSR compilation is invoked \" \\\n+          \"(applicable only with \"                                          \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier0Delay, 5, DIAGNOSTIC,                                  \\\n+          \"If C2 queue size grows over this amount per compiler thread \"    \\\n+          \"do not start profiling in the interpreter \"                      \\\n+          \"(applicable only with \"                                          \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3DelayOn, 5,                                            \\\n+          \"If C2 queue size grows over this amount per compiler thread \"    \\\n+          \"stop compiling at tier 3 and start compiling at tier 2\")         \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3DelayOff, 2,                                           \\\n+          \"If C2 queue size is less than this amount per compiler thread \"  \\\n+          \"allow methods compiled at tier 2 transition to tier 3\")          \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier3LoadFeedback, 5,                                       \\\n+          \"Tier 3 thresholds will increase twofold when C1 queue size \"     \\\n+          \"reaches this amount per compiler thread\")                        \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, Tier4LoadFeedback, 3,                                       \\\n+          \"Tier 4 thresholds will increase twofold when C2 queue size \"     \\\n+          \"reaches this amount per compiler thread\")                        \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, TieredCompileTaskTimeout, 50,                               \\\n+          \"Kill compile task if method was not used within \"                \\\n+          \"given timeout in milliseconds\")                                  \\\n+          range(0, max_intx)                                                \\\n+                                                                            \\\n+  product(intx, TieredStopAtLevel, 4,                                       \\\n+          \"Stop at given compilation level\")                                \\\n+          range(0, 4)                                                       \\\n+                                                                            \\\n+  product(intx, Tier0ProfilingStartPercentage, 200,                         \\\n+          \"Start profiling in interpreter if the counters exceed tier 3 \"   \\\n+          \"thresholds (tier 4 thresholds with \"                             \\\n+          \"CompilationMode=high-only|high-only-quick-internal)\"             \\\n+          \"by the specified percentage\")                                    \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \\\n+          \"Increase the compile threshold for C1 compilation if the code \"  \\\n+          \"cache is filled by the specified percentage\")                    \\\n+          range(0, 99)                                                      \\\n+                                                                            \\\n+  product(intx, TieredRateUpdateMinTime, 1,                                 \\\n+          \"Minimum rate sampling interval (in milliseconds)\")               \\\n+          range(0, max_intx)                                                \\\n+                                                                            \\\n+  product(intx, TieredRateUpdateMaxTime, 25,                                \\\n+          \"Maximum rate sampling interval (in milliseconds)\")               \\\n+          range(0, max_intx)                                                \\\n+                                                                            \\\n+  product(ccstr, CompilationMode, \"default\",                                \\\n+          \"Compilation modes: \"                                             \\\n+          \"default: normal tiered compilation; \"                            \\\n+          \"quick-only: C1-only mode; \"                                      \\\n+          \"high-only: C2\/JVMCI-only mode; \"                                 \\\n+          \"high-only-quick-internal: C2\/JVMCI-only mode, \"                  \\\n+          \"with JVMCI compiler compiled with C1.\")                          \\\n+                                                                            \\\n+  product(bool, PrintTieredEvents, false,                                   \\\n+          \"Print tiered events notifications\")                              \\\n+                                                                            \\\n+  product_pd(intx, OnStackReplacePercentage,                                \\\n+          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n+          \"% of CompileThreshold) before (re-)compiling OSR code\")          \\\n+          constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \\\n+                                                                            \\\n+  product(intx, InterpreterProfilePercentage, 33,                           \\\n+          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n+          \"% of CompileThreshold) before profiling in the interpreter\")     \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  \/* compiler directives *\/                                                 \\\n+                                                                            \\\n+  product(ccstrlist, CompileOnly, \"\",                                       \\\n+          \"List of methods (pkg\/class.name) to restrict compilation to\")    \\\n+                                                                            \\\n+  product(ccstr, CompileCommandFile, NULL,                                  \\\n+          \"Read compiler commands from this file [.hotspot_compiler]\")      \\\n+                                                                            \\\n+  product(ccstr, CompilerDirectivesFile, NULL, DIAGNOSTIC,                  \\\n+          \"Read compiler directives from this file\")                        \\\n+                                                                            \\\n+  product(ccstrlist, CompileCommand, \"\",                                    \\\n+          \"Prepend to .hotspot_compiler; e.g. log,java\/lang\/String.<init>\") \\\n+                                                                            \\\n+  develop(bool, ReplayCompiles, false,                                      \\\n+          \"Enable replay of compilations from ReplayDataFile\")              \\\n+                                                                            \\\n+  product(ccstr, ReplayDataFile, NULL,                                      \\\n+          \"File containing compilation replay information\"                  \\\n+          \"[default: .\/replay_pid%p.log] (%p replaced with pid)\")           \\\n+                                                                            \\\n+  product(ccstr, InlineDataFile, NULL,                                      \\\n+          \"File containing inlining replay information\"                     \\\n+          \"[default: .\/inline_pid%p.log] (%p replaced with pid)\")           \\\n+                                                                            \\\n+  develop(intx, ReplaySuppressInitializers, 2,                              \\\n+          \"Control handling of class initialization during replay: \"        \\\n+          \"0 - don't do anything special; \"                                 \\\n+          \"1 - treat all class initializers as empty; \"                     \\\n+          \"2 - treat class initializers for application classes as empty; \" \\\n+          \"3 - allow all class initializers to run during bootstrap but \"   \\\n+          \"    pretend they are empty after starting replay\")               \\\n+          range(0, 3)                                                       \\\n+                                                                            \\\n+  develop(bool, ReplayIgnoreInitErrors, false,                              \\\n+          \"Ignore exceptions thrown during initialization for replay\")      \\\n+                                                                            \\\n+  product(bool, DumpReplayDataOnError, true,                                \\\n+          \"Record replay data for crashing compiler threads\")               \\\n+                                                                            \\\n+  product(bool, CompilerDirectivesIgnoreCompileCommands, false, DIAGNOSTIC, \\\n+             \"Disable backwards compatibility for compile commands.\")       \\\n+                                                                            \\\n+  product(bool, CompilerDirectivesPrint, false, DIAGNOSTIC,                 \\\n+             \"Print compiler directives on installation.\")                  \\\n+                                                                            \\\n+  product(int,  CompilerDirectivesLimit, 50, DIAGNOSTIC,                    \\\n+             \"Limit on number of compiler directives.\")                     \\\n+                                                                            \\\n+  \/* Bytecode escape analysis estimation. *\/                                \\\n+                                                                            \\\n+  product(bool, EstimateArgEscape, true,                                    \\\n+          \"Analyze bytecodes to estimate escape state of arguments\")        \\\n+                                                                            \\\n+  product(intx, BCEATraceLevel, 0,                                          \\\n+          \"How much tracing to do of bytecode escape analysis estimates \"   \\\n+          \"(0-3)\")                                                          \\\n+          range(0, 3)                                                       \\\n+                                                                            \\\n+  product(intx, MaxBCEAEstimateLevel, 5,                                    \\\n+          \"Maximum number of nested calls that are analyzed by BC EA\")      \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, MaxBCEAEstimateSize, 150,                                   \\\n+          \"Maximum bytecode size of a method to be analyzed by BC EA\")      \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  \/* misc compiler flags *\/                                                 \\\n+                                                                            \\\n+  product(bool, AbortVMOnCompilationFailure, false, DIAGNOSTIC,             \\\n+          \"Abort VM when method had failed to compile.\")                    \\\n+                                                                            \\\n+  develop(intx, OSROnlyBCI, -1,                                             \\\n+          \"OSR only at this bci.  Negative values mean exclude that bci\")   \\\n+                                                                            \\\n+  develop(intx, DesiredMethodLimit,  8000,                                  \\\n+          \"The desired maximum method size (in bytecodes) after inlining\")  \\\n+                                                                            \\\n+  product(bool, DontCompileHugeMethods, true,                               \\\n+          \"Do not compile methods > HugeMethodLimit\")                       \\\n+                                                                            \\\n+  develop(intx, HugeMethodLimit,  8000,                                     \\\n+          \"Don't compile methods larger than this if \"                      \\\n+          \"+DontCompileHugeMethods\")                                        \\\n+                                                                            \\\n+\n+\/\/ end of COMPILER_FLAGS\n+\n+DECLARE_FLAGS(COMPILER_FLAGS)\n+\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":410,"deletions":0,"binary":false,"changes":410,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/invocationCounter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -29,0 +30,41 @@\n+MethodCounters::MethodCounters(const methodHandle& mh) :\n+#if INCLUDE_AOT\n+  _method(mh()),\n+#endif\n+  _nmethod_age(INT_MAX)\n+#ifdef TIERED\n+  , _rate(0),\n+  _prev_time(0),\n+  _highest_comp_level(0),\n+  _highest_osr_comp_level(0)\n+#endif\n+{\n+  set_interpreter_invocation_count(0);\n+  set_interpreter_throwout_count(0);\n+  JVMTI_ONLY(clear_number_of_breakpoints());\n+  invocation_counter()->init();\n+  backedge_counter()->init();\n+\n+  if (StressCodeAging) {\n+    set_nmethod_age(HotMethodDetectionLimit);\n+  }\n+\n+  \/\/ Set per-method thresholds.\n+  double scale = 1.0;\n+  CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n+\n+  int compile_threshold = CompilerConfig::scaled_compile_threshold(CompileThreshold, scale);\n+  _interpreter_invocation_limit = compile_threshold << InvocationCounter::count_shift;\n+  if (ProfileInterpreter) {\n+    \/\/ If interpreter profiling is enabled, the backward branch limit\n+    \/\/ is compared against the method data counter rather than an invocation\n+    \/\/ counter, therefore no shifting of bits is required.\n+    _interpreter_backward_branch_limit = (int)((int64_t)compile_threshold * (OnStackReplacePercentage - InterpreterProfilePercentage) \/ 100);\n+  } else {\n+    _interpreter_backward_branch_limit = (int)(((int64_t)compile_threshold * OnStackReplacePercentage \/ 100) << InvocationCounter::count_shift);\n+  }\n+  _interpreter_profile_limit = ((compile_threshold * InterpreterProfilePercentage) \/ 100) << InvocationCounter::count_shift;\n+  _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n+  _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/methodCounters.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -73,40 +73,1 @@\n-  MethodCounters(const methodHandle& mh) :\n-#if INCLUDE_AOT\n-                                    _method(mh()),\n-#endif\n-                                    _nmethod_age(INT_MAX)\n-#ifdef TIERED\n-                                 , _rate(0),\n-                                   _prev_time(0),\n-                                   _highest_comp_level(0),\n-                                   _highest_osr_comp_level(0)\n-#endif\n-  {\n-    set_interpreter_invocation_count(0);\n-    set_interpreter_throwout_count(0);\n-    JVMTI_ONLY(clear_number_of_breakpoints());\n-    invocation_counter()->init();\n-    backedge_counter()->init();\n-\n-    if (StressCodeAging) {\n-      set_nmethod_age(HotMethodDetectionLimit);\n-    }\n-\n-    \/\/ Set per-method thresholds.\n-    double scale = 1.0;\n-    CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n-\n-    int compile_threshold = CompilerConfig::scaled_compile_threshold(CompileThreshold, scale);\n-    _interpreter_invocation_limit = compile_threshold << InvocationCounter::count_shift;\n-    if (ProfileInterpreter) {\n-      \/\/ If interpreter profiling is enabled, the backward branch limit\n-      \/\/ is compared against the method data counter rather than an invocation\n-      \/\/ counter, therefore no shifting of bits is required.\n-      _interpreter_backward_branch_limit = (int)((int64_t)compile_threshold * (OnStackReplacePercentage - InterpreterProfilePercentage) \/ 100);\n-    } else {\n-      _interpreter_backward_branch_limit = (int)(((int64_t)compile_threshold * OnStackReplacePercentage \/ 100) << InvocationCounter::count_shift);\n-    }\n-    _interpreter_profile_limit = ((compile_threshold * InterpreterProfilePercentage) \/ 100) << InvocationCounter::count_shift;\n-    _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n-    _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n-  }\n+  MethodCounters(const methodHandle& mh);\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n-\/\/ Put the LP64\/JVMCI\/COMPILER1\/COMPILER1\/ARCH at\n-\/\/ the top, as they are processed by jvmFlags.cpp in that\n-\/\/ order.\n+\/\/ Put LP64\/ARCH\/JVMCI\/COMPILER1\/COMPILER2 at the top,\n+\/\/ as they are processed by jvmFlag.cpp in that order.\n@@ -53,0 +52,7 @@\n+  ARCH_FLAGS(                 \\\n+    develop,                  \\\n+    product,                  \\\n+    notproduct,               \\\n+    range,                    \\\n+    constraint)               \\\n+                              \\\n@@ -80,1 +86,1 @@\n-  ARCH_FLAGS(                 \\\n+  COMPILER_FLAGS(             \\\n@@ -82,0 +88,1 @@\n+    develop_pd,               \\\n@@ -83,0 +90,1 @@\n+    product_pd,               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/allFlags.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-\/\/ Find out the number of LP64\/JVMCI\/COMPILER1\/COMPILER1\/ARCH flags,\n+\/\/ Find out the number of LP64\/ARCH\/JVMCI\/COMPILER1\/COMPILER2 flags,\n@@ -477,0 +477,1 @@\n+enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         ENUM_F, IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n@@ -480,1 +481,0 @@\n-enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         ENUM_F, IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n@@ -483,1 +483,2 @@\n-const int first_flag_enum_JVMCI  = first_flag_enum_LP64  + num_flags_LP64;\n+const int first_flag_enum_ARCH   = first_flag_enum_LP64  + num_flags_LP64;\n+const int first_flag_enum_JVMCI  = first_flag_enum_ARCH  + num_flags_ARCH;\n@@ -486,2 +487,1 @@\n-const int first_flag_enum_ARCH   = first_flag_enum_C2    + num_flags_C2;\n-const int first_flag_enum_other  = first_flag_enum_ARCH  + num_flags_ARCH;\n+const int first_flag_enum_other  = first_flag_enum_C2    + num_flags_C2;\n@@ -490,1 +490,2 @@\n-  if (flag_enum < first_flag_enum_JVMCI) return JVMFlag::KIND_LP64_PRODUCT;\n+  if (flag_enum < first_flag_enum_ARCH)  return JVMFlag::KIND_LP64_PRODUCT;\n+  if (flag_enum < first_flag_enum_JVMCI) return JVMFlag::KIND_ARCH;\n@@ -493,2 +494,1 @@\n-  if (flag_enum < first_flag_enum_ARCH)  return JVMFlag::KIND_C2;\n-  if (flag_enum < first_flag_enum_other) return JVMFlag::KIND_ARCH;\n+  if (flag_enum < first_flag_enum_other) return JVMFlag::KIND_C2;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -961,43 +961,0 @@\n-  \/* compiler interface *\/                                                  \\\n-                                                                            \\\n-  develop(bool, CIPrintCompilerName, false,                                 \\\n-          \"when CIPrint is active, print the name of the active compiler\")  \\\n-                                                                            \\\n-  product(bool, CIPrintCompileQueue, false, DIAGNOSTIC,                     \\\n-          \"display the contents of the compile queue whenever a \"           \\\n-          \"compilation is enqueued\")                                        \\\n-                                                                            \\\n-  develop(bool, CIPrintRequests, false,                                     \\\n-          \"display every request for compilation\")                          \\\n-                                                                            \\\n-  product(bool, CITime, false,                                              \\\n-          \"collect timing information for compilation\")                     \\\n-                                                                            \\\n-  develop(bool, CITimeVerbose, false,                                       \\\n-          \"be more verbose in compilation timings\")                         \\\n-                                                                            \\\n-  develop(bool, CITimeEach, false,                                          \\\n-          \"display timing information after each successful compilation\")   \\\n-                                                                            \\\n-  develop(bool, CICountOSR, false,                                          \\\n-          \"use a separate counter when assigning ids to osr compilations\")  \\\n-                                                                            \\\n-  develop(bool, CICompileNatives, true,                                     \\\n-          \"compile native methods if supported by the compiler\")            \\\n-                                                                            \\\n-  develop_pd(bool, CICompileOSR,                                            \\\n-          \"compile on stack replacement methods if supported by the \"       \\\n-          \"compiler\")                                                       \\\n-                                                                            \\\n-  develop(bool, CIPrintMethodCodes, false,                                  \\\n-          \"print method bytecodes of the compiled code\")                    \\\n-                                                                            \\\n-  develop(bool, CIPrintTypeFlow, false,                                     \\\n-          \"print the results of ciTypeFlow analysis\")                       \\\n-                                                                            \\\n-  develop(bool, CITraceTypeFlow, false,                                     \\\n-          \"detailed per-bytecode tracing of ciTypeFlow analysis\")           \\\n-                                                                            \\\n-  develop(intx, OSROnlyBCI, -1,                                             \\\n-          \"OSR only at this bci.  Negative values mean exclude that bci\")   \\\n-                                                                            \\\n@@ -1378,20 +1335,0 @@\n-  product(bool, DontCompileHugeMethods, true,                               \\\n-          \"Do not compile methods > HugeMethodLimit\")                       \\\n-                                                                            \\\n-  \/* Bytecode escape analysis estimation. *\/                                \\\n-  product(bool, EstimateArgEscape, true,                                    \\\n-          \"Analyze bytecodes to estimate escape state of arguments\")        \\\n-                                                                            \\\n-  product(intx, BCEATraceLevel, 0,                                          \\\n-          \"How much tracing to do of bytecode escape analysis estimates \"   \\\n-          \"(0-3)\")                                                          \\\n-          range(0, 3)                                                       \\\n-                                                                            \\\n-  product(intx, MaxBCEAEstimateLevel, 5,                                    \\\n-          \"Maximum number of nested calls that are analyzed by BC EA\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxBCEAEstimateSize, 150,                                   \\\n-          \"Maximum bytecode size of a method to be analyzed by BC EA\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1773,71 +1710,0 @@\n-  \/* compiler interface *\/                                                  \\\n-  develop(intx, CIStart, 0,                                                 \\\n-          \"The id of the first compilation to permit\")                      \\\n-                                                                            \\\n-  develop(intx, CIStop, max_jint,                                           \\\n-          \"The id of the last compilation to permit\")                       \\\n-                                                                            \\\n-  develop(intx, CIStartOSR, 0,                                              \\\n-          \"The id of the first osr compilation to permit \"                  \\\n-          \"(CICountOSR must be on)\")                                        \\\n-                                                                            \\\n-  develop(intx, CIStopOSR, max_jint,                                        \\\n-          \"The id of the last osr compilation to permit \"                   \\\n-          \"(CICountOSR must be on)\")                                        \\\n-                                                                            \\\n-  develop(intx, CIBreakAtOSR, -1,                                           \\\n-          \"The id of osr compilation to break at\")                          \\\n-                                                                            \\\n-  develop(intx, CIBreakAt, -1,                                              \\\n-          \"The id of compilation to break at\")                              \\\n-                                                                            \\\n-  product(ccstrlist, CompileOnly, \"\",                                       \\\n-          \"List of methods (pkg\/class.name) to restrict compilation to\")    \\\n-                                                                            \\\n-  product(ccstr, CompileCommandFile, NULL,                                  \\\n-          \"Read compiler commands from this file [.hotspot_compiler]\")      \\\n-                                                                            \\\n-  product(ccstr, CompilerDirectivesFile, NULL, DIAGNOSTIC,                  \\\n-          \"Read compiler directives from this file\")                        \\\n-                                                                            \\\n-  product(ccstrlist, CompileCommand, \"\",                                    \\\n-          \"Prepend to .hotspot_compiler; e.g. log,java\/lang\/String.<init>\") \\\n-                                                                            \\\n-  develop(bool, ReplayCompiles, false,                                      \\\n-          \"Enable replay of compilations from ReplayDataFile\")              \\\n-                                                                            \\\n-  product(ccstr, ReplayDataFile, NULL,                                      \\\n-          \"File containing compilation replay information\"                  \\\n-          \"[default: .\/replay_pid%p.log] (%p replaced with pid)\")           \\\n-                                                                            \\\n-  product(ccstr, InlineDataFile, NULL,                                      \\\n-          \"File containing inlining replay information\"                     \\\n-          \"[default: .\/inline_pid%p.log] (%p replaced with pid)\")           \\\n-                                                                            \\\n-  develop(intx, ReplaySuppressInitializers, 2,                              \\\n-          \"Control handling of class initialization during replay: \"        \\\n-          \"0 - don't do anything special; \"                                 \\\n-          \"1 - treat all class initializers as empty; \"                     \\\n-          \"2 - treat class initializers for application classes as empty; \" \\\n-          \"3 - allow all class initializers to run during bootstrap but \"   \\\n-          \"    pretend they are empty after starting replay\")               \\\n-          range(0, 3)                                                       \\\n-                                                                            \\\n-  develop(bool, ReplayIgnoreInitErrors, false,                              \\\n-          \"Ignore exceptions thrown during initialization for replay\")      \\\n-                                                                            \\\n-  product(bool, DumpReplayDataOnError, true,                                \\\n-          \"Record replay data for crashing compiler threads\")               \\\n-                                                                            \\\n-  product(bool, CICompilerCountPerCPU, false,                               \\\n-          \"1 compiler thread for log(N CPUs)\")                              \\\n-                                                                            \\\n-  notproduct(intx, CICrashAt, -1,                                           \\\n-          \"id of compilation to trigger assert in compiler thread for \"     \\\n-          \"the purpose of testing, e.g. generation of replay data\")         \\\n-  notproduct(bool, CIObjectFactoryVerify, false,                            \\\n-          \"enable potentially expensive verification in ciObjectFactory\")   \\\n-                                                                            \\\n-  product(bool, AbortVMOnCompilationFailure, false, DIAGNOSTIC,             \\\n-          \"Abort VM when method had failed to compile.\")                    \\\n-                                                                            \\\n@@ -1941,224 +1807,0 @@\n-  product(double, CompileThresholdScaling, 1.0,                             \\\n-          \"Factor to control when first compilation happens \"               \\\n-          \"(both with and without tiered compilation): \"                    \\\n-          \"values greater than 1.0 delay counter overflow, \"                \\\n-          \"values between 0 and 1.0 rush counter overflow, \"                \\\n-          \"value of 1.0 leaves compilation thresholds unchanged \"           \\\n-          \"value of 0.0 is equivalent to -Xint. \"                           \\\n-          \"\"                                                                \\\n-          \"Flag can be set as per-method option. \"                          \\\n-          \"If a value is specified for a method, compilation thresholds \"   \\\n-          \"for that method are scaled by both the value of the global flag \"\\\n-          \"and the value of the per-method flag.\")                          \\\n-          range(0.0, DBL_MAX)                                               \\\n-                                                                            \\\n-  product(intx, Tier0InvokeNotifyFreqLog, 7,                                \\\n-          \"Interpreter (tier 0) invocation notification frequency\")         \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2InvokeNotifyFreqLog, 11,                               \\\n-          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier3InvokeNotifyFreqLog, 10,                               \\\n-          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n-          \"frequency\")                                                      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier23InlineeNotifyFreqLog, 20,                             \\\n-          \"Inlinee invocation (tiers 2 and 3) notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \\\n-          \"Interpreter (tier 0) invocation notification frequency\")         \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \\\n-          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \\\n-          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n-          \"frequency\")                                                      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2CompileThreshold, 0,                                   \\\n-          \"threshold at which tier 2 compilation is invoked\")               \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier2BackEdgeThreshold, 0,                                  \\\n-          \"Back edge threshold at which tier 2 compilation is invoked\")     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3InvocationThreshold, 200,                              \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold\")                                                      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3MinInvocationThreshold, 100,                           \\\n-          \"Minimum invocation to compile at tier 3\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3CompileThreshold, 2000,                                \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied)\")                                     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3BackEdgeThreshold,  60000,                             \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked\") \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTInvocationThreshold, 10000,                         \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold if coming from AOT\")                                   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \\\n-          \"Minimum invocation to compile at tier 3 if coming from AOT\")     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTCompileThreshold, 15000,                            \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied) if coming from AOT\")                  \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked \" \\\n-          \"if coming from AOT\")                                             \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTInvocationThreshold, 200, DIAGNOSTIC,               \\\n-          \"Switch to interpreter to profile if the number of method \"       \\\n-          \"invocations crosses this threshold if coming from AOT \"          \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTMinInvocationThreshold, 100, DIAGNOSTIC,            \\\n-          \"Minimum number of invocations to switch to interpreter \"         \\\n-          \"to profile if coming from AOT \"                                  \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTCompileThreshold, 2000, DIAGNOSTIC,                 \\\n-          \"Threshold at which to switch to interpreter to profile \"         \\\n-          \"if coming from AOT \"                                             \\\n-          \"(invocation minimum must be satisfied, \"                         \\\n-          \"applicable only with \"                                           \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTBackEdgeThreshold,  60000, DIAGNOSTIC,              \\\n-          \"Back edge threshold at which to switch to interpreter \"          \\\n-          \"to profile if coming from AOT \"                                  \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4InvocationThreshold, 5000,                             \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold\")                                                      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4MinInvocationThreshold, 600,                           \\\n-          \"Minimum invocation to compile at tier 4\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4CompileThreshold, 15000,                               \\\n-          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied)\")                                     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4BackEdgeThreshold, 40000,                              \\\n-          \"Back edge threshold at which tier 4 OSR compilation is invoked\") \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40InvocationThreshold, 5000, DIAGNOSTIC,                \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold (applicable only with \"                                \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40MinInvocationThreshold, 600, DIAGNOSTIC,              \\\n-          \"Minimum number of invocations to compile at tier 4 \"             \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40CompileThreshold, 10000, DIAGNOSTIC,                  \\\n-          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied, applicable only with \"                \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40BackEdgeThreshold, 15000, DIAGNOSTIC,                 \\\n-          \"Back edge threshold at which tier 4 OSR compilation is invoked \" \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0Delay, 5, DIAGNOSTIC,                                  \\\n-          \"If C2 queue size grows over this amount per compiler thread \"    \\\n-          \"do not start profiling in the interpreter \"                      \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3DelayOn, 5,                                            \\\n-          \"If C2 queue size grows over this amount per compiler thread \"    \\\n-          \"stop compiling at tier 3 and start compiling at tier 2\")         \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3DelayOff, 2,                                           \\\n-          \"If C2 queue size is less than this amount per compiler thread \"  \\\n-          \"allow methods compiled at tier 2 transition to tier 3\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3LoadFeedback, 5,                                       \\\n-          \"Tier 3 thresholds will increase twofold when C1 queue size \"     \\\n-          \"reaches this amount per compiler thread\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4LoadFeedback, 3,                                       \\\n-          \"Tier 4 thresholds will increase twofold when C2 queue size \"     \\\n-          \"reaches this amount per compiler thread\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, TieredCompileTaskTimeout, 50,                               \\\n-          \"Kill compile task if method was not used within \"                \\\n-          \"given timeout in milliseconds\")                                  \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, TieredStopAtLevel, 4,                                       \\\n-          \"Stop at given compilation level\")                                \\\n-          range(0, 4)                                                       \\\n-                                                                            \\\n-  product(intx, Tier0ProfilingStartPercentage, 200,                         \\\n-          \"Start profiling in interpreter if the counters exceed tier 3 \"   \\\n-          \"thresholds (tier 4 thresholds with \"                             \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\"             \\\n-          \"by the specified percentage\")                                    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \\\n-          \"Increase the compile threshold for C1 compilation if the code \"  \\\n-          \"cache is filled by the specified percentage\")                    \\\n-          range(0, 99)                                                      \\\n-                                                                            \\\n-  product(intx, TieredRateUpdateMinTime, 1,                                 \\\n-          \"Minimum rate sampling interval (in milliseconds)\")               \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, TieredRateUpdateMaxTime, 25,                                \\\n-          \"Maximum rate sampling interval (in milliseconds)\")               \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(ccstr, CompilationMode, \"default\",                                \\\n-          \"Compilation modes: \"                                             \\\n-          \"default: normal tiered compilation; \"                            \\\n-          \"quick-only: C1-only mode; \"                                      \\\n-          \"high-only: C2\/JVMCI-only mode; \"                                 \\\n-          \"high-only-quick-internal: C2\/JVMCI-only mode, \"                  \\\n-          \"with JVMCI compiler compiled with C1.\")                          \\\n-                                                                            \\\n@@ -2168,20 +1810,0 @@\n-  product(bool, PrintTieredEvents, false,                                   \\\n-          \"Print tiered events notifications\")                              \\\n-                                                                            \\\n-  product_pd(intx, OnStackReplacePercentage,                                \\\n-          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n-          \"% of CompileThreshold) before (re-)compiling OSR code\")          \\\n-          constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \\\n-                                                                            \\\n-  product(intx, InterpreterProfilePercentage, 33,                           \\\n-          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n-          \"% of CompileThreshold) before profiling in the interpreter\")     \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  develop(intx, DesiredMethodLimit,  8000,                                  \\\n-          \"The desired maximum method size (in bytecodes) after inlining\")  \\\n-                                                                            \\\n-  develop(intx, HugeMethodLimit,  8000,                                     \\\n-          \"Don't compile methods larger than this if \"                      \\\n-          \"+DontCompileHugeMethods\")                                        \\\n-                                                                            \\\n@@ -2449,8 +2071,0 @@\n-  product(bool, CompilerDirectivesIgnoreCompileCommands, false, DIAGNOSTIC, \\\n-             \"Disable backwards compatibility for compile commands.\")       \\\n-                                                                            \\\n-  product(bool, CompilerDirectivesPrint, false, DIAGNOSTIC,                 \\\n-             \"Print compiler directives on installation.\")                  \\\n-  product(int,  CompilerDirectivesLimit, 50, DIAGNOSTIC,                    \\\n-             \"Limit on number of compiler directives.\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":386,"binary":false,"changes":386,"status":"modified"}]}