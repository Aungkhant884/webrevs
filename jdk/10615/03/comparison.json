{"files":[{"patch":"@@ -38,0 +38,1 @@\n+  { \"GenericCDSFileMapHeader::_common_app_classpath_prefix_size\", offset_of(GenericCDSFileMapHeader, _common_app_classpath_prefix_size) },\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+  size_t longest_common_prefix_size = 0;\n@@ -224,0 +225,4 @@\n+  ResourceMark rm;\n+  GrowableArray<const char*>* app_cp_array = create_dumptime_app_classpath_array();\n+  int len = app_cp_array->length();\n+  longest_common_prefix_size = longest_common_app_classpath_prefix_len(len, app_cp_array);\n@@ -230,1 +235,2 @@\n-                    base_archive_name_offset);\n+                    base_archive_name_offset,\n+                    longest_common_prefix_size);\n@@ -235,1 +241,1 @@\n-                             size_t base_archive_name_offset) {\n+                             size_t base_archive_name_offset, size_t common_app_classpath_prefix_size) {\n@@ -242,0 +248,1 @@\n+  set_common_app_classpath_prefix_size((unsigned int)common_app_classpath_prefix_size);\n@@ -314,0 +321,1 @@\n+  st->print_cr(\"- common_app_classpath_size:      \" UINT32_FORMAT, common_app_classpath_prefix_size());\n@@ -811,0 +819,11 @@\n+GrowableArray<const char*>* FileMapInfo::create_dumptime_app_classpath_array() {\n+  Arguments::assert_is_dumping_archive();\n+  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n+  ClassPathEntry* cpe = ClassLoader::app_classpath_entries();\n+  while (cpe != NULL) {\n+    path_array->append(cpe->name());\n+    cpe = cpe->next();\n+  }\n+  return path_array;\n+}\n+\n@@ -845,1 +864,23 @@\n-bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray<const char*>* rp_array) {\n+unsigned int FileMapInfo::longest_common_app_classpath_prefix_len(int num_paths,\n+                                                                  GrowableArray<const char*>* rp_array) {\n+  if (num_paths == 0) {\n+    return 0;\n+  }\n+  unsigned int pos;\n+  for (pos = 0; ; pos++) {\n+    for (int i = 0; i < num_paths; i++) {\n+      if (rp_array->at(i)[pos] != '\\0' && rp_array->at(i)[pos] == rp_array->at(0)[pos]) {\n+        continue;\n+      }\n+\n+      \/\/ search backward for the pos before the file separator char\n+      while (pos > 0 && rp_array->at(0)[--pos] != *os::file_separator());\n+      \/\/ return the file separator char position\n+      return pos + 1;\n+    }\n+  }\n+  return 0;\n+}\n+\n+bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray<const char*>* rp_array,\n+                              unsigned int dumptime_prefix_len, unsigned int runtime_prefix_len) {\n@@ -848,2 +889,1 @@\n-  bool mismatch = false;\n-  while (i < num_paths && !mismatch) {\n+  while (i < num_paths) {\n@@ -855,2 +895,6 @@\n-    if (!os::same_files(shared_path(j)->name(), rp_array->at(i))) {\n-      mismatch = true;\n+    assert(strlen(shared_path(j)->name()) > (size_t)dumptime_prefix_len, \"sanity\");\n+    const char* dumptime_path = shared_path(j)->name() + dumptime_prefix_len;\n+    assert(strlen(rp_array->at(i)) > (size_t)runtime_prefix_len, \"sanity\");\n+    const char* runtime_path = runtime_path = rp_array->at(i)  + runtime_prefix_len;\n+    if (!os::same_files(dumptime_path, runtime_path)) {\n+      return true;\n@@ -861,1 +905,1 @@\n-  return mismatch;\n+  return false;\n@@ -915,1 +959,1 @@\n-      mismatch = check_paths(1, num, rp_array);\n+      mismatch = check_paths(1, num, rp_array, 0, 0);\n@@ -964,1 +1008,1 @@\n-    mismatch = check_paths(j, shared_app_paths_len, rp_array);\n+    mismatch = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n@@ -966,1 +1010,12 @@\n-      return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n+      \/\/ To facilitate app deployment, we allow the JAR files to be moved *together* to\n+      \/\/ a different location, as long as they are still stored under the same directory\n+      \/\/ structure. E.g., the following is OK.\n+      \/\/     java -Xshare:dump -cp \/a\/Foo.jar:\/a\/b\/Bar.jar  ...\n+      \/\/     java -Xshare:auto -cp \/x\/y\/Foo.jar:\/x\/y\/b\/Bar.jar  ...\n+      unsigned int dumptime_prefix_len = header()->common_app_classpath_prefix_size();\n+      unsigned int runtime_prefix_len = longest_common_app_classpath_prefix_len(shared_app_paths_len, rp_array);\n+      mismatch = check_paths(j, shared_app_paths_len, rp_array,\n+                             dumptime_prefix_len, runtime_prefix_len);\n+      if (mismatch) {\n+        return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n+      }\n@@ -994,1 +1049,1 @@\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array);\n+  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array, 0, 0);\n@@ -1208,0 +1263,4 @@\n+    if (!check_common_app_classpath_prefix_len()) {\n+      return false;\n+    }\n+\n@@ -1285,0 +1344,10 @@\n+\n+    return true;\n+  }\n+\n+  bool check_common_app_classpath_prefix_len() {\n+    int common_path_size = _header->_common_app_classpath_prefix_size;\n+    if (common_path_size < 0) {\n+      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n+      return false;\n+    }\n@@ -1367,2 +1436,3 @@\n-      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, base_offset);\n+      log_info(cds)(\"common_app_classpath_size: \" UINT32_FORMAT, header()->common_app_classpath_prefix_size());\n+      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n+      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":84,"deletions":14,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  unsigned int common_app_classpath_prefix_size() const { return _generic_header._common_app_classpath_prefix_size; }\n@@ -254,0 +255,1 @@\n+  void set_common_app_classpath_prefix_size(unsigned int s) { _generic_header._common_app_classpath_prefix_size = s; }\n@@ -313,1 +315,2 @@\n-                size_t base_archive_name_size, size_t base_archive_name_offset);\n+                size_t base_archive_name_size, size_t base_archive_name_offset,\n+                size_t common_app_classpath_size);\n@@ -558,0 +561,1 @@\n+  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(NULL);\n@@ -560,0 +564,3 @@\n+  unsigned int longest_common_app_classpath_prefix_len(int num_paths,\n+                                                       GrowableArray<const char*>* rp_array)\n+                                                       NOT_CDS_RETURN_(0);\n@@ -561,1 +568,3 @@\n-                    GrowableArray<const char*>* rp_array) NOT_CDS_RETURN_(false);\n+                    GrowableArray<const char*>* rp_array,\n+                    unsigned int dumptime_prefix_len,\n+                    unsigned int runtime_prefix_len) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 14\n+#define CURRENT_CDS_ARCHIVE_VERSION 15\n@@ -72,0 +72,2 @@\n+  unsigned int _common_app_classpath_prefix_size; \/\/ size of the common prefix of app class paths\n+                                                  \/\/    0 if no common prefix exists\n@@ -84,0 +86,1 @@\n+\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8279366\n+ * @summary Test app class paths checking with the longest common path taken into account.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @compile test-classes\/HelloMore.java\n+ * @run driver CommonAppClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n+public class CommonAppClasspath {\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+    private static final String failedMessage = \"APP classpath mismatch\";\n+    private static final String successMessage1 = \"Hello source: shared objects file\";\n+    private static final String successMessage2 = \"HelloMore source: shared objects file\";\n+\n+    private static void runtimeTest(String classPath, String mainClass, int expectedExitValue,\n+                                    String ... checkMessages) throws Exception {\n+        CDSTestUtils.Result result = TestCommon.run(\n+            \"-Xshare:on\",\n+            \"-XX:SharedArchiveFile=\" + TestCommon.getCurrentArchiveName(),\n+            \"-cp\", classPath,\n+            \"-Xlog:class+load=trace,class+path=info\",\n+            mainClass);\n+        if (expectedExitValue == 0) {\n+            result.assertNormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        } else {\n+            result.assertAbnormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"AppendClasspath_HelloMore\", \"HelloMore\");\n+        \/\/ dump an archive with only appJar in the original location\n+        String jars = appJar;\n+        TestCommon.testDump(jars, TestCommon.list(\"Hello\"));\n+\n+        \/\/ copy hello.jar to tmp dir\n+        Path destPath = CDSTestUtils.copyFile(appJar, System.getProperty(\"java.io.tmpdir\"));\n+\n+        \/\/ Run with appJar relocated to tmp dir - should PASS\n+        runtimeTest(destPath.toString(), \"Hello\", 0, successMessage1);\n+\n+        \/\/ dump an archive with both jars in the original location\n+        jars = appJar + File.pathSeparator + appJar2;\n+        TestCommon.testDump(jars, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        \/\/ copy hello.jar to USER_DIR\/deploy\n+        String newDir = USER_DIR.toString() + File.separator + \"deploy\";\n+        destPath = CDSTestUtils.copyFile(appJar, newDir);\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/deploy\n+        Path destPath2 = CDSTestUtils.copyFile(appJar2, newDir);\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/dpeloy - should PASS\n+        runtimeTest(destPath.toString() + File.pathSeparator + destPath2.toString(),\n+                    \"HelloMore\", 0, successMessage1, successMessage2);\n+\n+        \/\/ Run with relocation of only the second jar - should FAIL\n+        runtimeTest(appJar + File.pathSeparator + destPath2.toString(),\n+                    \"HelloMore\", 1, failedMessage);\n+\n+        \/\/ Run with relocation of only the first jar - should FAIL\n+        runtimeTest(destPath.toString() + File.pathSeparator + appJar2,\n+                    \"HelloMore\", 1, failedMessage);\n+\n+        \/\/ Dump CDS archive with the first jar relocated.\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        TestCommon.testDump(jars, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        \/\/ Run with first jar relocated - should PASS\n+        runtimeTest(destPath.toString() + File.pathSeparator + appJar2,\n+                    \"HelloMore\", 0, successMessage1, successMessage2);\n+\n+        \/\/ Run with both jars relocated - should FAIL\n+        runtimeTest(destPath.toString() + File.pathSeparator + destPath2.toString(),\n+                    \"HelloMore\", 1, failedMessage);\n+\n+        \/\/ Copy hello.jar to USER_DIR\/a\n+        destPath = CDSTestUtils.copyFile(appJar, USER_DIR.toString() + File.separator + \"a\");\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/aa\n+        destPath2 = CDSTestUtils.copyFile(appJar2, USER_DIR.toString() + File.separator + \"aa\");\n+\n+        \/\/ Dump CDS archive with the both jar files relocated\n+        \/\/ appJar to USER_DIR\/a\n+        \/\/ appJar2 to USER_DIR\/aa\n+        jars = destPath.toString() + File.pathSeparator + destPath2.toString();\n+        TestCommon.testDump(jars, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        \/\/ Copy hello.jar to USER_DIR\/x\/a\n+        Path runPath = CDSTestUtils.copyFile(appJar, USER_DIR.toString() + File.separator + \"x\" + File.separator + \"a\");\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/x\/aa\n+        Path runPath2= CDSTestUtils.copyFile(appJar2, USER_DIR.toString() + File.separator + \"x\" + File.separator + \"aa\");\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/x\/a and USER_DIR\/x\/aa dirs - should PASS\n+        runtimeTest(runPath.toString() + File.pathSeparator + runPath2.toString(),\n+                    \"HelloMore\", 0, successMessage1, successMessage2);\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/x\/a\n+        runPath2= CDSTestUtils.copyFile(appJar2, USER_DIR.toString() + File.separator + \"x\" + File.separator + \"a\");\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/x\/a dir - should FAIL\n+        runtimeTest(runPath.toString() + File.pathSeparator + runPath2.toString(),\n+                    \"HelloMore\", 1, failedMessage);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommonAppClasspath.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -274,0 +274,10 @@\n+\n+        \/\/ modify _common_app_classpath_size\n+        String wrongCommonAppClasspathOffset = startNewArchive(\"wrongCommonAppClasspathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, wrongCommonAppClasspathOffset);\n+        int commonAppClasspathPrefixSize = CDSArchiveUtils.commonAppClasspathPrefixSize(copiedJsa);\n+        System.out.println(\"    commonAppClasspathPrefixSize = \" + commonAppClasspathPrefixSize);\n+        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetCommonAppClasspathPrefixSize(), commonAppClasspathPrefixSize * 2);\n+        commonAppClasspathPrefixSize = CDSArchiveUtils.commonAppClasspathPrefixSize(copiedJsa);\n+        System.out.println(\"new commonAppClasspathPrefixSize = \" + commonAppClasspathPrefixSize);\n+        testAndCheck(verifyExecArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -153,1 +153,17 @@\n-        startTest(\"5. Make base archive name not terminated with '\\0'\");\n+        startTest(\"5a. Modify common app classpath size\");\n+        String wrongCommonAppClasspathOffset = getNewArchiveName(\"wrongCommonAppClasspathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongCommonAppClasspathOffset);\n+        int commonAppClasspathPrefixSize = CDSArchiveUtils.commonAppClasspathPrefixSize(copiedJsa);\n+        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetCommonAppClasspathPrefixSize(), -1);\n+        runTwo(baseArchiveName, wrongCommonAppClasspathOffset,\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"common app classpath prefix len < 0\");\n+\n+        startTest(\"5b. Modify common app classpath size, run with -XX:-VerifySharedSpaces\");\n+        VERIFY_CRC = true;\n+        runTwo(baseArchiveName, modTop,\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"Header checksum verification failed\");\n+        VERIFY_CRC = false;\n+\n+        startTest(\"6. Make base archive name not terminated with '\\0'\");\n@@ -165,1 +181,1 @@\n-        startTest(\"6. Modify base archive name to a file that doesn't exist\");\n+        startTest(\"7. Modify base archive name to a file that doesn't exist\");\n@@ -185,1 +201,1 @@\n-        startTest(\"7. Non-exist base archive\");\n+        startTest(\"8. Non-exist base archive\");\n@@ -193,1 +209,1 @@\n-        startTest(\"8. Non-exist top archive\");\n+        startTest(\"9. Non-exist top archive\");\n@@ -201,1 +217,1 @@\n-        startTest(\"9. nost-exist-base and non-exist-top\");\n+        startTest(\"10. nost-exist-base and non-exist-top\");\n@@ -212,1 +228,1 @@\n-        startTest(\"10. -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=\" + topArchiveName);\n+        startTest(\"11. -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=\" + topArchiveName);\n@@ -222,1 +238,1 @@\n-        startTest(\"11. -XX:SharedArchiveFile=\" + topArchiveName + \" -XX:ArchiveClassesAtExit=\" + getNewArchiveName(\"top3\"));\n+        startTest(\"12. -XX:SharedArchiveFile=\" + topArchiveName + \" -XX:ArchiveClassesAtExit=\" + getNewArchiveName(\"top3\"));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8279366\n+ * @summary Test app class paths checking with the longest common path taken into account.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @compile ..\/test-classes\/Hello.java\n+ * @compile ..\/test-classes\/HelloMore.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. CommonAppClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n+public class CommonAppClasspath extends DynamicArchiveTestBase {\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+    private static final String failedMessage = \"shared class paths mismatch\";\n+    private static final String successMessage1 = \"Hello source: shared objects file\";\n+    private static final String successMessage2 = \"HelloMore source: shared objects file\";\n+\n+    private static void runtimeTest(String topArchiveName, String classPath,\n+                                    String mainClass, int expectedExitValue,\n+                                    String ... checkMessages) throws Exception {\n+        CDSTestUtils.Result result = run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", classPath, mainClass);\n+        if (expectedExitValue == 0) {\n+            result.assertNormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        } else {\n+            result.assertAbnormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(CommonAppClasspath::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        String mainClass = \"HelloMore\";\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"AppendClasspath_HelloMore\", mainClass);\n+\n+        \/\/ dump an archive with only appJar in the original location\n+        String jars = appJar;\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", jars, \"Hello\")\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        \/\/ copy hello.jar to tmp dir\n+        Path destPath = CDSTestUtils.copyFile(appJar, System.getProperty(\"java.io.tmpdir\"));\n+\n+        \/\/ Run with appJar relocated to tmp dir - should PASS\n+        jars = destPath.toString();\n+        runtimeTest(topArchiveName, jars, \"Hello\", 0, successMessage1);\n+\n+        \/\/ dump an archive with both jars in the original location\n+        jars = appJar + File.pathSeparator + appJar2;\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        \/\/ copy hello.jar to USER_DIR\/deploy\n+        String newDir = USER_DIR.toString() + File.separator + \"deploy\";\n+        destPath = CDSTestUtils.copyFile(appJar, newDir);\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/deploy\n+        Path destPath2 = CDSTestUtils.copyFile(appJar2, newDir);\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/dpeloy - should PASS\n+        jars = destPath.toString() + File.pathSeparator + destPath2.toString();\n+        runtimeTest(topArchiveName, jars, mainClass, 0, successMessage1, successMessage2);\n+\n+        \/\/ Run with relocation of only the second jar - should FAIL\n+        jars = appJar + File.pathSeparator + destPath2.toString();\n+        runtimeTest(topArchiveName, jars, mainClass, 1, failedMessage);\n+\n+        \/\/ Run with relocation of only the first jar - should FAIL\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        runtimeTest(topArchiveName, jars, mainClass, 1, failedMessage);\n+\n+        \/\/ Dump CDS archive with the first jar relocated.\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        \/\/ Run with first jar relocated - should PASS\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        runtimeTest(topArchiveName, jars, mainClass, 0, successMessage1, successMessage2);\n+\n+        \/\/ Run with both jars relocated - should FAIL\n+        jars = destPath.toString() + File.pathSeparator + destPath2.toString();\n+        runtimeTest(topArchiveName, jars, mainClass, 1, failedMessage);\n+\n+        \/\/ Copy hello.jar to USER_DIR\/a\n+        destPath = CDSTestUtils.copyFile(appJar, USER_DIR.toString() + File.separator + \"a\");\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/aa\n+        destPath2 = CDSTestUtils.copyFile(appJar2, USER_DIR.toString() + File.separator + \"aa\");\n+\n+        \/\/ Dump CDS archive with the both jar files relocated\n+        \/\/ appJar to USER_DIR\/a\n+        \/\/ appJar2 to USER_DIR\/aa\n+        jars = destPath.toString() + File.pathSeparator + destPath2.toString();\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        \/\/ Copy hello.jar to USER_DIR\/x\/a\n+        Path runPath = CDSTestUtils.copyFile(appJar, USER_DIR.toString() + File.separator + \"x\" + File.separator + \"a\");\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/x\/aa\n+        Path runPath2= CDSTestUtils.copyFile(appJar2, USER_DIR.toString() + File.separator + \"x\" + File.separator + \"aa\");\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/x\/a and USER_DIR\/x\/aa dirs - should PASS\n+        jars = runPath.toString() + File.pathSeparator + runPath2.toString();\n+        runtimeTest(topArchiveName, jars, mainClass, 0, successMessage1, successMessage2);\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/x\/a\n+        runPath2= CDSTestUtils.copyFile(appJar2, USER_DIR.toString() + File.separator + \"x\" + File.separator + \"a\");\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/x\/a dir - should FAIL\n+        jars = runPath.toString() + File.pathSeparator + runPath2.toString();\n+        runtimeTest(topArchiveName, jars, mainClass, 1, failedMessage);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CommonAppClasspath.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -56,0 +56,1 @@\n+    private static int offsetCommonAppClasspathPrefixSize;\/\/ offset of GenericCDSFileMapHeader::_common_app_classpath_size\n@@ -96,0 +97,1 @@\n+            offsetCommonAppClasspathPrefixSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_common_app_classpath_prefix_size\");\n@@ -134,0 +136,1 @@\n+    public static int offsetCommonAppClasspathPrefixSize() { return offsetCommonAppClasspathPrefixSize; }\n@@ -161,0 +164,4 @@\n+    public static int commonAppClasspathPrefixSize(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetCommonAppClasspathPrefixSize, 4);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -32,0 +34,2 @@\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n@@ -764,0 +768,16 @@\n+\n+    public static Path copyFile(String srcFile, String destDir) throws Exception {\n+        int idx = srcFile.lastIndexOf(File.separator);\n+        String jarName = srcFile.substring(idx + 1);\n+        Path srcPath = Paths.get(jarName);\n+        Path newPath = Paths.get(destDir);\n+        Path newDir;\n+        if (!Files.exists(newPath)) {\n+            newDir = Files.createDirectories(newPath);\n+        } else {\n+            newDir = newPath;\n+        }\n+        Path destPath = newDir.resolve(jarName);\n+        Files.copy(srcPath, destPath, REPLACE_EXISTING, COPY_ATTRIBUTES);\n+        return destPath;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}