{"files":[{"patch":"@@ -38,0 +38,2 @@\n+  { \"GenericCDSFileMapHeader::_common_app_classpath_offset\", offset_of(GenericCDSFileMapHeader, _common_app_classpath_offset) },\n+  { \"GenericCDSFileMapHeader::_common_app_classpath_size\", offset_of(GenericCDSFileMapHeader, _common_app_classpath_size) },\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,0 +207,2 @@\n+  size_t longest_common_prefix_size = 0;\n+  size_t longest_common_prefix_offset = 0;\n@@ -224,0 +226,12 @@\n+  ResourceMark rm;\n+  GrowableArray<const char*>* app_cp_array = create_dumptime_app_classpath_array();\n+  int len = app_cp_array->length();\n+  char* lcp = NULL;\n+  if (len > 0) {\n+    lcp = longest_common_app_classpath(len, app_cp_array);\n+  }\n+  if (lcp != NULL) {\n+    longest_common_prefix_size = strlen(lcp) + 1;\n+    header_size += longest_common_prefix_size;\n+    longest_common_prefix_offset = c_header_size + base_archive_name_size;\n+  }\n@@ -230,1 +244,4 @@\n-                    base_archive_name_offset);\n+                    base_archive_name_offset,\n+                    longest_common_prefix_size,\n+                    longest_common_prefix_offset,\n+                    (const char*)lcp);\n@@ -235,1 +252,2 @@\n-                             size_t base_archive_name_offset) {\n+                             size_t base_archive_name_offset, size_t common_app_classpath_size,\n+                             size_t common_app_classpath_offset, const char* lcp) {\n@@ -242,0 +260,2 @@\n+  set_common_app_classpath_offset((unsigned int)common_app_classpath_offset);\n+  set_common_app_classpath_size((unsigned int)common_app_classpath_size);\n@@ -249,0 +269,3 @@\n+  if(common_app_classpath_size > 0) {\n+    copy_common_app_classpath(lcp);\n+  }\n@@ -307,0 +330,7 @@\n+void FileMapHeader::copy_common_app_classpath(const char* lcp) {\n+  assert(common_app_classpath_size() != 0, \"_common_app_classpath_size not set\");\n+  assert(common_app_classpath_offset() != 0, \"_common_app_classpath_offset not set\");\n+  assert(header_size() > sizeof(*this), \"_common_app_classpath_size not included in header size?\");\n+  memcpy((char*)this + common_app_classpath_offset(), lcp, common_app_classpath_size());\n+}\n+\n@@ -316,0 +346,2 @@\n+  st->print_cr(\"- common_app_classpath_offset:    \" UINT32_FORMAT, common_app_classpath_offset());\n+  st->print_cr(\"- common_app_classpath_size:      \" UINT32_FORMAT, common_app_classpath_size());\n@@ -811,0 +843,11 @@\n+GrowableArray<const char*>* FileMapInfo::create_dumptime_app_classpath_array() {\n+  Arguments::assert_is_dumping_archive();\n+  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n+  ClassPathEntry* cpe = ClassLoader::app_classpath_entries();\n+  while (cpe != NULL) {\n+    path_array->append(cpe->name());\n+    cpe = cpe->next();\n+  }\n+  return path_array;\n+}\n+\n@@ -845,0 +888,62 @@\n+char* FileMapInfo::longest_common_app_classpath(int num_paths,\n+                                                GrowableArray<const char*>* rp_array) {\n+  \/\/ find the shortest path length among all the entries\n+  char* chr = strrchr((char*)rp_array->at(0), *os::file_separator());\n+  size_t min_len = chr != NULL ? chr - rp_array->at(0) + 1 : strlen(rp_array->at(0)) + 1;\n+  for (int i = 1; i < num_paths; i++) {\n+    chr = strrchr((char*)rp_array->at(i), *os::file_separator());\n+    size_t curr_len = chr != NULL ? chr - rp_array->at(i) + 1 : strlen(rp_array->at(i)) + 1;\n+    min_len = MIN2(min_len, curr_len);\n+  }\n+\n+  \/\/ allocate a buffer to store the longest common prefix\n+  char* lcp = NEW_C_HEAP_ARRAY(char, min_len + 1, mtInternal);\n+  memset(lcp, 0, min_len + 1);\n+  char c;\n+  \/\/ find the longest common prefix\n+  for (int j = 0; j < (int)min_len; j++) {\n+    c = rp_array->at(0)[j];\n+    int k = 1;\n+    while (k < num_paths) {\n+      if (rp_array->at(k)[j] != c) {\n+        break;\n+      }\n+      k++;\n+    }\n+    *(lcp + j) = c;\n+  }\n+\n+  if (*lcp == '\\0') {\n+    \/\/ no longest common prefix, release the buffer\n+    FREE_C_HEAP_ARRAY(char, lcp);\n+    return NULL;\n+  } else {\n+    return lcp;\n+  }\n+}\n+\n+bool FileMapInfo::check_paths_ignoring_common_path(int shared_path_start_idx, int num_paths,\n+                                                   GrowableArray<const char*>* rp_array,\n+                                                   const char* dumptime_prefix, const char* runtime_prefix) {\n+  int i = 0;\n+  int j = shared_path_start_idx;\n+  bool mismatch = false;\n+  while (i < num_paths && !mismatch) {\n+    while (shared_path(j)->from_class_path_attr()) {\n+      \/\/ shared_path(j) was expanded from the JAR file attribute \"Class-Path:\"\n+      \/\/ during dump time. It's not included in the -classpath VM argument.\n+      j++;\n+    }\n+    assert(strlen(shared_path(j)->name()) > strlen(dumptime_prefix), \"sanity\");\n+    const char* dumptime_path = shared_path(j)->name() + strlen(dumptime_prefix);\n+    assert(strlen(rp_array->at(i)) > strlen(runtime_prefix), \"sanity\");\n+    const char* runtime_path = rp_array->at(i)  + strlen(runtime_prefix);\n+    if (strcmp(dumptime_path, runtime_path) != 0) {\n+      mismatch = true;\n+    }\n+    i++;\n+    j++;\n+  }\n+  return mismatch;\n+}\n+\n@@ -966,1 +1071,13 @@\n-      return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n+      char* dumptime_prefix = NULL;\n+      if (header()->common_app_classpath_size() > 0) {\n+        dumptime_prefix = (char*)header() + header()->common_app_classpath_offset();\n+      }\n+      const char* runtime_prefix = (const char*)longest_common_app_classpath(shared_app_paths_len, rp_array);\n+      if (dumptime_prefix != NULL && runtime_prefix != NULL) {\n+        mismatch = check_paths_ignoring_common_path(j, shared_app_paths_len, rp_array,\n+                                                    (const char*)dumptime_prefix, runtime_prefix);\n+      }\n+      FREE_C_HEAP_ARRAY(char, runtime_prefix);\n+      if (mismatch) {\n+        return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n+      }\n@@ -1208,0 +1325,4 @@\n+    if (!check_common_app_classpath()) {\n+      return false;\n+    }\n+\n@@ -1285,0 +1406,14 @@\n+\n+    return true;\n+  }\n+\n+  bool check_common_app_classpath() {\n+    unsigned int common_path_size    = _header->_common_app_classpath_size;\n+    \/\/ check the longest common prefix of the app class paths\n+    if (common_path_size > 0) {\n+      const char* lcp = ((const char*)_header) + _header->_common_app_classpath_offset;\n+      if (lcp[common_path_size - 1] != '\\0' || strlen(lcp) != common_path_size - 1) {\n+        FileMapInfo::fail_continue(\"common app classpath is damaged\");\n+        return false;\n+      }\n+    }\n@@ -1361,2 +1496,2 @@\n-  unsigned int base_offset = header()->base_archive_name_offset();\n-  unsigned int name_size = header()->base_archive_name_size();\n+  unsigned int lcp_offset = header()->common_app_classpath_offset();\n+  unsigned int name_size = header()->common_app_classpath_size();\n@@ -1364,2 +1499,2 @@\n-  if (base_offset != 0 && name_size != 0) {\n-    if (header_size != base_offset + name_size) {\n+  if (lcp_offset != 0 && name_size != 0) {\n+    if (header_size != lcp_offset + name_size) {\n@@ -1367,2 +1502,4 @@\n-      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, base_offset);\n+      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n+      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n+      log_info(cds)(\"common_app_classpath_size: \" UINT32_FORMAT, name_size);\n+      log_info(cds)(\"common_app_classpath_offset: \" UINT32_FORMAT, lcp_offset);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":146,"deletions":9,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -247,0 +247,2 @@\n+  unsigned int common_app_classpath_offset() const { return _generic_header._common_app_classpath_offset; }\n+  unsigned int common_app_classpath_size()   const { return _generic_header._common_app_classpath_size; }\n@@ -254,0 +256,2 @@\n+  void set_common_app_classpath_offset(unsigned int s) { _generic_header._common_app_classpath_offset = s; }\n+  void set_common_app_classpath_size(unsigned int s)   { _generic_header._common_app_classpath_size = s; }\n@@ -288,0 +292,1 @@\n+  void copy_common_app_classpath(const char* name);\n@@ -313,1 +318,2 @@\n-                size_t base_archive_name_size, size_t base_archive_name_offset);\n+                size_t base_archive_name_size, size_t base_archive_name_offset,\n+                size_t common_app_classpath_size, size_t common_app_classpath_offset, const char* lcp);\n@@ -558,0 +564,1 @@\n+  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(NULL);\n@@ -560,0 +567,6 @@\n+  char* longest_common_app_classpath(int num_paths,\n+                                     GrowableArray<const char*>* rp_array) NOT_CDS_RETURN_(NULL);\n+  bool  check_paths_ignoring_common_path(int shared_path_start_idx, int num_paths,\n+                                         GrowableArray<const char*>* rp_array,\n+                                         const char* dumptime_prefix, const char* runtime_prefix)\n+                                         NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 14\n+#define CURRENT_CDS_ARCHIVE_VERSION 15\n@@ -84,0 +84,6 @@\n+  unsigned int _common_app_classpath_offset; \/\/ offset to the common prefix of app class paths\n+                                             \/\/ if there exists a common prefix, the following offset\n+                                             \/\/ points to a 0-terminated string for the prefix\n+                                             \/\/ (char*)this + _base_archive_name_offset + _common_app_classpath_offset\n+  unsigned int _common_app_classpath_size;   \/\/ size of the common prefix of app class paths\n+                                             \/\/    0 if no common prefix exists\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8279366\n+ * @summary Test app class paths checking with the longest common path taken into account.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @compile test-classes\/HelloMore.java\n+ * @run driver CommonAppClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n+public class CommonAppClasspath {\n+\n+  private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+\n+  public static void main(String[] args) throws Exception {\n+    String appJar = JarBuilder.getOrCreateHelloJar();\n+    String appJar2 = JarBuilder.build(\"AppendClasspath_HelloMore\", \"HelloMore\");\n+\n+    \/\/ dump an archive with both jars in the original location\n+    int idx = appJar.lastIndexOf(File.separator);\n+    String jarName = appJar.substring(idx + 1);\n+    String jarDir = appJar.substring(0, idx);\n+    String jars = appJar + File.pathSeparator + appJar2;\n+    TestCommon.testDump(jars, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+    \/\/ copy hello.jar to USER_DIR\/deploy\n+    Path srcPath = Paths.get(appJar);\n+    Path newPath = Paths.get(USER_DIR.toString() + File.separator + \"deploy\");\n+    Path destDir = Files.createDirectory(newPath);\n+    Path destPath = destDir.resolve(jarName);\n+    Files.copy(srcPath, destPath, REPLACE_EXISTING, COPY_ATTRIBUTES);\n+\n+    \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/deploy\n+    idx = appJar2.lastIndexOf(File.separator);\n+    jarName = appJar2.substring(idx + 1);\n+    srcPath = Paths.get(appJar2);\n+    Path destPath2 = destDir.resolve(jarName);\n+    Files.copy(srcPath, destPath2, REPLACE_EXISTING, COPY_ATTRIBUTES);\n+\n+    \/\/ Run with both jars relocated to USER_DIR\/dpeloy - should PASS\n+    TestCommon.run(\n+        \"-Xshare:on\",\n+        \"-XX:SharedArchiveFile=\" + TestCommon.getCurrentArchiveName(),\n+        \"-cp\", destPath.toString() + File.pathSeparator + destPath2.toString(),\n+        \"-Xlog:class+load=trace,class+path=info\",\n+        \"HelloMore\")\n+        .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello source: shared objects file\")\n+                      .shouldContain(\"HelloMore source: shared objects file\")\n+                      .shouldHaveExitValue(0);\n+            });\n+\n+    \/\/ Run with relocation of only the second jar - should FAIL\n+    TestCommon.run(\n+        \"-Xshare:on\",\n+        \"-XX:SharedArchiveFile=\" + TestCommon.getCurrentArchiveName(),\n+        \"-cp\", appJar + File.pathSeparator + destPath2.toString(),\n+        \"-Xlog:class+load=trace,class+path=info\",\n+        \"HelloMore\")\n+        .assertAbnormalExit(output -> {\n+                output.shouldContain(\"APP classpath mismatch\")\n+                      .shouldHaveExitValue(1);\n+            });\n+\n+    \/\/ Run with relocation of only the first jar - should FAIL\n+    TestCommon.run(\n+        \"-Xshare:on\",\n+        \"-XX:SharedArchiveFile=\" + TestCommon.getCurrentArchiveName(),\n+        \"-cp\", destPath.toString() + File.pathSeparator + appJar2,\n+        \"-Xlog:class+load=trace,class+path=info\",\n+        \"HelloMore\")\n+        .assertAbnormalExit(output -> {\n+                output.shouldContain(\"APP classpath mismatch\")\n+                      .shouldHaveExitValue(1);\n+            });\n+\n+    \/\/ Dump CDS archive with the first jar relocated.\n+    jars = destPath.toString() + File.pathSeparator + appJar2;\n+    TestCommon.testDump(jars, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+    \/\/ Run with first jar relocated - should PASS\n+    TestCommon.run(\n+        \"-Xshare:on\",\n+        \"-XX:SharedArchiveFile=\" + TestCommon.getCurrentArchiveName(),\n+        \"-cp\", destPath.toString() + File.pathSeparator + appJar2,\n+        \"-Xlog:class+load=trace,class+path=info\",\n+        \"HelloMore\")\n+        .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello source: shared objects file\")\n+                      .shouldContain(\"HelloMore source: shared objects file\")\n+                      .shouldHaveExitValue(0);\n+            });\n+\n+    \/\/ Run with both jars relocated - should FAIL\n+    TestCommon.run(\n+        \"-Xshare:on\",\n+        \"-XX:SharedArchiveFile=\" + TestCommon.getCurrentArchiveName(),\n+        \"-cp\", destPath.toString() + File.pathSeparator + destPath2.toString(),\n+        \"-Xlog:class+load=trace,class+path=info\",\n+        \"HelloMore\")\n+        .assertAbnormalExit(output -> {\n+                output.shouldContain(\"APP classpath mismatch\")\n+                      .shouldHaveExitValue(1);\n+            });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommonAppClasspath.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -274,0 +274,12 @@\n+\n+        \/\/ modify _common_app_classpath_offset to point to middle of the common app classpath\n+        String wrongCommonAppClasspathOffset = startNewArchive(\"wrongCommonAppClasspathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, wrongCommonAppClasspathOffset);\n+        int commonAppClasspathSize = CDSArchiveUtils.commonAppClasspathSize(copiedJsa);\n+        System.out.println(\"    commonAppClasspathSize = \" + commonAppClasspathSize);\n+        int commonAppClasspathOffset = CDSArchiveUtils.commonAppClasspathOffset(copiedJsa);\n+        System.out.println(\"    commonAppClasspathOffset = \" + commonAppClasspathOffset);\n+        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetCommonAppClasspathOffset(), commonAppClasspathOffset + commonAppClasspathSize\/2);\n+        commonAppClasspathOffset = CDSArchiveUtils.commonAppClasspathOffset(copiedJsa);\n+        System.out.println(\"new commonAppClasspathOffset = \" + commonAppClasspathOffset);\n+        testAndCheck(verifyExecArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -153,1 +153,12 @@\n-        startTest(\"5. Make base archive name not terminated with '\\0'\");\n+        startTest(\"5. Make common app classpath offset points to middle of the common app classpath\");\n+        String wrongCommonAppClasspathOffset = getNewArchiveName(\"wrongCommonAppClasspathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongCommonAppClasspathOffset);\n+        int commonAppClasspathSize = CDSArchiveUtils.commonAppClasspathSize(copiedJsa);\n+        int commonAppClasspathOffset = CDSArchiveUtils.commonAppClasspathOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, commonAppClasspathOffset,\n+                                             commonAppClasspathOffset + commonAppClasspathSize\/2);\n+        runTwo(baseArchiveName, wrongCommonAppClasspathOffset,\n+               appJar, mainClass, isAuto ? 0 : 1,\n+               \"common app classpath is damaged\");\n+\n+        startTest(\"6. Make base archive name not terminated with '\\0'\");\n@@ -165,1 +176,1 @@\n-        startTest(\"6. Modify base archive name to a file that doesn't exist\");\n+        startTest(\"7. Modify base archive name to a file that doesn't exist\");\n@@ -185,1 +196,1 @@\n-        startTest(\"7. Non-exist base archive\");\n+        startTest(\"8. Non-exist base archive\");\n@@ -193,1 +204,1 @@\n-        startTest(\"8. Non-exist top archive\");\n+        startTest(\"9. Non-exist top archive\");\n@@ -201,1 +212,1 @@\n-        startTest(\"9. nost-exist-base and non-exist-top\");\n+        startTest(\"10. nost-exist-base and non-exist-top\");\n@@ -212,1 +223,1 @@\n-        startTest(\"10. -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=\" + topArchiveName);\n+        startTest(\"11. -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=\" + topArchiveName);\n@@ -222,1 +233,1 @@\n-        startTest(\"11. -XX:SharedArchiveFile=\" + topArchiveName + \" -XX:ArchiveClassesAtExit=\" + getNewArchiveName(\"top3\"));\n+        startTest(\"12. -XX:SharedArchiveFile=\" + topArchiveName + \" -XX:ArchiveClassesAtExit=\" + getNewArchiveName(\"top3\"));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8279366\n+ * @summary Test app class paths checking with the longest common path taken into account.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @compile ..\/test-classes\/Hello.java\n+ * @compile ..\/test-classes\/HelloMore.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. CommonAppClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n+public class CommonAppClasspath extends DynamicArchiveTestBase {\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(CommonAppClasspath::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        String mainClass = \"HelloMore\";\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"AppendClasspath_HelloMore\", mainClass);\n+\n+        \/\/ dump an archive with both jars in the original location\n+        String jars = appJar + File.pathSeparator + appJar2;\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        \/\/ copy hello.jar to USER_DIR\/deploy\n+        Path srcPath = Paths.get(appJar);\n+        Path newPath = Paths.get(USER_DIR.toString() + File.separator + \"deploy\");\n+        Path destDir = Files.createDirectory(newPath);\n+        int idx = appJar.lastIndexOf(File.separator);\n+        String jarName = appJar.substring(idx + 1);\n+        Path destPath = destDir.resolve(jarName);\n+        Files.copy(srcPath, destPath, REPLACE_EXISTING, COPY_ATTRIBUTES);\n+\n+        \/\/ copy AppendClasspath_HelloMore.jar to USER_DIR\/deploy\n+        idx = appJar2.lastIndexOf(File.separator);\n+        jarName = appJar2.substring(idx + 1);\n+        srcPath = Paths.get(appJar2);\n+        Path destPath2 = destDir.resolve(jarName);\n+        Files.copy(srcPath, destPath2, REPLACE_EXISTING, COPY_ATTRIBUTES);\n+\n+        \/\/ Run with both jars relocated to USER_DIR\/dpeloy - should PASS\n+        jars = destPath.toString() + File.pathSeparator + destPath2.toString();\n+        run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Hello source: shared objects file\")\n+                          .shouldContain(\"HelloMore source: shared objects file\")\n+                          .shouldHaveExitValue(0);\n+                });\n+\n+        \/\/ Run with relocation of only the second jar - should FAIL\n+        jars = appJar + File.pathSeparator + destPath2.toString();\n+        run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", jars, mainClass)\n+        .assertAbnormalExit(output -> {\n+                output.shouldContain(\"shared class paths mismatch\")\n+                      .shouldHaveExitValue(1);\n+            });\n+\n+        \/\/ Run with relocation of only the first jar - should FAIL\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", jars, mainClass)\n+        .assertAbnormalExit(output -> {\n+                output.shouldContain(\"shared class paths mismatch\")\n+                      .shouldHaveExitValue(1);\n+            });\n+\n+        \/\/ Dump CDS archive with the first jar relocated.\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        \/\/ Run with first jar relocated - should PASS\n+        jars = destPath.toString() + File.pathSeparator + appJar2;\n+        run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", jars, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Hello source: shared objects file\")\n+                          .shouldContain(\"HelloMore source: shared objects file\")\n+                          .shouldHaveExitValue(0);\n+                });\n+\n+        \/\/ Run with both jars relocated - should FAIL\n+        jars = destPath.toString() + File.pathSeparator + destPath2.toString();\n+        run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", jars, mainClass)\n+        .assertAbnormalExit(output -> {\n+                output.shouldContain(\"shared class paths mismatch\")\n+                      .shouldHaveExitValue(1);\n+            });\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CommonAppClasspath.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -56,0 +56,2 @@\n+    private static int offsetCommonAppClasspathOffset;\/\/ offset of GenericCDSFileMapHeader::_common_app_classpath_offset\n+    private static int offsetCommonAppClasspathSize;\/\/ offset of GenericCDSFileMapHeader::_common_app_classpath_size\n@@ -96,0 +98,2 @@\n+            offsetCommonAppClasspathOffset = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_common_app_classpath_offset\");\n+            offsetCommonAppClasspathSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_common_app_classpath_size\");\n@@ -134,0 +138,2 @@\n+    public static int offsetCommonAppClasspathOffset() { return offsetCommonAppClasspathOffset; }\n+    public static int offsetCommonAppClasspathSize() { return offsetCommonAppClasspathSize; }\n@@ -161,0 +167,8 @@\n+    public static int commonAppClasspathOffset(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetCommonAppClasspathOffset, 4);\n+    }\n+\n+    public static int commonAppClasspathSize(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetCommonAppClasspathSize, 4);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}