{"files":[{"patch":"@@ -161,1 +161,2 @@\n-  template <class T = MetaspaceObj> class MSORef : public Ref {\n+  template <class T, typename Enable = void>\n+  class MSORef : public Ref {\n@@ -210,1 +211,2 @@\n-  template <class T> class OtherArrayRef : public ArrayRef<T> {\n+  template <class T, typename Enable = void>\n+  class OtherArrayRef : public ArrayRef<T> {\n@@ -226,1 +228,1 @@\n-  template <class T = MetaspaceObj> class MSOArrayRef : public ArrayRef<T> {\n+  template <class T> class MSOArrayRef : public ArrayRef<T> {\n@@ -248,1 +250,1 @@\n-  template <class T = MetaspaceObj> class MSOPointerArrayRef : public ArrayRef<T*> {\n+  template <class T> class MSOPointerArrayRef : public ArrayRef<T*> {\n@@ -279,1 +281,2 @@\n-  \/\/ Note that the following will fail to compile:\n+  \/\/ Note that the following will fail to compile (to prevent you from adding new fields\n+  \/\/ into the MetaspaceObj subtypes that cannot be properly copied by CDS):\n@@ -282,3 +285,3 @@\n-  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a7);    => Hashtable is not a subclass of MetaspaceObj\n-  \/\/ Array<int*>*           a7 = ...;  it->push(&a6);    => int       is not a subclass of MetaspaceObj\n-  template <typename T, typename Enable = void>\n+  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a6);    => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<int*>*           a7 = ...;  it->push(&a7);    => int       is not a subclass of MetaspaceObj\n+  template <typename T>\n@@ -286,1 +289,1 @@\n-    using type = MSORef<T>;\n+    using type = MSORef<T, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>>;\n@@ -289,3 +292,3 @@\n-  template <typename T>\n-  struct RefMatcher<Array<T>, std::enable_if_t<!std::is_pointer<T>::value && !std::is_base_of<MetaspaceObj, T>::value>> {\n-    using type = OtherArrayRef<T>;\n+  template<typename T, typename Enable = void>\n+  struct ArrayRefMatcher {\n+    using type = OtherArrayRef<T, std::enable_if_t<!std::is_pointer<T>::value>>;\n@@ -294,2 +297,2 @@\n-  template <typename T>\n-  struct RefMatcher<Array<T>, std::enable_if_t<!std::is_pointer<T>::value &&  std::is_base_of<MetaspaceObj, T>::value>> {\n+  template<typename T>\n+  struct ArrayRefMatcher<T, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>> {\n@@ -299,2 +302,2 @@\n-  template <typename T>\n-  struct RefMatcher<Array<T*>, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>> {\n+  template<typename T>\n+  struct ArrayRefMatcher<T*, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>> {\n@@ -304,0 +307,19 @@\n+  template<typename T>\n+  struct RefMatcher<Array<T>> : public ArrayRefMatcher<T> {};\n+\n+#if 0\n+  \/\/ Enable this block if you're changing RefMatcher, to test for types that should be\n+  \/\/ disallowed by RefMatcher. Each of the following \"push\" calls should result in a\n+  \/\/ compile-time error.\n+  void test_disallowed_types(MetaspaceClosure* it) {\n+    Hashtable<bool, mtInternal>* h  = NULL;\n+    it->push(&h);\n+\n+    Array<Hashtable<bool, mtInternal>*>* a6 = NULL;\n+    it->push(&a6);\n+\n+    Array<int*>* a7 = NULL;\n+    it->push(&a7);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"}]}