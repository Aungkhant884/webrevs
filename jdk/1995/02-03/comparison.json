{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -161,2 +162,1 @@\n-  template <class T, typename Enable = void>\n-  class MSORef : public Ref {\n+  template <class T> class MSORef : public Ref {\n@@ -210,3 +210,2 @@\n-  \/\/ the fields inside T, so you should not embed any MetaspaceObj pointers inside T.\n-  template <class T, typename Enable = void>\n-  class OtherArrayRef : public ArrayRef<T> {\n+  \/\/ the fields inside T, so you should not embed any pointers inside T.\n+  template <class T> class OtherArrayRef : public ArrayRef<T> {\n@@ -270,66 +269,0 @@\n-  \/\/ RefMatcher uses SFINAE to provide the correct XxxRef type for wrapping a pointer when\n-  \/\/ MetaspaceClosure::push() is called. E.g.:\n-  \/\/\n-  \/\/ MetaspaceClosure*      it = ...;\n-  \/\/ Klass*                 o  = ...;  it->push(&o);     => MSORef\n-  \/\/ Array<int>*            a1 = ...;  it->push(&a1);    => OtherArrayRef\n-  \/\/ Array<Annotation>*     a2 = ...;  it->push(&a3);    => MSOArrayRef\n-  \/\/ Array<Klass*>*         a3 = ...;  it->push(&a2);    => MSOPointerArrayRef\n-  \/\/ Array<Array<Klass*>*>* a4 = ...;  it->push(&a3);    => MSOPointerArrayRef\n-  \/\/ Array<Annotation>*     a5 = ...;  it->push(&a3);    => MSOPointerArrayRef\n-  \/\/\n-  \/\/ Note that the following will fail to compile (to prevent you from adding new fields\n-  \/\/ into the MetaspaceObj subtypes that cannot be properly copied by CDS):\n-  \/\/\n-  \/\/ Hashtable*             h  = ...;  it->push(&h);     => Hashtable is not a subclass of MetaspaceObj\n-  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a6);    => Hashtable is not a subclass of MetaspaceObj\n-  \/\/ Array<int*>*           a7 = ...;  it->push(&a7);    => int       is not a subclass of MetaspaceObj\n-  template <typename T>\n-  struct RefMatcher {\n-    using type = MSORef<T, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>>;\n-  };\n-\n-  template<typename T, typename Enable = void>\n-  struct ArrayRefMatcher {\n-    using type = OtherArrayRef<T, std::enable_if_t<!std::is_pointer<T>::value>>;\n-  };\n-\n-  template<typename T>\n-  struct ArrayRefMatcher<T, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>> {\n-    using type = MSOArrayRef<T>;\n-  };\n-\n-  template<typename T>\n-  struct ArrayRefMatcher<T*, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>> {\n-    using type = MSOPointerArrayRef<T>;\n-  };\n-\n-  template<typename T>\n-  struct RefMatcher<Array<T>> : public ArrayRefMatcher<T> {};\n-\n-#if 0\n-  \/\/ Enable this block if you're changing RefMatcher, to test for types that should be\n-  \/\/ disallowed by RefMatcher. Each of the following \"push\" calls should result in a\n-  \/\/ compile-time error.\n-  void test_disallowed_types(MetaspaceClosure* it) {\n-    Hashtable<bool, mtInternal>* h  = NULL;\n-    it->push(&h);\n-\n-    Array<Hashtable<bool, mtInternal>*>* a6 = NULL;\n-    it->push(&a6);\n-\n-    Array<int*>* a7 = NULL;\n-    it->push(&a7);\n-  }\n-#endif\n-\n-public:\n-  \/\/ This is the main entry point for a subtype of MetaspaceObject to interate with a MetaspaceClosure.\n-  \/\/ See Annotations::metaspace_pointers_do().\n-  template <typename T>\n-  void push(T** mpp, Writability w = _default) {\n-    using RT = typename RefMatcher<T>::type;\n-    push_impl(new RT(mpp, w));\n-  }\n-\n-private:\n@@ -376,0 +309,61 @@\n+private:\n+  template <class REF_TYPE, typename T>\n+  void push_with_ref(T** mpp, Writability w) {\n+    push_impl(new REF_TYPE(mpp, w));\n+  }\n+\n+public:\n+  \/\/ When MetaspaceClosure::push(...) is called, pick the correct Ref subtype to handle it:\n+  \/\/\n+  \/\/ MetaspaceClosure*      it = ...;\n+  \/\/ Klass*                 o  = ...;  it->push(&o);     => MSORef\n+  \/\/ Array<int>*            a1 = ...;  it->push(&a1);    => OtherArrayRef\n+  \/\/ Array<Annotation>*     a2 = ...;  it->push(&a3);    => MSOArrayRef\n+  \/\/ Array<Klass*>*         a3 = ...;  it->push(&a2);    => MSOPointerArrayRef\n+  \/\/ Array<Array<Klass*>*>* a4 = ...;  it->push(&a3);    => MSOPointerArrayRef\n+  \/\/ Array<Annotation>*     a5 = ...;  it->push(&a3);    => MSOPointerArrayRef\n+  \/\/\n+  \/\/ Note that the following will fail to compile (to prevent you from adding new fields\n+  \/\/ into the MetaspaceObj subtypes that cannot be properly copied by CDS):\n+  \/\/\n+  \/\/ Hashtable*             h  = ...;  it->push(&h);     => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a6);    => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<int*>*           a7 = ...;  it->push(&a7);    => int       is not a subclass of MetaspaceObj\n+\n+  template <typename T>\n+  void push(T** mpp, Writability w = _default) {\n+    static_assert(std::is_base_of<MetaspaceObj, T>::value, \"Do not push pointers of arbitrary types\");\n+    push_with_ref<MSORef<T>>(mpp, w);\n+  }\n+\n+  template <typename T, ENABLE_IF(!std::is_base_of<MetaspaceObj, T>::value)>\n+  void push(Array<T>** mpp, Writability w = _default) {\n+    push_with_ref<OtherArrayRef<T>>(mpp, w);\n+  }\n+\n+  template <typename T, ENABLE_IF(std::is_base_of<MetaspaceObj, T>::value)>\n+  void push(Array<T>** mpp, Writability w = _default) {\n+    push_with_ref<MSOArrayRef<T>>(mpp, w);\n+  }\n+\n+  template <typename T>\n+  void push(Array<T*>** mpp, Writability w = _default) {\n+    static_assert(std::is_base_of<MetaspaceObj, T>::value, \"Do not push Arrays of arbitrary pointer types\");\n+    push_with_ref<MSOPointerArrayRef<T>>(mpp, w);\n+  }\n+\n+#if 0\n+  \/\/ Enable this block if you're changing the push(...) methods, to test for types that should be\n+  \/\/ disallowed. Each of the following \"push\" calls should result in a compile-time error.\n+  void test_disallowed_types(MetaspaceClosure* it) {\n+    Hashtable<bool, mtInternal>* h  = NULL;\n+    it->push(&h);\n+\n+    Array<Hashtable<bool, mtInternal>*>* a6 = NULL;\n+    it->push(&a6);\n+\n+    Array<int*>* a7 = NULL;\n+    it->push(&a7);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":65,"deletions":71,"binary":false,"changes":136,"status":"modified"}]}