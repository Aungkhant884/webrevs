{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n@@ -95,2 +97,2 @@\n-  \/\/ To work around the lack of a vtable, we use Ref class with templates\n-  \/\/ (see ObjectRef, PrimitiveArrayRef and PointerArrayRef)\n+  \/\/ To work around the lack of a vtable, we use the Ref class with templates\n+  \/\/ (see MSORef, OtherArrayRef, MSOArrayRef, and MSOPointerArrayRef)\n@@ -158,2 +160,2 @@\n-  \/\/ -------------------------------------------------- ObjectRef\n-  template <class T> class ObjectRef : public Ref {\n+  \/\/ MSORef -- iterate an instance of MetaspaceObj\n+  template <class T = MetaspaceObj> class MSORef : public Ref {\n@@ -170,1 +172,1 @@\n-    ObjectRef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n+    MSORef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n@@ -185,2 +187,2 @@\n-  \/\/ -------------------------------------------------- PrimitiveArrayRef\n-  template <class T> class PrimitiveArrayRef : public Ref {\n+  \/\/ abstract base class for MSOArrayRef, MSOPointerArrayRef and OtherArrayRef\n+  template <class T> class ArrayRef : public Ref {\n@@ -188,0 +190,1 @@\n+  protected:\n@@ -191,1 +194,0 @@\n-  protected:\n@@ -196,2 +198,1 @@\n-  public:\n-    PrimitiveArrayRef(Array<T>** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n+    ArrayRef(Array<T>** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n@@ -204,0 +205,8 @@\n+  };\n+\n+  \/\/ OtherArrayRef -- iterate an instance of Array<T>, where T is NOT a subtype of MetaspaceObj.\n+  \/\/ T can be a primitive type, since as int, or a structure. However, we do not scan\n+  \/\/ the fields inside T, so you should not embed any MetaspaceObj pointers inside T.\n+  template <class T> class OtherArrayRef : public ArrayRef<T> {\n+  public:\n+    OtherArrayRef(Array<T>** mpp, Writability w) : ArrayRef<T>(mpp, w) {}\n@@ -206,2 +215,2 @@\n-      Array<T>* array = dereference();\n-      log_trace(cds)(\"Iter(PrimitiveArray): %p [%d]\", array, array->length());\n+      Array<T>* array = ArrayRef<T>::dereference();\n+      log_trace(cds)(\"Iter(OtherArray): %p [%d]\", array, array->length());\n@@ -211,1 +220,1 @@\n-      log_trace(cds)(\"Iter(PrimitiveArray): %p [%d]\", array, array->length());\n+      log_trace(cds)(\"Iter(OtherArray): %p [%d]\", array, array->length());\n@@ -215,5 +224,8 @@\n-  \/\/ -------------------------------------------------- PointerArrayRef\n-  template <class T> class PointerArrayRef : public Ref {\n-    Array<T*>** _mpp;\n-    Array<T*>* dereference() const {\n-      return *_mpp;\n+  \/\/ MSOArrayRef -- iterate an instance of Array<T>, where T is a subtype of MetaspaceObj.\n+  \/\/ We recursively call T::metaspace_pointers_do() for each element in this array.\n+  template <class T = MetaspaceObj> class MSOArrayRef : public ArrayRef<T> {\n+  public:\n+    MSOArrayRef(Array<T>** mpp, Writability w) : ArrayRef<T>(mpp, w) {}\n+\n+    virtual void metaspace_pointers_do(MetaspaceClosure *it) const {\n+      metaspace_pointers_do_at_impl(it, ArrayRef<T>::dereference());\n@@ -221,3 +233,10 @@\n-  protected:\n-    virtual void** mpp() const {\n-      return (void**)_mpp;\n+    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {\n+      metaspace_pointers_do_at_impl(it, (Array<T>*)new_loc);\n+    }\n+  private:\n+    void metaspace_pointers_do_at_impl(MetaspaceClosure *it, Array<T>* array) const {\n+      log_trace(cds)(\"Iter(MSOArray): %p [%d]\", array, array->length());\n+      for (int i = 0; i < array->length(); i++) {\n+        T* elm = array->adr_at(i);\n+        elm->metaspace_pointers_do(it);\n+      }\n@@ -225,0 +244,1 @@\n+  };\n@@ -226,0 +246,3 @@\n+  \/\/ MSOPointerArrayRef -- iterate an instance of Array<T*>, where T is a subtype of MetaspaceObj.\n+  \/\/ We recursively call MetaspaceClosure::push() for each pointer in this array.\n+  template <class T = MetaspaceObj> class MSOPointerArrayRef : public ArrayRef<T*> {\n@@ -227,7 +250,1 @@\n-    PointerArrayRef(Array<T*>** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n-\n-    \/\/ all Arrays are read-only by default\n-    virtual bool is_read_only_by_default() const { return true; }\n-    virtual bool not_null()                const { return dereference() != NULL; }\n-    virtual int size()                     const { return dereference()->size(); }\n-    virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T*)); }\n+    MSOPointerArrayRef(Array<T*>** mpp, Writability w) : ArrayRef<T*>(mpp, w) {}\n@@ -236,1 +253,1 @@\n-      metaspace_pointers_do_at_impl(it, dereference());\n+      metaspace_pointers_do_at_impl(it, ArrayRef<T*>::dereference());\n@@ -243,1 +260,1 @@\n-      log_trace(cds)(\"Iter(ObjectArray): %p [%d]\", array, array->length());\n+      log_trace(cds)(\"Iter(MSOPointerArray): %p [%d]\", array, array->length());\n@@ -251,0 +268,46 @@\n+  \/\/ RefMatcher uses SFINAE to provide the correct XxxRef type for wrapping a pointer when\n+  \/\/ MetaspaceClosure::push() is called. E.g.:\n+  \/\/\n+  \/\/ MetaspaceClosure*      it = ...;\n+  \/\/ Klass*                 o  = ...;  it->push(&o);     => MSORef\n+  \/\/ Array<int>*            a1 = ...;  it->push(&a1);    => OtherArrayRef\n+  \/\/ Array<Annotation>*     a2 = ...;  it->push(&a3);    => MSOArrayRef\n+  \/\/ Array<Klass*>*         a3 = ...;  it->push(&a2);    => MSOPointerArrayRef\n+  \/\/ Array<Array<Klass*>*>* a4 = ...;  it->push(&a3);    => MSOPointerArrayRef\n+  \/\/ Array<Annotation>*     a5 = ...;  it->push(&a3);    => MSOPointerArrayRef\n+  \/\/\n+  \/\/ Note that the following will fail to compile:\n+  \/\/\n+  \/\/ Hashtable*             h  = ...;  it->push(&h);     => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a7);    => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<int*>*           a7 = ...;  it->push(&a6);    => int       is not a subclass of MetaspaceObj\n+  template <typename T, typename Enable = void>\n+  struct RefMatcher {\n+    using type = MSORef<T>;\n+  };\n+\n+  template <typename T>\n+  struct RefMatcher<Array<T>, std::enable_if_t<!std::is_pointer<T>::value && !std::is_base_of<MetaspaceObj, T>::value>> {\n+    using type = OtherArrayRef<T>;\n+  };\n+\n+  template <typename T>\n+  struct RefMatcher<Array<T>, std::enable_if_t<!std::is_pointer<T>::value &&  std::is_base_of<MetaspaceObj, T>::value>> {\n+    using type = MSOArrayRef<T>;\n+  };\n+\n+  template <typename T>\n+  struct RefMatcher<Array<T*>, std::enable_if_t<std::is_base_of<MetaspaceObj, T>::value>> {\n+    using type = MSOPointerArrayRef<T>;\n+  };\n+\n+public:\n+  \/\/ This is the main entry point for a subtype of MetaspaceObject to interate with a MetaspaceClosure.\n+  \/\/ See Annotations::metaspace_pointers_do().\n+  template <typename T>\n+  void push(T** mpp, Writability w = _default) {\n+    using RT = typename RefMatcher<T>::type;\n+    push_impl(new RT(mpp, w));\n+  }\n+\n+private:\n@@ -291,23 +354,0 @@\n-  \/\/ When you do:\n-  \/\/     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {\n-  \/\/       it->push(_my_field)\n-  \/\/     }\n-  \/\/\n-  \/\/ C++ will try to match the \"most specific\" template function. This one will\n-  \/\/ will be matched if possible (if mpp is an Array<> of any pointer type).\n-  template <typename T> void push(Array<T*>** mpp, Writability w = _default) {\n-    push_impl(new PointerArrayRef<T>(mpp, w));\n-  }\n-\n-  \/\/ If the above function doesn't match (mpp is an Array<>, but T is not a pointer type), then\n-  \/\/ this is the second choice.\n-  template <typename T> void push(Array<T>** mpp, Writability w = _default) {\n-    push_impl(new PrimitiveArrayRef<T>(mpp, w));\n-  }\n-\n-  \/\/ If the above function doesn't match (mpp is not an Array<> type), then\n-  \/\/ this will be matched by default.\n-  template <class T> void push(T** mpp, Writability w = _default) {\n-    push_impl(new ObjectRef<T>(mpp, w));\n-  }\n-\n@@ -315,1 +355,1 @@\n-    Ref* ref = new ObjectRef<T>(mpp, _default);\n+    Ref* ref = new MSORef<T>(mpp, _default);\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":95,"deletions":55,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"unittest.hpp\"\n+\n+class MyMetaData : public MetaspaceObj {\n+public:\n+  MyMetaData* _a;\n+  MyMetaData* _b;\n+\n+  MyMetaData() : _a(NULL), _b(NULL) {}\n+\n+  MetaspaceObj::Type type() const {\n+    return MetaspaceObj::SymbolType; \/\/ Just lie. It doesn't matter in this test\n+  }\n+  const char* internal_name()  const {\n+    return \"MyMetaData\";\n+  }\n+  int size() const {\n+    return align_up((int)sizeof(MyMetaData), wordSize) \/ wordSize;\n+  };\n+\n+  static bool is_read_only_by_default() {\n+    return true;\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_a);\n+    it->push(&_b);\n+  }\n+};\n+\n+class MyUniqueMetaspaceClosure : public MetaspaceClosure {\n+  static constexpr int SIZE = 10;\n+  MyMetaData* _visited[SIZE];\n+  int _count;\n+public:\n+  MyUniqueMetaspaceClosure() {\n+    for (int i = 0; i < SIZE; i++) {\n+      _visited[i] = NULL;\n+    }\n+    _count = 0;\n+  }\n+\n+  virtual bool do_ref(Ref* ref, bool read_only) {\n+    MyMetaData* ptr = (MyMetaData*)ref->obj();\n+    assert(_count < SIZE, \"out of bounds\");\n+    _visited[_count++] = ptr;\n+    return true; \/\/ recurse\n+  }\n+\n+  bool has_visited(MyMetaData* p) {\n+    for (int i = 0; i < SIZE; i++) {\n+      if (_visited[i] == p) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+};\n+\n+\/\/ iterate an Array<MyMetaData*>\n+TEST_VM(MetaspaceClosure, MSOPointerArrayRef) {\n+  Thread* THREAD = Thread::current();\n+  ClassLoaderData* cld = ClassLoaderData::the_null_class_loader_data();\n+  Array<MyMetaData*>* array = MetadataFactory::new_array<MyMetaData*>(cld, 4, THREAD);\n+  for (int i = 0; i < array->length(); i++) {\n+    EXPECT_TRUE(array->at(i) == NULL) << \"should be initialized to null\";\n+  }\n+\n+  MyMetaData x;\n+  MyMetaData y;\n+  MyMetaData z;\n+\n+  array->at_put(0, &x);\n+  array->at_put(2, &y);\n+  y._a = &z;\n+\n+  MyUniqueMetaspaceClosure closure;\n+  closure.push(&array);\n+\n+  EXPECT_TRUE(closure.has_visited(&x)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&y)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&z)) << \"must be\";\n+}\n+\n+\/\/ iterate an Array<MyMetaData>\n+TEST_VM(MetaspaceClosure, MSOArrayRef) {\n+  Thread* THREAD = Thread::current();\n+  ClassLoaderData* cld = ClassLoaderData::the_null_class_loader_data();\n+  Array<MyMetaData>* array = MetadataFactory::new_array<MyMetaData>(cld, 4, THREAD);\n+  for (int i = 0; i < array->length(); i++) {\n+    EXPECT_TRUE(array->at(i)._a == NULL) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i)._b == NULL) << \"should be initialized to null\";\n+  }\n+\n+  MyMetaData x;\n+  MyMetaData y;\n+  MyMetaData z;\n+\n+  array->adr_at(0)->_a = &x;\n+  array->adr_at(2)->_b = &y;\n+  y._a = &z;\n+\n+  MyUniqueMetaspaceClosure closure;\n+  closure.push(&array);\n+\n+  EXPECT_TRUE(closure.has_visited(&x)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&y)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&z)) << \"must be\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_metaspaceClosure.cpp","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}