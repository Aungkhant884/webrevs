{"files":[{"patch":"@@ -300,0 +300,9 @@\n+        \/**\n+         * Property to control {@link GetField#get(String, Object)} conversion of\n+         * {@link ClassNotFoundException} to {@code null}. If set to {@code true}\n+         * {@link GetField#get(String, Object)} returns null otherwise\n+         * throwing {@link ClassNotFoundException}.\n+         *\/\n+        private static final boolean GETFIELD_CNFE_RETURNS_NULL = GetBooleanAction\n+                .privilegedGetProperty(\"jdk.serialGetFieldCnfeReturnsNull\");\n+\n@@ -1599,0 +1608,1 @@\n+         * @throws ClassNotFoundException Class of a serialized object cannot be found.\n@@ -1604,1 +1614,1 @@\n-        public abstract Object get(String name, Object val) throws IOException;\n+        public abstract Object get(String name, Object val) throws IOException, ClassNotFoundException;\n@@ -2648,1 +2658,1 @@\n-        public Object get(String name, Object val) {\n+        public Object get(String name, Object val) throws ClassNotFoundException {\n@@ -2653,2 +2663,8 @@\n-                return (handles.lookupException(objHandle) == null) ?\n-                    objValues[off] : null;\n+                ClassNotFoundException ex = handles.lookupException(objHandle);\n+                if (ex == null)\n+                    return objValues[off];\n+                if (Caches.GETFIELD_CNFE_RETURNS_NULL) {\n+                    \/\/ Revert to the prior behavior; return null instead of CNFE\n+                    return null;\n+                }\n+                throw ex;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8273660\n+ * @summary Verify that ObjectInputStream ReadFields correctly reports ClassNotFoundException\n+ *    while getting the field value. The test uses Vector that calls ReadFields from its readObject.\n+ * @library \/test\/lib\n+ * @run testng ReadFieldsCNF\n+ * @run testng\/othervm -Djdk.serialGetFieldCnfeReturnsNull=true ReadFieldsCNF\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.StreamCorruptedException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Vector;\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+public class ReadFieldsCNF {\n+\n+    private static final boolean GETFIELD_CNFE_RETURNS_NULL =\n+            Boolean.getBoolean(\"jdk.serialGetFieldCnfeReturnsNull\");\n+\n+\n+    \/**\n+     * Test a Vector holding a reference to a class instance that will not be found.\n+     * @throws IOException If any other exception occurs\n+     *\/\n+    @Test\n+    private static void testVectorWithRole() throws IOException {\n+        System.out.println(\"Property GETFIELD_CNFE_RETURNS_NULL: \" + GETFIELD_CNFE_RETURNS_NULL);\n+\n+        Role role = new Role();\n+        Vector<Role> vector = new Vector<>();\n+        vector.add(role);\n+\n+        \/\/ Modify the byte stream to change the classname to be deserialized to\n+        \/\/ XeadFieldsCNF$Role.\n+        byte[] bytes = writeObject(vector);\n+\n+        \/\/ Locate the name of the class to be deserialize\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);  \/\/ Map bytes to chars\n+        int off = s.indexOf(Role.class.getName());\n+        System.out.printf(\"Role offset: %d (0x%x) : %s%n\", off, off, Role.class.getName());\n+        if (off < 0) {\n+            HexPrinter.simple().formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+            Assert.fail(\"classname not found\");\n+        }\n+\n+        bytes[off] = (byte) 'X';  \/\/ replace R with X -> Class not found\n+\n+        \/\/ Deserialize the Vector expecting a ClassNotFoundException\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            Object obj = in.readObject();\n+            System.out.println(\"Read: \" + obj);\n+            Assert.fail(\"Should not reach here, an exception should always occur\");\n+        } catch (ClassNotFoundException cnfe) {\n+            \/\/ Expected ClassNotFoundException\n+            String expected = \"XeadFieldsCNF$Role\";\n+            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            if (GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected IOException got ClassNotFoundException\", cnfe);\n+            }\n+            System.out.println(\"Normal:  OIS.readObject: \" + cnfe);\n+        } catch (StreamCorruptedException ioe) {\n+            if (!GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+            }\n+            System.out.println(\"Normal: \" + ioe);\n+        }\n+        \/\/ Other exceptions cause the test to fail\n+    }\n+\n+    \/**\n+     * For an object holding a reference to a class that will not be found.\n+     * @throws IOException If any other exception occurs\n+     *\/\n+    @Test\n+    private static void testHolderWithRole() throws IOException {\n+        System.out.println(\"Property GETFIELD_CNFE_RETURNS_NULL: \" + GETFIELD_CNFE_RETURNS_NULL);\n+        Role role = new Role();\n+        Holder holder = new Holder(role);\n+\n+        \/\/ Modify the byte stream to change the classname to be deserialized to\n+        \/\/ XeadFieldsCNF$Role.\n+        byte[] bytes = writeObject(holder);\n+\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);  \/\/ Map bytes to chars\n+        int off = s.indexOf(Role.class.getName(), 0);\n+        off = s.indexOf(Role.class.getName(), off + 1); \/\/ 2nd occurrence of classname\n+        System.out.printf(\"Role offset: %d (0x%x)%n\", off, off);\n+        if (off < 0) {\n+            HexPrinter.simple().formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+            Assert.fail(\"classname found at index: \" + off + \" (0x\" + Integer.toHexString(off) + \")\");\n+        }\n+\n+        bytes[off] = (byte) 'X';  \/\/ replace R with X -> Class not found\n+\n+        \/\/ Deserialize the Vector expecting a ClassNotFoundException\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            Holder obj = (Holder)in.readObject();\n+            System.out.println(\"Read: \" + obj);\n+            Assert.fail(\"Should not reach here, an exception should always occur\");\n+        } catch (ClassNotFoundException cnfe) {\n+            \/\/ Expected ClassNotFoundException\n+            String expected = \"XeadFieldsCNF$Role\";\n+            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            System.out.println(\"Normal: OIS.readObject: \" + cnfe);\n+        } catch (StreamCorruptedException ioe) {\n+            if (!GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+            }\n+            System.out.println(\"Normal: \" + ioe);\n+        }\n+        \/\/ Other exceptions cause the test to fail\n+    }\n+\n+    private static byte[] writeObject(Object o) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream os = new ObjectOutputStream(baos)) {\n+            os.writeObject(o);\n+        }\n+        return baos.toByteArray();\n+    }\n+\n+    static class Role implements Serializable {\n+        private static final long serialVersionUID = 0L;\n+\n+        Role() {}\n+    }\n+\n+    static class Holder implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+\n+        Role role;\n+\n+        Holder(Role role) {\n+            this.role = role;\n+        }\n+\n+        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+            ObjectInputStream.GetField fields = ois.readFields();\n+            try {\n+                Object repl = new Object();\n+                role = (Role)fields.get(\"role\", repl);\n+                System.out.println(\"Holder.readObject Role: \" + role);\n+            } catch (Exception ex) {\n+                \/\/ Catch CNFE and ignore it; check elsewhere that CNFE is thrown from OIS.readObject\n+                System.out.println(\"Normal: exception in Holder.readObject, ignoring: \" + ex);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"role: \" + role;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/GetField\/ReadFieldsCNF.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"}]}