{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.BufferUnderflowException;\n@@ -36,0 +37,3 @@\n+\n+import jdk.internal.net.http.common.Utils;\n+\n@@ -169,0 +173,21 @@\n+    \/**\n+     * Returns a character (char) corresponding to the next byte in the\n+     * input, interpreted as an ISO-8859-1 encoded character.\n+     * <p>\n+     * The ISO-8859-1 encoding is a 8-bit character coding that\n+     * corresponds to the first 256 Unicode characters - from U+0000 to\n+     * U+00FF. UTF-16 is backward compatible with ISO-8859-1 - which\n+     * means each byte in the input should be interpreted as an unsigned\n+     * value from [0, 255] representing the character code.\n+     *\n+     * @param input a {@code ByteBuffer} containing a partial input\n+     * @return the next byte in the input, interpreted as an ISO-8859-1\n+     * encoded char\n+     * @throws BufferUnderflowException\n+     *          if the input buffer's current position is not smaller\n+     *          than its limit\n+     *\/\n+    private char get(ByteBuffer input) {\n+        return (char)(input.get() & 0xFF);\n+    }\n+\n@@ -171,1 +196,1 @@\n-        while (input.hasRemaining() && (c =(char)input.get()) != CR) {\n+        while (input.hasRemaining() && (c = get(input)) != CR) {\n@@ -183,1 +208,1 @@\n-        char c = state == State.STATUS_LINE_FOUND_LF ? LF : (char)input.get();\n+        char c = state == State.STATUS_LINE_FOUND_LF ? LF : get(input);\n@@ -213,1 +238,1 @@\n-        char c = (char)input.get();\n+        char c = get(input);\n@@ -227,1 +252,1 @@\n-        char c = state == State.STATUS_LINE_END_LF ? LF : (char)input.get();\n+        char c = state == State.STATUS_LINE_END_LF ? LF : get(input);\n@@ -241,1 +266,1 @@\n-            char c = (char)input.get();\n+            char c = get(input);\n@@ -256,1 +281,1 @@\n-    private void addHeaderFromString(String headerString) {\n+    private void addHeaderFromString(String headerString) throws ProtocolException {\n@@ -261,4 +286,12 @@\n-        String name = headerString.substring(0, idx).trim();\n-        if (name.isEmpty())\n-            return;\n-        String value = headerString.substring(idx + 1, headerString.length()).trim();\n+        String name = headerString.substring(0, idx);\n+\n+        \/\/ compatibility with HttpURLConnection;\n+        if (name.isEmpty()) return;\n+\n+        if (!Utils.isValidName(name)) {\n+            throw protocolException(\"Invalid header name \\\"%s\\\"\", name);\n+        }\n+        String value = headerString.substring(idx + 1).trim();\n+        if (!Utils.isValidValue(value)) {\n+            throw protocolException(\"Invalid header value \\\"%s: %s\\\"\", name, value);\n+        }\n@@ -272,1 +305,1 @@\n-        char c = state == State.HEADER_FOUND_LF ? LF : (char)input.get();\n+        char c = state == State.HEADER_FOUND_LF ? LF : get(input);\n@@ -288,1 +321,1 @@\n-    private void resumeOrSecondCR(ByteBuffer input) {\n+    private void resumeOrSecondCR(ByteBuffer input) throws ProtocolException {\n@@ -290,1 +323,1 @@\n-        char c = (char)input.get();\n+        char c = get(input);\n@@ -325,1 +358,1 @@\n-        char c = (char)input.get();\n+        char c = get(input);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1HeaderParser.java","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -804,0 +804,1 @@\n+                    debug.log(\"Error decoding headers: \" + e.getMessage(), e);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-        for (char c = 0x21; c < 0xFF; c++) {\n+        for (char c = 0x21; c <= 0xFF; c++) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-    public static abstract class HttpTestExchange {\n+    public static abstract class HttpTestExchange implements AutoCloseable {\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8252374\n+ * @library \/test\/lib http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *       ReferenceTracker AggregateRequestBodyTest\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ *                     -Djdk.httpclient.HttpClient.log=requests,responses,errors\n+ *                     ISO_8859_1_Test\n+ * @summary Tests that a client is able to receive ISO-8859-1 encoded header values.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublisher;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLContext;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.Assert;\n+import org.testng.ITestContext;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+public class ISO_8859_1_Test implements HttpServerAdapters {\n+\n+    SSLContext sslContext;\n+    DummyServer http1DummyServer;\n+    HttpServerAdapters.HttpTestServer http1TestServer;   \/\/ HTTP\/1.1 ( http )\n+    HttpServerAdapters.HttpTestServer https1TestServer;  \/\/ HTTPS\/1.1 ( https  )\n+    HttpServerAdapters.HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpServerAdapters.HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http1Dummy;\n+    String http1URI;\n+    String https1URI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final int RESPONSE_CODE = 200;\n+    static final int ITERATION_COUNT = 4;\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<CompletionException> CE = CompletionException.class;\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    System.out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    System.err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            throw new RuntimeException(\"some tests failed\");\n+        }\n+    }\n+\n+    @AfterClass\n+    static final void printFailedTests() {\n+        out.println(\"\\n=========================\");\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+                e.getValue().printStackTrace();\n+            });\n+            if (tasksFailed) {\n+                System.out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private String[] uris() {\n+        return new String[] {\n+                http1Dummy,\n+                http1URI,\n+                https1URI,\n+                http2URI,\n+                https2URI,\n+        };\n+    }\n+\n+    static AtomicLong URICOUNT = new AtomicLong();\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            return new Object[0][];\n+        }\n+        String[] uris = uris();\n+        Object[][] result = new Object[uris.length * 2][];\n+        int i = 0;\n+        for (boolean sameClient : List.of(false, true)) {\n+            for (String uri : uris()) {\n+                result[i++] = new Object[]{uri, sameClient};\n+            }\n+        }\n+        assert i == uris.length * 2;\n+        return result;\n+    }\n+\n+    private HttpClient makeNewClient() {\n+        clientCount.incrementAndGet();\n+        HttpClient client =  HttpClient.newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build();\n+        return TRACKER.track(client);\n+    }\n+\n+    HttpClient newHttpClient(boolean share) {\n+        if (!share) return makeNewClient();\n+        HttpClient shared = sharedClient;\n+        if (shared != null) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient();\n+            }\n+            return shared;\n+        }\n+    }\n+\n+    private static final Exception completionCause(CompletionException x) {\n+        Throwable c = x;\n+        while (c  instanceof CompletionException\n+                || c instanceof ExecutionException) {\n+            if (c.getCause() == null) break;\n+            c = c.getCause();\n+        }\n+        if (c instanceof Error) throw (Error)c;\n+        return (Exception)c;\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    public void test(String uri, boolean sameClient) throws Exception {\n+        System.out.println(\"Request to \" + uri);\n+\n+        HttpClient client = newHttpClient(sameClient);\n+\n+        List<CompletableFuture<HttpResponse<String>>> cfs = new ArrayList<>();\n+        for (int i = 0; i < ITERATION_COUNT; i++) {\n+            HttpRequest request = HttpRequest.newBuilder(URI.create(uri + \"\/\" + i))\n+                    .build();\n+            cfs.add(client.sendAsync(request, BodyHandlers.ofString()));\n+        }\n+        try {\n+            CompletableFuture.allOf(cfs.toArray(CompletableFuture[]::new)).join();\n+        } catch (CompletionException x) {\n+            throw completionCause(x);\n+        }\n+        for (CompletableFuture<HttpResponse<String>> cf : cfs) {\n+            var response = cf.get();\n+            System.out.println(\"Got: \" + response);\n+            var value = response.headers().firstValue(\"Header8859\").orElse(null);\n+            assertEquals(value, \"U\\u00ffU\");\n+        }\n+        System.out.println(\"HttpClient: PASSED\");\n+        if (uri.contains(\"http1\")) {\n+            System.out.println(\"Testing with URLConnection\");\n+            var url = URI.create(uri).toURL();\n+            var conn = url.openConnection();\n+            conn.connect();\n+            conn.getInputStream().readAllBytes();\n+            var value = conn.getHeaderField(\"Header8859\");\n+            assertEquals(value, \"U\\u00ffU\", \"legacy stack failed\");\n+            System.out.println(\"URLConnection: PASSED\");\n+        }\n+        System.out.println(\"test: DONE\");\n+    }\n+\n+    static final class DummyServer extends Thread implements AutoCloseable {\n+        String RESP = \"\"\"\n+                HTTP\/1.1 200 OK\\r\n+                Content-length: 0\\r\n+                Header8859: U\\u00ffU\\r\n+                Connection: close\\r\n+                \\r\n+                \"\"\";\n+\n+        static final InetSocketAddress LOOPBACK =\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        final ServerSocket socket;\n+        final CopyOnWriteArrayList<Socket> accepted = new CopyOnWriteArrayList<Socket>();\n+        final CompletableFuture<Void> done = new CompletableFuture();\n+        volatile boolean closed;\n+        DummyServer() throws IOException  {\n+            socket = new ServerSocket();\n+            socket.bind(LOOPBACK);\n+        }\n+\n+        public String serverAuthority() {\n+            String address = socket.getInetAddress().getHostAddress();\n+            if (address.indexOf(':') >= 0) {\n+                address = \"[\" + address + \"]\";\n+            }\n+            return address + \":\" + socket.getLocalPort();\n+        }\n+\n+        public void run() {\n+            try {\n+                while (!socket.isClosed()) {\n+                    try (Socket client = socket.accept()) {\n+                        accepted.add(client);\n+                        try {\n+                            System.out.println(\"Accepted: \" + client);\n+                            String req = \"\";\n+                            BufferedReader reader = new BufferedReader(\n+                                    new InputStreamReader(client.getInputStream(),\n+                                            StandardCharsets.ISO_8859_1));\n+                            String line = null;\n+                            while (!(line = reader.readLine()).isEmpty()) {\n+                                System.out.println(\"Got line: \" + line);\n+                                req = req + line + \"\\r\\n\";\n+                            }\n+                            System.out.println(req);\n+                            System.out.println(\"Sending back \" + RESP);\n+                            client.getOutputStream().write(RESP.getBytes(StandardCharsets.ISO_8859_1));\n+                            client.getOutputStream().flush();\n+                        } finally {\n+                            accepted.remove(client);\n+                        }\n+                    }\n+                }\n+            } catch (Throwable t) {\n+                if (closed) {\n+                    done.complete(null);\n+                } else {\n+                    done.completeExceptionally(t);\n+                }\n+            } finally {\n+                done.complete(null);\n+            }\n+        }\n+\n+        final void close(AutoCloseable toclose) {\n+            try { toclose.close(); } catch (Exception x) {};\n+        }\n+\n+        final public void close() {\n+            closed = true;\n+            close(socket);\n+            accepted.forEach(this::close);\n+        }\n+    }\n+\n+    final static class ISO88591Handler implements HttpServerAdapters.HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (HttpTestExchange e = t) {\n+                t.getRequestBody().readAllBytes();\n+                t.getResponseHeaders().addHeader(\"Header8859\", \"U\\u00ffU\");\n+                t.sendResponseHeaders(200, 0);\n+            }\n+\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        HttpServerAdapters.HttpTestHandler handler = new ISO88591Handler();\n+        InetSocketAddress loopback = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        http1DummyServer = new DummyServer();\n+        http1Dummy = \"http:\/\/\" + http1DummyServer.serverAuthority() +\"\/http1\/dummy\/x\";\n+\n+        HttpServer http1 = HttpServer.create(loopback, 0);\n+        http1TestServer = HttpServerAdapters.HttpTestServer.of(http1);\n+        http1TestServer.addHandler(handler, \"\/http1\/server\/\");\n+        http1URI = \"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/server\/x\";\n+\n+        HttpsServer https1 = HttpsServer.create(loopback, 0);\n+        https1.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        https1TestServer = HttpServerAdapters.HttpTestServer.of(https1);\n+        https1TestServer.addHandler(handler, \"\/https1\/server\/\");\n+        https1URI = \"https:\/\/\" + https1TestServer.serverAuthority() + \"\/https1\/server\/x\";\n+\n+        \/\/ HTTP\/2\n+        http2TestServer = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(handler, \"\/http2\/server\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/server\/x\";\n+\n+        https2TestServer = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(handler, \"\/https2\/server\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/server\/x\";\n+\n+        serverCount.addAndGet(5);\n+        http1TestServer.start();\n+        https1TestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+        http1DummyServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        String sharedClientName =\n+                sharedClient == null ? null : sharedClient.toString();\n+        sharedClient = null;\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            http1TestServer.stop();\n+            https1TestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+            http1DummyServer.close();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    System.err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ISO_8859_1_Test.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n@@ -72,0 +73,6 @@\n+              \"HTTP\/1.1 200 OK\\r\\n\" +\n+              \"X-Header: U\\u00ffU\\r\\n\" + \/\/ value with U+00FF - Extended Latin-1\n+              \"Content-Length: 9\\r\\n\" +\n+              \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+              \"XXXXX\",\n+\n@@ -225,1 +232,3 @@\n-             \": no header\\r\\n\\r\\n\" +  \/\/ no\/empty header-name, followed by header\n+             \"X-foo: bar\\r\\n\" +\n+             \" : no header\\r\\n\" +  \/\/ fold, not a blank header-name\n+             \"Content-Length: 65\\r\\n\\r\\n\" +\n@@ -229,3 +238,7 @@\n-             \"Conte\\r\" +\n-             \" nt-Length: 9\\r\\n\" +    \/\/ fold\/bad header name ???\n-             \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+             \"X-foo: bar\\r\\n\" +\n+             \" \\t : no header\\r\\n\" +  \/\/ fold, not a blank header-name\n+             \"Content-Length: 65\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \": no header\\r\\n\\r\\n\" +  \/\/ no\/empty header-name, followed by header\n@@ -313,1 +326,1 @@\n-        byte[] bytes = respString.getBytes(US_ASCII);\n+        byte[] bytes = respString.getBytes(ISO_8859_1);\n@@ -329,1 +342,1 @@\n-            assertEquals(statusLine1, statusLine2, \"Status-line not equal\");\n+            assertEquals(statusLine2, statusLine1, \"Status-line not equal\");\n@@ -387,1 +400,47 @@\n-             \"HTTP\/1.1 -20 \\r\\n\"\n+             \"HTTP\/1.1 -20 \\r\\n\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \"X-fo\\u00ffo: foo\\r\\n\" +     \/\/ invalid char in name\n+             \"Content-Length: 5\\r\\n\" +\n+             \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \"X-foo : bar\\r\\n\" +          \/\/  trim space after name\n+             \"Content-Length: 5\\r\\n\" +\n+             \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \" X-foo: bar\\r\\n\" +          \/\/ trim space before name\n+             \"Content-Length: 5\\r\\n\" +\n+             \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \"X foo: bar\\r\\n\" +           \/\/ invalid space in name\n+             \"Content-Length: 5\\r\\n\" +\n+             \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \"Content-Length: 5\\r\\n\" +\n+             \"Content Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" + \/\/ invalid space in name\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \"Conte\\r\" +\n+             \" nt-Length: 9\\r\\n\" +    \/\/ fold results in space in header name\n+             \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \" : no header\\r\\n\" +  \/\/ all blank header-name (not fold)\n+             \"Content-Length: 65\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n+\n+             \"HTTP\/1.1 200 OK\\r\\n\" +\n+             \" \\t : no header\\r\\n\" +  \/\/ all blank header-name (not fold)\n+             \"Content-Length: 65\\r\\n\\r\\n\" +\n+             \"XXXXX\",\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/Http1HeaderParserTest.java","additions":67,"deletions":8,"binary":false,"changes":75,"status":"modified"}]}