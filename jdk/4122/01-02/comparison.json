{"files":[{"patch":"@@ -1098,2 +1098,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($src3$$reg), -1);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               ptrue, as_FloatRegister($src3$$reg), -1);\n@@ -3306,2 +3306,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($src1$$reg), 0);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               ptrue, as_FloatRegister($src1$$reg), 0);\n@@ -3326,2 +3326,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($src1$$reg), -1);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               ptrue, as_FloatRegister($src1$$reg), -1);\n@@ -3346,2 +3346,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),\n-                 as_FloatRegister($src1$$reg), 0);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($src1$$reg), 0);\n@@ -3366,2 +3366,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),\n-                 as_FloatRegister($src1$$reg), -1);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($src1$$reg), -1);\n@@ -3392,2 +3392,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -3413,2 +3413,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -3440,2 +3440,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -3461,2 +3461,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ D, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -3482,2 +3482,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ D, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -3505,2 +3505,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -3890,1 +3890,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -3907,1 +3907,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -3924,1 +3924,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -3941,1 +3941,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -3959,1 +3959,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -3977,1 +3977,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -730,2 +730,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($src3$$reg), -1);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               ptrue, as_FloatRegister($src3$$reg), -1);\n@@ -2076,2 +2076,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($src1$$reg), $3);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               ptrue, as_FloatRegister($src1$$reg), $3);\n@@ -2103,2 +2103,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),\n-                 as_FloatRegister($src1$$reg), $3);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($src1$$reg), $3);\n@@ -2132,2 +2132,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -2153,2 +2153,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -2180,2 +2180,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -2203,2 +2203,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ $3, ptrue,\n+               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n@@ -2229,2 +2229,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n@@ -2558,1 +2558,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n@@ -2583,1 +2583,1 @@\n-    int size = $esize$$constant;\n+    unsigned size = $esize$$constant;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -57,0 +57,11 @@\n+Assembler::SIMD_RegVariant Assembler::_esize2regvariant[9] = {\n+  INVALID,\n+  B,\n+  H,\n+  INVALID,\n+  S,\n+  INVALID,\n+  INVALID,\n+  INVALID,\n+  D,\n+};\n@@ -58,3 +69,4 @@\n-Assembler::SIMD_Arrangement Assembler::esize2arrangement(int esize, bool isQ) {\n-    guarantee(esize == 1 || esize == 2 || esize == 4 || esize == 8, \"unsupported element size\");\n-    return _esize2arrangement_table[esize][isQ];\n+Assembler::SIMD_Arrangement Assembler::esize2arrangement(unsigned esize, bool isQ) {\n+  assert(esize < ARRAY_SIZE(_esize2arrangement_table) &&\n+         _esize2arrangement_table[esize][isQ] != INVALID_ARRANGEMENT, \"unsupported element size\");\n+  return _esize2arrangement_table[esize][isQ];\n@@ -63,15 +75,4 @@\n-Assembler::SIMD_RegVariant Assembler::elemBytes_to_regVariant(int esize) {\n-  switch(esize) {\n-    case 1:\n-      return B;\n-    case 2:\n-      return H;\n-    case 4:\n-      return S;\n-    case 8:\n-      return D;\n-    default:\n-      assert(false, \"unsupported\");\n-      ShouldNotReachHere();\n-  }\n-  return INVALID;\n+Assembler::SIMD_RegVariant Assembler::elemBytes_to_regVariant(unsigned esize) {\n+  assert(esize < ARRAY_SIZE(_esize2regvariant) && _esize2regvariant[esize] != INVALID,\n+         \"unsupported element size\");\n+  return _esize2regvariant[esize];\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1505,0 +1505,4 @@\n+  enum SIMD_RegVariant {\n+      B, H, S, D, Q, INVALID\n+  };\n+\n@@ -1508,0 +1512,1 @@\n+  static SIMD_RegVariant _esize2regvariant[9];\n@@ -1511,5 +1516,1 @@\n-  enum SIMD_RegVariant {\n-    B, H, S, D, Q, INVALID\n-  };\n-\n-  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+  static SIMD_Arrangement esize2arrangement(unsigned esize, bool isQ);\n@@ -1517,1 +1518,1 @@\n-  static SIMD_RegVariant elemBytes_to_regVariant(int esize);\n+  static SIMD_RegVariant elemBytes_to_regVariant(unsigned esize);\n@@ -2932,1 +2933,1 @@\n-\/\/ SVE arithmetics - unpredicated\n+\/\/ SVE arithmetic - unpredicated\n@@ -2969,1 +2970,1 @@\n-\/\/ SVE integer arithmetics - predicate\n+\/\/ SVE integer arithmetic - predicate\n@@ -2997,1 +2998,1 @@\n-\/\/ SVE floating-point arithmetics - predicate\n+\/\/ SVE floating-point arithmetic - predicate\n@@ -3126,1 +3127,1 @@\n-\/\/ SVE load\/store - predicated\n+\/\/ SVE contiguous load\/store\n@@ -3143,1 +3144,1 @@\n-\/\/ SVE load gather, store scatter (scalar plus vector) - 32-bit scaled offset\n+\/\/ Gather\/scatter load\/store (SVE) - scalar plus vector\n@@ -3150,1 +3151,1 @@\n-\n+  \/\/ SVE 32-bit gather load words (scalar plus 32-bit scaled offsets)\n@@ -3152,0 +3153,1 @@\n+  \/\/ SVE 64-bit gather load (scalar plus 32-bit unpacked scaled offsets)\n@@ -3153,0 +3155,1 @@\n+  \/\/ SVE 32-bit scatter store (scalar plus 32-bit scaled offsets)\n@@ -3154,0 +3157,1 @@\n+  \/\/ SVE 64-bit scatter store (scalar plus unpacked 32-bit scaled offsets)\n@@ -3170,0 +3174,1 @@\n+\/\/ SVE stack frame adjustment\n@@ -3177,2 +3182,2 @@\n-  INSN(sve_addvl, 0b01);\n-  INSN(sve_addpl, 0b11);\n+  INSN(sve_addvl, 0b01); \/\/ Add multiple of vector register size to scalar register\n+  INSN(sve_addpl, 0b11); \/\/ Add multiple of predicate register size to scalar register\n@@ -3194,1 +3199,9 @@\n-  \/\/ SVE dup scalar\n+  \/\/ SVE increment register by predicate count\n+  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n+    prf(pg, 5), rf(rd, 0);\n+  }\n+\n+  \/\/ SVE broadcast general-purpose register to vector elements (unpredicated)\n@@ -3202,1 +3215,1 @@\n-  \/\/ SVE dup imm\n+  \/\/ SVE broadcast signed immediate to vector elements (unpredicated)\n@@ -3225,1 +3238,1 @@\n-  \/\/ SVE cpy general-purpose register\n+  \/\/ SVE copy general-purpose register to vector elements (predicated)\n@@ -3233,1 +3246,1 @@\n-  \/\/ SVE cpy immediate\n+  \/\/ SVE copy signed integer immediate to vector elements (predicated)\n@@ -3251,1 +3264,1 @@\n-  \/\/ SVE sel (vectors)\n+  \/\/ SVE conditionally select elements from two vectors\n@@ -3260,31 +3273,46 @@\n-\/\/ SVE compare vectors\n-#define INSN(NAME, op, cond, fp)  \\\n-  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm)  { \\\n-    starti;                                                                                       \\\n-    if (fp == 0) {                                                                                \\\n-      assert(T != Q, \"invalid size\");                                                             \\\n-    } else {                                                                                      \\\n-      assert(T != B && T != Q, \"invalid size\");                                                   \\\n-    }                                                                                             \\\n-    f(op, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);                \\\n-    pgrf(Pg, 10), rf(Zn, 5), f(cond & 1, 4), prf(Pd, 0);                                          \\\n-  }\n-\n-  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);  \/\/ Compare signed equal to vector\n-  INSN(sve_cmpne, 0b00100100, 0b1011, 0);  \/\/ Compare not equal to vector\n-  INSN(sve_cmpge, 0b00100100, 0b1000, 0);  \/\/ Compare signed greater than or equal to vector\n-  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);  \/\/ Compare signed greater than vector\n-  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);  \/\/ Floating-point compare vectors: Equal\n-  INSN(sve_fcmne, 0b01100101, 0b0111, 1);  \/\/ Floating-point compare vectors: Not Equal\n-  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);  \/\/ Floating-point compare vectors: Greater than\n-  INSN(sve_fcmge, 0b01100101, 0b0100, 1);  \/\/ Floating-point compare vectors: Greater than or equal\n-#undef INSN\n-\n-\/\/ SVE compare vector with immediate\n-#define INSN(NAME, cond)  \\\n-  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, int imm5) { \\\n-    starti;                                                                              \\\n-    assert(T != Q, \"invalid size\");                                                      \\\n-    guarantee(-16 <= imm5 && imm5 <= 15, \"invalid immediate\");                           \\\n-    f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),                   \\\n-    f((cond >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0); \\\n+\/\/ SVE Integer\/Floating-Point Compare - Vectors\n+#define INSN(NAME, op1, op2, fp)  \\\n+  void NAME(Condition cond, PRegister Pd, SIMD_RegVariant T, PRegister Pg,             \\\n+            FloatRegister Zn, FloatRegister Zm) {                                      \\\n+    starti;                                                                            \\\n+    if (fp == 0) {                                                                     \\\n+      assert(T != Q, \"invalid size\");                                                  \\\n+    } else {                                                                           \\\n+      assert(T != B && T != Q, \"invalid size\");                                        \\\n+      assert(cond != HI && cond != HS, \"invalid condition for fcm\");                   \\\n+    }                                                                                  \\\n+    int cond_op;                                                                       \\\n+    switch(cond) {                                                                     \\\n+      case EQ: cond_op = (op2 << 2) | 0b10; break;                                     \\\n+      case NE: cond_op = (op2 << 2) | 0b11; break;                                     \\\n+      case GE: cond_op = (op2 << 2) | 0b00; break;                                     \\\n+      case GT: cond_op = (op2 << 2) | 0b01; break;                                     \\\n+      case HI: cond_op = 0b0001; break;                                                \\\n+      case HS: cond_op = 0b0000; break;                                                \\\n+      default:                                                                         \\\n+        ShouldNotReachHere();                                                          \\\n+    }                                                                                  \\\n+    f(op1, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond_op >> 1) & 7, 15, 13); \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond_op & 1, 4), prf(Pd, 0);                            \\\n+  }\n+\n+  INSN(sve_cmp, 0b00100100, 0b10, 0);\n+  INSN(sve_fcm, 0b01100101, 0b01, 1);\n+#undef INSN\n+\n+\/\/ SVE Integer Compare - Signed Immediate\n+void sve_cmp(Condition cond, PRegister Pd, SIMD_RegVariant T,\n+             PRegister Pg, FloatRegister Zn, int imm5) {\n+  starti;\n+  assert(T != Q, \"invalid size\");\n+  guarantee(-16 <= imm5 && imm5 <= 15, \"invalid immediate\");\n+  int cond_op;\n+  switch(cond) {\n+    case EQ: cond_op = 0b1000; break;\n+    case NE: cond_op = 0b1001; break;\n+    case GE: cond_op = 0b0000; break;\n+    case GT: cond_op = 0b0001; break;\n+    case LE: cond_op = 0b0011; break;\n+    case LT: cond_op = 0b0010; break;\n+    default:\n+      ShouldNotReachHere();\n@@ -3292,0 +3320,4 @@\n+  f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),\n+  f((cond_op >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5);\n+  f(cond_op & 0x1, 4), prf(Pd, 0);\n+}\n@@ -3293,9 +3325,1 @@\n-  INSN(sve_cmpeq, 0b1000);\n-  INSN(sve_cmpne, 0b1001);\n-  INSN(sve_cmpgt, 0b0001);\n-  INSN(sve_cmpge, 0b0000);\n-  INSN(sve_cmplt, 0b0010);\n-  INSN(sve_cmple, 0b0011);\n-#undef INSN\n-\n-\/\/ SVE unpack and extend\n+\/\/ SVE unpack vector elements\n@@ -3310,4 +3334,4 @@\n-  INSN(sve_uunpkhi, 0b11);\n-  INSN(sve_uunpklo, 0b10);\n-  INSN(sve_sunpkhi, 0b01);\n-  INSN(sve_sunpklo, 0b00);\n+  INSN(sve_uunpkhi, 0b11); \/\/ Signed unpack and extend half of vector - high half\n+  INSN(sve_uunpklo, 0b10); \/\/ Signed unpack and extend half of vector - low half\n+  INSN(sve_sunpkhi, 0b01); \/\/ Unsigned unpack and extend half of vector - high half\n+  INSN(sve_sunpklo, 0b00); \/\/ Unsigned unpack and extend half of vector - low half\n@@ -3316,1 +3340,1 @@\n-\/\/ SVE uzp1\/uzp2 (vectors)\n+\/\/ SVE permute vector elements\n@@ -3325,2 +3349,2 @@\n-  INSN(sve_uzp1, 0b0);\n-  INSN(sve_uzp2, 0b1);\n+  INSN(sve_uzp1, 0b0); \/\/ Concatenate even elements from two vectors\n+  INSN(sve_uzp2, 0b1); \/\/ Concatenate odd elements from two vectors\n@@ -3353,1 +3377,1 @@\n-\/\/ SVE predicate break after\/before first true condition\n+\/\/ SVE partition break condition\n@@ -3361,2 +3385,2 @@\n-  INSN(sve_brka, 0b00);\n-  INSN(sve_brkb, 0b10);\n+  INSN(sve_brka, 0b00); \/\/ Break after first true condition\n+  INSN(sve_brkb, 0b10); \/\/ Break before first true condition\n@@ -3387,8 +3411,0 @@\n-  \/\/ Increment scalar by active predicate element count\n-  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n-    starti;\n-    assert(T != Q, \"invalid size\");\n-    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n-    prf(pg, 5), rf(rd, 0);\n-  }\n-\n@@ -3489,1 +3505,1 @@\n-  \/\/ SVE INDEX (immediates)\n+  \/\/ SVE create index starting from and incremented by immediate\n@@ -3497,1 +3513,1 @@\n-  \/\/ SVE programmable table lookup in single vector table\n+  \/\/ SVE programmable table lookup\/permute using vector of element indices\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":95,"deletions":79,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-    sve_cmpeq(tmp_pdn, T, tmp_pg, ztmp1, ztmp2);\n+    sve_cmp(Assembler::EQ, tmp_pdn, T, tmp_pg, ztmp1, ztmp2);\n@@ -908,1 +908,1 @@\n-  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt), isQ);\n@@ -950,0 +950,16 @@\n+  assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n+  FloatRegister z1 = zn, z2 = zm;\n+  \/\/ Convert the original BoolTest condition to Assembler::condition.\n+  Condition condition;\n+  switch (cond) {\n+    case BoolTest::eq: condition = Assembler::EQ; break;\n+    case BoolTest::ne: condition = Assembler::NE; break;\n+    case BoolTest::le: z1 = zm; z2 = zn;  \/\/ Swap the two inputs\n+    case BoolTest::ge: condition = Assembler::GE; break;\n+    case BoolTest::lt: z1 = zm; z2 = zn;  \/\/ Swap the two inputs\n+    case BoolTest::gt: condition = Assembler::GT; break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n+\n@@ -952,11 +968,1 @@\n-    switch (cond) {\n-      case BoolTest::eq: sve_fcmeq(pd, size, pg, zn, zm); break;\n-      case BoolTest::ne: sve_fcmne(pd, size, pg, zn, zm); break;\n-      case BoolTest::ge: sve_fcmge(pd, size, pg, zn, zm); break;\n-      case BoolTest::gt: sve_fcmgt(pd, size, pg, zn, zm); break;\n-      case BoolTest::le: sve_fcmge(pd, size, pg, zm, zn); break;\n-      case BoolTest::lt: sve_fcmgt(pd, size, pg, zm, zn); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+    sve_fcm(condition, pd, size, pg, z1, z2);\n@@ -964,11 +970,2 @@\n-    switch (cond) {\n-      case BoolTest::eq: sve_cmpeq(pd, size, pg, zn, zm); break;\n-      case BoolTest::ne: sve_cmpne(pd, size, pg, zn, zm); break;\n-      case BoolTest::ge: sve_cmpge(pd, size, pg, zn, zm); break;\n-      case BoolTest::gt: sve_cmpgt(pd, size, pg, zn, zm); break;\n-      case BoolTest::le: sve_cmpge(pd, size, pg, zm, zn); break;\n-      case BoolTest::lt: sve_cmpgt(pd, size, pg, zm, zn); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+    assert(is_integral_type(bt), \"unsupported element type\");\n+    sve_cmp(condition, pd, size, pg, z1, z2);\n@@ -982,1 +979,1 @@\n-  sve_cmpne(pn, size, pg, src, 0);\n+  sve_cmp(Assembler::NE, pn, size, pg, src, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"}]}