{"files":[{"patch":"@@ -476,14 +476,5 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  ucontext_t *uc = (ucontext_t*)context;\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.iar);\n-  st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.lr);\n-  st->print(\"sp =\"); print_location(st, (intptr_t)os::Aix::ucontext_get_sp(uc));\n-  for (int i = 0; i < 32; i++) {\n-    st->print(\"r%-2d=\", i);\n-    print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.gpr[i]);\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 32 \/* r0-r32 *\/ + 3 \/* pc, lr, sp *\/;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n@@ -492,1 +483,21 @@\n-  st->cr();\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    switch (n) {\n+    case 0:\n+      st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.iar);\n+      break;\n+    case 1:\n+      st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.lr);\n+      break;\n+    case 2:\n+      st->print(\"sp =\"); print_location(st, (intptr_t)os::Aix::ucontext_get_sp(uc));\n+      break;\n+    default:\n+      st->print(\"r%-2d=\", n-3);\n+      print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.gpr[n-3]);\n+      break;\n+    }\n+    ++n;\n+  }\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -484,2 +484,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 29 \/* x0-x28 *\/ + 3 \/* fp, lr, sp *\/;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -488,41 +492,19 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n-  st->print(\" x0=\"); print_location(st, uc->context_x[ 0]);\n-  st->print(\" x1=\"); print_location(st, uc->context_x[ 1]);\n-  st->print(\" x2=\"); print_location(st, uc->context_x[ 2]);\n-  st->print(\" x3=\"); print_location(st, uc->context_x[ 3]);\n-  st->print(\" x4=\"); print_location(st, uc->context_x[ 4]);\n-  st->print(\" x5=\"); print_location(st, uc->context_x[ 5]);\n-  st->print(\" x6=\"); print_location(st, uc->context_x[ 6]);\n-  st->print(\" x7=\"); print_location(st, uc->context_x[ 7]);\n-  st->print(\" x8=\"); print_location(st, uc->context_x[ 8]);\n-  st->print(\" x9=\"); print_location(st, uc->context_x[ 9]);\n-  st->print(\"x10=\"); print_location(st, uc->context_x[10]);\n-  st->print(\"x11=\"); print_location(st, uc->context_x[11]);\n-  st->print(\"x12=\"); print_location(st, uc->context_x[12]);\n-  st->print(\"x13=\"); print_location(st, uc->context_x[13]);\n-  st->print(\"x14=\"); print_location(st, uc->context_x[14]);\n-  st->print(\"x15=\"); print_location(st, uc->context_x[15]);\n-  st->print(\"x16=\"); print_location(st, uc->context_x[16]);\n-  st->print(\"x17=\"); print_location(st, uc->context_x[17]);\n-  st->print(\"x18=\"); print_location(st, uc->context_x[18]);\n-  st->print(\"x19=\"); print_location(st, uc->context_x[19]);\n-  st->print(\"x20=\"); print_location(st, uc->context_x[20]);\n-  st->print(\"x21=\"); print_location(st, uc->context_x[21]);\n-  st->print(\"x22=\"); print_location(st, uc->context_x[22]);\n-  st->print(\"x23=\"); print_location(st, uc->context_x[23]);\n-  st->print(\"x24=\"); print_location(st, uc->context_x[24]);\n-  st->print(\"x25=\"); print_location(st, uc->context_x[25]);\n-  st->print(\"x26=\"); print_location(st, uc->context_x[26]);\n-  st->print(\"x27=\"); print_location(st, uc->context_x[27]);\n-  st->print(\"x28=\"); print_location(st, uc->context_x[28]);\n-\n-  st->cr();\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    switch (n) {\n+    case 29:\n+      st->print(\" fp=\"); print_location(st, uc->context_fp);\n+      break;\n+    case 30:\n+      st->print(\" lr=\"); print_location(st, uc->context_lr);\n+      break;\n+    case 31:\n+      st->print(\" sp=\"); print_location(st, uc->context_sp);\n+      break;\n+    default:\n+      st->print(\"x%-2d=\",n); print_location(st, uc->context_x[n]);\n+      break;\n+    }\n+    ++n;\n+  }\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":25,"deletions":43,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -861,2 +861,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = AMD64_ONLY(16) NOT_AMD64(8);\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -865,10 +869,5 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->context_##id);\n+  switch (n) {\n@@ -876,16 +875,16 @@\n-  st->print(\"RAX=\"); print_location(st, uc->context_rax);\n-  st->print(\"RBX=\"); print_location(st, uc->context_rbx);\n-  st->print(\"RCX=\"); print_location(st, uc->context_rcx);\n-  st->print(\"RDX=\"); print_location(st, uc->context_rdx);\n-  st->print(\"RSP=\"); print_location(st, uc->context_rsp);\n-  st->print(\"RBP=\"); print_location(st, uc->context_rbp);\n-  st->print(\"RSI=\"); print_location(st, uc->context_rsi);\n-  st->print(\"RDI=\"); print_location(st, uc->context_rdi);\n-  st->print(\"R8 =\"); print_location(st, uc->context_r8);\n-  st->print(\"R9 =\"); print_location(st, uc->context_r9);\n-  st->print(\"R10=\"); print_location(st, uc->context_r10);\n-  st->print(\"R11=\"); print_location(st, uc->context_r11);\n-  st->print(\"R12=\"); print_location(st, uc->context_r12);\n-  st->print(\"R13=\"); print_location(st, uc->context_r13);\n-  st->print(\"R14=\"); print_location(st, uc->context_r14);\n-  st->print(\"R15=\"); print_location(st, uc->context_r15);\n+    CASE_PRINT_REG( 0, \"RAX=\", rax); break;\n+    CASE_PRINT_REG( 1, \"RBX=\", rbx); break;\n+    CASE_PRINT_REG( 2, \"RCX=\", rcx); break;\n+    CASE_PRINT_REG( 3, \"RDX=\", rdx); break;\n+    CASE_PRINT_REG( 4, \"RSP=\", rsp); break;\n+    CASE_PRINT_REG( 5, \"RBP=\", rbp); break;\n+    CASE_PRINT_REG( 6, \"RSI=\", rsi); break;\n+    CASE_PRINT_REG( 7, \"RDI=\", rdi); break;\n+    CASE_PRINT_REG( 8, \"R8 =\", r8); break;\n+    CASE_PRINT_REG( 9, \"R9 =\", r9); break;\n+    CASE_PRINT_REG(10, \"R10=\", r10); break;\n+    CASE_PRINT_REG(11, \"R11=\", r11); break;\n+    CASE_PRINT_REG(12, \"R12=\", r12); break;\n+    CASE_PRINT_REG(13, \"R13=\", r13); break;\n+    CASE_PRINT_REG(14, \"R14=\", r14); break;\n+    CASE_PRINT_REG(15, \"R15=\", r15); break;\n@@ -893,8 +892,8 @@\n-  st->print(\"EAX=\"); print_location(st, uc->context_eax);\n-  st->print(\"EBX=\"); print_location(st, uc->context_ebx);\n-  st->print(\"ECX=\"); print_location(st, uc->context_ecx);\n-  st->print(\"EDX=\"); print_location(st, uc->context_edx);\n-  st->print(\"ESP=\"); print_location(st, uc->context_esp);\n-  st->print(\"EBP=\"); print_location(st, uc->context_ebp);\n-  st->print(\"ESI=\"); print_location(st, uc->context_esi);\n-  st->print(\"EDI=\"); print_location(st, uc->context_edi);\n+    CASE_PRINT_REG(0, \"EAX=\", eax); break;\n+    CASE_PRINT_REG(1, \"EBX=\", ebx); break;\n+    CASE_PRINT_REG(2, \"ECX=\", ecx); break;\n+    CASE_PRINT_REG(3, \"EDX=\", edx); break;\n+    CASE_PRINT_REG(4, \"ESP=\", esp); break;\n+    CASE_PRINT_REG(5, \"EBP=\", ebp); break;\n+    CASE_PRINT_REG(6, \"ESI=\", esi); break;\n+    CASE_PRINT_REG(7, \"EDI=\", edi); break;\n@@ -902,2 +901,4 @@\n-\n-  st->cr();\n+    }\n+# undef CASE_PRINT_REG\n+    ++n;\n+  }\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,2 +362,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 32 \/* r0-r31 *\/;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -366,13 +370,6 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n-  for (int r = 0; r < 31; r++) {\n-    st->print(\"R%-2d=\", r);\n-    print_location(st, uc->uc_mcontext.regs[r]);\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    st->print(\"R%-2d=\", n);\n+    print_location(st, uc->uc_mcontext.regs[n]);\n+    ++n;\n@@ -380,1 +377,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -490,2 +490,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = ARM_REGS_IN_CONTEXT;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -494,1 +498,0 @@\n-\n@@ -496,5 +499,7 @@\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-  for (int r = 0; r < ARM_REGS_IN_CONTEXT; r++) {\n-    st->print(\"  %-3s = \", as_Register(r)->name());\n-    print_location(st, reg_area[r]);\n+\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    st->print(\"  %-3s = \", as_Register(n)->name());\n+    print_location(st, reg_area[n]);\n+    ++n;\n@@ -502,1 +507,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -484,2 +484,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 32 \/* r0-r32 *\/ + 3 \/* pc, lr, ctr *\/;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -488,10 +492,19 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->nip);\n-  st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->link);\n-  st->print(\"ctr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->ctr);\n-  for (int i = 0; i < 32; i++) {\n-    st->print(\"r%-2d=\", i);\n-    print_location(st, uc->uc_mcontext.regs->gpr[i]);\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    switch (n) {\n+    case 0:\n+      st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->nip);\n+      break;\n+    case 1:\n+      st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->link);\n+      break;\n+    case 2:\n+      st->print(\"ctr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->ctr);\n+      break;\n+    default:\n+      st->print(\"r%-2d=\", n-3);\n+      print_location(st, (intptr_t)uc->uc_mcontext.regs->gpr[n-3]);\n+      break;\n+    }\n+    ++n;\n@@ -499,1 +512,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -374,2 +374,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 32;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -378,13 +382,6 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n-  for (int r = 0; r < 32; r++) {\n-    st->print(\"%-*.*s=\", 8, 8, reg_abi_names[r]);\n-    print_location(st, uc->uc_mcontext.__gregs[r]);\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    st->print(\"%-*.*s=\", 8, 8, reg_abi_names[n]);\n+    print_location(st, uc->uc_mcontext.__gregs[n]);\n+    ++n;\n@@ -392,1 +389,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -463,2 +463,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 16 \/* r0-r15 *\/ + 1 \/* pc *\/;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -467,8 +471,10 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.psw.addr);\n-  for (int i = 0; i < 16; i++) {\n-    st->print(\"r%-2d=\", i);\n-    print_location(st, uc->uc_mcontext.gregs[i]);\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+    if (n == 0) {\n+      st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.psw.addr);\n+    } else {\n+      st->print(\"r%-2d=\", n-1);\n+      print_location(st, uc->uc_mcontext.gregs[n-1]);\n+    }\n+    ++n;\n@@ -476,1 +482,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -578,2 +578,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = AMD64_ONLY(16) NOT_AMD64(8);\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -582,10 +586,5 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->uc_mcontext.gregs[REG_##id]);\n+    switch (n) {\n@@ -593,16 +592,16 @@\n-  st->print(\"RAX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RAX]);\n-  st->print(\"RBX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBX]);\n-  st->print(\"RCX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RCX]);\n-  st->print(\"RDX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDX]);\n-  st->print(\"RSP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSP]);\n-  st->print(\"RBP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBP]);\n-  st->print(\"RSI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSI]);\n-  st->print(\"RDI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDI]);\n-  st->print(\"R8 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R8]);\n-  st->print(\"R9 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R9]);\n-  st->print(\"R10=\"); print_location(st, uc->uc_mcontext.gregs[REG_R10]);\n-  st->print(\"R11=\"); print_location(st, uc->uc_mcontext.gregs[REG_R11]);\n-  st->print(\"R12=\"); print_location(st, uc->uc_mcontext.gregs[REG_R12]);\n-  st->print(\"R13=\"); print_location(st, uc->uc_mcontext.gregs[REG_R13]);\n-  st->print(\"R14=\"); print_location(st, uc->uc_mcontext.gregs[REG_R14]);\n-  st->print(\"R15=\"); print_location(st, uc->uc_mcontext.gregs[REG_R15]);\n+    CASE_PRINT_REG( 0, \"RAX=\", RAX); break;\n+    CASE_PRINT_REG( 1, \"RBX=\", RBX); break;\n+    CASE_PRINT_REG( 2, \"RCX=\", RCX); break;\n+    CASE_PRINT_REG( 3, \"RDX=\", RDX); break;\n+    CASE_PRINT_REG( 4, \"RSP=\", RSP); break;\n+    CASE_PRINT_REG( 5, \"RBP=\", RBP); break;\n+    CASE_PRINT_REG( 6, \"RSI=\", RSI); break;\n+    CASE_PRINT_REG( 7, \"RDI=\", RDI); break;\n+    CASE_PRINT_REG( 8, \"R8 =\", R8); break;\n+    CASE_PRINT_REG( 9, \"R9 =\", R9); break;\n+    CASE_PRINT_REG(10, \"R10=\", R10); break;\n+    CASE_PRINT_REG(11, \"R11=\", R11); break;\n+    CASE_PRINT_REG(12, \"R12=\", R12); break;\n+    CASE_PRINT_REG(13, \"R13=\", R13); break;\n+    CASE_PRINT_REG(14, \"R14=\", R14); break;\n+    CASE_PRINT_REG(15, \"R15=\", R15); break;\n@@ -610,8 +609,8 @@\n-  st->print(\"EAX=\"); print_location(st, uc->uc_mcontext.gregs[REG_EAX]);\n-  st->print(\"EBX=\"); print_location(st, uc->uc_mcontext.gregs[REG_EBX]);\n-  st->print(\"ECX=\"); print_location(st, uc->uc_mcontext.gregs[REG_ECX]);\n-  st->print(\"EDX=\"); print_location(st, uc->uc_mcontext.gregs[REG_EDX]);\n-  st->print(\"ESP=\"); print_location(st, uc->uc_mcontext.gregs[REG_ESP]);\n-  st->print(\"EBP=\"); print_location(st, uc->uc_mcontext.gregs[REG_EBP]);\n-  st->print(\"ESI=\"); print_location(st, uc->uc_mcontext.gregs[REG_ESI]);\n-  st->print(\"EDI=\"); print_location(st, uc->uc_mcontext.gregs[REG_EDI]);\n+    CASE_PRINT_REG(0, \"EAX=\", EAX); break;\n+    CASE_PRINT_REG(1, \"EBX=\", EBX); break;\n+    CASE_PRINT_REG(2, \"ECX=\", ECX); break;\n+    CASE_PRINT_REG(3, \"EDX=\", EDX); break;\n+    CASE_PRINT_REG(4, \"ESP=\", ESP); break;\n+    CASE_PRINT_REG(5, \"EBP=\", EBP); break;\n+    CASE_PRINT_REG(6, \"ESI=\", ESI); break;\n+    CASE_PRINT_REG(7, \"EDI=\", EDI); break;\n@@ -619,2 +618,4 @@\n-\n-  st->cr();\n+    }\n+# undef CASE_PRINT_REG\n+    ++n;\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-void os::print_register_info(outputStream *st, const void* ucVoid) {\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -227,2 +227,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n- if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = 29 \/* X0-X28 *\/;\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -231,41 +235,38 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-  \/\/ this is only for the \"general purpose\" registers\n-  st->print(\" X0=\"); print_location(st, uc->X0);\n-  st->print(\" X1=\"); print_location(st, uc->X1);\n-  st->print(\" X2=\"); print_location(st, uc->X2);\n-  st->print(\" X3=\"); print_location(st, uc->X3);\n-  st->cr();\n-  st->print(\" X4=\"); print_location(st, uc->X4);\n-  st->print(\" X5=\"); print_location(st, uc->X5);\n-  st->print(\" X6=\"); print_location(st, uc->X6);\n-  st->print(\" X7=\"); print_location(st, uc->X7);\n-  st->cr();\n-  st->print(\" X8=\"); print_location(st, uc->X8);\n-  st->print(\" X9=\"); print_location(st, uc->X9);\n-  st->print(\"X10=\"); print_location(st, uc->X10);\n-  st->print(\"X11=\"); print_location(st, uc->X11);\n-  st->cr();\n-  st->print(\"X12=\"); print_location(st, uc->X12);\n-  st->print(\"X13=\"); print_location(st, uc->X13);\n-  st->print(\"X14=\"); print_location(st, uc->X14);\n-  st->print(\"X15=\"); print_location(st, uc->X15);\n-  st->cr();\n-  st->print(\"X16=\"); print_location(st, uc->X16);\n-  st->print(\"X17=\"); print_location(st, uc->X17);\n-  st->print(\"X18=\"); print_location(st, uc->X18);\n-  st->print(\"X19=\"); print_location(st, uc->X19);\n-  st->cr();\n-  st->print(\"X20=\"); print_location(st, uc->X20);\n-  st->print(\"X21=\"); print_location(st, uc->X21);\n-  st->print(\"X22=\"); print_location(st, uc->X22);\n-  st->print(\"X23=\"); print_location(st, uc->X23);\n-  st->cr();\n-  st->print(\"X24=\"); print_location(st, uc->X24);\n-  st->print(\"X25=\"); print_location(st, uc->X25);\n-  st->print(\"X26=\"); print_location(st, uc->X26);\n-  st->print(\"X27=\"); print_location(st, uc->X27);\n-  st->print(\"X28=\"); print_location(st, uc->X28);\n-\n-  st->cr();\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->id);\n+    switch (n) {\n+      CASE_PRINT_REG( 0, \" X0=\", X0); break;\n+      CASE_PRINT_REG( 1, \" X1=\", X1); break;\n+      CASE_PRINT_REG( 2, \" X2=\", X2); break;\n+      CASE_PRINT_REG( 3, \" X3=\", X3); break;\n+      CASE_PRINT_REG( 4, \" X4=\", X4); break;\n+      CASE_PRINT_REG( 5, \" X5=\", X5); break;\n+      CASE_PRINT_REG( 6, \" X6=\", X6); break;\n+      CASE_PRINT_REG( 7, \" X7=\", X7); break;\n+      CASE_PRINT_REG( 8, \" X8=\", X8); break;\n+      CASE_PRINT_REG( 9, \" X9=\", X9); break;\n+      CASE_PRINT_REG(10, \"X10=\", X10); break;\n+      CASE_PRINT_REG(11, \"X11=\", X11); break;\n+      CASE_PRINT_REG(12, \"X12=\", X12); break;\n+      CASE_PRINT_REG(13, \"X13=\", X13); break;\n+      CASE_PRINT_REG(14, \"X14=\", X14); break;\n+      CASE_PRINT_REG(15, \"X15=\", X15); break;\n+      CASE_PRINT_REG(16, \"X16=\", X16); break;\n+      CASE_PRINT_REG(17, \"X17=\", X17); break;\n+      CASE_PRINT_REG(18, \"X18=\", X18); break;\n+      CASE_PRINT_REG(19, \"X19=\", X19); break;\n+      CASE_PRINT_REG(20, \"X20=\", X20); break;\n+      CASE_PRINT_REG(21, \"X21=\", X21); break;\n+      CASE_PRINT_REG(22, \"X22=\", X22); break;\n+      CASE_PRINT_REG(23, \"X23=\", X23); break;\n+      CASE_PRINT_REG(24, \"X24=\", X24); break;\n+      CASE_PRINT_REG(25, \"X25=\", X25); break;\n+      CASE_PRINT_REG(26, \"X26=\", X26); break;\n+      CASE_PRINT_REG(27, \"X27=\", X27); break;\n+      CASE_PRINT_REG(28, \"X28=\", X28); break;\n+    }\n+# undef CASE_PRINT_REG\n+    ++n;\n+  }\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -470,2 +470,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n+void os::print_register_info(outputStream *st, const void *context, int& continuation) {\n+  const int register_count = AMD64_ONLY(16) NOT_AMD64(8);\n+  int n = continuation;\n+  if (context == nullptr || n < 0 || n >= register_count) {\n+    return;\n+  }\n@@ -474,6 +478,5 @@\n-\n-  st->print_cr(\"Register to memory mapping:\");\n-  st->cr();\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n+  while (n < register_count) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = n + 1;\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->id);\n+    switch (n) {\n@@ -481,17 +484,16 @@\n-  st->print(\"RIP=\"); print_location(st, uc->Rip);\n-  st->print(\"RAX=\"); print_location(st, uc->Rax);\n-  st->print(\"RBX=\"); print_location(st, uc->Rbx);\n-  st->print(\"RCX=\"); print_location(st, uc->Rcx);\n-  st->print(\"RDX=\"); print_location(st, uc->Rdx);\n-  st->print(\"RSP=\"); print_location(st, uc->Rsp);\n-  st->print(\"RBP=\"); print_location(st, uc->Rbp);\n-  st->print(\"RSI=\"); print_location(st, uc->Rsi);\n-  st->print(\"RDI=\"); print_location(st, uc->Rdi);\n-  st->print(\"R8 =\"); print_location(st, uc->R8);\n-  st->print(\"R9 =\"); print_location(st, uc->R9);\n-  st->print(\"R10=\"); print_location(st, uc->R10);\n-  st->print(\"R11=\"); print_location(st, uc->R11);\n-  st->print(\"R12=\"); print_location(st, uc->R12);\n-  st->print(\"R13=\"); print_location(st, uc->R13);\n-  st->print(\"R14=\"); print_location(st, uc->R14);\n-  st->print(\"R15=\"); print_location(st, uc->R15);\n+    CASE_PRINT_REG( 0, \"RAX=\", Rax); break;\n+    CASE_PRINT_REG( 1, \"RBX=\", Rbx); break;\n+    CASE_PRINT_REG( 2, \"RCX=\", Rcx); break;\n+    CASE_PRINT_REG( 3, \"RDX=\", Rdx); break;\n+    CASE_PRINT_REG( 4, \"RSP=\", Rsp); break;\n+    CASE_PRINT_REG( 5, \"RBP=\", Rbp); break;\n+    CASE_PRINT_REG( 6, \"RSI=\", Rsi); break;\n+    CASE_PRINT_REG( 7, \"RDI=\", Rdi); break;\n+    CASE_PRINT_REG( 8, \"R8 =\", R8); break;\n+    CASE_PRINT_REG( 9, \"R9 =\", R9); break;\n+    CASE_PRINT_REG(10, \"R10=\", R10); break;\n+    CASE_PRINT_REG(11, \"R11=\", R11); break;\n+    CASE_PRINT_REG(12, \"R12=\", R12); break;\n+    CASE_PRINT_REG(13, \"R13=\", R13); break;\n+    CASE_PRINT_REG(14, \"R14=\", R14); break;\n+    CASE_PRINT_REG(15, \"R15=\", R15); break;\n@@ -499,12 +501,13 @@\n-  st->print(\"EIP=\"); print_location(st, uc->Eip);\n-  st->print(\"EAX=\"); print_location(st, uc->Eax);\n-  st->print(\"EBX=\"); print_location(st, uc->Ebx);\n-  st->print(\"ECX=\"); print_location(st, uc->Ecx);\n-  st->print(\"EDX=\"); print_location(st, uc->Edx);\n-  st->print(\"ESP=\"); print_location(st, uc->Esp);\n-  st->print(\"EBP=\"); print_location(st, uc->Ebp);\n-  st->print(\"ESI=\"); print_location(st, uc->Esi);\n-  st->print(\"EDI=\"); print_location(st, uc->Edi);\n-#endif\n-\n-  st->cr();\n+    CASE_PRINT_REG(0, \"EAX=\", Eax); break;\n+    CASE_PRINT_REG(1, \"EBX=\", Ebx); break;\n+    CASE_PRINT_REG(2, \"ECX=\", Ecx); break;\n+    CASE_PRINT_REG(3, \"EDX=\", Edx); break;\n+    CASE_PRINT_REG(4, \"ESP=\", Esp); break;\n+    CASE_PRINT_REG(5, \"EBP=\", Ebp); break;\n+    CASE_PRINT_REG(6, \"ESI=\", Esi); break;\n+    CASE_PRINT_REG(7, \"EDI=\", Edi); break;\n+#endif \/\/ AMD64\n+    }\n+# undef CASE_PRINT_REG\n+    ++n;\n+  }\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":40,"deletions":37,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1012,0 +1012,5 @@\n+void os::print_register_info(outputStream* st, const void* context) {\n+  int continuation = 0;\n+  print_register_info(st, context, continuation);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -768,0 +768,1 @@\n+  static void print_register_info(outputStream* st, const void* context, int& continuation);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/stackOverflow.hpp\"\n@@ -64,1 +65,1 @@\n-#include \"utilities\/vmError.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -66,0 +67,2 @@\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmError.hpp\"\n@@ -85,0 +88,1 @@\n+volatile bool     VMError::_step_did_succeed = false;\n@@ -97,0 +101,1 @@\n+const size_t      VMError::_reattempt_required_stack_headroom = 64 * K;\n@@ -171,0 +176,63 @@\n+static bool stack_has_headroom(size_t headroom) {\n+  const size_t stack_size = os::current_stack_size();\n+  const size_t guard_size = StackOverflow::stack_guard_zone_size();\n+  const size_t unguarded_stack_size = stack_size - guard_size;\n+\n+  if (unguarded_stack_size < headroom) {\n+    return false;\n+  }\n+\n+  const address stack_base          = os::current_stack_base();\n+  const address unguarded_stack_end = stack_base - unguarded_stack_size;\n+  const address stack_pointer       = os::current_stack_pointer();\n+\n+  return stack_pointer >= unguarded_stack_end + headroom;\n+}\n+\n+#ifdef ASSERT\n+void VMError::reattempt_test_hit_stack_limit(outputStream* st) {\n+  if (stack_has_headroom(_reattempt_required_stack_headroom)) {\n+    \/\/ Use all but (_reattempt_required_stack_headroom - K) unguarded stack space.\n+    const size_t stack_size     = os::current_stack_size();\n+    const size_t guard_size     = StackOverflow::stack_guard_zone_size();\n+    const address stack_base    = os::current_stack_base();\n+    const address stack_pointer = os::current_stack_pointer();\n+\n+    const size_t unguarded_stack_size = stack_size - guard_size;\n+    const address unguarded_stack_end = stack_base - unguarded_stack_size;\n+    const size_t available_headroom   = stack_pointer - unguarded_stack_end;\n+    const size_t allocation_size      = available_headroom - _reattempt_required_stack_headroom + K;\n+\n+    st->print_cr(\"Current Stack Pointer: \" PTR_FORMAT \" alloca \" SIZE_FORMAT\n+                 \" of \" SIZE_FORMAT \" bytes available unguarded stack space\",\n+                 p2i(stack_pointer), allocation_size, available_headroom);\n+\n+    \/\/ Allocate byte blob on the stack. Make pointer volatile to avoid having\n+    \/\/ the compiler removing later reads.\n+    volatile char* stack_buffer = static_cast<char*>(alloca(allocation_size));\n+    \/\/ Initialize the last byte.\n+    stack_buffer[allocation_size - 1] = '\\0';\n+    \/\/ Recursive call should hit the stack limit.\n+    reattempt_test_hit_stack_limit(st);\n+    \/\/ Perform a volatile read of the last byte to avoid having the complier\n+    \/\/ remove the allocation.\n+    static_cast<void>(stack_buffer[allocation_size - 1] == '\\0');\n+  }\n+  controlled_crash(14);\n+}\n+#endif \/\/ ASSERT\n+\n+bool VMError::can_reattempt_step(const char* &stop_reason) {\n+  if (!stack_has_headroom(_reattempt_required_stack_headroom)) {\n+    stop_reason = \"Stack headroom limit reached\";\n+    return false;\n+  }\n+\n+  if (_step_did_timeout) {\n+    stop_reason = \"Step time limit reached\";\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -427,0 +495,20 @@\n+static void print_stack_location(outputStream* st, void* context, int& continuation) {\n+  const int number_of_stack_slots = 8;\n+\n+  int i = continuation;\n+  \/\/ Update continuation with next index before fetching frame\n+  continuation = i + 1;\n+  const frame fr = os::fetch_frame_from_context(context);\n+  while (i < number_of_stack_slots) {\n+    \/\/ Update continuation with next index before printing location\n+    continuation = i + 1;\n+    \/\/ decode stack contents if possible\n+    const intptr_t *slot = fr.sp() + i;\n+    if (is_aligned(slot, sizeof(intptr_t)) && os::is_readable_pointer(slot)) {\n+      st->print(\"stack at sp + %d slots: \", i);\n+      os::print_location(st, *(slot));\n+    }\n+    ++i;\n+  }\n+}\n+\n@@ -531,1 +619,3 @@\n-\n+  \/\/ Used by reattempt step logic\n+  static int continuation = 0;\n+  const char* stop_reattempt_reason = nullptr;\n@@ -534,0 +624,1 @@\n+    _step_did_succeed = false;                             \\\n@@ -538,1 +629,1 @@\n-# define STEP_IF(s,cond)                                   \\\n+# define STEP_IF(s, cond)                                  \\\n@@ -540,0 +631,1 @@\n+    _step_did_succeed = true;                              \\\n@@ -542,0 +634,1 @@\n+    _step_did_succeed = false;                             \\\n@@ -551,0 +644,16 @@\n+# define REATTEMPT_STEP_IF(s, cond)                        \\\n+    }                                                      \\\n+    _step_did_succeed = true;                              \\\n+  }                                                        \\\n+  if (_current_step < __LINE__ && !_step_did_succeed) {    \\\n+    _current_step = __LINE__;                              \\\n+    _current_step_info = s;                                \\\n+    const bool cond_value = (cond);                        \\\n+    if (cond_value && !can_reattempt_step(                 \\\n+                          stop_reattempt_reason)) {        \\\n+      st->print_cr(\"[stop reattempt (%s) reason: %s]\",     \\\n+                   _current_step_info,                     \\\n+                   stop_reattempt_reason);                 \\\n+    } else if (cond_value) {\n+      \/\/ [Continue Step logic]\n+\n@@ -553,0 +662,1 @@\n+    _step_did_succeed = true;                              \\\n@@ -559,2 +669,0 @@\n-  static bool print_native_stack_succeeded = false;\n-\n@@ -576,0 +684,1 @@\n+#define TEST_REATTEMPT_SECONDARY_CRASH 15\n@@ -590,0 +699,33 @@\n+  \/\/ See corresponding test in test\/runtime\/ErrorHandling\/ReattemptErrorTest.java\n+  STEP_IF(\"test reattempt secondary crash\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n+      TestCrashInErrorHandler);\n+    controlled_crash(14);\n+\n+  REATTEMPT_STEP_IF(\"test reattempt secondary crash, attempt 2\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"test reattempt secondary crash. attempt 2\");\n+\n+  REATTEMPT_STEP_IF(\"test reattempt secondary crash, attempt 3\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"test reattempt secondary crash. attempt 3\");\n+\n+  STEP_IF(\"test reattempt timeout\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"test reattempt timeout\");\n+    os::infinite_sleep();\n+\n+  REATTEMPT_STEP_IF(\"test reattempt timeout, attempt 2\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"test reattempt timeout, attempt 2\");\n+\n+  STEP_IF(\"test reattempt stack headroom\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"test reattempt stack headroom\");\n+    reattempt_test_hit_stack_limit(st);\n+\n+  REATTEMPT_STEP_IF(\"test reattempt stack headroom, attempt 2\",\n+      _verbose && TestCrashInErrorHandler == TEST_REATTEMPT_SECONDARY_CRASH)\n+    st->print_cr(\"test reattempt stack headroom, attempt 2\");\n+\n@@ -825,1 +967,0 @@\n-    print_native_stack_succeeded = true;\n@@ -827,1 +968,1 @@\n-  STEP_IF(\"retry printing native stack (no source info)\", _verbose && !print_native_stack_succeeded)\n+  REATTEMPT_STEP_IF(\"retry printing native stack (no source info)\", _verbose)\n@@ -867,1 +1008,1 @@\n-    \/\/ decode register contents if possible\n+    continuation = 0;\n@@ -869,1 +1010,3 @@\n-    os::print_register_info(st, _context);\n+    st->print_cr(\"Register to memory mapping:\");\n+    st->cr();\n+    os::print_register_info(st, _context, continuation);\n@@ -872,0 +1015,5 @@\n+  REATTEMPT_STEP_IF(\"printing register info, attempt 2\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    ResourceMark rm(_thread);\n+    os::print_register_info(st, _context, continuation);\n+    st->cr();\n@@ -873,1 +1021,5 @@\n-  STEP(\"printing top of stack, instructions near pc\")\n+  REATTEMPT_STEP_IF(\"printing register info, attempt 3\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    ResourceMark rm(_thread);\n+    os::print_register_info(st, _context, continuation);\n+    st->cr();\n@@ -875,1 +1027,1 @@\n-  STEP_IF(\"printing top of stack, instructions near pc\", _verbose && _context)\n+  STEP_IF(\"printing top of stack, instructions near pc\", _verbose && _context != nullptr)\n@@ -882,13 +1034,5 @@\n-    \/\/ decode stack contents if possible\n-    frame fr = os::fetch_frame_from_context(_context);\n-    const int slots = 8;\n-    const intptr_t *start = fr.sp();\n-    const intptr_t *end = start + slots;\n-    if (is_aligned(start, sizeof(intptr_t)) && os::is_readable_range(start, end)) {\n-      st->print_cr(\"Stack slot to memory mapping:\");\n-      for (int i = 0; i < slots; ++i) {\n-        st->print(\"stack at sp + %d slots: \", i);\n-        ResourceMark rm(_thread);\n-        os::print_location(st, *(start + i));\n-      }\n-    }\n+    continuation = 0;\n+    ResourceMark rm(_thread);\n+    st->print_cr(\"Stack slot to memory mapping:\");\n+    st->cr();\n+    print_stack_location(st, _context, continuation);\n@@ -897,1 +1041,11 @@\n-  STEP(\"printing code blobs if possible\")\n+  REATTEMPT_STEP_IF(\"inspecting top of stack, attempt 2\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    ResourceMark rm(_thread);\n+    print_stack_location(st, _context, continuation);\n+    st->cr();\n+\n+  REATTEMPT_STEP_IF(\"inspecting top of stack, attempt 3\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    ResourceMark rm(_thread);\n+    print_stack_location(st, _context, continuation);\n+    st->cr();\n@@ -959,2 +1113,0 @@\n-  STEP(\"printing process\")\n-\n@@ -969,1 +1121,1 @@\n-  STEP_IF(\"printing all threads\", _verbose && _thread)\n+  STEP_IF(\"printing all threads\", _verbose && _thread != nullptr)\n@@ -1118,0 +1270,1 @@\n+# undef REATTEMPT_STEP_IF\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":181,"deletions":28,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+  \/\/ used for reattempt step logic\n+  static const size_t _reattempt_required_stack_headroom;\n+\n@@ -91,0 +94,2 @@\n+  \/\/ Whether or not the last error reporting step did succeed.\n+  static volatile bool _step_did_succeed;\n@@ -120,0 +125,3 @@\n+  DEBUG_ONLY(static void reattempt_test_hit_stack_limit(outputStream* st));\n+  static bool can_reattempt_step(const char* &stop_reason);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -380,0 +380,1 @@\n+ -runtime\/ErrorHandling\/ReattemptErrorTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Check secondary error handling\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family != \"windows\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver ReattemptErrorTest\n+ *\/\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ReattemptErrorTest {\n+\n+    \/\/ 16 seconds for hs_err generation timeout = 4 seconds per step timeout\n+    public static final int ERROR_LOG_TIMEOUT = 16;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ How this works:\n+        \/\/ The test will fault with SIGFPE (ErrorHandlerTest=15) and then, during error handling,\n+        \/\/ three pieces of reattempt logic are tested:\n+        \/\/ * First a step will fault with SIGSEGV. And then reattempts the step twice. With the first\n+        \/\/   reattempt succeeding. And the second reattempt being skipped.\n+        \/\/ * Second a step will timeout, followed by a reattempt, the reattempt will be skipped.\n+        \/\/ * Third a step will use almost all stack space and then fault with SIGSEGV. After this the\n+        \/\/   proceeding reattempt steps will be skipped because of low stack headroom.\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xmx100M\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-XX:ErrorHandlerTest=15\",\n+            \"-XX:TestCrashInErrorHandler=15\",\n+            \"-XX:ErrorLogTimeout=\" + ERROR_LOG_TIMEOUT,\n+            \"-version\");\n+\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+\n+        \/\/ we should have crashed with a SIGFPE\n+        output_detail.shouldMatch(\"# A fatal error has been detected by the Java Runtime Environment:.*\");\n+        output_detail.shouldMatch(\"#.+SIGFPE.*\");\n+\n+        \/\/ extract hs-err file\n+        File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n+\n+        ArrayList<Pattern> positivePatternlist = new ArrayList<>();\n+        ArrayList<Pattern> negativePatternlist = new ArrayList<>();\n+\n+        \/\/ * First case\n+        \/\/   * First step crashes\n+        positivePatternlist.add(Pattern.compile(\"Will crash now \\\\(TestCrashInErrorHandler=15\\\\)...\"));\n+        positivePatternlist.add(Pattern.compile(\"\\\\[error occurred during error reporting \\\\(test reattempt secondary crash\\\\).*\\\\]\"));\n+        \/\/   * Second attempt succeeds\n+        positivePatternlist.add(Pattern.compile(\"test reattempt secondary crash. attempt 2\"));\n+        \/\/   * Third attempt is skipped\n+        negativePatternlist.add(Pattern.compile(\"test reattempt secondary crash. attempt 3\"));\n+\n+        \/\/ * Second case\n+        \/\/   * First step timeouts\n+        positivePatternlist.add(Pattern.compile(\"test reattempt timeout\"));\n+        positivePatternlist.add(Pattern.compile(\".*timeout occurred during error reporting in step \\\"test reattempt timeout\\\".*\"));\n+        \/\/   * Second attempt is skipped because of previous timeout\n+        negativePatternlist.add(Pattern.compile(\"test reattempt secondary crash, attempt 2\"));\n+        positivePatternlist.add(Pattern.compile(\".*stop reattempt \\\\(test reattempt timeout, attempt 2\\\\) reason: Step time limit reached.*\"));\n+\n+        \/\/ * Third case\n+        \/\/   * First step crashes after using almost all stack space\n+        positivePatternlist.add(Pattern.compile(\"test reattempt stack headroom\"));\n+        positivePatternlist.add(Pattern.compile(\"\\\\[error occurred during error reporting \\\\(test reattempt stack headroom\\\\).*\\\\]\"));\n+        \/\/   * Second step is skip because of limited stack headroom\n+        negativePatternlist.add(Pattern.compile(\"test reattempt stack headroom, attempt 2\"));\n+        positivePatternlist.add(Pattern.compile(\".*stop reattempt \\\\(test reattempt stack headroom, attempt 2\\\\) reason: Stack headroom limit reached.*\"));\n+\n+        Pattern[] positivePatterns = positivePatternlist.toArray(new Pattern[] {});\n+        Pattern[] negativePatterns = negativePatternlist.toArray(new Pattern[] {});\n+\n+        HsErrFileUtils.checkHsErrFileContent(hs_err_file, positivePatterns, negativePatterns, true, true);\n+\n+        System.out.println(\"OK.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ReattemptErrorTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}