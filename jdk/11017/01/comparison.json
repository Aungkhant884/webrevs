{"files":[{"patch":"@@ -476,1 +476,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -479,2 +479,0 @@\n-  ucontext_t *uc = (ucontext_t*)context;\n-\n@@ -483,0 +481,1 @@\n+}\n@@ -484,6 +483,3 @@\n-  st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.iar);\n-  st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.lr);\n-  st->print(\"sp =\"); print_location(st, (intptr_t)os::Aix::ucontext_get_sp(uc));\n-  for (int i = 0; i < 32; i++) {\n-    st->print(\"r%-2d=\", i);\n-    print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.gpr[i]);\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n@@ -492,1 +488,20 @@\n-  st->cr();\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  switch (n) {\n+  case 0:\n+    st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.iar);\n+    break;\n+  case 1:\n+    st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.lr);\n+    break;\n+  case 2:\n+    st->print(\"sp =\"); print_location(st, (intptr_t)os::Aix::ucontext_get_sp(uc));\n+    break;\n+  default:\n+    st->print(\"r%-2d=\", n-3);\n+    print_location(st, (intptr_t)uc->uc_mcontext.jmp_context.gpr[n-3]);\n+    break;\n+  }\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return 32 \/* r0-r32 *\/ + 3 \/* pc, lr, sp *\/;\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -487,2 +487,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -491,0 +489,1 @@\n+}\n@@ -492,35 +491,4 @@\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n-\n-  st->print(\" x0=\"); print_location(st, uc->context_x[ 0]);\n-  st->print(\" x1=\"); print_location(st, uc->context_x[ 1]);\n-  st->print(\" x2=\"); print_location(st, uc->context_x[ 2]);\n-  st->print(\" x3=\"); print_location(st, uc->context_x[ 3]);\n-  st->print(\" x4=\"); print_location(st, uc->context_x[ 4]);\n-  st->print(\" x5=\"); print_location(st, uc->context_x[ 5]);\n-  st->print(\" x6=\"); print_location(st, uc->context_x[ 6]);\n-  st->print(\" x7=\"); print_location(st, uc->context_x[ 7]);\n-  st->print(\" x8=\"); print_location(st, uc->context_x[ 8]);\n-  st->print(\" x9=\"); print_location(st, uc->context_x[ 9]);\n-  st->print(\"x10=\"); print_location(st, uc->context_x[10]);\n-  st->print(\"x11=\"); print_location(st, uc->context_x[11]);\n-  st->print(\"x12=\"); print_location(st, uc->context_x[12]);\n-  st->print(\"x13=\"); print_location(st, uc->context_x[13]);\n-  st->print(\"x14=\"); print_location(st, uc->context_x[14]);\n-  st->print(\"x15=\"); print_location(st, uc->context_x[15]);\n-  st->print(\"x16=\"); print_location(st, uc->context_x[16]);\n-  st->print(\"x17=\"); print_location(st, uc->context_x[17]);\n-  st->print(\"x18=\"); print_location(st, uc->context_x[18]);\n-  st->print(\"x19=\"); print_location(st, uc->context_x[19]);\n-  st->print(\"x20=\"); print_location(st, uc->context_x[20]);\n-  st->print(\"x21=\"); print_location(st, uc->context_x[21]);\n-  st->print(\"x22=\"); print_location(st, uc->context_x[22]);\n-  st->print(\"x23=\"); print_location(st, uc->context_x[23]);\n-  st->print(\"x24=\"); print_location(st, uc->context_x[24]);\n-  st->print(\"x25=\"); print_location(st, uc->context_x[25]);\n-  st->print(\"x26=\"); print_location(st, uc->context_x[26]);\n-  st->print(\"x27=\"); print_location(st, uc->context_x[27]);\n-  st->print(\"x28=\"); print_location(st, uc->context_x[28]);\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n@@ -528,1 +496,19 @@\n-  st->cr();\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  switch (n) {\n+  case 29:\n+    st->print(\" fp=\"); print_location(st, uc->context_fp);\n+    break;\n+  case 30:\n+    st->print(\" lr=\"); print_location(st, uc->context_lr);\n+    break;\n+  case 31:\n+    st->print(\" sp=\"); print_location(st, uc->context_sp);\n+    break;\n+  default:\n+    st->print(\"x%-2d=\",n); print_location(st, uc->context_x[n]);\n+    break;\n+  }\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return 29 \/* x0-x28 *\/ + 3 \/* fp, lr, sp *\/;\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":25,"deletions":39,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -871,2 +871,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -875,0 +873,1 @@\n+}\n@@ -876,5 +875,4 @@\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n-\n-  \/\/ this is only for the \"general purpose\" registers\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n@@ -882,0 +880,3 @@\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->context_##id);\n+  switch (n) {\n@@ -883,16 +884,16 @@\n-  st->print(\"RAX=\"); print_location(st, uc->context_rax);\n-  st->print(\"RBX=\"); print_location(st, uc->context_rbx);\n-  st->print(\"RCX=\"); print_location(st, uc->context_rcx);\n-  st->print(\"RDX=\"); print_location(st, uc->context_rdx);\n-  st->print(\"RSP=\"); print_location(st, uc->context_rsp);\n-  st->print(\"RBP=\"); print_location(st, uc->context_rbp);\n-  st->print(\"RSI=\"); print_location(st, uc->context_rsi);\n-  st->print(\"RDI=\"); print_location(st, uc->context_rdi);\n-  st->print(\"R8 =\"); print_location(st, uc->context_r8);\n-  st->print(\"R9 =\"); print_location(st, uc->context_r9);\n-  st->print(\"R10=\"); print_location(st, uc->context_r10);\n-  st->print(\"R11=\"); print_location(st, uc->context_r11);\n-  st->print(\"R12=\"); print_location(st, uc->context_r12);\n-  st->print(\"R13=\"); print_location(st, uc->context_r13);\n-  st->print(\"R14=\"); print_location(st, uc->context_r14);\n-  st->print(\"R15=\"); print_location(st, uc->context_r15);\n+  CASE_PRINT_REG( 0, \"RAX=\", rax); break;\n+  CASE_PRINT_REG( 1, \"RBX=\", rbx); break;\n+  CASE_PRINT_REG( 2, \"RCX=\", rcx); break;\n+  CASE_PRINT_REG( 3, \"RDX=\", rdx); break;\n+  CASE_PRINT_REG( 4, \"RSP=\", rsp); break;\n+  CASE_PRINT_REG( 5, \"RBP=\", rbp); break;\n+  CASE_PRINT_REG( 6, \"RSI=\", rsi); break;\n+  CASE_PRINT_REG( 7, \"RDI=\", rdi); break;\n+  CASE_PRINT_REG( 8, \"R8 =\", r8); break;\n+  CASE_PRINT_REG( 9, \"R9 =\", r9); break;\n+  CASE_PRINT_REG(10, \"R10=\", r10); break;\n+  CASE_PRINT_REG(11, \"R11=\", r11); break;\n+  CASE_PRINT_REG(12, \"R12=\", r12); break;\n+  CASE_PRINT_REG(13, \"R13=\", r13); break;\n+  CASE_PRINT_REG(14, \"R14=\", r14); break;\n+  CASE_PRINT_REG(15, \"R15=\", r15); break;\n@@ -900,8 +901,8 @@\n-  st->print(\"EAX=\"); print_location(st, uc->context_eax);\n-  st->print(\"EBX=\"); print_location(st, uc->context_ebx);\n-  st->print(\"ECX=\"); print_location(st, uc->context_ecx);\n-  st->print(\"EDX=\"); print_location(st, uc->context_edx);\n-  st->print(\"ESP=\"); print_location(st, uc->context_esp);\n-  st->print(\"EBP=\"); print_location(st, uc->context_ebp);\n-  st->print(\"ESI=\"); print_location(st, uc->context_esi);\n-  st->print(\"EDI=\"); print_location(st, uc->context_edi);\n+  CASE_PRINT_REG(0, \"EAX=\", eax); break;\n+  CASE_PRINT_REG(1, \"EBX=\", ebx); break;\n+  CASE_PRINT_REG(2, \"ECX=\", ecx); break;\n+  CASE_PRINT_REG(3, \"EDX=\", edx); break;\n+  CASE_PRINT_REG(4, \"ESP=\", esp); break;\n+  CASE_PRINT_REG(5, \"EBP=\", ebp); break;\n+  CASE_PRINT_REG(6, \"ESI=\", esi); break;\n+  CASE_PRINT_REG(7, \"EDI=\", edi); break;\n@@ -909,0 +910,3 @@\n+  }\n+# undef CASE_PRINT_REG\n+}\n@@ -910,1 +914,2 @@\n-  st->cr();\n+int os::print_nth_register_info_max_index() {\n+  return AMD64_ONLY(16) NOT_AMD64(8);\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":38,"deletions":33,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -256,1 +256,6 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n+  st->print_cr(\"No register info.\");\n+  st->cr();\n+}\n+\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n@@ -260,0 +265,4 @@\n+int os::print_nth_register_info_max_index() {\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -365,2 +365,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -369,0 +367,6 @@\n+}\n+\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n@@ -370,3 +374,1 @@\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n+  const ucontext_t *uc = (const ucontext_t*)context;\n@@ -374,1 +376,3 @@\n-  \/\/ this is only for the \"general purpose\" registers\n+  st->print(\"R%-2d=\", n);\n+  print_location(st, uc->uc_mcontext.regs[n]);\n+}\n@@ -376,5 +380,2 @@\n-  for (int r = 0; r < 31; r++) {\n-    st->print(\"R%-2d=\", r);\n-    print_location(st, uc->uc_mcontext.regs[r]);\n-  }\n-  st->cr();\n+int os::print_nth_register_info_max_index() {\n+  return 32 \/* r0-r31 *\/;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -493,3 +493,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n-  intx* reg_area = (intx*)&uc->uc_mcontext.arm_r0;\n@@ -498,3 +495,5 @@\n-  for (int r = 0; r < ARM_REGS_IN_CONTEXT; r++) {\n-    st->print(\"  %-3s = \", as_Register(r)->name());\n-    print_location(st, reg_area[r]);\n+}\n+\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n@@ -502,1 +501,10 @@\n-  st->cr();\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  intx* reg_area = (intx*)&uc->uc_mcontext.arm_r0;\n+\n+  st->print(\"  %-3s = \", as_Register(n)->name());\n+  print_location(st, reg_area[n]);\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return ARM_REGS_IN_CONTEXT;\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -487,2 +487,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -491,0 +489,1 @@\n+}\n@@ -492,6 +491,3 @@\n-  st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->nip);\n-  st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->link);\n-  st->print(\"ctr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->ctr);\n-  for (int i = 0; i < 32; i++) {\n-    st->print(\"r%-2d=\", i);\n-    print_location(st, uc->uc_mcontext.regs->gpr[i]);\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n@@ -499,1 +495,21 @@\n-  st->cr();\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  switch (n) {\n+  case 0:\n+    st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->nip);\n+    break;\n+  case 1:\n+    st->print(\"lr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->link);\n+    break;\n+  case 2:\n+    st->print(\"ctr =\"); print_location(st, (intptr_t)uc->uc_mcontext.regs->ctr);\n+    break;\n+  default:\n+    st->print(\"r%-2d=\", n-3);\n+    print_location(st, (intptr_t)uc->uc_mcontext.regs->gpr[n-3]);\n+    break;\n+  }\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return 32 \/* r0-r32 *\/ + 3 \/* pc, lr, ctr *\/;\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -374,2 +374,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -378,0 +376,6 @@\n+}\n+\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n@@ -379,3 +383,1 @@\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n+  const ucontext_t *uc = (const ucontext_t*)context;\n@@ -383,1 +385,3 @@\n-  \/\/ this is only for the \"general purpose\" registers\n+  st->print(\"%-*.*s=\", 8, 8, reg_abi_names[n]);\n+  print_location(st, uc->uc_mcontext.__gregs[n]);\n+}\n@@ -385,5 +389,2 @@\n-  for (int r = 0; r < 32; r++) {\n-    st->print(\"%-*.*s=\", 8, 8, reg_abi_names[r]);\n-    print_location(st, uc->uc_mcontext.__gregs[r]);\n-  }\n-  st->cr();\n+int os::print_nth_register_info_max_index() {\n+  return 32;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -459,2 +459,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -463,0 +461,1 @@\n+}\n@@ -464,4 +463,3 @@\n-  st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.psw.addr);\n-  for (int i = 0; i < 16; i++) {\n-    st->print(\"r%-2d=\", i);\n-    print_location(st, uc->uc_mcontext.gregs[i]);\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n@@ -469,1 +467,13 @@\n-  st->cr();\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+\n+  if (n == 0) {\n+    st->print(\"pc =\"); print_location(st, (intptr_t)uc->uc_mcontext.psw.addr);\n+  } else {\n+    st->print(\"r%-2d=\", n-1);\n+    print_location(st, uc->uc_mcontext.gregs[n-1]);\n+  }\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return 16 \/* r0-r15 *\/ + 1 \/* pc *\/;\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -599,2 +599,0 @@\n-  const ucontext_t *uc = (const ucontext_t*)context;\n-\n@@ -603,0 +601,1 @@\n+}\n@@ -604,3 +603,4 @@\n-  \/\/ this is horrendously verbose but the layout of the registers in the\n-  \/\/ context does not match how we defined our abstract Register set, so\n-  \/\/ we can't just iterate through the gregs area\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n@@ -608,1 +608,1 @@\n-  \/\/ this is only for the \"general purpose\" registers\n+  const ucontext_t *uc = (const ucontext_t*)context;\n@@ -610,0 +610,2 @@\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->uc_mcontext.gregs[REG_##id]);\n+  switch (n) {\n@@ -611,16 +613,16 @@\n-  st->print(\"RAX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RAX]);\n-  st->print(\"RBX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBX]);\n-  st->print(\"RCX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RCX]);\n-  st->print(\"RDX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDX]);\n-  st->print(\"RSP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSP]);\n-  st->print(\"RBP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBP]);\n-  st->print(\"RSI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSI]);\n-  st->print(\"RDI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDI]);\n-  st->print(\"R8 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R8]);\n-  st->print(\"R9 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R9]);\n-  st->print(\"R10=\"); print_location(st, uc->uc_mcontext.gregs[REG_R10]);\n-  st->print(\"R11=\"); print_location(st, uc->uc_mcontext.gregs[REG_R11]);\n-  st->print(\"R12=\"); print_location(st, uc->uc_mcontext.gregs[REG_R12]);\n-  st->print(\"R13=\"); print_location(st, uc->uc_mcontext.gregs[REG_R13]);\n-  st->print(\"R14=\"); print_location(st, uc->uc_mcontext.gregs[REG_R14]);\n-  st->print(\"R15=\"); print_location(st, uc->uc_mcontext.gregs[REG_R15]);\n+  CASE_PRINT_REG( 0, \"RAX=\", RAX); break;\n+  CASE_PRINT_REG( 1, \"RBX=\", RBX); break;\n+  CASE_PRINT_REG( 2, \"RCX=\", RCX); break;\n+  CASE_PRINT_REG( 3, \"RDX=\", RDX); break;\n+  CASE_PRINT_REG( 4, \"RSP=\", RSP); break;\n+  CASE_PRINT_REG( 5, \"RBP=\", RBP); break;\n+  CASE_PRINT_REG( 6, \"RSI=\", RSI); break;\n+  CASE_PRINT_REG( 7, \"RDI=\", RDI); break;\n+  CASE_PRINT_REG( 8, \"R8 =\", R8); break;\n+  CASE_PRINT_REG( 9, \"R9 =\", R9); break;\n+  CASE_PRINT_REG(10, \"R10=\", R10); break;\n+  CASE_PRINT_REG(11, \"R11=\", R11); break;\n+  CASE_PRINT_REG(12, \"R12=\", R12); break;\n+  CASE_PRINT_REG(13, \"R13=\", R13); break;\n+  CASE_PRINT_REG(14, \"R14=\", R14); break;\n+  CASE_PRINT_REG(15, \"R15=\", R15); break;\n@@ -628,8 +630,8 @@\n-  st->print(\"EAX=\"); print_location(st, uc->uc_mcontext.gregs[REG_EAX]);\n-  st->print(\"EBX=\"); print_location(st, uc->uc_mcontext.gregs[REG_EBX]);\n-  st->print(\"ECX=\"); print_location(st, uc->uc_mcontext.gregs[REG_ECX]);\n-  st->print(\"EDX=\"); print_location(st, uc->uc_mcontext.gregs[REG_EDX]);\n-  st->print(\"ESP=\"); print_location(st, uc->uc_mcontext.gregs[REG_ESP]);\n-  st->print(\"EBP=\"); print_location(st, uc->uc_mcontext.gregs[REG_EBP]);\n-  st->print(\"ESI=\"); print_location(st, uc->uc_mcontext.gregs[REG_ESI]);\n-  st->print(\"EDI=\"); print_location(st, uc->uc_mcontext.gregs[REG_EDI]);\n+  CASE_PRINT_REG(0, \"EAX=\", EAX); break;\n+  CASE_PRINT_REG(1, \"EBX=\", EBX); break;\n+  CASE_PRINT_REG(2, \"ECX=\", ECX); break;\n+  CASE_PRINT_REG(3, \"EDX=\", EDX); break;\n+  CASE_PRINT_REG(4, \"ESP=\", ESP); break;\n+  CASE_PRINT_REG(5, \"EBP=\", EBP); break;\n+  CASE_PRINT_REG(6, \"ESI=\", ESI); break;\n+  CASE_PRINT_REG(7, \"EDI=\", EDI); break;\n@@ -637,0 +639,3 @@\n+  }\n+# undef CASE_PRINT_REG\n+}\n@@ -638,1 +643,2 @@\n-  st->cr();\n+int os::print_nth_register_info_max_index() {\n+  return AMD64_ONLY(16) NOT_AMD64(8);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":38,"deletions":32,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-void os::print_register_info(outputStream *st, const void* ucVoid) {\n+void os::print_register_info_header(outputStream *st, const void* ucVoid) {\n@@ -418,0 +418,9 @@\n+  st->cr();\n+}\n+\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  ShouldNotCallThis();\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return 0;\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -228,4 +228,2 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n- if (context == NULL) return;\n-\n-  const CONTEXT* uc = (const CONTEXT*)context;\n+void os::print_register_info_header(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n@@ -235,36 +233,1 @@\n-  \/\/ this is only for the \"general purpose\" registers\n-  st->print(\" X0=\"); print_location(st, uc->X0);\n-  st->print(\" X1=\"); print_location(st, uc->X1);\n-  st->print(\" X2=\"); print_location(st, uc->X2);\n-  st->print(\" X3=\"); print_location(st, uc->X3);\n-  st->cr();\n-  st->print(\" X4=\"); print_location(st, uc->X4);\n-  st->print(\" X5=\"); print_location(st, uc->X5);\n-  st->print(\" X6=\"); print_location(st, uc->X6);\n-  st->print(\" X7=\"); print_location(st, uc->X7);\n-  st->cr();\n-  st->print(\" X8=\"); print_location(st, uc->X8);\n-  st->print(\" X9=\"); print_location(st, uc->X9);\n-  st->print(\"X10=\"); print_location(st, uc->X10);\n-  st->print(\"X11=\"); print_location(st, uc->X11);\n-  st->cr();\n-  st->print(\"X12=\"); print_location(st, uc->X12);\n-  st->print(\"X13=\"); print_location(st, uc->X13);\n-  st->print(\"X14=\"); print_location(st, uc->X14);\n-  st->print(\"X15=\"); print_location(st, uc->X15);\n-  st->cr();\n-  st->print(\"X16=\"); print_location(st, uc->X16);\n-  st->print(\"X17=\"); print_location(st, uc->X17);\n-  st->print(\"X18=\"); print_location(st, uc->X18);\n-  st->print(\"X19=\"); print_location(st, uc->X19);\n-  st->cr();\n-  st->print(\"X20=\"); print_location(st, uc->X20);\n-  st->print(\"X21=\"); print_location(st, uc->X21);\n-  st->print(\"X22=\"); print_location(st, uc->X22);\n-  st->print(\"X23=\"); print_location(st, uc->X23);\n-  st->cr();\n-  st->print(\"X24=\"); print_location(st, uc->X24);\n-  st->print(\"X25=\"); print_location(st, uc->X25);\n-  st->print(\"X26=\"); print_location(st, uc->X26);\n-  st->print(\"X27=\"); print_location(st, uc->X27);\n-  st->print(\"X28=\"); print_location(st, uc->X28);\n+}\n@@ -272,1 +235,44 @@\n-  st->cr();\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n+\n+  const CONTEXT* uc = (const CONTEXT*)context;\n+\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->id);\n+  switch (n) {\n+    CASE_PRINT_REG( 0, \" X0=\", X0); break;\n+    CASE_PRINT_REG( 1, \" X1=\", X1); break;\n+    CASE_PRINT_REG( 2, \" X2=\", X2); break;\n+    CASE_PRINT_REG( 3, \" X3=\", X3); break;\n+    CASE_PRINT_REG( 4, \" X4=\", X4); break;\n+    CASE_PRINT_REG( 5, \" X5=\", X5); break;\n+    CASE_PRINT_REG( 6, \" X6=\", X6); break;\n+    CASE_PRINT_REG( 7, \" X7=\", X7); break;\n+    CASE_PRINT_REG( 8, \" X8=\", X8); break;\n+    CASE_PRINT_REG( 9, \" X9=\", X9); break;\n+    CASE_PRINT_REG(10, \"X10=\", X10); break;\n+    CASE_PRINT_REG(11, \"X11=\", X11); break;\n+    CASE_PRINT_REG(12, \"X12=\", X12); break;\n+    CASE_PRINT_REG(13, \"X13=\", X13); break;\n+    CASE_PRINT_REG(14, \"X14=\", X14); break;\n+    CASE_PRINT_REG(15, \"X15=\", X15); break;\n+    CASE_PRINT_REG(16, \"X16=\", X16); break;\n+    CASE_PRINT_REG(17, \"X17=\", X17); break;\n+    CASE_PRINT_REG(18, \"X18=\", X18); break;\n+    CASE_PRINT_REG(19, \"X19=\", X19); break;\n+    CASE_PRINT_REG(20, \"X20=\", X20); break;\n+    CASE_PRINT_REG(21, \"X21=\", X21); break;\n+    CASE_PRINT_REG(22, \"X22=\", X22); break;\n+    CASE_PRINT_REG(23, \"X23=\", X23); break;\n+    CASE_PRINT_REG(24, \"X24=\", X24); break;\n+    CASE_PRINT_REG(25, \"X25=\", X25); break;\n+    CASE_PRINT_REG(26, \"X26=\", X26); break;\n+    CASE_PRINT_REG(27, \"X27=\", X27); break;\n+    CASE_PRINT_REG(28, \"X28=\", X28); break;\n+  }\n+# undef CASE_PRINT_REG\n+}\n+\n+int os::print_nth_register_info_max_index() {\n+  return 29 \/* X0-X28 *\/;\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":47,"deletions":41,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n+void os::print_register_info_header(outputStream *st, const void *context) {\n@@ -473,2 +473,0 @@\n-  const CONTEXT* uc = (const CONTEXT*)context;\n-\n@@ -477,0 +475,1 @@\n+}\n@@ -478,1 +477,4 @@\n-  \/\/ this is only for the \"general purpose\" registers\n+void os::print_nth_register_info(outputStream *st, int n, const void *context) {\n+  if (context == NULL || n < 0 || n >= print_nth_register_info_max_index()) {\n+    return;\n+  }\n@@ -480,0 +482,3 @@\n+  const CONTEXT* uc = (const CONTEXT*)context;\n+# define CASE_PRINT_REG(n, str, id) case n: st->print(str); print_location(st, uc->id);\n+  switch (n) {\n@@ -481,17 +486,16 @@\n-  st->print(\"RIP=\"); print_location(st, uc->Rip);\n-  st->print(\"RAX=\"); print_location(st, uc->Rax);\n-  st->print(\"RBX=\"); print_location(st, uc->Rbx);\n-  st->print(\"RCX=\"); print_location(st, uc->Rcx);\n-  st->print(\"RDX=\"); print_location(st, uc->Rdx);\n-  st->print(\"RSP=\"); print_location(st, uc->Rsp);\n-  st->print(\"RBP=\"); print_location(st, uc->Rbp);\n-  st->print(\"RSI=\"); print_location(st, uc->Rsi);\n-  st->print(\"RDI=\"); print_location(st, uc->Rdi);\n-  st->print(\"R8 =\"); print_location(st, uc->R8);\n-  st->print(\"R9 =\"); print_location(st, uc->R9);\n-  st->print(\"R10=\"); print_location(st, uc->R10);\n-  st->print(\"R11=\"); print_location(st, uc->R11);\n-  st->print(\"R12=\"); print_location(st, uc->R12);\n-  st->print(\"R13=\"); print_location(st, uc->R13);\n-  st->print(\"R14=\"); print_location(st, uc->R14);\n-  st->print(\"R15=\"); print_location(st, uc->R15);\n+  CASE_PRINT_REG( 0, \"RAX=\", Rax); break;\n+  CASE_PRINT_REG( 1, \"RBX=\", Rbx); break;\n+  CASE_PRINT_REG( 2, \"RCX=\", Rcx); break;\n+  CASE_PRINT_REG( 3, \"RDX=\", Rdx); break;\n+  CASE_PRINT_REG( 4, \"RSP=\", Rsp); break;\n+  CASE_PRINT_REG( 5, \"RBP=\", Rbp); break;\n+  CASE_PRINT_REG( 6, \"RSI=\", Rsi); break;\n+  CASE_PRINT_REG( 7, \"RDI=\", Rdi); break;\n+  CASE_PRINT_REG( 8, \"R8 =\", R8); break;\n+  CASE_PRINT_REG( 9, \"R9 =\", R9); break;\n+  CASE_PRINT_REG(10, \"R10=\", R10); break;\n+  CASE_PRINT_REG(11, \"R11=\", R11); break;\n+  CASE_PRINT_REG(12, \"R12=\", R12); break;\n+  CASE_PRINT_REG(13, \"R13=\", R13); break;\n+  CASE_PRINT_REG(14, \"R14=\", R14); break;\n+  CASE_PRINT_REG(15, \"R15=\", R15); break;\n@@ -499,10 +503,12 @@\n-  st->print(\"EIP=\"); print_location(st, uc->Eip);\n-  st->print(\"EAX=\"); print_location(st, uc->Eax);\n-  st->print(\"EBX=\"); print_location(st, uc->Ebx);\n-  st->print(\"ECX=\"); print_location(st, uc->Ecx);\n-  st->print(\"EDX=\"); print_location(st, uc->Edx);\n-  st->print(\"ESP=\"); print_location(st, uc->Esp);\n-  st->print(\"EBP=\"); print_location(st, uc->Ebp);\n-  st->print(\"ESI=\"); print_location(st, uc->Esi);\n-  st->print(\"EDI=\"); print_location(st, uc->Edi);\n-#endif\n+  CASE_PRINT_REG(0, \"EAX=\", Eax); break;\n+  CASE_PRINT_REG(1, \"EBX=\", Ebx); break;\n+  CASE_PRINT_REG(2, \"ECX=\", Ecx); break;\n+  CASE_PRINT_REG(3, \"EDX=\", Edx); break;\n+  CASE_PRINT_REG(4, \"ESP=\", Esp); break;\n+  CASE_PRINT_REG(5, \"EBP=\", Ebp); break;\n+  CASE_PRINT_REG(6, \"ESI=\", Esi); break;\n+  CASE_PRINT_REG(7, \"EDI=\", Edi); break;\n+#endif \/\/ AMD64\n+  }\n+# undef CASE_PRINT_REG\n+}\n@@ -510,1 +516,2 @@\n-  st->cr();\n+int os::print_nth_register_info_max_index() {\n+  return AMD64_ONLY(16) NOT_AMD64(8);\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -494,0 +494,3 @@\n+  develop(bool, TestReentrantErrorHandler, false,                           \\\n+          \"If true, simulates an reentrant error handler.\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -760,1 +760,3 @@\n-  static void print_register_info(outputStream* st, const void* context);\n+  static void print_register_info_header(outputStream* st, const void* context);\n+  static void print_nth_register_info(outputStream* st, int n, const void* context);\n+  static int  print_nth_register_info_max_index();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -78,0 +79,1 @@\n+int               VMError::_reentrant_iteration_step = -1;\n@@ -95,0 +97,7 @@\n+const size_t      VMError::_reentrant_reentries_stack_headroom = 64 * K;\n+const size_t      VMError::_global_reentrant_reentries_limit = 8;\n+size_t            VMError::_global_reentrant_reentries = 0;\n+const size_t      VMError::_default_step_reentrant_reentries_limit = 4;\n+size_t            VMError::_step_reentrant_reentries_limit =\n+                           _default_step_reentrant_reentries_limit;\n+size_t            VMError::_step_reentrant_reentries = 0;\n@@ -169,0 +178,52 @@\n+static bool check_stack_headroom(Thread* thread,\n+                                 size_t headroom) {\n+  static const address stack_top    = thread != nullptr\n+                                    ? thread->stack_base()\n+                                    : os::current_stack_base();\n+  static const size_t  stack_size   = thread != nullptr\n+                                    ? thread->stack_size()\n+                                    : os::current_stack_size();\n+  static const address stack_bottom = stack_top - stack_size;\n+\n+  const address stack_pointer = os::current_stack_pointer();\n+\n+  const ptrdiff_t stack_headroom = stack_pointer - stack_bottom;\n+  return (stack_pointer < stack_bottom || stack_headroom < 0 ||\n+          static_cast<size_t>(stack_headroom) < headroom);\n+}\n+\n+#ifdef ASSERT\n+void VMError::reenterant_test_hit_stack_limit() {\n+  if (!check_stack_headroom(_thread, _reentrant_reentries_stack_headroom)) {\n+    char stack_buffer[_reentrant_reentries_stack_headroom \/ 2];\n+    static_cast<void>(stack_buffer[sizeof(stack_buffer) - 1] = '\\0');\n+    reenterant_test_hit_stack_limit();\n+  }\n+  controlled_crash(14);\n+}\n+#endif \/\/ ASSERT\n+\n+bool VMError::should_stop_reenterant_entry(const char* &reason) {\n+  if (check_stack_headroom(_thread, _reentrant_reentries_stack_headroom)) {\n+    reason = \"Stack headroom limit reached\";\n+    return true;\n+  }\n+\n+  if (_global_reentrant_reentries >= _global_reentrant_reentries_limit) {\n+    reason = \"Global reentry limit reached\";\n+    return true;\n+  }\n+\n+  if (_step_reentrant_reentries >= _step_reentrant_reentries_limit) {\n+    reason = \"Step-wise reentry limit reached\";\n+    return true;\n+  }\n+\n+  if (_step_did_timeout) {\n+    reason = \"Step time limit reached\";\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n@@ -531,4 +592,72 @@\n-# define BEGIN if (_current_step == 0) { _current_step = __LINE__;\n-# define STEP(s) } if (_current_step < __LINE__) { _current_step = __LINE__; _current_step_info = s; \\\n-  record_step_start_time(); _step_did_timeout = false;\n-# define END clear_step_start_time(); }\n+\/\/ Used for REENTRANT_STEP bookkeeping\n+int reentry_step = _current_step;\n+bool should_break_on_reenterant_entry = false;\n+const char* break_on_reenterant_entry_reason = \"\";\n+# define REENTRANT_ITERATION_STEP (_reentrant_iteration_step-1)\n+# define REENTRANT_STEP_REENTRY_LIMIT(limit)               \\\n+  _step_reentrant_reentries_limit = (limit)\n+# define BEGIN                                             \\\n+  if (_current_step == 0) {                                \\\n+    _current_step = __LINE__;                              \\\n+    {\n+      \/\/ [Begin logic]\n+# define STEP(s)                                           \\\n+    }                                                      \\\n+  }                                                        \\\n+  if (_current_step < __LINE__) {                          \\\n+    _current_step = __LINE__;                              \\\n+    _current_step_info = s;                                \\\n+    record_step_start_time();                              \\\n+    _step_did_timeout = false;                             \\\n+    {\n+      \/\/ [Step logic]\n+# define REENTRANT_STEP_IF(s,cond)                         \\\n+    }                                                      \\\n+  }                                                        \\\n+  if (_current_step < __LINE__) {                          \\\n+    reentry_step = _current_step;                          \\\n+    _current_step = __LINE__;                              \\\n+    _current_step_info = s;                                \\\n+    if (_reentrant_iteration_step == -1) {                 \\\n+      record_step_start_time();                            \\\n+      _step_did_timeout = false;                           \\\n+    }                                                      \\\n+    if (cond) {                                            \\\n+      _current_step = reentry_step;                        \\\n+      should_break_on_reenterant_entry = false;            \\\n+      break_on_reenterant_entry_reason = \"\";               \\\n+      if (_reentrant_iteration_step++ == -1) {             \\\n+        _step_reentrant_reentries_limit =                  \\\n+            _default_step_reentrant_reentries_limit;\n+        \/\/ [Renterant step pre loop logic]\n+# define REENTRANT_LOOP_START(limit)                       \\\n+        _reentrant_iteration_step++;                       \\\n+      } else {                                             \\\n+        _global_reentrant_reentries++;                     \\\n+        _step_reentrant_reentries++;                       \\\n+        should_break_on_reenterant_entry =                 \\\n+            should_stop_reenterant_entry(                  \\\n+                break_on_reenterant_entry_reason);         \\\n+      }                                                    \\\n+      while (REENTRANT_ITERATION_STEP  < (limit)) {        \\\n+        if (should_break_on_reenterant_entry) {            \\\n+          st->print_cr(\"[break (%s, iteration step #%d)\"   \\\n+                       \" reason: %s]\", _current_step_info, \\\n+                       REENTRANT_ITERATION_STEP,           \\\n+                       break_on_reenterant_entry_reason);  \\\n+          break;                                           \\\n+        }\n+        \/\/ [Renterant step loop logic]\n+# define REENTRANT_LOOP_END                                \\\n+        _reentrant_iteration_step++;                       \\\n+      }                                                    \\\n+      _current_step = __LINE__;                            \\\n+      _step_reentrant_reentries = 0;                       \\\n+      _reentrant_iteration_step = -1;                      \\\n+      record_step_start_time();                            \\\n+      _step_did_timeout = false;\n+      \/\/ [Renterant step post loop logic]\n+# define END                                               \\\n+    }                                                      \\\n+    clear_step_start_time();                               \\\n+  }\n@@ -603,0 +732,74 @@\n+  \/\/ See corresponding test in test\/runtime\/ErrorHandling\/TestReentrantErrorHandler.java\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Step\", _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Step: Start\");\n+      \/\/ Test secondary crash before loop\n+    controlled_crash(TEST_SECONDARY_CRASH);\n+    REENTRANT_LOOP_START(4)\n+      \/\/ Test secondary crash in loop\n+      if (REENTRANT_ITERATION_STEP == 0) {\n+        controlled_crash(TEST_SECONDARY_CRASH);\n+      }\n+      \/\/ Test timeout in loop\n+      if (REENTRANT_ITERATION_STEP == 2) {\n+        os::infinite_sleep();\n+      }\n+      st->print_cr(\"TestReentrantErrorHandler Step: %d\", REENTRANT_ITERATION_STEP);\n+    REENTRANT_LOOP_END\n+\n+    st->print_cr(\"TestReentrantErrorHandler Step: Finished\");\n+    \/\/ The post loop logic is given another timeout window to allow\n+    \/\/ for a summary of the (partial) reentrant step. However post\n+    \/\/ loop logic should not have logic that can timeout, this is\n+    \/\/ only here to make sure that it would be handled.\n+    os::infinite_sleep();\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Rentry Limit\",\n+       _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Rentry Limit: Start\");\n+    REENTRANT_STEP_REENTRY_LIMIT(1);\n+    REENTRANT_LOOP_START(2)\n+      if (REENTRANT_ITERATION_STEP == 0) {\n+        controlled_crash(TEST_SECONDARY_CRASH);\n+      }\n+      st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Rentry Limit: Finished\");\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Global Rentry Limit\",\n+      _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Global Rentry Limit: Start\");\n+    REENTRANT_STEP_REENTRY_LIMIT(_global_reentrant_reentries_limit);\n+    REENTRANT_LOOP_START((int)_global_reentrant_reentries_limit)\n+      controlled_crash(TEST_SECONDARY_CRASH);\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Global Rentry Limit: Finished\");\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Stack Limit\",\n+      _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Stack Limit: Start\");\n+    reenterant_test_hit_stack_limit();\n+    REENTRANT_LOOP_START(1)\n+      st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Stack Limit: Finished\");\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Step: After\", _verbose && TestReentrantErrorHandler)\n+    \/\/ Crashes in previous reentrant step does not change future reentrant steps\n+    st->print_cr(\"TestReentrantErrorHandler Step: After still works\");\n+    REENTRANT_LOOP_START(4)\n+      st->print_cr(\"TestReentrantErrorHandler Step: After %d\", REENTRANT_ITERATION_STEP);\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Step: After End\");\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Step: Condition\",\n+    _verbose && TestReentrantErrorHandler && [](){\n+      controlled_crash(TEST_SECONDARY_CRASH);\n+      return true;\n+    }())\n+\n+    st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+    REENTRANT_LOOP_START(1)\n+      st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+\n@@ -907,1 +1110,2 @@\n-  STEP(\"printing register info\")\n+  REENTRANT_STEP_IF(\"printing register info\", _verbose && _context && _thread && Universe::is_fully_initialized())\n+    os::print_register_info_header(st, _context);\n@@ -909,6 +1113,7 @@\n-     \/\/ decode register contents if possible\n-     if (_verbose && _context && _thread && Universe::is_fully_initialized()) {\n-       ResourceMark rm(_thread);\n-       os::print_register_info(st, _context);\n-       st->cr();\n-     }\n+    REENTRANT_LOOP_START(os::print_nth_register_info_max_index())\n+      \/\/ decode register contents if possible\n+      ResourceMark rm(_thread);\n+      os::print_nth_register_info(st, REENTRANT_ITERATION_STEP, _context);\n+    REENTRANT_LOOP_END\n+\n+    st->cr();\n@@ -924,1 +1129,13 @@\n-  STEP(\"inspecting top of stack\")\n+  REENTRANT_STEP_IF(\"inspecting top of stack\", _verbose && _context && _thread && Universe::is_fully_initialized())\n+    st->print_cr(\"Stack slot to memory mapping:\");\n+\n+    REENTRANT_LOOP_START(8)\n+      \/\/ decode stack contents if possible\n+      frame fr = os::fetch_frame_from_context(_context);\n+      const intptr_t *slot = fr.sp() + REENTRANT_ITERATION_STEP;\n+      if (is_aligned(slot, sizeof(intptr_t)) && os::is_readable_pointer(slot)) {\n+        st->print(\"stack at sp + %d slots: \", REENTRANT_ITERATION_STEP);\n+        ResourceMark rm(_thread);\n+        os::print_location(st, *(slot));\n+      }\n+    REENTRANT_LOOP_END\n@@ -926,16 +1143,1 @@\n-     \/\/ decode stack contents if possible\n-     if (_verbose && _context && _thread && Universe::is_fully_initialized()) {\n-       frame fr = os::fetch_frame_from_context(_context);\n-       const int slots = 8;\n-       const intptr_t *start = fr.sp();\n-       const intptr_t *end = start + slots;\n-       if (is_aligned(start, sizeof(intptr_t)) && os::is_readable_range(start, end)) {\n-         st->print_cr(\"Stack slot to memory mapping:\");\n-         for (int i = 0; i < slots; ++i) {\n-           st->print(\"stack at sp + %d slots: \", i);\n-           ResourceMark rm(_thread);\n-           os::print_location(st, *(start + i));\n-         }\n-       }\n-       st->cr();\n-     }\n+    st->cr();\n@@ -1237,0 +1439,5 @@\n+# undef REENTRANT_STEP_IF\n+# undef REENTRANT_LOOP_START\n+# undef REENTRANT_STEP_REENTRY_LIMIT\n+# undef REENTRANT_ITERATION_STEP\n+# undef REENTRANT_LOOP_END\n@@ -1619,0 +1826,3 @@\n+        if (_reentrant_iteration_step > 0) {\n+          st->print(\", iteration step #%d\", _reentrant_iteration_step-1);\n+        }\n@@ -1636,2 +1846,7 @@\n-        ss.print(\"[error occurred during error reporting (%s), id 0x%x\",\n-                   _current_step_info, id);\n+        if (_reentrant_iteration_step > 0) {\n+          ss.print(\"[error occurred during error reporting (%s, iteration step #%d), id 0x%x\",\n+                    _current_step_info, _reentrant_iteration_step-1, id);\n+        } else {\n+          ss.print(\"[error occurred during error reporting (%s), id 0x%x\",\n+                    _current_step_info, id);\n+        }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":245,"deletions":30,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  static int         _reentrant_iteration_step;\n@@ -69,0 +70,8 @@\n+  \/\/ used for reentrant reentry logic\n+  static const size_t _reentrant_reentries_stack_headroom;\n+  static const size_t _global_reentrant_reentries_limit;\n+  static size_t       _global_reentrant_reentries;\n+  static const size_t _default_step_reentrant_reentries_limit;\n+  static size_t       _step_reentrant_reentries_limit;\n+  static size_t       _step_reentrant_reentries;\n+\n@@ -126,0 +135,3 @@\n+  DEBUG_ONLY(static void reenterant_test_hit_stack_limit());\n+  static bool should_stop_reenterant_entry(const char* &reason);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -373,0 +373,1 @@\n+ -runtime\/ErrorHandling\/TestReentrantErrorHandler.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStreamReader;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @summary Test Reentrant Error Handling Steps when generating hs_err files\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires (vm.debug == true) & (os.family != \"windows\")\n+ * @run driver TestReentrantErrorHandler\n+ *\/\n+\n+public class TestReentrantErrorHandler {\n+\n+    public static final boolean verbose = System.getProperty(\"verbose\") != null;\n+    \/\/ 16 seconds for hs_err generation timeout = 4 seconds per step timeout\n+    public static final int ERROR_LOG_TIMEOUT = 16;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xmx100M\",\n+            \"-XX:ErrorHandlerTest=14\",\n+            \"-XX:+TestReentrantErrorHandler\",\n+            \"-XX:ErrorLogTimeout=\" + ERROR_LOG_TIMEOUT,\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-version\");\n+\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+\n+        if (verbose) {\n+            System.err.println(\"<begin cmd output>\");\n+            System.err.println(output_detail.getOutput());\n+            System.err.println(\"<end cmd output>\");\n+        }\n+\n+        \/\/ we should have crashed with a SIGSEGV\n+        output_detail.shouldMatch(\"# A fatal error has been detected by the Java Runtime Environment:.*\");\n+        output_detail.shouldMatch(\"# +(?:SIGSEGV|SIGBUS|EXCEPTION_ACCESS_VIOLATION).*\");\n+\n+        \/\/ extract hs-err file\n+        String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n+        if (hs_err_file == null) {\n+            if (!verbose) {\n+                System.err.println(\"<begin cmd output>\");\n+                System.err.println(output_detail.getOutput());\n+                System.err.println(\"<end cmd output>\");\n+            }\n+            throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n+        }\n+\n+        File f = new File(hs_err_file);\n+        if (!f.exists()) {\n+            if (!verbose) {\n+                System.err.println(\"<begin cmd output>\");\n+                System.err.println(output_detail.getOutput());\n+                System.err.println(\"<end cmd output>\");\n+            }\n+            throw new RuntimeException(\"hs-err file missing at \"\n+                + f.getAbsolutePath() + \".\\n\");\n+        }\n+\n+        System.out.println(\"Found hs_err file. Scanning...\");\n+\n+        FileInputStream fis = new FileInputStream(f);\n+        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+        String line = null;\n+\n+\n+        Pattern [] pattern = new Pattern[] {\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: Start.*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Step\\\\).*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Step, iteration step #0\\\\).*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: 1.*\"),\n+            Pattern.compile(\".*timeout occurred during error reporting in step \\\"TestReentrantErrorHandler Step, iteration step #2\\\".*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Step, iteration step #3\\\\) reason: Step time limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: Finished.*\"),\n+            Pattern.compile(\".*timeout occurred during error reporting in step \\\"TestReentrantErrorHandler Step\\\".*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Rentry Limit: Start.*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Rentry Limit, iteration step #0\\\\).*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Rentry Limit, iteration step #1\\\\) reason: Step-wise reentry limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Rentry Limit: Finished.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Global Rentry Limit: Start.*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Global Rentry Limit, iteration step #.*\\\\) reason: Global reentry limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Global Rentry Limit: Finished.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Stack Limit: Start.*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Stack Limit\\\\).*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Stack Limit, iteration step #0\\\\) reason: Stack headroom limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Stack Limit: Finished.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: After still works.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: After 0.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: After 1.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: After 2.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: After 3.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: After End.*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Step: Condition\\\\).*\")\n+        };\n+        Pattern badPattern = Pattern.compile(\".*TestReentrantErrorHandler: BAD LINE.*\");\n+        int currentPattern = 0;\n+\n+        boolean badPatternFound = false;\n+        String lastLine = null;\n+        StringBuilder saved_hs_err = new StringBuilder();\n+        while ((line = br.readLine()) != null) {\n+            saved_hs_err.append(line + System.lineSeparator());\n+            if (currentPattern < pattern.length) {\n+                if (pattern[currentPattern].matcher(line).matches()) {\n+                    System.out.println(\"Found: \" + line + \".\");\n+                    currentPattern ++;\n+                }\n+            }\n+            if (badPattern.matcher(line).matches()) {\n+                badPatternFound = true;\n+            }\n+            lastLine = line;\n+        }\n+        br.close();\n+\n+        if (verbose) {\n+            System.err.println(\"<begin hs_err contents>\");\n+            System.err.print(saved_hs_err);\n+            System.err.println(\"<end hs_err contents>\");\n+        }\n+\n+        if (badPatternFound) {\n+            if (!verbose) {\n+                System.err.println(\"<begin hs_err contents>\");\n+                System.err.print(saved_hs_err);\n+                System.err.println(\"<end hs_err contents>\");\n+            }\n+            throw new RuntimeException(\"hs-err file contained a bad print statement\");\n+        }\n+\n+        if (currentPattern < pattern.length) {\n+            if (!verbose) {\n+                System.err.println(\"<begin hs_err contents>\");\n+                System.err.print(saved_hs_err);\n+                System.err.println(\"<end hs_err contents>\");\n+            }\n+            throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \\\"\" +  pattern[currentPattern].pattern() + \"\\\")\");\n+        }\n+\n+        if (!lastLine.equals(\"END.\")) {\n+            throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n+        } else {\n+            System.out.println(\"End marker found.\");\n+        }\n+\n+        System.out.println(\"OK.\");\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestReentrantErrorHandler.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"}]}