{"files":[{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -96,0 +97,7 @@\n+const size_t      VMError::_reentrant_reentries_stack_headroom = 64 * K;\n+const size_t      VMError::_global_reentrant_reentries_limit = 8;\n+size_t            VMError::_global_reentrant_reentries = 0;\n+const size_t      VMError::_default_step_reentrant_reentries_limit = 4;\n+size_t            VMError::_step_reentrant_reentries_limit =\n+                           _default_step_reentrant_reentries_limit;\n+size_t            VMError::_step_reentrant_reentries = 0;\n@@ -170,0 +178,52 @@\n+static bool check_stack_headroom(Thread* thread,\n+                                 size_t headroom) {\n+  static const address stack_top    = thread != nullptr\n+                                    ? thread->stack_base()\n+                                    : os::current_stack_base();\n+  static const size_t  stack_size   = thread != nullptr\n+                                    ? thread->stack_size()\n+                                    : os::current_stack_size();\n+  static const address stack_bottom = stack_top - stack_size;\n+\n+  const address stack_pointer = os::current_stack_pointer();\n+\n+  const ptrdiff_t stack_headroom = stack_pointer - stack_bottom;\n+  return (stack_pointer < stack_bottom || stack_headroom < 0 ||\n+          static_cast<size_t>(stack_headroom) < headroom);\n+}\n+\n+#ifdef ASSERT\n+void VMError::reenterant_test_hit_stack_limit() {\n+  if (!check_stack_headroom(_thread, _reentrant_reentries_stack_headroom)) {\n+    char stack_buffer[_reentrant_reentries_stack_headroom \/ 2];\n+    static_cast<void>(stack_buffer[sizeof(stack_buffer) - 1] = '\\0');\n+    reenterant_test_hit_stack_limit();\n+  }\n+  controlled_crash(14);\n+}\n+#endif \/\/ ASSERT\n+\n+bool VMError::should_stop_reenterant_entry(const char* &reason) {\n+  if (check_stack_headroom(_thread, _reentrant_reentries_stack_headroom)) {\n+    reason = \"Stack headroom limit reached\";\n+    return true;\n+  }\n+\n+  if (_global_reentrant_reentries >= _global_reentrant_reentries_limit) {\n+    reason = \"Global reentry limit reached\";\n+    return true;\n+  }\n+\n+  if (_step_reentrant_reentries >= _step_reentrant_reentries_limit) {\n+    reason = \"Step-wise reentry limit reached\";\n+    return true;\n+  }\n+\n+  if (_step_did_timeout) {\n+    reason = \"Step time limit reached\";\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n@@ -532,1 +592,1 @@\n-\/\/ Used for  REENTRANT_STEP bookkeeping\n+\/\/ Used for REENTRANT_STEP bookkeeping\n@@ -534,0 +594,2 @@\n+bool should_break_on_reenterant_entry = false;\n+const char* break_on_reenterant_entry_reason = \"\";\n@@ -535,0 +597,2 @@\n+# define REENTRANT_STEP_REENTRY_LIMIT(limit)               \\\n+  _step_reentrant_reentries_limit = (limit)\n@@ -557,2 +621,4 @@\n-    record_step_start_time();                              \\\n-    _step_did_timeout = false;                             \\\n+    if (_reentrant_iteration_step == -1) {                 \\\n+      record_step_start_time();                            \\\n+      _step_did_timeout = false;                           \\\n+    }                                                      \\\n@@ -561,1 +627,5 @@\n-      if (_reentrant_iteration_step++ == -1) {\n+      should_break_on_reenterant_entry = false;            \\\n+      break_on_reenterant_entry_reason = \"\";               \\\n+      if (_reentrant_iteration_step++ == -1) {             \\\n+        _step_reentrant_reentries_limit =                  \\\n+            _default_step_reentrant_reentries_limit;\n@@ -565,0 +635,6 @@\n+      } else {                                             \\\n+        _global_reentrant_reentries++;                     \\\n+        _step_reentrant_reentries++;                       \\\n+        should_break_on_reenterant_entry =                 \\\n+            should_stop_reenterant_entry(                  \\\n+                break_on_reenterant_entry_reason);         \\\n@@ -566,1 +642,8 @@\n-      while (REENTRANT_ITERATION_STEP  < (limit)) {\n+      while (REENTRANT_ITERATION_STEP  < (limit)) {        \\\n+        if (should_break_on_reenterant_entry) {            \\\n+          st->print_cr(\"[break (%s, iteration step #%d)\"   \\\n+                       \" reason: %s]\", _current_step_info, \\\n+                       REENTRANT_ITERATION_STEP,           \\\n+                       break_on_reenterant_entry_reason);  \\\n+          break;                                           \\\n+        }\n@@ -572,1 +655,4 @@\n-      _reentrant_iteration_step = -1;\n+      _step_reentrant_reentries = 0;                       \\\n+      _reentrant_iteration_step = -1;                      \\\n+      record_step_start_time();                            \\\n+      _step_did_timeout = false;\n@@ -657,1 +743,1 @@\n-      if (REENTRANT_ITERATION_STEP % 2 == 1) {\n+      if (REENTRANT_ITERATION_STEP == 2) {\n@@ -664,2 +750,35 @@\n-    \/\/ Test secondary crash after loop\n-    controlled_crash(TEST_SECONDARY_CRASH);\n+    \/\/ The post loop logic is given another timeout window to allow\n+    \/\/ for a summary of the (partial) reentrant step. However post\n+    \/\/ loop logic should not have logic that can timeout, this is\n+    \/\/ only here to make sure that it would be handled.\n+    os::infinite_sleep();\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Rentry Limit\",\n+       _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Rentry Limit: Start\");\n+    REENTRANT_STEP_REENTRY_LIMIT(1);\n+    REENTRANT_LOOP_START(2)\n+      if (REENTRANT_ITERATION_STEP == 0) {\n+        controlled_crash(TEST_SECONDARY_CRASH);\n+      }\n+      st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Rentry Limit: Finished\");\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Global Rentry Limit\",\n+      _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Global Rentry Limit: Start\");\n+    REENTRANT_STEP_REENTRY_LIMIT(_global_reentrant_reentries_limit);\n+    REENTRANT_LOOP_START((int)_global_reentrant_reentries_limit)\n+      controlled_crash(TEST_SECONDARY_CRASH);\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Global Rentry Limit: Finished\");\n+\n+  REENTRANT_STEP_IF(\"TestReentrantErrorHandler Stack Limit\",\n+      _verbose && TestReentrantErrorHandler)\n+    st->print_cr(\"TestReentrantErrorHandler Stack Limit: Start\");\n+    reenterant_test_hit_stack_limit();\n+    REENTRANT_LOOP_START(1)\n+      st->print_cr(\"TestReentrantErrorHandler: BAD LINE.\");\n+    REENTRANT_LOOP_END\n+    st->print_cr(\"TestReentrantErrorHandler Stack Limit: Finished\");\n@@ -1322,0 +1441,1 @@\n+# undef REENTRANT_STEP_REENTRY_LIMIT\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":129,"deletions":9,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+  \/\/ used for reentrant reentry logic\n+  static const size_t _reentrant_reentries_stack_headroom;\n+  static const size_t _global_reentrant_reentries_limit;\n+  static size_t       _global_reentrant_reentries;\n+  static const size_t _default_step_reentrant_reentries_limit;\n+  static size_t       _step_reentrant_reentries_limit;\n+  static size_t       _step_reentrant_reentries;\n+\n@@ -127,0 +135,3 @@\n+  DEBUG_ONLY(static void reenterant_test_hit_stack_limit());\n+  static bool should_stop_reenterant_entry(const char* &reason);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -105,3 +105,3 @@\n-            Pattern.compile(\".*timeout occurred during error reporting in step \\\"TestReentrantErrorHandler Step, iteration step #1\\\".*\"),\n-            Pattern.compile(\".*TestReentrantErrorHandler Step: 2.*\"),\n-            Pattern.compile(\".*timeout occurred during error reporting in step \\\"TestReentrantErrorHandler Step, iteration step #3\\\".*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Step: 1.*\"),\n+            Pattern.compile(\".*timeout occurred during error reporting in step \\\"TestReentrantErrorHandler Step, iteration step #2\\\".*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Step, iteration step #3\\\\) reason: Step time limit reached.*\"),\n@@ -109,1 +109,12 @@\n-            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Step\\\\).*\"),\n+            Pattern.compile(\".*timeout occurred during error reporting in step \\\"TestReentrantErrorHandler Step\\\".*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Rentry Limit: Start.*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Rentry Limit, iteration step #0\\\\).*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Rentry Limit, iteration step #1\\\\) reason: Step-wise reentry limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Rentry Limit: Finished.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Global Rentry Limit: Start.*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Global Rentry Limit, iteration step #.*\\\\) reason: Global reentry limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Global Rentry Limit: Finished.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Stack Limit: Start.*\"),\n+            Pattern.compile(\".*error occurred during error reporting \\\\(TestReentrantErrorHandler Stack Limit\\\\).*\"),\n+            Pattern.compile(\".*break \\\\(TestReentrantErrorHandler Stack Limit, iteration step #0\\\\) reason: Stack headroom limit reached.*\"),\n+            Pattern.compile(\".*TestReentrantErrorHandler Stack Limit: Finished.*\"),\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestReentrantErrorHandler.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}