{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    throws NoSuchAlgorithmException\n+            throws NoSuchAlgorithmException\n@@ -84,0 +84,9 @@\n+    \/**\n+     * @see #CertAndKeyGen(String, String, String, PrivateKey, X500Name)\n+     *\/\n+    public CertAndKeyGen (String keyType, String sigAlg, String providerName)\n+            throws NoSuchAlgorithmException, NoSuchProviderException\n+    {\n+        this(keyType, sigAlg, providerName, null, null);\n+    }\n+\n@@ -86,1 +95,2 @@\n-     * signature algorithm, and provider.\n+     * signature algorithm, and provider. The newly generated cert will\n+     * be signed by the signer's private key when it is provided.\n@@ -88,5 +98,5 @@\n-     * @param keyType type of key, e.g. \"RSA\", \"DSA\"\n-     * @param sigAlg name of the signature algorithm, e.g. \"MD5WithRSA\",\n-     *          \"MD2WithRSA\", \"SHAwithDSA\". If set to null, a default\n-     *          algorithm matching the private key will be chosen after\n-     *          the first keypair is generated.\n+     * @param keyType type of key, e.g. \"RSA\", \"DSA\", \"X25519\", \"DH\", etc.\n+     * @param sigAlg name of the signature algorithm, e.g. \"SHA384WithRSA\",\n+     *          \"SHA256withDSA\", etc. If set to null, a default\n+     *          algorithm matching the private key or signer's private\n+     *          key will be chosen after the first keypair is generated.\n@@ -94,0 +104,2 @@\n+     * @param signerPrivateKey (optional) signer's private key\n+     * @param signerSubjectName (optional) signer's subject name\n@@ -97,2 +109,3 @@\n-    public CertAndKeyGen (String keyType, String sigAlg, String providerName)\n-    throws NoSuchAlgorithmException, NoSuchProviderException\n+    public CertAndKeyGen(String keyType, String sigAlg, String providerName,\n+            PrivateKey signerPrivateKey, X500Name signerSubjectName)\n+        throws NoSuchAlgorithmException, NoSuchProviderException\n@@ -112,0 +125,3 @@\n+        this.signerPrivateKey = signerPrivateKey;\n+        this.signerSubjectName = signerSubjectName;\n+        this.signerFlag = signerPrivateKey != null;\n@@ -190,5 +206,14 @@\n-            sigAlg = SignatureUtil.getDefaultSigAlgForKey(privateKey);\n-            if (sigAlg == null) {\n-                throw new IllegalArgumentException(\n-                        \"Cannot derive signature algorithm from \"\n-                                + privateKey.getAlgorithm());\n+            if (signerFlag) {\n+                sigAlg = SignatureUtil.getDefaultSigAlgForKey(signerPrivateKey);\n+                if (sigAlg == null) {\n+                    throw new IllegalArgumentException(\n+                            \"Cannot derive signature algorithm from \"\n+                                    + signerPrivateKey.getAlgorithm());\n+                }\n+            } else {\n+                sigAlg = SignatureUtil.getDefaultSigAlgForKey(privateKey);\n+                if (sigAlg == null) {\n+                    throw new IllegalArgumentException(\n+                            \"Cannot derive signature algorithm from \"\n+                                    + privateKey.getAlgorithm());\n+                }\n@@ -269,0 +294,2 @@\n+    \/\/ Create a self-signed certificate, or a certificate that is signed by\n+    \/\/ a signer when the signer's private key is provided.\n@@ -296,1 +323,6 @@\n-            info.set(X509CertInfo.ISSUER, myname);\n+            if (signerFlag) {\n+                \/\/ use signer's subject name to set the issuer name\n+                info.set(X509CertInfo.ISSUER, signerSubjectName);\n+            } else {\n+                info.set(X509CertInfo.ISSUER, myname);\n+            }\n@@ -300,1 +332,6 @@\n-            cert.sign(privateKey, sigAlg);\n+            if (signerFlag) {\n+                \/\/ use signer's private key to sign\n+                cert.sign(signerPrivateKey, sigAlg);\n+            } else {\n+                cert.sign(privateKey, sigAlg);\n+            }\n@@ -324,0 +361,3 @@\n+    private boolean             signerFlag;\n+    private PrivateKey          signerPrivateKey;\n+    private X500Name            signerSubjectName;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/CertAndKeyGen.java","additions":57,"deletions":17,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -166,0 +166,2 @@\n+    private String signerAlias = null;\n+    private char[] signerKeyPass = null;\n@@ -212,0 +214,1 @@\n+            SIGNER, SIGNERKEYPASS,\n@@ -356,0 +359,2 @@\n+        SIGNER(\"signer\", \"<alias>\", \"signer.alias\"),\n+        SIGNERKEYPASS(\"signerkeypass\", \"<arg>\", \"signer.key.password\"),\n@@ -607,0 +612,5 @@\n+            } else if (collator.compare(flags, \"-signer\") == 0) {\n+                signerAlias = args[++i];\n+            } else if (collator.compare(flags, \"-signerkeypass\") == 0) {\n+                signerKeyPass = getPass(modifier, args[++i]);\n+                passwords.add(signerKeyPass);\n@@ -1152,1 +1162,2 @@\n-            doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName);\n+            doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName,\n+                    signerAlias);\n@@ -1862,1 +1873,2 @@\n-                              int keysize, String groupName, String sigAlgName)\n+                              int keysize, String groupName, String sigAlgName,\n+                              String signerAlias)\n@@ -1883,0 +1895,8 @@\n+                } else if (\"XDH\".equalsIgnoreCase(keyAlgName)) {\n+                    keysize = SecurityProviderConstants.DEF_XEC_KEY_SIZE;\n+                } else if (\"X25519\".equalsIgnoreCase(keyAlgName)) {\n+                    keysize = 255;\n+                } else if (\"X448\".equalsIgnoreCase(keyAlgName)) {\n+                    keysize = 448;\n+                } else if (\"DH\".equalsIgnoreCase(keyAlgName)) {\n+                    keysize = SecurityProviderConstants.DEF_DH_KEY_SIZE;\n@@ -1904,2 +1924,18 @@\n-        CertAndKeyGen keypair =\n-                new CertAndKeyGen(keyAlgName, sigAlgName, providerName);\n+        CertAndKeyGen keypair;\n+        KeyIdentifier signerSubjectKeyId = null;\n+        if (signerAlias != null) {\n+            PrivateKey signerPrivateKey =\n+                    (PrivateKey)recoverKey(signerAlias, storePass, signerKeyPass).fst;\n+            Certificate signerCert = keyStore.getCertificate(signerAlias);\n+\n+            X509CertImpl signerCertImpl;\n+            if (signerCert instanceof X509CertImpl) {\n+                signerCertImpl = (X509CertImpl) signerCert;\n+            } else {\n+                signerCertImpl = new X509CertImpl(signerCert.getEncoded());\n+            }\n+\n+            X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(\n+                    X509CertImpl.NAME + \".\" + X509CertImpl.INFO);\n+            X500Name signerSubjectName = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + \".\" +\n+                    X509CertInfo.DN_NAME);\n@@ -1907,0 +1943,10 @@\n+            keypair = new CertAndKeyGen(keyAlgName, sigAlgName, providerName,\n+                    signerPrivateKey, signerSubjectName);\n+\n+            signerSubjectKeyId = signerCertImpl.getSubjectKeyId();\n+            if (signerSubjectKeyId == null) {\n+                signerSubjectKeyId = new KeyIdentifier(signerCert.getPublicKey());\n+            }\n+        } else {\n+            keypair = new CertAndKeyGen(keyAlgName, sigAlgName, providerName);\n+        }\n@@ -1924,2 +1970,0 @@\n-        PrivateKey privKey = keypair.getPrivateKey();\n-\n@@ -1931,1 +1975,1 @@\n-                null);\n+                signerSubjectKeyId);\n@@ -1933,2 +1977,2 @@\n-        X509Certificate[] chain = new X509Certificate[1];\n-        chain[0] = keypair.getSelfCertificate(\n+        PrivateKey privKey = keypair.getPrivateKey();\n+        X509Certificate newCert = keypair.getSelfCertificate(\n@@ -1937,9 +1981,22 @@\n-        MessageFormat form = new MessageFormat(rb.getString\n-            (\"Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for\"));\n-        Object[] source = {\n-                groupName == null ? keysize : KeyUtil.getKeySize(privKey),\n-                fullDisplayAlgName(privKey),\n-                chain[0].getSigAlgName(),\n-                validity,\n-                x500Name};\n-        System.err.println(form.format(source));\n+        if (signerAlias != null) {\n+            MessageFormat form = new MessageFormat(rb.getString\n+                    (\"Generating.keysize.bit.keyAlgName.key.pair.and.a.certificate.sigAlgName.issued.by.signerAlias.with.a.validity.of.validality.days.for\"));\n+            Object[] source = {\n+                    groupName == null ? keysize : KeyUtil.getKeySize(privKey),\n+                    fullDisplayAlgName(privKey),\n+                    newCert.getSigAlgName(),\n+                    signerAlias,\n+                    validity,\n+                    x500Name};\n+            System.err.println(form.format(source));\n+        } else {\n+            MessageFormat form = new MessageFormat(rb.getString\n+                    (\"Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for\"));\n+            Object[] source = {\n+                    groupName == null ? keysize : KeyUtil.getKeySize(privKey),\n+                    fullDisplayAlgName(privKey),\n+                    newCert.getSigAlgName(),\n+                    validity,\n+                    x500Name};\n+            System.err.println(form.format(source));\n+        }\n@@ -1950,2 +2007,12 @@\n-        checkWeak(rb.getString(\"the.generated.certificate\"), chain[0]);\n-        keyStore.setKeyEntry(alias, privKey, keyPass, chain);\n+\n+        Certificate[] finalChain;\n+        if (signerAlias != null) {\n+            Certificate[] signerChain = keyStore.getCertificateChain(signerAlias);\n+            finalChain = new X509Certificate[signerChain.length + 1];\n+            finalChain[0] = newCert;\n+            System.arraycopy(signerChain, 0, finalChain, 1, signerChain.length);\n+        } else {\n+            finalChain = new Certificate[] { newCert };\n+        }\n+        checkWeak(rb.getString(\"the.generated.certificate\"), finalChain);\n+        keyStore.setKeyEntry(alias, privKey, keyPass, finalChain);\n@@ -4247,1 +4314,0 @@\n-     * @param akey the public key for the authority (issuer)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":87,"deletions":21,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,0 +165,4 @@\n+        {\"signer.alias\",\n+                \"signer alias\"}, \/\/-signer\n+        {\"signer.key.password\",\n+                \"signer key password\"}, \/\/-signerkeypass\n@@ -305,0 +309,2 @@\n+        {\"Generating.keysize.bit.keyAlgName.key.pair.and.a.certificate.sigAlgName.issued.by.signerAlias.with.a.validity.of.validality.days.for\",\n+                \"Generating {0} bit {1} key pair and a certificate ({2}) issued by <{3}> with a validity of {4} days\\n\\tfor: {5}\"},\n@@ -484,1 +490,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Resources.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.security.interfaces.XECKey;\n@@ -38,0 +39,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -100,0 +102,15 @@\n+        } else if (key instanceof XECKey) {\n+            XECKey pubk = (XECKey)key;\n+            AlgorithmParameterSpec params = pubk.getParams();\n+            if (params instanceof NamedParameterSpec) {\n+                String name = ((NamedParameterSpec) params).getName();\n+                if (name.equalsIgnoreCase(NamedParameterSpec.X25519.getName())) {\n+                    size = 255;\n+                } else if (name.equalsIgnoreCase(NamedParameterSpec.X448.getName())) {\n+                    size = 448;\n+                } else {\n+                    size = -1;\n+                }\n+            } else {\n+                size = -1;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,0 +114,1 @@\n+    public static final int DEF_XEC_KEY_SIZE;\n@@ -127,0 +128,1 @@\n+        int xecKeySize = 255;\n@@ -165,0 +167,2 @@\n+                    } else if (algoName.equals(\"XDH\")) {\n+                        xecKeySize = value;\n@@ -192,0 +196,1 @@\n+        DEF_XEC_KEY_SIZE = xecKeySize;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260693\n+ * @summary Test for keytool -genkeypair with -signer and -signerkeypass options\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.security.KeyStore;\n+import java.security.PublicKey;\n+import java.util.Arrays;\n+import sun.security.util.DerValue;\n+import sun.security.util.KeyUtil;\n+import sun.security.util.KnownOIDs;\n+import static sun.security.util.KnownOIDs.*;\n+\n+public class GenKeyPairSigner {\n+\n+    static OutputAnalyzer kt(String cmd, String ks) throws Exception {\n+        return SecurityTools.keytool(\"-storepass changeit \" + cmd +\n+                \" -keystore \" + ks);\n+    }\n+\n+    static OutputAnalyzer ktjks(String cmd, String ks, String kpass) throws Exception {\n+        return SecurityTools.keytool(\"-storepass changeit \" + cmd +\n+                \" -keystore \" + ks + \" -storetype jks\" + \" -keypass \" +\n+                kpass);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testSignerPKCS12();\n+        testSignerJKS();\n+        testSignerOpt();\n+    }\n+\n+    static void testSignerPKCS12() throws Exception {\n+        KeyStore kstore;\n+        X509Certificate cert;\n+        String sigName, pKeyAlg;\n+        PublicKey pKey;\n+        int keyLen;\n+\n+        \/*\n+         * The signer alias is stored in the PKCS12 keystore\n+         *\/\n+        System.out.println(\"Testing the signer alias that is stored in the PKCS12 keystore\");\n+        System.out.println(\"Generating a root cert with SubjectKeyIdentifier extension\");\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg EdDSA -alias ca -dname CN=CA -ext bc:c \" +\n+                \"-ext 2.5.29.14=04:14:00:01:02:03:04:05:06:07:08:09:10:11:12:13:14:15:16:17:18:19\")\n+                .shouldContain(\"Generating 255 bit Ed25519 key pair and self-signed certificate (Ed25519) with a validity of 90 days\")\n+                .shouldContain(\"for: CN=CA\")\n+                .shouldHaveExitValue(0);\n+\n+        System.out.println(\"Generating an XDH cert with -signer option\");\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg XDH -alias e1 -dname CN=E1 -signer ca\")\n+                .shouldContain(\"Generating 255 bit XDH key pair and a certificate (Ed25519) issued by <ca> with a validity of 90 days\")\n+                .shouldContain(\"for: CN=E1\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ examine the resulting cert\n+        kstore = KeyStore.getInstance(new File(\"ks\"), \"changeit\".toCharArray());\n+        cert = (X509Certificate)kstore.getCertificate(\"e1\");\n+\n+        Certificate[] certChain = kstore.getCertificateChain(\"e1\");\n+        if (certChain.length != 2) {\n+            throw new Exception(\"Generated cert chain is in error\");\n+        }\n+\n+        sigName = cert.getSigAlgName();\n+        if (sigName != \"Ed25519\") {\n+            throw new Exception(\"Signature algorithm name is in error\");\n+        }\n+\n+        pKey = cert.getPublicKey();\n+        keyLen = KeyUtil.getKeySize(pKey);\n+        if (keyLen != 255) {\n+            throw new Exception(\"Key size is in error\");\n+        }\n+\n+        pKeyAlg = pKey.getAlgorithm();\n+        if (pKeyAlg != \"XDH\") {\n+            throw new Exception(\"Subject Public Key Algorithm is in error\");\n+        }\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-list -v\")\n+                .shouldContain(\"Alias name: e1\")\n+                .shouldContain(\"Certificate chain length: 2\")\n+                .shouldContain(\"Signature algorithm name: Ed25519\")\n+                .shouldContain(\"Subject Public Key Algorithm: 255-bit XDH key\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ check to make sure that cert's AKID is created from the SKID of the signing cert\n+        byte[] expectedId = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+                0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19};\n+\n+        byte[] authorityKeyIdExt = cert.getExtensionValue(\n+                KnownOIDs.AuthorityKeyID.value());\n+\n+        byte[] authorityKeyId = null;\n+        if (authorityKeyIdExt == null) {\n+            throw new Exception(\"Failed to get AKID extension from the cert\");\n+        } else {\n+            try {\n+                authorityKeyId = new DerValue(authorityKeyIdExt).getOctetString();\n+            } catch (IOException e) {\n+                throw new Exception(\"Failed to get AKID encoded OctetString in the cert\");\n+            }\n+        }\n+\n+        authorityKeyId = Arrays.copyOfRange(authorityKeyId, 4, authorityKeyId.length);\n+        if (!Arrays.equals(authorityKeyId, expectedId)) {\n+            throw new Exception(\"Failed due to AKID mismatch\");\n+        }\n+\n+        kt(\"-genkeypair -keyalg RSA -alias ca2 -dname CN=CA2 -ext bc:c \",\n+                \"ks\");\n+\n+        System.out.println(\"Generating an X448 cert with -signer option\");\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg X448 -alias e2 -dname CN=E2 -sigalg SHA384withRSA -signer ca2\")\n+                .shouldContain(\"Generating 448 bit XDH key pair and a certificate (SHA384withRSA) issued by <ca2> with a validity of 90 days\")\n+                .shouldContain(\"for: CN=E2\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ examine the resulting cert\n+        kstore = KeyStore.getInstance(new File(\"ks\"), \"changeit\".toCharArray());\n+        cert = (X509Certificate)kstore.getCertificate(\"e2\");\n+        sigName = cert.getSigAlgName();\n+        if (sigName != \"SHA384withRSA\") {\n+            throw new Exception(\"Signature algorithm name is in error\");\n+        }\n+\n+        pKey = cert.getPublicKey();\n+        keyLen = KeyUtil.getKeySize(pKey);\n+        if (keyLen != 448) {\n+            throw new Exception(\"Key size is in error\");\n+        }\n+\n+        pKeyAlg = pKey.getAlgorithm();\n+        if (pKeyAlg != \"XDH\") {\n+            throw new Exception(\"Subject Public Key Algorithm is in error\");\n+        }\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-list -v\")\n+                .shouldContain(\"Alias name: e2\")\n+                .shouldContain(\"Signature algorithm name: SHA384withRSA\")\n+                .shouldContain(\"Subject Public Key Algorithm: 448-bit XDH key\")\n+                .shouldHaveExitValue(0);\n+\n+        kt(\"-genkeypair -keyalg DSA -alias ca3 -dname CN=CA3 -ext bc:c \",\n+                \"ks\");\n+\n+        System.out.println(\"Generating a DH cert with -signer option\");\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg DH -alias e3 -dname CN=E3 -signer ca3\")\n+                .shouldContain(\"Generating 2,048 bit DH key pair and a certificate (SHA256withDSA) issued by <ca3> with a validity of 90 days\")\n+                .shouldContain(\"for: CN=E3\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ examine the resulting cert\n+        kstore = KeyStore.getInstance(new File(\"ks\"), \"changeit\".toCharArray());\n+        cert = (X509Certificate)kstore.getCertificate(\"e3\");\n+        sigName = cert.getSigAlgName();\n+        if (sigName != \"SHA256withDSA\") {\n+            throw new Exception(\"Signature algorithm name is in error\");\n+        }\n+\n+        pKey = cert.getPublicKey();\n+        keyLen = KeyUtil.getKeySize(pKey);\n+        if (keyLen != 2048) {\n+            throw new Exception(\"Key size is in error\");\n+        }\n+\n+        pKeyAlg = pKey.getAlgorithm();\n+        if (pKeyAlg != \"DH\") {\n+            throw new Exception(\"Subject Public Key Algorithm is in error\");\n+        }\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-list -v\")\n+                .shouldContain(\"Alias name: e3\")\n+                .shouldContain(\"Signature algorithm name: SHA256withRSA\")\n+                .shouldContain(\"Subject Public Key Algorithm: 2048-bit DH key\")\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    static void testSignerJKS() throws Exception {\n+        KeyStore kstore;\n+        X509Certificate cert;\n+        String sigName, pKeyAlg;\n+        PublicKey pKey;\n+        int keyLen;\n+\n+        \/*\n+         * The signer alias is stored in the JKS keystore\n+         * Using JKS keystore here is to test the scenario when the private key\n+         * of the signer entry is protected by a password different from the\n+         * store password, and -signerkeypass option needs to be specified\n+         * along with -signer option.\n+         *\/\n+        System.out.println(\"Testing the signer alias that is stored in the JKS keystore\");\n+        ktjks(\"-genkeypair -keyalg RSA -keysize 1024 -alias ca -dname CN=CA -ext bc:c\",\n+                \"ksjks\", \"cakeypass\");\n+\n+        System.out.println(\"Generating an DSA cert with -signer and -signerkeypass options\");\n+        SecurityTools.keytool(\"-keystore ksjks -storepass changeit -storetype jks \" +\n+                \"-genkeypair -keyalg DSA -keysize 1024 -alias ca1 -dname CN=CA1 \" +\n+                \"-keypass ca1keypass -signer ca -signerkeypass cakeypass\")\n+                .shouldContain(\"Generating 1,024 bit DSA key pair and a certificate (SHA256withRSA) issued by <ca> with a validity of 90 days\")\n+                .shouldContain(\"for: CN=CA1\")\n+                .shouldContain(\"The generated certificate #1 of 2 uses a 1024-bit DSA key which is considered a security risk\")\n+                .shouldContain(\"The generated certificate #2 of 2 uses a 1024-bit RSA key which is considered a security risk\")\n+                .shouldHaveExitValue(0);\n+\n+        System.out.println(\"Generating an XDH cert with -signer and -signerkeypass options\");\n+        SecurityTools.keytool(\"-keystore ksjks -storepass changeit -storetype jks \" +\n+                \"-genkeypair -keyalg XDH -alias e1 -dname CN=E1 \" +\n+                \"-keypass e1keypass -signer ca1 -signerkeypass ca1keypass\")\n+                .shouldContain(\"Generating 255 bit XDH key pair and a certificate (SHA256withDSA) issued by <ca1> with a validity of 90 days\")\n+                .shouldContain(\"for: CN=E1\")\n+                .shouldContain(\"The generated certificate #2 of 3 uses a 1024-bit DSA key which is considered a security risk\")\n+                .shouldContain(\"The generated certificate #3 of 3 uses a 1024-bit RSA key which is considered a security risk\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ examine the resulting cert\n+        kstore = KeyStore.getInstance(new File(\"ksjks\"), \"changeit\".toCharArray());\n+        cert = (X509Certificate)kstore.getCertificate(\"e1\");\n+\n+        Certificate[] certChain = kstore.getCertificateChain(\"e1\");\n+        if (certChain.length != 3) {\n+            throw new Exception(\"Generated cert chain is in error\");\n+        }\n+\n+        sigName = cert.getSigAlgName();\n+        if (sigName != \"SHA256withDSA\") {\n+            throw new Exception(\"Signature algorithm name is in error\");\n+        }\n+\n+        pKey = cert.getPublicKey();\n+        keyLen = KeyUtil.getKeySize(pKey);\n+        if (keyLen != 255) {\n+            throw new Exception(\"Key size is in error\");\n+        }\n+\n+        pKeyAlg = pKey.getAlgorithm();\n+        if (pKeyAlg != \"XDH\") {\n+            throw new Exception(\"Subject Public Key Algorithm is in error\");\n+        }\n+\n+        SecurityTools.keytool(\"-keystore ksjks -storepass changeit \" +\n+                \"-list -v\")\n+                .shouldContain(\"Alias name: e1\")\n+                .shouldContain(\"Certificate chain length: 3\")\n+                .shouldContain(\"Signature algorithm name: SHA256withDSA\")\n+                .shouldContain(\"Subject Public Key Algorithm: 255-bit XDH key\")\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    static void testSignerOpt() throws Exception {\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg X25519 -alias e4 -dname CN=E4\")\n+                .shouldContain(\"Cannot derive signature algorithm from XDH\")\n+                .shouldHaveExitValue(1);\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg X448 -alias e4 -dname CN=E4 -signer noca\")\n+                .shouldContain(\"Alias <noca> does not exist\")\n+                .shouldHaveExitValue(1);\n+\n+        SecurityTools.keytool(\"-genkeypair --help\")\n+                .shouldContain(\"-signer <alias>         signer alias\")\n+                .shouldContain(\"-signerkeypass <arg>    signer key password\")\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GenKeyPairSigner.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"}]}