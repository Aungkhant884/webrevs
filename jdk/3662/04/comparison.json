{"files":[{"patch":"@@ -1378,15 +1378,0 @@\n-\/\/ For -XX:PrintSharedArchiveAndExit\n-class CountSharedStrings : public OopClosure {\n- private:\n-  int _count;\n- public:\n-  CountSharedStrings() : _count(0) {}\n-  void do_oop(oop* p) {\n-    _count++;\n-  }\n-  void do_oop(narrowOop* p) {\n-    _count++;\n-  }\n-  int total() { return _count; }\n-};\n-\n@@ -1447,3 +1432,1 @@\n-    CountSharedStrings cs;\n-    StringTable::shared_oops_do(&cs);\n-    tty->print_cr(\"Number of shared strings: %d\", cs.total());\n+    tty->print_cr(\"Number of shared strings: %zu\", StringTable::shared_entry_count());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-  inline bool empty() {\n+  inline bool empty() const {\n@@ -229,0 +229,4 @@\n+  inline size_t entry_count() const {\n+    return _entry_count;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -204,0 +204,1 @@\n+int java_lang_String::_flags_offset;\n@@ -211,0 +212,12 @@\n+bool java_lang_String::test_and_set_flag(oop java_string, uint8_t flag_mask) {\n+  uint8_t* addr = flags_addr(java_string);\n+  uint8_t value = Atomic::load(addr);\n+  while ((value & flag_mask) == 0) {\n+    uint8_t old_value = value;\n+    value |= flag_mask;\n+    value = Atomic::cmpxchg(addr, old_value, value);\n+    if (value == old_value) return false; \/\/ Flag bit changed from 0 to 1.\n+  }\n+  return true;                  \/\/ Flag bit is already 1.\n+}\n+\n@@ -224,0 +237,1 @@\n+  STRING_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -231,0 +245,1 @@\n+  STRING_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -99,0 +99,5 @@\n+\/\/ The flags field is a collection of bits representing boolean values used\n+\/\/ internally by the VM.\n+#define STRING_INJECTED_FIELDS(macro) \\\n+  macro(java_lang_String, flags, byte_signature, false)\n+\n@@ -105,0 +110,1 @@\n+  static int _flags_offset;\n@@ -112,0 +118,13 @@\n+  \/\/ Bitmasks for values in the injected flags field.\n+  static const uint8_t _deduplication_forbidden_mask = 1 << 0;\n+  static const uint8_t _deduplication_requested_mask = 1 << 1;\n+\n+  static int flags_offset() { CHECK_INIT(_flags_offset); }\n+  \/\/ Return the address of the injected flags field.\n+  static inline uint8_t* flags_addr(oop java_string);\n+  \/\/ Test whether the designated bit of the injected flags field is set.\n+  static inline bool is_flag_set(oop java_string, uint8_t flag_mask);\n+  \/\/ Atomically test and set the designated bit of the injected flags field,\n+  \/\/ returning true if the bit was already set.\n+  static bool test_and_set_flag(oop java_string, uint8_t flag_mask);\n+\n@@ -140,0 +159,13 @@\n+  \/\/ Set the deduplication_forbidden flag true.  This flag is sticky; once\n+  \/\/ set it never gets cleared.  This is set when a String is interned in\n+  \/\/ the StringTable, to prevent string deduplication from changing the\n+  \/\/ String's value array.\n+  static inline void set_deduplication_forbidden(oop java_string);\n+\n+  \/\/ Test and set the deduplication_requested flag.  Returns the old value\n+  \/\/ of the flag.  This flag is sticky; once set it never gets cleared.\n+  \/\/ Some GCs may use this flag when deciding whether to request\n+  \/\/ deduplication of a String, to avoid multiple requests for the same\n+  \/\/ object.\n+  static inline bool test_and_set_deduplication_requested(oop java_string);\n+\n@@ -145,0 +177,2 @@\n+  static inline bool deduplication_forbidden(oop java_string);\n+  static inline bool deduplication_requested(oop java_string);\n@@ -1738,0 +1772,1 @@\n+  STRING_INJECTED_FIELDS(macro)             \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -76,0 +76,26 @@\n+uint8_t* java_lang_String::flags_addr(oop java_string) {\n+  assert(_initialized, \"Must be initialized\");\n+  assert(is_instance(java_string), \"Must be java string\");\n+  return java_string->obj_field_addr<uint8_t>(_flags_offset);\n+}\n+\n+bool java_lang_String::is_flag_set(oop java_string, uint8_t flag_mask) {\n+  return (Atomic::load(flags_addr(java_string)) & flag_mask) != 0;\n+}\n+\n+bool java_lang_String::deduplication_forbidden(oop java_string) {\n+  return is_flag_set(java_string, _deduplication_forbidden_mask);\n+}\n+\n+bool java_lang_String::deduplication_requested(oop java_string) {\n+  return is_flag_set(java_string, _deduplication_requested_mask);\n+}\n+\n+void java_lang_String::set_deduplication_forbidden(oop java_string) {\n+  test_and_set_flag(java_string, _deduplication_forbidden_mask);\n+}\n+\n+bool java_lang_String::test_and_set_deduplication_requested(oop java_string) {\n+  return test_and_set_flag(java_string, _deduplication_requested_mask);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -349,5 +349,0 @@\n-  \/\/ Deduplicate the string before it is interned. Note that we should never\n-  \/\/ deduplicate a string after it has been interned. Doing so will counteract\n-  \/\/ compiler optimizations done on e.g. interned string literals.\n-  Universe::heap()->deduplicate_string(string_h());\n-\n@@ -358,0 +353,7 @@\n+  \/\/ Notify deduplication support that the string is being interned.  A string\n+  \/\/ must never be deduplicated after it has been interned.  Doing so interferes\n+  \/\/ with compiler optimizations done on e.g. interned string literals.\n+  if (StringDedup::is_enabled()) {\n+    StringDedup::notify_intern(string_h());\n+  }\n+\n@@ -703,0 +705,4 @@\n+size_t StringTable::shared_entry_count() {\n+  return _shared_table.entry_count();\n+}\n+\n@@ -709,0 +715,4 @@\n+oop StringTable::lookup_shared(const jchar* name, int len) {\n+  return _shared_table.lookup(name, java_lang_String::hash_code(name, len), len);\n+}\n+\n@@ -727,0 +737,4 @@\n+  \/\/ Prevent string deduplication from changing the 'value' field to\n+  \/\/ something not in the archive before building the archive.  Also marks\n+  \/\/ the shared string when loaded.\n+  java_lang_String::set_deduplication_forbidden(new_s);\n@@ -772,13 +786,0 @@\n-class SharedStringIterator {\n-  OopClosure* _oop_closure;\n-public:\n-  SharedStringIterator(OopClosure* f) : _oop_closure(f) {}\n-  void do_value(oop string) {\n-    _oop_closure->do_oop(&string);\n-  }\n-};\n-\n-void StringTable::shared_oops_do(OopClosure* f) {\n-  SharedStringIterator iter(f);\n-  _shared_table.iterate(&iter);\n-}\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -110,0 +110,2 @@\n+  static oop lookup_shared(const jchar* name, int len) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static size_t shared_entry_count() NOT_CDS_JAVA_HEAP_RETURN_(0);\n@@ -111,1 +113,0 @@\n-  static void shared_oops_do(OopClosure* f) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -1709,2 +1708,0 @@\n-  G1StringDedup::initialize();\n-\n@@ -1727,3 +1724,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::stop();\n-  }\n@@ -2312,8 +2306,0 @@\n-void G1CollectedHeap::deduplicate_string(oop str) {\n-  assert(java_lang_String::is_instance(str), \"invariant\");\n-\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::deduplicate(str);\n-  }\n-}\n-\n@@ -2440,3 +2426,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::threads_do(tc);\n-  }\n@@ -3092,1 +3075,1 @@\n-  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred, false);\n+  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred);\n@@ -3096,45 +3079,0 @@\n-\/\/ Clean string dedup data structures.\n-\/\/ Ideally we would prefer to use a StringDedupCleaningTask here, but we want to\n-\/\/ record the durations of the phases. Hence the almost-copy.\n-class G1StringDedupCleaningTask : public AbstractGangTask {\n-  BoolObjectClosure* _is_alive;\n-  OopClosure* _keep_alive;\n-  G1GCPhaseTimes* _phase_times;\n-\n-public:\n-  G1StringDedupCleaningTask(BoolObjectClosure* is_alive,\n-                            OopClosure* keep_alive,\n-                            G1GCPhaseTimes* phase_times) :\n-    AbstractGangTask(\"Partial Cleaning Task\"),\n-    _is_alive(is_alive),\n-    _keep_alive(keep_alive),\n-    _phase_times(phase_times)\n-  {\n-    assert(G1StringDedup::is_enabled(), \"String deduplication disabled.\");\n-    StringDedup::gc_prologue(true);\n-  }\n-\n-  ~G1StringDedupCleaningTask() {\n-    StringDedup::gc_epilogue();\n-  }\n-\n-  void work(uint worker_id) {\n-    StringDedupUnlinkOrOopsDoClosure cl(_is_alive, _keep_alive);\n-    {\n-      G1GCParPhaseTimesTracker x(_phase_times, G1GCPhaseTimes::StringDedupQueueFixup, worker_id);\n-      StringDedupQueue::unlink_or_oops_do(&cl);\n-    }\n-    {\n-      G1GCParPhaseTimesTracker x(_phase_times, G1GCPhaseTimes::StringDedupTableFixup, worker_id);\n-      StringDedupTable::unlink_or_oops_do(&cl, worker_id);\n-    }\n-  }\n-};\n-\n-void G1CollectedHeap::string_dedup_cleaning(BoolObjectClosure* is_alive,\n-                                            OopClosure* keep_alive,\n-                                            G1GCPhaseTimes* phase_times) {\n-  G1StringDedupCleaningTask cl(is_alive, keep_alive, phase_times);\n-  workers()->run_task(&cl);\n-}\n-\n@@ -3848,9 +3786,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    double string_dedup_time_ms = os::elapsedTime();\n-\n-    string_dedup_cleaning(&is_alive, &keep_alive, p);\n-\n-    double string_cleanup_time_ms = (os::elapsedTime() - string_dedup_time_ms) * 1000.0;\n-    p->record_string_deduplication_time(string_cleanup_time_ms);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":72,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1404,5 +1404,0 @@\n-  \/\/ Partial cleaning of VM internal data structures.\n-  void string_dedup_cleaning(BoolObjectClosure* is_alive,\n-                             OopClosure* keep_alive,\n-                             G1GCPhaseTimes* phase_times = NULL);\n-\n@@ -1414,3 +1409,0 @@\n-  \/\/ Deduplicate the string\n-  virtual void deduplicate_string(oop str);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -1533,2 +1532,0 @@\n-  \/\/ Inner scope to exclude the cleaning of the string table\n-  \/\/ from the displayed time.\n@@ -1633,3 +1630,0 @@\n-  } else if (StringDedup::is_enabled()) {\n-    GCTraceTime(Debug, gc, phases) debug(\"String Deduplication\", _gc_timer_cm);\n-    _g1h->string_dedup_cleaning(&g1_is_alive, NULL);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -274,4 +273,0 @@\n-  } else if (G1StringDedup::is_enabled()) {\n-    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: String Dedup Cleanup\", scope()->timer());\n-    \/\/ If no class unloading just clean out string deduplication data.\n-    _heap->string_dedup_cleaning(&_is_alive, NULL);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,2 +87,1 @@\n-    _adjust(collector),\n-    _string_dedup_cleaning_task(NULL, &_adjust, false) {\n+    _adjust(collector) {\n@@ -113,3 +112,0 @@\n-  \/\/ Adjust string dedup data structures.\n-  _string_dedup_cleaning_task.work(worker_id);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"gc\/shared\/parallelCleaning.hpp\"\n@@ -45,1 +43,0 @@\n-  StringDedupCleaningTask  _string_dedup_cleaning_task;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -62,4 +63,5 @@\n-  G1MarkAndPushClosure _mark_closure;\n-  G1VerifyOopClosure   _verify_closure;\n-  G1FollowStackClosure _stack_closure;\n-  CLDToOopClosure      _cld_closure;\n+  G1MarkAndPushClosure  _mark_closure;\n+  G1VerifyOopClosure    _verify_closure;\n+  G1FollowStackClosure  _stack_closure;\n+  CLDToOopClosure       _cld_closure;\n+  StringDedup::Requests _string_dedup_requests;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/g1\/g1StringDedupQueue.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -65,3 +65,4 @@\n-  if (G1StringDedup::is_enabled() &&\n-      java_lang_String::is_instance_inlined(obj)) {\n-    G1StringDedup::enqueue_from_mark(obj, _worker_id);\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance_inlined(obj) &&\n+      G1StringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests.add(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -142,8 +141,0 @@\n-  if (UseStringDeduplication) {\n-    _gc_par_phases[StringDedupQueueFixup] = new WorkerDataArray<double>(\"StringDedupQueueFixup\", \"Queue Fixup (ms):\", max_gc_threads);\n-    _gc_par_phases[StringDedupTableFixup] = new WorkerDataArray<double>(\"StringDedupTableFixup\", \"Table Fixup (ms):\", max_gc_threads);\n-  } else {\n-    _gc_par_phases[StringDedupQueueFixup] = NULL;\n-    _gc_par_phases[StringDedupTableFixup] = NULL;\n-  }\n-\n@@ -169,1 +160,0 @@\n-  _cur_string_deduplication_time_ms = 0.0;\n@@ -462,1 +452,0 @@\n-                        _cur_string_deduplication_time_ms +\n@@ -478,6 +467,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    debug_time(\"String Deduplication\", _cur_string_deduplication_time_ms);\n-    debug_phase(_gc_par_phases[StringDedupQueueFixup], 1);\n-    debug_phase(_gc_par_phases[StringDedupTableFixup], 1);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-    StringDedupQueueFixup,\n-    StringDedupTableFixup,\n@@ -149,2 +147,0 @@\n-  double _cur_string_deduplication_time_ms;\n-\n@@ -296,4 +292,0 @@\n-  void record_string_deduplication_time(double ms) {\n-    _cur_string_deduplication_time_ms = ms;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -521,5 +520,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    log_debug(gc, verify)(\"StrDedup\");\n-    G1StringDedup::verify();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/vmClasses.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -79,3 +79,1 @@\n-    _string_klass_or_null(G1StringDedup::is_enabled()\n-                          ? vmClasses::String_klass()\n-                          : nullptr),\n+    _string_dedup_requests(),\n@@ -86,4 +84,0 @@\n-  \/\/ Verify klass comparison with _string_klass_or_null is sufficient\n-  \/\/ to determine whether dedup is enabled and the object is a String.\n-  assert(vmClasses::String_klass()->is_final(), \"precondition\");\n-\n@@ -520,14 +514,8 @@\n-    \/\/ StringDedup::is_enabled() and java_lang_String::is_instance_inline\n-    \/\/ test of the obj, combined into a single comparison, using the klass\n-    \/\/ already in hand and avoiding the null check in is_instance.\n-    if (klass == _string_klass_or_null) {\n-      const bool is_from_young = region_attr.is_young();\n-      const bool is_to_young = dest_attr.is_young();\n-      assert(is_from_young == from_region->is_young(),\n-             \"sanity\");\n-      assert(is_to_young == _g1h->heap_region_containing(obj)->is_young(),\n-             \"sanity\");\n-      G1StringDedup::enqueue_from_evacuation(is_from_young,\n-                                             is_to_young,\n-                                             _worker_id,\n-                                             obj);\n+    \/\/ Check for deduplicating young Strings.\n+    if (G1StringDedup::is_candidate_from_evacuation(klass,\n+                                                    region_attr,\n+                                                    dest_attr,\n+                                                    age)) {\n+      \/\/ Record old; request adds a new weak reference, which reference\n+      \/\/ processing expects to refer to a from-space object.\n+      _string_dedup_requests.add(old);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -45,1 +46,0 @@\n-class Klass;\n@@ -87,2 +87,1 @@\n-  \/\/ Used to check whether string dedup should be applied to an object.\n-  Klass* _string_klass_or_null;\n+  StringDedup::Requests _string_dedup_requests;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,1 @@\n-                                               bool unloading_occurred,\n-                                               bool resize_dedup_table) :\n+                                               bool unloading_occurred) :\n@@ -60,1 +59,0 @@\n-  _string_dedup_task(is_alive, NULL, resize_dedup_table),\n@@ -75,3 +73,0 @@\n-  \/\/ Clean the string dedup data structures.\n-  _string_dedup_task.work(worker_id);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-  StringDedupCleaningTask _string_dedup_task;\n@@ -60,2 +59,1 @@\n-                         bool unloading_occurred,\n-                         bool resize_dedup_table);\n+                         bool unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,1 +27,0 @@\n-#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n@@ -30,6 +28,1 @@\n-#include \"gc\/g1\/g1StringDedupQueue.hpp\"\n-#include \"gc\/g1\/g1StringDedupStat.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedup.inline.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupTable.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupThread.inline.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -38,7 +31,1 @@\n-void G1StringDedup::initialize() {\n-  assert(UseG1GC, \"String deduplication available with G1\");\n-  StringDedup::initialize_impl<G1StringDedupQueue, G1StringDedupStat>();\n-}\n-\n-bool G1StringDedup::is_candidate_from_mark(oop obj) {\n-  bool from_young = G1CollectedHeap::heap()->heap_region_containing(obj)->is_young();\n+bool G1StringDedup::is_candidate_from_mark(oop java_string) {\n@@ -48,36 +35,2 @@\n-  return from_young && (obj->age() < StringDeduplicationAgeThreshold);\n-}\n-\n-void G1StringDedup::enqueue_from_mark(oop java_string, uint worker_id) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  assert(java_lang_String::is_instance(java_string), \"not a String\");\n-  if (is_candidate_from_mark(java_string)) {\n-    G1StringDedupQueue::push(worker_id, java_string);\n-  }\n-}\n-\n-bool G1StringDedup::is_candidate_from_evacuation(bool from_young, bool to_young, oop obj) {\n-  if (from_young) {\n-    if (to_young && obj->age() == StringDeduplicationAgeThreshold) {\n-      \/\/ Candidate found. String is being evacuated from young to young and just\n-      \/\/ reached the deduplication age threshold.\n-      return true;\n-    }\n-    if (!to_young && obj->age() < StringDeduplicationAgeThreshold) {\n-      \/\/ Candidate found. String is being evacuated from young to old but has not\n-      \/\/ reached the deduplication age threshold, i.e. has not previously been a\n-      \/\/ candidate during its life in the young generation.\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Not a candidate\n-  return false;\n-}\n-\n-void G1StringDedup::enqueue_from_evacuation(bool from_young, bool to_young, uint worker_id, oop java_string) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  assert(java_lang_String::is_instance(java_string), \"not a String\");\n-  if (is_candidate_from_evacuation(from_young, to_young, java_string)) {\n-    G1StringDedupQueue::push(worker_id, java_string);\n-  }\n+  return G1CollectedHeap::heap()->heap_region_containing(java_string)->is_young() &&\n+         StringDedup::is_below_threshold_age(java_string->age());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1StringDedup.cpp","additions":5,"deletions":52,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+#include \"gc\/g1\/g1HeapRegionAttr.hpp\"\n@@ -52,18 +53,2 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-class OopClosure;\n-class BoolObjectClosure;\n-class G1GCPhaseTimes;\n-class G1StringDedupUnlinkOrOopsDoClosure;\n-\n-\/\/\n-\/\/ G1 interface for interacting with string deduplication.\n-\/\/\n-class G1StringDedup : public StringDedup {\n-private:\n-\n-  \/\/ Candidate selection policies, returns true if the given object is\n-  \/\/ candidate for string deduplication.\n-  static bool is_candidate_from_mark(oop java_string);\n-  static bool is_candidate_from_evacuation(bool from_young, bool to_young, oop java_string);\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -71,0 +56,1 @@\n+class G1StringDedup : AllStatic {\n@@ -72,2 +58,5 @@\n-  \/\/ Initialize string deduplication.\n-  static void initialize();\n+  \/\/ Candidate selection policy for full GC, returning true if the given\n+  \/\/ String is a candidate for string deduplication.\n+  \/\/ precondition: StringDedup::is_enabled()\n+  \/\/ precondition: java_string is a Java String\n+  static bool is_candidate_from_mark(oop java_string);\n@@ -75,7 +64,13 @@\n-  \/\/ Enqueues a deduplication candidate for later processing by the deduplication\n-  \/\/ thread. Before enqueuing, these functions apply the appropriate candidate\n-  \/\/ selection policy to filters out non-candidates.\n-  \/\/ Precondition for both is that java_string is a String.\n-  static void enqueue_from_mark(oop java_string, uint worker_id);\n-  static void enqueue_from_evacuation(bool from_young, bool to_young,\n-                                      unsigned int queue, oop java_string);\n+  \/\/ Candidate selection policy for young\/mixed GC.\n+  \/\/ If to is young then age should be the new (survivor's) age.\n+  \/\/ if to is old then age should be the age of the copied from object.\n+  static bool is_candidate_from_evacuation(const Klass* klass,\n+                                           G1HeapRegionAttr from,\n+                                           G1HeapRegionAttr to,\n+                                           uint age) {\n+    return StringDedup::is_enabled_string(klass) &&\n+           from.is_young() &&\n+           (to.is_young() ?\n+            StringDedup::is_threshold_age(age) :\n+            StringDedup::is_below_threshold_age(age));\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1StringDedup.hpp","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n-#include \"gc\/g1\/g1StringDedupQueue.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/safepointVerifiers.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-\n-const size_t        G1StringDedupQueue::_max_size = 1000000; \/\/ Max number of elements per queue\n-const size_t        G1StringDedupQueue::_max_cache_size = 0; \/\/ Max cache size per queue\n-\n-G1StringDedupQueue::G1StringDedupQueue() :\n-  _cursor(0),\n-  _cancel(false),\n-  _empty(true),\n-  _dropped(0) {\n-  _nqueues = ParallelGCThreads;\n-  _queues = NEW_C_HEAP_ARRAY(G1StringDedupWorkerQueue, _nqueues, mtGC);\n-  for (size_t i = 0; i < _nqueues; i++) {\n-    new (_queues + i) G1StringDedupWorkerQueue(G1StringDedupWorkerQueue::default_segment_size(), _max_cache_size, _max_size);\n-  }\n-}\n-\n-G1StringDedupQueue::~G1StringDedupQueue() {\n-  ShouldNotReachHere();\n-}\n-\n-void G1StringDedupQueue::wait_impl() {\n-  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-  while (_empty && !_cancel) {\n-    ml.wait();\n-  }\n-}\n-\n-void G1StringDedupQueue::cancel_wait_impl() {\n-  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-  _cancel = true;\n-  ml.notify();\n-}\n-\n-void G1StringDedupQueue::push_impl(uint worker_id, oop java_string) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at safepoint\");\n-  assert(worker_id < _nqueues, \"Invalid queue\");\n-\n-  \/\/ Push and notify waiter\n-  G1StringDedupWorkerQueue& worker_queue = _queues[worker_id];\n-  if (!worker_queue.is_full()) {\n-    worker_queue.push(java_string);\n-    if (_empty) {\n-      MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-      if (_empty) {\n-        \/\/ Mark non-empty and notify waiter\n-        _empty = false;\n-        ml.notify();\n-      }\n-    }\n-  } else {\n-    \/\/ Queue is full, drop the string and update the statistics\n-    Atomic::inc(&_dropped);\n-  }\n-}\n-\n-oop G1StringDedupQueue::pop_impl() {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"Must not be at safepoint\");\n-  NoSafepointVerifier nsv;\n-\n-  \/\/ Try all queues before giving up\n-  for (size_t tries = 0; tries < _nqueues; tries++) {\n-    \/\/ The cursor indicates where we left of last time\n-    G1StringDedupWorkerQueue* queue = &_queues[_cursor];\n-    while (!queue->is_empty()) {\n-      oop obj = queue->pop();\n-      \/\/ The oop we pop can be NULL if it was marked\n-      \/\/ dead. Just ignore those and pop the next oop.\n-      if (obj != NULL) {\n-        return obj;\n-      }\n-    }\n-\n-    \/\/ Try next queue\n-    _cursor = (_cursor + 1) % _nqueues;\n-  }\n-\n-  \/\/ Mark empty\n-  _empty = true;\n-\n-  return NULL;\n-}\n-\n-void G1StringDedupQueue::unlink_or_oops_do_impl(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue) {\n-  assert(queue < _nqueues, \"Invalid queue\");\n-  StackIterator<oop, mtGC> iter(_queues[queue]);\n-  while (!iter.is_empty()) {\n-    oop* p = iter.next_addr();\n-    if (*p != NULL) {\n-      if (cl->is_alive(*p)) {\n-        cl->keep_alive(p);\n-      } else {\n-        \/\/ Clear dead reference\n-        *p = NULL;\n-      }\n-    }\n-  }\n-}\n-\n-void G1StringDedupQueue::print_statistics_impl() {\n-  log_debug(gc, stringdedup)(\"  Queue\");\n-  log_debug(gc, stringdedup)(\"    Dropped: \" UINTX_FORMAT, _dropped);\n-}\n-\n-void G1StringDedupQueue::verify_impl() {\n-  for (size_t i = 0; i < _nqueues; i++) {\n-    StackIterator<oop, mtGC> iter(_queues[i]);\n-    while (!iter.is_empty()) {\n-      oop obj = iter.next();\n-      if (obj != NULL) {\n-        guarantee(G1CollectedHeap::heap()->is_in_reserved(obj), \"Object must be on the heap\");\n-        guarantee(!obj->is_forwarded(), \"Object must not be forwarded\");\n-        guarantee(java_lang_String::is_instance(obj), \"Object must be a String\");\n-      }\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1StringDedupQueue.cpp","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1STRINGDEDUPQUEUE_HPP\n-#define SHARE_GC_G1_G1STRINGDEDUPQUEUE_HPP\n-\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"utilities\/stack.hpp\"\n-\n-class StringDedupUnlinkOrOopsDoClosure;\n-\n-\/\/\n-\/\/ G1 enqueues candidates during the stop-the-world mark\/evacuation phase.\n-\/\/\n-\n-class G1StringDedupQueue : public StringDedupQueue {\n-private:\n-  typedef Stack<oop, mtGC> G1StringDedupWorkerQueue;\n-\n-  static const size_t        _max_size;\n-  static const size_t        _max_cache_size;\n-\n-  G1StringDedupWorkerQueue*  _queues;\n-  size_t                     _nqueues;\n-  size_t                     _cursor;\n-  bool                       _cancel;\n-  volatile bool              _empty;\n-\n-  \/\/ Statistics counter, only used for logging.\n-  uintx                      _dropped;\n-\n-  ~G1StringDedupQueue();\n-\n-  void unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue);\n-\n-public:\n-  G1StringDedupQueue();\n-\n-protected:\n-\n-  \/\/ Blocks and waits for the queue to become non-empty.\n-  void wait_impl();\n-\n-  \/\/ Wakes up any thread blocked waiting for the queue to become non-empty.\n-  void cancel_wait_impl();\n-\n-  \/\/ Pushes a deduplication candidate onto a specific GC worker queue.\n-  void push_impl(uint worker_id, oop java_string);\n-\n-  \/\/ Pops a deduplication candidate from any queue, returns NULL if\n-  \/\/ all queues are empty.\n-  oop pop_impl();\n-\n-  size_t num_queues() const {\n-    return _nqueues;\n-  }\n-\n-  void unlink_or_oops_do_impl(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue);\n-\n-  void print_statistics_impl();\n-  void verify_impl();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1STRINGDEDUPQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1StringDedupQueue.hpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1StringDedupStat.hpp\"\n-#include \"logging\/log.hpp\"\n-\n-G1StringDedupStat::G1StringDedupStat() : StringDedupStat(),\n-  _deduped_young(0),\n-  _deduped_young_bytes(0),\n-  _deduped_old(0),\n-  _deduped_old_bytes(0),\n-  _heap(G1CollectedHeap::heap()) {\n-}\n-\n-\n-\n-void G1StringDedupStat::deduped(oop obj, uintx bytes) {\n-  StringDedupStat::deduped(obj, bytes);\n-  if (_heap->is_in_young(obj)) {\n-    _deduped_young ++;\n-    _deduped_young_bytes += bytes;\n-  } else {\n-    _deduped_old ++;\n-    _deduped_old_bytes += bytes;\n-  }\n-}\n-\n-void G1StringDedupStat::add(const StringDedupStat* const stat) {\n-  StringDedupStat::add(stat);\n-  const G1StringDedupStat* const g1_stat = (const G1StringDedupStat* const)stat;\n-  _deduped_young += g1_stat->_deduped_young;\n-  _deduped_young_bytes += g1_stat->_deduped_young_bytes;\n-  _deduped_old += g1_stat->_deduped_old;\n-  _deduped_old_bytes += g1_stat->_deduped_old_bytes;\n-}\n-\n-void G1StringDedupStat::print_statistics(bool total) const {\n-  StringDedupStat::print_statistics(total);\n-\n-  double deduped_young_percent       = percent_of(_deduped_young, _deduped);\n-  double deduped_young_bytes_percent = percent_of(_deduped_young_bytes, _deduped_bytes);\n-  double deduped_old_percent         = percent_of(_deduped_old, _deduped);\n-  double deduped_old_bytes_percent   = percent_of(_deduped_old_bytes, _deduped_bytes);\n-\n-  log_debug(gc, stringdedup)(\"      Young:      \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \") \" STRDEDUP_BYTES_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \")\",\n-                             _deduped_young, deduped_young_percent, STRDEDUP_BYTES_PARAM(_deduped_young_bytes), deduped_young_bytes_percent);\n-  log_debug(gc, stringdedup)(\"      Old:        \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \") \" STRDEDUP_BYTES_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \")\",\n-                             _deduped_old, deduped_old_percent, STRDEDUP_BYTES_PARAM(_deduped_old_bytes), deduped_old_bytes_percent);\n-\n-}\n-\n-void G1StringDedupStat::reset() {\n-  StringDedupStat::reset();\n-  _deduped_young = 0;\n-  _deduped_young_bytes = 0;\n-  _deduped_old = 0;\n-  _deduped_old_bytes = 0;\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1StringDedupStat.cpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1STRINGDEDUPSTAT_HPP\n-#define SHARE_GC_G1_G1STRINGDEDUPSTAT_HPP\n-\n-#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n-\n-\/\/ G1 extension for gathering\/reporting generational statistics\n-class G1StringDedupStat : public StringDedupStat {\n-private:\n-  uintx  _deduped_young;\n-  uintx  _deduped_young_bytes;\n-  uintx  _deduped_old;\n-  uintx  _deduped_old_bytes;\n-\n-  G1CollectedHeap* const _heap;\n-\n-public:\n-  G1StringDedupStat();\n-\n-  void deduped(oop obj, uintx bytes);\n-\n-  void add(const StringDedupStat* const stat);\n-\n-  void print_statistics(bool total) const;\n-\n-  void reset();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1STRINGDEDUPSTAT_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1StringDedupStat.hpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -585,0 +586,1 @@\n+  StringDedup::initialize();\n@@ -640,4 +642,0 @@\n-void CollectedHeap::deduplicate_string(oop str) {\n-  \/\/ Do nothing, unless overridden in subclass.\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -484,3 +484,0 @@\n-  \/\/ Deduplicate the string, iff the GC supports string deduplication.\n-  virtual void deduplicate_string(oop str);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-          \"codecache_oops\")                                                 \\\n+          \"codecache_oops, resolved_method_table, stringdedup\")             \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  static const uint weak_count = 5 JVMTI_ONLY(+ 1) JFR_ONLY(+ 1);\n+  static const uint weak_count = 8 JVMTI_ONLY(+ 1) JFR_ONLY(+ 1);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,23 +35,0 @@\n-StringDedupCleaningTask::StringDedupCleaningTask(BoolObjectClosure* is_alive,\n-                                                 OopClosure* keep_alive,\n-                                                 bool resize_table) :\n-  AbstractGangTask(\"String Dedup Cleaning\"),\n-  _dedup_closure(is_alive, keep_alive) {\n-\n-  if (StringDedup::is_enabled()) {\n-    StringDedup::gc_prologue(resize_table);\n-  }\n-}\n-\n-StringDedupCleaningTask::~StringDedupCleaningTask() {\n-  if (StringDedup::is_enabled()) {\n-    StringDedup::gc_epilogue();\n-  }\n-}\n-\n-void StringDedupCleaningTask::work(uint worker_id) {\n-  if (StringDedup::is_enabled()) {\n-    StringDedup::parallel_unlink(&_dedup_closure, worker_id);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -34,10 +33,0 @@\n-class StringDedupCleaningTask : public AbstractGangTask {\n-  StringDedupUnlinkOrOopsDoClosure _dedup_closure;\n-\n-public:\n-  StringDedupCleaningTask(BoolObjectClosure* is_alive, OopClosure* keep_alive, bool resize_table);\n-  ~StringDedupCleaningTask();\n-\n-  void work(uint worker_id);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-#include \"precompiled.hpp\"\n@@ -26,0 +25,7 @@\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -27,1 +33,4 @@\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupConfig.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupProcessor.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStorageUse.hpp\"\n@@ -29,1 +38,2 @@\n-#include \"gc\/shared\/stringdedup\/stringDedupThread.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -31,0 +41,10 @@\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,0 +52,1 @@\n+bool StringDedup::_initialized = false;\n@@ -34,4 +55,7 @@\n-void StringDedup::gc_prologue(bool resize_and_rehash_table) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupQueue::gc_prologue();\n-  StringDedupTable::gc_prologue(resize_and_rehash_table);\n+StringDedup::Processor* StringDedup::_processor = nullptr;\n+StringDedup::Stat StringDedup::_cur_stat{};\n+StringDedup::Stat StringDedup::_total_stat{};\n+\n+const Klass* StringDedup::_string_klass_or_null = nullptr;\n+uint StringDedup::_enabled_age_threshold = 0;\n+uint StringDedup::_enabled_age_limit = 0;\n@@ -39,0 +63,2 @@\n+bool StringDedup::ergo_initialize() {\n+  return Config::ergo_initialize();\n@@ -40,4 +66,30 @@\n-void StringDedup::gc_epilogue() {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupQueue::gc_epilogue();\n-  StringDedupTable::gc_epilogue();\n+\n+void StringDedup::initialize() {\n+  assert(!_initialized, \"already initialized\");\n+  \/\/ Unconditionally create the oopstorage objects, to simplify usage\n+  \/\/ elsewhere. OopStorageSet and clients don't support optional oopstorage\n+  \/\/ objects.\n+  Table::initialize_storage();\n+  Processor::initialize_storage();\n+  if (UseStringDeduplication) {\n+    Config::initialize();\n+    \/\/ Verify klass comparison with _string_klass_or_null is sufficient\n+    \/\/ to determine whether dedup is enabled and the object is a String.\n+    assert(vmClasses::String_klass()->is_final(), \"precondition\");\n+    _string_klass_or_null = vmClasses::String_klass();\n+    _enabled_age_threshold = Config::age_threshold();\n+    _enabled_age_limit = Config::age_threshold();\n+    Table::initialize();\n+    Processor::initialize();\n+    _enabled = true;\n+    log_info_p(stringdedup, init)(\"String Deduplication is enabled\");\n+  } else {\n+    \/\/ No klass will ever match.\n+    _string_klass_or_null = nullptr;\n+    \/\/ Age can never equal UINT_MAX.\n+    static_assert(markWord::max_age < UINT_MAX, \"assumption\");\n+    _enabled_age_threshold = UINT_MAX;\n+    \/\/ Age can never be less than zero.\n+    _enabled_age_limit = 0;\n+  }\n+  _initialized = true;\n@@ -47,2 +99,3 @@\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupThread::thread()->stop();\n+  assert(is_enabled(), \"precondition\");\n+  assert(_processor != nullptr, \"invariant\");\n+  _processor->stop();\n@@ -51,4 +104,4 @@\n-void StringDedup::deduplicate(oop java_string) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupStat dummy; \/\/ Statistics from this path is never used\n-  StringDedupTable::deduplicate(java_string, &dummy);\n+void StringDedup::threads_do(ThreadClosure* tc) {\n+  assert(is_enabled(), \"precondition\");\n+  assert(_processor != nullptr, \"invariant\");\n+  tc->do_thread(_processor);\n@@ -57,4 +110,18 @@\n-void StringDedup::parallel_unlink(StringDedupUnlinkOrOopsDoClosure* unlink, uint worker_id) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupQueue::unlink_or_oops_do(unlink);\n-  StringDedupTable::unlink_or_oops_do(unlink, worker_id);\n+void StringDedup::notify_intern(oop java_string) {\n+  assert(is_enabled(), \"precondition\");\n+  \/\/ A String that is interned in the StringTable must not later have its\n+  \/\/ underlying byte array changed, so mark it as not deduplicatable.  But we\n+  \/\/ can still add the byte array to the dedup table for sharing, so add the\n+  \/\/ string to the pending requests.  Triggering request processing is left\n+  \/\/ to the next GC.\n+  {\n+    MutexLocker ml(StringDedupIntern_lock, Mutex::_no_safepoint_check_flag);\n+    java_lang_String::set_deduplication_forbidden(java_string);\n+  }\n+  StorageUse* requests = Processor::storage_for_requests();\n+  oop* ref = requests->storage()->allocate();\n+  if (ref != nullptr) {\n+    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(ref, java_string);\n+    log_trace(stringdedup)(\"StringDedup::deduplicate\");\n+  }\n+  requests->relinquish();\n@@ -63,3 +130,6 @@\n-void StringDedup::threads_do(ThreadClosure* tc) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  tc->do_thread(StringDedupThread::thread());\n+StringDedup::Requests::Requests() :\n+  _storage_for_requests(nullptr), _buffer(nullptr), _index(0), _refill_failed(false)\n+{}\n+\n+StringDedup::Requests::~Requests() {\n+  flush();\n@@ -68,4 +138,40 @@\n-void StringDedup::verify() {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupQueue::verify();\n-  StringDedupTable::verify();\n+bool StringDedup::Requests::refill_buffer() {\n+  assert(_index == 0, \"precondition\");\n+  \/\/ Treat out of memory failure as sticky; don't keep retrying.\n+  if (_refill_failed) return false;\n+  \/\/ Lazy initialization of the requests object.  It can be common for\n+  \/\/ many of the marking threads to not encounter any candidates.\n+  const size_t buffer_size = OopStorage::bulk_allocate_limit;\n+  if (_buffer == nullptr) {\n+    \/\/ Lazily allocate a buffer to hold pre-allocated storage entries.\n+    _buffer = NEW_C_HEAP_ARRAY_RETURN_NULL(oop*, buffer_size, mtStringDedup);\n+    if (_buffer == nullptr) {\n+      log_debug(stringdedup)(\"request failed to allocate buffer\");\n+      _refill_failed = true;\n+      return false;\n+    }\n+    \/\/ Lazily obtain the storage object to use for requests.\n+    assert(_storage_for_requests == nullptr, \"invariant\");\n+    _storage_for_requests = Processor::storage_for_requests();\n+  }\n+  assert(_storage_for_requests != nullptr, \"invariant\");\n+  \/\/ Bulk pre-allocate some storage entries to satisfy this and future\n+  \/\/ requests.  This amortizes the cost of allocating entries over\n+  \/\/ multiple requests, and reduces contention on the storage object.\n+  _index = _storage_for_requests->storage()->allocate(_buffer, buffer_size);\n+  if (_index == 0) {\n+    log_debug(stringdedup)(\"request failed to allocate oopstorage entries\");\n+    flush();\n+    _refill_failed = true;\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void StringDedup::Requests::add(oop java_string) {\n+  assert(is_enabled(), \"StringDedup not enabled\");\n+  if ((_index == 0) && !refill_buffer()) return;\n+  \/\/ Store the string in the next pre-allocated storage entry.\n+  oop* ref = _buffer[--_index];\n+  NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(ref, java_string);\n+  log_trace(stringdedup)(\"request\");\n@@ -74,0 +180,16 @@\n+void StringDedup::Requests::flush() {\n+  if (_buffer != nullptr) {\n+    if (_index > 0) {\n+      assert(_storage_for_requests != nullptr, \"invariant\");\n+      _storage_for_requests->storage()->release(_buffer, _index);\n+    }\n+    FREE_C_HEAP_ARRAY(oop*, _buffer);\n+    _buffer = nullptr;\n+  }\n+  if (_storage_for_requests != nullptr) {\n+    _storage_for_requests->relinquish();\n+    _storage_for_requests = nullptr;\n+  }\n+  _index = 0;\n+  _refill_failed = false;\n+}\n@@ -75,6 +197,5 @@\n-StringDedupUnlinkOrOopsDoClosure::StringDedupUnlinkOrOopsDoClosure(BoolObjectClosure* is_alive,\n-                                                                   OopClosure* keep_alive) :\n-  _always_true(),\n-  _do_nothing(),\n-  _is_alive(is_alive != NULL ? is_alive : &_always_true),\n-  _keep_alive(keep_alive != NULL ? keep_alive : &_do_nothing) {\n+void StringDedup::verify() {\n+  assert_at_safepoint();\n+  if (is_enabled()) {\n+    Table::verify();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.cpp","additions":156,"deletions":35,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\/\/\n@@ -31,2 +30,15 @@\n-\/\/ String deduplication aims to reduce the heap live-set by deduplicating identical\n-\/\/ instances of String so that they share the same backing character array.\n+\/\/ String deduplication aims to reduce the heap live-set by modifying equal\n+\/\/ instances of java.lang.String so they share the same backing byte array\n+\/\/ (the String's value).\n+\/\/\n+\/\/ The deduplication process is divided in two main parts, 1) finding the\n+\/\/ objects to deduplicate, and 2) deduplicating those objects.\n+\/\/\n+\/\/ The first part is done as part of a normal GC cycle when objects are\n+\/\/ marked or evacuated. At this time a check is applied on each object to\n+\/\/ determine whether it is a candidate for deduplication.  Candidates are\n+\/\/ added to the set of deduplication requests for later processing.\n+\/\/\n+\/\/ The second part, processing the deduplication requests, is a concurrent\n+\/\/ phase.  This phase is executed by the deduplication thread, which takes\n+\/\/ candidates from the set of requests and tries to deduplicate them.\n@@ -34,9 +46,8 @@\n-\/\/ The deduplication process is divided in two main parts, 1) finding the objects to\n-\/\/ deduplicate, and 2) deduplicating those objects. The first part is done as part of\n-\/\/ a normal GC cycle when objects are marked or evacuated. At this time a check is\n-\/\/ applied on each object to check if it is a candidate for deduplication. If so, the\n-\/\/ object is placed on the deduplication queue for later processing. The second part,\n-\/\/ processing the objects on the deduplication queue, is a concurrent phase which\n-\/\/ starts right after the stop-the-wold marking\/evacuation phase. This phase is\n-\/\/ executed by the deduplication thread, which pulls deduplication candidates of the\n-\/\/ deduplication queue and tries to deduplicate them.\n+\/\/ A deduplication table is used to keep track of unique byte arrays used by\n+\/\/ String objects.  When deduplicating, a lookup is made in this table to\n+\/\/ see if there is already an equivalent byte array that was used by some\n+\/\/ other String.  If so, the String object is adjusted to point to that byte\n+\/\/ array, and the original array is released, allowing it to eventually be\n+\/\/ garbage collected.  If the lookup fails the byte array is instead\n+\/\/ inserted into the table so it can potentially be shared with other\n+\/\/ Strings in the future.\n@@ -44,7 +55,9 @@\n-\/\/ A deduplication hashtable is used to keep track of all unique character arrays\n-\/\/ used by String objects. When deduplicating, a lookup is made in this table to see\n-\/\/ if there is already an identical character array somewhere on the heap. If so, the\n-\/\/ String object is adjusted to point to that character array, releasing the reference\n-\/\/ to the original array allowing it to eventually be garbage collected. If the lookup\n-\/\/ fails the character array is instead inserted into the hashtable so that this array\n-\/\/ can be shared at some point in the future.\n+\/\/ The set of requests uses entries from a pair of weak OopStorage objects.\n+\/\/ One is used for requests, the other is being processed.  When processing\n+\/\/ completes, the roles of the storage objects are exchanged.  The GC adds\n+\/\/ entries referring to discovered candidates, allocating new OopStorage\n+\/\/ entries for the requests.  The deduplication processing thread does a\n+\/\/ concurrent iteration over the processing storage, deduplicating the\n+\/\/ Strings and releasing the OopStorage entries.  Two storage objects are\n+\/\/ used so there isn't any conflict between adding and removing entries by\n+\/\/ different threads.\n@@ -52,1 +65,8 @@\n-\/\/ Candidate selection criteria is GC specific.\n+\/\/ The deduplication table uses entries from another weak OopStorage to hold\n+\/\/ the byte arrays.  This permits reclamation of arrays that become unused.\n+\/\/ This is separate from the request storage objects because dead count\n+\/\/ tracking is used by the table implementation as part of resizing\n+\/\/ decisions and for deciding when to cleanup dead entries in the table.\n+\/\/ The usage pattern for the table is also very different from that of the\n+\/\/ request storages.  The request\/processing storages are used in a way that\n+\/\/ supports bulk allocation and release of entries.\n@@ -54,7 +74,21 @@\n-\/\/ Interned strings are a bit special. They are explicitly deduplicated just before\n-\/\/ being inserted into the StringTable (to avoid counteracting C2 optimizations done\n-\/\/ on string literals), then they also become deduplication candidates if they reach\n-\/\/ the deduplication age threshold or are evacuated to an old heap region. The second\n-\/\/ attempt to deduplicate such strings will be in vain, but we have no fast way of\n-\/\/ filtering them out. This has not shown to be a problem, as the number of interned\n-\/\/ strings is usually dwarfed by the number of normal (non-interned) strings.\n+\/\/ Candidate selection criteria is GC specific.  This class provides some\n+\/\/ helper functions that may be of use when implementing candidate\n+\/\/ selection.\n+\/\/\n+\/\/ Strings interned in the StringTable require special handling.  Once a\n+\/\/ String has been added to the StringTable, its byte array must not change.\n+\/\/ Doing so would counteract C2 optimizations on string literals.  But an\n+\/\/ interned string might later become a deduplication candidate through the\n+\/\/ normal GC discovery mechanism.  To prevent such modifications, the\n+\/\/ deduplication_forbidden flag of a String is set before interning it.  A\n+\/\/ String with that flag set may have its byte array added to the\n+\/\/ deduplication table, but will not have its byte array replaced by a\n+\/\/ different but equivalent array from the table.\n+\/\/\n+\/\/ A GC must opt-in to support string deduplication. This primarily involves\n+\/\/ making deduplication requests. As the GC is processing objects it must\n+\/\/ determine which are candidates for deduplication, and add those objects\n+\/\/ to StringDedup::Requests objects. Typically, each GC marking\/evacuation\n+\/\/ thread has its own Requests object. Once liveness analysis is complete,\n+\/\/ but before weak reference processing, the GC should flush or delete all\n+\/\/ of its Requests objects.\n@@ -64,1 +98,0 @@\n-\/\/\n@@ -66,5 +99,3 @@\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupTable.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/thread.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -72,0 +103,1 @@\n+class Klass;\n@@ -74,3 +106,5 @@\n-\/\/\n-\/\/ Main interface for interacting with string deduplication.\n-\/\/\n+\/\/ The StringDedup class provides the API for the deduplication mechanism.\n+\/\/ StringDedup::Requests and the StringDedup functions for candidate testing\n+\/\/ are all that a GC needs to use to support the string deduplication\n+\/\/ feature.  Other functions in the StringDedup class are called where\n+\/\/ needed, without requiring GC-specific code.\n@@ -78,2 +112,7 @@\n-private:\n-  \/\/ Single state for checking if string deduplication is enabled.\n+  class Config;\n+  class Processor;\n+  class Stat;\n+  class StorageUse;\n+  class Table;\n+\n+  static bool _initialized;\n@@ -82,0 +121,8 @@\n+  static Processor* _processor;\n+  static Stat _cur_stat;\n+  static Stat _total_stat;\n+\n+  static const Klass* _string_klass_or_null;\n+  static uint _enabled_age_threshold;\n+  static uint _enabled_age_limit;\n+\n@@ -83,4 +130,1 @@\n-  \/\/ Returns true if string deduplication is enabled.\n-  static bool is_enabled() {\n-    return _enabled;\n-  }\n+  class Requests;\n@@ -88,2 +132,3 @@\n-  \/\/ Stop the deduplication thread.\n-  static void stop();\n+  \/\/ Initialize and check command line arguments.\n+  \/\/ Returns true if configuration is valid, false otherwise.\n+  static bool ergo_initialize();\n@@ -91,3 +136,2 @@\n-  \/\/ Immediately deduplicates the given String object, bypassing the\n-  \/\/ the deduplication queue.\n-  static void deduplicate(oop java_string);\n+  \/\/ Initialize deduplication if enabled by command line arguments.\n+  static void initialize();\n@@ -95,1 +139,2 @@\n-  static void parallel_unlink(StringDedupUnlinkOrOopsDoClosure* unlink, uint worker_id);\n+  \/\/ Returns true if string deduplication is enabled.\n+  static bool is_enabled() { return _enabled; }\n@@ -97,0 +142,6 @@\n+  \/\/ Stop the deduplication processor thread.\n+  \/\/ precondition: is_enabled()\n+  static void stop();\n+\n+  \/\/ Visit the deduplication processor thread.\n+  \/\/ precondition: is_enabled()\n@@ -99,0 +150,6 @@\n+  \/\/ Notify that a String is being added to the StringTable.\n+  \/\/ precondition: is_enabled()\n+  \/\/ precondition: java_string is a Java String object.\n+  static void notify_intern(oop java_string);\n+\n+  \/\/ precondition: at safepoint\n@@ -101,3 +158,3 @@\n-  \/\/ GC support\n-  static void gc_prologue(bool resize_and_rehash_table);\n-  static void gc_epilogue();\n+  \/\/ Some predicates for use in testing whether an object is a candidate for\n+  \/\/ deduplication.  These functions combine an implicit is_enabled check\n+  \/\/ with another check in a single comparison.\n@@ -105,6 +162,19 @@\n-protected:\n-  \/\/ Initialize string deduplication.\n-  \/\/ Q: String Dedup Queue implementation\n-  \/\/ S: String Dedup Stat implementation\n-  template <typename Q, typename S>\n-  static void initialize_impl();\n+  \/\/ Return true if k is String klass and deduplication is enabled.\n+  static bool is_enabled_string(const Klass* k) {\n+    return k == _string_klass_or_null;\n+  }\n+\n+  \/\/ Return true if age == StringDeduplicationAgeThreshold and\n+  \/\/ deduplication is enabled.\n+  static bool is_threshold_age(uint age) {\n+    \/\/ Threshold is from option if enabled, or an impossible value (exceeds\n+    \/\/ markWord::max_age) if disabled.\n+    return age == _enabled_age_threshold;\n+  }\n+\n+  \/\/ Return true if age < StringDeduplicationAgeThreshold and\n+  \/\/ deduplication is enabled.\n+  static bool is_below_threshold_age(uint age) {\n+    \/\/ Limit is from option if enabled, or 0 if disabled.\n+    return age < _enabled_age_limit;\n+  }\n@@ -113,0 +183,1 @@\n+\/\/ GC requests for String deduplication.\n@@ -114,8 +185,10 @@\n-\/\/ This closure encapsulates the closures needed when scanning\n-\/\/ the deduplication queue and table during the unlink_or_oops_do() operation.\n-\/\/\n-class StringDedupUnlinkOrOopsDoClosure : public StackObj {\n-  AlwaysTrueClosure   _always_true;\n-  DoNothingClosure    _do_nothing;\n-  BoolObjectClosure*  _is_alive;\n-  OopClosure*         _keep_alive;\n+\/\/ Each marking thread should have it's own Requests object.  When marking\n+\/\/ is completed the Requests object must be flushed (either explicitly or by\n+\/\/ the destructor).\n+class StringDedup::Requests {\n+  StorageUse* _storage_for_requests;\n+  oop** _buffer;\n+  size_t _index;\n+  bool _refill_failed;\n+\n+  bool refill_buffer();\n@@ -124,2 +197,2 @@\n-  StringDedupUnlinkOrOopsDoClosure(BoolObjectClosure* is_alive,\n-                                   OopClosure* keep_alive);\n+  Requests();\n+  ~Requests();                  \/\/ Calls flush().\n@@ -127,1 +200,4 @@\n-  bool is_alive(oop o) { return _is_alive->do_object_b(o); }\n+  \/\/ Request deduplication of java_string.\n+  \/\/ prerequisite: StringDedup::is_enabled()\n+  \/\/ prerequisite: java_string is a Java String\n+  void add(oop java_string);\n@@ -129,1 +205,3 @@\n-  void keep_alive(oop* p) { _keep_alive->do_oop(p); }\n+  \/\/ Flush any buffered deduplication requests and release resources\n+  \/\/ used by this object.\n+  void flush();\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.hpp","additions":148,"deletions":70,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUP_INLINE_HPP\n-#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUP_INLINE_HPP\n-\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupThread.inline.hpp\"\n-\n-template <typename Q, typename S>\n-void StringDedup::initialize_impl() {\n-  if (UseStringDeduplication) {\n-    _enabled = true;\n-    StringDedupQueue::create<Q>();\n-    StringDedupTable::create();\n-    StringDedupThreadImpl<S>::create();\n-  }\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.inline.hpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/altHashing.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupConfig.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+size_t StringDedup::Config::_initial_table_size;\n+int StringDedup::Config::_age_threshold;\n+double StringDedup::Config::_load_factor_for_growth;\n+double StringDedup::Config::_load_factor_for_shrink;\n+double StringDedup::Config::_load_factor_target;\n+size_t StringDedup::Config::_minimum_dead_for_cleanup;\n+double StringDedup::Config::_dead_factor_for_cleanup;\n+uint64_t StringDedup::Config::_hash_seed;\n+\n+size_t StringDedup::Config::initial_table_size() {\n+  return _initial_table_size;\n+}\n+\n+int StringDedup::Config::age_threshold() {\n+  return _age_threshold;\n+}\n+\n+bool StringDedup::Config::should_cleanup_table(size_t entry_count, size_t dead_count) {\n+  return (dead_count > _minimum_dead_for_cleanup) &&\n+         (dead_count > (entry_count * _dead_factor_for_cleanup));\n+}\n+\n+uint64_t StringDedup::Config::hash_seed() {\n+  return _hash_seed;\n+}\n+\n+static uint64_t initial_hash_seed() {\n+  if (StringDeduplicationHashSeed != 0) {\n+    return StringDeduplicationHashSeed;\n+  } else {\n+    return AltHashing::compute_seed();\n+  }\n+}\n+\n+\/\/ Primes after 500 * 2^N and 500 * (2^N + 2^(N-1)) for integer N.\n+const size_t StringDedup::Config::good_sizes[] = {\n+  503, 751, 1009, 1511, 2003, 3001, 4001, 6007, 8009, 12007, 16001, 24001,\n+  32003, 48017, 64007, 96001, 128021, 192007, 256019, 384001, 512009, 768013,\n+  1024021, 1536011, 2048003, 3072001, 4096013, 6144001, 8192003, 12288011,\n+  16384001, 24576001, 32768011, 49152001, 65536043, 98304053,\n+  131072003, 196608007, 262144009, 393216007, 524288057, 786432001,\n+  1048576019, 1572864001 };\n+\n+const size_t StringDedup::Config::min_good_size = good_sizes[0];\n+const size_t StringDedup::Config::max_good_size = good_sizes[ARRAY_SIZE(good_sizes) - 1];\n+\n+size_t StringDedup::Config::good_size(size_t n) {\n+  size_t result = good_sizes[ARRAY_SIZE(good_sizes) - 1];\n+  for (size_t i = 0; i < ARRAY_SIZE(good_sizes); ++i) {\n+    if (n <= good_sizes[i]) {\n+      result = good_sizes[i];\n+      break;\n+    }\n+  }\n+  return result;\n+}\n+\n+size_t StringDedup::Config::grow_threshold(size_t table_size) {\n+  return (table_size < max_good_size) ?\n+         static_cast<size_t>(table_size * _load_factor_for_growth) :\n+         SIZE_MAX;\n+}\n+\n+size_t StringDedup::Config::shrink_threshold(size_t table_size) {\n+    return (table_size > min_good_size) ?\n+           static_cast<size_t>(table_size * _load_factor_for_shrink) :\n+           0;\n+}\n+\n+bool StringDedup::Config::should_grow_table(size_t table_size, size_t entry_count) {\n+  return entry_count > grow_threshold(table_size);\n+}\n+\n+bool StringDedup::Config::should_shrink_table(size_t table_size, size_t entry_count) {\n+  return entry_count < shrink_threshold(table_size);\n+}\n+\n+size_t StringDedup::Config::desired_table_size(size_t entry_count) {\n+  return good_size(static_cast<size_t>(entry_count \/ _load_factor_target));\n+}\n+\n+bool StringDedup::Config::ergo_initialize() {\n+  if (!UseStringDeduplication) {\n+    return true;\n+  } else if (!UseG1GC && !UseShenandoahGC) {\n+    \/\/ String deduplication requested but not supported by the selected GC.\n+    \/\/ Warn and force disable, but don't error except in debug build with\n+    \/\/ incorrect default.\n+    assert(!FLAG_IS_DEFAULT(UseStringDeduplication),\n+           \"Enabled by default for GC that doesn't support it\");\n+    log_warning(stringdedup)(\"String Deduplication disabled: \"\n+                             \"not supported by selected GC\");\n+    FLAG_SET_ERGO(UseStringDeduplication, false);\n+    return true;\n+  }\n+\n+  \/\/ UseStringDeduplication is enabled.  Check parameters.  These checks are\n+  \/\/ in addition to any range or constraint checks directly associated with\n+  \/\/ the parameters.\n+  bool result = true;\n+\n+  \/\/ ShrinkTableLoad <= TargetTableLoad <= GrowTableLoad.\n+  if (StringDeduplicationShrinkTableLoad > StringDeduplicationTargetTableLoad) {\n+    JVMFlag::printError(true,\n+                        \"StringDeduplicationShrinkTableLoad (%f) must not exceed \"\n+                        \"StringDeduplicationTargetTableLoad (%f)\",\n+                        StringDeduplicationShrinkTableLoad,\n+                        StringDeduplicationTargetTableLoad);\n+    result = false;\n+  }\n+  if (StringDeduplicationTargetTableLoad > StringDeduplicationGrowTableLoad) {\n+    JVMFlag::printError(true,\n+                        \"StringDeduplicationTargetTableLoad (%f) must not exceed \"\n+                        \"StringDeduplicationGrowTableLoad (%f)\",\n+                        StringDeduplicationTargetTableLoad,\n+                        StringDeduplicationGrowTableLoad);\n+    result = false;\n+  }\n+\n+  return result;\n+}\n+\n+void StringDedup::Config::initialize() {\n+  _initial_table_size = good_size(StringDeduplicationInitialTableSize);\n+  _age_threshold = StringDeduplicationAgeThreshold;\n+  _load_factor_for_growth = StringDeduplicationGrowTableLoad;\n+  _load_factor_for_shrink = StringDeduplicationShrinkTableLoad;\n+  _load_factor_target = StringDeduplicationTargetTableLoad;\n+  _minimum_dead_for_cleanup = StringDeduplicationCleanupDeadMinimum;\n+  _dead_factor_for_cleanup = percent_of(StringDeduplicationCleanupDeadPercent, 100);\n+  _hash_seed = initial_hash_seed();\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupConfig.cpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPCONFIG_HPP\n+#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPCONFIG_HPP\n+\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Provides access to canonicalized configuration parameter values.  This\n+\/\/ class captures the various StringDeduplicationXXX command line option\n+\/\/ values, massages them, and provides error checking support.\n+class StringDedup::Config : AllStatic {\n+  static size_t _initial_table_size;\n+  static int _age_threshold;\n+  static double _load_factor_for_growth;\n+  static double _load_factor_for_shrink;\n+  static double _load_factor_target;\n+  static size_t _minimum_dead_for_cleanup;\n+  static double _dead_factor_for_cleanup;\n+  static uint64_t _hash_seed;\n+\n+  static const size_t good_sizes[];\n+  static const size_t min_good_size;\n+  static const size_t max_good_size;\n+  static size_t good_size(size_t n);\n+\n+public:\n+  \/\/ Perform ergonomic adjustments and error checking.\n+  \/\/ Returns true on success, false if some error check failed.\n+  static bool ergo_initialize();\n+\n+  static void initialize();\n+\n+  static size_t initial_table_size();\n+  static int age_threshold();\n+  static uint64_t hash_seed();\n+\n+  static size_t grow_threshold(size_t table_size);\n+  static size_t shrink_threshold(size_t table_size);\n+  static bool should_grow_table(size_t table_size, size_t entry_count);\n+  static bool should_shrink_table(size_t table_size, size_t entry_count);\n+  static size_t desired_table_size(size_t entry_count);\n+  static bool should_cleanup_table(size_t entry_count, size_t dead_count);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPCONFIG_HPP\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupConfig.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageParState.inline.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupProcessor.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStorageUse.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupTable.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalCounter.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+StringDedup::Processor::Processor() : ConcurrentGCThread() {\n+  set_name(\"StringDedupProcessor\");\n+}\n+\n+OopStorage* StringDedup::Processor::_storages[2] = {};\n+\n+StringDedup::StorageUse* volatile StringDedup::Processor::_storage_for_requests = nullptr;\n+StringDedup::StorageUse* StringDedup::Processor::_storage_for_processing = nullptr;\n+\n+void StringDedup::Processor::initialize_storage() {\n+  assert(_storages[0] == nullptr, \"storage already created\");\n+  assert(_storages[1] == nullptr, \"storage already created\");\n+  assert(_storage_for_requests == nullptr, \"storage already created\");\n+  assert(_storage_for_processing == nullptr, \"storage already created\");\n+  _storages[0] = OopStorageSet::create_weak(\"StringDedup Requests0 Weak\", mtStringDedup);\n+  _storages[1] = OopStorageSet::create_weak(\"StringDedup Requests1 Weak\", mtStringDedup);\n+  _storage_for_requests = new StorageUse(_storages[0]);\n+  _storage_for_processing = new StorageUse(_storages[1]);\n+}\n+\n+void StringDedup::Processor::initialize() {\n+  _processor = new Processor();\n+  _processor->create_and_start();\n+}\n+\n+bool StringDedup::Processor::wait_for_requests() const {\n+  \/\/ Wait for the current request storage object to be non-empty.  The\n+  \/\/ num-dead notification from the Table notifies the monitor.\n+  if (!should_terminate()) {\n+    MonitorLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n+    OopStorage* storage = Atomic::load(&_storage_for_requests)->storage();\n+    while (!should_terminate() &&\n+           (storage->allocation_count() == 0) &&\n+           !Table::is_dead_entry_removal_needed()) {\n+      ml.wait();\n+    }\n+  }\n+  \/\/ Swap the request and processing storage objects.\n+  if (!should_terminate()) {\n+    log_trace(stringdedup)(\"swapping request storages\");\n+    _storage_for_processing = Atomic::xchg(&_storage_for_requests, _storage_for_processing);\n+    GlobalCounter::write_synchronize();\n+  }\n+  \/\/ Wait for the now current processing storage object to no longer be used\n+  \/\/ by an in-progress GC.  Again here, the num-dead notification from the\n+  \/\/ Table notifies the monitor.\n+  if (!should_terminate()) {\n+    log_trace(stringdedup)(\"waiting for storage to process\");\n+    MonitorLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n+    while (_storage_for_processing->is_used_acquire() && !should_terminate()) {\n+      ml.wait();\n+    }\n+  }\n+  return !should_terminate();\n+}\n+\n+StringDedup::StorageUse* StringDedup::Processor::storage_for_requests() {\n+  return StorageUse::obtain(&_storage_for_requests);\n+}\n+\n+bool StringDedup::Processor::yield_or_continue(SuspendibleThreadSetJoiner* joiner,\n+                                               Stat::Phase phase) const {\n+  if (joiner->should_yield()) {\n+    _cur_stat.block_phase(phase);\n+    joiner->yield();\n+    _cur_stat.unblock_phase();\n+  }\n+  return !should_terminate();\n+}\n+\n+void StringDedup::Processor::cleanup_table(SuspendibleThreadSetJoiner* joiner,\n+                                           bool grow_only,\n+                                           bool force) const {\n+  if (Table::cleanup_start_if_needed(grow_only, force)) {\n+    Stat::Phase phase = Table::cleanup_phase();\n+    while (yield_or_continue(joiner, phase)) {\n+      if (!Table::cleanup_step()) break;\n+    }\n+    Table::cleanup_end();\n+  }\n+}\n+\n+class StringDedup::Processor::ProcessRequest final : public OopClosure {\n+  OopStorage* _storage;\n+  SuspendibleThreadSetJoiner* _joiner;\n+  size_t _release_index;\n+  oop* _bulk_release[OopStorage::bulk_allocate_limit];\n+\n+  void release_ref(oop* ref) {\n+    assert(_release_index < ARRAY_SIZE(_bulk_release), \"invariant\");\n+    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(ref, nullptr);\n+    _bulk_release[_release_index++] = ref;\n+    if (_release_index == ARRAY_SIZE(_bulk_release)) {\n+      _storage->release(_bulk_release, _release_index);\n+      _release_index = 0;\n+    }\n+  }\n+\n+public:\n+  ProcessRequest(OopStorage* storage, SuspendibleThreadSetJoiner* joiner) :\n+    _storage(storage),\n+    _joiner(joiner),\n+    _release_index(0),\n+    _bulk_release()\n+  {}\n+\n+  ~ProcessRequest() {\n+    _storage->release(_bulk_release, _release_index);\n+  }\n+\n+  virtual void do_oop(narrowOop*) { ShouldNotReachHere(); }\n+\n+  virtual void do_oop(oop* ref) {\n+    if (_processor->yield_or_continue(_joiner, Stat::Phase::process)) {\n+      oop java_string = NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(ref);\n+      release_ref(ref);\n+      \/\/ Dedup java_string, after checking for various reasons to skip it.\n+      if (java_string == nullptr) {\n+        \/\/ String became unreachable before we got a chance to process it.\n+        _cur_stat.inc_skipped_dead();\n+      } else if (java_lang_String::value(java_string) == nullptr) {\n+        \/\/ Request during String construction, before its value array has\n+        \/\/ been initialized.\n+        _cur_stat.inc_skipped_incomplete();\n+      } else {\n+        Table::deduplicate(java_string);\n+        if (Table::is_grow_needed()) {\n+          _cur_stat.report_process_pause();\n+          _processor->cleanup_table(_joiner, true \/* grow_only *\/, false \/* force *\/);\n+          _cur_stat.report_process_resume();\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+void StringDedup::Processor::process_requests(SuspendibleThreadSetJoiner* joiner) const {\n+  OopStorage::ParState<true, false> par_state{_storage_for_processing->storage(), 1};\n+  ProcessRequest processor{_storage_for_processing->storage(), joiner};\n+  par_state.oops_do(&processor);\n+}\n+\n+void StringDedup::Processor::run_service() {\n+  while (!should_terminate()) {\n+    _cur_stat.report_idle_start();\n+    if (!wait_for_requests()) {\n+      assert(should_terminate(), \"invariant\");\n+      break;\n+    }\n+    SuspendibleThreadSetJoiner sts_joiner{};\n+    if (should_terminate()) break;\n+    _cur_stat.report_idle_end();\n+    _cur_stat.report_concurrent_start();\n+    _cur_stat.report_process_start();\n+    process_requests(&sts_joiner);\n+    if (should_terminate()) break;\n+    _cur_stat.report_process_end();\n+    cleanup_table(&sts_joiner,\n+                  false \/* grow_only *\/,\n+                  StringDeduplicationResizeALot \/* force *\/);\n+    if (should_terminate()) break;\n+    _cur_stat.report_concurrent_end();\n+    log_statistics();\n+  }\n+}\n+\n+void StringDedup::Processor::stop_service() {\n+  MonitorLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n+  ml.notify_all();\n+}\n+\n+void StringDedup::Processor::log_statistics() {\n+  _total_stat.add(&_cur_stat);\n+  Stat::log_summary(&_cur_stat, &_total_stat);\n+  if (log_is_enabled(Debug, stringdedup)) {\n+    _cur_stat.log_statistics(false);\n+    _total_stat.log_statistics(true);\n+    Table::log_statistics();\n+  }\n+  _cur_stat = Stat{};\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPPROCESSOR_HPP\n+#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPPROCESSOR_HPP\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class OopStorage;\n+class SuspendibleThreadSetJoiner;\n+\n+\/\/ Thread class for string deduplication.  There is only one instance of\n+\/\/ this class.  This thread processes deduplication requests.  It also\n+\/\/ manages the deduplication table, performing resize and cleanup operations\n+\/\/ as needed.  This includes managing the OopStorage objects used to hold\n+\/\/ requests.\n+\/\/\n+\/\/ This thread uses the SuspendibleThreadSet mechanism to take part in the\n+\/\/ safepoint protocol.  It checks for safepoints between processing requests\n+\/\/ in order to minimize safepoint latency.  The Table provides incremental\n+\/\/ operations for resizing and for removing dead entries, so this thread can\n+\/\/ perform safepoint checks between steps in those operations.\n+class StringDedup::Processor : public ConcurrentGCThread {\n+  Processor();\n+  ~Processor() = default;\n+\n+  NONCOPYABLE(Processor);\n+\n+  static OopStorage* _storages[2];\n+  static StorageUse* volatile _storage_for_requests;\n+  static StorageUse* _storage_for_processing;\n+\n+  \/\/ Returns !should_terminate();\n+  bool wait_for_requests() const;\n+\n+  \/\/ Yield if requested.  Returns !should_terminate() after possible yield.\n+  bool yield_or_continue(SuspendibleThreadSetJoiner* joiner, Stat::Phase phase) const;\n+\n+  class ProcessRequest;\n+  void process_requests(SuspendibleThreadSetJoiner* joiner) const;\n+  void cleanup_table(SuspendibleThreadSetJoiner* joiner, bool grow_only, bool force) const;\n+\n+  void log_statistics();\n+\n+protected:\n+  virtual void run_service();\n+  virtual void stop_service();\n+\n+public:\n+  static void initialize();\n+\n+  static void initialize_storage();\n+  static StorageUse* storage_for_requests();\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPPROCESSOR_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.hpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-StringDedupQueue* StringDedupQueue::_queue = NULL;\n-volatile size_t   StringDedupQueue::_claimed_index = 0;\n-\n-size_t StringDedupQueue::claim() {\n-  return Atomic::fetch_and_add(&_claimed_index, 1u);\n-}\n-\n-void StringDedupQueue::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl) {\n-  size_t claimed_queue = claim();\n-  while (claimed_queue < queue()->num_queues()) {\n-    queue()->unlink_or_oops_do_impl(cl, claimed_queue);\n-    claimed_queue = claim();\n-  }\n-}\n-\n-void StringDedupQueue::print_statistics() {\n-  queue()->print_statistics_impl();\n-}\n-\n-void StringDedupQueue::verify() {\n-  queue()->verify_impl();\n-}\n-\n-StringDedupQueue* const StringDedupQueue::queue() {\n-  assert(_queue != NULL, \"Not yet initialized\");\n-  return _queue;\n-}\n-\n-\n-void StringDedupQueue::gc_prologue() {\n-  _claimed_index = 0;\n-}\n-\n-void StringDedupQueue::gc_epilogue() {\n-  assert(_claimed_index >= queue()->num_queues() || _claimed_index == 0, \"All or nothing\");\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupQueue.cpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPQUEUE_HPP\n-#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPQUEUE_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-class StringDedupUnlinkOrOopsDoClosure;\n-\n-\/\/\n-\/\/ The deduplication queue acts as the communication channel between mark\/evacuation\n-\/\/ phase and the concurrent deduplication phase. Deduplication candidates\n-\/\/ found during mark\/evacuation are placed on this queue for later processing in the\n-\/\/ deduplication thread. A queue entry is an oop pointing to a String object (as opposed\n-\/\/ to entries in the deduplication hashtable which points to character arrays).\n-\/\/\n-\/\/ While users of the queue treat it as a single queue, it is implemented as a set of\n-\/\/ queues, one queue per GC worker thread, to allow lock-free and cache-friendly enqueue\n-\/\/ operations by the GC workers.\n-\/\/\n-\/\/ The oops in the queue are treated as weak pointers, meaning the objects they point to\n-\/\/ can become unreachable and pruned (cleared) before being popped by the deduplication\n-\/\/ thread.\n-\/\/\n-\/\/ Pushing to the queue is thread safe (this relies on each thread using a unique worker\n-\/\/ id). Popping from the queue is NOT thread safe and can only be done by the deduplication\n-\/\/ thread outside a safepoint.\n-\/\/\n-\n-class StringDedupQueue : public CHeapObj<mtGC> {\n-private:\n-  static StringDedupQueue*   _queue;\n-  static volatile size_t     _claimed_index;\n-\n-public:\n-  template <typename Q>\n-  static void create();\n-\n-  \/\/ Blocks and waits for the queue to become non-empty.\n-  static inline void wait();\n-\n-  \/\/ Wakes up any thread blocked waiting for the queue to become non-empty.\n-  static inline void cancel_wait();\n-\n-  \/\/ Pushes a deduplication candidate onto a specific GC worker queue.\n-  static inline void push(uint worker_id, oop java_string);\n-\n-  \/\/ Pops a deduplication candidate from any queue, returns NULL if\n-  \/\/ all queues are empty.\n-  static inline oop pop();\n-\n-  static void unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl);\n-\n-  static void print_statistics();\n-  static void verify();\n-\n-  \/\/ GC support\n-  static void gc_prologue();\n-  static void gc_epilogue();\n-\n-protected:\n-  static StringDedupQueue* const queue();\n-\n-  \/\/ Queue interface.\n-\n-  \/\/ Blocks and waits for the queue to become non-empty.\n-  virtual void wait_impl() = 0;\n-\n-  \/\/ Wakes up any thread blocked waiting for the queue to become non-empty.\n-  virtual void cancel_wait_impl() = 0;\n-\n-  \/\/ Pushes a deduplication candidate onto a specific GC worker queue.\n-  virtual void push_impl(uint worker_id, oop java_string) = 0;\n-\n-  \/\/ Pops a deduplication candidate from any queue, returns NULL if\n-  \/\/ all queues are empty.\n-  virtual oop pop_impl() = 0;\n-\n-  virtual void unlink_or_oops_do_impl(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue) = 0;\n-\n-  virtual void print_statistics_impl() = 0;\n-  virtual void verify_impl() = 0;\n-\n-  virtual size_t num_queues() const = 0;\n-\n-  static size_t claim();\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupQueue.hpp","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPQUEUE_INLINE_HPP\n-#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPQUEUE_INLINE_HPP\n-\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n-\n-template <typename Q>\n-void StringDedupQueue::create() {\n-  assert(StringDedup::is_enabled(), \"Must be enabled\");\n-  assert(_queue == NULL, \"Can have only one queue\");\n-  _queue = new Q;\n-}\n-\n-void StringDedupQueue::wait() {\n-  queue()->wait_impl();\n-}\n-\n-void StringDedupQueue::cancel_wait() {\n-  queue()->cancel_wait_impl();\n-}\n-\n-void StringDedupQueue::push(uint worker_id, oop java_string) {\n-  queue()->push_impl(worker_id, java_string);\n-}\n-\n-oop StringDedupQueue::pop() {\n-  return queue()->pop_impl();\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupQueue.inline.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -29,1 +30,1 @@\n-StringDedupStat::StringDedupStat() :\n+StringDedup::Stat::Stat() :\n@@ -31,2 +32,0 @@\n-  _skipped(0),\n-  _hashed(0),\n@@ -34,0 +33,1 @@\n+  _known_shared(0),\n@@ -38,0 +38,6 @@\n+  _replaced(0),\n+  _deleted(0),\n+  _skipped_dead(0),\n+  _skipped_incomplete(0),\n+  _skipped_shared(0),\n+  _concurrent(0),\n@@ -39,1 +45,3 @@\n-  _exec(0),\n+  _process(0),\n+  _resize_table(0),\n+  _cleanup_table(0),\n@@ -41,6 +49,8 @@\n-  _start_concurrent(0.0),\n-  _end_concurrent(0.0),\n-  _start_phase(0.0),\n-  _idle_elapsed(0.0),\n-  _exec_elapsed(0.0),\n-  _block_elapsed(0.0) {\n+  _concurrent_start(),\n+  _concurrent_elapsed(),\n+  _phase_start(),\n+  _idle_elapsed(),\n+  _process_elapsed(),\n+  _resize_table_elapsed(),\n+  _cleanup_table_elapsed(),\n+  _block_elapsed() {\n@@ -49,1 +59,1 @@\n-void StringDedupStat::add(const StringDedupStat* const stat) {\n+void StringDedup::Stat::add(const Stat* const stat) {\n@@ -51,2 +61,0 @@\n-  _skipped             += stat->_skipped;\n-  _hashed              += stat->_hashed;\n@@ -54,0 +62,1 @@\n+  _known_shared        += stat->_known_shared;\n@@ -58,0 +67,6 @@\n+  _replaced            += stat->_replaced;\n+  _deleted             += stat->_deleted;\n+  _skipped_dead        += stat->_skipped_dead;\n+  _skipped_incomplete  += stat->_skipped_incomplete;\n+  _skipped_shared      += stat->_skipped_shared;\n+  _concurrent          += stat->_concurrent;\n@@ -59,1 +74,3 @@\n-  _exec                += stat->_exec;\n+  _process             += stat->_process;\n+  _resize_table        += stat->_resize_table;\n+  _cleanup_table       += stat->_cleanup_table;\n@@ -61,0 +78,1 @@\n+  _concurrent_elapsed  += stat->_concurrent_elapsed;\n@@ -62,1 +80,3 @@\n-  _exec_elapsed        += stat->_exec_elapsed;\n+  _process_elapsed     += stat->_process_elapsed;\n+  _resize_table_elapsed += stat->_resize_table_elapsed;\n+  _cleanup_table_elapsed += stat->_cleanup_table_elapsed;\n@@ -66,4 +86,10 @@\n-void StringDedupStat::print_start(const StringDedupStat* last_stat) {\n-  log_info(gc, stringdedup)(\n-     \"Concurrent String Deduplication (\" STRDEDUP_TIME_FORMAT \")\",\n-     STRDEDUP_TIME_PARAM(last_stat->_start_concurrent));\n+\/\/ Support for log output formating\n+#define STRDEDUP_PERCENT_FORMAT         \"%5.1f%%\"\n+#define STRDEDUP_PERCENT_FORMAT_NS      \"%.1f%%\"\n+#define STRDEDUP_BYTES_FORMAT           \"%8.1f%s\"\n+#define STRDEDUP_BYTES_FORMAT_NS        \"%.1f%s\"\n+#define STRDEDUP_BYTES_PARAM(bytes)     byte_size_in_proper_unit((double)(bytes)), proper_unit_for_byte_size((bytes))\n+\n+#define STRDEDUP_ELAPSED_FORMAT_MS         \"%.3fms\"\n+static double strdedup_elapsed_param_ms(Tickspan t) {\n+  return t.seconds() * MILLIUNITS;\n@@ -72,1 +98,1 @@\n-void StringDedupStat::print_end(const StringDedupStat* last_stat, const StringDedupStat* total_stat) {\n+void StringDedup::Stat::log_summary(const Stat* last_stat, const Stat* total_stat) {\n@@ -80,1 +106,1 @@\n-  log_info(gc, stringdedup)(\n+  log_info(stringdedup)(\n@@ -82,6 +108,6 @@\n-    STRDEDUP_BYTES_FORMAT_NS \"->\" STRDEDUP_BYTES_FORMAT_NS \"(\" STRDEDUP_BYTES_FORMAT_NS \") \"\n-    \"avg \" STRDEDUP_PERCENT_FORMAT_NS \" \"\n-    \"(\" STRDEDUP_TIME_FORMAT \", \" STRDEDUP_TIME_FORMAT \") \" STRDEDUP_TIME_FORMAT_MS,\n-    STRDEDUP_BYTES_PARAM(last_stat->_new_bytes),\n-    STRDEDUP_BYTES_PARAM(last_stat->_new_bytes - last_stat->_deduped_bytes),\n-    STRDEDUP_BYTES_PARAM(last_stat->_deduped_bytes),\n+    \"%zu\/\" STRDEDUP_BYTES_FORMAT_NS \" (new), \"\n+    \"%zu\/\" STRDEDUP_BYTES_FORMAT_NS \" (deduped), \"\n+    \"avg \" STRDEDUP_PERCENT_FORMAT_NS \", \"\n+    STRDEDUP_ELAPSED_FORMAT_MS \" of \" STRDEDUP_ELAPSED_FORMAT_MS,\n+    last_stat->_new, STRDEDUP_BYTES_PARAM(last_stat->_new_bytes),\n+    last_stat->_deduped, STRDEDUP_BYTES_PARAM(last_stat->_deduped_bytes),\n@@ -89,28 +115,127 @@\n-    STRDEDUP_TIME_PARAM(last_stat->_start_concurrent),\n-    STRDEDUP_TIME_PARAM(last_stat->_end_concurrent),\n-    STRDEDUP_TIME_PARAM_MS(last_stat->_exec_elapsed));\n-}\n-\n-void StringDedupStat::reset() {\n-  _inspected = 0;\n-  _skipped = 0;\n-  _hashed = 0;\n-  _known = 0;\n-  _new = 0;\n-  _new_bytes = 0;\n-  _deduped = 0;\n-  _deduped_bytes = 0;\n-  _idle = 0;\n-  _exec = 0;\n-  _block = 0;\n-  _start_concurrent = 0.0;\n-  _end_concurrent = 0.0;\n-  _start_phase = 0.0;\n-  _idle_elapsed = 0.0;\n-  _exec_elapsed = 0.0;\n-  _block_elapsed = 0.0;\n-}\n-\n-void StringDedupStat::print_statistics(bool total) const {\n-  double skipped_percent             = percent_of(_skipped, _inspected);\n-  double hashed_percent              = percent_of(_hashed, _inspected);\n+    strdedup_elapsed_param_ms(last_stat->_process_elapsed),\n+    strdedup_elapsed_param_ms(last_stat->_concurrent_elapsed));\n+}\n+\n+void StringDedup::Stat::report_concurrent_start() {\n+  log_debug(stringdedup, phases, start)(\"Concurrent start\");\n+  _concurrent_start = Ticks::now();\n+  _concurrent++;\n+}\n+\n+void StringDedup::Stat::report_concurrent_end() {\n+  _concurrent_elapsed += (Ticks::now() - _concurrent_start);\n+  log_debug(stringdedup, phases)(\"Concurrent end: \" STRDEDUP_ELAPSED_FORMAT_MS,\n+                                 strdedup_elapsed_param_ms(_concurrent_elapsed));\n+}\n+\n+void StringDedup::Stat::report_phase_start(const char* phase) {\n+  log_debug(stringdedup, phases, start)(\"%s start\", phase);\n+  _phase_start = Ticks::now();\n+}\n+\n+void StringDedup::Stat::report_phase_end(const char* phase, Tickspan* elapsed) {\n+  *elapsed += Ticks::now() - _phase_start;\n+  log_debug(stringdedup, phases)(\"%s end: \" STRDEDUP_ELAPSED_FORMAT_MS,\n+                                 phase, strdedup_elapsed_param_ms(*elapsed));\n+}\n+\n+void StringDedup::Stat::report_idle_start() {\n+  report_phase_start(\"Idle\");\n+  _idle++;\n+}\n+\n+void StringDedup::Stat::report_idle_end() {\n+  report_phase_end(\"Idle\", &_idle_elapsed);\n+}\n+\n+void StringDedup::Stat::report_process_start() {\n+  report_phase_start(\"Process\");\n+  _process++;\n+}\n+\n+void StringDedup::Stat::report_process_pause() {\n+  _process_elapsed += (Ticks::now() - _phase_start);\n+  log_debug(stringdedup, phases)(\"Process paused\");\n+}\n+\n+void StringDedup::Stat::report_process_resume() {\n+  log_debug(stringdedup, phases)(\"Process resume\");\n+  _phase_start = Ticks::now();\n+}\n+\n+void StringDedup::Stat::report_process_end() {\n+  report_phase_end(\"Process\", &_process_elapsed);\n+}\n+\n+void StringDedup::Stat::report_resize_table_start(size_t new_bucket_count,\n+                                                  size_t old_bucket_count,\n+                                                  size_t entry_count) {\n+  _phase_start = Ticks::now();\n+  ++_resize_table;\n+  log_debug(stringdedup, phases, start)\n+           (\"Resize Table: %zu -> %zu (%zu)\",\n+            old_bucket_count, new_bucket_count, entry_count);\n+}\n+\n+void StringDedup::Stat::report_resize_table_end() {\n+  report_phase_end(\"Resize Table\", &_resize_table_elapsed);\n+}\n+\n+void StringDedup::Stat::report_cleanup_table_start(size_t entry_count,\n+                                                   size_t dead_count) {\n+  log_debug(stringdedup, phases, start)\n+           (\"Cleanup Table: %zu \/ %zu -> %zu\",\n+            dead_count, entry_count, (entry_count - dead_count));\n+  _phase_start = Ticks::now();\n+  _cleanup_table++;\n+}\n+\n+void StringDedup::Stat::report_cleanup_table_end() {\n+  report_phase_end(\"Cleanup Table\", &_cleanup_table_elapsed);\n+}\n+\n+Tickspan* StringDedup::Stat::elapsed_for_phase(Phase phase) {\n+  switch (phase) {\n+  case Phase::process: return &_process_elapsed;\n+  case Phase::resize_table: return &_resize_table_elapsed;\n+  case Phase::cleanup_table: return &_cleanup_table_elapsed;\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+void StringDedup::Stat::block_phase(Phase phase) {\n+  Ticks now = Ticks::now();\n+  *elapsed_for_phase(phase) += now - _phase_start;\n+  _phase_start = now;\n+  _block++;\n+}\n+\n+void StringDedup::Stat::unblock_phase() {\n+  Ticks now = Ticks::now();\n+  _block_elapsed += now - _phase_start;\n+  _phase_start = now;\n+}\n+\n+void StringDedup::Stat::log_times(const char* prefix) const {\n+  log_debug(stringdedup)(\n+    \"  %s Process: %zu\/\" STRDEDUP_ELAPSED_FORMAT_MS\n+    \", Idle: %zu\/\" STRDEDUP_ELAPSED_FORMAT_MS\n+    \", Blocked: %zu\/\" STRDEDUP_ELAPSED_FORMAT_MS,\n+    prefix,\n+    _process, strdedup_elapsed_param_ms(_process_elapsed),\n+    _idle, strdedup_elapsed_param_ms(_idle_elapsed),\n+    _block, strdedup_elapsed_param_ms(_block_elapsed));\n+  if (_resize_table > 0) {\n+    log_debug(stringdedup)(\n+      \"  %s Resize Table: %zu\/\" STRDEDUP_ELAPSED_FORMAT_MS,\n+      prefix, _resize_table, strdedup_elapsed_param_ms(_resize_table_elapsed));\n+  }\n+  if (_cleanup_table > 0) {\n+    log_debug(stringdedup)(\n+      \"  %s Cleanup Table: %zu\/\" STRDEDUP_ELAPSED_FORMAT_MS,\n+      prefix, _cleanup_table, strdedup_elapsed_param_ms(_cleanup_table_elapsed));\n+  }\n+}\n+\n+void StringDedup::Stat::log_statistics(bool total) const {\n@@ -118,0 +243,1 @@\n+  double known_shared_percent        = percent_of(_known_shared, _inspected);\n@@ -119,1 +245,1 @@\n-  double deduped_percent             = percent_of(_deduped, _new);\n+  double deduped_percent             = percent_of(_deduped, _inspected);\n@@ -121,31 +247,14 @@\n-\/*\n-  double deduped_young_percent       = percent_of(stat._deduped_young, stat._deduped);\n-  double deduped_young_bytes_percent = percent_of(stat._deduped_young_bytes, stat._deduped_bytes);\n-  double deduped_old_percent         = percent_of(stat._deduped_old, stat._deduped);\n-  double deduped_old_bytes_percent   = percent_of(stat._deduped_old_bytes, stat._deduped_bytes);\n-*\/\n-  if (total) {\n-    log_debug(gc, stringdedup)(\n-      \"  Total Exec: \" UINTX_FORMAT \"\/\" STRDEDUP_TIME_FORMAT_MS\n-      \", Idle: \" UINTX_FORMAT \"\/\" STRDEDUP_TIME_FORMAT_MS\n-      \", Blocked: \" UINTX_FORMAT \"\/\" STRDEDUP_TIME_FORMAT_MS,\n-      _exec, STRDEDUP_TIME_PARAM_MS(_exec_elapsed),\n-      _idle, STRDEDUP_TIME_PARAM_MS(_idle_elapsed),\n-      _block, STRDEDUP_TIME_PARAM_MS(_block_elapsed));\n-  } else {\n-    log_debug(gc, stringdedup)(\n-      \"  Last Exec: \" STRDEDUP_TIME_FORMAT_MS\n-      \", Idle: \" STRDEDUP_TIME_FORMAT_MS\n-      \", Blocked: \" UINTX_FORMAT \"\/\" STRDEDUP_TIME_FORMAT_MS,\n-      STRDEDUP_TIME_PARAM_MS(_exec_elapsed),\n-      STRDEDUP_TIME_PARAM_MS(_idle_elapsed),\n-      _block, STRDEDUP_TIME_PARAM_MS(_block_elapsed));\n-  }\n-  log_debug(gc, stringdedup)(\"    Inspected:    \" STRDEDUP_OBJECTS_FORMAT, _inspected);\n-  log_debug(gc, stringdedup)(\"      Skipped:    \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \")\", _skipped, skipped_percent);\n-  log_debug(gc, stringdedup)(\"      Hashed:     \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \")\", _hashed, hashed_percent);\n-  log_debug(gc, stringdedup)(\"      Known:      \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \")\", _known, known_percent);\n-  log_debug(gc, stringdedup)(\"      New:        \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \") \" STRDEDUP_BYTES_FORMAT,\n-                             _new, new_percent, STRDEDUP_BYTES_PARAM(_new_bytes));\n-  log_debug(gc, stringdedup)(\"    Deduplicated: \" STRDEDUP_OBJECTS_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \") \" STRDEDUP_BYTES_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT \")\",\n-                             _deduped, deduped_percent, STRDEDUP_BYTES_PARAM(_deduped_bytes), deduped_bytes_percent);\n+  double replaced_percent            = percent_of(_replaced, _new);\n+  double deleted_percent             = percent_of(_deleted, _new);\n+  log_times(total ? \"Total\" : \"Last\");\n+  log_debug(stringdedup)(\"    Inspected:    %12zu\", _inspected);\n+  log_debug(stringdedup)(\"      Known:      %12zu(%5.1f%%)\", _known, known_percent);\n+  log_debug(stringdedup)(\"      Shared:     %12zu(%5.1f%%)\", _known_shared, known_shared_percent);\n+  log_debug(stringdedup)(\"      New:        %12zu(%5.1f%%)\" STRDEDUP_BYTES_FORMAT,\n+                         _new, new_percent, STRDEDUP_BYTES_PARAM(_new_bytes));\n+  log_debug(stringdedup)(\"      Replaced:   %12zu(%5.1f%%)\", _replaced, replaced_percent);\n+  log_debug(stringdedup)(\"      Deleted:    %12zu(%5.1f%%)\", _deleted, deleted_percent);\n+  log_debug(stringdedup)(\"    Deduplicated: %12zu(%5.1f%%)\" STRDEDUP_BYTES_FORMAT \"(%5.1f%%)\",\n+                         _deduped, deduped_percent, STRDEDUP_BYTES_PARAM(_deduped_bytes), deduped_bytes_percent);\n+  log_debug(stringdedup)(\"    Skipped: %zu (dead), %zu (incomplete), %zu (shared)\",\n+                         _skipped_dead, _skipped_incomplete, _skipped_shared);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupStat.cpp","additions":197,"deletions":88,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,14 +28,3 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/os.hpp\"\n-\n-\/\/ Macros for GC log output formating\n-#define STRDEDUP_OBJECTS_FORMAT         UINTX_FORMAT_W(12)\n-#define STRDEDUP_TIME_FORMAT            \"%.3fs\"\n-#define STRDEDUP_TIME_PARAM(time)       (time)\n-#define STRDEDUP_TIME_FORMAT_MS         \"%.3fms\"\n-#define STRDEDUP_TIME_PARAM_MS(time)    ((time) * MILLIUNITS)\n-#define STRDEDUP_PERCENT_FORMAT         \"%5.1f%%\"\n-#define STRDEDUP_PERCENT_FORMAT_NS      \"%.1f%%\"\n-#define STRDEDUP_BYTES_FORMAT           \"%8.1f%s\"\n-#define STRDEDUP_BYTES_FORMAT_NS        \"%.1f%s\"\n-#define STRDEDUP_BYTES_PARAM(bytes)     byte_size_in_proper_unit((double)(bytes)), proper_unit_for_byte_size((bytes))\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n@@ -43,0 +32,1 @@\n+\/\/ Deduplication statistics.\n@@ -44,4 +34,12 @@\n-\/\/ Statistics gathered by the deduplication thread.\n-\/\/\n-class StringDedupStat : public CHeapObj<mtGC> {\n-protected:\n+\/\/ Operation counters are updated when deduplicating a string.\n+\/\/ Phase timing information is collected by the processing thread.\n+class StringDedup::Stat {\n+public:\n+  \/\/ Only phases that can be blocked, so excluding \"idle\".\n+  enum class Phase {\n+    process,\n+    resize_table,\n+    cleanup_table\n+  };\n+\n+private:\n@@ -49,11 +47,20 @@\n-  uintx  _inspected;\n-  uintx  _skipped;\n-  uintx  _hashed;\n-  uintx  _known;\n-  uintx  _new;\n-  uintx  _new_bytes;\n-  uintx  _deduped;\n-  uintx  _deduped_bytes;\n-  uintx  _idle;\n-  uintx  _exec;\n-  uintx  _block;\n+  size_t _inspected;\n+  size_t _known;\n+  size_t _known_shared;\n+  size_t _new;\n+  size_t _new_bytes;\n+  size_t _deduped;\n+  size_t _deduped_bytes;\n+  size_t _replaced;\n+  size_t _deleted;\n+  size_t _skipped_dead;\n+  size_t _skipped_incomplete;\n+  size_t _skipped_shared;\n+\n+  \/\/ Phase counters for deduplication thread\n+  size_t _concurrent;\n+  size_t _idle;\n+  size_t _process;\n+  size_t _resize_table;\n+  size_t _cleanup_table;\n+  size_t _block;\n@@ -62,6 +69,14 @@\n-  double _start_concurrent;\n-  double _end_concurrent;\n-  double _start_phase;\n-  double _idle_elapsed;\n-  double _exec_elapsed;\n-  double _block_elapsed;\n+  Ticks _concurrent_start;\n+  Tickspan _concurrent_elapsed;\n+  Ticks _phase_start;\n+  Tickspan _idle_elapsed;\n+  Tickspan _process_elapsed;\n+  Tickspan _resize_table_elapsed;\n+  Tickspan _cleanup_table_elapsed;\n+  Tickspan _block_elapsed;\n+\n+  void report_phase_start(const char* phase);\n+  void report_phase_end(const char* phase, Tickspan* elapsed);\n+  Tickspan* elapsed_for_phase(Phase phase);\n+\n+  void log_times(const char* prefix) const;\n@@ -70,1 +85,1 @@\n-  StringDedupStat();\n+  Stat();\n@@ -72,0 +87,1 @@\n+  \/\/ Track number of strings looked up.\n@@ -76,2 +92,3 @@\n-  void inc_skipped() {\n-    _skipped++;\n+  \/\/ Track number of requests skipped because string died.\n+  void inc_skipped_dead() {\n+    _skipped_dead++;\n@@ -80,2 +97,3 @@\n-  void inc_hashed() {\n-    _hashed++;\n+  \/\/ Track number of requests skipped because string was incomplete.\n+  void inc_skipped_incomplete() {\n+    _skipped_incomplete++;\n@@ -84,0 +102,7 @@\n+  \/\/ Track number of shared strings skipped because of a previously\n+  \/\/ installed equivalent entry.\n+  void inc_skipped_shared() {\n+    _skipped_shared++;\n+  }\n+\n+  \/\/ Track number of inspected strings already present.\n@@ -88,1 +113,7 @@\n-  void inc_new(uintx bytes) {\n+  \/\/ Track number of inspected strings found in the shared StringTable.\n+  void inc_known_shared() {\n+    _known_shared++;\n+  }\n+\n+  \/\/ Track number of inspected strings added and accumulated size.\n+  void inc_new(size_t bytes) {\n@@ -93,1 +124,2 @@\n-  virtual void deduped(oop obj, uintx bytes) {\n+  \/\/ Track number of inspected strings dedup'ed and accumulated savings.\n+  void inc_deduped(size_t bytes) {\n@@ -98,3 +130,3 @@\n-  void mark_idle() {\n-    _start_phase = os::elapsedTime();\n-    _idle++;\n+  \/\/ Track number of interned strings replacing existing strings.\n+  void inc_replaced() {\n+    _replaced++;\n@@ -103,6 +135,3 @@\n-  void mark_exec() {\n-    double now = os::elapsedTime();\n-    _idle_elapsed = now - _start_phase;\n-    _start_phase = now;\n-    _start_concurrent = now;\n-    _exec++;\n+  \/\/ Track number of strings removed from table.\n+  void inc_deleted() {\n+    _deleted++;\n@@ -111,6 +140,2 @@\n-  void mark_block() {\n-    double now = os::elapsedTime();\n-    _exec_elapsed += now - _start_phase;\n-    _start_phase = now;\n-    _block++;\n-  }\n+  void report_idle_start();\n+  void report_idle_end();\n@@ -118,5 +143,4 @@\n-  void mark_unblock() {\n-    double now = os::elapsedTime();\n-    _block_elapsed += now - _start_phase;\n-    _start_phase = now;\n-  }\n+  void report_process_start();\n+  void report_process_pause();\n+  void report_process_resume();\n+  void report_process_end();\n@@ -124,5 +148,13 @@\n-  void mark_done() {\n-    double now = os::elapsedTime();\n-    _exec_elapsed += now - _start_phase;\n-    _end_concurrent = now;\n-  }\n+  void report_resize_table_start(size_t new_bucket_count,\n+                                 size_t old_bucket_count,\n+                                 size_t entry_count);\n+  void report_resize_table_end();\n+\n+  void report_cleanup_table_start(size_t entry_count, size_t dead_count);\n+  void report_cleanup_table_end();\n+\n+  void report_concurrent_start();\n+  void report_concurrent_end();\n+\n+  void block_phase(Phase phase);\n+  void unblock_phase();\n@@ -130,3 +162,2 @@\n-  virtual void reset();\n-  virtual void add(const StringDedupStat* const stat);\n-  virtual void print_statistics(bool total) const;\n+  void add(const Stat* const stat);\n+  void log_statistics(bool total) const;\n@@ -134,2 +165,1 @@\n-  static void print_start(const StringDedupStat* last_stat);\n-  static void print_end(const StringDedupStat* last_stat, const StringDedupStat* total_stat);\n+  static void log_summary(const Stat* last_stat, const Stat* total_stat);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupStat.hpp","additions":103,"deletions":73,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStorageUse.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+StringDedup::StorageUse::StorageUse(OopStorage* storage) :\n+  _storage(storage), _use_count(0)\n+{}\n+\n+bool StringDedup::StorageUse::is_used_acquire() const {\n+  return Atomic::load_acquire(&_use_count) > 0;\n+}\n+\n+StringDedup::StorageUse*\n+StringDedup::StorageUse::obtain(StorageUse* volatile* ptr) {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  StorageUse* storage = Atomic::load(ptr);\n+  Atomic::inc(&storage->_use_count);\n+  return storage;\n+}\n+\n+void StringDedup::StorageUse::relinquish() {\n+  size_t result = Atomic::sub(&_use_count, size_t(1));\n+  assert(result != SIZE_MAX, \"use count underflow\");\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupStorageUse.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPSTORAGEUSE_HPP\n+#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPSTORAGEUSE_HPP\n+\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class OopStorage;\n+\n+\/\/ Manage access to one of the OopStorage objects used for requests.\n+class StringDedup::StorageUse : public CHeapObj<mtStringDedup> {\n+  OopStorage* const _storage;\n+  volatile size_t _use_count;\n+\n+  NONCOPYABLE(StorageUse);\n+\n+public:\n+  explicit StorageUse(OopStorage* storage);\n+\n+  OopStorage* storage() const { return _storage; }\n+\n+  \/\/ Return true if the storage is currently in use for registering requests.\n+  bool is_used_acquire() const;\n+\n+  \/\/ Get the current requests object, and increment its in-use count.\n+  static StorageUse* obtain(StorageUse* volatile* ptr);\n+\n+  \/\/ Discard a prior \"obtain\" request, decrementing the in-use count, and\n+  \/\/ permitting the deduplication thread to start processing if needed.\n+  void relinquish();\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPSTORAGEUSE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupStorageUse.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -30,0 +31,2 @@\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -31,0 +34,2 @@\n+#include \"gc\/shared\/stringdedup\/stringDedupConfig.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n@@ -32,1 +37,2 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -34,7 +40,5 @@\n-#include \"memory\/padded.inline.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/arrayOop.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/typeArrayOop.hpp\"\n-#include \"runtime\/atomic.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"oops\/access.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"oops\/weakHandle.inline.hpp\"\n@@ -42,2 +46,4 @@\n-#include \"runtime\/safepointVerifiers.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -45,0 +51,2 @@\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ StringDedup::Table::Bucket\n@@ -46,2 +54,3 @@\n-\/\/ List of deduplication table entries. Links table\n-\/\/ entries together using their _next fields.\n+\/\/ A bucket is a pair of vectors, one containing hash codes, the other\n+\/\/ containing values.  An \"entry\" is a corresponding pair of elements from\n+\/\/ the vectors.  The size of the table is the size of either vector.\n@@ -49,4 +58,29 @@\n-class StringDedupEntryList : public CHeapObj<mtGC> {\n-private:\n-  StringDedupEntry*   _list;\n-  size_t              _length;\n+\/\/ The capacity of the vectors is explicitly controlled, based on the size.\n+\/\/ Given N > 0 and 2^N <= size < 2^(N+1), then capacity = 2^N + k * 2^(N-1)\n+\/\/ for the smallest integer k in [0,2] such that size <= capacity.  That is,\n+\/\/ use a power of 2 or the midpoint between consecutive powers of 2 that is\n+\/\/ minimally at least size.\n+\/\/\n+\/\/ The main benefit of this representation is that it uses less space than a\n+\/\/ more traditional linked-list of entry nodes representation.  Such a\n+\/\/ representation requires 24 bytes per entry (64 bit platform) for the next\n+\/\/ pointer (8 bytes), the value (8 bytes), and the hash code (4 bytes, but\n+\/\/ padded to 8 because of alignment requirements).  The pair of vectors uses\n+\/\/ 12 bytes per entry, but has overhead for excess capacity so that adding\n+\/\/ an entry takes amortized constant time.  That excess capacity increases\n+\/\/ the per entry storage requirement, but it's still better than the linked\n+\/\/ list representation.\n+\/\/\n+\/\/ The per-bucket cost of a pair of vectors is higher than having a bucket\n+\/\/ be the head of a linked list of nodes.  We ameliorate this by allowing\n+\/\/ buckets to be somewhat longer than is usually desired for a hashtable.\n+\/\/ The lookup performance for string deduplication is not that critical, and\n+\/\/ searching a vector of hash codes of moderate length should be pretty\n+\/\/ fast.  By using a good hash function, having different values hash to the\n+\/\/ same hash code should be uncommon, making the part of the search of a\n+\/\/ bucket for a given hash code more effective.\n+\/\/\n+\/\/ The reason to record the hash codes with the values is that comparisons\n+\/\/ are expensive, and recomputing the hash code when resizing is also\n+\/\/ expensive.  A closed hashing implementation with just the values would be\n+\/\/ more space efficient.\n@@ -54,5 +88,3 @@\n-public:\n-  StringDedupEntryList() :\n-    _list(NULL),\n-    _length(0) {\n-  }\n+class StringDedup::Table::Bucket {\n+  GrowableArrayCHeap<uint, mtStringDedup> _hashes;\n+  GrowableArrayCHeap<TableValue, mtStringDedup> _values;\n@@ -60,5 +92,6 @@\n-  void add(StringDedupEntry* entry) {\n-    entry->set_next(_list);\n-    _list = entry;\n-    _length++;\n-  }\n+  void adjust_capacity(int new_capacity);\n+  void expand_if_full();\n+\n+public:\n+  \/\/ precondition: reserve == 0 or is the result of needed_capacity.\n+  Bucket(int reserve = 0);\n@@ -66,5 +99,3 @@\n-  StringDedupEntry* remove() {\n-    StringDedupEntry* entry = _list;\n-    if (entry != NULL) {\n-      _list = entry->next();\n-      _length--;\n+  ~Bucket() {\n+    while (!_values.is_empty()) {\n+      _values.pop().release(_table_storage);\n@@ -72,1 +103,0 @@\n-    return entry;\n@@ -75,5 +105,1 @@\n-  StringDedupEntry* remove_all() {\n-    StringDedupEntry* list = _list;\n-    _list = NULL;\n-    return list;\n-  }\n+  static int needed_capacity(int size);\n@@ -81,4 +107,2 @@\n-  size_t length() {\n-    return _length;\n-  }\n-};\n+  const GrowableArrayView<uint>& hashes() const { return _hashes; }\n+  const GrowableArrayView<TableValue>& values() const { return _values; }\n@@ -86,23 +110,2 @@\n-\/\/\n-\/\/ Cache of deduplication table entries. This cache provides fast allocation and\n-\/\/ reuse of table entries to lower the pressure on the underlying allocator.\n-\/\/ But more importantly, it provides fast\/deferred freeing of table entries. This\n-\/\/ is important because freeing of table entries is done during stop-the-world\n-\/\/ phases and it is not uncommon for large number of entries to be freed at once.\n-\/\/ Tables entries that are freed during these phases are placed onto a freelist in\n-\/\/ the cache. The deduplication thread, which executes in a concurrent phase, will\n-\/\/ later reuse or free the underlying memory for these entries.\n-\/\/\n-\/\/ The cache allows for single-threaded allocations and multi-threaded frees.\n-\/\/ Allocations are synchronized by StringDedupTable_lock as part of a table\n-\/\/ modification.\n-\/\/\n-class StringDedupEntryCache : public CHeapObj<mtGC> {\n-private:\n-  \/\/ One cache\/overflow list per GC worker to allow lock less freeing of\n-  \/\/ entries while doing a parallel scan of the table. Using PaddedEnd to\n-  \/\/ avoid false sharing.\n-  size_t                             _nlists;\n-  size_t                             _max_list_length;\n-  PaddedEnd<StringDedupEntryList>*   _cached;\n-  PaddedEnd<StringDedupEntryList>*   _overflowed;\n+  bool is_empty() const { return _hashes.length() == 0; }\n+  int length() const { return _hashes.length(); }\n@@ -110,3 +113,5 @@\n-public:\n-  StringDedupEntryCache(size_t max_size);\n-  ~StringDedupEntryCache();\n+  void add(uint hash_code, TableValue value) {\n+    expand_if_full();\n+    _hashes.push(hash_code);\n+    _values.push(value);\n+  }\n@@ -114,2 +119,5 @@\n-  \/\/ Set max number of table entries to cache.\n-  void set_max_size(size_t max_size);\n+  void delete_at(int index) {\n+    _values.at(index).release(_table_storage);\n+    _hashes.delete_at(index);\n+    _values.delete_at(index);\n+  }\n@@ -117,2 +125,4 @@\n-  \/\/ Get a table entry from the cache, or allocate a new entry if the cache is empty.\n-  StringDedupEntry* alloc();\n+  void pop_norelease() {\n+    _hashes.pop();\n+    _values.pop();\n+  }\n@@ -120,2 +130,1 @@\n-  \/\/ Insert a table entry into the cache.\n-  void free(StringDedupEntry* entry, uint worker_id);\n+  void shrink();\n@@ -123,2 +132,1 @@\n-  \/\/ Returns current number of entries in the cache.\n-  size_t size();\n+  TableValue find(typeArrayOop obj, uint hash_code) const;\n@@ -126,2 +134,1 @@\n-  \/\/ Deletes overflowed entries.\n-  void delete_overflowed();\n+  void verify(size_t bucket_index, size_t bucket_count) const;\n@@ -130,6 +137,5 @@\n-StringDedupEntryCache::StringDedupEntryCache(size_t max_size) :\n-  _nlists(ParallelGCThreads),\n-  _max_list_length(0),\n-  _cached(PaddedArray<StringDedupEntryList, mtGC>::create_unfreeable((uint)_nlists)),\n-  _overflowed(PaddedArray<StringDedupEntryList, mtGC>::create_unfreeable((uint)_nlists)) {\n-  set_max_size(max_size);\n+StringDedup::Table::Bucket::Bucket(int reserve) :\n+  _hashes(reserve), _values(reserve)\n+{\n+  assert(reserve == needed_capacity(reserve),\n+         \"reserve %d not computed properly\", reserve);\n@@ -138,2 +144,7 @@\n-StringDedupEntryCache::~StringDedupEntryCache() {\n-  ShouldNotReachHere();\n+\/\/ Choose the least power of 2 or half way between two powers of 2,\n+\/\/ such that number of entries <= target.\n+int StringDedup::Table::Bucket::needed_capacity(int needed) {\n+  if (needed == 0) return 0;\n+  int high = round_up_power_of_2(needed);\n+  int low = high - high\/4;\n+  return (needed <= low) ? low : high;\n@@ -142,2 +153,9 @@\n-void StringDedupEntryCache::set_max_size(size_t size) {\n-  _max_list_length = size \/ _nlists;\n+void StringDedup::Table::Bucket::adjust_capacity(int new_capacity) {\n+  GrowableArrayCHeap<uint, mtStringDedup> new_hashes{new_capacity};\n+  GrowableArrayCHeap<TableValue, mtStringDedup> new_values{new_capacity};\n+  while (!_hashes.is_empty()) {\n+    new_hashes.push(_hashes.pop());\n+    new_values.push(_values.pop());\n+  }\n+  _hashes.swap(&new_hashes);\n+  _values.swap(&new_values);\n@@ -146,6 +164,3 @@\n-StringDedupEntry* StringDedupEntryCache::alloc() {\n-  for (size_t i = 0; i < _nlists; i++) {\n-    StringDedupEntry* entry = _cached[i].remove();\n-    if (entry != NULL) {\n-      return entry;\n-    }\n+void StringDedup::Table::Bucket::expand_if_full() {\n+  if (_hashes.length() == _hashes.max_length()) {\n+    adjust_capacity(needed_capacity(_hashes.max_length() + 1));\n@@ -153,1 +168,0 @@\n-  return new StringDedupEntry();\n@@ -156,10 +170,4 @@\n-void StringDedupEntryCache::free(StringDedupEntry* entry, uint worker_id) {\n-  assert(entry->obj() != NULL, \"Double free\");\n-  assert(worker_id < _nlists, \"Invalid worker id\");\n-\n-  entry->set_obj(NULL);\n-  entry->set_hash(0);\n-\n-  if (_cached[worker_id].length() < _max_list_length) {\n-    \/\/ Cache is not full\n-    _cached[worker_id].add(entry);\n+void StringDedup::Table::Bucket::shrink() {\n+  if (_hashes.is_empty()) {\n+    _hashes.clear_and_deallocate();\n+    _values.clear_and_deallocate();\n@@ -167,2 +175,4 @@\n-    \/\/ Cache is full, add to overflow list for later deletion\n-    _overflowed[worker_id].add(entry);\n+    int target = needed_capacity(_hashes.length());\n+    if (target < _hashes.max_length()) {\n+      adjust_capacity(target);\n+    }\n@@ -172,4 +182,12 @@\n-size_t StringDedupEntryCache::size() {\n-  size_t size = 0;\n-  for (size_t i = 0; i < _nlists; i++) {\n-    size += _cached[i].length();\n+StringDedup::Table::TableValue\n+StringDedup::Table::Bucket::find(typeArrayOop obj, uint hash_code) const {\n+  int index = 0;\n+  for (uint cur_hash : _hashes) {\n+    if (cur_hash == hash_code) {\n+      typeArrayOop value = cast_from_oop<typeArrayOop>(_values.at(index).peek());\n+      if ((value != nullptr) &&\n+          java_lang_String::value_equals(obj, value)) {\n+        return _values.at(index);\n+      }\n+    }\n+    ++index;\n@@ -177,1 +195,1 @@\n-  return size;\n+  return TableValue();\n@@ -180,3 +198,22 @@\n-void StringDedupEntryCache::delete_overflowed() {\n-  double start = os::elapsedTime();\n-  uintx count = 0;\n+void StringDedup::Table::Bucket::verify(size_t bucket_index,\n+                                        size_t bucket_count) const {\n+  int entry_count = _hashes.length();\n+  guarantee(entry_count == _values.length(),\n+            \"hash\/value length mismatch: %zu: %d, %d\",\n+            bucket_index, entry_count, _values.length());\n+  for (uint hash_code : _hashes) {\n+    size_t hash_index = hash_code % bucket_count;\n+    guarantee(bucket_index == hash_index,\n+              \"entry in wrong bucket: %zu, %u\", bucket_index, hash_code);\n+  }\n+  size_t index = 0;\n+  for (TableValue tv : _values) {\n+    guarantee(!tv.is_empty(), \"entry missing value: %zu:%zu\", bucket_index, index);\n+    const oop* p = tv.ptr_raw();\n+    OopStorage::EntryStatus status = _table_storage->allocation_status(p);\n+    guarantee(OopStorage::ALLOCATED_ENTRY == status,\n+              \"bad value: %zu:%zu -> \" PTR_FORMAT, bucket_index, index, p2i(p));\n+    \/\/ Don't check object is oop_or_null; duplicates OopStorage verify.\n+    ++index;\n+  }\n+}\n@@ -184,2 +221,37 @@\n-  for (size_t i = 0; i < _nlists; i++) {\n-    StringDedupEntry* entry;\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Tracking dead entries\n+\/\/\n+\/\/ Keeping track of the number of dead entries in a table is complicated by\n+\/\/ the possibility that a GC could be changing the set while we're removing\n+\/\/ dead entries.\n+\/\/\n+\/\/ If a dead count report is received while cleaning, further cleaning may\n+\/\/ reduce the number of dead entries.  With STW reference processing one\n+\/\/ could maintain an accurate dead count by deducting cleaned entries.  But\n+\/\/ that doesn't work for concurrent reference processsing.  In that case the\n+\/\/ dead count being reported may include entries that have already been\n+\/\/ removed by concurrent cleaning.\n+\/\/\n+\/\/ It seems worse to unnecessarily resize or clean than to delay either.  So\n+\/\/ we track whether the reported dead count is good, and only consider\n+\/\/ resizing or cleaning when we have a good idea of the benefit.\n+\n+enum class StringDedup::Table::DeadState {\n+  \/\/ This is the initial state.  This state is also selected when a dead\n+  \/\/ count report is received and the state is wait1.  The reported dead\n+  \/\/ count is considered good.  It might be lower than actual because of an\n+  \/\/ in-progress concurrent reference processing.  It might also increase\n+  \/\/ immediately due to a new GC.  Oh well to both of those.\n+  good,\n+  \/\/ This state is selected when a dead count report is received and the\n+  \/\/ state is wait2.  Current value of dead count may be inaccurate because\n+  \/\/ of reference processing that was started before or during the most\n+  \/\/ recent cleaning and finished after.  Wait for the next report.\n+  wait1,\n+  \/\/ This state is selected when a cleaning operation completes. Current\n+  \/\/ value of dead count is inaccurate because we haven't had a report\n+  \/\/ since the last cleaning.\n+  wait2,\n+  \/\/ Currently cleaning the table.\n+  cleaning\n+};\n@@ -187,7 +259,3 @@\n-    {\n-      \/\/ The overflow list can be modified during safepoints, therefore\n-      \/\/ we temporarily join the suspendible thread set while removing\n-      \/\/ all entries from the list.\n-      SuspendibleThreadSetJoiner sts_join;\n-      entry = _overflowed[i].remove_all();\n-    }\n+void StringDedup::Table::num_dead_callback(size_t num_dead) {\n+  \/\/ Lock while modifying dead count and state.\n+  MonitorLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n@@ -195,8 +263,4 @@\n-    \/\/ Delete all entries\n-    while (entry != NULL) {\n-      StringDedupEntry* next = entry->next();\n-      delete entry;\n-      entry = next;\n-      count++;\n-    }\n-  }\n+  switch (Atomic::load(&_dead_state)) {\n+  case DeadState::good:\n+    Atomic::store(&_dead_count, num_dead);\n+    break;\n@@ -204,85 +268,13 @@\n-  double end = os::elapsedTime();\n-  log_trace(gc, stringdedup)(\"Deleted \" UINTX_FORMAT \" entries, \" STRDEDUP_TIME_FORMAT_MS,\n-                             count, STRDEDUP_TIME_PARAM_MS(end - start));\n-}\n-\n-StringDedupTable*        StringDedupTable::_table = NULL;\n-StringDedupEntryCache*   StringDedupTable::_entry_cache = NULL;\n-\n-const size_t             StringDedupTable::_min_size = (1 << 10);   \/\/ 1024\n-const size_t             StringDedupTable::_max_size = (1 << 24);   \/\/ 16777216\n-const double             StringDedupTable::_grow_load_factor = 2.0; \/\/ Grow table at 200% load\n-const double             StringDedupTable::_shrink_load_factor = _grow_load_factor \/ 3.0; \/\/ Shrink table at 67% load\n-const double             StringDedupTable::_max_cache_factor = 0.1; \/\/ Cache a maximum of 10% of the table size\n-const uintx              StringDedupTable::_rehash_multiple = 60;   \/\/ Hash bucket has 60 times more collisions than expected\n-const uintx              StringDedupTable::_rehash_threshold = (uintx)(_rehash_multiple * _grow_load_factor);\n-\n-uintx                    StringDedupTable::_entries_added = 0;\n-volatile uintx           StringDedupTable::_entries_removed = 0;\n-uintx                    StringDedupTable::_resize_count = 0;\n-uintx                    StringDedupTable::_rehash_count = 0;\n-\n-StringDedupTable*        StringDedupTable::_resized_table = NULL;\n-StringDedupTable*        StringDedupTable::_rehashed_table = NULL;\n-volatile size_t          StringDedupTable::_claimed_index = 0;\n-\n-StringDedupTable::StringDedupTable(size_t size, uint64_t hash_seed) :\n-  _size(size),\n-  _entries(0),\n-  _shrink_threshold((uintx)(size * _shrink_load_factor)),\n-  _grow_threshold((uintx)(size * _grow_load_factor)),\n-  _rehash_needed(false),\n-  _hash_seed(hash_seed) {\n-  assert(is_power_of_2(size), \"Table size must be a power of 2\");\n-  _buckets = NEW_C_HEAP_ARRAY(StringDedupEntry*, _size, mtGC);\n-  memset(_buckets, 0, _size * sizeof(StringDedupEntry*));\n-}\n-\n-StringDedupTable::~StringDedupTable() {\n-  FREE_C_HEAP_ARRAY(StringDedupEntry*, _buckets);\n-}\n-\n-void StringDedupTable::create() {\n-  assert(_table == NULL, \"One string deduplication table allowed\");\n-  _entry_cache = new StringDedupEntryCache(_min_size * _max_cache_factor);\n-  _table = new StringDedupTable(_min_size);\n-}\n-\n-void StringDedupTable::add(typeArrayOop value, bool latin1, unsigned int hash, StringDedupEntry** list) {\n-  StringDedupEntry* entry = _entry_cache->alloc();\n-  entry->set_obj(value);\n-  entry->set_hash(hash);\n-  entry->set_latin1(latin1);\n-  entry->set_next(*list);\n-  *list = entry;\n-  _entries++;\n-}\n-\n-void StringDedupTable::remove(StringDedupEntry** pentry, uint worker_id) {\n-  StringDedupEntry* entry = *pentry;\n-  *pentry = entry->next();\n-  _entry_cache->free(entry, worker_id);\n-}\n-\n-void StringDedupTable::transfer(StringDedupEntry** pentry, StringDedupTable* dest) {\n-  StringDedupEntry* entry = *pentry;\n-  *pentry = entry->next();\n-  unsigned int hash = entry->hash();\n-  size_t index = dest->hash_to_index(hash);\n-  StringDedupEntry** list = dest->bucket(index);\n-  entry->set_next(*list);\n-  *list = entry;\n-}\n-\n-typeArrayOop StringDedupTable::lookup(typeArrayOop value, bool latin1, unsigned int hash,\n-                                      StringDedupEntry** list, uintx &count) {\n-  for (StringDedupEntry* entry = *list; entry != NULL; entry = entry->next()) {\n-    if (entry->hash() == hash && entry->latin1() == latin1) {\n-      oop* obj_addr = (oop*)entry->obj_addr();\n-      oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(obj_addr);\n-      if (obj != NULL && java_lang_String::value_equals(value, static_cast<typeArrayOop>(obj))) {\n-        obj = NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(obj_addr);\n-        return static_cast<typeArrayOop>(obj);\n-      }\n-    }\n-    count++;\n+  case DeadState::wait1:\n+    \/\/ Set count first, so dedup thread gets this or a later value if it\n+    \/\/ sees the good state.\n+    Atomic::store(&_dead_count, num_dead);\n+    Atomic::release_store(&_dead_state, DeadState::good);\n+    break;\n+\n+  case DeadState::wait2:\n+    Atomic::release_store(&_dead_state, DeadState::wait1);\n+    break;\n+\n+  case DeadState::cleaning:\n+    break;\n@@ -291,2 +283,3 @@\n-  \/\/ Not found\n-  return NULL;\n+  \/\/ Wake up a possibly sleeping dedup thread.  This callback is invoked at\n+  \/\/ the end of a GC, so there may be new requests waiting.\n+  ml.notify_all();\n@@ -295,4 +288,5 @@\n-typeArrayOop StringDedupTable::lookup_or_add_inner(typeArrayOop value, bool latin1, unsigned int hash) {\n-  size_t index = hash_to_index(hash);\n-  StringDedupEntry** list = bucket(index);\n-  uintx count = 0;\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ StringDedup::Table::CleanupState\n+\n+class StringDedup::Table::CleanupState : public CHeapObj<mtStringDedup> {\n+  NONCOPYABLE(CleanupState);\n@@ -300,2 +294,31 @@\n-  \/\/ Lookup in list\n-  typeArrayOop existing_value = lookup(value, latin1, hash, list, count);\n+protected:\n+  CleanupState() = default;\n+\n+public:\n+  virtual ~CleanupState() = default;\n+  virtual bool step() = 0;\n+  virtual TableValue find(typeArrayOop obj, uint hash_code) const = 0;\n+  virtual void report_end() const = 0;\n+  virtual Stat::Phase phase() const = 0;\n+  virtual void verify() const = 0;\n+};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ StringDedup::Table::Resizer\n+\n+class StringDedup::Table::Resizer final : public CleanupState {\n+  Bucket* _buckets;\n+  size_t _number_of_buckets;\n+  size_t _bucket_index;\n+  size_t _shrink_index;\n+\n+public:\n+  Resizer(bool grow_only, Bucket* buckets, size_t number_of_buckets) :\n+    _buckets(buckets),\n+    _number_of_buckets(number_of_buckets),\n+    _bucket_index(0),\n+    \/\/ Disable bucket shrinking if grow_only requested.\n+    _shrink_index(grow_only ? Table::_number_of_buckets : 0)\n+  {\n+    Table::_need_bucket_shrinking = !grow_only;\n+  }\n@@ -303,3 +326,2 @@\n-  \/\/ Check if rehash is needed\n-  if (count > _rehash_threshold) {\n-    _rehash_needed = true;\n+  virtual ~Resizer() {\n+    free_buckets(_buckets, _number_of_buckets);\n@@ -308,3 +330,1 @@\n-  if (existing_value == NULL) {\n-    \/\/ Not found, add new entry\n-    add(value, latin1, hash, list);\n+  virtual bool step();\n@@ -312,2 +332,2 @@\n-    \/\/ Update statistics\n-    _entries_added++;\n+  virtual TableValue find(typeArrayOop obj, uint hash_code) const {\n+    return _buckets[hash_code % _number_of_buckets].find(obj, hash_code);\n@@ -316,2 +336,3 @@\n-  return existing_value;\n-}\n+  virtual void report_end() const {\n+    _cur_stat.report_resize_table_end();\n+  }\n@@ -319,7 +340,14 @@\n-unsigned int StringDedupTable::hash_code(typeArrayOop value, bool latin1) {\n-  unsigned int hash;\n-  int length = value->length();\n-  if (latin1) {\n-    const jbyte* data = (jbyte*)value->base(T_BYTE);\n-    if (use_java_hash()) {\n-      hash = java_lang_String::hash_code(data, length);\n+  virtual Stat::Phase phase() const {\n+    return Stat::Phase::resize_table;\n+  }\n+\n+  virtual void verify() const;\n+};\n+\n+bool StringDedup::Table::Resizer::step() {\n+  if (_bucket_index < _number_of_buckets) {\n+    Bucket& bucket = _buckets[_bucket_index];\n+    if (bucket.is_empty()) {\n+      bucket.shrink();          \/\/ Eagerly release old bucket memory.\n+      ++_bucket_index;\n+      return true;              \/\/ Continue transferring with next bucket.\n@@ -327,1 +355,10 @@\n-      hash = AltHashing::halfsiphash_32(_table->_hash_seed, (const uint8_t*)data, length);\n+      uint hash_code = bucket.hashes().last();\n+      TableValue tv = bucket.values().last();\n+      bucket.pop_norelease();\n+      if (tv.peek() != nullptr) {\n+        Table::add(tv, hash_code);\n+      } else {\n+        tv.release(_table_storage);\n+        _cur_stat.inc_deleted();\n+      }\n+      return true;              \/\/ Continue transferring current bucket.\n@@ -329,0 +366,7 @@\n+  } else if (_shrink_index < Table::_number_of_buckets) {\n+    \/\/ When the new buckets were created, space was reserved based on the\n+    \/\/ expected number of entries per bucket.  But that might be off for any\n+    \/\/ given bucket.  Some will have exceeded that and have been grown as\n+    \/\/ needed by the insertions.  But some might be less and can be shrunk.\n+    Table::_buckets[_shrink_index++].shrink();\n+    return true;                \/\/ Continue shrinking with next bucket.\n@@ -330,7 +374,1 @@\n-    length \/= sizeof(jchar) \/ sizeof(jbyte); \/\/ Convert number of bytes to number of chars\n-    const jchar* data = (jchar*)value->base(T_CHAR);\n-    if (use_java_hash()) {\n-      hash = java_lang_String::hash_code(data, length);\n-    } else {\n-      hash = AltHashing::halfsiphash_32(_table->_hash_seed, (const uint16_t*)data, length);\n-    }\n+    return false;               \/\/ All buckets transferred and shrunk, so done.\n@@ -338,0 +376,1 @@\n+}\n@@ -339,1 +378,4 @@\n-  return hash;\n+void StringDedup::Table::Resizer::verify() const {\n+  for (size_t i = 0; i < _number_of_buckets; ++i) {\n+    _buckets[i].verify(i, _number_of_buckets);\n+  }\n@@ -342,3 +384,2 @@\n-void StringDedupTable::deduplicate(oop java_string, StringDedupStat* stat) {\n-  assert(java_lang_String::is_instance(java_string), \"Must be a string\");\n-  NoSafepointVerifier nsv;\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ StringDedup::Table::Cleaner\n@@ -346,1 +387,3 @@\n-  stat->inc_inspected();\n+class StringDedup::Table::Cleaner final : public CleanupState {\n+  size_t _bucket_index;\n+  int _entry_index;\n@@ -348,5 +391,3 @@\n-  typeArrayOop value = java_lang_String::value(java_string);\n-  if (value == NULL) {\n-    \/\/ String has no value\n-    stat->inc_skipped();\n-    return;\n+public:\n+  Cleaner() : _bucket_index(0), _entry_index(0) {\n+    Table::_need_bucket_shrinking = false;\n@@ -355,2 +396,1 @@\n-  bool latin1 = java_lang_String::is_latin1(java_string);\n-  unsigned int hash = 0;\n+  virtual ~Cleaner() = default;\n@@ -358,9 +398,8 @@\n-  if (use_java_hash()) {\n-    if (!java_lang_String::hash_is_set(java_string)) {\n-      stat->inc_hashed();\n-    }\n-    hash = java_lang_String::hash_code(java_string);\n-  } else {\n-    \/\/ Compute hash\n-    hash = hash_code(value, latin1);\n-    stat->inc_hashed();\n+  virtual bool step();\n+\n+  virtual TableValue find(typeArrayOop obj, uint hash_code) const {\n+    return TableValue();\n+  }\n+\n+  virtual void report_end() const {\n+    _cur_stat.report_cleanup_table_end();\n@@ -369,5 +408,2 @@\n-  typeArrayOop existing_value = lookup_or_add(value, latin1, hash);\n-  if (existing_value == value) {\n-    \/\/ Same value, already known\n-    stat->inc_known();\n-    return;\n+  virtual Stat::Phase phase() const {\n+    return Stat::Phase::cleanup_table;\n@@ -376,3 +412,2 @@\n-  \/\/ Get size of value array\n-  uintx size_in_bytes = value->size() * HeapWordSize;\n-  stat->inc_new(size_in_bytes);\n+  virtual void verify() const {} \/\/ Nothing to do here.\n+};\n@@ -380,4 +415,21 @@\n-  if (existing_value != NULL) {\n-    \/\/ Existing value found, deduplicate string\n-    java_lang_String::set_value(java_string, existing_value);\n-    stat->deduped(value, size_in_bytes);\n+bool StringDedup::Table::Cleaner::step() {\n+  if (_bucket_index == Table::_number_of_buckets) {\n+    return false;               \/\/ All buckets processed, so done.\n+  }\n+  Bucket& bucket = Table::_buckets[_bucket_index];\n+  const GrowableArrayView<TableValue>& values = bucket.values();\n+  assert(_entry_index <= values.length(), \"invariant\");\n+  if (_entry_index == values.length()) {\n+    \/\/ End of current bucket.  Shrink the bucket if oversized for current\n+    \/\/ usage, and continue at the start of the next bucket.\n+    bucket.shrink();\n+    ++_bucket_index;\n+    _entry_index = 0;\n+  } else if (values.at(_entry_index).peek() == nullptr) {\n+    \/\/ Current entry is dead.  Remove and continue at same index.\n+    bucket.delete_at(_entry_index);\n+    --Table::_number_of_entries;\n+    _cur_stat.inc_deleted();\n+  } else {\n+    \/\/ Current entry is live.  Continue with the next entry.\n+    ++_entry_index;\n@@ -385,0 +437,1 @@\n+  return true;\n@@ -387,2 +440,16 @@\n-bool StringDedupTable::is_resizing() {\n-  return _resized_table != NULL;\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ StringDedup::Table\n+\n+OopStorage* StringDedup::Table::_table_storage;\n+StringDedup::Table::Bucket* StringDedup::Table::_buckets;\n+size_t StringDedup::Table::_number_of_buckets;\n+size_t StringDedup::Table::_number_of_entries = 0;\n+size_t StringDedup::Table::_grow_threshold;\n+StringDedup::Table::CleanupState* StringDedup::Table::_cleanup_state = nullptr;\n+bool StringDedup::Table::_need_bucket_shrinking = false;\n+volatile size_t StringDedup::Table::_dead_count = 0;\n+volatile StringDedup::Table::DeadState StringDedup::Table::_dead_state = DeadState::good;\n+\n+void StringDedup::Table::initialize_storage() {\n+  assert(_table_storage == nullptr, \"storage already created\");\n+  _table_storage = OopStorageSet::create_weak(\"StringDedup Table Weak\", mtStringDedup);\n@@ -391,2 +458,6 @@\n-bool StringDedupTable::is_rehashing() {\n-  return _rehashed_table != NULL;\n+void StringDedup::Table::initialize() {\n+  size_t num_buckets = Config::initial_table_size();\n+  _buckets = make_buckets(num_buckets);\n+  _number_of_buckets = num_buckets;\n+  _grow_threshold = Config::grow_threshold(num_buckets);\n+  _table_storage->register_num_dead_callback(num_dead_callback);\n@@ -395,26 +466,6 @@\n-StringDedupTable* StringDedupTable::prepare_resize() {\n-  size_t size = _table->_size;\n-\n-  \/\/ Decide whether to resize, and compute desired new size if so.\n-  if (_table->_entries > _table->_grow_threshold) {\n-    \/\/ Compute new size.\n-    size_t needed = _table->_entries \/ _grow_load_factor;\n-    if (needed < _max_size) {\n-      size = round_up_power_of_2(needed);\n-    } else {\n-      size = _max_size;\n-    }\n-  } else if (_table->_entries < _table->_shrink_threshold) {\n-    \/\/ Compute new size.  We can't shrink by more than a factor of 2,\n-    \/\/ because the partitioning for parallelization doesn't support more.\n-    if (size > _min_size) size \/= 2;\n-  }\n-  \/\/ If no change in size needed (and not forcing resize) then done.\n-  if (size == _table->_size) {\n-    if (!StringDeduplicationResizeALot) {\n-      return NULL;              \/\/ Don't resize.\n-    } else if (size < _max_size) {\n-      size *= 2;                \/\/ Force grow, but not past _max_size.\n-    } else {\n-      size \/= 2;                \/\/ Can't force grow, so force shrink instead.\n-    }\n+StringDedup::Table::Bucket*\n+StringDedup::Table::make_buckets(size_t number_of_buckets, size_t reserve) {\n+  Bucket* buckets = NEW_C_HEAP_ARRAY(Bucket, number_of_buckets, mtStringDedup);\n+  for (size_t i = 0; i < number_of_buckets; ++i) {\n+    \/\/ Cast because GrowableArray uses int for sizes and such.\n+    ::new (&buckets[i]) Bucket(static_cast<int>(reserve));\n@@ -422,6 +473,2 @@\n-  assert(size <= _max_size, \"invariant: %zu\", size);\n-  assert(size >= _min_size, \"invariant: %zu\", size);\n-  assert(is_power_of_2(size), \"invariant: %zu\", size);\n-\n-  \/\/ Update statistics\n-  _resize_count++;\n+  return buckets;\n+}\n@@ -429,2 +476,6 @@\n-  \/\/ Update max cache size\n-  _entry_cache->set_max_size(size * _max_cache_factor);\n+void StringDedup::Table::free_buckets(Bucket* buckets, size_t number_of_buckets) {\n+  while (number_of_buckets > 0) {\n+    buckets[--number_of_buckets].~Bucket();\n+  }\n+  FREE_C_HEAP_ARRAY(Bucket, buckets);\n+}\n@@ -432,3 +483,9 @@\n-  \/\/ Allocate the new table. The new table will be populated by workers\n-  \/\/ calling unlink_or_oops_do() and finally installed by finish_resize().\n-  return new StringDedupTable(size, _table->_hash_seed);\n+\/\/ Compute the hash code for obj using halfsiphash_32.  As this is a high\n+\/\/ quality hash function that is resistant to hashtable flooding, very\n+\/\/ unbalanced bucket chains should be rare, and duplicate hash codes within\n+\/\/ a bucket should be very rare.\n+uint StringDedup::Table::compute_hash(typeArrayOop obj) {\n+  int length = obj->length();\n+  uint64_t hash_seed = Config::hash_seed();\n+  const uint8_t* data = static_cast<uint8_t*>(obj->base(T_BYTE));\n+  return AltHashing::halfsiphash_32(hash_seed, data, length);\n@@ -437,2 +494,3 @@\n-void StringDedupTable::finish_resize(StringDedupTable* resized_table) {\n-  assert(resized_table != NULL, \"Invalid table\");\n+size_t StringDedup::Table::hash_to_index(uint hash_code) {\n+  return hash_code % _number_of_buckets;\n+}\n@@ -440,1 +498,4 @@\n-  resized_table->_entries = _table->_entries;\n+void StringDedup::Table::add(TableValue tv, uint hash_code) {\n+  _buckets[hash_to_index(hash_code)].add(hash_code, tv);\n+  ++_number_of_entries;\n+}\n@@ -442,2 +503,3 @@\n-  \/\/ Free old table\n-  delete _table;\n+bool StringDedup::Table::is_dead_count_good_acquire() {\n+  return Atomic::load_acquire(&_dead_state) == DeadState::good;\n+}\n@@ -445,2 +507,4 @@\n-  \/\/ Install new table\n-  _table = resized_table;\n+\/\/ Should be consistent with cleanup_start_if_needed.\n+bool StringDedup::Table::is_grow_needed() {\n+  return is_dead_count_good_acquire() &&\n+         ((_number_of_entries - Atomic::load(&_dead_count)) > _grow_threshold);\n@@ -449,13 +513,5 @@\n-void StringDedupTable::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl, uint worker_id) {\n-  \/\/ The table is divided into partitions to allow lock-less parallel processing by\n-  \/\/ multiple worker threads. A worker thread first claims a partition, which ensures\n-  \/\/ exclusive access to that part of the table, then continues to process it. To allow\n-  \/\/ shrinking of the table in parallel we also need to make sure that the same worker\n-  \/\/ thread processes all partitions where entries will hash to the same destination\n-  \/\/ partition. Since the table size is always a power of two and we always shrink by\n-  \/\/ dividing the table in half, we know that for a given partition there is only one\n-  \/\/ other partition whoes entries will hash to the same destination partition. That\n-  \/\/ other partition is always the sibling partition in the second half of the table.\n-  \/\/ For example, if the table is divided into 8 partitions, the sibling of partition 0\n-  \/\/ is partition 4, the sibling of partition 1 is partition 5, etc.\n-  size_t table_half = _table->_size \/ 2;\n+\/\/ Should be consistent with cleanup_start_if_needed.\n+bool StringDedup::Table::is_dead_entry_removal_needed() {\n+  return is_dead_count_good_acquire() &&\n+         Config::should_cleanup_table(_number_of_entries, Atomic::load(&_dead_count));\n+}\n@@ -463,3 +519,9 @@\n-  \/\/ Let each partition be one page worth of buckets\n-  size_t partition_size = MIN2(table_half, os::vm_page_size() \/ sizeof(StringDedupEntry*));\n-  assert(table_half % partition_size == 0, \"Invalid partition size\");\n+StringDedup::Table::TableValue\n+StringDedup::Table::find(typeArrayOop obj, uint hash_code) {\n+  assert(obj != nullptr, \"precondition\");\n+  if (_cleanup_state != nullptr) {\n+    TableValue tv = _cleanup_state->find(obj, hash_code);\n+    if (!tv.is_empty()) return tv;\n+  }\n+  return _buckets[hash_to_index(hash_code)].find(obj, hash_code);\n+}\n@@ -467,2 +529,4 @@\n-  \/\/ Number of entries removed during the scan\n-  uintx removed = 0;\n+void StringDedup::Table::install(typeArrayOop obj, uint hash_code) {\n+  add(TableValue(_table_storage, obj), hash_code);\n+  _cur_stat.inc_new(obj->size() * HeapWordSize);\n+}\n@@ -470,8 +534,1 @@\n-  for (;;) {\n-    \/\/ Grab next partition to scan\n-    size_t partition_begin = claim_table_partition(partition_size);\n-    size_t partition_end = partition_begin + partition_size;\n-    if (partition_begin >= table_half) {\n-      \/\/ End of table\n-      break;\n-    }\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -479,50 +536,28 @@\n-    \/\/ Scan the partition followed by the sibling partition in the second half of the table\n-    removed += unlink_or_oops_do(cl, partition_begin, partition_end, worker_id);\n-    removed += unlink_or_oops_do(cl, table_half + partition_begin, table_half + partition_end, worker_id);\n-  }\n-\n-  \/\/ Do atomic update here instead of taking StringDedupTable_lock. This allows concurrent\n-  \/\/ cleanup when multiple workers are cleaning up the table, while the mutators are blocked\n-  \/\/ on StringDedupTable_lock.\n-  if (removed > 0) {\n-    assert_locked_or_safepoint_weak(StringDedupTable_lock);\n-    Atomic::sub(&_table->_entries, removed);\n-    Atomic::add(&_entries_removed, removed);\n-  }\n-}\n-\n-uintx StringDedupTable::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl,\n-                                          size_t partition_begin,\n-                                          size_t partition_end,\n-                                          uint worker_id) {\n-  uintx removed = 0;\n-  for (size_t bucket = partition_begin; bucket < partition_end; bucket++) {\n-    StringDedupEntry** entry = _table->bucket(bucket);\n-    while (*entry != NULL) {\n-      oop* p = (oop*)(*entry)->obj_addr();\n-      if (cl->is_alive(*p)) {\n-        cl->keep_alive(p);\n-        if (is_resizing()) {\n-          \/\/ We are resizing the table, transfer entry to the new table\n-          _table->transfer(entry, _resized_table);\n-        } else {\n-          if (is_rehashing()) {\n-            \/\/ We are rehashing the table, rehash the entry but keep it\n-            \/\/ in the table. We can't transfer entries into the new table\n-            \/\/ at this point since we don't have exclusive access to all\n-            \/\/ destination partitions. finish_rehash() will do a single\n-            \/\/ threaded transfer of all entries.\n-            typeArrayOop value = (typeArrayOop)*p;\n-            bool latin1 = (*entry)->latin1();\n-            unsigned int hash = hash_code(value, latin1);\n-            (*entry)->set_hash(hash);\n-          }\n-\n-          \/\/ Move to next entry\n-          entry = (*entry)->next_addr();\n-        }\n-      } else {\n-        \/\/ Not alive, remove entry from table\n-        _table->remove(entry, worker_id);\n-        removed++;\n-      }\n+\/\/ Try to look up the string's value array in the shared string table.  This\n+\/\/ is only worthwhile if sharing is enabled, both at build-time and at\n+\/\/ runtime.  But it's complicated because we can't trust the is_latin1 value\n+\/\/ of the string we're deduplicating.  GC requests can provide us with\n+\/\/ access to a String that is incompletely constructed; the value could be\n+\/\/ set before the coder.\n+bool StringDedup::Table::try_deduplicate_shared(oop java_string) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  assert(value != nullptr, \"precondition\");\n+  assert(TypeArrayKlass::cast(value->klass())->element_type() == T_BYTE, \"precondition\");\n+  int length = value->length();\n+  static_assert(sizeof(jchar) == 2 * sizeof(jbyte), \"invariant\");\n+  assert(((length & 1) == 0) || CompactStrings, \"invariant\");\n+  if ((length & 1) == 0) {\n+    \/\/ If the length of the byte array is even, then the value array could be\n+    \/\/ either non-latin1 or a compact latin1 that happens to have an even length.\n+    \/\/ For the former case we want to look for a matching shared string.  But\n+    \/\/ for the latter we can still do a lookup, treating the value array as\n+    \/\/ non-latin1, and deduplicating if we find a match.  For deduplication we\n+    \/\/ only care if the arrays consist of the same sequence of bytes.\n+    const jchar* chars = static_cast<jchar*>(value->base(T_CHAR));\n+    oop found = StringTable::lookup_shared(chars, length >> 1);\n+    \/\/ If found is latin1, then it's byte array differs from the unicode\n+    \/\/ table key, so not actually a match to value.\n+    if ((found != nullptr) &&\n+        !java_lang_String::is_latin1(found) &&\n+        try_deduplicate_found_shared(java_string, found)) {\n+      return true;\n@@ -530,0 +565,12 @@\n+    \/\/ That didn't work.  Try as compact latin1.\n+  }\n+  \/\/ If not using compact strings then don't need to check further.\n+  if (!CompactStrings) return false;\n+  \/\/ Treat value as compact latin1 and try to deduplicate against that.\n+  \/\/ This works even if java_string is not latin1, but has a byte array with\n+  \/\/ the same sequence of bytes as a compact latin1 shared string.\n+  ResourceMark rm(Thread::current());\n+  jchar* chars = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);\n+  if (chars == nullptr) {\n+    _cur_stat.inc_skipped_shared();\n+    return true;\n@@ -531,0 +578,8 @@\n+  for (int i = 0; i < length; ++i) {\n+    chars[i] = value->byte_at(i) & 0xff;\n+  }\n+  oop found = StringTable::lookup_shared(chars, length);\n+  if (found == nullptr) return false;\n+  assert(java_lang_String::is_latin1(found), \"invariant\");\n+  return try_deduplicate_found_shared(java_string, found);\n+}\n@@ -532,1 +587,22 @@\n-  return removed;\n+bool StringDedup::Table::try_deduplicate_found_shared(oop java_string, oop found) {\n+  _cur_stat.inc_known_shared();\n+  typeArrayOop found_value = java_lang_String::value(found);\n+  if (found_value == java_lang_String::value(java_string)) {\n+    \/\/ String's value already matches what's in the table.\n+    return true;\n+  } else if (deduplicate_if_permitted(java_string, found_value)) {\n+    \/\/ If java_string has the same coder as found then it won't have\n+    \/\/ deduplication_forbidden set; interning would have found the matching\n+    \/\/ shared string.  But if they have different coders but happen to have\n+    \/\/ the same sequence of bytes in their value arrays, then java_string\n+    \/\/ could have been interned and marked deduplication-forbidden.\n+    _cur_stat.inc_deduped(found_value->size() * HeapWordSize);\n+    return true;\n+  } else {\n+    \/\/ Must be a mismatch between java_string and found string encodings,\n+    \/\/ and java_string has been marked deduplication_forbidden, so is\n+    \/\/ (being) interned in the StringTable.  Return false to allow\n+    \/\/ additional processing that might still lead to some benefit for\n+    \/\/ deduplication.\n+    return false;\n+  }\n@@ -535,2 +611,1 @@\n-void StringDedupTable::gc_prologue(bool resize_and_rehash_table) {\n-  assert(!is_resizing() && !is_rehashing(), \"Already in progress?\");\n+#else \/\/ if !INCLUDE_CDS_JAVA_HEAP\n@@ -538,9 +613,3 @@\n-  _claimed_index = 0;\n-  if (resize_and_rehash_table) {\n-    \/\/ If both resize and rehash is needed, only do resize. Rehash of\n-    \/\/ the table will eventually happen if the situation persists.\n-    _resized_table = StringDedupTable::prepare_resize();\n-    if (!is_resizing()) {\n-      _rehashed_table = StringDedupTable::prepare_rehash();\n-    }\n-  }\n+bool StringDedup::Table::try_deduplicate_shared(oop java_string) {\n+  ShouldNotReachHere();         \/\/ Call is guarded.\n+  return false;\n@@ -549,3 +618,2 @@\n-void StringDedupTable::gc_epilogue() {\n-  assert(!is_resizing() || !is_rehashing(), \"Can not both resize and rehash\");\n-  assert(_claimed_index >= _table->_size \/ 2 || _claimed_index == 0, \"All or nothing\");\n+\/\/ Undefined because unreferenced.\n+\/\/ bool StringDedup::Table::try_deduplicate_found_shared(oop java_string, oop found);\n@@ -553,6 +621,11 @@\n-  if (is_resizing()) {\n-    StringDedupTable::finish_resize(_resized_table);\n-    _resized_table = NULL;\n-  } else if (is_rehashing()) {\n-    StringDedupTable::finish_rehash(_rehashed_table);\n-    _rehashed_table = NULL;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n+bool StringDedup::Table::deduplicate_if_permitted(oop java_string,\n+                                                  typeArrayOop value) {\n+  \/\/ The non-dedup check and value assignment must be under lock.\n+  MutexLocker ml(StringDedupIntern_lock, Mutex::_no_safepoint_check_flag);\n+  if (java_lang_String::deduplication_forbidden(java_string)) {\n+    return false;\n+  } else {\n+    java_lang_String::set_value(java_string, value); \/\/ Dedup!\n+    return true;\n@@ -562,4 +635,6 @@\n-StringDedupTable* StringDedupTable::prepare_rehash() {\n-  if (!_table->_rehash_needed && !StringDeduplicationRehashALot) {\n-    \/\/ Rehash not needed\n-    return NULL;\n+void StringDedup::Table::deduplicate(oop java_string) {\n+  assert(java_lang_String::is_instance(java_string), \"precondition\");\n+  _cur_stat.inc_inspected();\n+  if ((StringTable::shared_entry_count() > 0) &&\n+      try_deduplicate_shared(java_string)) {\n+    return;                     \/\/ Done if deduplicated against shared StringTable.\n@@ -567,0 +642,26 @@\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  uint hash_code = compute_hash(value);\n+  TableValue tv = find(value, hash_code);\n+  if (tv.is_empty()) {\n+    \/\/ Not in table.  Create a new table entry.\n+    install(value, hash_code);\n+  } else {\n+    _cur_stat.inc_known();\n+    typeArrayOop found = cast_from_oop<typeArrayOop>(tv.resolve());\n+    assert(found != nullptr, \"invariant\");\n+    \/\/ Deduplicate if value array differs from what's in the table.\n+    if (found != value) {\n+      if (deduplicate_if_permitted(java_string, found)) {\n+        _cur_stat.inc_deduped(found->size() * HeapWordSize);\n+      } else {\n+        \/\/ If string marked deduplication_forbidden then we can't update its\n+        \/\/ value.  Instead, replace the array in the table with the new one,\n+        \/\/ as java_string is probably in the StringTable.  That makes it a\n+        \/\/ good target for future deduplications as it is probably intended\n+        \/\/ to live for some time.\n+        tv.replace(value);\n+        _cur_stat.inc_replaced();\n+      }\n+    }\n+  }\n+}\n@@ -568,5 +669,27 @@\n-  \/\/ Update statistics\n-  _rehash_count++;\n-\n-  \/\/ Compute new hash seed\n-  _table->_hash_seed = AltHashing::compute_seed();\n+bool StringDedup::Table::cleanup_start_if_needed(bool grow_only, bool force) {\n+  assert(_cleanup_state == nullptr, \"cleanup already in progress\");\n+  if (!is_dead_count_good_acquire()) return false;\n+  \/\/ If dead count is good then we can read it once and use it below\n+  \/\/ without needing any locking.  The recorded count could increase\n+  \/\/ after the read, but that's okay.\n+  size_t dead_count = Atomic::load(&_dead_count);\n+  \/\/ This assertion depends on dead state tracking.  Otherwise, concurrent\n+  \/\/ reference processing could detect some, but a cleanup operation could\n+  \/\/ remove them before they are reported.\n+  assert(dead_count <= _number_of_entries, \"invariant\");\n+  size_t adjusted = _number_of_entries - dead_count;\n+  if (force || Config::should_grow_table(_number_of_buckets, adjusted)) {\n+    return start_resizer(grow_only, adjusted);\n+  } else if (grow_only) {\n+    return false;\n+  } else if (Config::should_shrink_table(_number_of_buckets, adjusted)) {\n+    return start_resizer(false \/* grow_only *\/, adjusted);\n+  } else if (_need_bucket_shrinking ||\n+             Config::should_cleanup_table(_number_of_entries, dead_count)) {\n+    \/\/ Remove dead entries and shrink buckets if needed.\n+    return start_cleaner(_number_of_entries, dead_count);\n+  } else {\n+    \/\/ No cleanup needed.\n+    return false;\n+  }\n+}\n@@ -574,2 +697,4 @@\n-  \/\/ Allocate the new table, same size and hash seed\n-  return new StringDedupTable(_table->_size, _table->_hash_seed);\n+void StringDedup::Table::set_dead_state_cleaning() {\n+  MutexLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n+  Atomic::store(&_dead_count, size_t(0));\n+  Atomic::store(&_dead_state, DeadState::cleaning);\n@@ -578,2 +703,12 @@\n-void StringDedupTable::finish_rehash(StringDedupTable* rehashed_table) {\n-  assert(rehashed_table != NULL, \"Invalid table\");\n+bool StringDedup::Table::start_resizer(bool grow_only, size_t number_of_entries) {\n+  size_t new_size = Config::desired_table_size(number_of_entries);\n+  _cur_stat.report_resize_table_start(new_size, _number_of_buckets, number_of_entries);\n+  _cleanup_state = new Resizer(grow_only, _buckets, _number_of_buckets);\n+  size_t reserve = Bucket::needed_capacity(checked_cast<int>(number_of_entries \/ new_size));\n+  _buckets = make_buckets(new_size, reserve);\n+  _number_of_buckets = new_size;\n+  _number_of_entries = 0;\n+  _grow_threshold = Config::grow_threshold(new_size);\n+  set_dead_state_cleaning();\n+  return true;\n+}\n@@ -581,7 +716,6 @@\n-  \/\/ Move all newly rehashed entries into the correct buckets in the new table\n-  for (size_t bucket = 0; bucket < _table->_size; bucket++) {\n-    StringDedupEntry** entry = _table->bucket(bucket);\n-    while (*entry != NULL) {\n-      _table->transfer(entry, rehashed_table);\n-    }\n-  }\n+bool StringDedup::Table::start_cleaner(size_t number_of_entries, size_t dead_count) {\n+  _cur_stat.report_cleanup_table_start(number_of_entries, dead_count);\n+  _cleanup_state = new Cleaner();\n+  set_dead_state_cleaning();\n+  return true;\n+}\n@@ -589,1 +723,4 @@\n-  rehashed_table->_entries = _table->_entries;\n+bool StringDedup::Table::cleanup_step() {\n+  assert(_cleanup_state != nullptr, \"precondition\");\n+  return _cleanup_state->step();\n+}\n@@ -591,2 +728,8 @@\n-  \/\/ Free old table\n-  delete _table;\n+void StringDedup::Table::cleanup_end() {\n+  assert(_cleanup_state != nullptr, \"precondition\");\n+  _cleanup_state->report_end();\n+  delete _cleanup_state;\n+  _cleanup_state = nullptr;\n+  MutexLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n+  Atomic::store(&_dead_state, DeadState::wait2);\n+}\n@@ -594,2 +737,3 @@\n-  \/\/ Install new table\n-  _table = rehashed_table;\n+StringDedup::Stat::Phase StringDedup::Table::cleanup_phase() {\n+  assert(_cleanup_state != nullptr, \"precondition\");\n+  return _cleanup_state->phase();\n@@ -598,2 +742,12 @@\n-size_t StringDedupTable::claim_table_partition(size_t partition_size) {\n-  return Atomic::fetch_and_add(&_claimed_index, partition_size);\n+void StringDedup::Table::verify() {\n+  size_t total_count = 0;\n+  for (size_t i = 0; i < _number_of_buckets; ++i) {\n+    _buckets[i].verify(i, _number_of_buckets);\n+    total_count += _buckets[i].length();\n+  }\n+  guarantee(total_count == _number_of_entries,\n+            \"number of values mismatch: %zu counted, %zu recorded\",\n+            total_count, _number_of_entries);\n+  if (_cleanup_state != nullptr) {\n+    _cleanup_state->verify();\n+  }\n@@ -602,15 +756,19 @@\n-void StringDedupTable::verify() {\n-  for (size_t bucket = 0; bucket < _table->_size; bucket++) {\n-    \/\/ Verify entries\n-    StringDedupEntry** entry = _table->bucket(bucket);\n-    while (*entry != NULL) {\n-      typeArrayOop value = (*entry)->obj();\n-      guarantee(value != NULL, \"Object must not be NULL\");\n-      guarantee(Universe::heap()->is_in(value), \"Object must be on the heap\");\n-      guarantee(!value->is_forwarded(), \"Object must not be forwarded\");\n-      guarantee(value->is_typeArray(), \"Object must be a typeArrayOop\");\n-      bool latin1 = (*entry)->latin1();\n-      unsigned int hash = hash_code(value, latin1);\n-      guarantee((*entry)->hash() == hash, \"Table entry has inorrect hash\");\n-      guarantee(_table->hash_to_index(hash) == bucket, \"Table entry has incorrect index\");\n-      entry = (*entry)->next_addr();\n+void StringDedup::Table::log_statistics() {\n+  size_t dead_count;\n+  int dead_state;\n+  {\n+    MutexLocker ml(StringDedup_lock, Mutex::_no_safepoint_check_flag);\n+    dead_count = _dead_count;\n+    dead_state = static_cast<int>(_dead_state);\n+  }\n+  log_debug(stringdedup)(\"Table: %zu values in %zu buckets, %zu dead (%d)\",\n+                         _number_of_entries, _number_of_buckets,\n+                         dead_count, dead_state);\n+  LogStreamHandle(Trace, stringdedup) log;\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    GrowableArray<size_t> counts;\n+    for (size_t i = 0; i < _number_of_buckets; ++i) {\n+      int length = _buckets[i].length();\n+      size_t count = counts.at_grow(length);\n+      counts.at_put(length, count + 1);\n@@ -618,15 +776,5 @@\n-\n-    \/\/ Verify that we do not have entries with identical oops or identical arrays.\n-    \/\/ We only need to compare entries in the same bucket. If the same oop or an\n-    \/\/ identical array has been inserted more than once into different\/incorrect\n-    \/\/ buckets the verification step above will catch that.\n-    StringDedupEntry** entry1 = _table->bucket(bucket);\n-    while (*entry1 != NULL) {\n-      typeArrayOop value1 = (*entry1)->obj();\n-      bool latin1_1 = (*entry1)->latin1();\n-      StringDedupEntry** entry2 = (*entry1)->next_addr();\n-      while (*entry2 != NULL) {\n-        typeArrayOop value2 = (*entry2)->obj();\n-        bool latin1_2 = (*entry2)->latin1();\n-        guarantee(latin1_1 != latin1_2 || !java_lang_String::value_equals(value1, value2), \"Table entries must not have identical arrays\");\n-        entry2 = (*entry2)->next_addr();\n+    log.print_cr(\"Table bucket distribution:\");\n+    for (int i = 0; i < counts.length(); ++i) {\n+      size_t count = counts.at(i);\n+      if (count != 0) {\n+        log.print_cr(\"  %4d: %zu\", i, count);\n@@ -634,1 +782,0 @@\n-      entry1 = (*entry1)->next_addr();\n@@ -638,18 +785,0 @@\n-\n-void StringDedupTable::clean_entry_cache() {\n-  _entry_cache->delete_overflowed();\n-}\n-\n-void StringDedupTable::print_statistics() {\n-  Log(gc, stringdedup) log;\n-  log.debug(\"  Table\");\n-  log.debug(\"    Memory Usage: \" STRDEDUP_BYTES_FORMAT_NS,\n-            STRDEDUP_BYTES_PARAM(_table->_size * sizeof(StringDedupEntry*) + (_table->_entries + _entry_cache->size()) * sizeof(StringDedupEntry)));\n-  log.debug(\"    Size: \" SIZE_FORMAT \", Min: \" SIZE_FORMAT \", Max: \" SIZE_FORMAT, _table->_size, _min_size, _max_size);\n-  log.debug(\"    Entries: \" UINTX_FORMAT \", Load: \" STRDEDUP_PERCENT_FORMAT_NS \", Cached: \" UINTX_FORMAT \", Added: \" UINTX_FORMAT \", Removed: \" UINTX_FORMAT,\n-            _table->_entries, percent_of((size_t)_table->_entries, _table->_size), _entry_cache->size(), _entries_added, _entries_removed);\n-  log.debug(\"    Resize Count: \" UINTX_FORMAT \", Shrink Threshold: \" UINTX_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT_NS \"), Grow Threshold: \" UINTX_FORMAT \"(\" STRDEDUP_PERCENT_FORMAT_NS \")\",\n-            _resize_count, _table->_shrink_threshold, _shrink_load_factor * 100.0, _table->_grow_threshold, _grow_load_factor * 100.0);\n-  log.debug(\"    Rehash Count: \" UINTX_FORMAT \", Rehash Threshold: \" UINTX_FORMAT \", Hash Seed: \" UINT64_FORMAT, _rehash_count, _rehash_threshold, _table->_hash_seed);\n-  log.debug(\"    Age Threshold: \" UINTX_FORMAT, StringDeduplicationAgeThreshold);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupTable.cpp","additions":633,"deletions":504,"binary":false,"changes":1137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"memory\/allStatic.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -29,1 +31,4 @@\n-#include \"runtime\/mutexLocker.hpp\"\n+#include \"oops\/typeArrayOop.hpp\"\n+#include \"oops\/weakHandle.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -31,2 +36,1 @@\n-class StringDedupEntryCache;\n-class StringDedupUnlinkOrOopsDoClosure;\n+class OopStorage;\n@@ -34,0 +38,2 @@\n+\/\/ Provides deduplication.  This class keeps track of all the unique byte\n+\/\/ arrays used by deduplicated String objects.\n@@ -35,3 +41,6 @@\n-\/\/ Table entry in the deduplication hashtable. Points weakly to the\n-\/\/ character array. Can be chained in a linked list in case of hash\n-\/\/ collisions or when placed in a freelist in the entry cache.\n+\/\/ The arrays are in a hashtable, hashed using the bytes in the array.  The\n+\/\/ references to the arrays by the hashtable are weak, allowing arrays that\n+\/\/ become unreachable to be collected and their entries pruned from the\n+\/\/ table.  The hashtable is dynamically resized to accommodate the current\n+\/\/ number of hashtable entries.  There are several command line options\n+\/\/ controlling the growth or shrinkage of the hashtable.\n@@ -39,65 +48,3 @@\n-class StringDedupEntry : public CHeapObj<mtGC> {\n-private:\n-  StringDedupEntry* _next;\n-  unsigned int      _hash;\n-  bool              _latin1;\n-  typeArrayOop      _obj;\n-\n-public:\n-  StringDedupEntry() :\n-    _next(NULL),\n-    _hash(0),\n-    _latin1(false),\n-    _obj(NULL) {\n-  }\n-\n-  StringDedupEntry* next() {\n-    return _next;\n-  }\n-\n-  StringDedupEntry** next_addr() {\n-    return &_next;\n-  }\n-\n-  void set_next(StringDedupEntry* next) {\n-    _next = next;\n-  }\n-\n-  unsigned int hash() {\n-    return _hash;\n-  }\n-\n-  void set_hash(unsigned int hash) {\n-    _hash = hash;\n-  }\n-\n-  bool latin1() {\n-    return _latin1;\n-  }\n-\n-  void set_latin1(bool latin1) {\n-    _latin1 = latin1;\n-  }\n-\n-  typeArrayOop obj() {\n-    return _obj;\n-  }\n-\n-  typeArrayOop* obj_addr() {\n-    return &_obj;\n-  }\n-\n-  void set_obj(typeArrayOop obj) {\n-    _obj = obj;\n-  }\n-};\n-\n-\/\/\n-\/\/ The deduplication hashtable keeps track of all unique character arrays used\n-\/\/ by String objects. Each table entry weakly points to an character array, allowing\n-\/\/ otherwise unreachable character arrays to be declared dead and pruned from the\n-\/\/ table.\n-\/\/\n-\/\/ The table is dynamically resized to accommodate the current number of table entries.\n-\/\/ The table has hash buckets with chains for hash collision. If the average chain\n-\/\/ length goes above or below given thresholds the table grows or shrinks accordingly.\n+\/\/ Operations on the table are not thread-safe.  Only the deduplication\n+\/\/ thread calls most of the operations on the table.  The only exception is\n+\/\/ the GC dead object count notification and the management of its state.\n@@ -105,2 +52,5 @@\n-\/\/ The table is also dynamically rehashed (using a new hash seed) if it becomes severely\n-\/\/ unbalanced, i.e., a hash chain is significantly longer than average.\n+\/\/ The table supports resizing and removal of entries for byte arrays that\n+\/\/ have become unreferenced.  These operations are performed by the\n+\/\/ deduplication thread, in a series of small incremental steps.  This\n+\/\/ prevents these potentially long running operations from long blockage of\n+\/\/ safepoints or concurrent deduplication requests from the StringTable.\n@@ -108,7 +58,5 @@\n-\/\/ All access to the table is protected by the StringDedupTable_lock, except under\n-\/\/ safepoints in which case GC workers are allowed to access a table partitions they\n-\/\/ have claimed without first acquiring the lock. Note however, that this applies only\n-\/\/ the table partition (i.e. a range of elements in _buckets), not other parts of the\n-\/\/ table such as the _entries field, statistics counters, etc.\n-\/\/\n-class StringDedupTable : public CHeapObj<mtGC> {\n+\/\/ As a space optimization, when shared StringTable entries exist the shared\n+\/\/ part of the StringTable is also used as a source for byte arrays.  This\n+\/\/ permits deduplication of strings against those shared entries without\n+\/\/ recording them in this table too.\n+class StringDedup::Table : AllStatic {\n@@ -116,116 +64,46 @@\n-  \/\/ The currently active hashtable instance. Only modified when\n-  \/\/ the table is resizes or rehashed.\n-  static StringDedupTable*        _table;\n-\n-  \/\/ Cache for reuse and fast alloc\/free of table entries.\n-  static StringDedupEntryCache*   _entry_cache;\n-\n-  StringDedupEntry**              _buckets;\n-  size_t                          _size;\n-  volatile uintx                  _entries;\n-  uintx                           _shrink_threshold;\n-  uintx                           _grow_threshold;\n-  bool                            _rehash_needed;\n-\n-  \/\/ The hash seed also dictates which hash function to use. A\n-  \/\/ zero hash seed means we will use the Java compatible hash\n-  \/\/ function (which doesn't use a seed), and a non-zero hash\n-  \/\/ seed means we use the murmur3 hash function.\n-  uint64_t                        _hash_seed;\n-\n-  \/\/ Constants governing table resize\/rehash\/cache.\n-  static const size_t             _min_size;\n-  static const size_t             _max_size;\n-  static const double             _grow_load_factor;\n-  static const double             _shrink_load_factor;\n-  static const uintx              _rehash_multiple;\n-  static const uintx              _rehash_threshold;\n-  static const double             _max_cache_factor;\n-\n-  \/\/ Table statistics, only used for logging.\n-  static uintx                    _entries_added;\n-  static volatile uintx           _entries_removed;\n-  static uintx                    _resize_count;\n-  static uintx                    _rehash_count;\n-\n-  static volatile size_t          _claimed_index;\n-\n-  static StringDedupTable*        _resized_table;\n-  static StringDedupTable*        _rehashed_table;\n-\n-  StringDedupTable(size_t size, uint64_t hash_seed = 0);\n-  ~StringDedupTable();\n-\n-  \/\/ Returns the hash bucket at the given index.\n-  StringDedupEntry** bucket(size_t index) {\n-    return _buckets + index;\n-  }\n-\n-  \/\/ Returns the hash bucket index for the given hash code.\n-  size_t hash_to_index(unsigned int hash) {\n-    return (size_t)hash & (_size - 1);\n-  }\n-\n-  \/\/ Adds a new table entry to the given hash bucket.\n-  void add(typeArrayOop value, bool latin1, unsigned int hash, StringDedupEntry** list);\n-\n-  \/\/ Removes the given table entry from the table.\n-  void remove(StringDedupEntry** pentry, uint worker_id);\n-\n-  \/\/ Transfers a table entry from the current table to the destination table.\n-  void transfer(StringDedupEntry** pentry, StringDedupTable* dest);\n-\n-  \/\/ Returns an existing character array in the given hash bucket, or NULL\n-  \/\/ if no matching character array exists.\n-  typeArrayOop lookup(typeArrayOop value, bool latin1, unsigned int hash,\n-                      StringDedupEntry** list, uintx &count);\n-\n-  \/\/ Returns an existing character array in the table, or inserts a new\n-  \/\/ table entry if no matching character array exists.\n-  typeArrayOop lookup_or_add_inner(typeArrayOop value, bool latin1, unsigned int hash);\n-\n-  \/\/ Thread safe lookup or add of table entry\n-  static typeArrayOop lookup_or_add(typeArrayOop value, bool latin1, unsigned int hash) {\n-    \/\/ Protect the table from concurrent access. Also note that this lock\n-    \/\/ acts as a fence for _table, which could have been replaced by a new\n-    \/\/ instance if the table was resized or rehashed.\n-    MutexLocker ml(StringDedupTable_lock, Mutex::_no_safepoint_check_flag);\n-    return _table->lookup_or_add_inner(value, latin1, hash);\n-  }\n-\n-  \/\/ Returns true if the hashtable is currently using a Java compatible\n-  \/\/ hash function.\n-  static bool use_java_hash() {\n-    return _table->_hash_seed == 0;\n-  }\n-\n-  \/\/ Computes the hash code for the given character array, using the\n-  \/\/ currently active hash function and hash seed.\n-  static unsigned int hash_code(typeArrayOop value, bool latin1);\n-\n-  static uintx unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl,\n-                                 size_t partition_begin,\n-                                 size_t partition_end,\n-                                 uint worker_id);\n-\n-  static size_t claim_table_partition(size_t partition_size);\n-\n-  static bool is_resizing();\n-  static bool is_rehashing();\n-\n-  \/\/ If a table resize is needed, returns a newly allocated empty\n-  \/\/ hashtable of the proper size.\n-  static StringDedupTable* prepare_resize();\n-\n-  \/\/ Installs a newly resized table as the currently active table\n-  \/\/ and deletes the previously active table.\n-  static void finish_resize(StringDedupTable* resized_table);\n-\n-  \/\/ If a table rehash is needed, returns a newly allocated empty\n-  \/\/ hashtable and updates the hash seed.\n-  static StringDedupTable* prepare_rehash();\n-\n-  \/\/ Transfers rehashed entries from the currently active table into\n-  \/\/ the new table. Installs the new table as the currently active table\n-  \/\/ and deletes the previously active table.\n-  static void finish_rehash(StringDedupTable* rehashed_table);\n+  class Bucket;\n+  class CleanupState;\n+  class Resizer;\n+  class Cleaner;\n+  enum class DeadState;\n+\n+  \/\/ Values in the table are weak references to jbyte[] Java objects.  The\n+  \/\/ String's coder isn't recorded, even though it affects how String access\n+  \/\/ would interpret that array.  For the purposes of deduplication we don't\n+  \/\/ care about that distinction; two Strings with equivalent arrays but\n+  \/\/ different coders can be deduplicated to share a single array.  We also\n+  \/\/ can't depend on the coder value being correct here, since GC requests\n+  \/\/ can provide the deduplication thread with access to a String that is\n+  \/\/ incompletely constructed; the value could be set before the coder.\n+  using TableValue = WeakHandle;\n+\n+  \/\/ Weak storage for the string data in the table.\n+  static OopStorage* _table_storage;\n+  static Bucket* _buckets;\n+  static size_t _number_of_buckets;\n+  static size_t _number_of_entries;\n+  static size_t _grow_threshold;\n+  static CleanupState* _cleanup_state;\n+  static bool _need_bucket_shrinking;\n+  \/\/ These are always written while holding StringDedup_lock, but may be\n+  \/\/ read by the dedup thread without holding the lock lock.\n+  static volatile size_t _dead_count;\n+  static volatile DeadState _dead_state;\n+\n+  static uint compute_hash(typeArrayOop obj);\n+  static size_t hash_to_index(uint hash_code);\n+  static void add(TableValue tv, uint hash_code);\n+  static TableValue find(typeArrayOop obj, uint hash_code);\n+  static void install(typeArrayOop obj, uint hash_code);\n+  static bool deduplicate_if_permitted(oop java_string, typeArrayOop value);\n+  static bool try_deduplicate_shared(oop java_string);\n+  static bool try_deduplicate_found_shared(oop java_string, oop found);\n+  static Bucket* make_buckets(size_t number_of_buckets, size_t reserve = 0);\n+  static void free_buckets(Bucket* buckets, size_t number_of_buckets);\n+\n+  static bool start_resizer(bool grow_only, size_t number_of_entries);\n+  static bool start_cleaner(size_t number_of_entries, size_t dead_count);\n+\n+  static void num_dead_callback(size_t num_dead);\n+  static bool is_dead_count_good_acquire();\n+  static void set_dead_state_cleaning();\n@@ -234,1 +112,2 @@\n-  static void create();\n+  static void initialize_storage();\n+  static void initialize();\n@@ -236,3 +115,4 @@\n-  \/\/ Deduplicates the given String object, or adds its backing\n-  \/\/ character array to the deduplication hashtable.\n-  static void deduplicate(oop java_string, StringDedupStat* stat);\n+  \/\/ Deduplicate java_string.  If the table already contains the string's\n+  \/\/ data array, replace the string's data array with the one in the table.\n+  \/\/ Otherwise, add the string's data array to the table.\n+  static void deduplicate(oop java_string);\n@@ -240,1 +120,2 @@\n-  static void unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl, uint worker_id);\n+  \/\/ Returns true if table needs to grow.\n+  static bool is_grow_needed();\n@@ -242,2 +123,8 @@\n-  static void print_statistics();\n-  static void verify();\n+  \/\/ Returns true if there are enough dead entries to need cleanup.\n+  static bool is_dead_entry_removal_needed();\n+\n+  \/\/ If cleanup (resizing or removing dead entries) is needed or force\n+  \/\/ is true, setup cleanup state and return true.  If result is true,\n+  \/\/ the caller must eventually call cleanup_end.\n+  \/\/ precondition: no cleanup is in progress.\n+  static bool cleanup_start_if_needed(bool grow_only, bool force);\n@@ -245,2 +132,4 @@\n-  \/\/ If the table entry cache has grown too large, delete overflowed entries.\n-  static void clean_entry_cache();\n+  \/\/ Perform some cleanup work.  Returns true if any progress was made,\n+  \/\/ false if there is no further work to do.\n+  \/\/ precondition: a cleanup is in progress.\n+  static bool cleanup_step();\n@@ -248,3 +137,10 @@\n-  \/\/ GC support\n-  static void gc_prologue(bool resize_and_rehash_table);\n-  static void gc_epilogue();\n+  \/\/ Record the cleanup complete and cleanup state.\n+  \/\/ precondition: a cleanup is in progress.\n+  static void cleanup_end();\n+\n+  \/\/ Return the phase kind for the cleanup being performed.\n+  \/\/ precondition: a cleanup is in progress.\n+  static Stat::Phase cleanup_phase();\n+\n+  static void verify();\n+  static void log_statistics();\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupTable.hpp","additions":105,"deletions":209,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.inline.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupTable.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupThread.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-\n-StringDedupThread* StringDedupThread::_thread = NULL;\n-\n-StringDedupThread::StringDedupThread() :\n-  ConcurrentGCThread() {\n-  set_name(\"StrDedup\");\n-  create_and_start();\n-}\n-\n-StringDedupThread::~StringDedupThread() {\n-  ShouldNotReachHere();\n-}\n-\n-StringDedupThread* StringDedupThread::thread() {\n-  assert(_thread != NULL, \"String deduplication thread not created\");\n-  return _thread;\n-}\n-\n-class StringDedupSharedClosure: public OopClosure {\n- private:\n-  StringDedupStat* _stat;\n-\n- public:\n-  StringDedupSharedClosure(StringDedupStat* stat) : _stat(stat) {}\n-\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-  virtual void do_oop(oop* p) {\n-    oop java_string = RawAccess<>::oop_load(p);\n-    StringDedupTable::deduplicate(java_string, _stat);\n-  }\n-};\n-\n-\/\/ The CDS archive does not include the string deduplication table. Only the string\n-\/\/ table is saved in the archive. The shared strings from CDS archive need to be\n-\/\/ added to the string deduplication table before deduplication occurs. That is\n-\/\/ done in the beginning of the StringDedupThread (see StringDedupThread::do_deduplication()).\n-void StringDedupThread::deduplicate_shared_strings(StringDedupStat* stat) {\n-  StringDedupSharedClosure sharedStringDedup(stat);\n-  StringTable::shared_oops_do(&sharedStringDedup);\n-}\n-\n-void StringDedupThread::stop_service() {\n-  StringDedupQueue::cancel_wait();\n-}\n-\n-void StringDedupThread::print_start(const StringDedupStat* last_stat) {\n-  StringDedupStat::print_start(last_stat);\n-}\n-\n-void StringDedupThread::print_end(const StringDedupStat* last_stat, const StringDedupStat* total_stat) {\n-  StringDedupStat::print_end(last_stat, total_stat);\n-  if (log_is_enabled(Debug, gc, stringdedup)) {\n-    last_stat->print_statistics(false);\n-    total_stat->print_statistics(true);\n-\n-    StringDedupTable::print_statistics();\n-    StringDedupQueue::print_statistics();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupThread.cpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPTHREAD_HPP\n-#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPTHREAD_HPP\n-\n-#include \"gc\/shared\/concurrentGCThread.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupStat.hpp\"\n-\n-\/\/\n-\/\/ The deduplication thread is where the actual deduplication occurs. It waits for\n-\/\/ deduplication candidates to appear on the deduplication queue, removes them from\n-\/\/ the queue and tries to deduplicate them. It uses the deduplication hashtable to\n-\/\/ find identical, already existing, character arrays on the heap. The thread runs\n-\/\/ concurrently with the Java application but participates in safepoints to allow\n-\/\/ the GC to adjust and unlink oops from the deduplication queue and table.\n-\/\/\n-class StringDedupThread: public ConcurrentGCThread {\n-protected:\n-  static StringDedupThread* _thread;\n-\n-  StringDedupThread();\n-  ~StringDedupThread();\n-\n-  void print_start(const StringDedupStat* last_stat);\n-  void print_end(const StringDedupStat* last_stat, const StringDedupStat* total_stat);\n-\n-  void run_service() { this->do_deduplication(); }\n-  void stop_service();\n-\n-  void deduplicate_shared_strings(StringDedupStat* stat);\n-protected:\n-  virtual void do_deduplication() = 0;\n-\n-public:\n-  static StringDedupThread* thread();\n-};\n-\n-template <typename S>\n-class StringDedupThreadImpl : public StringDedupThread {\n-private:\n-  StringDedupThreadImpl() { }\n-\n-protected:\n-  void do_deduplication();\n-\n-public:\n-  static void create();\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupThread.hpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPTHREAD_INLINE_HPP\n-#define SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPTHREAD_INLINE_HPP\n-\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupQueue.inline.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupThread.hpp\"\n-\n-template <typename S>\n-void StringDedupThreadImpl<S>::do_deduplication() {\n-  S total_stat;\n-\n-  {\n-    \/\/ Block safepoints while deduplicating shared strings\n-    SuspendibleThreadSetJoiner sts_join;\n-    deduplicate_shared_strings(&total_stat);\n-  }\n-\n-  \/\/ Main loop\n-  for (;;) {\n-    S stat;\n-\n-    stat.mark_idle();\n-\n-    \/\/ Wait for the queue to become non-empty\n-    StringDedupQueue::wait();\n-    if (this->should_terminate()) {\n-      break;\n-    }\n-\n-    {\n-      \/\/ Include thread in safepoints\n-      SuspendibleThreadSetJoiner sts_join;\n-\n-      stat.mark_exec();\n-      StringDedupStat::print_start(&stat);\n-\n-      \/\/ Process the queue\n-      for (;;) {\n-        oop java_string = StringDedupQueue::pop();\n-        if (java_string == NULL) {\n-          break;\n-        }\n-\n-        StringDedupTable::deduplicate(java_string, &stat);\n-\n-        \/\/ Safepoint this thread if needed\n-        if (sts_join.should_yield()) {\n-          stat.mark_block();\n-          sts_join.yield();\n-          stat.mark_unblock();\n-        }\n-      }\n-\n-      stat.mark_done();\n-\n-      total_stat.add(&stat);\n-      print_end(&stat, &total_stat);\n-      stat.reset();\n-    }\n-\n-    StringDedupTable::clean_entry_cache();\n-  }\n-}\n-\n-template <typename S>\n-void StringDedupThreadImpl<S>::create() {\n-  assert(_thread == NULL, \"One string deduplication thread allowed\");\n-  _thread = new StringDedupThreadImpl<S>();\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_STRINGDEDUP_STRINGDEDUPTHREAD_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupThread.inline.hpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -731,1 +731,0 @@\n-  ShenandoahConcurrentStringDedupRoots       _dedup_roots;\n@@ -740,1 +739,0 @@\n-    _dedup_roots(phase),\n@@ -746,2 +744,0 @@\n-\n-    _dedup_roots.prologue();\n@@ -751,2 +747,0 @@\n-    _dedup_roots.epilogue();\n-\n@@ -769,5 +763,0 @@\n-\n-      \/\/ String dedup weak roots\n-      ShenandoahForwardedIsAliveClosure is_alive;\n-      ShenandoahEvacuateUpdateMetadataClosure<MO_RELEASE> keep_alive;\n-      _dedup_roots.oops_do(&is_alive, &keep_alive, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -391,1 +391,0 @@\n-  ShenandoahStringDedup::initialize();\n@@ -1788,5 +1787,0 @@\n-\n-  \/\/ Step 4. Stop String Dedup thread if it is active\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    ShenandoahStringDedup::stop();\n-  }\n@@ -2291,8 +2285,0 @@\n-void ShenandoahHeap::deduplicate_string(oop str) {\n-  assert(java_lang_String::is_instance(str), \"invariant\");\n-\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    ShenandoahStringDedup::deduplicate(str);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -644,2 +644,0 @@\n-  void deduplicate_string(oop str);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  _stringDedup_requests(),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -48,1 +49,1 @@\n-  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n+  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, StringDedup::Requests* const req, bool weak);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+  StringDedup::Requests     _stringdedup_requests;\n@@ -234,1 +235,1 @@\n-      ShenandoahMark::mark_through_ref<oop, STRING_DEDUP>(p, _queue, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, STRING_DEDUP>(p, _queue, _mark_context, &_stringdedup_requests, false);\n@@ -240,1 +241,1 @@\n-inline void ShenandoahMark::mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+inline void ShenandoahMark::mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, StringDedup::Requests* const req, bool weak) {\n@@ -261,1 +262,1 @@\n-        ShenandoahStringDedup::enqueue_candidate(obj);\n+        req->add(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahStrDedupQueue.hpp\"\n@@ -43,0 +42,1 @@\n+  StringDedup::Requests     _stringDedup_requests;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  ShenandoahMark::mark_through_ref<T, STRING_DEDUP>(p, _queue, _mark_context, _weak);\n+  ShenandoahMark::mark_through_ref<T, STRING_DEDUP>(p, _queue, _mark_context, &_stringDedup_requests, _weak);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahRootProcessor.inline.hpp\"\n@@ -41,1 +40,0 @@\n-  ShenandoahStringDedupRoots          _dedup_roots;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-  _dedup_roots(phase),\n@@ -60,1 +59,0 @@\n-  _dedup_roots.oops_do(_is_alive, _keep_alive, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  f(CNT_PREFIX ## StringDedupTableRoots,    DESC_PREFIX \"Dedup Table Roots\")           \\\n-  f(CNT_PREFIX ## StringDedupQueueRoots,    DESC_PREFIX \"Dedup Queue Roots\")           \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n@@ -82,56 +81,0 @@\n-ShenandoahStringDedupRoots::ShenandoahStringDedupRoots(ShenandoahPhaseTimings::Phase phase) : _phase(phase) {\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    StringDedup::gc_prologue(false);\n-  }\n-}\n-\n-ShenandoahStringDedupRoots::~ShenandoahStringDedupRoots() {\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    StringDedup::gc_epilogue();\n-  }\n-}\n-\n-void ShenandoahStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    ShenandoahStringDedup::parallel_oops_do(_phase, is_alive, keep_alive, worker_id);\n-  }\n-}\n-\n-ShenandoahConcurrentStringDedupRoots::ShenandoahConcurrentStringDedupRoots(ShenandoahPhaseTimings::Phase phase) :\n-  _phase(phase) {\n-}\n-\n-void ShenandoahConcurrentStringDedupRoots::prologue() {\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    StringDedupTable_lock->lock_without_safepoint_check();\n-    StringDedupQueue_lock->lock_without_safepoint_check();\n-    StringDedup::gc_prologue(true);\n-  }\n-}\n-\n-void ShenandoahConcurrentStringDedupRoots::epilogue() {\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    StringDedup::gc_epilogue();\n-    StringDedupQueue_lock->unlock();\n-    StringDedupTable_lock->unlock();\n-  }\n-}\n-\n-void ShenandoahConcurrentStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    assert_locked_or_safepoint_weak(StringDedupQueue_lock);\n-    assert_locked_or_safepoint_weak(StringDedupTable_lock);\n-\n-    StringDedupUnlinkOrOopsDoClosure sd_cl(is_alive, keep_alive);\n-    {\n-      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::StringDedupQueueRoots, worker_id);\n-      StringDedupQueue::unlink_or_oops_do(&sd_cl);\n-    }\n-\n-    {\n-      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::StringDedupTableRoots, worker_id);\n-      StringDedupTable::unlink_or_oops_do(&sd_cl, worker_id);\n-    }\n-  }\n-}\n-\n@@ -186,1 +129,0 @@\n-   _dedup_roots(phase),\n@@ -277,1 +219,0 @@\n-  _dedup_roots(phase),\n@@ -287,1 +228,0 @@\n-  _dedup_roots(phase),\n@@ -304,1 +244,0 @@\n-  _dedup_roots.oops_do(&always_true, oops, worker_id);\n@@ -318,1 +257,0 @@\n-   _dedup_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n@@ -320,1 +258,0 @@\n-   _dedup_roots.prologue();\n@@ -323,4 +260,0 @@\n-ShenandoahHeapIterationRootScanner::~ShenandoahHeapIterationRootScanner() {\n-  _dedup_roots.epilogue();\n-}\n-\n@@ -340,1 +273,0 @@\n-   _dedup_roots.oops_do(&always_true, oops, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":0,"deletions":68,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -99,23 +99,0 @@\n-class ShenandoahStringDedupRoots {\n-private:\n-  ShenandoahPhaseTimings::Phase _phase;\n-public:\n-  ShenandoahStringDedupRoots(ShenandoahPhaseTimings::Phase phase);\n-  ~ShenandoahStringDedupRoots();\n-\n-  void oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);\n-};\n-\n-class ShenandoahConcurrentStringDedupRoots {\n-private:\n-  ShenandoahPhaseTimings::Phase _phase;\n-\n-public:\n-  ShenandoahConcurrentStringDedupRoots(ShenandoahPhaseTimings::Phase phase);\n-\n-  void prologue();\n-  void epilogue();\n-\n-  void oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);\n-};\n-\n@@ -194,1 +171,0 @@\n-  ShenandoahStringDedupRoots      _dedup_roots;\n@@ -231,1 +207,0 @@\n-  ShenandoahConcurrentStringDedupRoots                     _dedup_roots;\n@@ -236,1 +211,0 @@\n-  ~ShenandoahHeapIterationRootScanner();\n@@ -249,1 +223,0 @@\n-  ShenandoahStringDedupRoots                                _dedup_roots;\n@@ -267,1 +240,0 @@\n-  ShenandoahStringDedupRoots                                _dedup_roots;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-    AlwaysTrueClosure always_true;\n@@ -169,1 +168,0 @@\n-    _dedup_roots.oops_do(&always_true, oops, worker_id);\n@@ -188,1 +186,0 @@\n-  _dedup_roots.oops_do(is_alive, keep_alive, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,4 +65,0 @@\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    ShenandoahStringDedup::oops_do_slow(oops);\n-  }\n-\n@@ -86,4 +82,0 @@\n-  if (ShenandoahStringDedup::is_enabled()) {\n-    ShenandoahStringDedup::oops_do_slow(oops);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  ShenandoahMark::mark_through_ref<T, NO_DEDUP>(p, _queue, _mark_context, false);\n+  ShenandoahMark::mark_through_ref<T, NO_DEDUP>(p, _queue, _mark_context, NULL, false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,249 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shared\/stringdedup\/stringDedupThread.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahStrDedupQueue.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahStringDedup.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-\n-ShenandoahStrDedupQueue::ShenandoahStrDedupQueue() :\n-  _consumer_queue(NULL),\n-  _num_producer_queue(ShenandoahHeap::heap()->max_workers()),\n-  _published_queues(NULL),\n-  _free_list(NULL),\n-  _num_free_buffer(0),\n-  _max_free_buffer(ShenandoahHeap::heap()->max_workers() * 2),\n-  _cancel(false),\n-  _total_buffers(0) {\n-  _producer_queues = NEW_C_HEAP_ARRAY(ShenandoahQueueBuffer*, _num_producer_queue, mtGC);\n-  for (size_t index = 0; index < _num_producer_queue; index ++) {\n-    _producer_queues[index] = NULL;\n-  }\n-}\n-\n-ShenandoahStrDedupQueue::~ShenandoahStrDedupQueue() {\n-  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-  for (size_t index = 0; index < num_queues_nv(); index ++) {\n-    release_buffers(queue_at(index));\n-  }\n-\n-  release_buffers(_free_list);\n-  FREE_C_HEAP_ARRAY(ShenandoahQueueBuffer*, _producer_queues);\n-}\n-\n-void ShenandoahStrDedupQueue::wait_impl() {\n-  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-  while (_consumer_queue == NULL && !_cancel) {\n-    ml.wait();\n-    assert(_consumer_queue == NULL, \"Why wait?\");\n-    _consumer_queue = _published_queues;\n-    _published_queues = NULL;\n-  }\n-}\n-\n-void ShenandoahStrDedupQueue::cancel_wait_impl() {\n-  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-  _cancel = true;\n-  ml.notify();\n-}\n-\n-void ShenandoahStrDedupQueue::unlink_or_oops_do_impl(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue) {\n-  ShenandoahQueueBuffer* q = queue_at(queue);\n-  while (q != NULL) {\n-    q->unlink_or_oops_do(cl);\n-    q = q->next();\n-  }\n-}\n-\n-ShenandoahQueueBuffer* ShenandoahStrDedupQueue::queue_at(size_t queue_id) const {\n-  assert(queue_id <= num_queues(), \"Invalid queue id\");\n-  if (queue_id < _num_producer_queue) {\n-    return _producer_queues[queue_id];\n-  } else if (queue_id == _num_producer_queue) {\n-    return _consumer_queue;\n-  } else {\n-    assert(queue_id == _num_producer_queue + 1, \"Must be\");\n-    return _published_queues;\n-  }\n-}\n-\n-void ShenandoahStrDedupQueue::set_producer_buffer(ShenandoahQueueBuffer* buf, size_t queue_id) {\n-  assert(queue_id < _num_producer_queue, \"Not a producer queue id\");\n-  _producer_queues[queue_id] = buf;\n-}\n-\n-void ShenandoahStrDedupQueue::push_impl(uint worker_id, oop string_oop) {\n-  assert(worker_id < _num_producer_queue, \"Invalid queue id. Can only push to producer queue\");\n-  assert(ShenandoahStringDedup::is_candidate(string_oop), \"Not a candidate\");\n-\n-  ShenandoahQueueBuffer* buf = queue_at((size_t)worker_id);\n-\n-  if (buf == NULL) {\n-    MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-    buf = new_buffer();\n-    set_producer_buffer(buf, worker_id);\n-  } else if (buf->is_full()) {\n-    MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-    buf->set_next(_published_queues);\n-    _published_queues = buf;\n-    buf = new_buffer();\n-    set_producer_buffer(buf, worker_id);\n-    ml.notify();\n-  }\n-\n-  assert(!buf->is_full(), \"Sanity\");\n-  buf->push(string_oop);\n-}\n-\n-oop ShenandoahStrDedupQueue::pop_impl() {\n-  assert(Thread::current() == StringDedupThread::thread(), \"Must be dedup thread\");\n-  while (true) {\n-    if (_consumer_queue == NULL) {\n-      MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-      _consumer_queue = _published_queues;\n-      _published_queues = NULL;\n-    }\n-\n-    \/\/ there is nothing\n-    if (_consumer_queue == NULL) {\n-      return NULL;\n-    }\n-\n-    oop obj = NULL;\n-    if (pop_candidate(obj)) {\n-      assert(ShenandoahStringDedup::is_candidate(obj), \"Must be a candidate\");\n-      return obj;\n-    }\n-    assert(obj == NULL, \"No more candidate\");\n-  }\n-}\n-\n-bool ShenandoahStrDedupQueue::pop_candidate(oop& obj) {\n-  ShenandoahQueueBuffer* to_release = NULL;\n-  bool suc = true;\n-  do {\n-    if (_consumer_queue->is_empty()) {\n-      ShenandoahQueueBuffer* buf = _consumer_queue;\n-      _consumer_queue = _consumer_queue->next();\n-      buf->set_next(to_release);\n-      to_release = buf;\n-\n-      if (_consumer_queue == NULL) {\n-        suc = false;\n-        break;\n-      }\n-    }\n-    obj = _consumer_queue->pop();\n-  } while (obj == NULL);\n-\n-  if (to_release != NULL) {\n-    MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);\n-    release_buffers(to_release);\n-  }\n-\n-  return suc;\n-}\n-\n-ShenandoahQueueBuffer* ShenandoahStrDedupQueue::new_buffer() {\n-  assert_lock_strong(StringDedupQueue_lock);\n-  if (_free_list != NULL) {\n-    assert(_num_free_buffer > 0, \"Sanity\");\n-    ShenandoahQueueBuffer* buf = _free_list;\n-    _free_list = _free_list->next();\n-    _num_free_buffer --;\n-    buf->reset();\n-    return buf;\n-  } else {\n-    assert(_num_free_buffer == 0, \"Sanity\");\n-    _total_buffers ++;\n-    return new ShenandoahQueueBuffer;\n-  }\n-}\n-\n-void ShenandoahStrDedupQueue::release_buffers(ShenandoahQueueBuffer* list) {\n-  assert_lock_strong(StringDedupQueue_lock);\n-  while (list != NULL) {\n-    ShenandoahQueueBuffer* tmp = list;\n-    list = list->next();\n-    if (_num_free_buffer < _max_free_buffer) {\n-      tmp->set_next(_free_list);\n-      _free_list = tmp;\n-      _num_free_buffer ++;\n-    } else {\n-      _total_buffers --;\n-      delete tmp;\n-    }\n-  }\n-}\n-\n-void ShenandoahStrDedupQueue::print_statistics_impl() {\n-  Log(gc, stringdedup) log;\n-  log.debug(\"  Queue:\");\n-  log.debug(\"    Total buffers: \" SIZE_FORMAT \" (\" SIZE_FORMAT \" %s). \" SIZE_FORMAT \" buffers are on free list\",\n-    _total_buffers,\n-    byte_size_in_proper_unit(_total_buffers * sizeof(ShenandoahQueueBuffer)),\n-    proper_unit_for_byte_size(_total_buffers * sizeof(ShenandoahQueueBuffer)),\n-    _num_free_buffer);\n-}\n-\n-class VerifyQueueClosure : public OopClosure {\n-private:\n-  ShenandoahHeap* _heap;\n-public:\n-  VerifyQueueClosure();\n-\n-  void do_oop(oop* o);\n-  void do_oop(narrowOop* o) {\n-    ShouldNotCallThis();\n-  }\n-};\n-\n-VerifyQueueClosure::VerifyQueueClosure() :\n-  _heap(ShenandoahHeap::heap()) {\n-}\n-\n-void VerifyQueueClosure::do_oop(oop* o) {\n-  if (*o != NULL) {\n-    oop obj = *o;\n-    shenandoah_assert_correct(o, obj);\n-    assert(java_lang_String::is_instance(obj), \"Object must be a String\");\n-  }\n-}\n-\n-void ShenandoahStrDedupQueue::verify_impl() {\n-  VerifyQueueClosure vcl;\n-  for (size_t index = 0; index < num_queues(); index ++) {\n-    ShenandoahQueueBuffer* buf = queue_at(index);\n-    while (buf != NULL) {\n-      buf->oops_do(&vcl);\n-      buf = buf->next();\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStrDedupQueue.cpp","additions":0,"deletions":249,"binary":false,"changes":249,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSTRDEDUPQUEUE_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHSTRDEDUPQUEUE_HPP\n-\n-#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-template <uint buffer_size>\n-class ShenandoahOopBuffer : public CHeapObj<mtGC> {\n-private:\n-  oop           _buf[buffer_size];\n-  volatile uint _index;\n-  ShenandoahOopBuffer<buffer_size>* _next;\n-\n-public:\n-  ShenandoahOopBuffer();\n-\n-  bool is_full()  const;\n-  bool is_empty() const;\n-  uint size()     const;\n-\n-  void push(oop obj);\n-  oop pop();\n-\n-  void reset();\n-\n-  void set_next(ShenandoahOopBuffer<buffer_size>* next);\n-  ShenandoahOopBuffer<buffer_size>* next() const;\n-\n-  void unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl);\n-  void oops_do(OopClosure* cl);\n-\n-private:\n-  uint index_acquire() const;\n-  void set_index_release(uint index);\n-};\n-\n-typedef ShenandoahOopBuffer<64> ShenandoahQueueBuffer;\n-\n-\/\/ Muti-producer and single consumer queue set\n-class ShenandoahStrDedupQueue : public StringDedupQueue {\n-private:\n-  ShenandoahQueueBuffer** _producer_queues;\n-  ShenandoahQueueBuffer*  _consumer_queue;\n-  size_t                  _num_producer_queue;\n-\n-  \/\/ The queue is used for producers to publish completed buffers\n-  ShenandoahQueueBuffer* _published_queues;\n-\n-  \/\/ Cached free buffers\n-  ShenandoahQueueBuffer* _free_list;\n-  size_t                 _num_free_buffer;\n-  const size_t           _max_free_buffer;\n-\n-  bool                   _cancel;\n-\n-  \/\/ statistics\n-  size_t                 _total_buffers;\n-\n-private:\n-  ~ShenandoahStrDedupQueue();\n-\n-public:\n-  ShenandoahStrDedupQueue();\n-\n-  void wait_impl();\n-  void cancel_wait_impl();\n-\n-  void push_impl(uint worker_id, oop string_oop);\n-  oop  pop_impl();\n-\n-  void unlink_or_oops_do_impl(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue);\n-\n-  void print_statistics_impl();\n-  void verify_impl();\n-\n-protected:\n-  size_t num_queues() const { return num_queues_nv(); }\n-\n-private:\n-  inline size_t num_queues_nv() const { return (_num_producer_queue + 2); }\n-\n-  ShenandoahQueueBuffer* new_buffer();\n-\n-  void release_buffers(ShenandoahQueueBuffer* list);\n-\n-  ShenandoahQueueBuffer* queue_at(size_t queue_id) const;\n-\n-  bool pop_candidate(oop& obj);\n-\n-  void set_producer_buffer(ShenandoahQueueBuffer* buf, size_t queue_id);\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSTRDEDUPQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStrDedupQueue.hpp","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSTRDEDUPQUEUE_INLINE_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHSTRDEDUPQUEUE_INLINE_HPP\n-\n-#include \"gc\/shenandoah\/shenandoahStrDedupQueue.hpp\"\n-#include \"oops\/access.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-\/\/ With concurrent string dedup cleaning up, GC worker threads\n-\/\/ may see oops just enqueued, so release_store and load_acquire\n-\/\/ relationship needs to be established between enqueuing threads\n-\/\/ and GC workers.\n-\/\/ For example, when GC sees a slot (index), there must be a valid\n-\/\/ (dead or live) oop.\n-\/\/ Note: There is no concern if GC misses newly enqueued oops,\n-\/\/ since LRB ensures they are in to-space.\n-template <uint buffer_size>\n-ShenandoahOopBuffer<buffer_size>::ShenandoahOopBuffer() :\n-  _index(0), _next(NULL) {\n-}\n-\n-template <uint buffer_size>\n-bool ShenandoahOopBuffer<buffer_size>::is_full() const {\n-  return index_acquire() >= buffer_size;\n-}\n-\n-template <uint buffer_size>\n-bool ShenandoahOopBuffer<buffer_size>::is_empty() const {\n-  return index_acquire() == 0;\n-}\n-\n-template <uint buffer_size>\n-uint ShenandoahOopBuffer<buffer_size>::size() const {\n-  return index_acquire();\n-}\n-\n-template <uint buffer_size>\n-void ShenandoahOopBuffer<buffer_size>::push(oop obj) {\n-  assert(!is_full(),  \"Buffer is full\");\n-  uint idx = index_acquire();\n-  RawAccess<IS_NOT_NULL>::oop_store(&_buf[idx], obj);\n-  set_index_release(idx + 1);\n-}\n-\n-template <uint buffer_size>\n-oop ShenandoahOopBuffer<buffer_size>::pop() {\n-  assert(!is_empty(), \"Buffer is empty\");\n-  uint idx = index_acquire() - 1;\n-  oop value = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE | MO_ACQUIRE>::oop_load(&_buf[idx]);\n-  set_index_release(idx);\n-  return value;\n-}\n-\n-template <uint buffer_size>\n-void ShenandoahOopBuffer<buffer_size>::set_next(ShenandoahOopBuffer<buffer_size>* next) {\n-  _next = next;\n-}\n-\n-template <uint buffer_size>\n-ShenandoahOopBuffer<buffer_size>* ShenandoahOopBuffer<buffer_size>::next() const {\n-  return _next;\n-}\n-\n-template <uint buffer_size>\n-void ShenandoahOopBuffer<buffer_size>::reset() {\n-  _index = 0;\n-  _next = NULL;\n-}\n-\n-template <uint buffer_size>\n-uint ShenandoahOopBuffer<buffer_size>::index_acquire() const {\n-  return Atomic::load_acquire(&_index);\n-}\n-\n-template <uint buffer_size>\n-void ShenandoahOopBuffer<buffer_size>::set_index_release(uint index) {\n-  return Atomic::release_store(&_index, index);\n-}\n-\n-template <uint buffer_size>\n-void ShenandoahOopBuffer<buffer_size>::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl) {\n-  uint len = size();\n-  for (uint index = 0; index < len; index ++) {\n-    oop* obj_addr = &_buf[index];\n-    if (*obj_addr != NULL) {\n-      if (cl->is_alive(*obj_addr)) {\n-        cl->keep_alive(obj_addr);\n-      } else {\n-        RawAccess<MO_RELEASE>::oop_store(&_buf[index], oop());\n-      }\n-    }\n-  }\n-}\n-\n-template <uint buffer_size>\n-void ShenandoahOopBuffer<buffer_size>::oops_do(OopClosure* cl) {\n-  uint len = size();\n-  for (uint index = 0; index < len; index ++) {\n-    cl->do_oop(&_buf[index]);\n-  }\n-}\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSTRDEDUPQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStrDedupQueue.inline.hpp","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shared\/stringdedup\/stringDedup.inline.hpp\"\n-#include \"gc\/shared\/workgroup.hpp\"\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahMarkingContext.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n-#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n-#include \"gc\/shenandoah\/shenandoahStrDedupQueue.hpp\"\n-#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n-#include \"runtime\/thread.hpp\"\n-\n-void ShenandoahStringDedup::initialize() {\n-  assert(UseShenandoahGC, \"String deduplication available with Shenandoah GC\");\n-  StringDedup::initialize_impl<ShenandoahStrDedupQueue, StringDedupStat>();\n-}\n-\n-\/* Enqueue candidates for deduplication.\n- * The method should only be called by GC worker threads during marking phases.\n- *\/\n-void ShenandoahStringDedup::enqueue_candidate(oop java_string) {\n-  assert(Thread::current()->is_Worker_thread(),\n-        \"Only from a GC worker thread\");\n-\n-  if (java_string->age() <= StringDeduplicationAgeThreshold) {\n-    const markWord mark = java_string->mark();\n-\n-    \/\/ Having\/had displaced header, too risk to deal with them, skip\n-    if (mark == markWord::INFLATING() || mark.has_displaced_mark_helper()) {\n-      return;\n-    }\n-\n-    \/\/ Increase string age and enqueue it when it rearches age threshold\n-    markWord new_mark = mark.incr_age();\n-    if (mark == java_string->cas_set_mark(new_mark, mark)) {\n-      if (mark.age() == StringDeduplicationAgeThreshold) {\n-        StringDedupQueue::push(ShenandoahWorkerSession::worker_id(), java_string);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Deduplicate a string, return true if it is deduplicated.\n-void ShenandoahStringDedup::deduplicate(oop java_string) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  StringDedupStat dummy; \/\/ Statistics from this path is never used\n-  StringDedupTable::deduplicate(java_string, &dummy);\n-}\n-\n-void ShenandoahStringDedup::parallel_oops_do(ShenandoahPhaseTimings::Phase phase,\n-        BoolObjectClosure* is_alive, OopClosure* cl, uint worker_id) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-\n-  StringDedupUnlinkOrOopsDoClosure sd_cl(is_alive, cl);\n-  {\n-    ShenandoahWorkerTimingsTracker x(phase, ShenandoahPhaseTimings::StringDedupQueueRoots, worker_id);\n-    StringDedupQueue::unlink_or_oops_do(&sd_cl);\n-  }\n-\n-  {\n-    ShenandoahWorkerTimingsTracker x(phase, ShenandoahPhaseTimings::StringDedupTableRoots, worker_id);\n-    StringDedupTable::unlink_or_oops_do(&sd_cl, worker_id);\n-  }\n-}\n-\n-void ShenandoahStringDedup::oops_do_slow(OopClosure* cl) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-  AlwaysTrueClosure always_true;\n-  StringDedupUnlinkOrOopsDoClosure sd_cl(&always_true, cl);\n-  StringDedupQueue::unlink_or_oops_do(&sd_cl);\n-  StringDedupTable::unlink_or_oops_do(&sd_cl, 0);\n-}\n-\n-\/\/\n-\/\/ Task for parallel unlink_or_oops_do() operation on the deduplication queue\n-\/\/ and table.\n-\/\/\n-class ShenandoahStringDedupUnlinkOrOopsDoTask : public AbstractGangTask {\n-private:\n-  StringDedupUnlinkOrOopsDoClosure _cl;\n-\n-public:\n-  ShenandoahStringDedupUnlinkOrOopsDoTask(BoolObjectClosure* is_alive,\n-                                  OopClosure* keep_alive,\n-                                  bool allow_resize_and_rehash) :\n-    AbstractGangTask(\"Shenandoah String Dedup Unlink\/Process\"),\n-    _cl(is_alive, keep_alive) {\n-      StringDedup::gc_prologue(allow_resize_and_rehash);\n-  }\n-\n-  ~ShenandoahStringDedupUnlinkOrOopsDoTask() {\n-    StringDedup::gc_epilogue();\n-  }\n-\n-  virtual void work(uint worker_id) {\n-    StringDedupQueue::unlink_or_oops_do(&_cl);\n-    StringDedupTable::unlink_or_oops_do(&_cl, worker_id);\n-  }\n-};\n-\n-void ShenandoahStringDedup::unlink_or_oops_do(BoolObjectClosure* is_alive,\n-                                      OopClosure* keep_alive,\n-                                      bool allow_resize_and_rehash) {\n-  assert(is_enabled(), \"String deduplication not enabled\");\n-\n-  ShenandoahStringDedupUnlinkOrOopsDoTask task(is_alive, keep_alive, allow_resize_and_rehash);\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  heap->workers()->run_task(&task);\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.cpp","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -29,2 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n-#include \"memory\/iterator.hpp\"\n@@ -34,16 +32,0 @@\n-  \/\/ Initialize string deduplication.\n-  static void initialize();\n-\n-  \/\/ Enqueue a string to worker's local string dedup queue\n-  static void enqueue_candidate(oop java_string);\n-\n-  \/\/ Deduplicate a string, the call is lock-free\n-  static void deduplicate(oop java_string);\n-\n-  static void parallel_oops_do(ShenandoahPhaseTimings::Phase phase,\n-                               BoolObjectClosure* is_alive,\n-                               OopClosure* cl,\n-                               uint worker_id);\n-\n-  static void oops_do_slow(OopClosure* cl);\n-\n@@ -51,5 +33,0 @@\n-\n-  static void unlink_or_oops_do(BoolObjectClosure* is_alive,\n-                                OopClosure* keep_alive,\n-                                bool allow_resize_and_rehash);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.hpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n@@ -32,2 +32,20 @@\n-  return java_lang_String::is_instance_inlined(obj) &&\n-         java_lang_String::value(obj) != NULL;\n+  assert(Thread::current()->is_Worker_thread(),\n+        \"Only from a GC worker thread\");\n+  if (!java_lang_String::is_instance_inlined(obj) ||\n+       java_lang_String::value(obj) == nullptr) {\n+    return false;\n+  }\n+  if (StringDedup::is_below_threshold_age(obj->age())) {\n+    const markWord mark = obj->mark();\n+    \/\/ Having\/had displaced header, too risk to deal with them, skip\n+    if (mark == markWord::INFLATING() || mark.has_displaced_mark_helper()) {\n+      return false;\n+    }\n+\n+    \/\/ Increase string age and enqueue it when it rearches age threshold\n+    markWord new_mark = mark.incr_age();\n+    if (mark == obj->cas_set_mark(new_mark, mark)) {\n+      return StringDedup::is_threshold_age(new_mark.age());\n+    }\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.inline.hpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  f(mtStringDedup,    \"String Deduplication\")                                        \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -1069,0 +1070,2 @@\n+    } else if (strcmp(token, \"stringdedup\") == 0) {\n+      verify_flags |= Verify_StringDedup;\n@@ -1121,1 +1124,0 @@\n-  {\n@@ -1126,1 +1128,0 @@\n-  }\n@@ -1151,0 +1152,4 @@\n+  if (should_verify_subset(Verify_StringDedup)) {\n+    log_debug(gc, verify)(\"String Deduplication\");\n+    StringDedup::verify();\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+    Verify_StringDedup = 2048,\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -4001,0 +4002,4 @@\n+  if (!StringDedup::ergo_initialize()) {\n+    return JNI_EINVAL;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1943,1 +1943,1 @@\n-  product(uintx, StringDeduplicationAgeThreshold, 3,                        \\\n+  product(uint, StringDeduplicationAgeThreshold, 3,                         \\\n@@ -1948,0 +1948,23 @@\n+  product(size_t, StringDeduplicationInitialTableSize, 500, EXPERIMENTAL,   \\\n+          \"Approximate initial number of buckets in the table\")             \\\n+          range(1, 1 * G)                                                   \\\n+                                                                            \\\n+  product(double, StringDeduplicationGrowTableLoad, 14.0, EXPERIMENTAL,     \\\n+          \"Entries per bucket above which the table should be expanded\")    \\\n+          range(0.1, 1000.0)                                                \\\n+                                                                            \\\n+  product(double, StringDeduplicationShrinkTableLoad, 1.0, EXPERIMENTAL,    \\\n+          \"Entries per bucket below which the table should be shrunk\")      \\\n+          range(0.01, 100.0)                                                \\\n+                                                                            \\\n+  product(double, StringDeduplicationTargetTableLoad, 7.0, EXPERIMENTAL,    \\\n+          \"Desired entries per bucket when resizing the table\")             \\\n+          range(0.01, 1000.0)                                               \\\n+                                                                            \\\n+  product(size_t, StringDeduplicationCleanupDeadMinimum, 100, EXPERIMENTAL, \\\n+          \"Minimum number of dead table entries for cleaning the table\")    \\\n+                                                                            \\\n+  product(int, StringDeduplicationCleanupDeadPercent, 5, EXPERIMENTAL,      \\\n+          \"Minimum percentage of dead table entries for cleaning the table\") \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n@@ -1949,1 +1972,1 @@\n-          \"Force table resize every time the table is scanned\")             \\\n+          \"Force more frequent table resizing\")                             \\\n@@ -1951,2 +1974,2 @@\n-  product(bool, StringDeduplicationRehashALot, false, DIAGNOSTIC,           \\\n-          \"Force table rehash every time the table is scanned\")             \\\n+  product(uint64_t, StringDeduplicationHashSeed, 0, DIAGNOSTIC,             \\\n+          \"Seed for the table hashing function; 0 requests computed seed\")  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -465,0 +466,5 @@\n+  \/\/ Shut down string deduplication if running.\n+  if (StringDedup::is_enabled()) {\n+    StringDedup::stop();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-Monitor* StringDedupQueue_lock        = NULL;\n-Mutex*   StringDedupTable_lock        = NULL;\n+Monitor* StringDedup_lock             = NULL;\n+Mutex*   StringDedupIntern_lock       = NULL;\n@@ -226,3 +226,0 @@\n-    def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);\n-    def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  _safepoint_check_never);\n-\n@@ -234,4 +231,2 @@\n-  if (UseShenandoahGC) {\n-    def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);\n-    def(StringDedupTable_lock      , PaddedMutex  , leaf + 1,    true,  _safepoint_check_never);\n-  }\n+  def(StringDedup_lock             , PaddedMonitor, leaf,        true,  _safepoint_check_never);\n+  def(StringDedupIntern_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-extern Monitor* StringDedupQueue_lock;           \/\/ a lock on the string deduplication queue\n-extern Mutex*   StringDedupTable_lock;           \/\/ a lock on the string deduplication table\n+extern Monitor* StringDedup_lock;                \/\/ a lock on the string deduplication facility\n+extern Mutex*   StringDedupIntern_lock;          \/\/ a lock on StringTable notification of StringDedup\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -3759,0 +3760,3 @@\n+  if (StringDedup::is_enabled()) {\n+    StringDedup::threads_do(&cl);\n+  }\n@@ -3819,0 +3823,5 @@\n+  if (StringDedup::is_enabled()) {\n+    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n+    StringDedup::threads_do(&print_closure);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -201,7 +201,2 @@\n-template <class T> void print_literal(T l) {\n-  l->print();\n-}\n-\n-static void print_literal(WeakHandle l) {\n-  l.print();\n-}\n+template <class T> static void print_literal(T const& l) { l.print(); }\n+template <class T> static void print_literal(T* l) { print_literal(*l); }\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -134,3 +134,0 @@\n-        new LogMessageWithLevel(\"String Deduplication\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Queue Fixup\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Table Fixup\", Level.DEBUG),\n@@ -200,1 +197,0 @@\n-                                                   \"-XX:+UseStringDeduplication\",\n@@ -209,1 +205,0 @@\n-                                                   \"-XX:+UseStringDeduplication\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationAgeThreshold\n- * @summary Test string deduplication age threshold\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationAgeThreshold\n- *\/\n-\n-public class TestStringDeduplicationAgeThreshold {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testAgeThreshold();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationAgeThreshold.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationFullGC\n- * @summary Test string deduplication during full GC\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationFullGC\n- *\/\n-\n-public class TestStringDeduplicationFullGC {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testFullGC();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationFullGC.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationInterned\n- * @summary Test string deduplication of interned strings\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationInterned\n- *\/\n-\n-public class TestStringDeduplicationInterned {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testInterned();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationInterned.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationPrintOptions\n- * @summary Test string deduplication print options\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationPrintOptions\n- *\/\n-\n-public class TestStringDeduplicationPrintOptions {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testPrintOptions();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationPrintOptions.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationTableRehash\n- * @summary Test string deduplication table rehash\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationTableRehash\n- *\/\n-\n-public class TestStringDeduplicationTableRehash {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testTableRehash();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationTableRehash.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationTableResize\n- * @summary Test string deduplication table resize\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationTableResize\n- *\/\n-\n-public class TestStringDeduplicationTableResize {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testTableResize();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationTableResize.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,458 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * Common code for string deduplication tests\n- *\/\n-\n-import java.lang.reflect.*;\n-import java.util.*;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import sun.misc.*;\n-\n-class TestStringDeduplicationTools {\n-    private static final String YoungGC = \"YoungGC\";\n-    private static final String FullGC  = \"FullGC\";\n-\n-    private static final int Xmn = 50;  \/\/ MB\n-    private static final int Xms = 100; \/\/ MB\n-    private static final int Xmx = 100; \/\/ MB\n-    private static final int MB = 1024 * 1024;\n-    private static final int StringLength = 50;\n-\n-    private static final int LargeNumberOfStrings = 10000;\n-    private static final int SmallNumberOfStrings = 10;\n-\n-    private static Field valueField;\n-    private static Unsafe unsafe;\n-    private static byte[] dummy;\n-\n-    static {\n-        try {\n-            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n-            field.setAccessible(true);\n-            unsafe = (Unsafe)field.get(null);\n-\n-            valueField = String.class.getDeclaredField(\"value\");\n-            valueField.setAccessible(true);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static Object getValue(String string) {\n-        try {\n-            return valueField.get(string);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static void doFullGc(int numberOfTimes) {\n-        List<List<String>> newStrings = new ArrayList<List<String>>();\n-        for (int i = 0; i < numberOfTimes; i++) {\n-            \/\/ Create some more strings for every collection, to ensure\n-            \/\/ there will be deduplication work that will be reported.\n-            newStrings.add(createStrings(SmallNumberOfStrings, SmallNumberOfStrings));\n-            System.out.println(\"Begin: Full GC \" + (i + 1) + \"\/\" + numberOfTimes);\n-            System.gc();\n-            System.out.println(\"End: Full GC \" + (i + 1) + \"\/\" + numberOfTimes);\n-        }\n-    }\n-\n-    private static void doYoungGc(int numberOfTimes) {\n-        \/\/ Provoke at least numberOfTimes young GCs\n-        final int objectSize = 128;\n-        final int maxObjectInYoung = (Xmn * MB) \/ objectSize;\n-        List<List<String>> newStrings = new ArrayList<List<String>>();\n-        for (int i = 0; i < numberOfTimes; i++) {\n-            \/\/ Create some more strings for every collection, to ensure\n-            \/\/ there will be deduplication work that will be reported.\n-            newStrings.add(createStrings(SmallNumberOfStrings, SmallNumberOfStrings));\n-            System.out.println(\"Begin: Young GC \" + (i + 1) + \"\/\" + numberOfTimes);\n-            for (int j = 0; j < maxObjectInYoung + 1; j++) {\n-                dummy = new byte[objectSize];\n-            }\n-            System.out.println(\"End: Young GC \" + (i + 1) + \"\/\" + numberOfTimes);\n-        }\n-    }\n-\n-    private static void forceDeduplication(int ageThreshold, String gcType) {\n-        \/\/ Force deduplication to happen by either causing a FullGC or a YoungGC.\n-        \/\/ We do several collections to also provoke a situation where the the\n-        \/\/ deduplication thread needs to yield while processing the queue. This\n-        \/\/ also tests that the references in the deduplication queue are adjusted\n-        \/\/ accordingly.\n-        if (gcType.equals(FullGC)) {\n-            doFullGc(3);\n-        } else {\n-            doYoungGc(ageThreshold + 3);\n-        }\n-    }\n-\n-    private static String generateString(int id) {\n-        StringBuilder builder = new StringBuilder(StringLength);\n-\n-        builder.append(\"DeduplicationTestString:\" + id + \":\");\n-\n-        while (builder.length() < StringLength) {\n-            builder.append('X');\n-        }\n-\n-        return builder.toString();\n-    }\n-\n-    private static ArrayList<String> createStrings(int total, int unique) {\n-        System.out.println(\"Creating strings: total=\" + total + \", unique=\" + unique);\n-        if (total % unique != 0) {\n-            throw new RuntimeException(\"Total must be divisible by unique\");\n-        }\n-\n-        ArrayList<String> list = new ArrayList<String>(total);\n-        for (int j = 0; j < total \/ unique; j++) {\n-            for (int i = 0; i < unique; i++) {\n-                list.add(generateString(i));\n-            }\n-        }\n-\n-        return list;\n-    }\n-\n-    \/**\n-     * Verifies that the given list contains expected number of unique strings.\n-     * It's possible that deduplication hasn't completed yet, so the method\n-     * will perform several attempts to check with a little pause between.\n-     * The method throws RuntimeException to signal that verification failed.\n-     *\n-     * @param list strings to check\n-     * @param uniqueExpected expected number of unique strings\n-     * @throws RuntimeException if check fails\n-     *\/\n-    private static void verifyStrings(ArrayList<String> list, int uniqueExpected) {\n-        boolean passed = false;\n-        for (int attempts = 0; attempts < 10; attempts++) {\n-            \/\/ Check number of deduplicated strings\n-            ArrayList<Object> unique = new ArrayList<Object>(uniqueExpected);\n-            for (String string: list) {\n-                Object value = getValue(string);\n-                boolean uniqueValue = true;\n-                for (Object obj: unique) {\n-                    if (obj == value) {\n-                        uniqueValue = false;\n-                        break;\n-                    }\n-                }\n-\n-                if (uniqueValue) {\n-                    unique.add(value);\n-                }\n-            }\n-\n-            System.out.println(\"Verifying strings: total=\" + list.size() +\n-                               \", uniqueFound=\" + unique.size() +\n-                               \", uniqueExpected=\" + uniqueExpected);\n-\n-            if (unique.size() == uniqueExpected) {\n-                System.out.println(\"Deduplication completed (as fast as \" + attempts + \" iterations)\");\n-                passed = true;\n-                break;\n-            } else {\n-                System.out.println(\"Deduplication not completed, waiting...\");\n-                \/\/ Give the deduplication thread time to complete\n-                try {\n-                    Thread.sleep(1000);\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        }\n-        if (!passed) {\n-            throw new RuntimeException(\"String verification failed\");\n-        }\n-    }\n-\n-    private static OutputAnalyzer runTest(String... extraArgs) throws Exception {\n-        String[] defaultArgs = new String[] {\n-            \"-Xmn\" + Xmn + \"m\",\n-            \"-Xms\" + Xms + \"m\",\n-            \"-Xmx\" + Xmx + \"m\",\n-            \"-XX:+UseG1GC\",\n-            \"-XX:+UnlockDiagnosticVMOptions\",\n-            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\",\n-            \"-XX:+VerifyAfterGC\" \/\/ Always verify after GC\n-        };\n-\n-        ArrayList<String> args = new ArrayList<String>();\n-        args.addAll(Arrays.asList(defaultArgs));\n-        args.addAll(Arrays.asList(extraArgs));\n-\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        System.err.println(output.getStderr());\n-        System.out.println(output.getStdout());\n-        return output;\n-    }\n-\n-    private static class DeduplicationTest {\n-        public static void main(String[] args) {\n-            System.out.println(\"Begin: DeduplicationTest\");\n-\n-            final int numberOfStrings = Integer.parseUnsignedInt(args[0]);\n-            final int numberOfUniqueStrings = Integer.parseUnsignedInt(args[1]);\n-            final int ageThreshold = Integer.parseUnsignedInt(args[2]);\n-            final String gcType = args[3];\n-\n-            ArrayList<String> list = createStrings(numberOfStrings, numberOfUniqueStrings);\n-            forceDeduplication(ageThreshold, gcType);\n-            verifyStrings(list, numberOfUniqueStrings);\n-\n-            System.out.println(\"End: DeduplicationTest\");\n-        }\n-\n-        public static OutputAnalyzer run(int numberOfStrings, int ageThreshold, String gcType, String... extraArgs) throws Exception {\n-            String[] defaultArgs = new String[] {\n-                \"-XX:+UseStringDeduplication\",\n-                \"-XX:StringDeduplicationAgeThreshold=\" + ageThreshold,\n-                DeduplicationTest.class.getName(),\n-                \"\" + numberOfStrings,\n-                \"\" + numberOfStrings \/ 2,\n-                \"\" + ageThreshold,\n-                gcType\n-            };\n-\n-            ArrayList<String> args = new ArrayList<String>();\n-            args.addAll(Arrays.asList(extraArgs));\n-            args.addAll(Arrays.asList(defaultArgs));\n-\n-            return runTest(args.toArray(new String[args.size()]));\n-        }\n-    }\n-\n-    private static class InternedTest {\n-        public static void main(String[] args) {\n-            \/\/ This test verifies that interned strings are always\n-            \/\/ deduplicated when being interned, and never after\n-            \/\/ being interned.\n-\n-            System.out.println(\"Begin: InternedTest\");\n-\n-            final int ageThreshold = Integer.parseUnsignedInt(args[0]);\n-            final String baseString = \"DeduplicationTestString:\" + InternedTest.class.getName();\n-\n-            \/\/ Create duplicate of baseString\n-            StringBuilder sb1 = new StringBuilder(baseString);\n-            String dupString1 = sb1.toString();\n-            if (getValue(dupString1) == getValue(baseString)) {\n-                throw new RuntimeException(\"Values should not match\");\n-            }\n-\n-            \/\/ Force baseString to be inspected for deduplication\n-            \/\/ and be inserted into the deduplication hashtable.\n-            forceDeduplication(ageThreshold, FullGC);\n-\n-            \/\/ Wait for deduplication to occur\n-            for (int attempts = 0; attempts < 10; attempts++) {\n-                if (getValue(dupString1) == getValue(baseString)) {\n-                    break;\n-                }\n-                System.out.println(\"Waiting...\");\n-                try {\n-                    Thread.sleep(1000);\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-            if (getValue(dupString1) != getValue(baseString)) {\n-                throw new RuntimeException(\"Deduplication has not occurred\");\n-            }\n-\n-            \/\/ Create a new duplicate of baseString\n-            StringBuilder sb2 = new StringBuilder(baseString);\n-            String dupString2 = sb2.toString();\n-            if (getValue(dupString2) == getValue(baseString)) {\n-                throw new RuntimeException(\"Values should not match\");\n-            }\n-\n-            \/\/ Intern the new duplicate\n-            Object beforeInternedValue = getValue(dupString2);\n-            String internedString = dupString2.intern();\n-            if (internedString != dupString2) {\n-                throw new RuntimeException(\"String should match\");\n-            }\n-            if (getValue(internedString) != getValue(baseString)) {\n-                throw new RuntimeException(\"Values should match\");\n-            }\n-\n-            \/\/ Check original value of interned string, to make sure\n-            \/\/ deduplication happened on the interned string and not\n-            \/\/ on the base string\n-            if (beforeInternedValue == getValue(baseString)) {\n-                throw new RuntimeException(\"Values should not match\");\n-            }\n-\n-            System.out.println(\"End: InternedTest\");\n-        }\n-\n-        public static OutputAnalyzer run() throws Exception {\n-            return runTest(\"-Xlog:gc=debug,gc+stringdedup=trace\",\n-                           \"-XX:+UseStringDeduplication\",\n-                           \"-XX:StringDeduplicationAgeThreshold=\" + DefaultAgeThreshold,\n-                           InternedTest.class.getName(),\n-                           \"\" + DefaultAgeThreshold);\n-        }\n-    }\n-\n-    \/*\n-     * Tests\n-     *\/\n-\n-    private static final int MaxAgeThreshold      = 15;\n-    private static final int DefaultAgeThreshold  = 3;\n-    private static final int MinAgeThreshold      = 1;\n-\n-    private static final int TooLowAgeThreshold   = MinAgeThreshold - 1;\n-    private static final int TooHighAgeThreshold  = MaxAgeThreshold + 1;\n-\n-    public static void testYoungGC() throws Exception {\n-        \/\/ Do young GC to age strings to provoke deduplication\n-        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n-                                                      DefaultAgeThreshold,\n-                                                      YoungGC,\n-                                                      \"-Xlog:gc,gc+stringdedup=trace\");\n-        output.shouldNotContain(\"Full GC\");\n-        output.shouldContain(\"Pause Young (Normal) (G1 Evacuation Pause)\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldContain(\"Deduplicated:\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void testFullGC() throws Exception {\n-        \/\/ Do full GC to age strings to provoke deduplication\n-        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n-                                                      DefaultAgeThreshold,\n-                                                      FullGC,\n-                                                      \"-Xlog:gc,gc+stringdedup=trace\");\n-        output.shouldNotContain(\"Pause Young (Normal) (G1 Evacuation Pause)\");\n-        output.shouldContain(\"Full GC\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldContain(\"Deduplicated:\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void testTableResize() throws Exception {\n-        \/\/ Test with StringDeduplicationResizeALot\n-        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n-                                                      DefaultAgeThreshold,\n-                                                      YoungGC,\n-                                                      \"-Xlog:gc,gc+stringdedup=trace\",\n-                                                      \"-XX:+StringDeduplicationResizeALot\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldContain(\"Deduplicated:\");\n-        output.shouldNotContain(\"Resize Count: 0\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void testTableRehash() throws Exception {\n-        \/\/ Test with StringDeduplicationRehashALot\n-        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n-                                                      DefaultAgeThreshold,\n-                                                      YoungGC,\n-                                                      \"-Xlog:gc,gc+stringdedup=trace\",\n-                                                      \"-XX:+StringDeduplicationRehashALot\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldContain(\"Deduplicated:\");\n-        \/\/ Ensure there have been some rehashes.  Can't check for never\n-        \/\/ being zero, because the first collection might trigger a resize,\n-        \/\/ which suppresses rehash.  But as written, some collections should\n-        \/\/ not lead to a resize, and those will do a rehash.\n-        output.shouldMatch(\".* Rehash Count: [1-9].*\");\n-        output.shouldNotContain(\"Hash Seed: 0x0\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void testAgeThreshold() throws Exception {\n-        OutputAnalyzer output;\n-\n-        \/\/ Test with max age theshold\n-        output = DeduplicationTest.run(SmallNumberOfStrings,\n-                                       MaxAgeThreshold,\n-                                       YoungGC,\n-                                       \"-Xlog:gc,gc+stringdedup=trace\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldContain(\"Deduplicated:\");\n-        output.shouldHaveExitValue(0);\n-\n-        \/\/ Test with min age theshold\n-        output = DeduplicationTest.run(SmallNumberOfStrings,\n-                                       MinAgeThreshold,\n-                                       YoungGC,\n-                                       \"-Xlog:gc,gc+stringdedup=trace\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldContain(\"Deduplicated:\");\n-        output.shouldHaveExitValue(0);\n-\n-        \/\/ Test with too low age threshold\n-        output = DeduplicationTest.run(SmallNumberOfStrings,\n-                                       TooLowAgeThreshold,\n-                                       YoungGC);\n-        output.shouldContain(\"outside the allowed range\");\n-        output.shouldHaveExitValue(1);\n-\n-        \/\/ Test with too high age threshold\n-        output = DeduplicationTest.run(SmallNumberOfStrings,\n-                                       TooHighAgeThreshold,\n-                                       YoungGC);\n-        output.shouldContain(\"outside the allowed range\");\n-        output.shouldHaveExitValue(1);\n-    }\n-\n-    public static void testPrintOptions() throws Exception {\n-        OutputAnalyzer output;\n-\n-        \/\/ Test without -Xlog:gc\n-        output = DeduplicationTest.run(SmallNumberOfStrings,\n-                                       DefaultAgeThreshold,\n-                                       YoungGC);\n-        output.shouldNotContain(\"Concurrent String Deduplication\");\n-        output.shouldNotContain(\"Deduplicated:\");\n-        output.shouldHaveExitValue(0);\n-\n-        \/\/ Test with -Xlog:gc+stringdedup\n-        output = DeduplicationTest.run(SmallNumberOfStrings,\n-                                       DefaultAgeThreshold,\n-                                       YoungGC,\n-                                       \"-Xlog:gc+stringdedup\");\n-        output.shouldContain(\"Concurrent String Deduplication\");\n-        output.shouldNotContain(\"Deduplicated:\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void testInterned() throws Exception {\n-        \/\/ Test that interned strings are deduplicated before being interned\n-        OutputAnalyzer output = InternedTest.run();\n-        output.shouldHaveExitValue(0);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationTools.java","additions":0,"deletions":458,"binary":false,"changes":458,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestStringDeduplicationYoungGC\n- * @summary Test string deduplication during young GC\n- * @bug 8029075\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc:open\n- * @modules java.base\/java.lang:open\n- *          java.management\n- * @run driver gc.g1.TestStringDeduplicationYoungGC\n- *\/\n-\n-public class TestStringDeduplicationYoungGC {\n-    public static void main(String[] args) throws Exception {\n-        TestStringDeduplicationTools.testYoungGC();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationYoungGC.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * @test TestStringDeduplicationAgeThreshold\n+ * @summary Test string deduplication age threshold\n+ * @bug 8029075\n+ * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationAgeThreshold\n+ *\/\n+\n+public class TestStringDeduplicationAgeThreshold {\n+    public static void main(String[] args) throws Exception {\n+        TestStringDeduplicationTools.testAgeThreshold();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationAgeThreshold.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * @test TestStringDeduplicationFullGC\n+ * @summary Test string deduplication during full GC\n+ * @bug 8029075\n+ * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationFullGC\n+ *\/\n+\n+public class TestStringDeduplicationFullGC {\n+    public static void main(String[] args) throws Exception {\n+        TestStringDeduplicationTools.testFullGC();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationFullGC.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * @test TestStringDeduplicationInterned\n+ * @summary Test string deduplication of interned strings\n+ * @bug 8029075\n+ * @requires vm.gc == \"null\" | vm.gc == \"G1\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationInterned\n+ *\/\n+\n+public class TestStringDeduplicationInterned {\n+    public static void main(String[] args) throws Exception {\n+        TestStringDeduplicationTools.testInterned();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationInterned.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * @test TestStringDeduplicationPrintOptions\n+ * @summary Test string deduplication print options\n+ * @bug 8029075\n+ * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationPrintOptions\n+ *\/\n+\n+public class TestStringDeduplicationPrintOptions {\n+    public static void main(String[] args) throws Exception {\n+        TestStringDeduplicationTools.testPrintOptions();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationPrintOptions.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * @test TestStringDeduplicationTableResize\n+ * @summary Test string deduplication table resize\n+ * @bug 8029075\n+ * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationTableResize\n+ *\/\n+\n+public class TestStringDeduplicationTableResize {\n+    public static void main(String[] args) throws Exception {\n+        TestStringDeduplicationTools.testTableResize();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationTableResize.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,467 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * Common code for string deduplication tests\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import sun.misc.*;\n+\n+class TestStringDeduplicationTools {\n+    private static final String YoungGC = \"YoungGC\";\n+    private static final String FullGC  = \"FullGC\";\n+\n+    private static final int Xmn = 50;  \/\/ MB\n+    private static final int Xms = 100; \/\/ MB\n+    private static final int Xmx = 100; \/\/ MB\n+    private static final int MB = 1024 * 1024;\n+    private static final int StringLength = 50;\n+\n+    private static final int LargeNumberOfStrings = 10000;\n+    private static final int SmallNumberOfStrings = 10;\n+\n+    private static Field valueField;\n+    private static Unsafe unsafe;\n+    private static byte[] dummy;\n+\n+    static {\n+        try {\n+            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            field.setAccessible(true);\n+            unsafe = (Unsafe)field.get(null);\n+\n+            valueField = String.class.getDeclaredField(\"value\");\n+            valueField.setAccessible(true);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getValue(String string) {\n+        try {\n+            return valueField.get(string);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void doFullGc(int numberOfTimes) {\n+        List<List<String>> newStrings = new ArrayList<List<String>>();\n+        for (int i = 0; i < numberOfTimes; i++) {\n+            \/\/ Create some more strings for every collection, to ensure\n+            \/\/ there will be deduplication work that will be reported.\n+            newStrings.add(createStrings(SmallNumberOfStrings, SmallNumberOfStrings));\n+            System.out.println(\"Begin: Full GC \" + (i + 1) + \"\/\" + numberOfTimes);\n+            System.gc();\n+            System.out.println(\"End: Full GC \" + (i + 1) + \"\/\" + numberOfTimes);\n+        }\n+    }\n+\n+    private static void doYoungGc(int numberOfTimes) {\n+        \/\/ Provoke at least numberOfTimes young GCs\n+        final int objectSize = 128;\n+        final int maxObjectInYoung = (Xmn * MB) \/ objectSize;\n+        List<List<String>> newStrings = new ArrayList<List<String>>();\n+        for (int i = 0; i < numberOfTimes; i++) {\n+            \/\/ Create some more strings for every collection, to ensure\n+            \/\/ there will be deduplication work that will be reported.\n+            newStrings.add(createStrings(SmallNumberOfStrings, SmallNumberOfStrings));\n+            System.out.println(\"Begin: Young GC \" + (i + 1) + \"\/\" + numberOfTimes);\n+            for (int j = 0; j < maxObjectInYoung + 1; j++) {\n+                dummy = new byte[objectSize];\n+            }\n+            System.out.println(\"End: Young GC \" + (i + 1) + \"\/\" + numberOfTimes);\n+        }\n+    }\n+\n+    private static void forceDeduplication(int ageThreshold, String gcType) {\n+        \/\/ Force deduplication to happen by either causing a FullGC or a YoungGC.\n+        \/\/ We do several collections to also provoke a situation where the the\n+        \/\/ deduplication thread needs to yield while processing the queue. This\n+        \/\/ also tests that the references in the deduplication queue are adjusted\n+        \/\/ accordingly.\n+        if (gcType.equals(FullGC)) {\n+            doFullGc(3);\n+        } else {\n+            doYoungGc(ageThreshold + 3);\n+        }\n+    }\n+\n+    private static boolean waitForDeduplication(String s1, String s2) {\n+        boolean first = true;\n+        int timeout = 10000;     \/\/ 10sec in ms\n+        int iterationWait = 100; \/\/ 100ms\n+        for (int attempts = 0; attempts < (timeout \/ iterationWait); attempts++) {\n+            if (getValue(s1) == getValue(s2)) {\n+                return true;\n+            }\n+            if (first) {\n+                System.out.println(\"Waiting for deduplication...\");\n+                first = false;\n+            }\n+            try {\n+                Thread.sleep(iterationWait);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static String generateString(int id) {\n+        StringBuilder builder = new StringBuilder(StringLength);\n+\n+        builder.append(\"DeduplicationTestString:\" + id + \":\");\n+\n+        while (builder.length() < StringLength) {\n+            builder.append('X');\n+        }\n+\n+        return builder.toString();\n+    }\n+\n+    private static ArrayList<String> createStrings(int total, int unique) {\n+        System.out.println(\"Creating strings: total=\" + total + \", unique=\" + unique);\n+        if (total % unique != 0) {\n+            throw new RuntimeException(\"Total must be divisible by unique\");\n+        }\n+\n+        ArrayList<String> list = new ArrayList<String>(total);\n+        for (int j = 0; j < total \/ unique; j++) {\n+            for (int i = 0; i < unique; i++) {\n+                list.add(generateString(i));\n+            }\n+        }\n+\n+        return list;\n+    }\n+\n+    \/**\n+     * Verifies that the given list contains expected number of unique strings.\n+     * It's possible that deduplication hasn't completed yet, so the method\n+     * will perform several attempts to check with a little pause between.\n+     * The method throws RuntimeException to signal that verification failed.\n+     *\n+     * @param list strings to check\n+     * @param uniqueExpected expected number of unique strings\n+     * @throws RuntimeException if check fails\n+     *\/\n+    private static void verifyStrings(ArrayList<String> list, int uniqueExpected) {\n+        boolean passed = false;\n+        for (int attempts = 0; attempts < 10; attempts++) {\n+            \/\/ Check number of deduplicated strings\n+            ArrayList<Object> unique = new ArrayList<Object>(uniqueExpected);\n+            for (String string: list) {\n+                Object value = getValue(string);\n+                boolean uniqueValue = true;\n+                for (Object obj: unique) {\n+                    if (obj == value) {\n+                        uniqueValue = false;\n+                        break;\n+                    }\n+                }\n+\n+                if (uniqueValue) {\n+                    unique.add(value);\n+                }\n+            }\n+\n+            System.out.println(\"Verifying strings: total=\" + list.size() +\n+                               \", uniqueFound=\" + unique.size() +\n+                               \", uniqueExpected=\" + uniqueExpected);\n+\n+            if (unique.size() == uniqueExpected) {\n+                System.out.println(\"Deduplication completed (as fast as \" + attempts + \" iterations)\");\n+                passed = true;\n+                break;\n+            } else {\n+                System.out.println(\"Deduplication not completed, waiting...\");\n+                \/\/ Give the deduplication thread time to complete\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+        if (!passed) {\n+            throw new RuntimeException(\"String verification failed\");\n+        }\n+    }\n+\n+    private static OutputAnalyzer runTest(String... extraArgs) throws Exception {\n+        String[] defaultArgs = new String[] {\n+            \"-Xmn\" + Xmn + \"m\",\n+            \"-Xms\" + Xms + \"m\",\n+            \"-Xmx\" + Xmx + \"m\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\",\n+            \"-XX:+VerifyAfterGC\" \/\/ Always verify after GC\n+        };\n+\n+        ArrayList<String> args = new ArrayList<String>();\n+        args.addAll(Arrays.asList(defaultArgs));\n+        args.addAll(Arrays.asList(extraArgs));\n+\n+        ProcessBuilder pb = ProcessTools.createTestJvm(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.err.println(output.getStderr());\n+        System.out.println(output.getStdout());\n+        return output;\n+    }\n+\n+    private static class DeduplicationTest {\n+        public static void main(String[] args) {\n+            System.out.println(\"Begin: DeduplicationTest\");\n+\n+            final int numberOfStrings = Integer.parseUnsignedInt(args[0]);\n+            final int numberOfUniqueStrings = Integer.parseUnsignedInt(args[1]);\n+            final int ageThreshold = Integer.parseUnsignedInt(args[2]);\n+            final String gcType = args[3];\n+\n+            ArrayList<String> list = createStrings(numberOfStrings, numberOfUniqueStrings);\n+            forceDeduplication(ageThreshold, gcType);\n+            verifyStrings(list, numberOfUniqueStrings);\n+\n+            System.out.println(\"End: DeduplicationTest\");\n+        }\n+\n+        public static OutputAnalyzer run(int numberOfStrings, int ageThreshold, String gcType, String... extraArgs) throws Exception {\n+            String[] defaultArgs = new String[] {\n+                \"-XX:+UseStringDeduplication\",\n+                \"-XX:StringDeduplicationAgeThreshold=\" + ageThreshold,\n+                DeduplicationTest.class.getName(),\n+                \"\" + numberOfStrings,\n+                \"\" + numberOfStrings \/ 2,\n+                \"\" + ageThreshold,\n+                gcType\n+            };\n+\n+            ArrayList<String> args = new ArrayList<String>();\n+            args.addAll(Arrays.asList(extraArgs));\n+            args.addAll(Arrays.asList(defaultArgs));\n+\n+            return runTest(args.toArray(new String[args.size()]));\n+        }\n+    }\n+\n+    private static class InternedTest {\n+        public static void main(String[] args) {\n+            \/\/ This test verifies that interned strings are always\n+            \/\/ deduplicated when being interned, and never after\n+            \/\/ being interned.\n+\n+            System.out.println(\"Begin: InternedTest\");\n+\n+            final int ageThreshold = Integer.parseUnsignedInt(args[0]);\n+            final String baseString = \"DeduplicationTestString:\" + InternedTest.class.getName();\n+\n+            \/\/ Create duplicate of baseString\n+            StringBuilder sb1 = new StringBuilder(baseString);\n+            String dupString1 = sb1.toString();\n+            if (getValue(dupString1) == getValue(baseString)) {\n+                throw new RuntimeException(\"Values should not match\");\n+            }\n+\n+            \/\/ Force baseString to be inspected for deduplication\n+            \/\/ and be inserted into the deduplication hashtable.\n+            forceDeduplication(ageThreshold, FullGC);\n+\n+            if (!waitForDeduplication(dupString1, baseString)) {\n+                throw new RuntimeException(\"Deduplication has not occurred\");\n+            }\n+\n+            \/\/ Create a new duplicate of baseString\n+            StringBuilder sb2 = new StringBuilder(baseString);\n+            String dupString2 = sb2.toString();\n+            if (getValue(dupString2) == getValue(baseString)) {\n+                throw new RuntimeException(\"Values should not match\");\n+            }\n+\n+            \/\/ Intern the new duplicate\n+            Object beforeInternedValue = getValue(dupString2);\n+            String internedString = dupString2.intern();\n+            Object afterInternedValue = getValue(dupString2);\n+\n+            \/\/ Force internedString to be inspected for deduplication.\n+            \/\/ Because it was interned it should be queued up for\n+            \/\/ dedup, even though it hasn't reached the age threshold.\n+            doYoungGc(1);\n+\n+            if (internedString != dupString2) {\n+                throw new RuntimeException(\"String should match\");\n+            }\n+\n+            \/\/ Check original value of interned string, to make sure\n+            \/\/ deduplication happened on the interned string and not\n+            \/\/ on the base string\n+            if (beforeInternedValue == getValue(baseString)) {\n+                throw new RuntimeException(\"Values should not match\");\n+            }\n+\n+            \/\/ Create duplicate of baseString\n+            StringBuilder sb3 = new StringBuilder(baseString);\n+            String dupString3 = sb3.toString();\n+            if (getValue(dupString3) == getValue(baseString)) {\n+                throw new RuntimeException(\"Values should not match\");\n+            }\n+\n+            forceDeduplication(ageThreshold, FullGC);\n+\n+            if (!waitForDeduplication(dupString3, baseString)) {\n+                if (getValue(dupString3) != getValue(internedString)) {\n+                    throw new RuntimeException(\"String 3 doesn't match either\");\n+                }\n+            }\n+\n+            if (afterInternedValue != getValue(dupString2)) {\n+                throw new RuntimeException(\"Interned string value changed\");\n+            }\n+\n+            System.out.println(\"End: InternedTest\");\n+        }\n+\n+        public static OutputAnalyzer run() throws Exception {\n+            return runTest(\"-Xlog:gc=debug,stringdedup*=debug\",\n+                           \"-XX:+UseStringDeduplication\",\n+                           \"-XX:StringDeduplicationAgeThreshold=\" + DefaultAgeThreshold,\n+                           InternedTest.class.getName(),\n+                           \"\" + DefaultAgeThreshold);\n+        }\n+    }\n+\n+    \/*\n+     * Tests\n+     *\/\n+\n+    private static final int MaxAgeThreshold      = 15;\n+    private static final int DefaultAgeThreshold  = 3;\n+    private static final int MinAgeThreshold      = 1;\n+\n+    private static final int TooLowAgeThreshold   = MinAgeThreshold - 1;\n+    private static final int TooHighAgeThreshold  = MaxAgeThreshold + 1;\n+\n+    public static void testYoungGC() throws Exception {\n+        \/\/ Do young GC to age strings to provoke deduplication\n+        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n+                                                      DefaultAgeThreshold,\n+                                                      YoungGC,\n+                                                      \"-Xlog:gc*,stringdedup*=debug\");\n+        output.shouldContain(\"Concurrent String Deduplication\");\n+        output.shouldContain(\"Deduplicated:\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static void testFullGC() throws Exception {\n+        \/\/ Do full GC to age strings to provoke deduplication\n+        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n+                                                      DefaultAgeThreshold,\n+                                                      FullGC,\n+                                                      \"-Xlog:gc*,stringdedup*=debug\");\n+        output.shouldContain(\"Concurrent String Deduplication\");\n+        output.shouldContain(\"Deduplicated:\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static void testTableResize() throws Exception {\n+        \/\/ Test with StringDeduplicationResizeALot\n+        OutputAnalyzer output = DeduplicationTest.run(LargeNumberOfStrings,\n+                                                      DefaultAgeThreshold,\n+                                                      YoungGC,\n+                                                      \"-Xlog:gc*,stringdedup*=debug\",\n+                                                      \"-XX:+StringDeduplicationResizeALot\");\n+        output.shouldContain(\"Concurrent String Deduplication\");\n+        output.shouldContain(\"Deduplicated:\");\n+        output.shouldNotContain(\"Resize Count: 0\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static void testAgeThreshold() throws Exception {\n+        OutputAnalyzer output;\n+\n+        \/\/ Test with max age theshold\n+        output = DeduplicationTest.run(SmallNumberOfStrings,\n+                                       MaxAgeThreshold,\n+                                       YoungGC,\n+                                       \"-Xlog:gc*,stringdedup*=debug\");\n+        output.shouldContain(\"Concurrent String Deduplication\");\n+        output.shouldContain(\"Deduplicated:\");\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ Test with min age theshold\n+        output = DeduplicationTest.run(SmallNumberOfStrings,\n+                                       MinAgeThreshold,\n+                                       YoungGC,\n+                                       \"-Xlog:gc*,stringdedup*=debug\");\n+        output.shouldContain(\"Concurrent String Deduplication\");\n+        output.shouldContain(\"Deduplicated:\");\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ Test with too low age threshold\n+        output = DeduplicationTest.run(SmallNumberOfStrings,\n+                                       TooLowAgeThreshold,\n+                                       YoungGC);\n+        output.shouldContain(\"outside the allowed range\");\n+        output.shouldHaveExitValue(1);\n+\n+        \/\/ Test with too high age threshold\n+        output = DeduplicationTest.run(SmallNumberOfStrings,\n+                                       TooHighAgeThreshold,\n+                                       YoungGC);\n+        output.shouldContain(\"outside the allowed range\");\n+        output.shouldHaveExitValue(1);\n+    }\n+\n+    public static void testPrintOptions() throws Exception {\n+        OutputAnalyzer output;\n+\n+        \/\/ Test without -Xlog:gc\n+        output = DeduplicationTest.run(SmallNumberOfStrings,\n+                                       DefaultAgeThreshold,\n+                                       YoungGC);\n+        output.shouldNotContain(\"Concurrent String Deduplication\");\n+        output.shouldNotContain(\"Deduplicated:\");\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ Test with -Xlog:stringdedup\n+        output = DeduplicationTest.run(SmallNumberOfStrings,\n+                                       DefaultAgeThreshold,\n+                                       YoungGC,\n+                                       \"-Xlog:stringdedup\");\n+        output.shouldContain(\"Concurrent String Deduplication\");\n+        output.shouldNotContain(\"Deduplicated:\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static void testInterned() throws Exception {\n+        \/\/ Test that interned strings are deduplicated before being interned\n+        OutputAnalyzer output = InternedTest.run();\n+        output.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationTools.java","additions":467,"deletions":0,"binary":false,"changes":467,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stringdedup;\n+\n+\/*\n+ * @test TestStringDeduplicationYoungGC\n+ * @summary Test string deduplication during young GC\n+ * @bug 8029075\n+ * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationYoungGC\n+ *\/\n+\n+public class TestStringDeduplicationYoungGC {\n+    public static void main(String[] args) throws Exception {\n+        TestStringDeduplicationTools.testYoungGC();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationYoungGC.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}