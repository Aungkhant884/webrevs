{"files":[{"patch":"@@ -147,1 +147,0 @@\n-  assert(G1ThreadLocalData::dirty_card_queue(thread).is_active(), \"Dirty card queue should be active\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,3 +53,1 @@\n-  \/\/ Dirty card queues are always active, so we create them with their\n-  \/\/ active field set to true.\n-  PtrQueue(qset, true \/* active *\/),\n+  PtrQueue(qset),\n@@ -89,3 +87,1 @@\n-{\n-  _all_active = true;\n-}\n+{}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  PtrQueue(qset, true \/* always active *\/)\n+  PtrQueue(qset)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  nonstatic_field(PtrQueue,            _active,         bool)                 \\\n+  nonstatic_field(SATBMarkQueue,       _active,         bool)                 \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-PtrQueue::PtrQueue(PtrQueueSet* qset, bool active) :\n+PtrQueue::PtrQueue(PtrQueueSet* qset) :\n@@ -40,1 +40,0 @@\n-  _active(active),\n@@ -224,2 +223,1 @@\n-  _allocator(allocator),\n-  _all_active(false)\n+  _allocator(allocator)\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-  \/\/ Whether updates should be logged.\n-  bool _active;\n-\n@@ -95,1 +92,1 @@\n-  PtrQueue(PtrQueueSet* qset, bool active = false);\n+  PtrQueue(PtrQueueSet* qset);\n@@ -148,15 +145,0 @@\n-  \/\/ Set the \"active\" property of the queue to \"b\".  An enqueue to an\n-  \/\/ inactive thread is a no-op.  Setting a queue to inactive resets its\n-  \/\/ log to the empty state.\n-  void set_active(bool b) {\n-    _active = b;\n-    if (!b && _buf != NULL) {\n-      reset();\n-    } else if (b && _buf != NULL) {\n-      assert(index() == capacity(),\n-             \"invariant: queues are empty when activated.\");\n-    }\n-  }\n-\n-  bool is_active() const { return _active; }\n-\n@@ -179,8 +161,0 @@\n-\n-  template<typename Derived>\n-  static ByteSize byte_offset_of_active() {\n-    return byte_offset_of(Derived, _active);\n-  }\n-\n-  static ByteSize byte_width_of_active() { return in_ByteSize(sizeof(bool)); }\n-\n@@ -293,2 +267,0 @@\n-  bool _all_active;\n-\n@@ -332,2 +304,0 @@\n-  bool is_active() { return _all_active; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,5 +41,5 @@\n-  \/\/ SATB queues are only active during marking cycles. We create\n-  \/\/ them with their active field set to false. If a thread is\n-  \/\/ created during a cycle and its SATB queue needs to be activated\n-  \/\/ before the thread starts running, we'll need to set its active\n-  \/\/ field to true. This must be done in the collector-specific\n+  PtrQueue(qset),\n+  \/\/ SATB queues are only active during marking cycles. We create them\n+  \/\/ with their active field set to false. If a thread is created\n+  \/\/ during a cycle, it's SATB queue needs to be activated before the\n+  \/\/ thread starts running.  This is handled by the collector-specific\n@@ -47,1 +47,1 @@\n-  PtrQueue(qset, false \/* active *\/)\n+  _active(false)\n@@ -89,1 +89,2 @@\n-  _buffer_enqueue_threshold(0)\n+  _buffer_enqueue_threshold(0),\n+  _all_active(false)\n@@ -210,1 +211,7 @@\n-      _qset->satb_queue_for_thread(t).set_active(_active);\n+      SATBMarkQueue& queue = _qset->satb_queue_for_thread(t);\n+      if (queue.buffer() != nullptr) {\n+        assert(!_active || queue.index() == _qset->buffer_size(),\n+               \"queues should be empty when activated\");\n+        queue.set_index(_qset->buffer_size());\n+      }\n+      queue.set_active(_active);\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  friend class VMStructs;\n@@ -52,0 +53,4 @@\n+  \/\/ Per-queue (so thread-local) cache of the SATBMarkQueueSet's\n+  \/\/ active state, to support inline barriers in compiled code.\n+  bool _active;\n+\n@@ -58,0 +63,3 @@\n+  bool is_active() const { return _active; }\n+  void set_active(bool value) { _active = value; }\n+\n@@ -84,1 +92,1 @@\n-    return PtrQueue::byte_offset_of_active<SATBMarkQueue>();\n+    return byte_offset_of(SATBMarkQueue, _active);\n@@ -86,1 +94,0 @@\n-  using PtrQueue::byte_width_of_active;\n@@ -88,0 +95,1 @@\n+  static ByteSize byte_width_of_active() { return in_ByteSize(sizeof(bool)); }\n@@ -98,1 +106,3 @@\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 3 * sizeof(size_t));\n+  \/\/ SATB is only active during marking.  Enqueuing is not done when inactive.\n+  bool _all_active;\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 4 * sizeof(size_t));\n@@ -124,0 +134,2 @@\n+  bool is_active() const { return _all_active; }\n+\n@@ -141,0 +153,1 @@\n+  \/\/ When active, add obj to queue by calling enqueue_known_active.\n@@ -144,0 +157,1 @@\n+  \/\/ Add obj to queue.  This qset and the queue must be active.\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"}]}