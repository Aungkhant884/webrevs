{"files":[{"patch":"@@ -404,1 +404,0 @@\n-#ifdef ASSERT\n@@ -406,2 +405,1 @@\n-    : _base(r), _index(noreg), _offset(in_bytes(disp)), _mode(base_plus_offset), _target(0) { }\n-#endif\n+    : Address(r, in_bytes(disp)) { }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,11 +92,2 @@\n-#ifdef ASSERT\n-  Address(Register rn, ByteSize offset, AsmOffset mode = basic_offset) {\n-    _base = rn;\n-    _index = noreg;\n-    _disp = in_bytes(offset);\n-    _mode = mode;\n-    _shift_imm = 0;\n-    _shift = lsl;\n-    _offset_op = add_offset;\n-  }\n-#endif\n+  Address(Register rn, ByteSize offset, AsmOffset mode = basic_offset) :\n+    Address(rn, in_bytes(offset), mode) {}\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,6 +58,2 @@\n-#ifdef ASSERT\n-  AsmOperand(ByteSize bytesize_8) {\n-    const int imm_8 = in_bytes(bytesize_8);\n-    encode(imm_8);\n-  }\n-#endif \/\/ ASSERT\n+  AsmOperand(ByteSize bytesize_8) :\n+    AsmOperand(in_bytes(bytesize_8)) {}\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1642,1 +1642,1 @@\n-  DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)\n+  inline void ld_ptr(Register d, ByteSize b, Register s1);\n@@ -1666,1 +1666,1 @@\n-  DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)\n+  inline void st_ptr(Register d, ByteSize b, Register s1);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-DEBUG_ONLY(inline void Assembler::ld_ptr(Register d, ByteSize b, Register s1) { ld(d, in_bytes(b), s1); })\n+inline void Assembler::ld_ptr(Register d, ByteSize b, Register s1) { ld(d, in_bytes(b), s1); }\n@@ -369,1 +369,1 @@\n-DEBUG_ONLY(inline void Assembler::st_ptr(Register d, ByteSize b, Register s1) { std(d, in_bytes(b), s1); })\n+inline void Assembler::st_ptr(Register d, ByteSize b, Register s1) { std(d, in_bytes(b), s1); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -209,2 +209,0 @@\n-#ifdef ASSERT\n-  \/\/ ByteSize is only a class when ASSERT is defined, otherwise it's an int.\n@@ -212,3 +210,1 @@\n-    _base(base),\n-    _index(noreg),\n-    _disp(in_bytes(disp)) {}\n+    Address(base, in_bytes(disp)) {}\n@@ -217,4 +213,1 @@\n-    _base(base),\n-    _index(index),\n-    _disp(in_bytes(disp)) {}\n-#endif\n+    Address(base, index, in_bytes(disp)) {}\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -259,0 +259,13 @@\n+  \/\/ The following overloads are used in connection with the\n+  \/\/ ByteSize type (see sizes.hpp).  They simplify the use of\n+  \/\/ ByteSize'd arguments in assembly code.\n+\n+  Address(Register base, ByteSize disp)\n+    : Address(base, in_bytes(disp)) {}\n+\n+  Address(Register base, Register index, ScaleFactor scale, ByteSize disp)\n+    : Address(base, index, scale, in_bytes(disp)) {}\n+\n+  Address(Register base, RegisterOrConstant index, ScaleFactor scale, ByteSize disp)\n+    : Address(base, index, scale, in_bytes(disp)) {}\n+\n@@ -279,45 +292,0 @@\n-  \/\/ The following two overloads are used in connection with the\n-  \/\/ ByteSize type (see sizes.hpp).  They simplify the use of\n-  \/\/ ByteSize'd arguments in assembly code. Note that their equivalent\n-  \/\/ for the optimized build are the member functions with int disp\n-  \/\/ argument since ByteSize is mapped to an int type in that case.\n-  \/\/\n-  \/\/ Note: DO NOT introduce similar overloaded functions for WordSize\n-  \/\/ arguments as in the optimized mode, both ByteSize and WordSize\n-  \/\/ are mapped to the same type and thus the compiler cannot make a\n-  \/\/ distinction anymore (=> compiler errors).\n-\n-#ifdef ASSERT\n-  Address(Register base, ByteSize disp)\n-    : _base(base),\n-      _index(noreg),\n-      _xmmindex(xnoreg),\n-      _scale(no_scale),\n-      _disp(in_bytes(disp)),\n-      _isxmmindex(false){\n-  }\n-\n-  Address(Register base, Register index, ScaleFactor scale, ByteSize disp)\n-    : _base(base),\n-      _index(index),\n-      _xmmindex(xnoreg),\n-      _scale(scale),\n-      _disp(in_bytes(disp)),\n-      _isxmmindex(false){\n-    assert(!index->is_valid() == (scale == Address::no_scale),\n-           \"inconsistent address\");\n-  }\n-  Address(Register base, RegisterOrConstant index, ScaleFactor scale, ByteSize disp)\n-    : _base (base),\n-      _index(index.register_or_noreg()),\n-      _xmmindex(xnoreg),\n-      _scale(scale),\n-      _disp (in_bytes(disp) + (index.constant_or_zero() * scale_size(scale))),\n-      _isxmmindex(false) {\n-    if (!index.is_register())  scale = Address::no_scale;\n-    assert(!_index->is_valid() == (scale == Address::no_scale),\n-           \"inconsistent address\");\n-  }\n-\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":13,"deletions":45,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -35,16 +35,0 @@\n-\/\/ The classes are defined with friend functions operating on them instead of member\n-\/\/ functions so that they (the classes) can be re-#define'd to int types in optimized\n-\/\/ mode. This allows full type checking and maximum safety in debug mode, and full\n-\/\/ optimizations (constant folding) and zero overhead (time and space wise) in the\n-\/\/ optimized build (some compilers do not optimize one-element value classes but\n-\/\/ instead create an object in memory - thus the overhead may be significant).\n-\/\/\n-\/\/ Note: 1) DO NOT add new overloaded friend functions that do not have a unique function\n-\/\/          function name but require signature types for resolution. This will not work\n-\/\/          in optimized mode as both, ByteSize and WordSize are mapped to the same type\n-\/\/          and thus the distinction would not be possible anymore (=> compiler errors).\n-\/\/\n-\/\/       2) DO NOT add non-static member functions as they cannot be mapped so something\n-\/\/          compilable in the optimized build. Static member functions could be added\n-\/\/          but require a corresponding class definition in the optimized build.\n-\/\/\n@@ -59,0 +43,1 @@\n+enum class WordSize : int {};\n@@ -60,79 +45,2 @@\n-#ifdef ASSERT\n-\n-class ByteSize {\n- private:\n-  int _size;\n-\n-  \/\/ Note: This constructor must be private to avoid implicit conversions!\n-  ByteSize(int size)                                  { _size = size; }\n-\n- public:\n-  \/\/ constructors\n-  inline friend ByteSize in_ByteSize(int size);\n-\n-  \/\/ accessors\n-  inline friend int in_bytes(ByteSize x);\n-\n-  \/\/ operators\n-  friend ByteSize operator + (ByteSize x, ByteSize y) { return ByteSize(in_bytes(x) + in_bytes(y)); }\n-  friend ByteSize operator - (ByteSize x, ByteSize y) { return ByteSize(in_bytes(x) - in_bytes(y)); }\n-  friend ByteSize operator * (ByteSize x, int      y) { return ByteSize(in_bytes(x) * y          ); }\n-\n-  \/\/ comparison\n-  friend bool operator == (ByteSize x, ByteSize y)    { return in_bytes(x) == in_bytes(y); }\n-  friend bool operator != (ByteSize x, ByteSize y)    { return in_bytes(x) != in_bytes(y); }\n-  friend bool operator <  (ByteSize x, ByteSize y)    { return in_bytes(x) <  in_bytes(y); }\n-  friend bool operator <= (ByteSize x, ByteSize y)    { return in_bytes(x) <= in_bytes(y); }\n-  friend bool operator >  (ByteSize x, ByteSize y)    { return in_bytes(x) >  in_bytes(y); }\n-  friend bool operator >= (ByteSize x, ByteSize y)    { return in_bytes(x) >= in_bytes(y); }\n-};\n-\n-inline ByteSize in_ByteSize(int size) { return ByteSize(size); }\n-inline int      in_bytes(ByteSize x)  { return x._size; }\n-\n-\n-class WordSize {\n- private:\n-  int _size;\n-\n-  \/\/ Note: This constructor must be private to avoid implicit conversions!\n-  WordSize(int size)                                  { _size = size; }\n-\n- public:\n-  \/\/ constructors\n-  inline friend WordSize in_WordSize(int size);\n-\n-  \/\/ accessors\n-  inline friend int in_words(WordSize x);\n-\n-  \/\/ operators\n-  friend WordSize operator + (WordSize x, WordSize y) { return WordSize(in_words(x) + in_words(y)); }\n-  friend WordSize operator - (WordSize x, WordSize y) { return WordSize(in_words(x) - in_words(y)); }\n-  friend WordSize operator * (WordSize x, int      y) { return WordSize(in_words(x) * y          ); }\n-\n-  \/\/ comparison\n-  friend bool operator == (WordSize x, WordSize y)    { return in_words(x) == in_words(y); }\n-  friend bool operator != (WordSize x, WordSize y)    { return in_words(x) != in_words(y); }\n-  friend bool operator <  (WordSize x, WordSize y)    { return in_words(x) <  in_words(y); }\n-  friend bool operator <= (WordSize x, WordSize y)    { return in_words(x) <= in_words(y); }\n-  friend bool operator >  (WordSize x, WordSize y)    { return in_words(x) >  in_words(y); }\n-  friend bool operator >= (WordSize x, WordSize y)    { return in_words(x) >= in_words(y); }\n-};\n-\n-inline WordSize in_WordSize(int size) { return WordSize(size); }\n-inline int      in_words(WordSize x)  { return x._size; }\n-\n-\n-#else \/\/ ASSERT\n-\n-\/\/ The following definitions must match the corresponding friend declarations\n-\/\/ in the Byte\/WordSize classes if they are typedef'ed to be int. This will\n-\/\/ be the case in optimized mode to ensure zero overhead for these types.\n-\/\/\n-\/\/ Note: If a compiler does not inline these function calls away, one may\n-\/\/       want to use #define's to make sure full optimization (constant\n-\/\/       folding in particular) is possible.\n-\n-typedef int ByteSize;\n-inline ByteSize in_ByteSize(int size)                 { return size; }\n-inline int      in_bytes   (ByteSize x)               { return x; }\n+constexpr WordSize in_WordSize(int size) { return static_cast<WordSize>(size); }\n+constexpr int      in_words(WordSize x)  { return static_cast<int>(x); }\n@@ -140,3 +48,1 @@\n-typedef int WordSize;\n-inline WordSize in_WordSize(int size)                 { return size; }\n-inline int      in_words   (WordSize x)               { return x; }\n+enum class ByteSize : int {};\n@@ -144,1 +50,2 @@\n-#endif \/\/ ASSERT\n+constexpr ByteSize in_ByteSize(int size) { return static_cast<ByteSize>(size); }\n+constexpr int      in_bytes(ByteSize x)  { return static_cast<int>(x); }\n@@ -146,0 +53,3 @@\n+constexpr ByteSize operator + (ByteSize x, ByteSize y) { return in_ByteSize(in_bytes(x) + in_bytes(y)); }\n+constexpr ByteSize operator - (ByteSize x, ByteSize y) { return in_ByteSize(in_bytes(x) - in_bytes(y)); }\n+constexpr ByteSize operator * (ByteSize x, int      y) { return in_ByteSize(in_bytes(x) * y          ); }\n","filename":"src\/hotspot\/share\/utilities\/sizes.hpp","additions":9,"deletions":99,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/sizes.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST(ByteSize, constructors) {\n+  EXPECT_EQ(in_bytes(in_ByteSize(10)), 10);\n+}\n+\n+TEST(ByteSize, operators) {\n+  ByteSize s = in_ByteSize(7);\n+  ASSERT_EQ(in_bytes(s + in_ByteSize(3)), 10);\n+  ASSERT_EQ(in_bytes(s - in_ByteSize(3)), 4);\n+  ASSERT_EQ(in_bytes(s * 3), 21);\n+}\n+\n+TEST(WordSize, constructors) {\n+  EXPECT_EQ(in_words(in_WordSize(10)), 10);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_sizes.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}