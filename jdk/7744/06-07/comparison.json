{"files":[{"patch":"@@ -249,44 +249,0 @@\n-    \/**\n-     * Given components array and index, recast and reorder that component to\n-     * match shape.\n-     *\n-     * @param carrierShape  carrier reshape\n-     * @param components    carrier components\n-     * @param i             index of component to reshape\n-     *\n-     * @return component reshaped\n-     *\/\n-    private static MethodHandle reshapeComponent(CarrierShape carrierShape,\n-                                                 MethodHandle[] components, int i) {\n-        Class<?>[] ptypes = carrierShape.ptypes();\n-        CarrierCounts componentCounts = CarrierCounts.tally(ptypes, i);\n-        Class<?> ptype = ptypes[i];\n-        int index;\n-        MethodHandle filter = null;\n-\n-        if (!ptype.isPrimitive()) {\n-            index = carrierShape.objectOffset() + componentCounts.objectCount();\n-        } else if (ptype == double.class) {\n-            index = carrierShape.longOffset() + componentCounts.longCount();\n-            filter = LONG_TO_DOUBLE;\n-        } else if (ptype == float.class) {\n-            index = carrierShape.intOffset() + componentCounts.intCount();\n-            filter = INT_TO_FLOAT;\n-        } else if (ptype == long.class) {\n-            index = carrierShape.longOffset() + componentCounts.longCount();\n-        } else {\n-            index = carrierShape.intOffset() + componentCounts.intCount();\n-        }\n-\n-        MethodHandle component = components[index];\n-\n-        if (filter != null) {\n-            component = MethodHandles.filterReturnValue(component, filter);\n-        }\n-\n-        component = MethodHandles.explicitCastArguments(component,\n-                methodType(ptype, Object.class));\n-\n-        return component;\n-    }\n-\n@@ -544,14 +500,0 @@\n-\n-        \/**\n-         * Return a carrier accessor for component {@code i}.\n-         *\n-         * @param carrierShape  carrier object shape\n-         * @param i             index of parameter to get\n-         *\n-         * @return carrier component {@code i} accessor {@link MethodHandle}\n-         *\/\n-        private static MethodHandle component(CarrierShape carrierShape, int i) {\n-            MethodHandle[] components = createComponents(carrierShape);\n-\n-            return reshapeComponent(carrierShape, components, i);\n-        }\n@@ -872,19 +814,0 @@\n-\n-        \/**\n-         * Returns a carrier component accessor {@link MethodHandle} for the\n-         * component {@code i}.\n-         *\n-         * @param carrierShape  shape of the carrier object\n-         * @param i             index to the component\n-         *\n-         * @return carrier component accessor {@link MethodHandle}\n-         *\n-         * @throws IllegalArgumentException if number of component slots exceeds\n-         *         maximum\n-         *\/\n-        private static MethodHandle component(CarrierShape carrierShape, int i) {\n-            CarrierClass carrierClass = findCarrierClass(carrierShape);\n-            MethodHandle[] components = carrierClass.components;\n-\n-            return reshapeComponent(carrierShape, components, i);\n-        }\n@@ -1023,7 +946,0 @@\n-        \/**\n-         * {@return supplied methodType}\n-         *\/\n-        private MethodType methodType() {\n-            return methodType;\n-        }\n-\n@@ -1133,0 +1049,2 @@\n+     * @implSpec The array returned is guaranteed to be a fresh copy. This allows the\n+     * client can replace elements tailored to their needs without impacting other clients.\n@@ -1148,28 +1066,0 @@\n-    \/**\n-     * Return a component accessor {@link MethodHandle} for component {@code i}.\n-     *\n-     * @param methodType  {@link MethodType} providing types for the carrier's\n-     *                    components\n-     * @param i           component index\n-     *\n-     * @return a component accessor {@link MethodHandle} for component {@code i}\n-     *\n-     * @throws NullPointerException is any argument is null\n-     * @throws IllegalArgumentException if number of component slots exceeds maximum\n-     *                                  or if {@code i} is out of bounds\n-     *\/\n-    public static MethodHandle component(MethodType methodType, int i) {\n-        Objects.requireNonNull(methodType);\n-        CarrierShape carrierShape = new CarrierShape(methodType);\n-        int slotCount = carrierShape.slotCount();\n-\n-        if (i < 0 || i >= carrierShape.count()) {\n-            throw new IllegalArgumentException(\"i is out of bounds for parameter types\");\n-        } else if (MAX_COMPONENTS < slotCount) {\n-            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n-        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n-            return CarrierObjectFactory.component(carrierShape, i);\n-        } else {\n-            return CarrierArrayFactory.component(carrierShape, i);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":2,"deletions":112,"binary":false,"changes":114,"status":"modified"}]}