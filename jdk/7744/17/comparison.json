{"files":[{"patch":"@@ -0,0 +1,1179 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodHandles.Lookup.ClassOption;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * A <em>carrier<\/em> is an opaque object that can be used to store component values\n+ * while avoiding primitive boxing associated with collection objects. Component values\n+ * can be primitive or Object. Clients can create new carrier instances by describing a\n+ * carrier <em>shape<\/em>, that is, a {@linkplain MethodType method type} whose parameter\n+ * types describe the types of the carrier component values.\n+ *\n+ * @implNote The strategy for storing components is deliberately left unspecified\n+ * so that future improvements will not be hampered by backward compatibility\n+ * issues.\n+ *\n+ * @since 19\n+ *\/\n+public final class Carrier {\n+    \/**\n+     * Class file version.\n+     *\/\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+\n+    \/**\n+     * Maximum number of components in a carrier (based on the maximum\n+     * number of args to a constructor.)\n+     *\/\n+    public static final int MAX_COMPONENTS = 255 - \/* this *\/ 1;\n+\n+    \/**\n+     * Maximum number of components in a CarrierClass.\n+     *\/\n+    private static final int MAX_OBJECT_COMPONENTS = 32;\n+\n+    \/**\n+     * Stable annotation.\n+     *\/\n+    private static final String STABLE = \"jdk\/internal\/vm\/annotation\/Stable\";\n+    private static final String STABLE_SIG = \"L\" + STABLE + \";\";\n+\n+    \/**\n+     * Number of integer slots used by a long.\n+     *\/\n+    private static final int LONG_SLOTS = 2;\n+\n+    \/*\n+     * Initialize {@link MethodHandle} constants.\n+     *\/\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            FLOAT_TO_INT = lookup.findStatic(Float.class, \"floatToRawIntBits\",\n+                    methodType(int.class, float.class));\n+            INT_TO_FLOAT = lookup.findStatic(Float.class, \"intBitsToFloat\",\n+                    methodType(float.class, int.class));\n+            DOUBLE_TO_LONG = lookup.findStatic(Double.class, \"doubleToRawLongBits\",\n+                    methodType(long.class, double.class));\n+            LONG_TO_DOUBLE = lookup.findStatic(Double.class, \"longBitsToDouble\",\n+                    methodType(double.class, long.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * float\/double conversions.\n+     *\/\n+    private static final MethodHandle FLOAT_TO_INT;\n+    private static final MethodHandle INT_TO_FLOAT;\n+    private static final MethodHandle DOUBLE_TO_LONG;\n+    private static final MethodHandle LONG_TO_DOUBLE;\n+\n+    \/**\n+     * long signature descriptor.\n+     *\/\n+    private static final String LONG_DESCRIPTOR =\n+            Type.getDescriptor(long.class);\n+\n+    \/**\n+     * int signature descriptor.\n+     *\/\n+    private static final String INT_DESCRIPTOR =\n+            Type.getDescriptor(int.class);\n+\n+    \/**\n+     * Object signature descriptor.\n+     *\/\n+    private static final String OBJECT_DESCRIPTOR =\n+            Type.getDescriptor(Object.class);\n+\n+    \/**\n+     * Cache mapping {@link MethodType} to previously defined\n+     * {@link Carrier Carriers}.\n+     *\/\n+    private static ConcurrentHashMap<MethodType, Carrier>\n+            methodTypeCache = new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Class of the underly carrier.\n+     *\/\n+    private final Class<?> carrierClass;\n+\n+    \/**\n+     * Constructor {@link MethodHandle}.\n+     *\/\n+    private final MethodHandle constructor;\n+\n+    \/**\n+     * List of component {@link MethodHandle MethodHandles}\n+     *\/\n+    private final List<MethodHandle> components;\n+\n+    \/**\n+     * Given a constructor {@link MethodHandle} recast and reorder arguments to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier shape\n+     * @param constructor   carrier constructor to reshape\n+     *\n+     * @return constructor with arguments recasted and reordered\n+     *\/\n+    private static MethodHandle reshapeConstructor(CarrierShape carrierShape,\n+                                                   MethodHandle constructor) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int[] reorder = new int[count];\n+        Class<?>[] permutePTypes = new Class<?>[count];\n+        MethodHandle[] filters = new MethodHandle[count];\n+        boolean hasFilters = false;\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle filter = null;\n+            int from;\n+\n+            if (!ptype.isPrimitive()) {\n+                from = objectIndex++;\n+                ptype = Object.class;\n+            } else if (ptype == double.class) {\n+                from = longIndex++;\n+                filter = DOUBLE_TO_LONG;\n+            } else if (ptype == float.class) {\n+                from = intIndex++;\n+                filter = FLOAT_TO_INT;\n+            } else if (ptype == long.class) {\n+                from = longIndex++;\n+            } else {\n+                from = intIndex++;\n+                ptype = int.class;\n+            }\n+\n+            permutePTypes[index] = ptype;\n+            reorder[from] = index++;\n+\n+            if (filter != null) {\n+                filters[from] = filter;\n+                hasFilters = true;\n+            }\n+        }\n+\n+        if (hasFilters) {\n+            constructor = MethodHandles.filterArguments(constructor, 0, filters);\n+        }\n+\n+        MethodType permutedMethodType =\n+                methodType(constructor.type().returnType(), permutePTypes);\n+        constructor = MethodHandles.permuteArguments(constructor,\n+                permutedMethodType, reorder);\n+        constructor = MethodHandles.explicitCastArguments(constructor,\n+                methodType(Object.class, ptypes));\n+\n+        return constructor;\n+    }\n+\n+    \/**\n+     * Given components array, recast and reorder components to match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components to reshape\n+     *\n+     * @return list of components reshaped\n+     *\/\n+    private static List<MethodHandle> reshapeComponents(CarrierShape carrierShape,\n+                                                        MethodHandle[] components) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        MethodHandle[] reorder = new MethodHandle[count];\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle component;\n+\n+            if (!ptype.isPrimitive()) {\n+                component = components[objectIndex++];\n+            } else if (ptype == double.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[longIndex++], LONG_TO_DOUBLE);\n+            } else if (ptype == float.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[intIndex++], INT_TO_FLOAT);\n+            } else if (ptype == long.class) {\n+                component = components[longIndex++];\n+            } else {\n+                component = components[intIndex++];\n+            }\n+\n+            MethodType methodType = methodType(ptype, Object.class);\n+            reorder[index++] =\n+                    MethodHandles.explicitCastArguments(component, methodType);\n+        }\n+\n+        return List.of(reorder);\n+    }\n+\n+    \/**\n+     * Factory for carriers that are backed by int[] and Object[]. This strategy is\n+     * used when the number of components exceeds {@link Carrier#MAX_OBJECT_COMPONENTS}.\n+     *\/\n+    private static class CarrierArrayFactory {\n+        \/**\n+         * Unsafe access.\n+         *\/\n+        private static final Unsafe UNSAFE;\n+\n+        static {\n+            try {\n+                UNSAFE = Unsafe.getUnsafe();\n+                Lookup lookup = MethodHandles.lookup();\n+                CONSTRUCTOR = lookup.findConstructor(CarrierArray.class,\n+                        methodType(void.class, int.class, int.class));\n+                GET_LONG = lookup.findVirtual(CarrierArray.class, \"getLong\",\n+                        methodType(long.class, int.class));\n+                PUT_LONG = lookup.findVirtual(CarrierArray.class, \"putLong\",\n+                        methodType(CarrierArray.class, int.class, long.class));\n+                GET_INTEGER = lookup.findVirtual(CarrierArray.class, \"getInteger\",\n+                        methodType(int.class, int.class));\n+                PUT_INTEGER = lookup.findVirtual(CarrierArray.class, \"putInteger\",\n+                        methodType(CarrierArray.class, int.class, int.class));\n+                GET_OBJECT = lookup.findVirtual(CarrierArray.class, \"getObject\",\n+                        methodType(Object.class, int.class));\n+                PUT_OBJECT = lookup.findVirtual(CarrierArray.class, \"putObject\",\n+                        methodType(CarrierArray.class, int.class, Object.class));\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier static init fail\", ex);\n+            }\n+        }\n+\n+        \/*\n+         * Constructor accessor MethodHandles.\n+         *\/\n+        private static final MethodHandle CONSTRUCTOR;\n+        private static final MethodHandle GET_LONG;\n+        private static final MethodHandle PUT_LONG;\n+        private static final MethodHandle GET_INTEGER;\n+        private static final MethodHandle PUT_INTEGER;\n+        private static final MethodHandle GET_OBJECT;\n+        private static final MethodHandle PUT_OBJECT;\n+\n+        \/**\n+         * Wrapper object for carrier arrays. Instances types are stored in the {@code objects}\n+         * array, while primitive types are recast to {@code int\/long} and stored in the\n+         * {@code primitives} array. Primitive byte, short, char, boolean and int are stored as\n+         * integers. Longs and doubles are stored as longs.  Longs take up the first part of the\n+         * primitives array using normal indices. Integers follow using int[] indices offset beyond\n+         * the longs using unsafe getInt\/putInt.\n+         *\/\n+        private static class CarrierArray {\n+            \/**\n+             * Carrier for primitive values.\n+             *\/\n+            private final long[] primitives;\n+\n+            \/**\n+             * Carrier for objects;\n+             *\/\n+            private final Object[] objects;\n+\n+            \/**\n+             * Constructor.\n+             *\n+             * @param primitiveCount  slot count required for primitives\n+             * @param objectCount     slot count required for objects\n+             *\/\n+            CarrierArray(int primitiveCount, int objectCount) {\n+                this.primitives =\n+                    primitiveCount != 0 ? new long[(primitiveCount + 1) \/ LONG_SLOTS] : null;\n+                this.objects = objectCount != 0 ? new Object[objectCount] : null;\n+            }\n+\n+            \/**\n+             * Check index and compute offset for unsafe access.\n+             *\n+             * @param i  index in primitive[]\n+             *\n+             * @return offset for unsafe access\n+             *\/\n+            private long offset(int i) {\n+                if (i < 0 || (primitives.length * LONG_SLOTS) <= i) {\n+                    throw new RuntimeException(\"primitive index out of range: \" + i);\n+                }\n+\n+                return Unsafe.ARRAY_LONG_BASE_OFFSET +\n+                        (long)i * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            }\n+\n+            \/**\n+             * {@return long value at index}\n+             *\n+             * @param i  array index\n+             *\/\n+            private long getLong(int i) {\n+                return primitives[i];\n+            }\n+\n+            \/**\n+             * Put a long value into the primitive[].\n+             *\n+             * @param i      array index\n+             * @param value  long value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putLong(int i, long value) {\n+                primitives[i] = value;\n+\n+                return this;\n+            }\n+\n+            \/**\n+             * {@return int value at index}\n+             *\n+             * @param i  array index\n+             *\/\n+            private int getInteger(int i) {\n+                return UNSAFE.getInt(primitives, offset(i));\n+            }\n+\n+            \/**\n+             * Put a int value into the int[].\n+             *\n+             * @param i      array index\n+             * @param value  int value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putInteger(int i, int value) {\n+                UNSAFE.putInt(primitives, offset(i), value);\n+\n+                return this;\n+            }\n+\n+            \/**\n+             * {@return Object value at index}\n+             *\n+             * @param i  array index\n+             *\/\n+            private Object getObject(int i) {\n+                return objects[i];\n+            }\n+\n+            \/**\n+             * Put a object value into the objects[].\n+             *\n+             * @param i      array index\n+             * @param value  object value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putObject(int i, Object value) {\n+                objects[i] = value;\n+\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * Constructor\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to generic carrier constructor.\n+         *\/\n+        private static MethodHandle constructor(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int primitiveCount = longCount * LONG_SLOTS + intCount;\n+\n+            MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,\n+                    0, primitiveCount, objectCount);\n+\n+            \/\/ long array index\n+            int index = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_LONG, 1, index++);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_INTEGER, 1, index++);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_OBJECT, 1, i);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            return constructor;\n+        }\n+\n+        \/**\n+         * Utility to construct the basic accessors from the components.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier accessors\n+         *\/\n+        private static MethodHandle[] createComponents(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle[] components =\n+                    new MethodHandle[carrierShape.ptypes().length];\n+\n+            \/\/ long array index\n+            int index = 0;\n+            \/\/ component index\n+            int comIndex = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_LONG, 1, index++);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_INTEGER, 1, index++);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_OBJECT, 1, i);\n+            }\n+            return components;\n+        }\n+\n+        \/**\n+         * Permute a raw constructor and component accessor\n+         * {@link MethodHandle MethodHandles} to match the order and types of\n+         * the parameter types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link Carrier} instance\n+         *\/\n+        private static Carrier carrier(CarrierShape carrierShape) {\n+            MethodHandle constructor = constructor(carrierShape);\n+            MethodHandle[] components = createComponents(carrierShape);\n+\n+            return new Carrier(Object[].class,\n+                               reshapeConstructor(carrierShape, constructor),\n+                               reshapeComponents(carrierShape, components));\n+        }\n+    }\n+\n+    \/**\n+     * Factory for object based carrier. This strategy is used when the number of\n+     * components is less than equal {@link Carrier#MAX_OBJECT_COMPONENTS}. The factory\n+     * constructs an anonymous class that provides a shape that  matches the\n+     * number of longs, ints and objects required by the {@link CarrierShape}. The\n+     * factory caches and reuses anonymous classes when looking for a match.\n+     * <p>\n+     * The anonymous class that is constructed contains the number of long fields then\n+     * int fields then object fields required by the {@link CarrierShape}. The order\n+     * of fields is reordered by the component accessor {@link MethodHandles}. So a\n+     * carrier requiring an int and then object will use the same anonymous class as\n+     * a carrier requiring an object then int.\n+     * <p>\n+     * The carrier constructor recasts\/translates values that are not long, int or\n+     * object. The component accessors reverse the effect of the recasts\/translates.\n+     *\/\n+    private static class CarrierObjectFactory {\n+        \/**\n+         * Define the hidden class Lookup object\n+         *\n+         * @param bytes  class content\n+         *\n+         * @return the Lookup object of the hidden class\n+         *\/\n+        private static Lookup defineHiddenClass(byte[] bytes) {\n+            try {\n+                Lookup lookup = MethodHandles.lookup();\n+                return lookup.defineHiddenClass(bytes, false, ClassOption.STRONG);\n+            } catch (IllegalAccessException ex) {\n+                throw new AssertionError(\"carrier factory static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the name of a long component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of long component\n+         *\/\n+        private static String longFieldName(int index) {\n+            return \"l\" + index;\n+        }\n+\n+        \/**\n+         * Generate the name of an int component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of int component\n+         *\/\n+        private static String intFieldName(int index) {\n+            return \"i\" + index;\n+        }\n+\n+        \/**\n+         * Generate the name of an object component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of object component\n+         *\/\n+        private static String objectFieldName(int index) {\n+            return \"o\" + index;\n+        }\n+\n+        \/**\n+         * Generate the full name of a carrier class based on shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return name of a carrier class\n+         *\/\n+        private static String carrierClassName(CarrierShape carrierShape) {\n+            String packageName = Carrier.class.getPackageName().replace('.', '\/');\n+            String className = \"Carrier\" +\n+                    longFieldName(carrierShape.longCount()) +\n+                    intFieldName(carrierShape.intCount()) +\n+                    objectFieldName(carrierShape.objectCount());\n+\n+            return packageName.isEmpty() ? className :\n+                    packageName + \"\/\" + className;\n+        }\n+\n+        \/**\n+         * Build up the byte code for the carrier class.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return byte array of byte code for the carrier class\n+         *\/\n+        private static byte[] buildCarrierClass(CarrierShape carrierShape) {\n+            int maxStack = 3;\n+            int maxLocals = 1 \/* this *\/ + carrierShape.slotCount();\n+            String carrierClassName = carrierClassName(carrierShape);\n+            StringBuilder initDescriptor = new StringBuilder(\"(\");\n+\n+            ClassWriter cw = new ClassWriter(0);\n+            cw.visit(CLASSFILE_VERSION, ACC_PRIVATE | ACC_FINAL, carrierClassName,\n+                    null, \"java\/lang\/Object\", null);\n+\n+            int fieldFlags = ACC_PRIVATE | ACC_FINAL;\n+\n+            for (int i = 0; i < carrierShape.longCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, longFieldName(i),\n+                        LONG_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(LONG_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.intCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, intFieldName(i),\n+                        INT_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(INT_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.objectCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, objectFieldName(i),\n+                        OBJECT_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(OBJECT_DESCRIPTOR);\n+            }\n+\n+            initDescriptor.append(\")V\");\n+\n+            int arg = 1;\n+\n+            MethodVisitor init = cw.visitMethod(ACC_PUBLIC,\n+                    \"<init>\", initDescriptor.toString(), null, null);\n+            init.visitVarInsn(ALOAD, 0);\n+            init.visitMethodInsn(INVOKESPECIAL,\n+                    \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+\n+            for (int i = 0; i < carrierShape.longCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(LLOAD, arg);\n+                arg += LONG_SLOTS;\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        longFieldName(i), LONG_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.intCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(ILOAD, arg++);\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        intFieldName(i), INT_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.objectCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(ALOAD, arg++);\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        objectFieldName(i), OBJECT_DESCRIPTOR);\n+            }\n+\n+            init.visitInsn(RETURN);\n+            init.visitMaxs(maxStack, maxLocals);\n+            init.visitEnd();\n+\n+            cw.visitEnd();\n+\n+            return cw.toByteArray();\n+        }\n+\n+        \/**\n+         * Build up a {@link MethodType} based in a carrier shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return the constructor method type\n+         *\/\n+        private static MethodType constructorMethodType(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int count = carrierShape.count();\n+            Class<?>[] ptypes = new Class<?>[count];\n+            int arg = 0;\n+\n+            for(int i = 0; i < longCount; i++) {\n+                ptypes[arg++] = long.class;\n+            }\n+\n+            for(int i = 0; i < intCount; i++) {\n+                ptypes[arg++] = int.class;\n+            }\n+\n+            for(int i = 0; i < objectCount; i++) {\n+                ptypes[arg++] = Object.class;\n+            }\n+\n+            return methodType(void.class, ptypes);\n+        }\n+\n+        \/**\n+         * Returns the raw constructor for the carrier class.\n+         *\n+         * @param carrierClassLookup     lookup for carrier class\n+         * @param carrierClass           newly constructed carrier class\n+         * @param constructorMethodType  constructor method type\n+         *\n+         * @return {@link MethodHandle} to carrier class constructor\n+         *\n+         * @throws ReflectiveOperationException if lookup failure\n+         *\/\n+        private static MethodHandle constructor(Lookup carrierClassLookup,\n+                                                Class<?> carrierClass,\n+                                                MethodType constructorMethodType)\n+                throws ReflectiveOperationException {\n+            return carrierClassLookup.findConstructor(carrierClass,\n+                    constructorMethodType);\n+        }\n+\n+        \/**\n+         * Returns an array of raw component accessors for the carrier class.\n+         *\n+         * @param carrierShape           shape of carrier\n+         * @param carrierClassLookup     lookup for carrier class\n+         * @param carrierClass           newly constructed carrier class\n+         *\n+         * @return {@link MethodHandle MethodHandles} to carrier component\n+         *         accessors\n+         *\n+         * @throws ReflectiveOperationException if lookup failure\n+         *\/\n+        private static MethodHandle[] createComponents(CarrierShape carrierShape,\n+                                                       Lookup carrierClassLookup,\n+                                                       Class<?> carrierClass)\n+                throws ReflectiveOperationException {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int count = carrierShape.count();\n+            MethodHandle[] components = new MethodHandle[count];\n+            int arg = 0;\n+\n+            for(int i = 0; i < longCount; i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        longFieldName(i), long.class);\n+            }\n+\n+            for(int i = 0; i < intCount; i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        intFieldName(i), int.class);\n+            }\n+\n+            for(int i = 0; i < objectCount; i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        objectFieldName(i), Object.class);\n+            }\n+\n+            return components;\n+        }\n+\n+        \/**\n+         * Construct a new object carrier class based on shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return a {@link CarrierClass} object containing constructor and\n+         *         component accessors.\n+         *\/\n+        private static CarrierClass newCarrierClass(CarrierShape carrierShape) {\n+            byte[] bytes = buildCarrierClass(carrierShape);\n+\n+            try {\n+                Lookup carrierCLassLookup = defineHiddenClass(bytes);\n+                Class<?> carrierClass = carrierCLassLookup.lookupClass();\n+                MethodType constructorMethodType = constructorMethodType(carrierShape);\n+                MethodHandle constructor = constructor(carrierCLassLookup,\n+                        carrierClass, constructorMethodType);\n+                MethodHandle[] components = createComponents(carrierShape,\n+                        carrierCLassLookup, carrierClass);\n+\n+                return new CarrierClass(constructor, components);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier class static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Permute a raw constructor and component accessor\n+         * {@link MethodHandle MethodHandles} to match the order and types of\n+         * the parameter types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link Carrier} instance\n+         *\/\n+        private static Carrier carrier(CarrierShape carrierShape) {\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle constructor = carrierClass.constructor();\n+            MethodHandle[] components = carrierClass.components();\n+\n+            return new Carrier(constructor.type().returnType(),\n+                               reshapeConstructor(carrierShape, constructor),\n+                               reshapeComponents(carrierShape, components));\n+        }\n+    }\n+\n+    \/**\n+     * Provides raw constructor and component MethodHandles for a constructed\n+     * carrier class.\n+     *\/\n+    private record CarrierClass(\n+            \/*\n+             * A raw {@link MethodHandle} for a carrier object constructor.\n+             * This constructor will only have Object, int and long type arguments.\n+             *\/\n+            MethodHandle constructor,\n+\n+            \/*\n+             * All the raw {@link MethodHandle MethodHandles} for a carrier\n+             * component accessors. These accessors will only return Object, int and\n+             * long types.\n+             *\/\n+            MethodHandle[] components) {\n+    }\n+\n+    \/**\n+     * Cache for all constructed carrier object classes, keyed on class\n+     * name (i.e., carrier shape.)\n+     *\/\n+    private static final ConcurrentHashMap<String, CarrierClass> carrierCache =\n+            new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carrier() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carrier(Class<?> carrierClass,\n+                    MethodHandle constructor, List<MethodHandle> components) {\n+        this.carrierClass = carrierClass;\n+        this.constructor = constructor;\n+        this.components = components;\n+    }\n+\n+    \/**\n+     * Find or create carrier class for a carrier shape.\n+     *\n+     * @param carrierShape  shape of carrier\n+     *\n+     * @return {@link Class<>} of carrier class matching carrier shape\n+     *\/\n+    private static CarrierClass findCarrierClass(CarrierShape carrierShape) {\n+        String carrierClassName =\n+                CarrierObjectFactory.carrierClassName(carrierShape);\n+\n+        return carrierCache.computeIfAbsent(carrierClassName,\n+                cn -> CarrierObjectFactory.newCarrierClass(carrierShape));\n+    }\n+\n+    private record CarrierCounts(int longCount, int intCount, int objectCount) {\n+        \/**\n+         * Count the number of fields required in each of Object, int and long.\n+         *\n+         * @param ptypes  parameter types\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        static CarrierCounts tally(Class<?>[] ptypes) {\n+            return tally(ptypes, ptypes.length);\n+        }\n+\n+        \/**\n+         * Count the number of fields required in each of Object, int and long\n+         * limited to the first {@code n} parameters.\n+         *\n+         * @param ptypes  parameter types\n+         * @param n       number of parameters to check\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        private static CarrierCounts tally(Class<?>[] ptypes, int n) {\n+            int longCount = 0;\n+            int intCount = 0;\n+            int objectCount = 0;\n+\n+            for (int i = 0; i < n; i++) {\n+                Class<?> ptype = ptypes[i];\n+\n+                if (!ptype.isPrimitive()) {\n+                    objectCount++;\n+                } else if (ptype == long.class || ptype == double.class) {\n+                    longCount++;\n+                } else {\n+                    intCount++;\n+                }\n+            }\n+\n+            return new CarrierCounts(longCount, intCount, objectCount);\n+        }\n+\n+        \/**\n+         * {@return total number of components}\n+         *\/\n+        private int count() {\n+            return longCount + intCount + objectCount;\n+        }\n+\n+        \/**\n+         * {@return total number of slots}\n+         *\/\n+        private int slotCount() {\n+            return longCount * LONG_SLOTS + intCount + objectCount;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Shape of carrier based on counts of each of the three fundamental data\n+     * types.\n+     *\/\n+    private static class CarrierShape {\n+        \/**\n+         * {@link MethodType} providing types for the carrier's components.\n+         *\/\n+        private final MethodType methodType;\n+\n+        \/**\n+         * Counts of different parameter types.\n+         *\/\n+        private final CarrierCounts counts;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param methodType  {@link MethodType} providing types for the\n+         *                    carrier's components\n+         *\/\n+        public CarrierShape(MethodType methodType) {\n+            this.methodType = methodType;\n+            this.counts = CarrierCounts.tally(methodType.parameterArray());\n+        }\n+\n+        \/**\n+         * {@return number of long fields needed}\n+         *\/\n+        private int longCount() {\n+            return counts.longCount();\n+        }\n+\n+        \/**\n+         * {@return number of int fields needed}\n+         *\/\n+        private int intCount() {\n+            return counts.intCount();\n+        }\n+\n+        \/**\n+         * {@return number of object fields needed}\n+         *\/\n+        private int objectCount() {\n+            return counts.objectCount();\n+        }\n+\n+        \/**\n+         * {@return array of parameter types}\n+         *\/\n+        private Class<?>[] ptypes() {\n+            return methodType.parameterArray();\n+        }\n+\n+        \/**\n+         * {@return number of components}\n+         *\/\n+        private int count() {\n+            return counts.count();\n+        }\n+\n+        \/**\n+         * {@return number of slots used}\n+         *\/\n+        private int slotCount() {\n+            return counts.slotCount();\n+        }\n+\n+        \/**\n+         * {@return index of first long component}\n+         *\/\n+        private int longOffset() {\n+            return 0;\n+        }\n+\n+        \/**\n+         * {@return index of first int component}\n+         *\/\n+        private int intOffset() {\n+            return longCount();\n+        }\n+\n+        \/**\n+         * {@return index of first object component}\n+         *\/\n+        private int objectOffset() {\n+            return longCount() + intCount();\n+        }\n+\n+        \/**\n+         * {@return true if primitive components present}\n+         *\/\n+        private boolean hasPrimitives() {\n+            return longCount() != 0 ||  intCount() != 0;\n+        }\n+    }\n+\n+    \/**\n+     * Factory method to return a {@link Carrier} instance that matches the shape\n+     * of the supplied {@link MethodType}. The return type of the {@link MethodType}\n+     * is ignored.\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @return {@link Carrier} instance\n+     *\n+     * @throws NullPointerException is methodType is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *\/\n+    public static Carrier of(MethodType methodType) {\n+        Objects.requireNonNull(methodType, \"methodType must be not be null\");\n+        MethodType constructorMT = methodType.changeReturnType(Object.class);\n+        CarrierShape carrierShape = new CarrierShape(constructorMT);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        }\n+\n+        return methodTypeCache.computeIfAbsent(constructorMT, (mt) -> {\n+            if (slotCount <= MAX_OBJECT_COMPONENTS && carrierShape.hasPrimitives()) {\n+                return CarrierObjectFactory.carrier(carrierShape);\n+            } else {\n+                return CarrierArrayFactory.carrier(carrierShape);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Factory method to return  a {@link Carrier} instance that matches the shape\n+     * of the supplied parameter types.\n+     *\n+     * @param ptypes   parameter types that supply the shape of the carrier's\n+     *                 components\n+     *\n+     * @return {@link Carrier} instance\n+     *\n+     * @throws NullPointerException is ptypes is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *\/\n+    public static Carrier of(Class<?>... ptypes) {\n+        Objects.requireNonNull(ptypes, \"ptypes must be not be null\");\n+        return of(methodType(Object.class, ptypes));\n+    }\n+\n+    \/**\n+     * {@return the underlying carrier class}\n+     *\/\n+    public Class<?> carrierClass() {\n+        return carrierClass;\n+    }\n+\n+    \/**\n+     * {@return the constructor {@link MethodHandle} for the carrier . The\n+     * carrier constructor will have a return type of {@link Object} }\n+     *\/\n+    public MethodHandle constructor() {\n+        return constructor;\n+    }\n+\n+    \/**\n+     * {@return immutable list of component accessor {@link MethodHandle MethodHandles}\n+     * for all the carrier's components. The receiver type of the accessors\n+     * will be {@link Object} }\n+     *\/\n+    public List<MethodHandle> components() {\n+        return components;\n+    }\n+\n+    \/**\n+     * {@return a component accessor {@link MethodHandle} for component {@code i}.\n+     * The receiver type of the accessor will be {@link Object} }\n+     *\n+     * @param i  component index\n+     *\n+     * @throws IllegalArgumentException if {@code i} is out of bounds\n+     *\/\n+    public MethodHandle component(int i) {\n+        if (i < 0 || components.size() <= i) {\n+            throw new IllegalArgumentException(\"i is out of bounds \" + i +\n+                    \" of \" + components.size());\n+        }\n+\n+        return components.get(i);\n+    }\n+\n+    \/**\n+     * {@return the underlying carrier class of the carrier representing\n+     * {@code methodType} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\/\n+    public static Class<?> carrierClass(MethodType methodType) {\n+        return of(methodType).carrierClass();\n+    }\n+\n+    \/**\n+     * {@return the constructor {@link MethodHandle} for the carrier\n+     * representing {@code methodType}. The carrier constructor will have a\n+     * return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\/\n+    public static MethodHandle constructor(MethodType methodType) {\n+        return of(methodType).constructor();\n+    }\n+\n+    \/**\n+     * {@return immutable list of component accessor {@link MethodHandle MethodHandles}\n+     * for all the components of the carrier representing {@code methodType}. The\n+     * receiver type of the accessors will be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\/\n+    public static List<MethodHandle> components(MethodType methodType) {\n+        return of(methodType).components();\n+    }\n+\n+    \/**\n+     * {@return a component accessor {@link MethodHandle} for component {@code i}\n+     * of the carrier representing {@code methodType}. The receiver type of the\n+     * accessor will be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     * @param i  component index\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\n+     * @throws IllegalArgumentException if {@code i} is out of bounds\n+     *\/\n+    public static MethodHandle component(MethodType methodType, int i) {\n+        return of(methodType).component(i);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":1179,"deletions":0,"binary":false,"changes":1179,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the Carrier class.\n+ * @compile CarrierTest.java\n+ * @run main CarrierTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.runtime.Carrier;\n+import java.util.Arrays;\n+\n+public class CarrierTest {\n+    public static void main(String[] args) throws Throwable {\n+        primitivesTest();\n+        primitivesTestInArrayCarrier();\n+        limitsTest();\n+        cacheTest();\n+        staticTest();\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static void primitivesTest() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class);\n+        Carrier carrier = Carrier.of(methodType);\n+        Class<?> carrierClass = carrier.carrierClass();\n+        assertTrue(!carrierClass.isArray(), \"carrier should be instance\");\n+        MethodHandle constructor = carrier.constructor();\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\");\n+        MethodHandle[] components = carrier.components().toArray(new MethodHandle[0]);\n+\n+        assertTrue((byte)components[0].invokeExact(object) == (byte)0xFF,\n+                \"primitive byte test failure\");\n+        assertTrue((short)components[1].invokeExact(object) == (short)0xFFFF,\n+                \"primitive short test failure\");\n+        assertTrue((char)components[2].invokeExact(object) == 'C',\n+                \"primitive char test failure\");\n+        assertTrue((int)components[3].invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive int test failure\");\n+        assertTrue((long)components[4].invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive long test failure\");\n+        assertTrue((float)components[5].invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive float test failure\");\n+        assertTrue((double)components[6].invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive double test failure\");\n+        assertTrue((boolean)components[7].invokeExact(object),\n+                \"primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components[8].invokeExact(object)),\n+                \"primitive String test failure\");\n+\n+        MethodHandle component = carrier.component(8);\n+        assertTrue(\"abcde\".equals((String)component.invokeExact(object)),\n+                \"primitive String test failure\");\n+    }\n+\n+    static void primitivesTestInArrayCarrier() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class\n+                );\n+        Carrier carrier = Carrier.of(methodType);\n+        Class<?> carrierClass = carrier.carrierClass();\n+        assertTrue(carrierClass.isArray(), \"carrier should be array\");\n+        MethodHandle constructor = carrier.constructor();\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\",\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null\n+        );\n+        MethodHandle[] components = carrier.components().toArray(new MethodHandle[0]);\n+        assertTrue((byte)components[0].invokeExact(object) == (byte)0xFF,\n+                \"primitive in array byte test failure\");\n+        assertTrue((short)components[1].invokeExact(object) == (short)0xFFFF,\n+                \"primitive in array short test failure\");\n+        assertTrue((char)components[2].invokeExact(object) == 'C',\n+                \"primitive in array char test failure\");\n+        assertTrue((int)components[3].invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive in array int test failure\");\n+        assertTrue((long)components[4].invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive in array long test failure\");\n+        assertTrue((float)components[5].invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive in array float test failure\");\n+        assertTrue((double)components[6].invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive in array double test failure\");\n+        assertTrue((boolean)components[7].invokeExact(object),\n+                \"primitive in array boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components[8].invokeExact(object)),\n+                \"primitive in array String test failure\");\n+    }\n+\n+    static void limitsTest() {\n+        boolean passed;\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[Carrier.MAX_COMPONENTS + 1];\n+            Arrays.fill(ptypes, Object.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            Carrier carrier = Carrier.of(methodType);\n+            MethodHandle constructor = carrier.constructor();\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        assertTrue(passed, \"failed to report too many components\");\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[Carrier.MAX_COMPONENTS \/ 2 + 1];\n+            Arrays.fill(ptypes, long.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            Carrier carrier = Carrier.of(methodType);\n+            MethodHandle constructor = carrier.constructor();\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        assertTrue(passed, \"failed to report too many components\");\n+    }\n+\n+    static void cacheTest() {\n+        Class<?>[] ptypes = new Class<?>[] {\n+                byte.class, short.class,\n+                char.class, int.class, long.class,\n+                float.class, double.class,\n+                boolean.class, String.class\n+        };\n+        MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+        Carrier carrier1 = Carrier.of(ptypes);\n+        Carrier carrier2 = Carrier.of(methodType);\n+\n+        assertTrue(carrier1 == carrier2, \"carrier cache not matching correctly\");\n+    }\n+\n+    static void staticTest() {\n+        Class<?>[] ptypes = new Class<?>[] {\n+                byte.class, short.class,\n+                char.class, int.class, long.class,\n+                float.class, double.class,\n+                boolean.class, String.class\n+        };\n+        MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+        Carrier carrier = Carrier.of(methodType);\n+        assertTrue(carrier.constructor() == Carrier.constructor(methodType),\n+                \"static constructor incorrect\");\n+        assertTrue(carrier.components() == Carrier.components(methodType),\n+                \"static components incorrect\");\n+        assertTrue(carrier.component(1) == Carrier.component(methodType, 1),\n+                \"static component incorrect\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/CarrierTest.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}