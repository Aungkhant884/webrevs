{"files":[{"patch":"@@ -334,2 +334,3 @@\n-                this.primitives = new long[primitiveCount];\n-                this.objects = new Object[objectCount];\n+                this.primitives =\n+                    primitiveCount != 0 ? new long[(primitiveCount + 1) \/ 2] : null;\n+                this.objects = objectCount != 0 ? new Object[objectCount] : null;\n@@ -346,1 +347,1 @@\n-                if (i < 0 || primitives.length <= i) {\n+                if (i < 0 || (primitives.length * LONG_SLOTS) <= i) {\n@@ -435,1 +436,1 @@\n-            int primitiveSlots = longCount * LONG_SLOTS + intCount;\n+            int primitiveCount = longCount * LONG_SLOTS + intCount;\n@@ -438,1 +439,1 @@\n-                    0, primitiveSlots, objectCount);\n+                    0, primitiveCount, objectCount);\n@@ -1120,0 +1121,58 @@\n+\n+    \/**\n+     * {@return the underlying carrier class of the carrier representing\n+     * {@code methodType} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\/\n+    public static Class<?> carrierClass(MethodType methodType) {\n+        return of(methodType).carrierClass();\n+    }\n+\n+    \/**\n+     * {@return the constructor {@link MethodHandle} for the carrier\n+     * representing {@code methodType}. The carrier constructor will have a\n+     * return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\/\n+    public static MethodHandle constructor(MethodType methodType) {\n+        return of(methodType).constructor();\n+    }\n+\n+    \/**\n+     * {@return immutable list of component accessor {@link MethodHandle MethodHandles}\n+     * for all the components of the carrier representing {@code methodType}. The\n+     * receiver type of the accessors will be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\/\n+    public static List<MethodHandle> components(MethodType methodType) {\n+        return of(methodType).components();\n+    }\n+\n+    \/**\n+     * {@return a component accessor {@link MethodHandle} for component {@code i}\n+     * of the carrier representing {@code methodType}. The receiver type of the\n+     * accessor will be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the\n+     *                    the shape of the carrier's components\n+     * @param i  component index\n+     *\n+     * @implNote Used internally by the Condy API.\n+     *\n+     * @throws IllegalArgumentException if {@code i} is out of bounds\n+     *\/\n+    public static MethodHandle component(MethodType methodType, int i) {\n+        return of(methodType).component(i);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":64,"deletions":5,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -36,1 +35,0 @@\n-import java.util.List;\n@@ -44,0 +42,1 @@\n+        staticTest();\n@@ -52,2 +51,0 @@\n-    static final int MAX_COMPONENTS = 254;\n-\n@@ -107,1 +104,1 @@\n-                        );\n+                );\n@@ -123,1 +120,1 @@\n-                );\n+        );\n@@ -150,1 +147,1 @@\n-            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS + 1];\n+            Class<?>[] ptypes = new Class<?>[Carrier.MAX_COMPONENTS + 1];\n@@ -159,3 +156,1 @@\n-        if (!passed) {\n-            throw new RuntimeException(\"failed to report too many components \");\n-        }\n+        assertTrue(passed, \"failed to report too many components\");\n@@ -165,1 +160,1 @@\n-            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS \/ 2 + 1];\n+            Class<?>[] ptypes = new Class<?>[Carrier.MAX_COMPONENTS \/ 2 + 1];\n@@ -174,3 +169,1 @@\n-        if (!passed) {\n-            throw new RuntimeException(\"failed to report too many components \");\n-        }\n+        assertTrue(passed, \"failed to report too many components\");\n@@ -186,2 +179,1 @@\n-        MethodType methodType =\n-                MethodType.methodType(Object.class, ptypes);\n+        MethodType methodType = MethodType.methodType(Object.class, ptypes);\n@@ -191,3 +183,18 @@\n-        if (carrier1 != carrier2) {\n-            throw new RuntimeException(\"carrier cache not matching correctly\");\n-        }\n+        assertTrue(carrier1 == carrier2, \"carrier cache not matching correctly\");\n+    }\n+\n+    static void staticTest() {\n+        Class<?>[] ptypes = new Class<?>[] {\n+                byte.class, short.class,\n+                char.class, int.class, long.class,\n+                float.class, double.class,\n+                boolean.class, String.class\n+        };\n+        MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+        Carrier carrier = Carrier.of(methodType);\n+        assertTrue(carrier.constructor() == Carrier.constructor(methodType),\n+                \"static constructor incorrect\");\n+        assertTrue(carrier.components() == Carrier.components(methodType),\n+                \"static components incorrect\");\n+        assertTrue(carrier.component(1) == Carrier.component(methodType, 1),\n+                \"static component incorrect\");\n","filename":"test\/jdk\/java\/lang\/runtime\/CarrierTest.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"}]}