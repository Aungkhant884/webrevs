{"files":[{"patch":"@@ -134,0 +134,17 @@\n+    \/**\n+     * Cache mapping {@link MethodType} to previously defined\n+     * {@link Carrier Carriers}.\n+     *\/\n+    private static ConcurrentHashMap<MethodType, Carrier>\n+            methodTypeCache = new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Constructor {@link MethodHandle}.\n+     *\/\n+    private final MethodHandle constructor;\n+\n+    \/**\n+     * List of component {@link MethodHandle MethodHandles}\n+     *\/\n+    private final List<MethodHandle> components;\n+\n@@ -242,44 +259,0 @@\n-    \/**\n-     * Given components array and index, recast and reorder that component to\n-     * match shape.\n-     *\n-     * @param carrierShape  carrier reshape\n-     * @param components    carrier components\n-     * @param i             index of component to reshape\n-     *\n-     * @return component reshaped\n-     *\/\n-    private static MethodHandle reshapeComponent(CarrierShape carrierShape,\n-                                                 MethodHandle[] components, int i) {\n-        Class<?>[] ptypes = carrierShape.ptypes();\n-        CarrierCounts componentCounts = CarrierCounts.tally(ptypes, i);\n-        Class<?> ptype = ptypes[i];\n-        int index;\n-        MethodHandle filter = null;\n-\n-        if (!ptype.isPrimitive()) {\n-            index = carrierShape.objectOffset() + componentCounts.objectCount();\n-        } else if (ptype == double.class) {\n-            index = carrierShape.longOffset() + componentCounts.longCount();\n-            filter = LONG_TO_DOUBLE;\n-        } else if (ptype == float.class) {\n-            index = carrierShape.intOffset() + componentCounts.intCount();\n-            filter = INT_TO_FLOAT;\n-        } else if (ptype == long.class) {\n-            index = carrierShape.longOffset() + componentCounts.longCount();\n-        } else {\n-            index = carrierShape.intOffset() + componentCounts.intCount();\n-        }\n-\n-        MethodHandle component = components[index];\n-\n-        if (filter != null) {\n-            component = MethodHandles.filterReturnValue(component, filter);\n-        }\n-\n-        component = MethodHandles.explicitCastArguments(component,\n-                methodType(ptype, Object.class));\n-\n-        return component;\n-    }\n-\n@@ -481,1 +454,1 @@\n-            return reshapeConstructor(carrierShape, constructor);\n+            return constructor;\n@@ -519,15 +492,3 @@\n-         * Return an array of carrier component accessors, aligning with types in\n-         * {@code ptypes}.\n-         *\n-         * @param carrierShape  carrier object shape\n-         *\n-         * @return list of carrier accessors\n-         *\/\n-        private static List<MethodHandle> components(CarrierShape carrierShape) {\n-            MethodHandle[] components = createComponents(carrierShape);\n-\n-            return reshapeComponents(carrierShape, components);\n-        }\n-\n-        \/**\n-         * Return a carrier accessor for component {@code i}.\n+         * Permute a raw constructor and component accessor\n+         * {@link MethodHandle MethodHandles} to match the order and types of\n+         * the parameter types.\n@@ -536,1 +497,0 @@\n-         * @param i             index of parameter to get\n@@ -538,1 +498,1 @@\n-         * @return carrier component {@code i} accessor {@link MethodHandle}\n+         * @return {@link Carrier} instance\n@@ -540,1 +500,2 @@\n-        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+        private static Carrier carrier(CarrierShape carrierShape) {\n+            MethodHandle constructor = constructor(carrierShape);\n@@ -543,1 +504,2 @@\n-            return reshapeComponent(carrierShape, components, i);\n+            return new Carrier(reshapeConstructor(carrierShape, constructor),\n+                               reshapeComponents(carrierShape, components));\n@@ -832,2 +794,3 @@\n-         * Permute a raw constructor {@link MethodHandle} to match the order and\n-         * types of the parameter types.\n+         * Permute a raw constructor and component accessor\n+         * {@link MethodHandle MethodHandles} to match the order and types of\n+         * the parameter types.\n@@ -837,1 +800,1 @@\n-         * @return {@link MethodHandle} constructor matching parameter types\n+         * @return {@link Carrier} instance\n@@ -839,1 +802,1 @@\n-        private static MethodHandle constructor(CarrierShape carrierShape) {\n+        private static Carrier carrier(CarrierShape carrierShape) {\n@@ -842,14 +805,0 @@\n-\n-            return reshapeConstructor(carrierShape, constructor);\n-        }\n-\n-        \/**\n-         * Permute raw component accessors to match order and types of the parameter\n-         * types.\n-         *\n-         * @param carrierShape  carrier object shape\n-         *\n-         * @return list of components matching parameter types\n-         *\/\n-        private static List<MethodHandle> components(CarrierShape carrierShape) {\n-            CarrierClass carrierClass = findCarrierClass(carrierShape);\n@@ -858,20 +807,2 @@\n-            return reshapeComponents(carrierShape, components);\n-        }\n-\n-        \/**\n-         * Returns a carrier component accessor {@link MethodHandle} for the\n-         * component {@code i}.\n-         *\n-         * @param carrierShape  shape of the carrier object\n-         * @param i             index to the component\n-         *\n-         * @return carrier component accessor {@link MethodHandle}\n-         *\n-         * @throws IllegalArgumentException if number of component slots exceeds\n-         *         maximum\n-         *\/\n-        private static MethodHandle component(CarrierShape carrierShape, int i) {\n-            CarrierClass carrierClass = findCarrierClass(carrierShape);\n-            MethodHandle[] components = carrierClass.components;\n-\n-            return reshapeComponent(carrierShape, components, i);\n+            return new Carrier(reshapeConstructor(carrierShape, constructor),\n+                               reshapeComponents(carrierShape, components));\n@@ -911,0 +842,9 @@\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carrier(MethodHandle constructor, List<MethodHandle> components) {\n+        this.constructor = constructor;\n+        this.components = components;\n@@ -1073,0 +1013,7 @@\n+\n+        \/**\n+         * {@return true if primitive components present}\n+         *\/\n+        private boolean hasPrimitives() {\n+            return longCount() != 0 ||  intCount() != 0;\n+        }\n@@ -1076,3 +1023,2 @@\n-     * Return a constructor {@link MethodHandle} for a carrier with components\n-     * aligning with the parameter types of the supplied\n-     * {@link MethodType methodType}.\n+     * Factory method to return {@link Carrier} that matches the shape\n+     * of the supplied {@link MethodType}.\n@@ -1083,1 +1029,1 @@\n-     * @return carrier constructor {@link MethodHandle}\n+     * @return {@link Carrier} instance\n@@ -1085,1 +1031,1 @@\n-     * @throws NullPointerException is any argument is null\n+     * @throws NullPointerException is methodType is null\n@@ -1088,3 +1034,4 @@\n-    public static MethodHandle constructor(MethodType methodType) {\n-        Objects.requireNonNull(methodType);\n-        CarrierShape carrierShape = new CarrierShape(methodType);\n+    public static Carrier of(MethodType methodType) {\n+        Objects.requireNonNull(methodType, \"methodType must be not be null\");\n+        MethodType constructorMT = methodType.changeReturnType(Object.class);\n+        CarrierShape carrierShape = new CarrierShape(constructorMT);\n@@ -1095,4 +1042,0 @@\n-        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n-            return CarrierObjectFactory.constructor(carrierShape);\n-        } else {\n-            return CarrierArrayFactory.constructor(carrierShape);\n@@ -1100,0 +1043,8 @@\n+\n+        return methodTypeCache.computeIfAbsent(constructorMT, (mt) -> {\n+            if (slotCount <= MAX_OBJECT_COMPONENTS && carrierShape.hasPrimitives()) {\n+                return CarrierObjectFactory.carrier(carrierShape);\n+            } else {\n+                return CarrierArrayFactory.carrier(carrierShape);\n+            }\n+        });\n@@ -1103,2 +1054,2 @@\n-     * Return component accessor {@link MethodHandle MethodHandles} for all the\n-     * carrier's components.\n+     * Factory method to return {@link Carrier} that matches the shape\n+     * of the supplied parameter types.\n@@ -1106,2 +1057,1 @@\n-     * @param methodType  {@link MethodType} providing types for the carrier's\n-     *                    components\n+     * @param ptypes   types of the carrier's components\n@@ -1109,1 +1059,1 @@\n-     * @return immutable list of component accessors {@link MethodHandle MethodHandles}\n+     * @return {@link Carrier} instance\n@@ -1111,1 +1061,1 @@\n-     * @throws NullPointerException is any argument is null\n+     * @throws NullPointerException is ptypes is null\n@@ -1114,4 +1064,4 @@\n-    public static List<MethodHandle> components(MethodType methodType) {\n-        Objects.requireNonNull(methodType);\n-        CarrierShape carrierShape =  new CarrierShape(methodType);\n-        int slotCount = carrierShape.slotCount();\n+    public static Carrier of(Class<?>... ptypes) {\n+        Objects.requireNonNull(ptypes, \"ptypes must be not be null\");\n+        return of(methodType(Object.class, ptypes));\n+    }\n@@ -1119,7 +1069,5 @@\n-        if (MAX_COMPONENTS < slotCount) {\n-            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n-        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n-            return CarrierObjectFactory.components(carrierShape);\n-        } else {\n-            return CarrierArrayFactory.components(carrierShape);\n-        }\n+    \/**\n+     * {@return the constructor {@link MethodHandle} for the carrier.}\n+     *\/\n+    public MethodHandle constructor() {\n+        return constructor;\n@@ -1129,5 +1077,9 @@\n-     * Return a component accessor {@link MethodHandle} for component {@code i}.\n-     *\n-     * @param methodType  {@link MethodType} providing types for the carrier's\n-     *                    components\n-     * @param i           component index\n+     * {@return immutable list of component accessor {@link MethodHandle MethodHandles}\n+     * for all the carrier's components.}\n+     *\/\n+    public List<MethodHandle> components() {\n+        return components;\n+    }\n+\n+    \/**\n+     * {@return a component accessor {@link MethodHandle} for component {@code i}.}\n@@ -1135,1 +1087,1 @@\n-     * @return a component accessor {@link MethodHandle} for component {@code i}\n+     * @param i  component index\n@@ -1137,3 +1089,1 @@\n-     * @throws NullPointerException is any argument is null\n-     * @throws IllegalArgumentException if number of component slots exceeds maximum\n-     *                                  or if {@code i} is out of bounds\n+     * @throws IllegalArgumentException if {@code i} is out of bounds\n@@ -1141,13 +1091,4 @@\n-    public static MethodHandle component(MethodType methodType, int i) {\n-        Objects.requireNonNull(methodType);\n-        CarrierShape carrierShape = new CarrierShape(methodType);\n-        int slotCount = carrierShape.slotCount();\n-\n-        if (i < 0 || i >= carrierShape.count()) {\n-            throw new IllegalArgumentException(\"i is out of bounds for parameter types\");\n-        } else if (MAX_COMPONENTS < slotCount) {\n-            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n-        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n-            return CarrierObjectFactory.component(carrierShape, i);\n-        } else {\n-            return CarrierArrayFactory.component(carrierShape, i);\n+    public MethodHandle component(int i) {\n+        if (i < 0 || components.size() <= i) {\n+            throw new IllegalArgumentException(\"i is out of bounds \" + i +\n+                    \" of \" + components.size());\n@@ -1155,0 +1096,2 @@\n+\n+        return components.get(i);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":96,"deletions":153,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+        cacheTest();\n@@ -59,1 +60,2 @@\n-        MethodHandle constructor = Carrier.constructor(methodType);\n+        Carrier carrier = Carrier.of(methodType);\n+        MethodHandle constructor = carrier.constructor();\n@@ -64,1 +66,1 @@\n-        MethodHandle[] components = Carrier.components(methodType).toArray(new MethodHandle[0]);\n+        MethodHandle[] components = carrier.components().toArray(new MethodHandle[0]);\n@@ -85,1 +87,1 @@\n-        MethodHandle component = Carrier.component(methodType, 8);\n+        MethodHandle component = carrier.component(8);\n@@ -104,1 +106,2 @@\n-        MethodHandle constructor = Carrier.constructor(methodType);\n+        Carrier carrier = Carrier.of(methodType);\n+        MethodHandle constructor = carrier.constructor();\n@@ -117,1 +120,1 @@\n-        MethodHandle[] components = Carrier.components(methodType).toArray(new MethodHandle[0]);\n+        MethodHandle[] components = carrier.components().toArray(new MethodHandle[0]);\n@@ -146,1 +149,2 @@\n-            MethodHandle constructor = Carrier.constructor(methodType);\n+            Carrier carrier = Carrier.of(methodType);\n+            MethodHandle constructor = carrier.constructor();\n@@ -160,1 +164,2 @@\n-            MethodHandle constructor = Carrier.constructor(methodType);\n+            Carrier carrier = Carrier.of(methodType);\n+            MethodHandle constructor = carrier.constructor();\n@@ -169,0 +174,17 @@\n+\n+    static void cacheTest() {\n+        Class<?>[] ptypes = new Class<?>[] {\n+                byte.class, short.class,\n+                char.class, int.class, long.class,\n+                float.class, double.class,\n+                boolean.class, String.class\n+        };\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, ptypes);\n+        Carrier carrier1 = Carrier.of(ptypes);\n+        Carrier carrier2 = Carrier.of(methodType);\n+\n+        if (carrier1 != carrier2) {\n+            throw new RuntimeException(\"carrier cache not matching correctly\");\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/CarrierTest.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"}]}