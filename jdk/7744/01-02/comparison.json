{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -51,2 +52,2 @@\n- * so that future improvements will not be hampered by issues of backward\n- * compatability.\n+ * so that future improvements will not be hampered by backward compatability\n+ * issues.\n@@ -56,0 +57,1 @@\n+\/*non-public*\/\n@@ -84,0 +86,5 @@\n+    \/**\n+     * Number of integer slots used by a long.\n+     *\/\n+    private static final int LONG_SLOTS = 2;\n+\n@@ -88,2 +95,1 @@\n-        Lookup lookup = MethodHandles.lookup();\n-        LOOKUP = lookup;\n+        LOOKUP = MethodHandles.lookup();\n@@ -92,1 +98,1 @@\n-            FLOAT_TO_INT = lookup.findStatic(Float.class, \"floatToRawIntBits\",\n+            FLOAT_TO_INT = LOOKUP.findStatic(Float.class, \"floatToRawIntBits\",\n@@ -94,1 +100,1 @@\n-            INT_TO_FLOAT = lookup.findStatic(Float.class, \"intBitsToFloat\",\n+            INT_TO_FLOAT = LOOKUP.findStatic(Float.class, \"intBitsToFloat\",\n@@ -96,1 +102,1 @@\n-            DOUBLE_TO_LONG = lookup.findStatic(Double.class, \"doubleToRawLongBits\",\n+            DOUBLE_TO_LONG = LOOKUP.findStatic(Double.class, \"doubleToRawLongBits\",\n@@ -98,1 +104,1 @@\n-            LONG_TO_DOUBLE = lookup.findStatic(Double.class, \"longBitsToDouble\",\n+            LONG_TO_DOUBLE = LOOKUP.findStatic(Double.class, \"longBitsToDouble\",\n@@ -132,7 +138,154 @@\n-     * Factory for carriers that are backed by an Object[]. This strategy is used when\n-     * the number of components exceeds {@link Carrier#MAX_OBJECT_COMPONENTS}. The\n-     * object returned by the carrier constructor is the backing Object[].\n-     * <p>\n-     * Each element of the Object[] corresponds directly, via index, to each component.\n-     * If the component is a primitive value then the constructor boxes the value before\n-     * inserting into the array, and the carrier component getter unboxes.\n+     * Given a constructor {@link MethodHandle} recast and reorder arguments to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier shape\n+     * @param constructor   carrier constructor to reshape\n+     *\n+     * @return constructor with arguments recasted and reordered\n+     *\/\n+    private static MethodHandle reshapeConstructor(CarrierShape carrierShape,\n+                                                   MethodHandle constructor) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int[] reorder = new int[count];\n+        Class<?>[] permutePTypes = new Class<?>[count];\n+        MethodHandle[] filters = new MethodHandle[count];\n+        boolean hasFilters = false;\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle filter = null;\n+            int from;\n+\n+            if (!ptype.isPrimitive()) {\n+                from = objectIndex++;\n+                ptype = Object.class;\n+            } else if(ptype == double.class) {\n+                from = longIndex++;\n+                filter = DOUBLE_TO_LONG;\n+            } else if(ptype == float.class) {\n+                from = intIndex++;\n+                filter = FLOAT_TO_INT;\n+            } else if (ptype == long.class) {\n+                from = longIndex++;\n+            } else {\n+                from = intIndex++;\n+                ptype = int.class;\n+            }\n+\n+            permutePTypes[index] = ptype;\n+            reorder[from] = index++;\n+\n+            if (filter != null) {\n+                filters[from] = filter;\n+                hasFilters = true;\n+            }\n+        }\n+\n+        if (hasFilters) {\n+            constructor = MethodHandles.filterArguments(constructor, 0, filters);\n+        }\n+\n+        MethodType permutedMethodType =\n+                methodType(constructor.type().returnType(), permutePTypes);\n+        constructor = MethodHandles.permuteArguments(constructor,\n+                permutedMethodType, reorder);\n+        constructor = MethodHandles.explicitCastArguments(constructor,\n+                methodType(Object.class, ptypes));\n+\n+        return constructor;\n+    }\n+\n+    \/**\n+     * Given components array, recast and reorder components to match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components to reshape\n+     *\n+     * @return components reshaped\n+     *\/\n+    private static MethodHandle[] reshapeComponents(CarrierShape carrierShape,\n+                                                    MethodHandle[] components) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        MethodHandle[] reorder = new MethodHandle[count];\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle component;\n+\n+            if (!ptype.isPrimitive()) {\n+                component = components[objectIndex++];\n+            } else if (ptype == double.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[longIndex++], LONG_TO_DOUBLE);\n+            } else if (ptype == float.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[intIndex++], INT_TO_FLOAT);\n+            } else if (ptype == long.class) {\n+                component = components[longIndex++];\n+            } else {\n+                component = components[intIndex++];\n+            }\n+\n+            MethodType methodType = methodType(ptype, Object.class);\n+            reorder[index++] =\n+                    MethodHandles.explicitCastArguments(component, methodType);\n+        }\n+\n+        return reorder;\n+    }\n+\n+    \/**\n+     * Given components array and index, recast and reorder that component to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components\n+     * @param i             index of component to reshape\n+     *\n+     * @return component reshaped\n+     *\/\n+    private static MethodHandle reshapeComponent(CarrierShape carrierShape,\n+                                                 MethodHandle[] components, int i) {\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        CarrierCounts componentCounts = CarrierCounts.tally(ptypes, i);\n+        Class<?> ptype = ptypes[i];\n+        int index;\n+        MethodHandle filter = null;\n+\n+        if (!ptype.isPrimitive()) {\n+            index = carrierShape.objectOffset() + componentCounts.objectCount();\n+        } else if (ptype == double.class) {\n+            index = carrierShape.longOffset() + componentCounts.longCount();\n+            filter = LONG_TO_DOUBLE;\n+        } else if (ptype == float.class) {\n+            index = carrierShape.intOffset() + componentCounts.intCount();\n+            filter = INT_TO_FLOAT;\n+        } else if (ptype == long.class) {\n+            index = carrierShape.longOffset() + componentCounts.longCount();\n+        } else {\n+            index = carrierShape.intOffset() + componentCounts.intCount();\n+        }\n+\n+        MethodHandle component = components[index];\n+\n+        if (filter != null) {\n+            component = MethodHandles.filterReturnValue(component, filter);\n+        }\n+\n+        component = MethodHandles.explicitCastArguments(component,\n+                methodType(ptype, Object.class));\n+\n+        return component;\n+    }\n+\n+    \/**\n+     * Factory for carriers that are backed by int[] and Object[]. This strategy is\n+     * used when the number of components exceeds {@link Carrier#MAX_OBJECT_COMPONENTS}.\n@@ -141,0 +294,162 @@\n+        \/**\n+         * Lookup used to define and reference the carrier array methods.\n+         *\/\n+        private static final MethodHandles.Lookup LOOKUP;\n+\n+        \/**\n+         * Unsafe access.\n+         *\/\n+        private static final Unsafe UNSAFE;\n+\n+        static {\n+            LOOKUP = MethodHandles.lookup();\n+            UNSAFE = Unsafe.getUnsafe();\n+\n+            try {\n+                CONSTRUCTOR = LOOKUP.findConstructor(CarrierArray.class,\n+                        methodType(void.class, int.class, int.class));\n+                GET_LONG = LOOKUP.findVirtual(CarrierArray.class, \"getLong\",\n+                        methodType(long.class, int.class));\n+                PUT_LONG = LOOKUP.findVirtual(CarrierArray.class, \"putLong\",\n+                        methodType(CarrierArray.class, int.class, long.class));\n+                GET_INTEGER = LOOKUP.findVirtual(CarrierArray.class, \"getInteger\",\n+                        methodType(int.class, int.class));\n+                PUT_INTEGER = LOOKUP.findVirtual(CarrierArray.class, \"putInteger\",\n+                        methodType(CarrierArray.class, int.class, int.class));\n+                GET_OBJECT = LOOKUP.findVirtual(CarrierArray.class, \"getObject\",\n+                        methodType(Object.class, int.class));\n+                PUT_OBJECT = LOOKUP.findVirtual(CarrierArray.class, \"putObject\",\n+                        methodType(CarrierArray.class, int.class, Object.class));\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier static init fail\", ex);\n+            }\n+        }\n+\n+        \/*\n+         * Constructor accessor MethodHandles.\n+         *\/\n+        private static final MethodHandle CONSTRUCTOR;\n+        private static final MethodHandle GET_LONG;\n+        private static final MethodHandle PUT_LONG;\n+        private static final MethodHandle GET_INTEGER;\n+        private static final MethodHandle PUT_INTEGER;\n+        private static final MethodHandle GET_OBJECT;\n+        private static final MethodHandle PUT_OBJECT;\n+\n+        \/**\n+         * Wrapper object for carrier arrays.\n+         *\/\n+        private static class CarrierArray {\n+            \/**\n+             * Carrier for longs and integers.\n+             *\/\n+            private final int[] integers;\n+\n+            \/**\n+             * Carrier for objects;\n+             *\/\n+            private final Object[] objects;\n+\n+            \/**\n+             * Constructor.\n+             *\n+             * @param intCount     slot count required for longs and integers\n+             * @param objectCount  slot count required for objects\n+             *\/\n+            CarrierArray(int intCount, int objectCount) {\n+                this.integers = new int[intCount];\n+                this.objects = new Object[objectCount];\n+            }\n+\n+            \/**\n+             * Check index and compute offset for unsafe long access.\n+             *\n+             * @param i  index in int[]\n+             *\n+             * @return offset for unsafe long access\n+             *\/\n+            private long longOffset(int i) {\n+                if (i < 0 || integers.length <= i) {\n+                    throw new RuntimeException(\"long index out of range: \" + i);\n+                }\n+\n+                return Unsafe.ARRAY_INT_BASE_OFFSET +\n+                        (long)i * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            }\n+\n+            \/**\n+             * Get a long value from the int[].\n+             *\n+             * @param i  array index\n+             *\n+             * @return long value at that index.\n+             *\/\n+            private long getLong(int i) {\n+                return UNSAFE.getLong(integers, longOffset(i));\n+            }\n+\n+            \/**\n+             * Put a long value into the int[].\n+             *\n+             * @param i      array index\n+             * @param value  long value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putLong(int i, long value) {\n+                UNSAFE.putLong(integers, longOffset(i), value);\n+\n+                return this;\n+            }\n+\n+            \/**\n+             * Get a int value from the int[].\n+             *\n+             * @param i  array index\n+             *\n+             * @return int value at that index.\n+             *\/\n+            private int getInteger(int i) {\n+                return integers[i];\n+            }\n+\n+            \/**\n+             * Put a int value into the int[].\n+             *\n+             * @param i      array index\n+             * @param value  int value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putInteger(int i, int value) {\n+                integers[i] = value;\n+\n+                return this;\n+            }\n+\n+            \/**\n+             * Get an object value from the objects[].\n+             *\n+             * @param i  array index\n+             *\n+             * @return object value at that index.\n+             *\/\n+            private Object getObject(int i) {\n+                return objects[i];\n+            }\n+\n+            \/**\n+             * Put a object value into the objects[].\n+             *\n+             * @param i      array index\n+             * @param value  object value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putObject(int i, Object value) {\n+                objects[i] = value;\n+\n+                return this;\n+            }\n+        }\n+\n@@ -149,4 +464,14 @@\n-            Class<?>[] ptypes = carrierShape.ptypes();\n-            MethodType methodType = methodType(Object.class, ptypes);\n-            MethodHandle collector = MethodHandles.identity(Object[].class)\n-                    .withVarargs(true);\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int intSlots = longCount * LONG_SLOTS + intCount;\n+\n+            MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,\n+                    0, intSlots, objectCount);\n+\n+            int index = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_LONG, 1, index);\n+                index += LONG_SLOTS;\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n@@ -154,1 +479,11 @@\n-            return collector.asType(methodType);\n+            for (int i = 0; i < intCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_INTEGER, 1, index++);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_OBJECT, 1, i);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            return reshapeConstructor(carrierShape, constructor);\n@@ -158,2 +493,1 @@\n-         * Return an array of carrier component getters, aligning with types in\n-         * {@code ptypes}.\n+         * Utility to construct the basic accessors from the components.\n@@ -163,1 +497,1 @@\n-         * @return array of carrier getters\n+         * @return array of carrier accessors\n@@ -165,4 +499,6 @@\n-        private static MethodHandle[] components(CarrierShape carrierShape) {\n-            Class<?>[] ptypes = carrierShape.ptypes();\n-            int length = ptypes.length;\n-            MethodHandle[] getters = new MethodHandle[length];\n+        private static MethodHandle[] createComponents(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle[] components =\n+                    new MethodHandle[carrierShape.ptypes().length];\n@@ -170,2 +506,4 @@\n-            for (int i = 0; i < length; i++) {\n-                getters[i] = component(carrierShape, i);\n+            int index = 0, j = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                components[j++] = MethodHandles.insertArguments(GET_LONG, 1, index);\n+                index += LONG_SLOTS;\n@@ -174,1 +512,8 @@\n-            return getters;\n+            for (int i = 0; i < intCount; i++) {\n+                components[j++] = MethodHandles.insertArguments(GET_INTEGER, 1, index++);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                components[j++] = MethodHandles.insertArguments(GET_OBJECT, 1, i);\n+            }\n+            return components;\n@@ -178,1 +523,15 @@\n-         * Return a carrier getter for component {@code i}.\n+         * Return an array of carrier component accessors, aligning with types in\n+         * {@code ptypes}.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier accessors\n+         *\/\n+        private static MethodHandle[] components(CarrierShape carrierShape) {\n+            MethodHandle[] components = createComponents(carrierShape);\n+\n+            return reshapeComponents(carrierShape, components);\n+        }\n+\n+        \/**\n+         * Return a carrier accessor for component {@code i}.\n@@ -183,1 +542,1 @@\n-         * @return carrier component {@code i} getter {@link MethodHandle}\n+         * @return carrier component {@code i} accessor {@link MethodHandle}\n@@ -186,4 +545,1 @@\n-            Class<?>[] ptypes = carrierShape.ptypes();\n-            MethodType methodType = methodType(ptypes[i], Object.class);\n-            MethodHandle getter =\n-                    MethodHandles.arrayElementGetter(Object[].class);\n+            MethodHandle[] components = createComponents(carrierShape);\n@@ -191,2 +547,1 @@\n-            return MethodHandles.insertArguments(\n-                    getter, 1, i).asType(methodType);\n+            return reshapeComponent(carrierShape, components, i);\n@@ -205,1 +560,1 @@\n-     * of fields is reordered by the component getter {@link MethodHandles}. So a\n+     * of fields is reordered by the component accessor {@link MethodHandles}. So a\n@@ -210,1 +565,1 @@\n-     * object. The component getters reverse the effect of the recasts\/translates.\n+     * object. The component accessors reverse the effect of the recasts\/translates.\n@@ -335,1 +690,1 @@\n-                arg += 2;\n+                arg += LONG_SLOTS;\n@@ -369,2 +724,0 @@\n-            int objectCount = carrierShape.objectCount();\n-            int intCount = carrierShape.intCount();\n@@ -372,2 +725,4 @@\n-            int argCount = objectCount + intCount + longCount;\n-            Class<?>[] ptypes = new Class<?>[argCount];\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int count = carrierShape.count();\n+            Class<?>[] ptypes = new Class<?>[count];\n@@ -376,1 +731,1 @@\n-            for(int i = 0; i < carrierShape.longCount(); i++) {\n+            for(int i = 0; i < longCount; i++) {\n@@ -380,1 +735,1 @@\n-            for(int i = 0; i < carrierShape.intCount(); i++) {\n+            for(int i = 0; i < intCount; i++) {\n@@ -384,1 +739,1 @@\n-            for(int i = 0; i < carrierShape.objectCount(); i++) {\n+            for(int i = 0; i < objectCount; i++) {\n@@ -411,1 +766,1 @@\n-         * Returns an array of raw component getters for the carrier class.\n+         * Returns an array of raw component accessors for the carrier class.\n@@ -416,1 +771,0 @@\n-         * @param constructorMethodType  constructor method type\n@@ -419,1 +773,1 @@\n-         *         getters\n+         *         accessors\n@@ -423,4 +777,3 @@\n-        private static MethodHandle[] components(CarrierShape carrierShape,\n-                                                 Lookup carrierClassLookup,\n-                                                 Class<?> carrierClass,\n-                                                 MethodType constructorMethodType)\n+        private static MethodHandle[] createComponents(CarrierShape carrierShape,\n+                                                       Lookup carrierClassLookup,\n+                                                       Class<?> carrierClass)\n@@ -428,2 +781,5 @@\n-            MethodHandle[] components;\n-            components = new MethodHandle[constructorMethodType.parameterCount()];\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int count = carrierShape.count();\n+            MethodHandle[] components = new MethodHandle[count];\n@@ -432,1 +788,1 @@\n-            for(int i = 0; i < carrierShape.longCount(); i++) {\n+            for(int i = 0; i < longCount; i++) {\n@@ -434,1 +790,1 @@\n-                        CarrierObjectFactory.longFieldName(i), long.class);\n+                        longFieldName(i), long.class);\n@@ -437,1 +793,1 @@\n-            for(int i = 0; i < carrierShape.intCount(); i++) {\n+            for(int i = 0; i < intCount; i++) {\n@@ -439,1 +795,1 @@\n-                        CarrierObjectFactory.intFieldName(i), int.class);\n+                        intFieldName(i), int.class);\n@@ -442,1 +798,1 @@\n-            for(int i = 0; i < carrierShape.objectCount(); i++) {\n+            for(int i = 0; i < objectCount; i++) {\n@@ -444,1 +800,1 @@\n-                        CarrierObjectFactory.objectFieldName(i), Object.class);\n+                        objectFieldName(i), Object.class);\n@@ -456,1 +812,1 @@\n-         *         component getters.\n+         *         component accessors.\n@@ -467,2 +823,2 @@\n-                MethodHandle[] components = components(carrierShape,\n-                        carrierCLassLookup, carrierClass, constructorMethodType);\n+                MethodHandle[] components = createComponents(carrierShape,\n+                        carrierCLassLookup, carrierClass);\n@@ -485,40 +841,0 @@\n-            Class<?>[] ptypes = carrierShape.ptypes();\n-            int length = ptypes.length;\n-            int objectIndex = carrierShape.objectOffset();\n-            int intIndex = carrierShape.intOffset();\n-            int longIndex = carrierShape.longOffset();\n-            int[] reorder = new int[length];\n-            Class<?>[] permutePTypes = new Class<?>[length];\n-            MethodHandle[] filters = new MethodHandle[length];\n-            boolean hasFilters = false;\n-            int index = 0;\n-\n-            for (Class<?> ptype : ptypes) {\n-                MethodHandle filter = null;\n-                int from;\n-\n-                if (!ptype.isPrimitive()) {\n-                    from = objectIndex++;\n-                    ptype = Object.class;\n-                } else if(ptype == double.class) {\n-                    from = longIndex++;\n-                    filter = DOUBLE_TO_LONG;\n-                } else if(ptype == float.class) {\n-                    from = intIndex++;\n-                    filter = FLOAT_TO_INT;\n-                } else if (ptype == long.class) {\n-                    from = longIndex++;\n-                } else {\n-                    from = intIndex++;\n-                    ptype = int.class;\n-                }\n-\n-                permutePTypes[index] = ptype;\n-                reorder[from] = index++;\n-\n-                if (filter != null) {\n-                    filters[from] = filter;\n-                    hasFilters = true;\n-                }\n-            }\n-\n@@ -528,12 +844,1 @@\n-            if (hasFilters) {\n-                constructor = MethodHandles.filterArguments(constructor, 0, filters);\n-            }\n-\n-            MethodType permutedMethodType =\n-                    methodType(constructor.type().returnType(), permutePTypes);\n-            constructor = MethodHandles.permuteArguments(constructor,\n-                    permutedMethodType, reorder);\n-            constructor = MethodHandles.explicitCastArguments(constructor,\n-                    methodType(Object.class, ptypes));\n-\n-            return constructor;\n+            return reshapeConstructor(carrierShape, constructor);\n@@ -543,1 +848,1 @@\n-         * Permute raw component getters to match order and types of the parameter\n+         * Permute raw component accessors to match order and types of the parameter\n@@ -551,6 +856,0 @@\n-            Class<?>[] ptypes = carrierShape.ptypes();\n-            MethodHandle[] reorder = new MethodHandle[ptypes.length];\n-            int objectIndex = carrierShape.objectOffset();\n-            int intIndex = carrierShape.intOffset();\n-            int longIndex = carrierShape.longOffset();\n-            int index = 0;\n@@ -560,23 +859,1 @@\n-            for (Class<?> ptype : ptypes) {\n-                MethodHandle component;\n-\n-                if (!ptype.isPrimitive()) {\n-                    component = components[objectIndex++];\n-                } else if (ptype == double.class) {\n-                    component = MethodHandles.filterReturnValue(\n-                            components[longIndex++], LONG_TO_DOUBLE);\n-                } else if (ptype == float.class) {\n-                    component = MethodHandles.filterReturnValue(\n-                            components[intIndex++], INT_TO_FLOAT);\n-                } else if (ptype == long.class) {\n-                    component = components[longIndex++];\n-                } else {\n-                    component = components[intIndex++];\n-                }\n-\n-                MethodType methodType = methodType(ptype, Object.class);\n-                reorder[index++] =\n-                        MethodHandles.explicitCastArguments(component, methodType);\n-            }\n-\n-            return reorder;\n+            return reshapeComponents(carrierShape, components);\n@@ -586,1 +863,1 @@\n-         * Returns a carrier component getter {@link MethodHandle} for the\n+         * Returns a carrier component accessor {@link MethodHandle} for the\n@@ -592,1 +869,1 @@\n-         * @return carrier component getter {@link MethodHandle}\n+         * @return carrier component accessor {@link MethodHandle}\n@@ -598,20 +875,0 @@\n-            Class<?>[] ptypes = carrierShape.ptypes();\n-            CarrierCounts componentCounts = CarrierCounts.count(ptypes, i);\n-            Class<?> ptype = ptypes[i];\n-            int index;\n-            MethodHandle filter = null;\n-\n-            if (!ptype.isPrimitive()) {\n-                index = carrierShape.objectOffset() + componentCounts.objectCount();\n-            } else if (ptype == double.class) {\n-                index = carrierShape.longOffset() + componentCounts.longCount();\n-                filter = LONG_TO_DOUBLE;\n-            } else if (ptype == float.class) {\n-                index = carrierShape.intOffset() + componentCounts.intCount();\n-                filter = INT_TO_FLOAT;\n-            } else if (ptype == long.class) {\n-                index = carrierShape.longOffset() + componentCounts.longCount();\n-            } else {\n-                index = carrierShape.intOffset() + componentCounts.intCount();\n-            }\n-\n@@ -619,1 +876,1 @@\n-            MethodHandle component = carrierClass.component(index);\n+            MethodHandle[] components = carrierClass.components;\n@@ -621,8 +878,1 @@\n-            if (filter != null) {\n-                component = MethodHandles.filterReturnValue(component, filter);\n-            }\n-\n-            component = MethodHandles.explicitCastArguments(component,\n-                    methodType(ptype, Object.class));\n-\n-            return component;\n+            return reshapeComponent(carrierShape, components, i);\n@@ -637,1 +887,1 @@\n-            \/**\n+            \/*\n@@ -643,1 +893,1 @@\n-            \/**\n+            \/*\n@@ -645,1 +895,1 @@\n-             * component getters. These getters will only return Object, int and\n+             * component accessors. These accessors will only return Object, int and\n@@ -649,12 +899,0 @@\n-\n-        \/**\n-         * Create a single raw {@link MethodHandle} for a carrier component\n-         * getter.\n-         *\n-         * @param i  index of component to get\n-         *\n-         * @return raw {@link MethodHandle} for the component getter\n-         *\/\n-        MethodHandle component(int i) {\n-            return components[i];\n-        }\n@@ -699,2 +937,2 @@\n-        static CarrierCounts count(Class<?>[] ptypes) {\n-            return count(ptypes, ptypes.length);\n+        static CarrierCounts tally(Class<?>[] ptypes) {\n+            return tally(ptypes, ptypes.length);\n@@ -712,1 +950,1 @@\n-        private static CarrierCounts count(Class<?>[] ptypes, int n) {\n+        private static CarrierCounts tally(Class<?>[] ptypes, int n) {\n@@ -732,0 +970,9 @@\n+        \/**\n+         * Returns total number of components.\n+         *\n+         * @return total number of components\n+         *\/\n+        private int count() {\n+            return longCount + intCount + objectCount;\n+        }\n+\n@@ -738,1 +985,1 @@\n-            return longCount * 2 + intCount + objectCount;\n+            return longCount * LONG_SLOTS + intCount + objectCount;\n@@ -766,1 +1013,1 @@\n-            this.counts = CarrierCounts.count(methodType.parameterArray());\n+            this.counts = CarrierCounts.tally(methodType.parameterArray());\n@@ -815,3 +1062,1 @@\n-         * Return number of constructor parameters.\n-         *\n-         * @return number of constructor parameters\n+         * {@return number of components}\n@@ -819,2 +1064,2 @@\n-        private int parameterCount() {\n-            return methodType.parameterCount();\n+        private int count() {\n+            return counts.count();\n@@ -858,1 +1103,0 @@\n-\n@@ -889,1 +1133,1 @@\n-     * Return component getter {@link MethodHandle MethodHandles} for all the\n+     * Return component accessor {@link MethodHandle MethodHandles} for all the\n@@ -911,1 +1155,1 @@\n-            return Carrier.CarrierArrayFactory.components(carrierShape);\n+            return CarrierArrayFactory.components(carrierShape);\n@@ -916,1 +1160,1 @@\n-     * Return a component getter {@link MethodHandle} for component {@code i}.\n+     * Return a component accessor {@link MethodHandle} for component {@code i}.\n@@ -922,1 +1166,1 @@\n-     * @return a component getter {@link MethodHandle} for component {@code i}\n+     * @return a component accessor {@link MethodHandle} for component {@code i}\n@@ -933,1 +1177,1 @@\n-        if (i < 0 || i >= carrierShape.parameterCount()) {\n+        if (i < 0 || i >= carrierShape.count()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":454,"deletions":210,"binary":false,"changes":664,"status":"modified"}]}