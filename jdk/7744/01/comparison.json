{"files":[{"patch":"@@ -0,0 +1,943 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodHandles.Lookup.ClassOption;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import jdk.internal.misc.VM;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * This  class is used to create anonymous objects that have number and types of\n+ * components determined at runtime.\n+ *\n+ * @implNote The strategy for storing components is deliberately left ambiguous\n+ * so that future improvements will not be hampered by issues of backward\n+ * compatability.\n+ *\n+ * @since 19\n+ *\/\n+final class Carrier {\n+    \/**\n+     * Class file version.\n+     *\/\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+\n+    \/**\n+     * Lookup used to define and reference the carrier object classes.\n+     *\/\n+    private static final Lookup LOOKUP;\n+\n+    \/**\n+     * Maximum number of components in a carrier (based on the maximum\n+     * number of args to a constructor.)\n+     *\/\n+    private static final int MAX_COMPONENTS = 255 - \/* this *\/ 1;\n+\n+    \/**\n+     * Maximum number of components in a CarrierClass.\n+     *\/\n+    private static final int MAX_OBJECT_COMPONENTS = 32;\n+\n+    \/**\n+     * Stable annotation.\n+     *\/\n+    private static final String STABLE = \"jdk\/internal\/vm\/annotation\/Stable\";\n+    private static final String STABLE_SIG = \"L\" + STABLE + \";\";\n+\n+    \/*\n+     * Initialize {@link MethodHandle} constants.\n+     *\/\n+    static {\n+        Lookup lookup = MethodHandles.lookup();\n+        LOOKUP = lookup;\n+\n+        try {\n+            FLOAT_TO_INT = lookup.findStatic(Float.class, \"floatToRawIntBits\",\n+                    methodType(int.class, float.class));\n+            INT_TO_FLOAT = lookup.findStatic(Float.class, \"intBitsToFloat\",\n+                    methodType(float.class, int.class));\n+            DOUBLE_TO_LONG = lookup.findStatic(Double.class, \"doubleToRawLongBits\",\n+                    methodType(long.class, double.class));\n+            LONG_TO_DOUBLE = lookup.findStatic(Double.class, \"longBitsToDouble\",\n+                    methodType(double.class, long.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * float\/double conversions.\n+     *\/\n+    private static final MethodHandle FLOAT_TO_INT;\n+    private static final MethodHandle INT_TO_FLOAT;\n+    private static final MethodHandle DOUBLE_TO_LONG;\n+    private static final MethodHandle LONG_TO_DOUBLE;\n+\n+    \/**\n+     * long signature descriptor.\n+     *\/\n+    private static final String LONG_DESCRIPTOR =\n+            Type.getDescriptor(long.class);\n+\n+    \/**\n+     * int signature descriptor.\n+     *\/\n+    private static final String INT_DESCRIPTOR =\n+            Type.getDescriptor(int.class);\n+\n+    \/**\n+     * Object signature descriptor.\n+     *\/\n+    private static final String OBJECT_DESCRIPTOR =\n+            Type.getDescriptor(Object.class);\n+\n+    \/**\n+     * Factory for carriers that are backed by an Object[]. This strategy is used when\n+     * the number of components exceeds {@link Carrier#MAX_OBJECT_COMPONENTS}. The\n+     * object returned by the carrier constructor is the backing Object[].\n+     * <p>\n+     * Each element of the Object[] corresponds directly, via index, to each component.\n+     * If the component is a primitive value then the constructor boxes the value before\n+     * inserting into the array, and the carrier component getter unboxes.\n+     *\/\n+    private static class CarrierArrayFactory {\n+        \/**\n+         * Constructor\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to generic carrier constructor.\n+         *\/\n+        private static MethodHandle constructor(CarrierShape carrierShape) {\n+            Class<?>[] ptypes = carrierShape.ptypes();\n+            MethodType methodType = methodType(Object.class, ptypes);\n+            MethodHandle collector = MethodHandles.identity(Object[].class)\n+                    .withVarargs(true);\n+\n+            return collector.asType(methodType);\n+        }\n+\n+        \/**\n+         * Return an array of carrier component getters, aligning with types in\n+         * {@code ptypes}.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier getters\n+         *\/\n+        private static MethodHandle[] components(CarrierShape carrierShape) {\n+            Class<?>[] ptypes = carrierShape.ptypes();\n+            int length = ptypes.length;\n+            MethodHandle[] getters = new MethodHandle[length];\n+\n+            for (int i = 0; i < length; i++) {\n+                getters[i] = component(carrierShape, i);\n+            }\n+\n+            return getters;\n+        }\n+\n+        \/**\n+         * Return a carrier getter for component {@code i}.\n+         *\n+         * @param carrierShape  carrier object shape\n+         * @param i             index of parameter to get\n+         *\n+         * @return carrier component {@code i} getter {@link MethodHandle}\n+         *\/\n+        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+            Class<?>[] ptypes = carrierShape.ptypes();\n+            MethodType methodType = methodType(ptypes[i], Object.class);\n+            MethodHandle getter =\n+                    MethodHandles.arrayElementGetter(Object[].class);\n+\n+            return MethodHandles.insertArguments(\n+                    getter, 1, i).asType(methodType);\n+        }\n+    }\n+\n+    \/**\n+     * Factory for object based carrier. This strategy is used when the number of\n+     * components is less than equal {@link Carrier#MAX_OBJECT_COMPONENTS}. The factory\n+     * constructs an anonymous class that provides a shape that  matches the\n+     * number of longs, ints and objects required by the {@link CarrierShape}. The\n+     * factory caches and reuses anonymous classes when looking for a match.\n+     * <p>\n+     * The anonymous class that is constructed contains the number of long fields then\n+     * int fields then object fields required by the {@link CarrierShape}. The order\n+     * of fields is reordered by the component getter {@link MethodHandles}. So a\n+     * carrier requiring an int and then object will use the same anonymous class as\n+     * a carrier requiring an object then int.\n+     * <p>\n+     * The carrier constructor recasts\/translates values that are not long, int or\n+     * object. The component getters reverse the effect of the recasts\/translates.\n+     *\/\n+    private static class CarrierObjectFactory {\n+        \/**\n+         * Define the hidden class Lookup object\n+         *\n+         * @param bytes  class content\n+         *\n+         * @return the Lookup object of the hidden class\n+         *\/\n+        private static Lookup defineHiddenClass(byte[] bytes) {\n+            try {\n+                return LOOKUP.defineHiddenClass(bytes, false, ClassOption.STRONG);\n+            } catch (IllegalAccessException ex) {\n+                throw new AssertionError(\"carrier factory static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the name of a long component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of long component\n+         *\/\n+        private static String longFieldName(int index) {\n+            return \"l\" + index;\n+        }\n+\n+        \/**\n+         * Generate the name of an int component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of int component\n+         *\/\n+        private static String intFieldName(int index) {\n+            return \"i\" + index;\n+        }\n+\n+        \/**\n+         * Generate the name of an object component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of object component\n+         *\/\n+        private static String objectFieldName(int index) {\n+            return \"o\" + index;\n+        }\n+\n+        \/**\n+         * Generate the full name of a carrier class based on shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return name of a carrier class\n+         *\/\n+        private static String carrierClassName(CarrierShape carrierShape) {\n+            String packageName = Carrier.class.getPackageName().replace('.', '\/');\n+            String className = \"Carrier\" +\n+                    longFieldName(carrierShape.longCount()) +\n+                    intFieldName(carrierShape.intCount()) +\n+                    objectFieldName(carrierShape.objectCount());\n+\n+            return packageName.isEmpty() ? className :\n+                    packageName + \"\/\" + className;\n+        }\n+\n+        \/**\n+         * Build up the byte code for the carrier class.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return byte array of byte code for the carrier class\n+         *\/\n+        private static byte[] buildCarrierClass(CarrierShape carrierShape) {\n+            int maxStack = 3;\n+            int maxLocals = 1 \/* this *\/ + carrierShape.slotCount();\n+            String carrierClassName = carrierClassName(carrierShape);\n+            StringBuilder initDescriptor = new StringBuilder(\"(\");\n+\n+            ClassWriter cw = new ClassWriter(0);\n+            cw.visit(CLASSFILE_VERSION, ACC_PRIVATE | ACC_FINAL, carrierClassName,\n+                    null, \"java\/lang\/Object\", null);\n+\n+            int fieldFlags = ACC_PRIVATE | ACC_FINAL;\n+\n+            for (int i = 0; i < carrierShape.longCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, longFieldName(i),\n+                        LONG_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(LONG_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.intCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, intFieldName(i),\n+                        INT_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(INT_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.objectCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, objectFieldName(i),\n+                        OBJECT_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(OBJECT_DESCRIPTOR);\n+            }\n+\n+            initDescriptor.append(\")V\");\n+\n+            int arg = 1;\n+\n+            MethodVisitor init = cw.visitMethod(ACC_PUBLIC,\n+                    \"<init>\", initDescriptor.toString(), null, null);\n+            init.visitVarInsn(ALOAD, 0);\n+            init.visitMethodInsn(INVOKESPECIAL,\n+                    \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+\n+            for (int i = 0; i < carrierShape.longCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(LLOAD, arg);\n+                arg += 2;\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        longFieldName(i), LONG_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.intCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(ILOAD, arg++);\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        intFieldName(i), INT_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.objectCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(ALOAD, arg++);\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        objectFieldName(i), OBJECT_DESCRIPTOR);\n+            }\n+\n+            init.visitInsn(RETURN);\n+            init.visitMaxs(maxStack, maxLocals);\n+            init.visitEnd();\n+\n+            cw.visitEnd();\n+\n+            return cw.toByteArray();\n+        }\n+\n+        \/**\n+         * Returns the constructor method type.\n+         *\n+         * @return the constructor method type.\n+         *\/\n+        private static MethodType constructorMethodType(CarrierShape carrierShape) {\n+            int objectCount = carrierShape.objectCount();\n+            int intCount = carrierShape.intCount();\n+            int longCount = carrierShape.longCount();\n+            int argCount = objectCount + intCount + longCount;\n+            Class<?>[] ptypes = new Class<?>[argCount];\n+            int arg = 0;\n+\n+            for(int i = 0; i < carrierShape.longCount(); i++) {\n+                ptypes[arg++] = long.class;\n+            }\n+\n+            for(int i = 0; i < carrierShape.intCount(); i++) {\n+                ptypes[arg++] = int.class;\n+            }\n+\n+            for(int i = 0; i < carrierShape.objectCount(); i++) {\n+                ptypes[arg++] = Object.class;\n+            }\n+\n+            return methodType(void.class, ptypes);\n+        }\n+\n+        \/**\n+         * Returns the raw constructor for the carrier class.\n+         *\n+         * @param carrierClassLookup     lookup for carrier class\n+         * @param carrierClass           newly constructed carrier class\n+         * @param constructorMethodType  constructor method type\n+         *\n+         * @return {@link MethodHandle} to carrier class constructor\n+         *\n+         * @throws ReflectiveOperationException if lookup failure\n+         *\/\n+        private static MethodHandle constructor(Lookup carrierClassLookup,\n+                                                Class<?> carrierClass,\n+                                                MethodType constructorMethodType)\n+                throws ReflectiveOperationException {\n+            return carrierClassLookup.findConstructor(carrierClass,\n+                    constructorMethodType);\n+        }\n+\n+        \/**\n+         * Returns an array of raw component getters for the carrier class.\n+         *\n+         * @param carrierShape           shape of carrier\n+         * @param carrierClassLookup     lookup for carrier class\n+         * @param carrierClass           newly constructed carrier class\n+         * @param constructorMethodType  constructor method type\n+         *\n+         * @return {@link MethodHandle MethodHandles} to carrier component\n+         *         getters\n+         *\n+         * @throws ReflectiveOperationException if lookup failure\n+         *\/\n+        private static MethodHandle[] components(CarrierShape carrierShape,\n+                                                 Lookup carrierClassLookup,\n+                                                 Class<?> carrierClass,\n+                                                 MethodType constructorMethodType)\n+                throws ReflectiveOperationException {\n+            MethodHandle[] components;\n+            components = new MethodHandle[constructorMethodType.parameterCount()];\n+            int arg = 0;\n+\n+            for(int i = 0; i < carrierShape.longCount(); i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        CarrierObjectFactory.longFieldName(i), long.class);\n+            }\n+\n+            for(int i = 0; i < carrierShape.intCount(); i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        CarrierObjectFactory.intFieldName(i), int.class);\n+            }\n+\n+            for(int i = 0; i < carrierShape.objectCount(); i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        CarrierObjectFactory.objectFieldName(i), Object.class);\n+            }\n+\n+            return components;\n+        }\n+\n+        \/**\n+         * Construct a new object carrier class based on shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return a {@link CarrierClass} object containing constructor and\n+         *         component getters.\n+         *\/\n+        private static CarrierClass newCarrierClass(CarrierShape carrierShape) {\n+            byte[] bytes = buildCarrierClass(carrierShape);\n+\n+            try {\n+                Lookup carrierCLassLookup = defineHiddenClass(bytes);\n+                Class<?> carrierClass = carrierCLassLookup.lookupClass();\n+                MethodType constructorMethodType = constructorMethodType(carrierShape);\n+                MethodHandle constructor = constructor(carrierCLassLookup,\n+                        carrierClass, constructorMethodType);\n+                MethodHandle[] components = components(carrierShape,\n+                        carrierCLassLookup, carrierClass, constructorMethodType);\n+\n+                return new CarrierClass(constructor, components);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier class static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Permute a raw constructor {@link MethodHandle} to match the order and\n+         * types of the parameter types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} constructor matching parameter types\n+         *\/\n+        private static MethodHandle constructor(CarrierShape carrierShape) {\n+            Class<?>[] ptypes = carrierShape.ptypes();\n+            int length = ptypes.length;\n+            int objectIndex = carrierShape.objectOffset();\n+            int intIndex = carrierShape.intOffset();\n+            int longIndex = carrierShape.longOffset();\n+            int[] reorder = new int[length];\n+            Class<?>[] permutePTypes = new Class<?>[length];\n+            MethodHandle[] filters = new MethodHandle[length];\n+            boolean hasFilters = false;\n+            int index = 0;\n+\n+            for (Class<?> ptype : ptypes) {\n+                MethodHandle filter = null;\n+                int from;\n+\n+                if (!ptype.isPrimitive()) {\n+                    from = objectIndex++;\n+                    ptype = Object.class;\n+                } else if(ptype == double.class) {\n+                    from = longIndex++;\n+                    filter = DOUBLE_TO_LONG;\n+                } else if(ptype == float.class) {\n+                    from = intIndex++;\n+                    filter = FLOAT_TO_INT;\n+                } else if (ptype == long.class) {\n+                    from = longIndex++;\n+                } else {\n+                    from = intIndex++;\n+                    ptype = int.class;\n+                }\n+\n+                permutePTypes[index] = ptype;\n+                reorder[from] = index++;\n+\n+                if (filter != null) {\n+                    filters[from] = filter;\n+                    hasFilters = true;\n+                }\n+            }\n+\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle constructor = carrierClass.constructor();\n+\n+            if (hasFilters) {\n+                constructor = MethodHandles.filterArguments(constructor, 0, filters);\n+            }\n+\n+            MethodType permutedMethodType =\n+                    methodType(constructor.type().returnType(), permutePTypes);\n+            constructor = MethodHandles.permuteArguments(constructor,\n+                    permutedMethodType, reorder);\n+            constructor = MethodHandles.explicitCastArguments(constructor,\n+                    methodType(Object.class, ptypes));\n+\n+            return constructor;\n+        }\n+\n+        \/**\n+         * Permute raw component getters to match order and types of the parameter\n+         * types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of components matching parameter types\n+         *\/\n+        private static MethodHandle[] components(CarrierShape carrierShape) {\n+            Class<?>[] ptypes = carrierShape.ptypes();\n+            MethodHandle[] reorder = new MethodHandle[ptypes.length];\n+            int objectIndex = carrierShape.objectOffset();\n+            int intIndex = carrierShape.intOffset();\n+            int longIndex = carrierShape.longOffset();\n+            int index = 0;\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle[] components = carrierClass.components();\n+\n+            for (Class<?> ptype : ptypes) {\n+                MethodHandle component;\n+\n+                if (!ptype.isPrimitive()) {\n+                    component = components[objectIndex++];\n+                } else if (ptype == double.class) {\n+                    component = MethodHandles.filterReturnValue(\n+                            components[longIndex++], LONG_TO_DOUBLE);\n+                } else if (ptype == float.class) {\n+                    component = MethodHandles.filterReturnValue(\n+                            components[intIndex++], INT_TO_FLOAT);\n+                } else if (ptype == long.class) {\n+                    component = components[longIndex++];\n+                } else {\n+                    component = components[intIndex++];\n+                }\n+\n+                MethodType methodType = methodType(ptype, Object.class);\n+                reorder[index++] =\n+                        MethodHandles.explicitCastArguments(component, methodType);\n+            }\n+\n+            return reorder;\n+        }\n+\n+        \/**\n+         * Returns a carrier component getter {@link MethodHandle} for the\n+         * component {@code i}.\n+         *\n+         * @param carrierShape  shape of the carrier object\n+         * @param i             index to the component\n+         *\n+         * @return carrier component getter {@link MethodHandle}\n+         *\n+         * @throws IllegalArgumentException if number of component slots exceeds\n+         *         maximum\n+         *\/\n+        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+            Class<?>[] ptypes = carrierShape.ptypes();\n+            CarrierCounts componentCounts = CarrierCounts.count(ptypes, i);\n+            Class<?> ptype = ptypes[i];\n+            int index;\n+            MethodHandle filter = null;\n+\n+            if (!ptype.isPrimitive()) {\n+                index = carrierShape.objectOffset() + componentCounts.objectCount();\n+            } else if (ptype == double.class) {\n+                index = carrierShape.longOffset() + componentCounts.longCount();\n+                filter = LONG_TO_DOUBLE;\n+            } else if (ptype == float.class) {\n+                index = carrierShape.intOffset() + componentCounts.intCount();\n+                filter = INT_TO_FLOAT;\n+            } else if (ptype == long.class) {\n+                index = carrierShape.longOffset() + componentCounts.longCount();\n+            } else {\n+                index = carrierShape.intOffset() + componentCounts.intCount();\n+            }\n+\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle component = carrierClass.component(index);\n+\n+            if (filter != null) {\n+                component = MethodHandles.filterReturnValue(component, filter);\n+            }\n+\n+            component = MethodHandles.explicitCastArguments(component,\n+                    methodType(ptype, Object.class));\n+\n+            return component;\n+        }\n+    }\n+\n+    \/**\n+     * Provides raw constructor and component MethodHandles for a constructed\n+     * carrier class.\n+     *\/\n+    private record CarrierClass(\n+            \/**\n+             * A raw {@link MethodHandle} for a carrier object constructor.\n+             * This constructor will only have Object, int and long type arguments.\n+             *\/\n+            MethodHandle constructor,\n+\n+            \/**\n+             * All the raw {@link MethodHandle MethodHandles} for a carrier\n+             * component getters. These getters will only return Object, int and\n+             * long types.\n+             *\/\n+            MethodHandle[] components) {\n+\n+        \/**\n+         * Create a single raw {@link MethodHandle} for a carrier component\n+         * getter.\n+         *\n+         * @param i  index of component to get\n+         *\n+         * @return raw {@link MethodHandle} for the component getter\n+         *\/\n+        MethodHandle component(int i) {\n+            return components[i];\n+        }\n+    }\n+\n+    \/**\n+     * Cache for all constructed carrier object classes, keyed on class\n+     * name (i.e., carrier shape.)\n+     *\/\n+    private static final ConcurrentHashMap<String, CarrierClass> carrierCache =\n+            new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carrier() {\n+    }\n+\n+    \/**\n+     * Find or create carrier class for a carrier shape.\n+     *\n+     * @param carrierShape  shape of carrier\n+     *\n+     * @return {@link Class<>} of carrier class matching carrier shape\n+     *\/\n+    private static CarrierClass findCarrierClass(CarrierShape carrierShape) {\n+        String carrierClassName =\n+                CarrierObjectFactory.carrierClassName(carrierShape);\n+\n+        return carrierCache.computeIfAbsent(carrierClassName,\n+                cn -> CarrierObjectFactory.newCarrierClass(carrierShape));\n+    }\n+\n+    private record CarrierCounts(int longCount, int intCount, int objectCount) {\n+        \/**\n+         * Count the number of fields required in each of Object, int and long.\n+         *\n+         * @param ptypes  parameter types\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        static CarrierCounts count(Class<?>[] ptypes) {\n+            return count(ptypes, ptypes.length);\n+        }\n+\n+        \/**\n+         * Count the number of fields required in each of Object, int and long\n+         * limited to the first {@code n} parameters.\n+         *\n+         * @param ptypes  parameter types\n+         * @param n       number of parameters to check\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        private static CarrierCounts count(Class<?>[] ptypes, int n) {\n+            int longCount = 0;\n+            int intCount = 0;\n+            int objectCount = 0;\n+\n+            for (int i = 0; i < n; i++) {\n+                Class<?> ptype = ptypes[i];\n+\n+                if (!ptype.isPrimitive()) {\n+                    objectCount++;\n+                } else if (ptype == long.class || ptype == double.class) {\n+                    longCount++;\n+                } else {\n+                    intCount++;\n+                }\n+            }\n+\n+            return new CarrierCounts(longCount, intCount, objectCount);\n+        }\n+\n+        \/**\n+         * Returns total number of slots.\n+         *\n+         * @return total number of slots\n+         *\/\n+        private int slotCount() {\n+            return longCount * 2 + intCount + objectCount;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Shape of carrier based on counts of each of the three fundamental data\n+     * types.\n+     *\/\n+    private static class CarrierShape {\n+        \/**\n+         * {@link MethodType} providing types for the carrier's components.\n+         *\/\n+        private final MethodType methodType;\n+\n+        \/**\n+         * Counts of different parameter types.\n+         *\/\n+        private final CarrierCounts counts;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param methodType  {@link MethodType} providing types for the\n+         *                    carrier's components\n+         *\/\n+        public CarrierShape(MethodType methodType) {\n+            this.methodType = methodType;\n+            this.counts = CarrierCounts.count(methodType.parameterArray());\n+        }\n+\n+        \/**\n+         * Return supplied methodType.\n+         *\n+         * @return supplied methodType\n+         *\/\n+        private MethodType methodType() {\n+            return methodType;\n+        }\n+\n+        \/**\n+         * Return the number of long fields needed.\n+         *\n+         * @return number of long fields needed\n+         *\/\n+        private int longCount() {\n+            return counts.longCount();\n+        }\n+\n+        \/**\n+         * Return the number of int fields needed.\n+         *\n+         * @return number of int fields needed\n+         *\/\n+        private int intCount() {\n+            return counts.intCount();\n+        }\n+\n+        \/**\n+         * Return the number of object fields needed.\n+         *\n+         * @return number of object fields needed\n+         *\/\n+        private int objectCount() {\n+            return counts.objectCount();\n+        }\n+\n+        \/**\n+         * Return parameter types.\n+         *\n+         * @return array of parameter types\n+         *\/\n+        private Class<?>[] ptypes() {\n+            return methodType.parameterArray();\n+        }\n+\n+        \/**\n+         * Return number of constructor parameters.\n+         *\n+         * @return number of constructor parameters\n+         *\/\n+        private int parameterCount() {\n+            return methodType.parameterCount();\n+        }\n+\n+        \/**\n+         * Total number of slots used in a {@link CarrierClass} instance.\n+         *\n+         * @return number of slots used\n+         *\/\n+        private int slotCount() {\n+            return counts.slotCount();\n+        }\n+\n+        \/**\n+         * Returns index of first long component.\n+         *\n+         * @return index of first long component\n+         *\/\n+        private int longOffset() {\n+            return 0;\n+        }\n+\n+        \/**\n+         * Returns index of first int component.\n+         *\n+         * @return index of first int component\n+         *\/\n+        private int intOffset() {\n+            return longCount();\n+        }\n+\n+        \/**\n+         * Returns index of first object component.\n+         *\n+         * @return index of first object component\n+         *\/\n+        private int objectOffset() {\n+            return longCount() + intCount();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Return a constructor {@link MethodHandle} for a carrier with components\n+     * aligning with the parameter types of the supplied\n+     * {@link MethodType methodType}.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     *\n+     * @return carrier constructor {@link MethodHandle}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *\/\n+    public static MethodHandle constructor(MethodType methodType) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape = new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.constructor(carrierShape);\n+        } else {\n+            return CarrierArrayFactory.constructor(carrierShape);\n+        }\n+    }\n+\n+    \/**\n+     * Return component getter {@link MethodHandle MethodHandles} for all the\n+     * carrier's components.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     *\n+     * @return  array of get component {@link MethodHandle MethodHandles,}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *\n+     *\/\n+    public static MethodHandle[] components(MethodType methodType) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape =  new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.components(carrierShape);\n+        } else {\n+            return Carrier.CarrierArrayFactory.components(carrierShape);\n+        }\n+    }\n+\n+    \/**\n+     * Return a component getter {@link MethodHandle} for component {@code i}.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     * @param i           component index\n+     *\n+     * @return a component getter {@link MethodHandle} for component {@code i}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *                                  or if {@code i} is out of bounds\n+     *\/\n+    public static MethodHandle component(MethodType methodType, int i) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape = new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (i < 0 || i >= carrierShape.parameterCount()) {\n+            throw new IllegalArgumentException(\"i is out of bounds for parameter types\");\n+        } else if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.component(carrierShape, i);\n+        } else {\n+            return CarrierArrayFactory.component(carrierShape, i);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":943,"deletions":0,"binary":false,"changes":943,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the Carrier class.\n+ * @compile CarrierTest.java\n+ * @run main CarrierTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.runtime.Carrier;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class CarrierTest {\n+    public static void main(String[] args) throws Throwable {\n+        primitivesTest();\n+        primitivesTestInArrayCarrier();\n+        limitsTest();\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static final int MAX_COMPONENTS = 254;\n+\n+    static void primitivesTest() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class);\n+        MethodHandle constructor = Carrier.constructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\");\n+        MethodHandle[] components = Carrier.components(methodType);\n+        assertTrue((byte)components[0].invokeExact(object) == (byte)0xFF,\n+                \"primitive byte test failure\");\n+        assertTrue((short)components[1].invokeExact(object) == (short)0xFFFF,\n+                \"primitive short test failure\");\n+        assertTrue((char)components[2].invokeExact(object) == 'C',\n+                \"primitive char test failure\");\n+        assertTrue((int)components[3].invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive int test failure\");\n+        assertTrue((long)components[4].invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive long test failure\");\n+        assertTrue((float)components[5].invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive float test failure\");\n+        assertTrue((double)components[6].invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive double test failure\");\n+        assertTrue((boolean)components[7].invokeExact(object),\n+                \"primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components[8].invokeExact(object)),\n+                \"primitive String test failure\");\n+    }\n+\n+    static void primitivesTestInArrayCarrier() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class\n+                        );\n+        MethodHandle constructor = Carrier.constructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\",\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null\n+                );\n+        MethodHandle[] components = Carrier.components(methodType);\n+        assertTrue((byte)components[0].invokeExact(object) == (byte)0xFF,\n+                \"primitive in array byte test failure\");\n+        assertTrue((short)components[1].invokeExact(object) == (short)0xFFFF,\n+                \"primitive in array short test failure\");\n+        assertTrue((char)components[2].invokeExact(object) == 'C',\n+                \"primitive in array char test failure\");\n+        assertTrue((int)components[3].invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive in array int test failure\");\n+        assertTrue((long)components[4].invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive in array long test failure\");\n+        assertTrue((float)components[5].invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive in array float test failure\");\n+        assertTrue((double)components[6].invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive in array double test failure\");\n+        assertTrue((boolean)components[7].invokeExact(object),\n+                \"primitive in array boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components[8].invokeExact(object)),\n+                \"primitive in array String test failure\");\n+    }\n+\n+    static void limitsTest() {\n+        boolean passed;\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS + 1];\n+            Arrays.fill(ptypes, Object.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carrier.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS \/ 2 + 1];\n+            Arrays.fill(ptypes, long.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carrier.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/CarrierTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}