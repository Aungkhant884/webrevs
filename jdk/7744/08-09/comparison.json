{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.List;\n@@ -55,1 +56,1 @@\n- * so that future improvements will not be hampered by backward compatability\n+ * so that future improvements will not be hampered by backward compatibility\n@@ -60,2 +61,0 @@\n-\n-\/*non-public*\/\n@@ -212,1 +211,1 @@\n-     * @return components reshaped\n+     * @return list of components reshaped\n@@ -214,2 +213,2 @@\n-    private static MethodHandle[] reshapeComponents(CarrierShape carrierShape,\n-                                                    MethodHandle[] components) {\n+    private static List<MethodHandle> reshapeComponents(CarrierShape carrierShape,\n+                                                        MethodHandle[] components) {\n@@ -246,1 +245,45 @@\n-        return reorder;\n+        return List.of(reorder);\n+    }\n+\n+    \/**\n+     * Given components array and index, recast and reorder that component to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components\n+     * @param i             index of component to reshape\n+     *\n+     * @return component reshaped\n+     *\/\n+    private static MethodHandle reshapeComponent(CarrierShape carrierShape,\n+                                                 MethodHandle[] components, int i) {\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        CarrierCounts componentCounts = CarrierCounts.tally(ptypes, i);\n+        Class<?> ptype = ptypes[i];\n+        int index;\n+        MethodHandle filter = null;\n+\n+        if (!ptype.isPrimitive()) {\n+            index = carrierShape.objectOffset() + componentCounts.objectCount();\n+        } else if (ptype == double.class) {\n+            index = carrierShape.longOffset() + componentCounts.longCount();\n+            filter = LONG_TO_DOUBLE;\n+        } else if (ptype == float.class) {\n+            index = carrierShape.intOffset() + componentCounts.intCount();\n+            filter = INT_TO_FLOAT;\n+        } else if (ptype == long.class) {\n+            index = carrierShape.longOffset() + componentCounts.longCount();\n+        } else {\n+            index = carrierShape.intOffset() + componentCounts.intCount();\n+        }\n+\n+        MethodHandle component = components[index];\n+\n+        if (filter != null) {\n+            component = MethodHandles.filterReturnValue(component, filter);\n+        }\n+\n+        component = MethodHandles.explicitCastArguments(component,\n+                methodType(ptype, Object.class));\n+\n+        return component;\n@@ -493,1 +536,1 @@\n-         * @return array of carrier accessors\n+         * @return list of carrier accessors\n@@ -495,1 +538,1 @@\n-        private static MethodHandle[] components(CarrierShape carrierShape) {\n+        private static List<MethodHandle> components(CarrierShape carrierShape) {\n@@ -500,0 +543,14 @@\n+\n+        \/**\n+         * Return a carrier accessor for component {@code i}.\n+         *\n+         * @param carrierShape  carrier object shape\n+         * @param i             index of parameter to get\n+         *\n+         * @return carrier component {@code i} accessor {@link MethodHandle}\n+         *\/\n+        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+            MethodHandle[] components = createComponents(carrierShape);\n+\n+            return reshapeComponent(carrierShape, components, i);\n+        }\n@@ -806,1 +863,1 @@\n-         * @return array of components matching parameter types\n+         * @return list of components matching parameter types\n@@ -808,1 +865,1 @@\n-        private static MethodHandle[] components(CarrierShape carrierShape) {\n+        private static List<MethodHandle> components(CarrierShape carrierShape) {\n@@ -814,0 +871,19 @@\n+\n+        \/**\n+         * Returns a carrier component accessor {@link MethodHandle} for the\n+         * component {@code i}.\n+         *\n+         * @param carrierShape  shape of the carrier object\n+         * @param i             index to the component\n+         *\n+         * @return carrier component accessor {@link MethodHandle}\n+         *\n+         * @throws IllegalArgumentException if number of component slots exceeds\n+         *         maximum\n+         *\/\n+        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle[] components = carrierClass.components;\n+\n+            return reshapeComponent(carrierShape, components, i);\n+        }\n@@ -1044,1 +1120,1 @@\n-     * @return  array of component accessors {@link MethodHandle MethodHandles,}\n+     * @return immutable list of component accessors {@link MethodHandle MethodHandles}\n@@ -1048,3 +1124,0 @@\n-     *\n-     * @implSpec The array returned is guaranteed to be a fresh copy. This allows the\n-     * client can replace elements tailored to their needs without impacting other clients.\n@@ -1052,1 +1125,1 @@\n-    public static MethodHandle[] components(MethodType methodType) {\n+    public static List<MethodHandle> components(MethodType methodType) {\n@@ -1066,0 +1139,28 @@\n+    \/**\n+     * Return a component accessor {@link MethodHandle} for component {@code i}.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     * @param i           component index\n+     *\n+     * @return a component accessor {@link MethodHandle} for component {@code i}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *                                  or if {@code i} is out of bounds\n+     *\/\n+    public static MethodHandle component(MethodType methodType, int i) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape = new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (i < 0 || i >= carrierShape.count()) {\n+            throw new IllegalArgumentException(\"i is out of bounds for parameter types\");\n+        } else if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.component(carrierShape, i);\n+        } else {\n+            return CarrierArrayFactory.component(carrierShape, i);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":117,"deletions":16,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-        MethodHandle[] components = Carrier.components(methodType);\n+        MethodHandle[] components = Carrier.components(methodType).toArray(new MethodHandle[0]);\n+\n@@ -83,0 +84,4 @@\n+\n+        MethodHandle component = Carrier.component(methodType, 8);\n+        assertTrue(\"abcde\".equals((String)component.invokeExact(object)),\n+                \"primitive String test failure\");\n@@ -112,1 +117,1 @@\n-        MethodHandle[] components = Carrier.components(methodType);\n+        MethodHandle[] components = Carrier.components(methodType).toArray(new MethodHandle[0]);\n","filename":"test\/jdk\/java\/lang\/runtime\/CarrierTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}