{"files":[{"patch":"@@ -0,0 +1,1176 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodHandles.Lookup.ClassOption;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * A <em>carrier<\/em> is an opaque object that can be used to store component values\n+ * while avoiding primitive boxing associated with collection objects. Component values\n+ * can be primitive or Object. Clients can create new carrier instances by describing a\n+ * carrier <em>shape<\/em>, that is, a {@linkplain MethodType method type} whose parameter\n+ * types describe the types of the carrier component values.\n+ *\n+ * @implNote The strategy for storing components is deliberately left ambiguous\n+ * so that future improvements will not be hampered by backward compatability\n+ * issues.\n+ *\n+ * @since 19\n+ *\/\n+\n+\/*non-public*\/\n+public final class Carrier {\n+    \/**\n+     * Class file version.\n+     *\/\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+\n+    \/**\n+     * Lookup used to define and reference the carrier object classes.\n+     *\/\n+    private static final Lookup LOOKUP;\n+\n+    \/**\n+     * Maximum number of components in a carrier (based on the maximum\n+     * number of args to a constructor.)\n+     *\/\n+    private static final int MAX_COMPONENTS = 255 - \/* this *\/ 1;\n+\n+    \/**\n+     * Maximum number of components in a CarrierClass.\n+     *\/\n+    private static final int MAX_OBJECT_COMPONENTS = 32;\n+\n+    \/**\n+     * Stable annotation.\n+     *\/\n+    private static final String STABLE = \"jdk\/internal\/vm\/annotation\/Stable\";\n+    private static final String STABLE_SIG = \"L\" + STABLE + \";\";\n+\n+    \/**\n+     * Number of integer slots used by a long.\n+     *\/\n+    private static final int LONG_SLOTS = 2;\n+\n+    \/*\n+     * Initialize {@link MethodHandle} constants.\n+     *\/\n+    static {\n+        LOOKUP = MethodHandles.lookup();\n+\n+        try {\n+            FLOAT_TO_INT = LOOKUP.findStatic(Float.class, \"floatToRawIntBits\",\n+                    methodType(int.class, float.class));\n+            INT_TO_FLOAT = LOOKUP.findStatic(Float.class, \"intBitsToFloat\",\n+                    methodType(float.class, int.class));\n+            DOUBLE_TO_LONG = LOOKUP.findStatic(Double.class, \"doubleToRawLongBits\",\n+                    methodType(long.class, double.class));\n+            LONG_TO_DOUBLE = LOOKUP.findStatic(Double.class, \"longBitsToDouble\",\n+                    methodType(double.class, long.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * float\/double conversions.\n+     *\/\n+    private static final MethodHandle FLOAT_TO_INT;\n+    private static final MethodHandle INT_TO_FLOAT;\n+    private static final MethodHandle DOUBLE_TO_LONG;\n+    private static final MethodHandle LONG_TO_DOUBLE;\n+\n+    \/**\n+     * long signature descriptor.\n+     *\/\n+    private static final String LONG_DESCRIPTOR =\n+            Type.getDescriptor(long.class);\n+\n+    \/**\n+     * int signature descriptor.\n+     *\/\n+    private static final String INT_DESCRIPTOR =\n+            Type.getDescriptor(int.class);\n+\n+    \/**\n+     * Object signature descriptor.\n+     *\/\n+    private static final String OBJECT_DESCRIPTOR =\n+            Type.getDescriptor(Object.class);\n+\n+    \/**\n+     * Given a constructor {@link MethodHandle} recast and reorder arguments to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier shape\n+     * @param constructor   carrier constructor to reshape\n+     *\n+     * @return constructor with arguments recasted and reordered\n+     *\/\n+    private static MethodHandle reshapeConstructor(CarrierShape carrierShape,\n+                                                   MethodHandle constructor) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int[] reorder = new int[count];\n+        Class<?>[] permutePTypes = new Class<?>[count];\n+        MethodHandle[] filters = new MethodHandle[count];\n+        boolean hasFilters = false;\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle filter = null;\n+            int from;\n+\n+            if (!ptype.isPrimitive()) {\n+                from = objectIndex++;\n+                ptype = Object.class;\n+            } else if(ptype == double.class) {\n+                from = longIndex++;\n+                filter = DOUBLE_TO_LONG;\n+            } else if(ptype == float.class) {\n+                from = intIndex++;\n+                filter = FLOAT_TO_INT;\n+            } else if (ptype == long.class) {\n+                from = longIndex++;\n+            } else {\n+                from = intIndex++;\n+                ptype = int.class;\n+            }\n+\n+            permutePTypes[index] = ptype;\n+            reorder[from] = index++;\n+\n+            if (filter != null) {\n+                filters[from] = filter;\n+                hasFilters = true;\n+            }\n+        }\n+\n+        if (hasFilters) {\n+            constructor = MethodHandles.filterArguments(constructor, 0, filters);\n+        }\n+\n+        MethodType permutedMethodType =\n+                methodType(constructor.type().returnType(), permutePTypes);\n+        constructor = MethodHandles.permuteArguments(constructor,\n+                permutedMethodType, reorder);\n+        constructor = MethodHandles.explicitCastArguments(constructor,\n+                methodType(Object.class, ptypes));\n+\n+        return constructor;\n+    }\n+\n+    \/**\n+     * Given components array, recast and reorder components to match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components to reshape\n+     *\n+     * @return components reshaped\n+     *\/\n+    private static MethodHandle[] reshapeComponents(CarrierShape carrierShape,\n+                                                    MethodHandle[] components) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        MethodHandle[] reorder = new MethodHandle[count];\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle component;\n+\n+            if (!ptype.isPrimitive()) {\n+                component = components[objectIndex++];\n+            } else if (ptype == double.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[longIndex++], LONG_TO_DOUBLE);\n+            } else if (ptype == float.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[intIndex++], INT_TO_FLOAT);\n+            } else if (ptype == long.class) {\n+                component = components[longIndex++];\n+            } else {\n+                component = components[intIndex++];\n+            }\n+\n+            MethodType methodType = methodType(ptype, Object.class);\n+            reorder[index++] =\n+                    MethodHandles.explicitCastArguments(component, methodType);\n+        }\n+\n+        return reorder;\n+    }\n+\n+    \/**\n+     * Given components array and index, recast and reorder that component to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components\n+     * @param i             index of component to reshape\n+     *\n+     * @return component reshaped\n+     *\/\n+    private static MethodHandle reshapeComponent(CarrierShape carrierShape,\n+                                                 MethodHandle[] components, int i) {\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        CarrierCounts componentCounts = CarrierCounts.tally(ptypes, i);\n+        Class<?> ptype = ptypes[i];\n+        int index;\n+        MethodHandle filter = null;\n+\n+        if (!ptype.isPrimitive()) {\n+            index = carrierShape.objectOffset() + componentCounts.objectCount();\n+        } else if (ptype == double.class) {\n+            index = carrierShape.longOffset() + componentCounts.longCount();\n+            filter = LONG_TO_DOUBLE;\n+        } else if (ptype == float.class) {\n+            index = carrierShape.intOffset() + componentCounts.intCount();\n+            filter = INT_TO_FLOAT;\n+        } else if (ptype == long.class) {\n+            index = carrierShape.longOffset() + componentCounts.longCount();\n+        } else {\n+            index = carrierShape.intOffset() + componentCounts.intCount();\n+        }\n+\n+        MethodHandle component = components[index];\n+\n+        if (filter != null) {\n+            component = MethodHandles.filterReturnValue(component, filter);\n+        }\n+\n+        component = MethodHandles.explicitCastArguments(component,\n+                methodType(ptype, Object.class));\n+\n+        return component;\n+    }\n+\n+    \/**\n+     * Factory for carriers that are backed by int[] and Object[]. This strategy is\n+     * used when the number of components exceeds {@link Carrier#MAX_OBJECT_COMPONENTS}.\n+     *\/\n+    private static class CarrierArrayFactory {\n+        \/**\n+         * Lookup used to define and reference the carrier array methods.\n+         *\/\n+        private static final MethodHandles.Lookup LOOKUP;\n+\n+        \/**\n+         * Unsafe access.\n+         *\/\n+        private static final Unsafe UNSAFE;\n+\n+        static {\n+            LOOKUP = MethodHandles.lookup();\n+            UNSAFE = Unsafe.getUnsafe();\n+\n+            try {\n+                CONSTRUCTOR = LOOKUP.findConstructor(CarrierArray.class,\n+                        methodType(void.class, int.class, int.class));\n+                GET_LONG = LOOKUP.findVirtual(CarrierArray.class, \"getLong\",\n+                        methodType(long.class, int.class));\n+                PUT_LONG = LOOKUP.findVirtual(CarrierArray.class, \"putLong\",\n+                        methodType(CarrierArray.class, int.class, long.class));\n+                GET_INTEGER = LOOKUP.findVirtual(CarrierArray.class, \"getInteger\",\n+                        methodType(int.class, int.class));\n+                PUT_INTEGER = LOOKUP.findVirtual(CarrierArray.class, \"putInteger\",\n+                        methodType(CarrierArray.class, int.class, int.class));\n+                GET_OBJECT = LOOKUP.findVirtual(CarrierArray.class, \"getObject\",\n+                        methodType(Object.class, int.class));\n+                PUT_OBJECT = LOOKUP.findVirtual(CarrierArray.class, \"putObject\",\n+                        methodType(CarrierArray.class, int.class, Object.class));\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier static init fail\", ex);\n+            }\n+        }\n+\n+        \/*\n+         * Constructor accessor MethodHandles.\n+         *\/\n+        private static final MethodHandle CONSTRUCTOR;\n+        private static final MethodHandle GET_LONG;\n+        private static final MethodHandle PUT_LONG;\n+        private static final MethodHandle GET_INTEGER;\n+        private static final MethodHandle PUT_INTEGER;\n+        private static final MethodHandle GET_OBJECT;\n+        private static final MethodHandle PUT_OBJECT;\n+\n+        \/**\n+         * Wrapper object for carrier arrays. Instances types are stored in the {@code objects}\n+         * array, while primitive types are recast to {@code int\/long} and stored in the\n+         * {@code primitives} array. Primitive byte, short, char, boolean and int are stored as\n+         * integers. Longs and doubles are stored as longs.  Longs take up the first part of the\n+         * primitives array using normal indices. Integers follow using int[] indices offset beyond\n+         * the longs using unsafe getInt\/putInt.\n+         *\/\n+        private static class CarrierArray {\n+            \/**\n+             * Carrier for primitive values.\n+             *\/\n+            private final long[] primitives;\n+\n+            \/**\n+             * Carrier for objects;\n+             *\/\n+            private final Object[] objects;\n+\n+            \/**\n+             * Constructor.\n+             *\n+             * @param primitiveCount  slot count required for primitives\n+             * @param objectCount     slot count required for objects\n+             *\/\n+            CarrierArray(int primitiveCount, int objectCount) {\n+                this.primitives = new long[primitiveCount];\n+                this.objects = new Object[objectCount];\n+            }\n+\n+            \/**\n+             * Check index and compute offset for unsafe access.\n+             *\n+             * @param i  index in primitive[]\n+             *\n+             * @return offset for unsafe access\n+             *\/\n+            private long offset(int i) {\n+                if (i < 0 || primitives.length <= i) {\n+                    throw new RuntimeException(\"primitive index out of range: \" + i);\n+                }\n+\n+                return Unsafe.ARRAY_LONG_BASE_OFFSET +\n+                        (long)i * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            }\n+\n+            \/**\n+             * {@return long value at index}\n+             *\n+             * @param i  array index\n+             *\/\n+            private long getLong(int i) {\n+                return primitives[i];\n+            }\n+\n+            \/**\n+             * Put a long value into the primitive[].\n+             *\n+             * @param i      array index\n+             * @param value  long value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putLong(int i, long value) {\n+                primitives[i] = value;\n+\n+                return this;\n+            }\n+\n+            \/**\n+             * {@return int value at index}\n+             *\n+             * @param i  array index\n+             *\/\n+            private int getInteger(int i) {\n+                return UNSAFE.getInt(primitives, offset(i));\n+            }\n+\n+            \/**\n+             * Put a int value into the int[].\n+             *\n+             * @param i      array index\n+             * @param value  int value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putInteger(int i, int value) {\n+                UNSAFE.putInt(primitives, offset(i), value);\n+\n+                return this;\n+            }\n+\n+            \/**\n+             * {@return Object value at index}\n+             *\n+             * @param i  array index\n+             *\/\n+            private Object getObject(int i) {\n+                return objects[i];\n+            }\n+\n+            \/**\n+             * Put a object value into the objects[].\n+             *\n+             * @param i      array index\n+             * @param value  object value to store\n+             *\n+             * @return this object\n+             *\/\n+            private CarrierArray putObject(int i, Object value) {\n+                objects[i] = value;\n+\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * Constructor\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to generic carrier constructor.\n+         *\/\n+        private static MethodHandle constructor(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int primitiveSlots = longCount * LONG_SLOTS + intCount;\n+\n+            MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,\n+                    0, primitiveSlots, objectCount);\n+\n+            \/\/ long array index\n+            int index = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_LONG, 1, index++);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_INTEGER, 1, index++);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_OBJECT, 1, i);\n+                constructor = MethodHandles.collectArguments(put, 0, constructor);\n+            }\n+\n+            return reshapeConstructor(carrierShape, constructor);\n+        }\n+\n+        \/**\n+         * Utility to construct the basic accessors from the components.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier accessors\n+         *\/\n+        private static MethodHandle[] createComponents(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle[] components =\n+                    new MethodHandle[carrierShape.ptypes().length];\n+\n+            \/\/ long array index\n+            int index = 0;\n+            \/\/ component index\n+            int comIndex = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_LONG, 1, index++);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_INTEGER, 1, index++);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_OBJECT, 1, i);\n+            }\n+            return components;\n+        }\n+\n+        \/**\n+         * Return an array of carrier component accessors, aligning with types in\n+         * {@code ptypes}.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier accessors\n+         *\/\n+        private static MethodHandle[] components(CarrierShape carrierShape) {\n+            MethodHandle[] components = createComponents(carrierShape);\n+\n+            return reshapeComponents(carrierShape, components);\n+        }\n+\n+        \/**\n+         * Return a carrier accessor for component {@code i}.\n+         *\n+         * @param carrierShape  carrier object shape\n+         * @param i             index of parameter to get\n+         *\n+         * @return carrier component {@code i} accessor {@link MethodHandle}\n+         *\/\n+        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+            MethodHandle[] components = createComponents(carrierShape);\n+\n+            return reshapeComponent(carrierShape, components, i);\n+        }\n+    }\n+\n+    \/**\n+     * Factory for object based carrier. This strategy is used when the number of\n+     * components is less than equal {@link Carrier#MAX_OBJECT_COMPONENTS}. The factory\n+     * constructs an anonymous class that provides a shape that  matches the\n+     * number of longs, ints and objects required by the {@link CarrierShape}. The\n+     * factory caches and reuses anonymous classes when looking for a match.\n+     * <p>\n+     * The anonymous class that is constructed contains the number of long fields then\n+     * int fields then object fields required by the {@link CarrierShape}. The order\n+     * of fields is reordered by the component accessor {@link MethodHandles}. So a\n+     * carrier requiring an int and then object will use the same anonymous class as\n+     * a carrier requiring an object then int.\n+     * <p>\n+     * The carrier constructor recasts\/translates values that are not long, int or\n+     * object. The component accessors reverse the effect of the recasts\/translates.\n+     *\/\n+    private static class CarrierObjectFactory {\n+        \/**\n+         * Define the hidden class Lookup object\n+         *\n+         * @param bytes  class content\n+         *\n+         * @return the Lookup object of the hidden class\n+         *\/\n+        private static Lookup defineHiddenClass(byte[] bytes) {\n+            try {\n+                return LOOKUP.defineHiddenClass(bytes, false, ClassOption.STRONG);\n+            } catch (IllegalAccessException ex) {\n+                throw new AssertionError(\"carrier factory static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the name of a long component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of long component\n+         *\/\n+        private static String longFieldName(int index) {\n+            return \"l\" + index;\n+        }\n+\n+        \/**\n+         * Generate the name of an int component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of int component\n+         *\/\n+        private static String intFieldName(int index) {\n+            return \"i\" + index;\n+        }\n+\n+        \/**\n+         * Generate the name of an object component.\n+         *\n+         * @param index field\/component index\n+         *\n+         * @return name of object component\n+         *\/\n+        private static String objectFieldName(int index) {\n+            return \"o\" + index;\n+        }\n+\n+        \/**\n+         * Generate the full name of a carrier class based on shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return name of a carrier class\n+         *\/\n+        private static String carrierClassName(CarrierShape carrierShape) {\n+            String packageName = Carrier.class.getPackageName().replace('.', '\/');\n+            String className = \"Carrier\" +\n+                    longFieldName(carrierShape.longCount()) +\n+                    intFieldName(carrierShape.intCount()) +\n+                    objectFieldName(carrierShape.objectCount());\n+\n+            return packageName.isEmpty() ? className :\n+                    packageName + \"\/\" + className;\n+        }\n+\n+        \/**\n+         * Build up the byte code for the carrier class.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return byte array of byte code for the carrier class\n+         *\/\n+        private static byte[] buildCarrierClass(CarrierShape carrierShape) {\n+            int maxStack = 3;\n+            int maxLocals = 1 \/* this *\/ + carrierShape.slotCount();\n+            String carrierClassName = carrierClassName(carrierShape);\n+            StringBuilder initDescriptor = new StringBuilder(\"(\");\n+\n+            ClassWriter cw = new ClassWriter(0);\n+            cw.visit(CLASSFILE_VERSION, ACC_PRIVATE | ACC_FINAL, carrierClassName,\n+                    null, \"java\/lang\/Object\", null);\n+\n+            int fieldFlags = ACC_PRIVATE | ACC_FINAL;\n+\n+            for (int i = 0; i < carrierShape.longCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, longFieldName(i),\n+                        LONG_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(LONG_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.intCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, intFieldName(i),\n+                        INT_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(INT_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.objectCount(); i++) {\n+                FieldVisitor fw = cw.visitField(fieldFlags, objectFieldName(i),\n+                        OBJECT_DESCRIPTOR, null, null);\n+                fw.visitAnnotation(STABLE_SIG, true);\n+                fw.visitEnd();\n+                initDescriptor.append(OBJECT_DESCRIPTOR);\n+            }\n+\n+            initDescriptor.append(\")V\");\n+\n+            int arg = 1;\n+\n+            MethodVisitor init = cw.visitMethod(ACC_PUBLIC,\n+                    \"<init>\", initDescriptor.toString(), null, null);\n+            init.visitVarInsn(ALOAD, 0);\n+            init.visitMethodInsn(INVOKESPECIAL,\n+                    \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+\n+            for (int i = 0; i < carrierShape.longCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(LLOAD, arg);\n+                arg += LONG_SLOTS;\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        longFieldName(i), LONG_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.intCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(ILOAD, arg++);\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        intFieldName(i), INT_DESCRIPTOR);\n+            }\n+\n+            for (int i = 0; i < carrierShape.objectCount(); i++) {\n+                init.visitVarInsn(ALOAD, 0);\n+                init.visitVarInsn(ALOAD, arg++);\n+                init.visitFieldInsn(PUTFIELD, carrierClassName,\n+                        objectFieldName(i), OBJECT_DESCRIPTOR);\n+            }\n+\n+            init.visitInsn(RETURN);\n+            init.visitMaxs(maxStack, maxLocals);\n+            init.visitEnd();\n+\n+            cw.visitEnd();\n+\n+            return cw.toByteArray();\n+        }\n+\n+        \/**\n+         * Build up a {@link MethodType} based in a carrier shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return the constructor method type\n+         *\/\n+        private static MethodType constructorMethodType(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int count = carrierShape.count();\n+            Class<?>[] ptypes = new Class<?>[count];\n+            int arg = 0;\n+\n+            for(int i = 0; i < longCount; i++) {\n+                ptypes[arg++] = long.class;\n+            }\n+\n+            for(int i = 0; i < intCount; i++) {\n+                ptypes[arg++] = int.class;\n+            }\n+\n+            for(int i = 0; i < objectCount; i++) {\n+                ptypes[arg++] = Object.class;\n+            }\n+\n+            return methodType(void.class, ptypes);\n+        }\n+\n+        \/**\n+         * Returns the raw constructor for the carrier class.\n+         *\n+         * @param carrierClassLookup     lookup for carrier class\n+         * @param carrierClass           newly constructed carrier class\n+         * @param constructorMethodType  constructor method type\n+         *\n+         * @return {@link MethodHandle} to carrier class constructor\n+         *\n+         * @throws ReflectiveOperationException if lookup failure\n+         *\/\n+        private static MethodHandle constructor(Lookup carrierClassLookup,\n+                                                Class<?> carrierClass,\n+                                                MethodType constructorMethodType)\n+                throws ReflectiveOperationException {\n+            return carrierClassLookup.findConstructor(carrierClass,\n+                    constructorMethodType);\n+        }\n+\n+        \/**\n+         * Returns an array of raw component accessors for the carrier class.\n+         *\n+         * @param carrierShape           shape of carrier\n+         * @param carrierClassLookup     lookup for carrier class\n+         * @param carrierClass           newly constructed carrier class\n+         *\n+         * @return {@link MethodHandle MethodHandles} to carrier component\n+         *         accessors\n+         *\n+         * @throws ReflectiveOperationException if lookup failure\n+         *\/\n+        private static MethodHandle[] createComponents(CarrierShape carrierShape,\n+                                                       Lookup carrierClassLookup,\n+                                                       Class<?> carrierClass)\n+                throws ReflectiveOperationException {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int count = carrierShape.count();\n+            MethodHandle[] components = new MethodHandle[count];\n+            int arg = 0;\n+\n+            for(int i = 0; i < longCount; i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        longFieldName(i), long.class);\n+            }\n+\n+            for(int i = 0; i < intCount; i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        intFieldName(i), int.class);\n+            }\n+\n+            for(int i = 0; i < objectCount; i++) {\n+                components[arg++] = carrierClassLookup.findGetter(carrierClass,\n+                        objectFieldName(i), Object.class);\n+            }\n+\n+            return components;\n+        }\n+\n+        \/**\n+         * Construct a new object carrier class based on shape.\n+         *\n+         * @param carrierShape  shape of carrier\n+         *\n+         * @return a {@link CarrierClass} object containing constructor and\n+         *         component accessors.\n+         *\/\n+        private static CarrierClass newCarrierClass(CarrierShape carrierShape) {\n+            byte[] bytes = buildCarrierClass(carrierShape);\n+\n+            try {\n+                Lookup carrierCLassLookup = defineHiddenClass(bytes);\n+                Class<?> carrierClass = carrierCLassLookup.lookupClass();\n+                MethodType constructorMethodType = constructorMethodType(carrierShape);\n+                MethodHandle constructor = constructor(carrierCLassLookup,\n+                        carrierClass, constructorMethodType);\n+                MethodHandle[] components = createComponents(carrierShape,\n+                        carrierCLassLookup, carrierClass);\n+\n+                return new CarrierClass(constructor, components);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier class static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Permute a raw constructor {@link MethodHandle} to match the order and\n+         * types of the parameter types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} constructor matching parameter types\n+         *\/\n+        private static MethodHandle constructor(CarrierShape carrierShape) {\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle constructor = carrierClass.constructor();\n+\n+            return reshapeConstructor(carrierShape, constructor);\n+        }\n+\n+        \/**\n+         * Permute raw component accessors to match order and types of the parameter\n+         * types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of components matching parameter types\n+         *\/\n+        private static MethodHandle[] components(CarrierShape carrierShape) {\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle[] components = carrierClass.components();\n+\n+            return reshapeComponents(carrierShape, components);\n+        }\n+\n+        \/**\n+         * Returns a carrier component accessor {@link MethodHandle} for the\n+         * component {@code i}.\n+         *\n+         * @param carrierShape  shape of the carrier object\n+         * @param i             index to the component\n+         *\n+         * @return carrier component accessor {@link MethodHandle}\n+         *\n+         * @throws IllegalArgumentException if number of component slots exceeds\n+         *         maximum\n+         *\/\n+        private static MethodHandle component(CarrierShape carrierShape, int i) {\n+            CarrierClass carrierClass = findCarrierClass(carrierShape);\n+            MethodHandle[] components = carrierClass.components;\n+\n+            return reshapeComponent(carrierShape, components, i);\n+        }\n+    }\n+\n+    \/**\n+     * Provides raw constructor and component MethodHandles for a constructed\n+     * carrier class.\n+     *\/\n+    private record CarrierClass(\n+            \/*\n+             * A raw {@link MethodHandle} for a carrier object constructor.\n+             * This constructor will only have Object, int and long type arguments.\n+             *\/\n+            MethodHandle constructor,\n+\n+            \/*\n+             * All the raw {@link MethodHandle MethodHandles} for a carrier\n+             * component accessors. These accessors will only return Object, int and\n+             * long types.\n+             *\/\n+            MethodHandle[] components) {\n+    }\n+\n+    \/**\n+     * Cache for all constructed carrier object classes, keyed on class\n+     * name (i.e., carrier shape.)\n+     *\/\n+    private static final ConcurrentHashMap<String, CarrierClass> carrierCache =\n+            new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carrier() {\n+    }\n+\n+    \/**\n+     * Find or create carrier class for a carrier shape.\n+     *\n+     * @param carrierShape  shape of carrier\n+     *\n+     * @return {@link Class<>} of carrier class matching carrier shape\n+     *\/\n+    private static CarrierClass findCarrierClass(CarrierShape carrierShape) {\n+        String carrierClassName =\n+                CarrierObjectFactory.carrierClassName(carrierShape);\n+\n+        return carrierCache.computeIfAbsent(carrierClassName,\n+                cn -> CarrierObjectFactory.newCarrierClass(carrierShape));\n+    }\n+\n+    private record CarrierCounts(int longCount, int intCount, int objectCount) {\n+        \/**\n+         * Count the number of fields required in each of Object, int and long.\n+         *\n+         * @param ptypes  parameter types\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        static CarrierCounts tally(Class<?>[] ptypes) {\n+            return tally(ptypes, ptypes.length);\n+        }\n+\n+        \/**\n+         * Count the number of fields required in each of Object, int and long\n+         * limited to the first {@code n} parameters.\n+         *\n+         * @param ptypes  parameter types\n+         * @param n       number of parameters to check\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        private static CarrierCounts tally(Class<?>[] ptypes, int n) {\n+            int longCount = 0;\n+            int intCount = 0;\n+            int objectCount = 0;\n+\n+            for (int i = 0; i < n; i++) {\n+                Class<?> ptype = ptypes[i];\n+\n+                if (!ptype.isPrimitive()) {\n+                    objectCount++;\n+                } else if (ptype == long.class || ptype == double.class) {\n+                    longCount++;\n+                } else {\n+                    intCount++;\n+                }\n+            }\n+\n+            return new CarrierCounts(longCount, intCount, objectCount);\n+        }\n+\n+        \/**\n+         * {@return total number of components}\n+         *\/\n+        private int count() {\n+            return longCount + intCount + objectCount;\n+        }\n+\n+        \/**\n+         * {@return total number of slots}\n+         *\/\n+        private int slotCount() {\n+            return longCount * LONG_SLOTS + intCount + objectCount;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Shape of carrier based on counts of each of the three fundamental data\n+     * types.\n+     *\/\n+    private static class CarrierShape {\n+        \/**\n+         * {@link MethodType} providing types for the carrier's components.\n+         *\/\n+        private final MethodType methodType;\n+\n+        \/**\n+         * Counts of different parameter types.\n+         *\/\n+        private final CarrierCounts counts;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param methodType  {@link MethodType} providing types for the\n+         *                    carrier's components\n+         *\/\n+        public CarrierShape(MethodType methodType) {\n+            this.methodType = methodType;\n+            this.counts = CarrierCounts.tally(methodType.parameterArray());\n+        }\n+\n+        \/**\n+         * {@return supplied methodType}\n+         *\/\n+        private MethodType methodType() {\n+            return methodType;\n+        }\n+\n+        \/**\n+         * {@return number of long fields needed}\n+         *\/\n+        private int longCount() {\n+            return counts.longCount();\n+        }\n+\n+        \/**\n+         * {@return number of int fields needed}\n+         *\/\n+        private int intCount() {\n+            return counts.intCount();\n+        }\n+\n+        \/**\n+         * {@return number of object fields needed}\n+         *\/\n+        private int objectCount() {\n+            return counts.objectCount();\n+        }\n+\n+        \/**\n+         * {@return array of parameter types}\n+         *\/\n+        private Class<?>[] ptypes() {\n+            return methodType.parameterArray();\n+        }\n+\n+        \/**\n+         * {@return number of components}\n+         *\/\n+        private int count() {\n+            return counts.count();\n+        }\n+\n+        \/**\n+         * {@return number of slots used}\n+         *\/\n+        private int slotCount() {\n+            return counts.slotCount();\n+        }\n+\n+        \/**\n+         * {@return index of first long component}\n+         *\/\n+        private int longOffset() {\n+            return 0;\n+        }\n+\n+        \/**\n+         * {@return index of first int component}\n+         *\/\n+        private int intOffset() {\n+            return longCount();\n+        }\n+\n+        \/**\n+         * {@return index of first object component}\n+         *\/\n+        private int objectOffset() {\n+            return longCount() + intCount();\n+        }\n+    }\n+\n+    \/**\n+     * Return a constructor {@link MethodHandle} for a carrier with components\n+     * aligning with the parameter types of the supplied\n+     * {@link MethodType methodType}.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     *\n+     * @return carrier constructor {@link MethodHandle}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *\/\n+    public static MethodHandle constructor(MethodType methodType) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape = new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.constructor(carrierShape);\n+        } else {\n+            return CarrierArrayFactory.constructor(carrierShape);\n+        }\n+    }\n+\n+    \/**\n+     * Return component accessor {@link MethodHandle MethodHandles} for all the\n+     * carrier's components.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     *\n+     * @return  array of get component {@link MethodHandle MethodHandles,}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *\n+     *\/\n+    public static MethodHandle[] components(MethodType methodType) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape =  new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.components(carrierShape);\n+        } else {\n+            return CarrierArrayFactory.components(carrierShape);\n+        }\n+    }\n+\n+    \/**\n+     * Return a component accessor {@link MethodHandle} for component {@code i}.\n+     *\n+     * @param methodType  {@link MethodType} providing types for the carrier's\n+     *                    components\n+     * @param i           component index\n+     *\n+     * @return a component accessor {@link MethodHandle} for component {@code i}\n+     *\n+     * @throws NullPointerException is any argument is null\n+     * @throws IllegalArgumentException if number of component slots exceeds maximum\n+     *                                  or if {@code i} is out of bounds\n+     *\/\n+    public static MethodHandle component(MethodType methodType, int i) {\n+        Objects.requireNonNull(methodType);\n+        CarrierShape carrierShape = new CarrierShape(methodType);\n+        int slotCount = carrierShape.slotCount();\n+\n+        if (i < 0 || i >= carrierShape.count()) {\n+            throw new IllegalArgumentException(\"i is out of bounds for parameter types\");\n+        } else if (MAX_COMPONENTS < slotCount) {\n+            throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+        } else  if (slotCount <= MAX_OBJECT_COMPONENTS) {\n+            return CarrierObjectFactory.component(carrierShape, i);\n+        } else {\n+            return CarrierArrayFactory.component(carrierShape, i);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carrier.java","additions":1176,"deletions":0,"binary":false,"changes":1176,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the Carrier class.\n+ * @compile CarrierTest.java\n+ * @run main CarrierTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.runtime.Carrier;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class CarrierTest {\n+    public static void main(String[] args) throws Throwable {\n+        primitivesTest();\n+        primitivesTestInArrayCarrier();\n+        limitsTest();\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static final int MAX_COMPONENTS = 254;\n+\n+    static void primitivesTest() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class);\n+        MethodHandle constructor = Carrier.constructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\");\n+        MethodHandle[] components = Carrier.components(methodType);\n+        assertTrue((byte)components[0].invokeExact(object) == (byte)0xFF,\n+                \"primitive byte test failure\");\n+        assertTrue((short)components[1].invokeExact(object) == (short)0xFFFF,\n+                \"primitive short test failure\");\n+        assertTrue((char)components[2].invokeExact(object) == 'C',\n+                \"primitive char test failure\");\n+        assertTrue((int)components[3].invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive int test failure\");\n+        assertTrue((long)components[4].invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive long test failure\");\n+        assertTrue((float)components[5].invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive float test failure\");\n+        assertTrue((double)components[6].invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive double test failure\");\n+        assertTrue((boolean)components[7].invokeExact(object),\n+                \"primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components[8].invokeExact(object)),\n+                \"primitive String test failure\");\n+    }\n+\n+    static void primitivesTestInArrayCarrier() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class\n+                        );\n+        MethodHandle constructor = Carrier.constructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\",\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null\n+                );\n+        MethodHandle[] components = Carrier.components(methodType);\n+        assertTrue((byte)components[0].invokeExact(object) == (byte)0xFF,\n+                \"primitive in array byte test failure\");\n+        assertTrue((short)components[1].invokeExact(object) == (short)0xFFFF,\n+                \"primitive in array short test failure\");\n+        assertTrue((char)components[2].invokeExact(object) == 'C',\n+                \"primitive in array char test failure\");\n+        assertTrue((int)components[3].invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive in array int test failure\");\n+        assertTrue((long)components[4].invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive in array long test failure\");\n+        assertTrue((float)components[5].invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive in array float test failure\");\n+        assertTrue((double)components[6].invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive in array double test failure\");\n+        assertTrue((boolean)components[7].invokeExact(object),\n+                \"primitive in array boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components[8].invokeExact(object)),\n+                \"primitive in array String test failure\");\n+    }\n+\n+    static void limitsTest() {\n+        boolean passed;\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS + 1];\n+            Arrays.fill(ptypes, Object.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carrier.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS \/ 2 + 1];\n+            Arrays.fill(ptypes, long.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carrier.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/CarrierTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}