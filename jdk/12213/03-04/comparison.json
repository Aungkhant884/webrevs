{"files":[{"patch":"@@ -93,0 +93,2 @@\n+  \/\/ internal template function(Node* node, Node**& ptr) -> bool\n+  \/\/ If it returns true, node is deleted.\n@@ -94,1 +96,1 @@\n-  void unlink_impl(Function function) { \/\/ lambda enabled API\n+  void unlink_impl(Function function) {\n@@ -295,0 +297,16 @@\n+  \/\/ function is a callable(lambda or functor) with the same signature of ITER::do_entry() above.\n+  template <class Function>\n+  void unlink(Function function) { \/\/ lambda enabled API\n+    auto wrapper = [&](Node* const node, Node**& ptr) {\n+      bool clean = function(node->_key, node->_value);\n+      if (clean) {\n+        *ptr = node->_next;\n+      } else {\n+        ptr = &(node->_next);\n+      }\n+      return clean;\n+    };\n+\n+    unlink_impl(wrapper);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -263,0 +263,6 @@\n+      rh.unlink([&](K const& key, V const& val) {\n+        return ((uintptr_t)key % 2) == 0; \/\/ delete all even keys\n+      });\n+      ASSERT_FALSE(rh.get(as_K(6)));\n+      ASSERT_TRUE(rh.get(as_K(7)));\n+\n@@ -339,0 +345,11 @@\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_delete_lambda) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  _simple_test_table.unlink([&](SymbolHandle& key, int value) { return true; });\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n@@ -468,0 +485,20 @@\n+TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr_lambda) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n+    \/\/ handle the refcounting.\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  _ptr_test_table.unlink([&](auto key, auto value) {\n+    delete value;\n+    return true;\n+  });\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}