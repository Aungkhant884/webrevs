{"files":[{"patch":"@@ -93,0 +93,29 @@\n+  template<typename Function>\n+  void unlink_impl(Function function) { \/\/ lambda enabled API\n+    const unsigned sz = table_size();\n+    int cnt = _number_of_entries;\n+\n+    for (unsigned index = 0; cnt > 0 && index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      Node* node = *ptr;\n+\n+      while (node != nullptr) {\n+        bool clean = function(node, ptr);\n+\n+        if (clean) {\n+          Node* prev = node;\n+          node = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete prev;\n+          }\n+          _number_of_entries--;\n+        } else {\n+          node = node->_next;\n+        }\n+\n+        --cnt;\n+        assert(cnt > 0 || node == nullptr, \"sanity check\");\n+      }\n+    }\n+  }\n+\n@@ -101,1 +130,4 @@\n-      unlink_all();\n+      auto wrapper = [&](Node* const node, Node** ptr) {\n+        return true;\n+      };\n+      unlink_impl(wrapper);\n@@ -250,21 +282,6 @@\n-    const unsigned sz = table_size();\n-    int cnt = _number_of_entries;\n-\n-    for (unsigned index = 0; cnt > 0 && index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        \/\/ do_entry must clean up the key and value in Node.\n-        bool clean = iter->do_entry(node->_key, node->_value);\n-\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          }\n-          _number_of_entries--;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n-        if (--cnt <= 0) return;\n+    auto wrapper = [&](Node* const node, Node**& ptr) {\n+      bool clean = iter->do_entry(node->_key, node->_value);\n+      if (clean) {\n+        *ptr = node->_next;\n+      } else {\n+        ptr = &(node->_next);\n@@ -272,1 +289,4 @@\n-    }\n+      return clean;\n+    };\n+\n+    unlink_impl(wrapper);\n@@ -278,19 +298,4 @@\n-    Node** bucket = table();\n-    const unsigned sz = table_size();\n-\n-    while (_number_of_entries > 0 && bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      int n = 0;\n-\n-      while (node != NULL) {\n-        Node* cur = node;\n-        node = node->_next;\n-        if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-          delete cur;\n-        }\n-        n++;\n-      }\n-\n-      if (n > 0) {\n-        *bucket = nullptr;\n-        _number_of_entries -= n;\n+    auto wrapper = [&](Node* const node, Node** ptr) {\n+      if (node->_next == nullptr) {\n+        \/\/ nullify the bucket when reach the end of linked list.\n+        *ptr = nullptr;\n@@ -298,2 +303,0 @@\n-      bucket++;\n-    }\n@@ -301,0 +304,3 @@\n+      return true;\n+    };\n+    unlink_impl(wrapper);\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":50,"deletions":44,"binary":false,"changes":94,"status":"modified"}]}