{"files":[{"patch":"@@ -101,11 +101,1 @@\n-      Node* const* bucket = table();\n-      const unsigned sz = table_size();\n-      while (bucket < bucket_at(sz)) {\n-        Node* node = *bucket;\n-        while (node != nullptr) {\n-          Node* cur = node;\n-          node = node->_next;\n-          delete cur;\n-        }\n-        ++bucket;\n-      }\n+      unlink_all();\n@@ -261,1 +251,3 @@\n-    for (unsigned index = 0; index < sz; index++) {\n+    int cnt = _number_of_entries;\n+\n+    for (unsigned index = 0; cnt > 0 && index < sz; index++) {\n@@ -263,0 +255,1 @@\n+\n@@ -267,0 +260,1 @@\n+\n@@ -272,1 +266,1 @@\n-          _number_of_entries --;\n+          _number_of_entries--;\n@@ -276,0 +270,1 @@\n+        if (--cnt <= 0) return;\n@@ -280,0 +275,29 @@\n+  \/\/ unlink_all() is a specialized version of unlink() when we decide to remove all elements.\n+  \/\/ It can not replace unlink(ITER* iter) if user-provided iter releases key\/value\n+  void unlink_all() {\n+    Node** bucket = table();\n+    const unsigned sz = table_size();\n+\n+    while (_number_of_entries > 0 && bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      int n = 0;\n+\n+      while (node != NULL) {\n+        Node* cur = node;\n+        node = node->_next;\n+        if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+          delete cur;\n+        }\n+        n++;\n+      }\n+\n+      if (n > 0) {\n+        *bucket = nullptr;\n+        _number_of_entries -= n;\n+      }\n+      bucket++;\n+    }\n+\n+    assert(_number_of_entries == 0, \"sanity check\");\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-\n+      rh.unlink_all();\n@@ -262,0 +262,6 @@\n+\n+      rh.unlink_all();\n+      for (uintptr_t i = 10; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_FALSE(rh.get(as_K(index)));\n+      }\n@@ -333,0 +339,12 @@\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simle_unlink_all) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink_all to remove the matching (or all) values from the table.\n+  _simple_test_table.unlink_all();\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n@@ -415,0 +433,15 @@\n+TEST_VM_F(ResourceHashtableDeleteTest, value_unlink_all) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  _test_table.unlink_all();\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"}]}