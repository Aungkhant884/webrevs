{"files":[{"patch":"@@ -75,12 +75,1 @@\n-  struct RemoveAll {\n-    bool do_entry(const JvmtiTagMapKey& entry, const jlong& tag) {\n-      return true;\n-    }\n-  } remove_all;\n-  \/\/ The unlink method of ResourceHashTable gets a pointer to a type whose 'do_entry(K,V)' method is callled\n-  \/\/ while iterating over all the elements of the table. If the do_entry() method returns true the element\n-  \/\/ will be removed.\n-  \/\/ In this case, we always return true from do_entry to clear all the elements.\n-  _table.unlink(&remove_all);\n-\n-  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n+  _table.unlink_all();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -93,0 +93,29 @@\n+  template<typename Function>\n+  void unlink_impl(Function function) { \/\/ lambda enabled API\n+    const unsigned sz = table_size();\n+    int cnt = _number_of_entries;\n+\n+    for (unsigned index = 0; cnt > 0 && index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      Node* node = *ptr;\n+\n+      while (node != nullptr) {\n+        bool clean = function(node, ptr);\n+\n+        if (clean) {\n+          Node* prev = node;\n+          node = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete prev;\n+          }\n+          _number_of_entries--;\n+        } else {\n+          node = node->_next;\n+        }\n+\n+        --cnt;\n+        assert(cnt > 0 || node == nullptr, \"sanity check\");\n+      }\n+    }\n+  }\n+\n@@ -101,11 +130,4 @@\n-      Node* const* bucket = table();\n-      const unsigned sz = table_size();\n-      while (bucket < bucket_at(sz)) {\n-        Node* node = *bucket;\n-        while (node != nullptr) {\n-          Node* cur = node;\n-          node = node->_next;\n-          delete cur;\n-        }\n-        ++bucket;\n-      }\n+      auto wrapper = [&](Node* const node, Node** ptr) {\n+        return true;\n+      };\n+      unlink_impl(wrapper);\n@@ -260,16 +282,6 @@\n-    const unsigned sz = table_size();\n-    for (unsigned index = 0; index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        \/\/ do_entry must clean up the key and value in Node.\n-        bool clean = iter->do_entry(node->_key, node->_value);\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          }\n-          _number_of_entries --;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n+    auto wrapper = [&](Node* const node, Node**& ptr) {\n+      bool clean = iter->do_entry(node->_key, node->_value);\n+      if (clean) {\n+        *ptr = node->_next;\n+      } else {\n+        ptr = &(node->_next);\n@@ -277,1 +289,19 @@\n-    }\n+      return clean;\n+    };\n+\n+    unlink_impl(wrapper);\n+  }\n+\n+  \/\/ unlink_all() is a specialized version of unlink() when we decide to remove all elements.\n+  \/\/ It can not replace unlink(ITER* iter) if user-provided iter releases key\/value\n+  void unlink_all() {\n+    auto wrapper = [&](Node* const node, Node** ptr) {\n+      if (node->_next == nullptr) {\n+        \/\/ nullify the bucket when reach the end of linked list.\n+        *ptr = nullptr;\n+      }\n+\n+      return true;\n+    };\n+    unlink_impl(wrapper);\n+    assert(_number_of_entries == 0, \"sanity check\");\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":58,"deletions":28,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-\n+      rh.unlink_all();\n@@ -262,0 +262,6 @@\n+\n+      rh.unlink_all();\n+      for (uintptr_t i = 10; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_FALSE(rh.get(as_K(index)));\n+      }\n@@ -333,0 +339,12 @@\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_unlink_all) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink_all to remove the matching (or all) values from the table.\n+  _simple_test_table.unlink_all();\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n@@ -415,0 +433,15 @@\n+TEST_VM_F(ResourceHashtableDeleteTest, value_unlink_all) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  _test_table.unlink_all();\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"}]}