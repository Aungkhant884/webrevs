{"files":[{"patch":"@@ -5417,1 +5417,1 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1\n+\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n@@ -5430,0 +5430,13 @@\n+   \/\/\n+   \/\/@IntrinsicCandidate\n+   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n+   \/\/    byte[] da, int dp, int len) {\n+   \/\/  int i = 0;\n+   \/\/  for (; i < len; i++) {\n+   \/\/    char c = sa[sp++];\n+   \/\/    if (c >= '\\u0080')\n+   \/\/      break;\n+   \/\/    da[dp++] = (byte)c;\n+   \/\/  }\n+   \/\/  return i;\n+   \/\/}\n@@ -5433,1 +5446,1 @@\n-  Register tmp5, Register result) {\n+  Register tmp5, Register result, bool ascii) {\n@@ -5444,0 +5457,3 @@\n+  int mask = ascii ? 0xff80ff80 : 0xff00ff00;\n+  int short_mask = ascii ? 0xff80 : 0xff00;\n+\n@@ -5463,1 +5479,1 @@\n-      movl(tmp5, 0xff00ff00);   \/\/ create mask to test for Unicode chars in vector\n+      movl(tmp5, mask);   \/\/ create mask to test for Unicode or non-ASCII chars in vector\n@@ -5472,1 +5488,1 @@\n-      vptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode chars in  vector\n+      vptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode or non-ASCII chars in vector\n@@ -5487,1 +5503,1 @@\n-      movl(tmp5, 0xff00ff00);   \/\/ create mask to test for Unicode chars in vector\n+      movl(tmp5, mask);   \/\/ create mask to test for Unicode or non-ASCII chars in vector\n@@ -5511,1 +5527,1 @@\n-      ptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode chars in  vector\n+      ptest(tmp2Reg, tmp1Reg);       \/\/ check for Unicode or non-ASCII chars in vector\n@@ -5549,1 +5565,1 @@\n-  testl(tmp5, 0xff00);      \/\/ check if Unicode char\n+  testl(tmp5, short_mask);      \/\/ check if Unicode or non-ASCII char\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1727,1 +1727,1 @@\n-                        XMMRegister tmp4, Register tmp5, Register result);\n+                        XMMRegister tmp4, Register tmp5, Register result, bool ascii);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12202,0 +12202,1 @@\n+  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n@@ -12209,1 +12210,1 @@\n-                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);\n+                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, false);\n@@ -12214,0 +12215,16 @@\n+\/\/ encode char[] to byte[] in ASCII\n+instruct encode_ascii_array(eSIRegP src, eDIRegP dst, eDXRegI len,\n+                          regD tmp1, regD tmp2, regD tmp3, regD tmp4,\n+                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"Encode array $src,$dst,$len -> $result    \/\/ KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI \" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, true);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -11773,0 +11773,1 @@\n+  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n@@ -11780,1 +11781,18 @@\n-                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);\n+                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ encode char[] to byte[] in ASCII\n+instruct encode_ascii_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n+                            legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,\n+                            rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"Encode array $src,$dst,$len -> $result    \/\/ KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI \" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, true);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -508,0 +508,1 @@\n+  case vmIntrinsics::_encodeAsciiArray:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+  do_intrinsic(_encodeAsciiArray,       java_lang_StringCoding, encodeAsciiArray_name, encodeISOArray_signature, F_S)   \\\n+   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -219,0 +219,4 @@\n+  case vmIntrinsics::_encodeAsciiArray:\n+#if !defined(X86)\n+    return false; \/\/ not yet implemented\n+#endif\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+  bool ascii;\n@@ -174,1 +175,4 @@\n-  EncodeISOArrayNode(Node* control, Node* arymem, Node* s1, Node* s2, Node* c): Node(control, arymem, s1, s2, c) {};\n+  EncodeISOArrayNode(Node* control, Node* arymem, Node* s1, Node* s2, Node* c, bool ascii):\n+    Node(control, arymem, s1, s2, c), ascii(ascii) {\n+    };\n+  bool is_ascii() { return ascii; }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -594,1 +594,3 @@\n-    return inline_encodeISOArray();\n+    return inline_encodeISOArray(false);\n+  case vmIntrinsics::_encodeAsciiArray:\n+    return inline_encodeISOArray(true);\n@@ -4885,2 +4887,2 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1\n-bool LibraryCallKit::inline_encodeISOArray() {\n+\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n+bool LibraryCallKit::inline_encodeISOArray(bool ascii) {\n@@ -4921,1 +4923,1 @@\n-  Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length);\n+  Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length, ascii);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-  bool inline_encodeISOArray();\n+  bool inline_encodeISOArray(bool ascii);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-                                          byte[] da, int dp, int len) {\n+                                         byte[] da, int dp, int len) {\n@@ -60,0 +60,14 @@\n+    @IntrinsicCandidate\n+    public static int implEncodeAsciiArray(char[] sa, int sp,\n+                                           byte[] da, int dp, int len)\n+    {\n+        int i = 0;\n+        for (; i < len; i++) {\n+            char c = sa[sp++];\n+            if (c >= '\\u0080')\n+                break;\n+            da[dp++] = (byte)c;\n+        }\n+        return i;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2422,0 +2422,4 @@\n+            public int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -359,0 +359,9 @@\n+    \/**\n+     * Encodes ASCII codepoints as possible from the source array into\n+     * the destination byte array, assuming that the encoding is ASCII\n+     * compatible\n+     *\n+     * @return the number of bytes successfully encoded, or 0 if none\n+     *\/\n+    int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -82,2 +84,0 @@\n-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n@@ -437,1 +437,0 @@\n-        private char[] c2;\n@@ -448,1 +447,0 @@\n-            int dlASCII = dp + Math.min(sl - sp, dl - dp);\n@@ -450,3 +448,5 @@\n-            \/\/ ASCII only loop\n-            while (dp < dlASCII && sa[sp] < '\\u0080')\n-                da[dp++] = (byte) sa[sp++];\n+            \/\/ Handle ASCII-only prefix\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            sp += n;\n+            dp += n;\n+\n@@ -552,1 +552,0 @@\n-            int dlASCII = dp + Math.min(len, da.length);\n@@ -554,3 +553,4 @@\n-            \/\/ ASCII only optimized loop\n-            while (dp < dlASCII && sa[sp] < '\\u0080')\n-                da[dp++] = (byte) sa[sp++];\n+            \/\/ Handle ASCII-only prefix\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n+            sp += n;\n+            dp += n;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -55,2 +57,0 @@\n-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n@@ -217,1 +217,1 @@\n-            int len  = Math.min(dl - dp, sl - sp);\n+            int len = Math.min(dl - dp, sl - sp);\n@@ -219,0 +219,6 @@\n+            if (isASCIICompatible) {\n+                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n+                sp += n;\n+                dp += n;\n+                len -= n;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    private static class Decoder extends CharsetDecoder {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -66,1 +66,1 @@\n-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static class Decoder extends CharsetDecoder {\n@@ -162,0 +162,4 @@\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            sp += n;\n+            dp += n;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private static class Decoder extends CharsetDecoder {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -88,1 +88,1 @@\n-        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static class Decoder extends CharsetDecoder {\n@@ -446,2 +446,1 @@\n-                                            ByteBuffer dst)\n-        {\n+                                            ByteBuffer dst) {\n@@ -455,1 +454,0 @@\n-            int dlASCII = dp + Math.min(sl - sp, dl - dp);\n@@ -457,3 +455,15 @@\n-            \/\/ ASCII only loop\n-            while (dp < dlASCII && sa[sp] < '\\u0080')\n-                da[dp++] = (byte) sa[sp++];\n+            \/\/ Handle ASCII-only prefix\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            sp += n;\n+            dp += n;\n+\n+            if (sp < sl) {\n+                return encodeArrayLoopSlow(src, sa, sp, sl, dst, da, dp, dl);\n+            } else {\n+                updatePositions(src, sp, dst, dp);\n+                return CoderResult.UNDERFLOW;\n+            }\n+        }\n+\n+        private CoderResult encodeArrayLoopSlow(CharBuffer src, char[] sa, int sp, int sl,\n+                                                ByteBuffer dst, byte[] da, int dp, int dl) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,346 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key randomness\n- * @bug 6896617\n- * @summary Optimize sun.nio.cs.ISO_8859_1$Encode.encodeArrayLoop() with SSE instructions on x86\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/sun.nio.cs\n- *          java.management\n- *\n- * @ignore 8193479\n- * @run main\/othervm\/timeout=1200 -Xbatch -Xmx256m compiler.codegen.Test6896617\n- *\/\n-\n-package compiler.codegen;\n-\n-import jdk.test.lib.Utils;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n-import java.nio.charset.Charset;\n-import java.nio.charset.CharsetDecoder;\n-import java.nio.charset.CharsetEncoder;\n-import java.nio.charset.CodingErrorAction;\n-import java.util.Arrays;\n-import java.util.Random;\n-\n-public class Test6896617 {\n-    final static int SIZE = 256;\n-\n-    public static void main(String[] args) {\n-        String csn = \"ISO-8859-1\";\n-        Charset cs = Charset.forName(csn);\n-        CharsetEncoder enc = cs.newEncoder();\n-        enc.onMalformedInput(CodingErrorAction.REPLACE)\n-           .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-        CharsetDecoder dec = cs.newDecoder();\n-        dec.onMalformedInput(CodingErrorAction.REPLACE)\n-           .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-\n-        byte repl = (byte)'?';\n-        enc.replaceWith(new byte[] { repl });\n-\n-        \/\/ Use internal API for tests.\n-        sun.nio.cs.ArrayEncoder arrenc = (sun.nio.cs.ArrayEncoder)enc;\n-        sun.nio.cs.ArrayDecoder arrdec = (sun.nio.cs.ArrayDecoder)dec;\n-\n-        \/\/ Populate char[] with chars which can be encoded by ISO_8859_1 (<= 0xFF)\n-        Random rnd = Utils.getRandomInstance();\n-        int maxchar = 0xFF;\n-        char[] a = new char[SIZE];\n-        byte[] b = new byte[SIZE];\n-        char[] at = new char[SIZE];\n-        byte[] bt = new byte[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            char c = (char) rnd.nextInt(maxchar);\n-            if (!enc.canEncode(c)) {\n-                System.out.printf(\"Something wrong: can't encode c=%03x\\n\", (int)c);\n-                System.exit(97);\n-            }\n-            a[i] = c;\n-            b[i] = (byte)c;\n-            at[i] = (char)-1;\n-            bt[i] = (byte)-1;\n-        }\n-        if (arrenc.encode(a, 0, SIZE, bt) != SIZE || !Arrays.equals(b, bt)) {\n-            System.out.println(\"Something wrong: ArrayEncoder.encode failed\");\n-            System.exit(97);\n-        }\n-        if (arrdec.decode(b, 0, SIZE, at) != SIZE || !Arrays.equals(a, at)) {\n-            System.out.println(\"Something wrong: ArrayDecoder.decode failed\");\n-            System.exit(97);\n-        }\n-        for (int i = 0; i < SIZE; i++) {\n-            at[i] = (char)-1;\n-            bt[i] = (byte)-1;\n-        }\n-\n-        ByteBuffer bb  = ByteBuffer.wrap(b);\n-        CharBuffer ba  = CharBuffer.wrap(a);\n-        ByteBuffer bbt = ByteBuffer.wrap(bt);\n-        CharBuffer bat = CharBuffer.wrap(at);\n-        if (!enc.encode(ba, bbt, true).isUnderflow() || !Arrays.equals(b, bt)) {\n-            System.out.println(\"Something wrong: Encoder.encode failed\");\n-            System.exit(97);\n-        }\n-        if (!dec.decode(bb, bat, true).isUnderflow() || !Arrays.equals(a, at)) {\n-            System.out.println(\"Something wrong: Decoder.decode failed\");\n-            System.exit(97);\n-        }\n-        for (int i = 0; i < SIZE; i++) {\n-            at[i] = (char)-1;\n-            bt[i] = (byte)-1;\n-        }\n-\n-        \/\/ Warm up\n-        boolean failed = false;\n-        int result = 0;\n-        for (int i = 0; i < 10000; i++) {\n-            result += arrenc.encode(a, 0, SIZE, bt);\n-            result -= arrdec.decode(b, 0, SIZE, at);\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            result += arrenc.encode(a, 0, SIZE, bt);\n-            result -= arrdec.decode(b, 0, SIZE, at);\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            result += arrenc.encode(a, 0, SIZE, bt);\n-            result -= arrdec.decode(b, 0, SIZE, at);\n-        }\n-        if (result != 0 || !Arrays.equals(b, bt) || !Arrays.equals(a, at)) {\n-            failed = true;\n-            System.out.println(\"Failed: ArrayEncoder.encode char[\" + SIZE + \"] and ArrayDecoder.decode byte[\" + SIZE + \"]\");\n-        }\n-        for (int i = 0; i < SIZE; i++) {\n-            at[i] = (char)-1;\n-            bt[i] = (byte)-1;\n-        }\n-\n-        boolean is_underflow = true;\n-        for (int i = 0; i < 10000; i++) {\n-            ba.clear(); bb.clear(); bat.clear(); bbt.clear();\n-            boolean enc_res = enc.encode(ba, bbt, true).isUnderflow();\n-            boolean dec_res = dec.decode(bb, bat, true).isUnderflow();\n-            is_underflow = is_underflow && enc_res && dec_res;\n-        }\n-        for (int i = 0; i < SIZE; i++) {\n-            at[i] = (char)-1;\n-            bt[i] = (byte)-1;\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            ba.clear(); bb.clear(); bat.clear(); bbt.clear();\n-            boolean enc_res = enc.encode(ba, bbt, true).isUnderflow();\n-            boolean dec_res = dec.decode(bb, bat, true).isUnderflow();\n-            is_underflow = is_underflow && enc_res && dec_res;\n-        }\n-        for (int i = 0; i < SIZE; i++) {\n-            at[i] = (char)-1;\n-            bt[i] = (byte)-1;\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            ba.clear(); bb.clear(); bat.clear(); bbt.clear();\n-            boolean enc_res = enc.encode(ba, bbt, true).isUnderflow();\n-            boolean dec_res = dec.decode(bb, bat, true).isUnderflow();\n-            is_underflow = is_underflow && enc_res && dec_res;\n-        }\n-        if (!is_underflow || !Arrays.equals(b, bt) || !Arrays.equals(a, at)) {\n-            failed = true;\n-            System.out.println(\"Failed: Encoder.encode char[\" + SIZE + \"] and Decoder.decode byte[\" + SIZE + \"]\");\n-        }\n-\n-        \/\/ Test encoder with different source and destination sizes\n-        System.out.println(\"Testing different source and destination sizes\");\n-        for (int i = 1; i <= SIZE; i++) {\n-            for (int j = 1; j <= SIZE; j++) {\n-                bt = new byte[j];\n-                \/\/ very source's SIZE\n-                result = arrenc.encode(a, 0, i, bt);\n-                int l = Math.min(i, j);\n-                if (result != l) {\n-                    failed = true;\n-                    System.out.println(\"Failed: encode char[\" + i + \"] to byte[\" + j + \"]: result = \" + result + \", expected \" + l);\n-                }\n-                for (int k = 0; k < l; k++) {\n-                    if (bt[k] != b[k]) {\n-                        failed = true;\n-                        System.out.println(\"Failed: encoded byte[\" + k + \"] (\" + bt[k] + \") != \" + b[k]);\n-                    }\n-                }\n-                \/\/ very source's offset\n-                int sz = SIZE - i + 1;\n-                result = arrenc.encode(a, i-1, sz, bt);\n-                l = Math.min(sz, j);\n-                if (result != l) {\n-                    failed = true;\n-                    System.out.println(\"Failed: encode char[\" + sz + \"] to byte[\" + j + \"]: result = \" + result + \", expected \" + l);\n-                }\n-                for (int k = 0; k < l; k++) {\n-                    if (bt[k] != b[i+k-1]) {\n-                        failed = true;\n-                        System.out.println(\"Failed: encoded byte[\" + k + \"] (\" + bt[k] + \") != \" + b[i+k-1]);\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Test encoder with char > 0xFF\n-        System.out.println(\"Testing big char\");\n-\n-        byte orig = (byte)'A';\n-        bt = new byte[SIZE];\n-        for (int i = 1; i <= SIZE; i++) {\n-            for (int j = 0; j < i; j++) {\n-                a[j] += 0x100;\n-                \/\/ make sure to replace a different byte\n-                bt[j] = orig;\n-                result = arrenc.encode(a, 0, i, bt);\n-                if (result != i) {\n-                    failed = true;\n-                    System.out.println(\"Failed: encode char[\" + i + \"] to byte[\" + i + \"]: result = \" + result + \", expected \" + i);\n-                }\n-                if (bt[j] != repl) {\n-                    failed = true;\n-                    System.out.println(\"Failed: encoded replace byte[\" + j + \"] (\" + bt[j] + \") != \" + repl);\n-                }\n-                bt[j] = b[j]; \/\/ Restore to compare whole array\n-                for (int k = 0; k < i; k++) {\n-                    if (bt[k] != b[k]) {\n-                        failed = true;\n-                        System.out.println(\"Failed: encoded byte[\" + k + \"] (\" + bt[k] + \") != \" + b[k]);\n-                    }\n-                }\n-                a[j] -= 0x100; \/\/ Restore\n-            }\n-        }\n-\n-        \/\/ Test sun.nio.cs.ISO_8859_1$Encode.encodeArrayLoop() performance.\n-\n-        int itrs = Integer.getInteger(\"iterations\", 1000000);\n-        int size = Integer.getInteger(\"size\", 256);\n-        a  = new char[size];\n-        b  = new byte[size];\n-        bt = new byte[size];\n-        for (int i = 0; i < size; i++) {\n-            char c = (char) rnd.nextInt(maxchar);\n-            if (!enc.canEncode(c)) {\n-                System.out.printf(\"Something wrong: can't encode c=%03x\\n\", (int)c);\n-                System.exit(97);\n-            }\n-            a[i] = c;\n-            b[i]  = (byte)-1;\n-            bt[i] = (byte)c;\n-        }\n-        ba = CharBuffer.wrap(a);\n-        bb = ByteBuffer.wrap(b);\n-        boolean enc_res = enc.encode(ba, bb, true).isUnderflow();\n-        if (!enc_res || !Arrays.equals(b, bt)) {\n-            failed = true;\n-            System.out.println(\"Failed 1: Encoder.encode char[\" + size + \"]\");\n-        }\n-        for (int i = 0; i < size; i++) {\n-            b[i] = (byte)-1;\n-        }\n-\n-        \/\/ Make sure to recompile method if needed before performance run.\n-        for (int i = 0; i < 10000; i++) {\n-            ba.clear(); bb.clear();\n-            enc_res = enc_res && enc.encode(ba, bb, true).isUnderflow();\n-        }\n-        for (int i = 0; i < size; i++) {\n-            b[i] = (byte)-1;\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            ba.clear(); bb.clear();\n-            enc_res = enc_res && enc.encode(ba, bb, true).isUnderflow();\n-        }\n-        if (!enc_res || !Arrays.equals(b, bt)) {\n-            failed = true;\n-            System.out.println(\"Failed 2: Encoder.encode char[\" + size + \"]\");\n-        }\n-        for (int i = 0; i < size; i++) {\n-            b[i] = (byte)-1;\n-        }\n-\n-        System.out.println(\"Testing ISO_8859_1$Encode.encodeArrayLoop() performance\");\n-        long start = System.currentTimeMillis();\n-        for (int i = 0; i < itrs; i++) {\n-            ba.clear(); bb.clear();\n-            enc_res = enc_res && enc.encode(ba, bb, true).isUnderflow();\n-        }\n-        long end = System.currentTimeMillis();\n-        if (!enc_res || !Arrays.equals(b, bt)) {\n-            failed = true;\n-            System.out.println(\"Failed 3: Encoder.encode char[\" + size + \"]\");\n-        } else {\n-            System.out.println(\"size: \" + size + \" time: \" + (end - start));\n-        }\n-\n-        \/\/ Test sun.nio.cs.ISO_8859_1$Encode.encode() performance.\n-\n-        \/\/ Make sure to recompile method if needed before performance run.\n-        result = 0;\n-        for (int i = 0; i < size; i++) {\n-            b[i] = (byte)-1;\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            result += arrenc.encode(a, 0, size, b);\n-        }\n-        for (int i = 0; i < size; i++) {\n-            b[i] = (byte)-1;\n-        }\n-        for (int i = 0; i < 10000; i++) {\n-            result += arrenc.encode(a, 0, size, b);\n-        }\n-        if (result != size*20000 || !Arrays.equals(b, bt)) {\n-            failed = true;\n-            System.out.println(\"Failed 1: ArrayEncoder.encode char[\" + SIZE + \"]\");\n-        }\n-        for (int i = 0; i < size; i++) {\n-            b[i] = (byte)-1;\n-        }\n-\n-        System.out.println(\"Testing ISO_8859_1$Encode.encode() performance\");\n-        result = 0;\n-        start = System.currentTimeMillis();\n-        for (int i = 0; i < itrs; i++) {\n-            result += arrenc.encode(a, 0, size, b);\n-        }\n-        end = System.currentTimeMillis();\n-        if (!Arrays.equals(b, bt)) {\n-            failed = true;\n-            System.out.println(\"Failed 2: ArrayEncoder.encode char[\" + size + \"]\");\n-        } else {\n-            System.out.println(\"size: \" + size + \" time: \" + (end - start));\n-        }\n-\n-        if (failed) {\n-          System.out.println(\"FAILED\");\n-          System.exit(97);\n-        }\n-        System.out.println(\"PASSED\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/Test6896617.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"deleted"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 6896617 8274242\n+ * @summary Verify potentially intrinsified encoders behave well before and after compilation\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/timeout=1200 --add-opens=java.base\/sun.nio.cs=ALL-UNNAMED -Xbatch -Xmx256m compiler.intrinsics.string.TestEncodeIntrinsics\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Method;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CodingErrorAction;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+public class TestEncodeIntrinsics {\n+    final static int SIZE = 256;\n+\n+    public static void main(String[] args) {\n+\n+        test(\"ISO-8859-1\", false);\n+        test(\"UTF-8\", true);\n+        test(\"US-ASCII\", true);\n+        test(\"CESU-8\", true);\n+    }\n+\n+    private static void test(String csn, boolean asciiOnly) {\n+        try {\n+            System.out.println(\"Testing \" + csn);\n+            Charset cs = Charset.forName(csn);\n+            CharsetEncoder enc = cs.newEncoder();\n+            enc.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            CharsetDecoder dec = cs.newDecoder();\n+            dec.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+\n+            byte repl = (byte) '?';\n+            enc.replaceWith(new byte[]{repl});\n+\n+            \/\/ Populate char[] with chars which can be encoded by ISO_8859_1 (<= 0xFF)\n+            Random rnd = Utils.getRandomInstance();\n+            int maxchar = asciiOnly ? 0x7F : 0xFF;\n+            char[] a = new char[SIZE];\n+            byte[] b = new byte[SIZE];\n+            char[] at = new char[SIZE];\n+            byte[] bt = new byte[SIZE];\n+            for (int i = 0; i < SIZE; i++) {\n+                char c = (char) rnd.nextInt(maxchar);\n+                if (!enc.canEncode(c)) {\n+                    System.out.printf(\"Something wrong: can't encode c=%03x\\n\", (int) c);\n+                    System.exit(97);\n+                }\n+                a[i] = c;\n+                b[i] = (byte) c;\n+                at[i] = (char) -1;\n+                bt[i] = (byte) -1;\n+            }\n+\n+            Method encodeArray = null;\n+            if (csn.equals(\"ISO-8859-1\")) {\n+                \/\/ Use internal API for tests\n+                encodeArray = enc.getClass().getDeclaredMethod(\"encodeISOArray\",\n+                        char[].class, int.class, byte[].class, int.class, int.class);\n+                encodeArray.setAccessible(true);\n+                if ((int) encodeArray.invoke(enc, a, 0, bt, 0, SIZE) != SIZE || !Arrays.equals(b, bt)) {\n+                    System.out.println(\"Something wrong: ArrayEncoder.encode failed\");\n+                    System.exit(97);\n+                }\n+                for (int i = 0; i < SIZE; i++) {\n+                    at[i] = (char) -1;\n+                }\n+            }\n+\n+            ByteBuffer bb = ByteBuffer.wrap(b);\n+            CharBuffer ba = CharBuffer.wrap(a);\n+            ByteBuffer bbt = ByteBuffer.wrap(bt);\n+            CharBuffer bat = CharBuffer.wrap(at);\n+            if (!enc.encode(ba, bbt, true).isUnderflow() || !Arrays.equals(b, bt)) {\n+                System.out.println(\"Something wrong: Encoder.encode failed\");\n+                System.exit(97);\n+            }\n+            if (!dec.decode(bb, bat, true).isUnderflow() || !Arrays.equals(a, at)) {\n+                System.out.println(\"Something wrong: Decoder.decode failed (a == at: \" + !Arrays.equals(a, at) + \")\");\n+                System.exit(97);\n+            }\n+            for (int i = 0; i < SIZE; i++) {\n+                at[i] = (char) -1;\n+                bt[i] = (byte) -1;\n+            }\n+\n+            \/\/ Warm up\n+            boolean failed = false;\n+\n+            if (csn.equals(\"ISO-8859-1\")) {\n+                for (int i = 0; i < 10000; i++) {\n+                    failed |= (int) encodeArray.invoke(enc, a, 0, bt, 0, SIZE) != SIZE;\n+                }\n+                for (int i = 0; i < 10000; i++) {\n+                    failed |= (int) encodeArray.invoke(enc, a, 0, bt, 0, SIZE) != SIZE;\n+                }\n+                for (int i = 0; i < 10000; i++) {\n+                    failed |= (int) encodeArray.invoke(enc, a, 0, bt, 0, SIZE) != SIZE;\n+                }\n+                if (failed || !Arrays.equals(b, bt)) {\n+                    failed = true;\n+                    System.out.println(\"Failed: ISO_8859_1$Encoder.encode char[\" + SIZE + \"]\");\n+                }\n+            }\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                at[i] = (char) -1;\n+                bt[i] = (byte) -1;\n+            }\n+\n+            boolean is_underflow = true;\n+            for (int i = 0; i < 10000; i++) {\n+                ba.clear();\n+                bb.clear();\n+                bat.clear();\n+                bbt.clear();\n+                boolean enc_res = enc.encode(ba, bbt, true).isUnderflow();\n+                boolean dec_res = dec.decode(bb, bat, true).isUnderflow();\n+                is_underflow = is_underflow && enc_res && dec_res;\n+            }\n+            for (int i = 0; i < SIZE; i++) {\n+                at[i] = (char) -1;\n+                bt[i] = (byte) -1;\n+            }\n+            for (int i = 0; i < 10000; i++) {\n+                ba.clear();\n+                bb.clear();\n+                bat.clear();\n+                bbt.clear();\n+                boolean enc_res = enc.encode(ba, bbt, true).isUnderflow();\n+                boolean dec_res = dec.decode(bb, bat, true).isUnderflow();\n+                is_underflow = is_underflow && enc_res && dec_res;\n+            }\n+            for (int i = 0; i < SIZE; i++) {\n+                at[i] = (char) -1;\n+                bt[i] = (byte) -1;\n+            }\n+            for (int i = 0; i < 10000; i++) {\n+                ba.clear();\n+                bb.clear();\n+                bat.clear();\n+                bbt.clear();\n+                boolean enc_res = enc.encode(ba, bbt, true).isUnderflow();\n+                boolean dec_res = dec.decode(bb, bat, true).isUnderflow();\n+                is_underflow = is_underflow && enc_res && dec_res;\n+            }\n+            if (!is_underflow) {\n+                failed = true;\n+                System.out.println(\"Failed: got a non-underflow\");\n+            }\n+            if (!Arrays.equals(b, bt)) {\n+                failed = true;\n+                System.out.println(\"Failed: b != bt\");\n+            }\n+            if (!Arrays.equals(a, at)) {\n+                failed = true;\n+                System.out.println(\"Failed: a != at\");\n+            }\n+\n+            \/\/ Test encoder with char > 0xFF\n+            System.out.println(\"Testing big char\");\n+\n+            byte orig = (byte) 'A';\n+            bt = new byte[SIZE + 10]; \/\/ add some spare room to deal with encoding multi-byte\n+            ba = CharBuffer.wrap(a);\n+            bbt = ByteBuffer.wrap(bt);\n+            for (int i = 1; i <= SIZE; i++) {\n+                for (int j = 0; j < i; j++) {\n+                    char bigChar = (char)(ba.get(j) + 0x100);\n+                    ba.put(j, bigChar);\n+                    \/\/ make sure to replace a different byte\n+                    bbt.put(j, orig);\n+                    ba.clear();\n+                    ba.limit(i);\n+                    bbt.clear();\n+                    if (!enc.encode(ba, bbt, true).isUnderflow()) {\n+                        failed = true;\n+                        System.out.println(\"Failed: encode char[\" + i + \"] to byte[\" + i + \"]: expected underflow\");\n+                    }\n+                    if (bt[j] == b[j] && b[j] != repl) { \/\/ b[j] can be equal to repl; ignore\n+                        failed = true;\n+                        System.out.println(\"Failed: different byte expected at pos bt[\" + j + \"]\");\n+                    }\n+                    if (!enc.canEncode(bigChar) && bt[j] != repl) {\n+                        failed = true;\n+                        System.out.println(\"Failed: encoded replace byte[\" + j + \"] (\" + bt[j] + \") != \" + repl);\n+                    }\n+\n+                    \/\/ Check that all bytes prior to the replaced one was encoded properly\n+                    for (int k = 0; k < j; k++) {\n+                        if (bbt.get(k) != b[k]) {\n+                            failed = true;\n+                            System.out.println(\"Failed: encoded byte[\" + k + \"] (\" + bt[k] + \") != \" + b[k]);\n+                        }\n+                    }\n+                    ba.put(j, (char)(ba.get(j) - 0x100)); \/\/ Restore\n+                }\n+            }\n+\n+            if (failed) {\n+                System.out.println(\"FAILED\");\n+                System.exit(97);\n+            }\n+            System.out.println(\"PASSED\");\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            System.out.println(\"FAILED\");\n+            System.exit(97);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestEncodeIntrinsics.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -33,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -48,0 +51,2 @@\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n@@ -50,0 +55,1 @@\n+@Fork(3)\n@@ -58,1 +64,1 @@\n-    @Param({\"BIG5\", \"ISO-8859-15\", \"ASCII\", \"UTF-16\"})\n+    @Param({\"UTF-8\", \"BIG5\", \"ISO-8859-15\", \"ASCII\", \"UTF-16\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/CharsetEncodeDecode.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}