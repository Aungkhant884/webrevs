{"files":[{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1GCParPhaseTimesTracker.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+void G1AbstractSubTask::record_work_item(uint worker_id, uint index, size_t count) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  g1h->phase_times()->record_thread_work_item(_tag, worker_id, count, index);\n+}\n+\n+const char* G1AbstractSubTask::name() const {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  return g1h->phase_times()->phase_name(_tag);\n+}\n+\n+bool G1BatchedGangTask::try_claim_serial_task(int& task) {\n+  task = Atomic::load(&_num_serial_tasks_done);\n+  if (task < _serial_tasks.length()) {\n+    task = Atomic::fetch_and_add(&_num_serial_tasks_done, 1, memory_order_relaxed);\n+  }\n+  return task < _serial_tasks.length();\n+}\n+\n+void G1BatchedGangTask::add_serial_task(G1AbstractSubTask* task) {\n+  assert(task != nullptr, \"must be\");\n+  _serial_tasks.push(task);\n+}\n+\n+void G1BatchedGangTask::add_parallel_task(G1AbstractSubTask* task) {\n+  assert(task != nullptr, \"must be\");\n+  _parallel_tasks.push(task);\n+}\n+\n+G1BatchedGangTask::G1BatchedGangTask(const char* name, G1GCPhaseTimes* phase_times) :\n+  AbstractGangTask(name),\n+  _num_serial_tasks_done(0),\n+  _phase_times(phase_times),\n+  _serial_tasks(),\n+  _parallel_tasks() {\n+}\n+\n+uint G1BatchedGangTask::num_busy_workers() const {\n+  double sum = 0.0;\n+  for (G1AbstractSubTask* task : _serial_tasks) {\n+    sum += task->num_busy_workers();\n+  }\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    sum += task->num_busy_workers();\n+  }\n+  return ceil(sum);\n+}\n+\n+void G1BatchedGangTask::set_max_workers(uint max_workers) {\n+  for (G1AbstractSubTask* task : _serial_tasks) {\n+    task->set_max_workers(max_workers);\n+  }\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    task->set_max_workers(max_workers);\n+  }\n+}\n+\n+void G1BatchedGangTask::work(uint worker_id) {\n+  int t = 0;\n+  while (try_claim_serial_task(t)) {\n+    G1AbstractSubTask* task = _serial_tasks.at(t);\n+    G1GCParPhaseTimesTracker x(_phase_times, task->tag(), worker_id);\n+    task->do_work(worker_id);\n+  }\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    G1GCParPhaseTimesTracker x(_phase_times, task->tag(), worker_id);\n+    task->do_work(worker_id);\n+  }\n+}\n+\n+G1BatchedGangTask::~G1BatchedGangTask() {\n+  assert(Atomic::load(&_num_serial_tasks_done) >= _serial_tasks.length(),\n+         \"Only %d tasks of %d claimed\", Atomic::load(&_num_serial_tasks_done), _serial_tasks.length());\n+\n+  for (G1AbstractSubTask* task : _parallel_tasks) {\n+    delete task;\n+  }\n+  for (G1AbstractSubTask* task : _serial_tasks) {\n+    delete task;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedGangTask.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1BATCHEDGANGTASK_HPP\n+#define SHARE_GC_G1_G1BATCHEDGANGTASK_HPP\n+\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+template <typename E, MEMFLAGS F>\n+class GrowableArrayCHeap;\n+\n+\/\/ G1AbstractSubTask represents a task to be performed either within a\n+\/\/ G1BatchedGangTask running on a single worker (\"serially\") or multiple workers\n+\/\/ (\"in parallel\"). A G1AbstractSubTask is always associated with a phase tag\n+\/\/ that is used to automatically store timing information.\n+\/\/\n+\/\/ A \"serial\" task is some piece of work that either can not be parallelized\n+\/\/ easily, or is typically so short that parallelization is not worth the effort.\n+\/\/ Current examples would be summarizing per worker thread information gathered\n+\/\/ during garbage collection (e.g. Merge PSS work).\n+\/\/\n+\/\/ A \"parallel\" task could be some large amount of work that typically naturally\n+\/\/ splits across the heap in some way. Current examples would be clearing the\n+\/\/ card table.\n+\/\/\n+\/\/ See G1BatchedGangTask for information on execution.\n+class G1AbstractSubTask : public CHeapObj<mtGC> {\n+  G1GCPhaseTimes::GCParPhases _tag;\n+\n+  NONCOPYABLE(G1AbstractSubTask);\n+\n+protected:\n+  \/\/ Record work item for this tag in G1GCPhaseTimes.\n+  void record_work_item(uint worker_id, uint index, size_t count);\n+\n+public:\n+  G1AbstractSubTask(G1GCPhaseTimes::GCParPhases tag) : _tag(tag) { }\n+  virtual ~G1AbstractSubTask() { }\n+\n+  \/\/ How many workers (threads) would this task be able to keep busy for at least\n+  \/\/ as long as to amortize worker startup costs.\n+  \/\/ Called by G1BatchedGangTask to determine total number of workers.\n+  virtual double num_busy_workers() const = 0;\n+\n+  \/\/ Called by G1BatchedGangTask to provide information about the the maximum\n+  \/\/ number of workers for all subtasks after it has been determined.\n+  virtual void set_max_workers(uint max_workers) { }\n+\n+  \/\/ Perform the actual work. Gets the worker id it is run on passed in.\n+  virtual void do_work(uint worker_id) = 0;\n+\n+  \/\/ Tag for this G1AbstractSubTask.\n+  G1GCPhaseTimes::GCParPhases tag() const { return _tag; }\n+  \/\/ Human readable name derived from the tag.\n+  const char* name() const;\n+};\n+\n+\/\/ G1BatchedGangTask runs a set of G1AbstractSubTask using a work gang.\n+\/\/\n+\/\/ Subclasses of this class add their G1AbstractSubTasks into either the list\n+\/\/ of \"serial\" or the list of \"parallel\" tasks. They are supposed to be the owners\n+\/\/ of the G1AbstractSubTasks.\n+\/\/\n+\/\/ Eg. the constructor contains code like the following:\n+\/\/\n+\/\/   add_serial_task(new SomeSubTask());\n+\/\/   [...]\n+\/\/   add_parallel_task(new SomeOtherSubTask());\n+\/\/   [...]\n+\/\/\n+\/\/ During execution in the work gang, this class will make sure that the \"serial\"\n+\/\/ tasks are executed by a single worker exactly once, but different \"serial\"\n+\/\/ tasks may be executed in parallel using different workers. \"Parallel\" tasks'\n+\/\/ do_work() method may be called by different workers passing a different\n+\/\/ worker_id at the same time, but at most once per given worker_id.\n+\/\/\n+\/\/ There is also no guarantee that G1AbstractSubTasks::do_work() of different tasks\n+\/\/ are actually run in parallel.\n+\/\/\n+\/\/ The current implementation assumes that constructors and destructors of the\n+\/\/ G1AbstractSubTasks can executed in the constructor\/destructor of an instance\n+\/\/ of this class.\n+\/\/\n+\/\/ The constructor, destructor and the do_work() methods from different\n+\/\/ G1AbstractSubTasks may run in any order so they must not have any\n+\/\/ dependencies at all.\n+\/\/\n+\/\/ For a given G1AbstractSubTask T call order of its methods are as follows:\n+\/\/\n+\/\/ 1) T()\n+\/\/ 2) T::thread_usage()\n+\/\/ 3) T::set_max_workers()\n+\/\/ 4) T::do_work()  \/\/ potentially in parallel with any other registered G1AbstractSubTask\n+\/\/ 5) ~T()\n+\/\/\n+class G1BatchedGangTask : public AbstractGangTask {\n+  volatile int _num_serial_tasks_done;\n+  G1GCPhaseTimes* _phase_times;\n+\n+  bool try_claim_serial_task(int& task);\n+\n+  NONCOPYABLE(G1BatchedGangTask);\n+\n+  GrowableArrayCHeap<G1AbstractSubTask*, mtGC> _serial_tasks;\n+  GrowableArrayCHeap<G1AbstractSubTask*, mtGC> _parallel_tasks;\n+\n+protected:\n+  void add_serial_task(G1AbstractSubTask* task);\n+  void add_parallel_task(G1AbstractSubTask* task);\n+\n+  G1BatchedGangTask(const char* name, G1GCPhaseTimes* phase_times);\n+\n+public:\n+  void work(uint worker_id) override;\n+\n+  \/\/ How many workers can this gang task keep busy and could be started.\n+  uint num_busy_workers() const;\n+  \/\/ Informs the G1AbstractSubTasks about that we will start execution with the\n+  \/\/ given number of workers.\n+  void set_max_workers(uint max_workers);\n+\n+  ~G1BatchedGangTask();\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1BATCHEDGANGTASK_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedGangTask.hpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1BatchedGangTaskWorkers : AllStatic {\n+  static WorkGang* _work_gang;\n+  static WorkGang* work_gang() {\n+    if (_work_gang == nullptr) {\n+      _work_gang = new WorkGang(\"G1 Small Workers\", MaxWorkers, false, false);\n+      _work_gang->initialize_workers();\n+      _work_gang->update_active_workers(MaxWorkers);\n+    }\n+    return _work_gang;\n+  }\n+\n+public:\n+  static const uint MaxWorkers = 4;\n+  static void run_task(AbstractGangTask* task) {\n+    work_gang()->run_task(task);\n+  }\n+};\n+\n+WorkGang* G1BatchedGangTaskWorkers::_work_gang = nullptr;\n+\n+class G1TestSubTask : public G1AbstractSubTask {\n+  mutable uint _phase;\n+  volatile uint _num_do_work; \/\/ Amount of do_work() has been called.\n+\n+  void check_and_inc_phase(uint expected) const {\n+    ASSERT_EQ(_phase, expected);\n+    _phase++;\n+  }\n+\n+  bool volatile* _do_work_called_by;\n+\n+protected:\n+  uint _max_workers;\n+\n+  void do_work_called(uint worker_id) {\n+    Atomic::inc(&_num_do_work);\n+    bool orig_value = Atomic::cmpxchg(&_do_work_called_by[worker_id], false, true);\n+    ASSERT_EQ(orig_value, false);\n+  }\n+\n+  void verify_do_work_called_by(uint num_workers) {\n+    ASSERT_EQ(Atomic::load(&_num_do_work), num_workers);\n+    \/\/ Do not need to check the _do_work_called_by array. The count is already verified\n+    \/\/ by above statement, and we already check that a given flag is only set once.\n+  }\n+\n+public:\n+  \/\/ Actual use of GCParPhasesSentinel will cause an assertion failure when trying\n+  \/\/ to add timing information - this should be disabled here.\n+  G1TestSubTask() : G1AbstractSubTask(G1GCPhaseTimes::GCParPhasesSentinel),\n+    _phase(0),\n+    _num_do_work(0),\n+    _do_work_called_by(nullptr),\n+    _max_workers(0) {\n+    check_and_inc_phase(0);\n+  }\n+\n+  ~G1TestSubTask() {\n+    check_and_inc_phase(3);\n+    FREE_C_HEAP_ARRAY(bool, _do_work_called_by);\n+  }\n+\n+  double num_busy_workers() const override {\n+    check_and_inc_phase(1);\n+    return 1.0;\n+  }\n+\n+  \/\/ Called by G1BatchedGangTask to provide information about the the maximum\n+  \/\/ number of workers for all subtasks after it has been determined.\n+  void set_max_workers(uint max_workers) override {\n+    assert(max_workers >= 1, \"must be\");\n+    check_and_inc_phase(2);\n+\n+    _do_work_called_by = NEW_C_HEAP_ARRAY(bool, max_workers, mtInternal);\n+    for (uint i = 0; i < max_workers; i++) {\n+      _do_work_called_by[i] = false;\n+    }\n+    _max_workers = max_workers;\n+  }\n+\n+  void do_work(uint worker_id) override {\n+    do_work_called(worker_id);\n+  }\n+};\n+\n+class G1SerialTestSubTask : public G1TestSubTask {\n+public:\n+  G1SerialTestSubTask() : G1TestSubTask() { }\n+  ~G1SerialTestSubTask() {\n+    verify_do_work_called_by(1);\n+  }\n+\n+  double num_busy_workers() const override {\n+    G1TestSubTask::num_busy_workers();\n+    return 1.0;\n+  }\n+};\n+\n+class G1ParallelTestSubTask : public G1TestSubTask {\n+public:\n+  G1ParallelTestSubTask() : G1TestSubTask() { }\n+  ~G1ParallelTestSubTask() {\n+    verify_do_work_called_by(_max_workers);\n+  }\n+\n+  double num_busy_workers() const override {\n+    G1TestSubTask::num_busy_workers();\n+    return 2.0;\n+  }\n+};\n+\n+class G1TestBatchedGangTask : public G1BatchedGangTask {\n+public:\n+  G1TestBatchedGangTask() : G1BatchedGangTask(\"Batched Gang Test Task\", nullptr) {\n+    add_serial_task(new G1SerialTestSubTask());\n+    add_parallel_task(new G1ParallelTestSubTask());\n+  }\n+};\n+\n+TEST_VM(G1BatchedGangTask, check) {\n+  G1TestBatchedGangTask task;\n+  uint tasks = task.num_busy_workers();\n+  ASSERT_EQ(tasks, 3u);\n+  task.set_max_workers(G1BatchedGangTaskWorkers::MaxWorkers);\n+  G1BatchedGangTaskWorkers::run_task(&task);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1BatchedGangTask.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}