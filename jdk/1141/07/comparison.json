{"files":[{"patch":"@@ -67,0 +67,1 @@\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -746,1 +747,1 @@\n-  size_t uncommitted_regions = 0;\n+  uint shrink_count = 0;\n@@ -795,0 +796,1 @@\n+\n@@ -796,1 +798,1 @@\n-      uncommitted_regions++;\n+      shrink_count++;\n@@ -800,3 +802,5 @@\n-  if (uncommitted_regions != 0) {\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (uncommitted archive regions). Total size: \" SIZE_FORMAT \"B\",\n-                              HeapRegion::GrainWords * HeapWordSize * uncommitted_regions);\n+  if (shrink_count != 0) {\n+    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (archive regions). Total size: \" SIZE_FORMAT \"B\",\n+                              HeapRegion::GrainWords * HeapWordSize * shrink_count);\n+    \/\/ Explicit uncommit.\n+    uncommit_regions(shrink_count);\n@@ -1018,0 +1022,1 @@\n+  uncommit_regions_if_necessary();\n@@ -1297,0 +1302,1 @@\n+    log_debug(gc, heap)(\"Uncommittable regions after shrink: %u\", num_regions_removed);\n@@ -2614,0 +2620,14 @@\n+uint G1CollectedHeap::uncommit_regions(uint region_limit) {\n+  return _hrm.uncommit_inactive_regions(region_limit);\n+}\n+\n+bool G1CollectedHeap::has_uncommittable_regions() {\n+  return _hrm.has_inactive_regions();\n+}\n+\n+void G1CollectedHeap::uncommit_regions_if_necessary() {\n+  if (has_uncommittable_regions()) {\n+    G1UncommitRegionTask::enqueue();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -566,0 +566,6 @@\n+  \/\/ Check if there is memory to uncommit and if so schedule a task to do it.\n+  void uncommit_regions_if_necessary();\n+  \/\/ Immediately uncommit uncommittable regions.\n+  uint uncommit_regions(uint region_limit);\n+  bool has_uncommittable_regions();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CommittedRegionMap.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+HeapRegionRange::HeapRegionRange(uint start, uint end) :\n+    _start(start),\n+    _end(end) {\n+  assert(start <= end, \"Invariant\");\n+}\n+\n+G1CommittedRegionMap::G1CommittedRegionMap() :\n+  _active(mtGC),\n+  _inactive(mtGC),\n+  _num_active(0),\n+  _num_inactive(0) { }\n+\n+void G1CommittedRegionMap::initialize(uint num_regions) {\n+  _active.initialize(num_regions);\n+  _inactive.initialize(num_regions);\n+}\n+\n+uint G1CommittedRegionMap::num_active() const {\n+  return _num_active;\n+}\n+\n+uint G1CommittedRegionMap::num_inactive() const {\n+  return _num_inactive;\n+}\n+\n+uint G1CommittedRegionMap::max_length() const {\n+  return (uint) _active.size();\n+}\n+\n+void G1CommittedRegionMap::activate(uint start, uint end) {\n+  verify_active_count(start, end, 0);\n+  verify_inactive_count(start, end, 0);\n+\n+  log_debug(gc, heap, region)(\"Activate regions [%u, %u)\", start, end);\n+\n+  active_set_range(start, end);\n+}\n+\n+void G1CommittedRegionMap::reactivate(uint start, uint end) {\n+  verify_active_count(start, end, 0);\n+  verify_inactive_count(start, end, (end - start));\n+\n+  log_debug(gc, heap, region)(\"Reactivate regions [%u, %u)\", start, end);\n+\n+  active_set_range(start, end);\n+  inactive_clear_range(start, end);\n+}\n+\n+void G1CommittedRegionMap::deactivate(uint start, uint end) {\n+  verify_active_count(start, end, (end - start));\n+  verify_inactive_count(start, end, 0);\n+\n+  log_debug(gc, heap, region)(\"Deactivate regions [%u, %u)\", start, end);\n+\n+  active_clear_range(start, end);\n+  inactive_set_range(start, end);\n+}\n+\n+void G1CommittedRegionMap::uncommit(uint start, uint end) {\n+  verify_active_count(start, end, 0);\n+  verify_inactive_count(start, end, (end-start));\n+\n+  log_debug(gc, heap, region)(\"Uncommit regions [%u, %u)\", start, end);\n+\n+  inactive_clear_range(start, end);\n+}\n+\n+HeapRegionRange G1CommittedRegionMap::next_active_range(uint offset) const {\n+  \/\/ Find first active index from offset.\n+  uint start = (uint) _active.get_next_one_offset(offset);\n+  if (start == max_length()) {\n+    \/\/ Early out when no active regions are found.\n+    return HeapRegionRange(max_length(), max_length());\n+  }\n+\n+  uint end = (uint) _active.get_next_zero_offset(start);\n+  verify_active_range(start, end);\n+\n+  return HeapRegionRange(start, end);\n+}\n+\n+HeapRegionRange G1CommittedRegionMap::next_committable_range(uint offset) const {\n+  \/\/ We should only call this function when there are no inactive regions.\n+  verify_no_inactive_regons();\n+\n+  \/\/ Find first free region from offset.\n+  uint start = (uint) _active.get_next_zero_offset(offset);\n+  if (start == max_length()) {\n+    \/\/ Early out when no free regions are found.\n+    return HeapRegionRange(max_length(), max_length());\n+  }\n+\n+  uint end = (uint) _active.get_next_one_offset(start);\n+  verify_free_range(start, end);\n+\n+  return HeapRegionRange(start, end);\n+}\n+\n+HeapRegionRange G1CommittedRegionMap::next_inactive_range(uint offset) const {\n+  \/\/ Find first inactive region from offset.\n+  uint start = (uint) _inactive.get_next_one_offset(offset);\n+\n+  if (start == max_length()) {\n+    \/\/ Early when no inactive regions are found.\n+    return HeapRegionRange(max_length(), max_length());\n+  }\n+\n+  uint end = (uint) _inactive.get_next_zero_offset(start);\n+  verify_inactive_range(start, end);\n+\n+  return HeapRegionRange(start, end);\n+}\n+\n+void G1CommittedRegionMap::active_set_range(uint start, uint end) {\n+  guarantee_mt_safety_active();\n+\n+  _active.par_set_range(start, end, BitMap::unknown_range);\n+  _num_active += (end - start);\n+}\n+\n+void G1CommittedRegionMap::active_clear_range(uint start, uint end) {\n+  guarantee_mt_safety_active();\n+\n+  _active.par_clear_range(start, end, BitMap::unknown_range);\n+  _num_active -= (end - start);\n+}\n+\n+void G1CommittedRegionMap::inactive_set_range(uint start, uint end) {\n+  guarantee_mt_safety_inactive();\n+\n+  _inactive.par_set_range(start, end, BitMap::unknown_range);\n+  _num_inactive += (end - start);\n+}\n+\n+void G1CommittedRegionMap::inactive_clear_range(uint start, uint end) {\n+  guarantee_mt_safety_inactive();\n+\n+  _inactive.par_clear_range(start, end, BitMap::unknown_range);\n+  _num_inactive -= (end - start);\n+}\n+\n+void G1CommittedRegionMap::guarantee_mt_safety_active() const {\n+  \/\/ G1CommittedRegionMap _active-map MT safety protocol:\n+  \/\/ (a) If we're at a safepoint, the caller must either be the VM thread or\n+  \/\/     hold the FreeList_lock.\n+  \/\/ (b) If we're not at a safepoint, the caller must hold the Heap_lock.\n+  \/\/ Protocol only applies after initialization is complete.\n+\n+  if (!Universe::is_fully_initialized()) {\n+    return;\n+  }\n+\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    guarantee(Thread::current()->is_VM_thread() ||\n+              FreeList_lock->owned_by_self(),\n+              \"G1CommittedRegionMap _active-map MT safety protocol at a safepoint\");\n+  } else {\n+    guarantee(Heap_lock->owned_by_self(),\n+              \"G1CommittedRegionMap _active-map MT safety protocol outside a safepoint\");\n+  }\n+}\n+\n+void G1CommittedRegionMap::guarantee_mt_safety_inactive() const {\n+  \/\/ G1CommittedRegionMap _inactive-map MT safety protocol:\n+  \/\/ (a) If we're at a safepoint, the caller must either be the VM thread or\n+  \/\/     hold the FreeList_lock.\n+  \/\/ (b) If we're not at a safepoint, the caller must hold the Uncommit_lock.\n+  \/\/ Protocol only applies after initialization is complete.\n+\n+  if (!Universe::is_fully_initialized()) {\n+    return;\n+  }\n+\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    guarantee(Thread::current()->is_VM_thread() ||\n+              FreeList_lock->owned_by_self(),\n+              \"G1CommittedRegionMap MT safety protocol at a safepoint\");\n+  } else {\n+    guarantee(Uncommit_lock->owned_by_self(),\n+              \"G1CommittedRegionMap MT safety protocol outside a safepoint\");\n+  }\n+}\n+\n+#ifdef ASSERT\n+void G1CommittedRegionMap::verify_active_range(uint start, uint end) const {\n+  assert(active(start), \"First region (%u) is not active\", start);\n+  assert(active(end - 1), \"Last region (%u) is not active\", end - 1);\n+  assert(end == _active.size() || !active(end), \"Region (%u) is active but not included in range\", end);\n+}\n+\n+void G1CommittedRegionMap::verify_inactive_range(uint start, uint end) const {\n+  assert(inactive(start), \"First region (%u) is not inactive\", start);\n+  assert(inactive(end - 1), \"Last region (%u) in range is not inactive\", end - 1);\n+  assert(end == _inactive.size() || !inactive(end), \"Region (%u) is inactive but not included in range\", end);\n+}\n+\n+void G1CommittedRegionMap::verify_free_range(uint start, uint end) const {\n+  assert(!active(start), \"First region (%u) is active\", start);\n+  assert(!active(end - 1), \"Last region (%u) in range is active\", end - 1);\n+}\n+\n+void G1CommittedRegionMap::verify_no_inactive_regons() const {\n+  BitMap::idx_t first_inactive = _inactive.get_next_one_offset(0);\n+  assert(first_inactive == _inactive.size(), \"Should be no inactive regions, but was at index: \" SIZE_FORMAT, first_inactive);\n+}\n+\n+void G1CommittedRegionMap::verify_active_count(uint start, uint end, uint expected) const {\n+  uint found = (uint) _active.count_one_bits(start, end);\n+  assert(found == expected, \"Unexpected number of active regions, found: %u, expected: %u\", found, expected);\n+}\n+\n+void G1CommittedRegionMap::verify_inactive_count(uint start, uint end, uint expected) const {\n+  uint found = (uint) _inactive.count_one_bits(start, end);\n+  assert(found == expected, \"Unexpected number of inactive regions, found: %u, expected: %u\", found, expected);\n+}\n+\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.cpp","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1COMMITTEDREGIONMAP_HPP\n+#define SHARE_GC_G1_G1COMMITTEDREGIONMAP_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ Helper class to define a range [start, end) of regions.\n+class HeapRegionRange : public StackObj {\n+  \/\/ Inclusive start of the range.\n+  uint _start;\n+  \/\/ Exclusive end of the range.\n+  uint _end;\n+ public:\n+  HeapRegionRange(uint start, uint end);\n+\n+  uint start() const { return _start; }\n+  uint end() const { return _end; }\n+  uint length() const { return _end - _start; }\n+};\n+\n+\/\/ The G1CommittedRegionMap keeps track of which regions are currently committed.\n+\/\/ It tracks both regions ready for use and if there are any regions ready for\n+\/\/ uncommit. We basically have three states. Uncommitted, Active, Inactive. All\n+\/\/ regions that are either Active or Inactive are committed.\n+\/\/\n+\/\/ State transitions:\n+\/\/   Uncommitted -> Active      (activate())\n+\/\/   Active      -> Inactive    (deactivate())\n+\/\/   Inactive    -> Active      (reactivate())\n+\/\/   Inactive    -> Uncommitted (uncommit())\n+\/\/\n+class G1CommittedRegionMap : public CHeapObj<mtGC> {\n+  \/\/ Each bit in this bitmap indicates that the corresponding region is active\n+  \/\/ and available for allocation.\n+  CHeapBitMap _active;\n+  \/\/ Each bit in this bitmap indicates that the corresponding region is no longer\n+  \/\/ active and it can be uncommitted.\n+  CHeapBitMap _inactive;\n+  \/\/ The union of these two bitmaps are the regions that are currently committed.\n+\n+  \/\/ The number of regions active and available for use.\n+  uint _num_active;\n+\n+  \/\/ The number of regions ready to be uncommitted.\n+  uint _num_inactive;\n+\n+  uint max_length() const;\n+\n+  \/\/ Helpers to mark and do accounting for the bitmaps. Depending on when called\n+  \/\/ these helpers require to own different locks. See guarantee_mt_safety_* for\n+  \/\/ details.\n+  void active_set_range(uint start, uint end);\n+  void active_clear_range(uint start, uint end);\n+  void inactive_set_range(uint start, uint end);\n+  void inactive_clear_range(uint start, uint end);\n+\n+public:\n+  G1CommittedRegionMap();\n+  void initialize(uint num_regions);\n+\n+  uint num_active() const;\n+  uint num_inactive() const;\n+\n+  \/\/ Check if a region is marked active.\n+  inline bool active(uint index) const;\n+  \/\/ Check if a region is marked inactive.\n+  inline bool inactive(uint index) const;\n+\n+  \/\/ Mark a range of regions as active.\n+  void activate(uint start, uint end);\n+  \/\/ Mark a range of regions as inactive and ready to be uncommitted.\n+  void deactivate(uint start, uint end);\n+  \/\/ Mark a range of regions active again and no longer ready for uncommit.\n+  void reactivate(uint start, uint end);\n+  \/\/ Uncommit a range of inactive regions.\n+  void uncommit(uint start, uint end);\n+\n+  \/\/ Finds the next range of active regions starting at offset.\n+  HeapRegionRange next_active_range(uint offset) const;\n+  \/\/ Finds the next range of inactive regions starting at offset.\n+  HeapRegionRange next_inactive_range(uint offset) const;\n+  \/\/ Finds the next range of committable regions starting at offset.\n+  \/\/ This function must only be called when no inactive regions are\n+  \/\/ present and can be used to activate more regions.\n+  HeapRegionRange next_committable_range(uint offset) const;\n+\n+protected:\n+  virtual void guarantee_mt_safety_active() const;\n+  virtual void guarantee_mt_safety_inactive() const;\n+\n+  void verify_active_range(uint start, uint end) const NOT_DEBUG_RETURN;\n+  void verify_free_range(uint start, uint end) const NOT_DEBUG_RETURN;\n+  void verify_inactive_range(uint start, uint end) const NOT_DEBUG_RETURN;\n+  void verify_no_inactive_regons() const NOT_DEBUG_RETURN;\n+  void verify_active_count(uint start, uint end, uint expected) const NOT_DEBUG_RETURN;\n+  void verify_inactive_count(uint start, uint end, uint expected) const NOT_DEBUG_RETURN;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1COMMITTEDREGIONMAP_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1COMMITTEDREGIONMAP_INLINE_HPP\n+#define SHARE_GC_G1_G1COMMITTEDREGIONMAP_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CommittedRegionMap.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+inline bool G1CommittedRegionMap::active(uint index) const {\n+  return _active.at(index);\n+}\n+\n+inline bool G1CommittedRegionMap::inactive(uint index) const {\n+  return _inactive.at(index);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1COMMITTEDREGIONMAP_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.inline.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1163,0 +1163,1 @@\n+    _g1h->uncommit_regions_if_necessary();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,0 +101,12 @@\n+  void active(HeapRegion* hr) {\n+    if (is_active()) {\n+      print(\"ACTIVE\", hr);\n+    }\n+  }\n+\n+  void inactive(HeapRegion* hr) {\n+    if (is_active()) {\n+      print(\"INACTIVE\", hr);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HRPrinter.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -190,1 +190,3 @@\n-  guarantee(is_area_uncommitted(start_page, size_in_pages), \"Specified area is not uncommitted\");\n+  guarantee(is_area_uncommitted(start_page, size_in_pages),\n+            \"Specified area is not uncommitted, start page: \" SIZE_FORMAT \", page count: \" SIZE_FORMAT,\n+            start_page, size_in_pages);\n@@ -199,1 +201,1 @@\n-      _dirty.clear_range(start_page, end_page);\n+      _dirty.par_clear_range(start_page, end_page, BitMap::unknown_range);\n@@ -204,1 +206,1 @@\n-  _committed.set_range(start_page, end_page);\n+  _committed.par_set_range(start_page, end_page, BitMap::unknown_range);\n@@ -218,1 +220,3 @@\n-  guarantee(is_area_committed(start_page, size_in_pages), \"checking\");\n+  guarantee(is_area_committed(start_page, size_in_pages),\n+            \"Specified area is not committed, start page: \" SIZE_FORMAT \", page count: \" SIZE_FORMAT,\n+            start_page, size_in_pages);\n@@ -224,1 +228,1 @@\n-    _dirty.set_range(start_page, end_page);\n+    _dirty.par_set_range(start_page, end_page, BitMap::unknown_range);\n@@ -229,1 +233,1 @@\n-  _committed.clear_range(start_page, end_page);\n+  _committed.par_clear_range(start_page, end_page, BitMap::unknown_range);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -53,0 +53,8 @@\n+\/\/ Used to manually signal a mapper to handle a set of regions as committed.\n+\/\/ Setting the 'zero_filled' parameter to false signals the mapper that the\n+\/\/ regions have not been cleared by the OS and that they need to be clear\n+\/\/ explicitly.\n+void G1RegionToSpaceMapper::signal_mapping_changed(uint start_idx, size_t num_regions) {\n+  fire_on_commit(start_idx, num_regions, false);\n+}\n+\n@@ -73,0 +81,10 @@\n+  bool is_range_committed(uint start_idx, size_t num_regions) {\n+    BitMap::idx_t end = start_idx + num_regions;\n+    return _region_commit_map.get_next_zero_offset(start_idx, end) == end;\n+  }\n+\n+  bool is_range_uncommitted(uint start_idx, size_t num_regions) {\n+    BitMap::idx_t end = start_idx + num_regions;\n+    return _region_commit_map.get_next_one_offset(start_idx, end) == end;\n+  }\n+\n@@ -74,0 +92,4 @@\n+    guarantee(is_range_uncommitted(start_idx, num_regions),\n+              \"Range not uncommitted, start: %u, num_regions: \" SIZE_FORMAT,\n+              start_idx, num_regions);\n+\n@@ -87,1 +109,1 @@\n-    _region_commit_map.set_range(start_idx, start_idx + num_regions);\n+    _region_commit_map.par_set_range(start_idx, start_idx + num_regions, BitMap::unknown_range);\n@@ -92,0 +114,4 @@\n+    guarantee(is_range_committed(start_idx, num_regions),\n+             \"Range not committed, start: %u, num_regions: \" SIZE_FORMAT,\n+              start_idx, num_regions);\n+\n@@ -93,1 +119,1 @@\n-    _region_commit_map.clear_range(start_idx, start_idx + num_regions);\n+    _region_commit_map.par_clear_range(start_idx, start_idx + num_regions, BitMap::unknown_range);\n@@ -102,0 +128,11 @@\n+  \/\/ Lock to prevent bitmap updates and the actual underlying\n+  \/\/ commit to get out of order. This can happen in the cases\n+  \/\/ where one thread is expanding the heap during a humongous\n+  \/\/ allocation and at the same time the service thread is\n+  \/\/ doing uncommit. These operations will not operate on the\n+  \/\/ same regions, but they might operate on regions sharing\n+  \/\/ an underlying OS page. So we need to make sure that both\n+  \/\/ those resources are in sync:\n+  \/\/ - G1RegionToSpaceMapper::_region_commit_map;\n+  \/\/ - G1PageBasedVirtualSpace::_committed (_storage.commit())\n+  Mutex _lock;\n@@ -131,1 +168,2 @@\n-    _regions_per_page((page_size * commit_factor) \/ alloc_granularity) {\n+    _regions_per_page((page_size * commit_factor) \/ alloc_granularity),\n+    _lock(Mutex::leaf, \"G1 mapper lock\", true, Mutex::_safepoint_check_never) {\n@@ -151,7 +189,0 @@\n-    for (size_t page = start_page; page <= end_page; page++) {\n-      if (!is_page_committed(page)) {\n-        \/\/ Page not committed.\n-        if (num_committed == 0) {\n-          first_committed = page;\n-        }\n-        num_committed++;\n@@ -159,2 +190,21 @@\n-        if (!_storage.commit(page, 1)) {\n-          \/\/ Found dirty region during commit.\n+    \/\/ Concurrent operations might operate on regions sharing the same\n+    \/\/ underlying OS page. See lock declaration for more details.\n+    {\n+      MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+      for (size_t page = start_page; page <= end_page; page++) {\n+        if (!is_page_committed(page)) {\n+          \/\/ Page not committed.\n+          if (num_committed == 0) {\n+            first_committed = page;\n+          }\n+          num_committed++;\n+\n+          if (!_storage.commit(page, 1)) {\n+            \/\/ Found dirty region during commit.\n+            all_zero_filled = false;\n+          }\n+\n+          \/\/ Move memory to correct NUMA node for the heap.\n+          numa_request_on_node(page);\n+        } else {\n+          \/\/ Page already committed.\n@@ -163,6 +213,0 @@\n-\n-        \/\/ Move memory to correct NUMA node for the heap.\n-        numa_request_on_node(page);\n-      } else {\n-        \/\/ Page already committed.\n-        all_zero_filled = false;\n@@ -170,1 +214,0 @@\n-    }\n@@ -172,2 +215,4 @@\n-    \/\/ Update the commit map for the given range.\n-    _region_commit_map.set_range(start_idx, region_limit);\n+      \/\/ Update the commit map for the given range. Not using the par_set_range\n+      \/\/ since updates to _region_commit_map for this mapper is protected by _lock.\n+      _region_commit_map.set_range(start_idx, region_limit, BitMap::unknown_range);\n+    }\n@@ -191,2 +236,6 @@\n-    \/\/ Clear commit map for the given range.\n-    _region_commit_map.clear_range(start_idx, region_limit);\n+    \/\/ Concurrent operations might operate on regions sharing the same\n+    \/\/ underlying OS page. See lock declaration for more details.\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ Clear commit map for the given range. Not using the par_clear_range since\n+    \/\/ updates to _region_commit_map for this mapper is protected by _lock.\n+    _region_commit_map.clear_range(start_idx, region_limit, BitMap::unknown_range);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":72,"deletions":23,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+  void signal_mapping_changed(uint start_idx, size_t num_regions);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,2 +213,1 @@\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  ml.notify();\n+  notify();\n@@ -217,1 +216,1 @@\n-void G1ServiceThread::schedule_task(G1ServiceTask* task, jlong delay_ms) {\n+void G1ServiceThread::schedule(G1ServiceTask* task, jlong delay_ms) {\n@@ -232,0 +231,5 @@\n+void G1ServiceThread::schedule_task(G1ServiceTask* task, jlong delay_ms) {\n+  schedule(task, delay_ms);\n+  notify();\n+}\n+\n@@ -246,0 +250,5 @@\n+void G1ServiceThread::notify() {\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  ml.notify();\n+}\n+\n@@ -312,2 +321,1 @@\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  ml.notify();\n+  notify();\n@@ -331,1 +339,1 @@\n-  _service_thread->schedule_task(this, delay_ms);\n+  _service_thread->schedule(this, delay_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -126,1 +126,5 @@\n-  void schedule_task(G1ServiceTask* task, jlong delay);\n+  void schedule(G1ServiceTask* task, jlong delay);\n+\n+  \/\/ Notify a change to the service thread. Used to either stop\n+  \/\/ the service or to force check for new tasks.\n+  void notify();\n@@ -136,0 +140,4 @@\n+\n+  \/\/ Schedule the task and notify the service thread that a new\n+  \/\/ task might be ready to run.\n+  void schedule_task(G1ServiceTask* task, jlong delay);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+G1UncommitRegionTask* G1UncommitRegionTask::_instance = NULL;\n+\n+G1UncommitRegionTask::G1UncommitRegionTask() :\n+    G1ServiceTask(\"G1 Uncommit Region Task\"),\n+    _active(false),\n+    _summary_duration(),\n+    _summary_region_count(0) { }\n+\n+void G1UncommitRegionTask::initialize() {\n+  assert(_instance == NULL, \"Already initialized\");\n+  _instance = new G1UncommitRegionTask();\n+\n+  \/\/ Register the task with the service thread. This will automatically\n+  \/\/ schedule the task so we change the state to active.\n+  _instance->set_active(true);\n+  G1CollectedHeap::heap()->service_thread()->register_task(_instance);\n+}\n+\n+G1UncommitRegionTask* G1UncommitRegionTask::instance() {\n+  if (_instance == NULL) {\n+    initialize();\n+  }\n+  return _instance;\n+}\n+\n+void G1UncommitRegionTask::enqueue() {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  G1UncommitRegionTask* uncommit_task = instance();\n+  if (!uncommit_task->is_active()) {\n+    \/\/ Change state to active and schedule with no delay.\n+    uncommit_task->set_active(true);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(uncommit_task, 0);\n+  }\n+}\n+\n+bool G1UncommitRegionTask::is_active() {\n+  return _active;\n+}\n+\n+void G1UncommitRegionTask::set_active(bool state) {\n+  assert(_active != state, \"Must do a state change\");\n+  \/\/ There is no need to guard _active with a lock since the places where it\n+  \/\/ is updated can never run in parallel. The state is set to true only in\n+  \/\/ a safepoint and it is set to false while running on the service thread\n+  \/\/ joined with the suspendible thread set.\n+  _active = state;\n+}\n+\n+void G1UncommitRegionTask::report_execution(Tickspan time, uint regions) {\n+  _summary_region_count += regions;\n+  _summary_duration += time;\n+\n+  log_trace(gc, heap)(\"Concurrent Uncommit: \" SIZE_FORMAT \"%s, %u regions, %1.3fms\",\n+                      byte_size_in_proper_unit(regions * HeapRegion::GrainBytes),\n+                      proper_unit_for_byte_size(regions * HeapRegion::GrainBytes),\n+                      regions,\n+                      time.seconds() * 1000);\n+}\n+\n+void G1UncommitRegionTask::report_summary() {\n+  log_debug(gc, heap)(\"Concurrent Uncommit Summary: \" SIZE_FORMAT \"%s, %u regions, %1.3fms\",\n+                      byte_size_in_proper_unit(_summary_region_count * HeapRegion::GrainBytes),\n+                      proper_unit_for_byte_size(_summary_region_count * HeapRegion::GrainBytes),\n+                      _summary_region_count,\n+                      _summary_duration.seconds() * 1000);\n+}\n+\n+void G1UncommitRegionTask::clear_summary() {\n+  _summary_duration = Tickspan();\n+  _summary_region_count = 0;\n+}\n+\n+void G1UncommitRegionTask::execute() {\n+  assert(_active, \"Must be active\");\n+\n+  \/\/ Translate the size limit into a number of regions. This cannot be a\n+  \/\/ compile time constant because G1HeapRegionSize is set ergonomically.\n+  static const uint region_limit = (uint) (UncommitSizeLimit \/ G1HeapRegionSize);\n+\n+  \/\/ Prevent from running during a GC pause.\n+  SuspendibleThreadSetJoiner sts;\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+  Ticks start = Ticks::now();\n+  uint uncommit_count = g1h->uncommit_regions(region_limit);\n+  Tickspan uncommit_time = (Ticks::now() - start);\n+\n+  if (uncommit_count > 0) {\n+    report_execution(uncommit_time, uncommit_count);\n+  }\n+\n+  \/\/ Reschedule if there are more regions to uncommit, otherwise\n+  \/\/ change state to inactive.\n+  if (g1h->has_uncommittable_regions()) {\n+    \/\/ No delay, reason to reschedule rather then to loop is to allow\n+    \/\/ other tasks to run without waiting for a full uncommit cycle.\n+    schedule(0);\n+  } else {\n+    \/\/ Nothing more to do, change state and report a summary.\n+    set_active(false);\n+    report_summary();\n+    clear_summary();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1UNCOMMITREGIONTASK_HPP\n+#define SHARE_GC_G1_G1UNCOMMITREGIONTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class G1UncommitRegionTask : public G1ServiceTask {\n+  \/\/ Each execution of the uncommit task is limited to uncommit at most 256M.\n+  \/\/ This limit is small enough to ensure that the duration of each invocation\n+  \/\/ is short, while still making reasonable progress.\n+  static const uint UncommitSizeLimit = 256 * M;\n+\n+  static G1UncommitRegionTask* _instance;\n+  static void initialize();\n+  static G1UncommitRegionTask* instance();\n+\n+  \/\/ The _active state is used to prevent the task from being enqueued on the\n+  \/\/ service thread multiple times. If the task is active, a new requst to\n+  \/\/ enqueue it will be ignored.\n+  bool _active;\n+\n+  \/\/ Members to keep a summary of the current concurrent uncommit\n+  \/\/ work. Used for printing when no more work is available.\n+  Tickspan _summary_duration;\n+  uint _summary_region_count;\n+\n+  G1UncommitRegionTask();\n+  bool is_active();\n+  void set_active(bool state);\n+\n+  void report_execution(Tickspan time, uint regions);\n+  void report_summary();\n+  void clear_summary();\n+\n+public:\n+  static void enqueue();\n+  virtual void execute();\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CommittedRegionMap.inline.hpp\"\n@@ -62,4 +63,0 @@\n-HeapRegionRange::HeapRegionRange(uint start, uint end) : _start(start), _end(end) {\n-  assert(start <= end, \"Invariant\");\n-}\n-\n@@ -70,2 +67,1 @@\n-  _available_map(mtGC),\n-  _num_committed(0),\n+  _committed_map(),\n@@ -99,5 +95,1 @@\n-  _available_map.initialize(_regions.length());\n-}\n-\n-bool HeapRegionManager::is_available(uint region) const {\n-  return _available_map.at(region);\n+  _committed_map.initialize(reserved_length());\n@@ -177,0 +169,15 @@\n+void HeapRegionManager::expand(uint start, uint num_regions, WorkGang* pretouch_gang) {\n+  commit_regions(start, num_regions, pretouch_gang);\n+  for (uint i = start; i < start + num_regions; i++) {\n+    HeapRegion* hr = _regions.get_by_index(i);\n+    if (hr == NULL) {\n+      hr = new_heap_region(i);\n+      OrderAccess::storestore();\n+      _regions.set_by_index(i, hr);\n+      _allocated_heapregions_length = MAX2(_allocated_heapregions_length, i + 1);\n+    }\n+    G1CollectedHeap::heap()->hr_printer()->commit(hr);\n+  }\n+  activate_regions(start, num_regions);\n+}\n+\n@@ -182,2 +189,0 @@\n-  _num_committed += (uint)num_regions;\n-\n@@ -196,8 +201,2 @@\n-void HeapRegionManager::uncommit_regions(uint start, size_t num_regions) {\n-  guarantee(num_regions >= 1, \"Need to specify at least one region to uncommit, tried to uncommit zero regions at %u\", start);\n-  guarantee(_num_committed >= num_regions, \"pre-condition\");\n-\n-  \/\/ Reset node index to distinguish with committed regions.\n-  for (uint i = start; i < start + num_regions; i++) {\n-    at(i)->set_node_index(G1NUMA::UnknownNodeIndex);\n-  }\n+void HeapRegionManager::uncommit_regions(uint start, uint num_regions) {\n+  guarantee(num_regions > 0, \"No point in calling this for zero regions\");\n@@ -205,5 +204,8 @@\n-  \/\/ Print before uncommitting.\n-  if (G1CollectedHeap::heap()->hr_printer()->is_active()) {\n-    for (uint i = start; i < start + num_regions; i++) {\n-      HeapRegion* hr = at(i);\n-      G1CollectedHeap::heap()->hr_printer()->uncommit(hr);\n+  uint end = start + num_regions;\n+  G1HRPrinter* printer = G1CollectedHeap::heap()->hr_printer();\n+  if (printer->is_active()) {\n+    for (uint i = start; i < end; i++) {\n+      \/\/ Can't use at() here since region is no longer marked available.\n+      HeapRegion* hr = _regions.get_by_index(i);\n+      assert(hr != NULL, \"Region should still be present\");\n+      printer->uncommit(hr);\n@@ -213,3 +215,1 @@\n-  _num_committed -= (uint)num_regions;\n-\n-  _available_map.par_clear_range(start, start + num_regions, BitMap::unknown_range);\n+  \/\/ Uncommit heap memory\n@@ -226,13 +226,0 @@\n-}\n-\n-void HeapRegionManager::make_regions_available(uint start, uint num_regions, WorkGang* pretouch_gang) {\n-  guarantee(num_regions > 0, \"No point in calling this for zero regions\");\n-  commit_regions(start, num_regions, pretouch_gang);\n-  for (uint i = start; i < start + num_regions; i++) {\n-    if (_regions.get_by_index(i) == NULL) {\n-      HeapRegion* new_hr = new_heap_region(i);\n-      OrderAccess::storestore();\n-      _regions.set_by_index(i, new_hr);\n-      _allocated_heapregions_length = MAX2(_allocated_heapregions_length, i + 1);\n-    }\n-  }\n@@ -240,1 +227,2 @@\n-  _available_map.par_set_range(start, start + num_regions, BitMap::unknown_range);\n+  _committed_map.uncommit(start, end);\n+}\n@@ -242,0 +230,1 @@\n+void HeapRegionManager::initialize_regions(uint start, uint num_regions) {\n@@ -245,3 +234,0 @@\n-    if (G1CollectedHeap::heap()->hr_printer()->is_active()) {\n-      G1CollectedHeap::heap()->hr_printer()->commit(hr);\n-    }\n@@ -251,1 +237,2 @@\n-    insert_into_free_list(at(i));\n+    insert_into_free_list(hr);\n+    G1CollectedHeap::heap()->hr_printer()->active(hr);\n@@ -255,0 +242,41 @@\n+void HeapRegionManager::activate_regions(uint start, uint num_regions) {\n+  _committed_map.activate(start, start + num_regions);\n+  initialize_regions(start, num_regions);\n+}\n+\n+void HeapRegionManager::reactivate_regions(uint start, uint num_regions) {\n+  assert(num_regions > 0, \"No point in calling this for zero regions\");\n+\n+  clear_auxiliary_data_structures(start, num_regions);\n+\n+  _committed_map.reactivate(start, start + num_regions);\n+  initialize_regions(start, num_regions);\n+}\n+\n+void HeapRegionManager::deactivate_regions(uint start, uint num_regions) {\n+  assert(num_regions > 0, \"Need to specify at least one region to uncommit, tried to uncommit zero regions at %u\", start);\n+  assert(length() >= num_regions, \"pre-condition\");\n+\n+  \/\/ Reset NUMA index to and print state change.\n+  uint end = start + num_regions;\n+  for (uint i = start; i < end; i++) {\n+    HeapRegion* hr = at(i);\n+    hr->set_node_index(G1NUMA::UnknownNodeIndex);\n+    G1CollectedHeap::heap()->hr_printer()->inactive(hr);\n+  }\n+\n+  _committed_map.deactivate(start, end);\n+}\n+\n+void HeapRegionManager::clear_auxiliary_data_structures(uint start, uint num_regions) {\n+  \/\/ Signal marking bitmaps to clear the given regions.\n+  _prev_bitmap_mapper->signal_mapping_changed(start, num_regions);\n+  _next_bitmap_mapper->signal_mapping_changed(start, num_regions);\n+  \/\/ Signal G1BlockOffsetTable to clear the given regions.\n+  _bot_mapper->signal_mapping_changed(start, num_regions);\n+  \/\/ Signal G1CardTable to clear the given regions.\n+  _cardtable_mapper->signal_mapping_changed(start, num_regions);\n+  \/\/ Signal G1CardCounts to clear the given regions.\n+  _card_counts_mapper->signal_mapping_changed(start, num_regions);\n+}\n+\n@@ -273,2 +301,2 @@\n-uint HeapRegionManager::expand_by(uint num_regions, WorkGang* pretouch_workers) {\n-  return expand_at(0, num_regions, pretouch_workers);\n+bool HeapRegionManager::has_inactive_regions() const {\n+  return _committed_map.num_inactive() > 0;\n@@ -277,4 +305,40 @@\n-uint HeapRegionManager::expand_at(uint start, uint num_regions, WorkGang* pretouch_workers) {\n-  if (num_regions == 0) {\n-    return 0;\n-  }\n+uint HeapRegionManager::uncommit_inactive_regions(uint limit) {\n+  assert(limit > 0, \"Need to specify at least one region to uncommit\");\n+\n+  uint uncommitted = 0;\n+  uint offset = 0;\n+  do {\n+    MutexLocker uc(Uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    HeapRegionRange range = _committed_map.next_inactive_range(offset);\n+    \/\/ No more regions available for uncommit. Return the number of regions\n+    \/\/ already uncommitted or 0 if there were no longer any inactive regions.\n+    if (range.length() == 0) {\n+      return uncommitted;\n+    }\n+\n+    uint start = range.start();\n+    uint num_regions = MIN2(range.length(), limit - uncommitted);\n+    uncommitted += num_regions;\n+    uncommit_regions(start, num_regions);\n+  } while (uncommitted < limit);\n+\n+  assert(uncommitted == limit, \"Invariant\");\n+  return uncommitted;\n+}\n+\n+uint HeapRegionManager::expand_inactive(uint num_regions) {\n+  uint offset = 0;\n+  uint expanded = 0;\n+\n+  do {\n+    HeapRegionRange regions = _committed_map.next_inactive_range(offset);\n+    if (regions.length() == 0) {\n+      \/\/ No more unavailable regions.\n+      break;\n+    }\n+\n+    uint to_expand = MIN2(num_regions - expanded, regions.length());\n+    reactivate_regions(regions.start(), to_expand);\n+    expanded += to_expand;\n+    offset = regions.end();\n+  } while (expanded < num_regions);\n@@ -282,1 +346,7 @@\n-  uint offset = start;\n+  return expanded;\n+}\n+\n+uint HeapRegionManager::expand_any(uint num_regions, WorkGang* pretouch_workers) {\n+  assert(num_regions > 0, \"Must expand at least 1 region\");\n+\n+  uint offset = 0;\n@@ -286,1 +356,1 @@\n-    HeapRegionRange regions = find_unavailable_from_idx(offset);\n+    HeapRegionRange regions = _committed_map.next_committable_range(offset);\n@@ -293,1 +363,1 @@\n-    make_regions_available(regions.start(), to_expand, pretouch_workers);\n+    expand(regions.start(), to_expand, pretouch_workers);\n@@ -298,0 +368,15 @@\n+  return expanded;\n+}\n+\n+uint HeapRegionManager::expand_by(uint num_regions, WorkGang* pretouch_workers) {\n+  assert(num_regions > 0, \"Must expand at least 1 region\");\n+\n+  \/\/ First \"undo\" any requests to uncommit memory concurrently by\n+  \/\/ reverting such regions to being available.\n+  uint expanded = expand_inactive(num_regions);\n+\n+  \/\/ Commit more regions if needed.\n+  if (expanded < num_regions) {\n+    expanded += expand_any(num_regions - expanded, pretouch_workers);\n+  }\n+\n@@ -307,2 +392,15 @@\n-    if (!is_available(i)) {\n-      make_regions_available(i, 1, pretouch_workers);\n+    \/\/ First check inactive. If the regions is inactive, try to reactivate it\n+    \/\/ before it get uncommitted by the G1SeriveThread.\n+    if (_committed_map.inactive(i)) {\n+      \/\/ Need to grab the lock since this can be called by a java thread\n+      \/\/ doing humongous allocations.\n+      MutexLocker uc(Uncommit_lock, Mutex::_no_safepoint_check_flag);\n+      \/\/ State might change while getting the lock.\n+      if (_committed_map.inactive(i)) {\n+        reactivate_regions(i, 1);\n+      }\n+    }\n+    \/\/ Not else-if to catch the case where the inactive region was uncommited\n+    \/\/ while waiting to get the lock.\n+    if (!_committed_map.active(i)) {\n+      expand(i, 1, pretouch_workers);\n@@ -310,0 +408,2 @@\n+\n+    assert(at(i)->is_free(), \"Region must be free at this point\");\n@@ -388,2 +488,0 @@\n-  BitMap::idx_t range_start = 0;\n-  BitMap::idx_t range_end = range_start;\n@@ -391,0 +489,1 @@\n+  HeapRegionRange range(0,0);\n@@ -393,4 +492,3 @@\n-    range_start = _available_map.get_next_one_offset(range_end);\n-    range_end = _available_map.get_next_zero_offset(range_start);\n-    candidate = find_contiguous_in_range((uint) range_start, (uint) range_end, num_regions);\n-  } while (candidate == G1_NO_HRM_INDEX && range_end < reserved_length());\n+    range = _committed_map.next_active_range(range.end());\n+    candidate = find_contiguous_in_range(range.start(), range.end(), num_regions);\n+  } while (candidate == G1_NO_HRM_INDEX && range.end() < reserved_length());\n@@ -438,22 +536,0 @@\n-HeapRegionRange HeapRegionManager::find_unavailable_from_idx(uint index) const {\n-  guarantee(index <= reserved_length(), \"checking\");\n-\n-  \/\/ Find first unavailable region from offset.\n-  BitMap::idx_t start = _available_map.get_next_zero_offset(index);\n-  if (start == _available_map.size()) {\n-    \/\/ No unavailable regions found.\n-    return HeapRegionRange(reserved_length(), reserved_length());\n-  }\n-\n-  \/\/ The end of the range is the next available region.\n-  BitMap::idx_t end = _available_map.get_next_one_offset(start);\n-\n-  assert(!_available_map.at(start), \"Found region (\" SIZE_FORMAT \") is not unavailable\", start);\n-  assert(!_available_map.at(end - 1), \"Last region (\" SIZE_FORMAT \") in range is not unavailable\", end - 1);\n-  assert(end == _available_map.size() || _available_map.at(end), \"Region (\" SIZE_FORMAT \") is not available\", end);\n-\n-  \/\/ Shrink returned range to number of regions left to commit if necessary.\n-  end = MIN2(start + available(), end);\n-  return HeapRegionRange((uint) start, (uint) end);\n-}\n-\n@@ -581,1 +657,2 @@\n-  uncommit_regions(index, num_regions);\n+  \/\/ Mark regions as inactive making them ready for uncommit.\n+  deactivate_regions(index, (uint) num_regions);\n@@ -620,3 +697,3 @@\n-  guarantee(_num_committed <= max_length(),\n-            \"invariant: _num_committed: %u max_regions: %u\",\n-            _num_committed, max_length());\n+  guarantee(length() <= max_length(),\n+            \"invariant: committed regions: %u max_regions: %u\",\n+            length(), max_length());\n@@ -653,1 +730,1 @@\n-  guarantee(num_committed == _num_committed, \"Found %u committed regions, but should be %u\", num_committed, _num_committed);\n+  guarantee(num_committed == length(), \"Found %u committed regions, but should be %u\", num_committed, length());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":168,"deletions":91,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CommittedRegionMap.hpp\"\n@@ -45,14 +46,0 @@\n-\/\/ Helper class to define a range [start, end) of regions.\n-class HeapRegionRange : public StackObj {\n-  \/\/ Inclusive start of the range.\n-  uint _start;\n-  \/\/ Exclusive end of the range.\n-  uint _end;\n- public:\n-  HeapRegionRange(uint start, uint end);\n-\n-  uint start() const { return _start; }\n-  uint end() const { return _end; }\n-  uint length() const { return _end - _start; }\n-};\n-\n@@ -94,6 +81,3 @@\n-  \/\/ Each bit in this bitmap indicates that the corresponding region is available\n-  \/\/ for allocation.\n-  CHeapBitMap _available_map;\n-\n-  \/\/ The number of regions committed in the heap.\n-  uint _num_committed;\n+  \/\/ Keeps track of the currently committed regions in the heap. The committed regions\n+  \/\/ can either be active (ready for use) or inactive (ready for uncommit).\n+  G1CommittedRegionMap _committed_map;\n@@ -110,0 +94,3 @@\n+  \/\/ Initialize the HeapRegions in the range and put them on the free list.\n+  void initialize_regions(uint start, uint num_regions);\n+\n@@ -123,4 +110,0 @@\n-  \/\/ Finds the next sequence of unavailable regions starting at the given index. Returns the\n-  \/\/ sequence found as a HeapRegionRange. If no regions can be found, both start and end of\n-  \/\/ the returned range is equal to reserved_length().\n-  HeapRegionRange find_unavailable_from_idx(uint index) const;\n@@ -135,0 +118,6 @@\n+  \/\/ Clear the auxiliary data structures by notifying them that the mapping has\n+  \/\/ changed. The structures that needs to be cleared will than clear. This is\n+  \/\/ used to allow reuse regions scheduled for uncommit without uncommitting and\n+  \/\/ then committing them.\n+  void clear_auxiliary_data_structures(uint start, uint num_regions);\n+\n@@ -141,2 +130,12 @@\n-  void make_regions_available(uint index, uint num_regions = 1, WorkGang* pretouch_gang = NULL);\n-  void uncommit_regions(uint index, size_t num_regions = 1);\n+  void expand(uint index, uint num_regions, WorkGang* pretouch_gang = NULL);\n+\n+  \/\/ G1RegionCommittedMap helpers. These functions do the work that comes with\n+  \/\/ the state changes tracked by G1CommittedRegionMap. To make sure this is\n+  \/\/ safe from a multi-threading point of view there are two lock protocols in\n+  \/\/ G1RegionCommittedMap::guarantee_mt_safety_* that are enforced. The lock\n+  \/\/ needed should have been acquired before calling these functions.\n+  void activate_regions(uint index, uint num_regions);\n+  void deactivate_regions(uint start, uint num_regions);\n+  void reactivate_regions(uint start, uint num_regions);\n+  void uncommit_regions(uint start, uint num_regions);\n+\n@@ -152,0 +151,4 @@\n+  \/\/ Expand helper activating inactive regions rather than committing new ones.\n+  uint expand_inactive(uint num_regions);\n+  \/\/ Expand helper finding new regions to commit.\n+  uint expand_any(uint num_regions, WorkGang* pretouch_workers);\n@@ -183,1 +186,1 @@\n-  bool is_available(uint region) const;\n+  inline bool is_available(uint region) const;\n@@ -236,2 +239,2 @@\n-  \/\/ Return the number of regions that have been committed in the heap.\n-  uint length() const { return _num_committed; }\n+  \/\/ Return the number of regions currently active and available for use.\n+  uint length() const { return _committed_map.num_active(); }\n@@ -255,5 +258,0 @@\n-  \/\/ Makes sure that the regions from start to start+num_regions-1 are available\n-  \/\/ for allocation. Returns the number of regions that were committed to achieve\n-  \/\/ this.\n-  uint expand_at(uint start, uint num_regions, WorkGang* pretouch_workers);\n-\n@@ -285,2 +283,2 @@\n-  \/\/ Uncommit a number of regions starting at the specified index, which must be available,\n-  \/\/ empty, and free.\n+  \/\/ Remove a number of regions starting at the specified index, which must be available,\n+  \/\/ empty, and free. The regions are marked inactive and can later be uncommitted.\n@@ -289,0 +287,7 @@\n+  \/\/ Check if there are any inactive regions that can be uncommitted.\n+  bool has_inactive_regions() const;\n+\n+  \/\/ Uncommit inactive regions. Limit the number of regions to uncommit and return\n+  \/\/ actual number uncommitted.\n+  uint uncommit_inactive_regions(uint limit);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":41,"deletions":36,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CommittedRegionMap.inline.hpp\"\n@@ -32,0 +33,4 @@\n+inline bool HeapRegionManager::is_available(uint region) const {\n+  return _committed_map.active(region);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+#include \"gc\/g1\/heapRegionManager.hpp\"\n@@ -507,0 +508,7 @@\n+WB_ENTRY(jboolean, WB_G1HasRegionsToUncommit(JNIEnv* env, jobject o))\n+  if (UseG1GC) {\n+    return G1CollectedHeap::heap()->has_uncommittable_regions();\n+  }\n+  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1HasRegionsToUncommit: G1 GC is not enabled\");\n+WB_END\n+\n@@ -2305,0 +2313,1 @@\n+  {CC\"g1HasRegionsToUncommit\",  CC\"()Z\",              (void*)&WB_G1HasRegionsToUncommit},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+Mutex*   Uncommit_lock                = NULL;\n@@ -223,0 +224,1 @@\n+    def(Uncommit_lock              , PaddedMutex  , leaf + 1 ,   true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+extern Mutex*   Uncommit_lock;                   \/\/ protects the uncommit list when not at safepoints\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CommittedRegionMap.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1CommittedRegionMapSerial : public G1CommittedRegionMap {\n+public:\n+  static const uint TestRegions = 512;\n+\n+  void verify_counts() {\n+    verify_active_count(0, TestRegions, num_active());\n+    verify_inactive_count(0, TestRegions, num_inactive());\n+  }\n+\n+protected:\n+  void guarantee_mt_safety_active() const { }\n+  void guarantee_mt_safety_inactive() const { }\n+};\n+\n+static bool mutate() {\n+  return os::random() % 2 == 0;\n+}\n+\n+static void generate_random_map(G1CommittedRegionMap* map) {\n+  for (uint i = 0; i < G1CommittedRegionMapSerial::TestRegions; i++) {\n+    if (mutate()) {\n+      map->activate(i, i+1);\n+    }\n+  }\n+\n+  if (map->num_active() == 0) {\n+    \/\/ If we randomly activated 0 regions, activate the first half\n+    \/\/ to have some regions to test.\n+    map->activate(0, G1CommittedRegionMapSerial::TestRegions \/ 2);\n+  }\n+}\n+\n+static void random_deactivate(G1CommittedRegionMap* map) {\n+  uint current_offset = 0;\n+  do {\n+    HeapRegionRange current = map->next_active_range(current_offset);\n+    if (mutate()) {\n+      if (current.length() < 5) {\n+        \/\/ For short ranges, deactivate whole.\n+        map->deactivate(current.start(), current.end());\n+      } else {\n+        \/\/ For larger ranges, deactivate half.\n+        map->deactivate(current.start(), current.end() - (current.length() \/ 2));\n+      }\n+    }\n+    current_offset = current.end();\n+  } while (current_offset != G1CommittedRegionMapSerial::TestRegions);\n+}\n+\n+static void random_uncommit_or_reactive(G1CommittedRegionMap* map) {\n+  uint current_offset = 0;\n+  do {\n+    HeapRegionRange current = map->next_inactive_range(current_offset);\n+    \/\/ Randomly either reactivate or uncommit\n+    if (mutate()) {\n+      map->reactivate(current.start(), current.end());\n+    } else {\n+      map->uncommit(current.start(), current.end());\n+    }\n+\n+    current_offset = current.end();\n+  } while (current_offset != G1CommittedRegionMapSerial::TestRegions);\n+}\n+\n+static void random_activate_free(G1CommittedRegionMap* map) {\n+  uint current_offset = 0;\n+  do {\n+    HeapRegionRange current = map->next_committable_range(current_offset);\n+    \/\/ Randomly either reactivate or uncommit\n+    if (mutate()) {\n+      if (current.length() < 5) {\n+        \/\/ For short ranges, deactivate whole.\n+        map->activate(current.start(), current.end());\n+      } else {\n+        \/\/ For larger ranges, deactivate half.\n+        map->activate(current.start(), current.end() - (current.length() \/ 2));\n+      }\n+    }\n+\n+    current_offset = current.end();\n+  } while (current_offset != G1CommittedRegionMapSerial::TestRegions);\n+}\n+\n+TEST(G1CommittedRegionMapTest, serial) {\n+  G1CommittedRegionMapSerial serial_map;\n+  serial_map.initialize(G1CommittedRegionMapSerial::TestRegions);\n+\n+  \/\/ Activate some regions\n+  generate_random_map(&serial_map);\n+\n+  \/\/ Work through the map and mutate it\n+  for (int i = 0; i < 500; i++) {\n+    random_deactivate(&serial_map);\n+    serial_map.verify_counts();\n+    random_uncommit_or_reactive(&serial_map);\n+    serial_map.verify_counts();\n+    random_activate_free(&serial_map);\n+    serial_map.verify_counts();\n+    ASSERT_EQ(serial_map.num_inactive(), 0u);\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1RegionMap.cpp","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n+#include \"gc\/g1\/g1RegionToSpaceMapper.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1MapperWorkers : AllStatic {\n+  static WorkGang* _work_gang;\n+  static WorkGang* work_gang() {\n+    if (_work_gang == NULL) {\n+      _work_gang = new WorkGang(\"G1 Small Workers\", MaxWorkers, false, false);\n+      _work_gang->initialize_workers();\n+      _work_gang->update_active_workers(MaxWorkers);\n+    }\n+    return _work_gang;\n+  }\n+\n+public:\n+  static const uint MaxWorkers = 4;\n+  static void run_task(AbstractGangTask* task) {\n+    work_gang()->run_task(task);\n+  }\n+};\n+WorkGang* G1MapperWorkers::_work_gang = NULL;\n+\n+class G1TestCommitUncommit : public AbstractGangTask {\n+  G1RegionToSpaceMapper* _mapper;\n+  uint _claim_id;\n+public:\n+  G1TestCommitUncommit(G1RegionToSpaceMapper* mapper) :\n+      AbstractGangTask(\"Stress mapper\"),\n+      _mapper(mapper),\n+      _claim_id(0) { }\n+\n+  void work(uint worker_id) {\n+    uint index = Atomic::fetch_and_add(&_claim_id, 1u);\n+\n+    for (int i = 0; i < 100000; i++) {\n+      \/\/ Stress commit and uncommit of a single region. The same\n+      \/\/ will be done for multiple adjacent region to make sure\n+      \/\/ we properly handle bitmap updates as well as updates for\n+      \/\/ regions sharing the same underlying OS page.\n+      _mapper->commit_regions(index);\n+      _mapper->uncommit_regions(index);\n+    }\n+  }\n+};\n+\n+TEST_VM(G1RegionToSpaceMapper, smallStressAdjacent) {\n+  \/\/ Fake a heap with 1m regions and create a BOT like mapper. This\n+  \/\/ will give a G1RegionsSmallerThanCommitSizeMapper to stress.\n+  uint num_regions = G1MapperWorkers::MaxWorkers;\n+  size_t region_size = 1*M;\n+  size_t size = G1BlockOffsetTable::compute_size(num_regions * region_size \/ HeapWordSize);\n+  size_t page_size = os::vm_page_size();\n+\n+  ReservedSpace rs(size, os::vm_page_size());\n+\n+  G1RegionToSpaceMapper* small_mapper  =\n+    G1RegionToSpaceMapper::create_mapper(rs,\n+                                         size,\n+                                         page_size,\n+                                         region_size,\n+                                         G1BlockOffsetTable::heap_map_factor(),\n+                                         mtGC);\n+\n+\n+\n+  G1TestCommitUncommit task(small_mapper);\n+  G1MapperWorkers::run_task(&task);\n+}\n+\n+TEST_VM(G1RegionToSpaceMapper, largeStressAdjacent) {\n+  \/\/ Fake a heap with 2m regions and create a BOT like mapper. This\n+  \/\/ will give a G1RegionsLargerThanCommitSizeMapper to stress.\n+  uint num_regions = G1MapperWorkers::MaxWorkers;\n+  size_t region_size = 2*M;\n+  size_t size = G1BlockOffsetTable::compute_size(num_regions * region_size \/ HeapWordSize);\n+  size_t page_size = os::vm_page_size();\n+\n+  ReservedSpace rs(size, page_size);\n+\n+  G1RegionToSpaceMapper* large_mapper  =\n+    G1RegionToSpaceMapper::create_mapper(rs,\n+                                         size,\n+                                         page_size,\n+                                         region_size,\n+                                         G1BlockOffsetTable::heap_map_factor(),\n+                                         mtGC);\n+\n+  G1TestCommitUncommit task(large_mapper);\n+  G1MapperWorkers::run_task(&task);\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -156,1 +156,1 @@\n-        public static void main(String[] args) throws IOException {\n+        public static void main(String[] args) throws Exception {\n@@ -223,1 +223,1 @@\n-        public void test() throws IOException {\n+        public void test() throws Exception {\n@@ -245,0 +245,8 @@\n+            if (WhiteBox.getWhiteBox().g1HasRegionsToUncommit()) {\n+                System.out.println(\"Waiting for concurrent uncommit to complete\");\n+                do {\n+                    Thread.sleep(1000);\n+                } while(WhiteBox.getWhiteBox().g1HasRegionsToUncommit());\n+                System.out.println(\"Concurrent uncommit done\");\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.stress;\n+\n+\/*\n+ * @test TestStressUncommit\n+ * @key stress\n+ * @summary Stress uncommitting by allocating and releasing memory\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver\/timeout=1300 gc.stress.TestStressG1Uncommit\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import com.sun.management.ThreadMXBean;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestStressG1Uncommit {\n+    public static void main(String[] args) throws Exception {\n+        ArrayList<String> options = new ArrayList<>();\n+        Collections.addAll(options,\n+            \"-Xlog:gc,gc+heap+region=debug\",\n+            \"-XX:+UseG1GC\",\n+            StressUncommit.class.getName()\n+        );\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(options);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldMatch(\"Uncommit regions\");\n+        output.outputTo(System.out);\n+    }\n+}\n+\n+class StressUncommit {\n+    private static final long M = 1024 * 1024;\n+    private static final long G = 1024 * M;\n+    private static final Instant StartTime = Instant.now();\n+\n+    private static final ThreadMXBean threadBean = (ThreadMXBean) ManagementFactory.getThreadMXBean();\n+    private static final MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();\n+    private static ConcurrentLinkedQueue<Object> globalKeepAlive;\n+\n+    public static void main(String args[]) throws InterruptedException {\n+        \/\/ Leave 20% head room to try to avoid Full GCs.\n+        long allocationSize = (long) (Runtime.getRuntime().maxMemory() * 0.8);\n+\n+        \/\/ Figure out suitable number of workers (~1 per gig).\n+        int gigsOfAllocation = (int) Math.ceil((double) allocationSize \/ G);\n+        int numWorkers = Math.min(gigsOfAllocation, Runtime.getRuntime().availableProcessors());\n+        long workerAllocation = allocationSize \/ numWorkers;\n+\n+        log(\"Using \" + numWorkers + \" workers, each allocating: ~\" + (workerAllocation \/ M) + \"M\");\n+        ExecutorService workers = Executors.newFixedThreadPool(numWorkers);\n+        try {\n+            int iteration = 1;\n+            \/\/ Run for 60 seconds.\n+            while (uptime() < 60) {\n+                log(\"Interation: \" + iteration++);\n+                globalKeepAlive = new ConcurrentLinkedQueue<>();\n+                \/\/ Submit work to executor.\n+                CountDownLatch workersRunning = new CountDownLatch(numWorkers);\n+                for (int j = 0; j < numWorkers; j++) {\n+                    \/\/ Submit worker task.\n+                    workers.submit(() -> {\n+                    allocateToLimit(workerAllocation);\n+                    workersRunning.countDown();\n+                    });\n+                }\n+\n+                \/\/ Wait for tasks to complete.\n+                workersRunning.await();\n+\n+                \/\/ Clear the reference holding all task allocations alive.\n+                globalKeepAlive = null;\n+\n+                \/\/ Do a GC that should shrink the heap.\n+                long committedBefore = memoryBean.getHeapMemoryUsage().getCommitted();\n+                System.gc();\n+                long committedAfter = memoryBean.getHeapMemoryUsage().getCommitted();\n+                Asserts.assertLessThan(committedAfter, committedBefore);\n+            }\n+        } finally {\n+            workers.shutdown();\n+            workers.awaitTermination(5, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void allocateToLimit(long limit) {\n+        var localKeepAlive = new LinkedList<byte[]>();\n+\n+        long currentAllocation = threadBean.getCurrentThreadAllocatedBytes();\n+        long allocationLimit = currentAllocation + limit;\n+\n+        while (currentAllocation < allocationLimit) {\n+            \/\/ Check roughly every megabyte.\n+            for (long j = 0 ; j < 1000; j++) {\n+            localKeepAlive.add(new byte[1024]);\n+            }\n+            currentAllocation = threadBean.getCurrentThreadAllocatedBytes();\n+        }\n+\n+        \/\/ Add to globalKeepAlive for realease by main thread.\n+        globalKeepAlive.add(localKeepAlive);\n+    }\n+\n+    private static long uptime() {\n+        return Duration.between(StartTime, Instant.now()).getSeconds();\n+    }\n+\n+    private static void log(String text) {\n+        System.out.println(uptime() + \"s: \" + text);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Uncommit.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -166,0 +166,1 @@\n+  public native boolean g1HasRegionsToUncommit();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}