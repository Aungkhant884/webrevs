{"files":[{"patch":"@@ -207,1 +207,1 @@\n-      _dirty.clear_range(start_page, end_page);\n+      _dirty.par_clear_range(start_page, end_page, BitMap::unknown_range);\n@@ -212,1 +212,1 @@\n-  _committed.set_range(start_page, end_page);\n+  _committed.par_set_range(start_page, end_page, BitMap::unknown_range);\n@@ -226,1 +226,3 @@\n-  guarantee(is_area_committed(start_page, size_in_pages), \"checking\");\n+  guarantee(is_area_committed(start_page, size_in_pages),\n+            \"Specified area is not committed, start page: \" SIZE_FORMAT \", page count: \" SIZE_FORMAT,\n+            start_page, size_in_pages);\n@@ -232,1 +234,1 @@\n-    _dirty.set_range(start_page, end_page);\n+    _dirty.par_set_range(start_page, end_page, BitMap::unknown_range);\n@@ -237,1 +239,1 @@\n-  _committed.clear_range(start_page, end_page);\n+  _committed.par_clear_range(start_page, end_page, BitMap::unknown_range);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,0 +84,10 @@\n+  bool committed_range(uint start_idx, size_t num_regions) {\n+    BitMap::idx_t end = start_idx + num_regions;\n+    return _region_commit_map.get_next_zero_offset(start_idx, end) == end;\n+  }\n+\n+  bool uncommitted_range(uint start_idx, size_t num_regions) {\n+    BitMap::idx_t end = start_idx + num_regions;\n+    return _region_commit_map.get_next_one_offset(start_idx, end) == end;\n+  }\n+\n@@ -85,0 +95,4 @@\n+    guarantee(uncommitted_range(start_idx, num_regions),\n+              \"Range not uncommitted, start: %u, num_regions: \" SIZE_FORMAT,\n+              start_idx, num_regions);\n+\n@@ -98,1 +112,1 @@\n-    _region_commit_map.set_range(start_idx, start_idx + num_regions);\n+    _region_commit_map.par_set_range(start_idx, start_idx + num_regions, BitMap::unknown_range);\n@@ -103,0 +117,4 @@\n+    guarantee(committed_range(start_idx, num_regions),\n+             \"Range not committed, start: %u, num_regions: \" SIZE_FORMAT,\n+              start_idx, num_regions);\n+\n@@ -104,1 +122,1 @@\n-    _region_commit_map.clear_range(start_idx, start_idx + num_regions);\n+    _region_commit_map.par_clear_range(start_idx, start_idx + num_regions, BitMap::unknown_range);\n@@ -113,0 +131,8 @@\n+  \/\/ Lock to prevent bitmap updates and the actual underlying\n+  \/\/ commit to get out of order. This can happen in the cases\n+  \/\/ where one thread is expanding the heap during a humongous\n+  \/\/ allocation and at the same time the service thread is\n+  \/\/ doing uncommit. These operations will not operate on the\n+  \/\/ same regions, but they might operate on regions sharing\n+  \/\/ an underlying OS page.\n+  Mutex _lock;\n@@ -142,1 +168,2 @@\n-    _regions_per_page((page_size * commit_factor) \/ alloc_granularity) {\n+    _regions_per_page((page_size * commit_factor) \/ alloc_granularity),\n+    _lock(Mutex::leaf, \"G1 mapper lock\", true, Mutex::_safepoint_check_never) {\n@@ -162,7 +189,0 @@\n-    for (size_t page = start_page; page <= end_page; page++) {\n-      if (!is_page_committed(page)) {\n-        \/\/ Page not committed.\n-        if (num_committed == 0) {\n-          first_committed = page;\n-        }\n-        num_committed++;\n@@ -170,2 +190,21 @@\n-        if (!_storage.commit(page, 1)) {\n-          \/\/ Found dirty region during commit.\n+    \/\/ Concurrent operations might operate on regions sharing the same\n+    \/\/ underlying OS page. See lock declaration for more details.\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    {\n+      for (size_t page = start_page; page <= end_page; page++) {\n+        if (!is_page_committed(page)) {\n+          \/\/ Page not committed.\n+          if (num_committed == 0) {\n+            first_committed = page;\n+          }\n+          num_committed++;\n+\n+          if (!_storage.commit(page, 1)) {\n+            \/\/ Found dirty region during commit.\n+            all_zero_filled = false;\n+          }\n+\n+          \/\/ Move memory to correct NUMA node for the heap.\n+          numa_request_on_node(page);\n+        } else {\n+          \/\/ Page already committed.\n@@ -174,6 +213,0 @@\n-\n-        \/\/ Move memory to correct NUMA node for the heap.\n-        numa_request_on_node(page);\n-      } else {\n-        \/\/ Page already committed.\n-        all_zero_filled = false;\n@@ -181,1 +214,0 @@\n-    }\n@@ -183,2 +215,3 @@\n-    \/\/ Update the commit map for the given range.\n-    _region_commit_map.set_range(start_idx, region_limit);\n+      \/\/ Update the commit map for the given range.\n+      _region_commit_map.par_set_range(start_idx, region_limit, BitMap::unknown_range);\n+    }\n@@ -202,0 +235,3 @@\n+    \/\/ Concurrent operations might operate on regions sharing the same\n+    \/\/ underlying OS page. See lock declaration for more details.\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n@@ -203,1 +239,1 @@\n-    _region_commit_map.clear_range(start_idx, region_limit);\n+    _region_commit_map.par_clear_range(start_idx, region_limit, BitMap::unknown_range);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":58,"deletions":22,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-    def(Uncommit_lock              , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);\n+    def(Uncommit_lock              , PaddedMutex  , leaf + 1 ,   true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1BlockOffsetTable.hpp\"\n+#include \"gc\/g1\/g1RegionToSpaceMapper.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1MapperWorkers : AllStatic {\n+  static WorkGang* _work_gang;\n+  static WorkGang* work_gang() {\n+    if (_work_gang == NULL) {\n+      _work_gang = new WorkGang(\"G1 Small Workers\", MaxWorkers, false, false);\n+      _work_gang->initialize_workers();\n+      _work_gang->update_active_workers(MaxWorkers);\n+    }\n+    return _work_gang;\n+  }\n+\n+public:\n+  static const uint MaxWorkers = 4;\n+  static void run_task(AbstractGangTask* task) {\n+    work_gang()->run_task(task);\n+  }\n+};\n+WorkGang* G1MapperWorkers::_work_gang = NULL;\n+\n+class G1TestCommitUncommit : public AbstractGangTask {\n+  G1RegionToSpaceMapper* _mapper;\n+  uint _claim_id;\n+public:\n+  G1TestCommitUncommit(G1RegionToSpaceMapper* mapper) :\n+      AbstractGangTask(\"Stress mapper\"),\n+      _mapper(mapper),\n+      _claim_id(0) { }\n+\n+  void work(uint worker_id) {\n+    uint index = Atomic::fetch_and_add(&_claim_id, 1u);\n+\n+    for (int i = 0; i < 100000; i++) {\n+      \/\/ Stress commit and uncommit of a single region. The same\n+      \/\/ will be done for multiple adjacent region to make sure\n+      \/\/ we properly handle bitmap updates as well as updates for\n+      \/\/ regions sharing the same underlying OS page.\n+      _mapper->commit_regions(index);\n+      _mapper->uncommit_regions(index);\n+    }\n+  }\n+};\n+\n+TEST_VM(G1RegionToSpaceMapper, smallStressAdjacent) {\n+  \/\/ Fake a heap with 1m regions and create a BOT like mapper. This\n+  \/\/ will give a G1RegionsSmallerThanCommitSizeMapper to stress.\n+  uint num_regions = G1MapperWorkers::MaxWorkers;\n+  size_t region_size = 1*M;\n+  size_t size = G1BlockOffsetTable::compute_size(num_regions * region_size \/ HeapWordSize);\n+  size_t page_size = os::vm_page_size();\n+\n+  ReservedSpace rs(size, os::vm_page_size());\n+\n+  G1RegionToSpaceMapper* small_mapper  =\n+    G1RegionToSpaceMapper::create_mapper(rs,\n+                                         size,\n+                                         page_size,\n+                                         region_size,\n+                                         G1BlockOffsetTable::heap_map_factor(),\n+                                         mtGC);\n+\n+\n+\n+  G1TestCommitUncommit task(small_mapper);\n+  G1MapperWorkers::run_task(&task);\n+}\n+\n+TEST_VM(G1RegionToSpaceMapper, largeStressAdjacent) {\n+  \/\/ Fake a heap with 2m regions and create a BOT like mapper. This\n+  \/\/ will give a G1RegionsLargerThanCommitSizeMapper to stress.\n+  uint num_regions = G1MapperWorkers::MaxWorkers;\n+  size_t region_size = 2*M;\n+  size_t size = G1BlockOffsetTable::compute_size(num_regions * region_size \/ HeapWordSize);\n+  size_t page_size = os::vm_page_size();\n+\n+  ReservedSpace rs(size, page_size);\n+\n+  G1RegionToSpaceMapper* large_mapper  =\n+    G1RegionToSpaceMapper::create_mapper(rs,\n+                                         size,\n+                                         page_size,\n+                                         region_size,\n+                                         G1BlockOffsetTable::heap_map_factor(),\n+                                         mtGC);\n+\n+  G1TestCommitUncommit task(large_mapper);\n+  G1MapperWorkers::run_task(&task);\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}