{"files":[{"patch":"@@ -2640,1 +2640,1 @@\n-    G1UncommitRegionTask::activate();\n+    G1UncommitRegionTask::run();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,3 @@\n-  \/\/ Helpers to mark and do accounting for the bitmaps.\n+  \/\/ Helpers to mark and do accounting for the bitmaps. Depending on when called\n+  \/\/ these helpers require to own different locks. See guarantee_mt_safty_* for\n+  \/\/ details.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-\/\/ regions have not been cleared by the OS.\n+\/\/ regions have not been cleared by the OS and that they need to be clear\n+\/\/ explicitly.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    _state(TaskState::inactive),\n+    _active(false),\n@@ -46,1 +46,1 @@\n-  _instance->set_state(TaskState::active);\n+  _instance->set_active(true);\n@@ -57,1 +57,1 @@\n-void G1UncommitRegionTask::activate() {\n+void G1UncommitRegionTask::run() {\n@@ -63,1 +63,1 @@\n-    uncommit_task->set_state(TaskState::active);\n+    uncommit_task->set_active(true);\n@@ -65,1 +65,1 @@\n-    \/\/ Notify service thread to avoid unnecesarry waiting.\n+    \/\/ Notify service thread to avoid unnecessary waiting.\n@@ -71,1 +71,1 @@\n-  return _state == TaskState::active;\n+  return _active;\n@@ -74,3 +74,3 @@\n-void G1UncommitRegionTask::set_state(TaskState state) {\n-  assert(_state != state, \"Must do a state change\");\n-  _state = state;\n+void G1UncommitRegionTask::set_active(bool state) {\n+  assert(_active != state, \"Must do a state change\");\n+  _active = state;\n@@ -104,1 +104,1 @@\n-  assert(_state == TaskState::active, \"Must be active\");\n+  assert(_active, \"Must be active\");\n@@ -106,1 +106,3 @@\n-  \/\/ Each execution is limited to uncommit at most 256M worth of regions.\n+  \/\/ Each execution is limited to uncommit at most 256M worth of regions. This\n+  \/\/ limit is small enough to ensure that the duration of each invocation is\n+  \/\/ short, while still making reasonable progress.\n@@ -128,1 +130,2 @@\n-    set_state(TaskState::inactive);\n+    \/\/ Nothing more to do, change state and report a summary.\n+    set_active(false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,7 +37,6 @@\n-  \/\/ The state is not guarded by any lock because the places\n-  \/\/ where it is updated can never run concurrently. The state\n-  \/\/ is set to active only from a safepoint and it is set to\n-  \/\/ inactive while running on the service thread joined with\n-  \/\/ the suspendible thread set.\n-  enum class TaskState { active, inactive };\n-  TaskState _state;\n+  \/\/ The _active state is not guarded by a lock since the places\n+  \/\/ where it is updated can never run in parallel. The state is\n+  \/\/ set to active only from a safepoint and it is set to false\n+  \/\/ while running on the service thread joined with the suspendible\n+  \/\/ thread set.\n+  bool _active;\n@@ -52,1 +51,1 @@\n-  void set_state(TaskState state);\n+  void set_active(bool state);\n@@ -59,1 +58,1 @@\n-  static void activate();\n+  static void run();\n@@ -63,1 +62,1 @@\n-#endif\n\\ No newline at end of file\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-  guarantee(num_regions > 0, \"No point in calling this for zero regions\");\n@@ -262,3 +261,3 @@\n-void HeapRegionManager::deactivate_regions(uint start, size_t num_regions) {\n-  guarantee(num_regions >= 1, \"Need to specify at least one region to uncommit, tried to uncommit zero regions at %u\", start);\n-  guarantee(length() >= num_regions, \"pre-condition\");\n+void HeapRegionManager::deactivate_regions(uint start, uint num_regions) {\n+  assert(num_regions > 0, \"Need to specify at least one region to uncommit, tried to uncommit zero regions at %u\", start);\n+  assert(length() >= num_regions, \"pre-condition\");\n@@ -270,2 +269,2 @@\n-  uint end = (uint) (start + num_regions);\n-  for (uint i = start; i < start + num_regions; i++) {\n+  uint end = start + num_regions;\n+  for (uint i = start; i < end; i++) {\n@@ -283,0 +282,1 @@\n+  \/\/ Signal marking bitmaps to clear the given regions.\n@@ -285,0 +285,1 @@\n+  \/\/ Signal G1BlockOffsetTable to clear the given regions.\n@@ -286,0 +287,1 @@\n+  \/\/ Signal G1CardTable to clear the given regions.\n@@ -287,0 +289,1 @@\n+  \/\/ Signal G1CardCounts to clear the given regions.\n@@ -313,1 +316,1 @@\n-  guarantee(limit >= 1, \"Need to specify at least one region to uncommit\");\n+  assert(limit > 0, \"Need to specify at least one region to uncommit\");\n@@ -320,1 +323,2 @@\n-    \/\/ No more regions available for uncommit\n+    \/\/ No more regions available for uncommit. Return the number of regions\n+    \/\/ already uncommitted or 0 if there were no longer any inactive regions.\n@@ -664,1 +668,1 @@\n-  deactivate_regions(index, num_regions);\n+  deactivate_regions(index, (uint) num_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-  \/\/ Map to keep track of which regions are in use.\n+  \/\/ Keeps track of the currently committed regions in the heap. The committed regions\n+  \/\/ can either be active (ready for use) or inactive (ready for uncommit).\n@@ -122,1 +123,1 @@\n-  \/\/ used to allow reuse regions scheduled for uncommit without uncommiting and\n+  \/\/ used to allow reuse regions scheduled for uncommit without uncommitting and\n@@ -132,3 +133,3 @@\n-  void expand(uint index, uint num_regions = 1, WorkGang* pretouch_gang = NULL);\n-  void activate_regions(uint index, uint num_regions = 1);\n-  void deactivate_regions(uint start, size_t num_regions);\n+  void expand(uint index, uint num_regions, WorkGang* pretouch_gang = NULL);\n+  void activate_regions(uint index, uint num_regions);\n+  void deactivate_regions(uint start, uint num_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}