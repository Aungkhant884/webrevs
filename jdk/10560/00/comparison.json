{"files":[{"patch":"@@ -406,0 +406,1 @@\n+    $1_MODFILELIST_FIXED := $$($1_MODFILELIST).fixed\n@@ -472,0 +473,6 @@\n+    # Convert the paths in the MODFILELIST file to Windows-style paths\n+    # on Windows. This is needed because javac operates on Windows-style paths\n+    # when running on Windows. On other platforms this just copies the MODFILELIST file.\n+    $$($1_MODFILELIST_FIXED): $$($1_MODFILELIST)\n+\t\t$$(call FixPathFile, $$($1_MODFILELIST), $$($1_MODFILELIST_FIXED))\n+\n@@ -475,1 +482,1 @@\n-        $$($1_MODFILELIST)\n+        $$($1_MODFILELIST_FIXED)\n@@ -480,1 +487,1 @@\n-\t\t        -XDmodifiedInputs=$$($1_MODFILELIST) \\\n+\t\t        -XDmodifiedInputs=$$($1_MODFILELIST_FIXED) \\\n","filename":"make\/common\/JavaCompilation.gmk","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -446,0 +446,7 @@\n+#\n+# FixPathFile is the file version of FixPath. It instead takes a file with paths in $1\n+# and outputs the 'fixed' paths into the file in $2. If the file in $2 already exists\n+# it is overwritten.\n+# On non-Windows platforms this instead does a copy, so that $2 can still be used\n+# as a depenendency of a make rule, instead of having to conditionally depend on\n+# $1 instead, based on the target platform.\n@@ -449,0 +456,2 @@\n+  FixPathFile = \\\n+    $(shell $(FIXPATH_BASE) convert $1 $2)\n@@ -452,0 +461,2 @@\n+  FixPathFile = \\\n+      $(shell $(CP) $1 $2)\n","filename":"make\/common\/MakeBase.gmk","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -157,1 +157,3 @@\n-            Set<String> modified = new HashSet<>(Files.readAllLines(Paths.get(modifiedInputs)));\n+            Set<Path> modified = Files.readAllLines(Paths.get(modifiedInputs)).stream()\n+                                                                              .map(Paths::get)\n+                                                                              .collect(Collectors.toSet());\n@@ -258,1 +260,1 @@\n-            JavaCompiler compiler, Iterable<JavaFileObject> fileObjects, Set<String> modified,\n+            JavaCompiler compiler, Iterable<JavaFileObject> fileObjects, Set<Path> modified,\n@@ -275,0 +277,1 @@\n+                                        .map(Path::toString)\n@@ -278,1 +281,1 @@\n-            if (modified.contains(jfo.getName())) {\n+            if (modified.contains(Path.of(jfo.getName()))) {\n@@ -292,1 +295,1 @@\n-                if (!modified.contains(jfo.getName())) {\n+                if (!modified.contains(Path.of(jfo.getName()))) {\n@@ -323,0 +326,1 @@\n+                                                  .map(Path::toString)\n@@ -882,1 +886,1 @@\n-        private final Set<String> modified;\n+        private final Set<Path> modified;\n@@ -888,1 +892,1 @@\n-                                         Set<String> modified,\n+                                         Set<Path> modified,\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/Depend.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -355,0 +355,15 @@\n+# Treat $1 as name of a file containing paths. Convert those paths to Windows style,\n+# and output them to the file specified by $2.\n+# If the output file already exists, it is overwritten.\n+function convert_file() {\n+  infile=\"$1\"\n+  outfile=\"$2\"\n+  if [[ -e $outfile ]] ; then\n+    rm $outfile\n+  fi\n+  while read line; do\n+    convert_path \"$line\"\n+    echo \"$result\" >> $outfile\n+  done < $infile\n+}\n+\n@@ -501,0 +516,2 @@\n+elif [[ \"$ACTION\" == \"convert\" ]] ; then\n+  convert_file \"$@\"\n","filename":"make\/scripts\/fixpath.sh","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}