{"files":[{"patch":"@@ -603,1 +603,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -606,1 +606,0 @@\n-        \/*package-private*\/\n@@ -608,5 +607,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -615,17 +611,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -647,1 +637,1 @@\n-                    Byte128Mask::defaultMaskReinterpret);\n+                    Byte128Mask::defaultMaskCast);\n@@ -649,1 +639,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -635,1 +635,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -638,1 +638,0 @@\n-        \/*package-private*\/\n@@ -640,5 +639,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -647,17 +643,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -679,1 +669,1 @@\n-                    Byte256Mask::defaultMaskReinterpret);\n+                    Byte256Mask::defaultMaskCast);\n@@ -681,1 +671,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -699,1 +699,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -702,1 +702,0 @@\n-        \/*package-private*\/\n@@ -704,5 +703,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -711,17 +707,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -743,1 +733,1 @@\n-                    Byte512Mask::defaultMaskReinterpret);\n+                    Byte512Mask::defaultMaskCast);\n@@ -745,1 +735,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -590,1 +590,0 @@\n-        \/*package-private*\/\n@@ -592,5 +591,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -599,17 +595,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -631,1 +621,1 @@\n-                    Byte64Mask::defaultMaskReinterpret);\n+                    Byte64Mask::defaultMaskCast);\n@@ -633,1 +623,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -576,1 +576,0 @@\n-        \/*package-private*\/\n@@ -578,5 +577,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -585,17 +581,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -617,1 +607,1 @@\n-                    ByteMaxMask::defaultMaskReinterpret);\n+                    ByteMaxMask::defaultMaskCast);\n@@ -619,1 +609,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -574,1 +574,0 @@\n-        \/*package-private*\/\n@@ -576,5 +575,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -583,17 +579,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -615,1 +605,1 @@\n-                    Double128Mask::defaultMaskReinterpret);\n+                    Double128Mask::defaultMaskCast);\n@@ -617,1 +607,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -578,1 +578,0 @@\n-        \/*package-private*\/\n@@ -580,5 +579,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -587,17 +583,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -619,1 +609,1 @@\n-                    Double256Mask::defaultMaskReinterpret);\n+                    Double256Mask::defaultMaskCast);\n@@ -621,1 +611,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -583,1 +583,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -586,1 +586,0 @@\n-        \/*package-private*\/\n@@ -588,5 +587,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -595,17 +591,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -627,1 +617,1 @@\n-                    Double512Mask::defaultMaskReinterpret);\n+                    Double512Mask::defaultMaskCast);\n@@ -629,1 +619,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -572,1 +572,0 @@\n-        \/*package-private*\/\n@@ -574,5 +573,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -581,17 +577,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -613,1 +603,1 @@\n-                    Double64Mask::defaultMaskReinterpret);\n+                    Double64Mask::defaultMaskCast);\n@@ -615,1 +605,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -571,1 +571,0 @@\n-        \/*package-private*\/\n@@ -573,5 +572,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -580,17 +576,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -612,1 +602,1 @@\n-                    DoubleMaxMask::defaultMaskReinterpret);\n+                    DoubleMaxMask::defaultMaskCast);\n@@ -614,1 +604,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -578,1 +578,0 @@\n-        \/*package-private*\/\n@@ -580,5 +579,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -587,17 +583,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -619,1 +609,1 @@\n-                    Float128Mask::defaultMaskReinterpret);\n+                    Float128Mask::defaultMaskCast);\n@@ -621,1 +611,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -583,1 +583,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -586,1 +586,0 @@\n-        \/*package-private*\/\n@@ -588,5 +587,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -595,17 +591,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -627,1 +617,1 @@\n-                    Float256Mask::defaultMaskReinterpret);\n+                    Float256Mask::defaultMaskCast);\n@@ -629,1 +619,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -602,1 +602,0 @@\n-        \/*package-private*\/\n@@ -604,5 +603,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -611,17 +607,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -643,1 +633,1 @@\n-                    Float512Mask::defaultMaskReinterpret);\n+                    Float512Mask::defaultMaskCast);\n@@ -645,1 +635,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -574,1 +574,0 @@\n-        \/*package-private*\/\n@@ -576,5 +575,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -583,17 +579,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -615,1 +605,1 @@\n-                    Float64Mask::defaultMaskReinterpret);\n+                    Float64Mask::defaultMaskCast);\n@@ -617,1 +607,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -571,1 +571,0 @@\n-        \/*package-private*\/\n@@ -573,5 +572,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -580,17 +576,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -612,1 +602,1 @@\n-                    FloatMaxMask::defaultMaskReinterpret);\n+                    FloatMaxMask::defaultMaskCast);\n@@ -614,1 +604,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -582,1 +582,0 @@\n-        \/*package-private*\/\n@@ -584,5 +583,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -591,17 +587,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -623,1 +613,1 @@\n-                    Int128Mask::defaultMaskReinterpret);\n+                    Int128Mask::defaultMaskCast);\n@@ -625,1 +615,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -590,1 +590,0 @@\n-        \/*package-private*\/\n@@ -592,5 +591,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -599,17 +595,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -631,1 +621,1 @@\n-                    Int256Mask::defaultMaskReinterpret);\n+                    Int256Mask::defaultMaskCast);\n@@ -633,1 +623,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -606,1 +606,0 @@\n-        \/*package-private*\/\n@@ -608,5 +607,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -615,17 +611,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -647,1 +637,1 @@\n-                    Int512Mask::defaultMaskReinterpret);\n+                    Int512Mask::defaultMaskCast);\n@@ -649,1 +639,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -578,1 +578,0 @@\n-        \/*package-private*\/\n@@ -580,5 +579,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -587,17 +583,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -619,1 +609,1 @@\n-                    Int64Mask::defaultMaskReinterpret);\n+                    Int64Mask::defaultMaskCast);\n@@ -621,1 +611,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -576,1 +576,0 @@\n-        \/*package-private*\/\n@@ -578,5 +577,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -585,17 +581,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -617,1 +607,1 @@\n-                    IntMaxMask::defaultMaskReinterpret);\n+                    IntMaxMask::defaultMaskCast);\n@@ -619,1 +609,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -568,1 +568,0 @@\n-        \/*package-private*\/\n@@ -570,5 +569,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -577,17 +573,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -609,1 +599,1 @@\n-                    Long128Mask::defaultMaskReinterpret);\n+                    Long128Mask::defaultMaskCast);\n@@ -611,1 +601,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -572,1 +572,0 @@\n-        \/*package-private*\/\n@@ -574,5 +573,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -581,17 +577,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -613,1 +603,1 @@\n-                    Long256Mask::defaultMaskReinterpret);\n+                    Long256Mask::defaultMaskCast);\n@@ -615,1 +605,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -580,1 +580,0 @@\n-        \/*package-private*\/\n@@ -582,5 +581,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -589,17 +585,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -621,1 +611,1 @@\n-                    Long512Mask::defaultMaskReinterpret);\n+                    Long512Mask::defaultMaskCast);\n@@ -623,1 +613,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -566,1 +566,0 @@\n-        \/*package-private*\/\n@@ -568,5 +567,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -575,17 +571,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -607,1 +597,1 @@\n-                    Long64Mask::defaultMaskReinterpret);\n+                    Long64Mask::defaultMaskCast);\n@@ -609,1 +599,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -566,1 +566,0 @@\n-        \/*package-private*\/\n@@ -568,5 +567,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -575,17 +571,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -607,1 +597,1 @@\n-                    LongMaxMask::defaultMaskReinterpret);\n+                    LongMaxMask::defaultMaskCast);\n@@ -609,1 +599,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -590,1 +590,0 @@\n-        \/*package-private*\/\n@@ -592,5 +591,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -599,17 +595,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -631,1 +621,1 @@\n-                    Short128Mask::defaultMaskReinterpret);\n+                    Short128Mask::defaultMaskCast);\n@@ -633,1 +623,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -606,1 +606,0 @@\n-        \/*package-private*\/\n@@ -608,5 +607,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -615,17 +611,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -647,1 +637,1 @@\n-                    Short256Mask::defaultMaskReinterpret);\n+                    Short256Mask::defaultMaskCast);\n@@ -649,1 +639,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -635,1 +635,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -638,1 +638,0 @@\n-        \/*package-private*\/\n@@ -640,5 +639,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -647,17 +643,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -679,1 +669,1 @@\n-                    Short512Mask::defaultMaskReinterpret);\n+                    Short512Mask::defaultMaskCast);\n@@ -681,1 +671,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -582,1 +582,0 @@\n-        \/*package-private*\/\n@@ -584,5 +583,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -591,17 +587,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -623,1 +613,1 @@\n-                    Short64Mask::defaultMaskReinterpret);\n+                    Short64Mask::defaultMaskCast);\n@@ -625,1 +615,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -576,1 +576,0 @@\n-        \/*package-private*\/\n@@ -578,5 +577,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -585,17 +581,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -617,1 +607,1 @@\n-                    ShortMaxMask::defaultMaskReinterpret);\n+                    ShortMaxMask::defaultMaskCast);\n@@ -619,1 +609,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -846,1 +846,1 @@\n-         * Helper function for all sorts of lane-wise conversions.\n+         * Helper function for lane-wise mask conversions.\n@@ -849,1 +849,0 @@\n-        \/*package-private*\/\n@@ -851,5 +850,2 @@\n-        final <E>\n-        VectorMask<E> defaultMaskReinterpret(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n@@ -858,17 +854,11 @@\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Mask(maskArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n@@ -890,1 +880,1 @@\n-                    $Type$$bits$Mask::defaultMaskReinterpret);\n+                    $Type$$bits$Mask::defaultMaskCast);\n@@ -892,1 +882,1 @@\n-            return this.defaultMaskReinterpret(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"}]}