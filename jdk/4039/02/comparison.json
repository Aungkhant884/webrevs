{"files":[{"patch":"@@ -1385,2 +1385,2 @@\n-  if (is_mask && elem_bt_from != elem_bt_to) {\n-    return false; \/\/ type mismatch\n+  if (is_mask && (type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to))) {\n+    return false; \/\/ elem size mismatch\n@@ -1388,0 +1388,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -602,0 +602,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -604,2 +625,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +629,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte128Mask::defaultMaskCast);\n@@ -624,3 +638,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -634,0 +634,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -636,2 +657,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -640,15 +661,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte256Mask::defaultMaskCast);\n@@ -656,3 +670,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -698,0 +698,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -700,2 +721,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -704,15 +725,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte512Mask::defaultMaskCast);\n@@ -720,3 +734,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -586,0 +586,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -588,2 +609,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -592,15 +613,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte64Mask::defaultMaskCast);\n@@ -608,3 +622,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -572,0 +572,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -574,2 +595,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -578,15 +599,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    ByteMaxMask::defaultMaskCast);\n@@ -594,3 +608,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -570,0 +570,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -572,2 +593,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -576,15 +597,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double128Mask::defaultMaskCast);\n@@ -592,3 +606,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -574,0 +574,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -576,2 +597,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -580,15 +601,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double256Mask::defaultMaskCast);\n@@ -596,3 +610,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -582,0 +582,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -584,2 +605,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -588,15 +609,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double512Mask::defaultMaskCast);\n@@ -604,3 +618,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -568,0 +568,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -570,2 +591,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -574,15 +595,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double64Mask::defaultMaskCast);\n@@ -590,3 +604,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -567,0 +567,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -569,2 +590,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -573,15 +594,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    DoubleMaxMask::defaultMaskCast);\n@@ -589,3 +603,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -574,0 +574,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -576,2 +597,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -580,15 +601,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float128Mask::defaultMaskCast);\n@@ -596,3 +610,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -582,0 +582,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -584,2 +605,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -588,15 +609,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float256Mask::defaultMaskCast);\n@@ -604,3 +618,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -598,0 +598,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -600,2 +621,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -604,15 +625,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float512Mask::defaultMaskCast);\n@@ -620,3 +634,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -570,0 +570,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -572,2 +593,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -576,15 +597,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float64Mask::defaultMaskCast);\n@@ -592,3 +606,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -567,0 +567,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -569,2 +590,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -573,15 +594,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    FloatMaxMask::defaultMaskCast);\n@@ -589,3 +603,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -578,0 +578,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -580,2 +601,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -584,15 +605,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int128Mask::defaultMaskCast);\n@@ -600,3 +614,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -586,0 +586,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -588,2 +609,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -592,15 +613,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int256Mask::defaultMaskCast);\n@@ -608,3 +622,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -602,0 +602,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -604,2 +625,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +629,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int512Mask::defaultMaskCast);\n@@ -624,3 +638,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -574,0 +574,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -576,2 +597,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -580,15 +601,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int64Mask::defaultMaskCast);\n@@ -596,3 +610,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -572,0 +572,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -574,2 +595,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -578,15 +599,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    IntMaxMask::defaultMaskCast);\n@@ -594,3 +608,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -564,0 +564,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -566,2 +587,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -570,15 +591,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long128Mask::defaultMaskCast);\n@@ -586,3 +600,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -568,0 +568,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -570,2 +591,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -574,15 +595,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long256Mask::defaultMaskCast);\n@@ -590,3 +604,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -576,0 +576,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -578,2 +599,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -582,15 +603,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long512Mask::defaultMaskCast);\n@@ -598,3 +612,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -562,0 +562,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -564,2 +585,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -568,15 +589,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long64Mask::defaultMaskCast);\n@@ -584,3 +598,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -562,0 +562,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -564,2 +585,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -568,15 +589,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    LongMaxMask::defaultMaskCast);\n@@ -584,3 +598,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -586,0 +586,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -588,2 +609,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -592,15 +613,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short128Mask::defaultMaskCast);\n@@ -608,3 +622,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -602,0 +602,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -604,2 +625,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +629,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short256Mask::defaultMaskCast);\n@@ -624,3 +638,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -634,0 +634,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -636,2 +657,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -640,15 +661,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short512Mask::defaultMaskCast);\n@@ -656,3 +670,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -578,0 +578,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -580,2 +601,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -584,15 +605,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short64Mask::defaultMaskCast);\n@@ -600,3 +614,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -572,0 +572,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -574,2 +595,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -578,15 +599,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    ShortMaxMask::defaultMaskCast);\n@@ -594,3 +608,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -845,0 +845,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -847,2 +868,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -851,15 +872,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    $Type$$bits$Mask::defaultMaskCast);\n@@ -867,3 +881,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"}]}