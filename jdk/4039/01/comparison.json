{"files":[{"patch":"@@ -1385,2 +1385,2 @@\n-  if (is_mask && elem_bt_from != elem_bt_to) {\n-    return false; \/\/ type mismatch\n+  if (is_mask && (type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to))) {\n+    return false; \/\/ elem size mismatch\n@@ -1388,0 +1388,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -602,0 +602,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -604,2 +626,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +630,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte128Mask::defaultMaskCast);\n@@ -624,3 +639,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -634,0 +634,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -636,2 +658,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -640,15 +662,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte256Mask::defaultMaskCast);\n@@ -656,3 +671,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -698,0 +698,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -700,2 +722,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -704,15 +726,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte512Mask::defaultMaskCast);\n@@ -720,3 +735,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -586,0 +586,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -588,2 +610,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -592,15 +614,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte64Mask::defaultMaskCast);\n@@ -608,3 +623,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -572,0 +572,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -574,2 +596,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -578,15 +600,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    ByteMaxMask::defaultMaskCast);\n@@ -594,3 +609,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -570,0 +570,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -572,2 +594,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -576,15 +598,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double128Mask::defaultMaskCast);\n@@ -592,3 +607,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -574,0 +574,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -576,2 +598,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -580,15 +602,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double256Mask::defaultMaskCast);\n@@ -596,3 +611,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -582,0 +582,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -584,2 +606,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -588,15 +610,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double512Mask::defaultMaskCast);\n@@ -604,3 +619,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -568,0 +568,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -570,2 +592,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -574,15 +596,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double64Mask::defaultMaskCast);\n@@ -590,3 +605,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -567,0 +567,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -569,2 +591,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -573,15 +595,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    DoubleMaxMask::defaultMaskCast);\n@@ -589,3 +604,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -574,0 +574,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -576,2 +598,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -580,15 +602,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float128Mask::defaultMaskCast);\n@@ -596,3 +611,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -582,0 +582,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -584,2 +606,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -588,15 +610,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float256Mask::defaultMaskCast);\n@@ -604,3 +619,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -598,0 +598,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -600,2 +622,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -604,15 +626,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float512Mask::defaultMaskCast);\n@@ -620,3 +635,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -570,0 +570,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -572,2 +594,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -576,15 +598,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float64Mask::defaultMaskCast);\n@@ -592,3 +607,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -567,0 +567,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -569,2 +591,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -573,15 +595,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    FloatMaxMask::defaultMaskCast);\n@@ -589,3 +604,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -578,0 +578,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -580,2 +602,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -584,15 +606,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int128Mask::defaultMaskCast);\n@@ -600,3 +615,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -586,0 +586,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -588,2 +610,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -592,15 +614,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int256Mask::defaultMaskCast);\n@@ -608,3 +623,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -602,0 +602,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -604,2 +626,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +630,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int512Mask::defaultMaskCast);\n@@ -624,3 +639,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -574,0 +574,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -576,2 +598,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -580,15 +602,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int64Mask::defaultMaskCast);\n@@ -596,3 +611,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -572,0 +572,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -574,2 +596,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -578,15 +600,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    IntMaxMask::defaultMaskCast);\n@@ -594,3 +609,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -564,0 +564,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -566,2 +588,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -570,15 +592,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long128Mask::defaultMaskCast);\n@@ -586,3 +601,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -568,0 +568,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -570,2 +592,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -574,15 +596,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long256Mask::defaultMaskCast);\n@@ -590,3 +605,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -576,0 +576,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -578,2 +600,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -582,15 +604,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long512Mask::defaultMaskCast);\n@@ -598,3 +613,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -562,0 +562,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -564,2 +586,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -568,15 +590,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long64Mask::defaultMaskCast);\n@@ -584,3 +599,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -562,0 +562,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -564,2 +586,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -568,15 +590,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    LongMaxMask::defaultMaskCast);\n@@ -584,3 +599,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -586,0 +586,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -588,2 +610,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -592,15 +614,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short128Mask::defaultMaskCast);\n@@ -608,3 +623,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -602,0 +602,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -604,2 +626,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +630,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short256Mask::defaultMaskCast);\n@@ -624,3 +639,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -634,0 +634,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -636,2 +658,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -640,15 +662,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short512Mask::defaultMaskCast);\n@@ -656,3 +671,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -578,0 +578,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -580,2 +602,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -584,15 +606,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short64Mask::defaultMaskCast);\n@@ -600,3 +615,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -572,0 +572,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -574,2 +596,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -578,15 +600,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    ShortMaxMask::defaultMaskCast);\n@@ -594,3 +609,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -845,0 +845,22 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return (\n+                switch (dsp.laneType.switchKey) {\n+                    case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n+                    case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n+                    default                 -> throw new AssertionError(dsp);\n+                }\n+            );\n+        }\n+\n@@ -847,2 +869,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -851,15 +873,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    $Type$$bits$Mask::defaultMaskCast);\n@@ -867,3 +882,1 @@\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return this.defaultMaskCast(species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"}]}