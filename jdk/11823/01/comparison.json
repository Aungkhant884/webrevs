{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -49,1 +48,1 @@\n-    String socket_path;\n+    String socketPath;\n@@ -60,8 +59,3 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(vmid);\n-            if (pid < 1) {\n-                throw new NumberFormatException();\n-            }\n-        } catch (NumberFormatException x) {\n-            throw new AttachNotSupportedException(\"Invalid process identifier: \" + vmid);\n+        int pid = Integer.parseInt(vmid);\n+        if (pid < 1) {\n+            throw new AttachNotSupportedException(\"Invalid process identifier -1\");\n@@ -73,3 +67,3 @@\n-        File socket_file = new File(tmpdir, \".java_pid\" + pid);\n-        socket_path = socket_file.getPath();\n-        if (!socket_file.exists()) {\n+        File socketFile = new File(tmpdir, \".java_pid\" + pid);\n+        socketPath = socketFile.getPath();\n+        if (!socketFile.exists()) {\n@@ -82,1 +76,1 @@\n-                final int delay_step = 100;\n+                final int delayStep = 100;\n@@ -84,1 +78,1 @@\n-                long time_spend = 0;\n+                long timeSpend = 0;\n@@ -88,1 +82,1 @@\n-                    delay += delay_step;\n+                    delay += delayStep;\n@@ -93,2 +87,2 @@\n-                    time_spend += delay;\n-                    if (time_spend > timeout\/2 && !socket_file.exists()) {\n+                    timeSpend += delay;\n+                    if (timeSpend > timeout\/2 && !socketFile.exists()) {\n@@ -98,2 +92,2 @@\n-                } while (time_spend <= timeout && !socket_file.exists());\n-                if (!socket_file.exists()) {\n+                } while (timeSpend <= timeout && !socketFile.exists());\n+                if (!socketFile.exists()) {\n@@ -103,2 +97,2 @@\n-                           \"or HotSpot VM not loaded\", socket_path, pid,\n-                                      time_spend));\n+                           \"or HotSpot VM not loaded\", socketPath, pid,\n+                                      timeSpend));\n@@ -113,1 +107,1 @@\n-        checkPermissions(socket_path);\n+        checkPermissions(socketPath);\n@@ -120,1 +114,1 @@\n-            connect(s, socket_path);\n+            connect(s, socketPath);\n@@ -131,2 +125,2 @@\n-            if (socket_path != null) {\n-                socket_path = null;\n+            if (socketPath != null) {\n+                socketPath = null;\n@@ -140,3 +134,0 @@\n-    \/\/ known errors\n-    private static final int ATTACH_ERROR_BADVERSION = 101;\n-\n@@ -151,1 +142,1 @@\n-            if (socket_path == null) {\n+            if (socketPath == null) {\n@@ -161,1 +152,1 @@\n-            connect(s, socket_path);\n+            connect(s, socketPath);\n@@ -188,14 +179,1 @@\n-        SocketInputStream sis = new SocketInputStream(s);\n-\n-        \/\/ Read the command completion status\n-        int completionStatus;\n-        try {\n-            completionStatus = readInt(sis);\n-        } catch (IOException x) {\n-            sis.close();\n-            if (ioe != null) {\n-                throw ioe;\n-            } else {\n-                throw x;\n-            }\n-        }\n+        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n@@ -203,25 +181,2 @@\n-        if (completionStatus != 0) {\n-            \/\/ read from the stream and use that as the error message\n-            String message = readErrorMessage(sis);\n-            sis.close();\n-\n-            \/\/ In the event of a protocol mismatch then the target VM\n-            \/\/ returns a known error so that we can throw a reasonable\n-            \/\/ error.\n-            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n-                throw new IOException(\"Protocol mismatch with target VM\");\n-            }\n-\n-            \/\/ Special-case the \"load\" command so that the right exception is\n-            \/\/ thrown.\n-            if (cmd.equals(\"load\")) {\n-                String msg = \"Failed to load agent library\";\n-                if (!message.isEmpty())\n-                    msg += \": \" + message;\n-                throw new AgentLoadException(msg);\n-            } else {\n-                if (message.isEmpty())\n-                    message = \"Command failed in target VM\";\n-                throw new AttachOperationFailedException(message);\n-            }\n-        }\n+        \/\/ Process the command completion status\n+        processCompletionStatus(ioe, cmd, sis);\n@@ -236,5 +191,3 @@\n-    private static class SocketInputStream extends InputStream {\n-        int s;\n-\n-        public SocketInputStream(int s) {\n-            this.s = s;\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -243,8 +196,3 @@\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+        @Override\n+        protected int readImpl(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.read((int)fd, bs, off, len);\n@@ -253,16 +201,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0)\n-                return 0;\n-\n-            return VirtualMachineImpl.read(s, bs, off, len);\n-        }\n-\n-        public synchronized void close() throws IOException {\n-            if (s != -1) {\n-                int toClose = s;\n-                s = -1;\n-                VirtualMachineImpl.close(toClose);\n-            }\n+        @Override\n+        protected void closeImpl(long fd) throws IOException {\n+            VirtualMachineImpl.close((int)fd);\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":35,"deletions":100,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -51,1 +50,1 @@\n-    String socket_path;\n+    String socketPath;\n@@ -61,8 +60,3 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(vmid);\n-            if (pid < 1) {\n-                throw new NumberFormatException();\n-            }\n-        } catch (NumberFormatException x) {\n-            throw new AttachNotSupportedException(\"Invalid process identifier: \" + vmid);\n+        int pid = Integer.parseInt(vmid);\n+        if (pid < 1) {\n+            throw new AttachNotSupportedException(\"Invalid process identifier -1\");\n@@ -72,1 +66,1 @@\n-        int ns_pid = getNamespacePid(pid);\n+        int nsPid = getNamespacePid(pid);\n@@ -77,3 +71,3 @@\n-        File socket_file = findSocketFile(pid, ns_pid);\n-        socket_path = socket_file.getPath();\n-        if (!socket_file.exists()) {\n+        File socketFile = findSocketFile(pid, nsPid);\n+        socketPath = socketFile.getPath();\n+        if (!socketFile.exists()) {\n@@ -81,1 +75,1 @@\n-            File f = createAttachFile(pid, ns_pid).getCanonicalFile();\n+            File f = createAttachFile(pid, nsPid).getCanonicalFile();\n@@ -86,1 +80,1 @@\n-                final int delay_step = 100;\n+                final int delayStep = 100;\n@@ -88,1 +82,1 @@\n-                long time_spend = 0;\n+                long timeSpend = 0;\n@@ -92,1 +86,1 @@\n-                    delay += delay_step;\n+                    delay += delayStep;\n@@ -97,2 +91,2 @@\n-                    time_spend += delay;\n-                    if (time_spend > timeout\/2 && !socket_file.exists()) {\n+                    timeSpend += delay;\n+                    if (timeSpend > timeout\/2 && !socketFile.exists()) {\n@@ -102,2 +96,2 @@\n-                } while (time_spend <= timeout && !socket_file.exists());\n-                if (!socket_file.exists()) {\n+                } while (timeSpend <= timeout && !socketFile.exists());\n+                if (!socketFile.exists()) {\n@@ -107,2 +101,2 @@\n-                          \"or HotSpot VM not loaded\", socket_path, pid,\n-                                      time_spend));\n+                          \"or HotSpot VM not loaded\", socketPath, pid,\n+                                      timeSpend));\n@@ -117,1 +111,1 @@\n-        checkPermissions(socket_path);\n+        checkPermissions(socketPath);\n@@ -124,1 +118,1 @@\n-            connect(s, socket_path);\n+            connect(s, socketPath);\n@@ -135,2 +129,2 @@\n-            if (socket_path != null) {\n-                socket_path = null;\n+            if (socketPath != null) {\n+                socketPath = null;\n@@ -144,3 +138,0 @@\n-    \/\/ known errors\n-    private static final int ATTACH_ERROR_BADVERSION = 101;\n-\n@@ -155,1 +146,1 @@\n-            if (socket_path == null) {\n+            if (socketPath == null) {\n@@ -165,1 +156,1 @@\n-            connect(s, socket_path);\n+            connect(s, socketPath);\n@@ -192,14 +183,1 @@\n-        SocketInputStream sis = new SocketInputStream(s);\n-\n-        \/\/ Read the command completion status\n-        int completionStatus;\n-        try {\n-            completionStatus = readInt(sis);\n-        } catch (IOException x) {\n-            sis.close();\n-            if (ioe != null) {\n-                throw ioe;\n-            } else {\n-                throw x;\n-            }\n-        }\n+        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n@@ -207,25 +185,2 @@\n-        if (completionStatus != 0) {\n-            \/\/ read from the stream and use that as the error message\n-            String message = readErrorMessage(sis);\n-            sis.close();\n-\n-            \/\/ In the event of a protocol mismatch then the target VM\n-            \/\/ returns a known error so that we can throw a reasonable\n-            \/\/ error.\n-            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n-                throw new IOException(\"Protocol mismatch with target VM\");\n-            }\n-\n-            \/\/ Special-case the \"load\" command so that the right exception is\n-            \/\/ thrown.\n-            if (cmd.equals(\"load\")) {\n-                String msg = \"Failed to load agent library\";\n-                if (!message.isEmpty())\n-                    msg += \": \" + message;\n-                throw new AgentLoadException(msg);\n-            } else {\n-                if (message.isEmpty())\n-                    message = \"Command failed in target VM\";\n-                throw new AttachOperationFailedException(message);\n-            }\n-        }\n+        \/\/ Process the command completion status\n+        processCompletionStatus(ioe, cmd, sis);\n@@ -240,5 +195,3 @@\n-    private static class SocketInputStream extends InputStream {\n-        int s = -1;\n-\n-        public SocketInputStream(int s) {\n-            this.s = s;\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -247,8 +200,3 @@\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+        @Override\n+        protected int readImpl(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.read((int)fd, bs, off, len);\n@@ -257,17 +205,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0) {\n-                return 0;\n-            }\n-\n-            return VirtualMachineImpl.read(s, bs, off, len);\n-        }\n-\n-        public synchronized void close() throws IOException {\n-            if (s != -1) {\n-                int toClose = s;\n-                s = -1;\n-                VirtualMachineImpl.close(toClose);\n-            }\n+        @Override\n+        protected void closeImpl(long fd) throws IOException {\n+            VirtualMachineImpl.close((int)fd);\n@@ -278,1 +212,1 @@\n-    private File findSocketFile(int pid, int ns_pid) {\n+    private File findSocketFile(int pid, int nsPid) {\n@@ -283,1 +217,1 @@\n-        return new File(root, \".java_pid\" + ns_pid);\n+        return new File(root, \".java_pid\" + nsPid);\n@@ -290,2 +224,2 @@\n-    private File createAttachFile(int pid, int ns_pid) throws IOException {\n-        String fn = \".attach_pid\" + ns_pid;\n+    private File createAttachFile(int pid, int nsPid) throws IOException {\n+        String fn = \".attach_pid\" + nsPid;\n@@ -299,1 +233,1 @@\n-            if (pid != ns_pid) {\n+            if (pid != nsPid) {\n@@ -349,2 +283,2 @@\n-                    int ns_pid = Integer.parseInt(parts[parts.length - 1]);\n-                    return ns_pid;\n+                    int nsPid = Integer.parseInt(parts[parts.length - 1]);\n+                    return nsPid;\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":44,"deletions":110,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -50,1 +49,1 @@\n-    String socket_path;\n+    String socketPath;\n@@ -61,8 +60,3 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(vmid);\n-            if (pid < 1) {\n-                throw new NumberFormatException();\n-            }\n-        } catch (NumberFormatException x) {\n-            throw new AttachNotSupportedException(\"Invalid process identifier: \" + vmid);\n+        int pid = Integer.parseInt(vmid);\n+        if (pid < 1) {\n+            throw new AttachNotSupportedException(\"Invalid process identifier -1\");\n@@ -74,3 +68,3 @@\n-        File socket_file = new File(tmpdir, \".java_pid\" + pid);\n-        socket_path = socket_file.getPath();\n-        if (!socket_file.exists()) {\n+        File socketFile = new File(tmpdir, \".java_pid\" + pid);\n+        socketPath = socketFile.getPath();\n+        if (!socketFile.exists()) {\n@@ -82,1 +76,1 @@\n-                final int delay_step = 100;\n+                final int delayStep = 100;\n@@ -84,1 +78,1 @@\n-                long time_spend = 0;\n+                long timeSpend = 0;\n@@ -88,1 +82,1 @@\n-                    delay += delay_step;\n+                    delay += delayStep;\n@@ -93,2 +87,2 @@\n-                    time_spend += delay;\n-                    if (time_spend > timeout\/2 && !socket_file.exists()) {\n+                    timeSpend += delay;\n+                    if (timeSpend > timeout\/2 && !socketFile.exists()) {\n@@ -98,2 +92,2 @@\n-                } while (time_spend <= timeout && !socket_file.exists());\n-                if (!socket_file.exists()) {\n+                } while (timeSpend <= timeout && !socketFile.exists());\n+                if (!socketFile.exists()) {\n@@ -103,2 +97,2 @@\n-                                      \"or HotSpot VM not loaded\", socket_path,\n-                                      pid, time_spend));\n+                                      \"or HotSpot VM not loaded\", socketPath,\n+                                      pid, timeSpend));\n@@ -113,1 +107,1 @@\n-        checkPermissions(socket_path);\n+        checkPermissions(socketPath);\n@@ -120,1 +114,1 @@\n-            connect(s, socket_path);\n+            connect(s, socketPath);\n@@ -131,2 +125,2 @@\n-            if (socket_path != null) {\n-                socket_path = null;\n+            if (socketPath != null) {\n+                socketPath = null;\n@@ -140,3 +134,0 @@\n-    \/\/ known errors\n-    private static final int ATTACH_ERROR_BADVERSION = 101;\n-\n@@ -151,1 +142,1 @@\n-            if (socket_path == null) {\n+            if (socketPath == null) {\n@@ -161,1 +152,1 @@\n-            connect(s, socket_path);\n+            connect(s, socketPath);\n@@ -188,26 +179,1 @@\n-        SocketInputStream sis = new SocketInputStream(s);\n-\n-        \/\/ Read the command completion status\n-        int completionStatus;\n-        try {\n-            completionStatus = readInt(sis);\n-        } catch (IOException x) {\n-            sis.close();\n-            if (ioe != null) {\n-                throw ioe;\n-            } else {\n-                throw x;\n-            }\n-        }\n-\n-        if (completionStatus != 0) {\n-            \/\/ read from the stream and use that as the error message\n-            String message = readErrorMessage(sis);\n-            sis.close();\n-\n-            \/\/ In the event of a protocol mismatch then the target VM\n-            \/\/ returns a known error so that we can throw a reasonable\n-            \/\/ error.\n-            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n-                throw new IOException(\"Protocol mismatch with target VM\");\n-            }\n+        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n@@ -215,13 +181,2 @@\n-            \/\/ Special-case the \"load\" command so that the right exception is\n-            \/\/ thrown.\n-            if (cmd.equals(\"load\")) {\n-                String msg = \"Failed to load agent library\";\n-                if (!message.isEmpty())\n-                    msg += \": \" + message;\n-                throw new AgentLoadException(msg);\n-            } else {\n-                if (message.isEmpty())\n-                    message = \"Command failed in target VM\";\n-                throw new AttachOperationFailedException(message);\n-            }\n-        }\n+        \/\/ Process the command completion status\n+        processCompletionStatus(ioe, cmd, sis);\n@@ -236,15 +191,3 @@\n-    private static class SocketInputStream extends InputStream {\n-        int s;\n-\n-        public SocketInputStream(int s) {\n-            this.s = s;\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -253,9 +196,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0) {\n-                return 0;\n-            }\n-\n-            return VirtualMachineImpl.read(s, bs, off, len);\n+        @Override\n+        protected int readImpl(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.read((int)fd, bs, off, len);\n@@ -264,6 +201,3 @@\n-        public synchronized void close() throws IOException {\n-            if (s != -1) {\n-                int toClose = s;\n-                s = -1;\n-                VirtualMachineImpl.close(toClose);\n-            }\n+        @Override\n+        protected void closeImpl(long fd) throws IOException {\n+            VirtualMachineImpl.close((int)fd);\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":35,"deletions":101,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.tools.attach.AttachOperationFailedException;\n@@ -186,0 +187,2 @@\n+    \/\/ known error\n+    private static final int ATTACH_ERROR_BADVERSION = 101;\n@@ -369,0 +372,81 @@\n+    void processCompletionStatus(IOException ioe, String cmd, InputStream sis) throws AgentLoadException, IOException {\n+        \/\/ Read the command completion status\n+        int completionStatus;\n+        try {\n+            completionStatus = readInt(sis);\n+        } catch (IOException x) {\n+            sis.close();\n+            if (ioe != null) {\n+                throw ioe;\n+            } else {\n+                throw x;\n+            }\n+        }\n+        if (completionStatus != 0) {\n+            \/\/ read from the stream and use that as the error message\n+            String message = readErrorMessage(sis);\n+            sis.close();\n+\n+            \/\/ In the event of a protocol mismatch then the target VM\n+            \/\/ returns a known error so that we can throw a reasonable\n+            \/\/ error.\n+            if (completionStatus == ATTACH_ERROR_BADVERSION) {\n+                throw new IOException(\"Protocol mismatch with target VM\");\n+            }\n+\n+            \/\/ Special-case the \"load\" command so that the right exception is\n+            \/\/ thrown.\n+            if (cmd.equals(\"load\")) {\n+                String msg = \"Failed to load agent library\";\n+                if (!message.isEmpty()) {\n+                    msg += \": \" + message;\n+                }\n+                throw new AgentLoadException(msg);\n+            } else {\n+                if (message.isEmpty()) {\n+                    message = \"Command failed in target VM\";\n+                }\n+                throw new AttachOperationFailedException(message);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * InputStream for the socket connection to get target VM\n+     *\/\n+    static abstract class SocketInputStream extends InputStream {\n+        private final long fd;\n+\n+        public SocketInputStream(long fd) {\n+            this.fd = fd;\n+        }\n+\n+        protected abstract int readImpl(long fd, byte[] bs, int off, int len) throws IOException;\n+        protected abstract void closeImpl(long fd) throws IOException;\n+\n+        public synchronized int read() throws IOException {\n+            byte b[] = new byte[1];\n+            int n = this.read(b, 0, 1);\n+            if (n == 1) {\n+                return b[0] & 0xff;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n+            if ((off < 0) || (off > bs.length) || (len < 0) ||\n+                ((off + len) > bs.length) || ((off + len) < 0)) {\n+                throw new IndexOutOfBoundsException();\n+            } else if (len == 0) {\n+                return 0;\n+            }\n+            return readImpl(fd, bs, off, len);\n+        }\n+\n+        public synchronized void close() throws IOException {\n+            if (fd != -1) {\n+                closeImpl(fd);\n+            }\n+        }\n+    }\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":85,"deletions":1,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tools.attach.AttachOperationFailedException;\n@@ -36,0 +35,3 @@\n+\/*\n+ * Windows implementation of HotSpotVirtualMachine\n+ *\/\n@@ -48,6 +50,1 @@\n-        int pid;\n-        try {\n-            pid = Integer.parseInt(id);\n-        } catch (NumberFormatException x) {\n-            throw new AttachNotSupportedException(\"Invalid process identifier\");\n-        }\n+        int pid = Integer.parseInt(id);\n@@ -111,20 +108,4 @@\n-            PipedInputStream in = new PipedInputStream(hPipe);\n-\n-            \/\/ read completion status\n-            int status = readInt(in);\n-            if (status != 0) {\n-                \/\/ read from the stream and use that as the error message\n-                String message = readErrorMessage(in);\n-                in.close();\n-                \/\/ special case the load command so that the right exception is thrown\n-                if (cmd.equals(\"load\")) {\n-                    String msg = \"Failed to load agent library\";\n-                    if (!message.isEmpty())\n-                        msg += \": \" + message;\n-                    throw new AgentLoadException(msg);\n-                } else {\n-                    if (message.isEmpty())\n-                        message = \"Command failed in target VM\";\n-                    throw new AttachOperationFailedException(message);\n-                }\n-            }\n+            SocketInputStreamImpl in = new SocketInputStreamImpl(hPipe);\n+\n+            \/\/ Process the command completion status\n+            processCompletionStatus(null, cmd, in);\n@@ -142,16 +123,3 @@\n-    private static class PipedInputStream extends InputStream {\n-\n-        private long hPipe;\n-\n-        public PipedInputStream(long hPipe) {\n-            this.hPipe = hPipe;\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            byte b[] = new byte[1];\n-            int n = this.read(b, 0, 1);\n-            if (n == 1) {\n-                return b[0] & 0xff;\n-            } else {\n-                return -1;\n-            }\n+    private static class SocketInputStreamImpl extends SocketInputStream {\n+        public SocketInputStreamImpl(long fd) {\n+            super(fd);\n@@ -160,8 +128,3 @@\n-        public synchronized int read(byte[] bs, int off, int len) throws IOException {\n-            if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                ((off + len) > bs.length) || ((off + len) < 0)) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (len == 0)\n-                return 0;\n-\n-            return VirtualMachineImpl.readPipe(hPipe, bs, off, len);\n+        @Override\n+        protected int readImpl(long fd, byte[] bs, int off, int len) throws IOException {\n+            return VirtualMachineImpl.readPipe(fd, bs, off, len);\n@@ -170,6 +133,3 @@\n-        public synchronized void close() throws IOException {\n-            if (hPipe != -1) {\n-                long toClose = hPipe;\n-                hPipe = -1;\n-                VirtualMachineImpl.closePipe(toClose);\n-           }\n+        @Override\n+        protected void closeImpl(long fd) throws IOException {\n+            VirtualMachineImpl.closePipe(fd);\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":18,"deletions":58,"binary":false,"changes":76,"status":"modified"}]}