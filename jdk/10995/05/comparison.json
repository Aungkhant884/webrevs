{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import java.io.InputStream;\n-import java.io.IOException;\n@@ -31,0 +29,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -175,2 +176,2 @@\n-     * Returns 0 after EOF has reached for the current entry data,\n-     * otherwise always return 1.\n+     * Returns 0 when end of stream is detected for the current ZIP entry or\n+     * {@link #closeEntry()} has been called on the current ZIP entry, otherwise always return 1.\n@@ -181,1 +182,2 @@\n-     * @return     1 before EOF and 0 after EOF has reached for current entry.\n+     * @return 0 when end of stream is detected for the current ZIP entry or\n+     * {@link #closeEntry()} has been called on the current ZIP entry, otherwise 1.\n@@ -195,1 +197,173 @@\n-     * Reads from the current ZIP entry into an array of bytes, returning the number of\n+     * Reads the next byte of data from the input stream for the current\n+     * ZIP entry. This method will block until enough input is available for\n+     * decompression.\n+     * @return the byte read, or -1 if the end of the stream is reached\n+     * @throws    IOException if an I\/O error has occurred\n+     *\/\n+    @Override\n+    public int read() throws IOException {\n+        return super.read();\n+    }\n+\n+    \/**\n+     * Reads all remaining bytes from the input stream for the current ZIP entry.\n+     * This method blocks until all remaining bytes have been read and end of\n+     * stream is detected, or an exception is thrown. This method does not close\n+     * the input stream.\n+     *\n+     * <p> When this stream reaches end of stream, further invocations of this\n+     * method will return an empty byte array.\n+     *\n+     * <p> Note that this method is intended for simple cases where it is\n+     * convenient to read all bytes into a byte array. It is not intended for\n+     * reading input streams with large amounts of data.\n+     *\n+     * <p> If an I\/O error occurs reading from the input stream, then it may do\n+     * so after some, but not all, bytes have been read. Consequently, the input\n+     * stream may not be at end of stream and may be in an inconsistent state.\n+     * It is strongly recommended that the stream be promptly closed if an I\/O\n+     * error occurs.\n+     *\n+     * @throws OutOfMemoryError {@inheritDoc}\n+     *\n+     * @since 9\n+     *\/\n+    @Override\n+    public byte[] readAllBytes() throws IOException {\n+        return super.readAllBytes();\n+    }\n+\n+    \/**\n+     * Reads up to a specified number of bytes from the input stream\n+     * for the current ZIP entry. This method blocks until the requested number\n+     * of bytes has been read, end of stream is detected, or an exception\n+     * is thrown. This method does not close the input stream.\n+     *\n+     * <p> The length of the returned array equals the number of bytes read\n+     * from the stream. If {@code len} is zero, then no bytes are read and\n+     * an empty byte array is returned. Otherwise, up to {@code len} bytes\n+     * are read from the stream. Fewer than {@code len} bytes may be read if\n+     * end of stream is encountered.\n+     *\n+     * <p> When this stream reaches end of stream, further invocations of this\n+     * method will return an empty byte array.\n+     *\n+     * <p> Note that this method is intended for simple cases where it is\n+     * convenient to read the specified number of bytes into a byte array. The\n+     * total amount of memory allocated by this method is proportional to the\n+     * number of bytes read from the stream which is bounded by {@code len}.\n+     * Therefore, the method may be safely called with very large values of\n+     * {@code len} provided sufficient memory is available.\n+     *\n+     * <p> If an I\/O error occurs reading from the input stream, then it may do\n+     * so after some, but not all, bytes have been read. Consequently, the input\n+     * stream may not be at end of stream and may be in an inconsistent state.\n+     * It is strongly recommended that the stream be promptly closed if an I\/O\n+     * error occurs.\n+     *\n+     * @implNote\n+     * This method calls {@code super.readNBytes(int len)}.\n+     *\n+     *  @throws OutOfMemoryError {@inheritDoc}\n+     *\n+     * @since 11\n+     *\/\n+    @Override\n+    public byte[] readNBytes(int len) throws IOException {\n+        return super.readNBytes(len);\n+    }\n+\n+    \/**\n+     * Reads the requested number of bytes from the input stream into the given\n+     * byte array for the current ZIP entry returning the number of\n+     * inflated bytes.\n+     * This method blocks until {@code len} bytes of input data have\n+     * been read, end of stream is detected, or an exception is thrown. The\n+     * number of bytes actually read, possibly zero, is returned. This method\n+     * does not close the input stream.\n+     *\n+     * <p> In the case where end of stream is reached before {@code len} bytes\n+     * have been read, then the actual number of bytes read will be returned.\n+     * When this stream reaches end of stream, further invocations of this\n+     * method will return zero.\n+     *\n+     * <p> If {@code len} is zero, then no bytes are read and {@code 0} is\n+     * returned; otherwise, there is an attempt to read up to {@code len} bytes.\n+     *\n+     * <p> The first byte read is stored into element {@code b[off]}, the next\n+     * one in to {@code b[off+1]}, and so on. The number of bytes read is, at\n+     * most, equal to {@code len}. Let <i>k<\/i> be the number of bytes actually\n+     * read; these bytes will be stored in elements {@code b[off]} through\n+     * {@code b[off+}<i>k<\/i>{@code -1]}, leaving elements {@code b[off+}<i>k<\/i>\n+     * {@code ]} through {@code b[off+len-1]} unaffected.\n+     *\n+     * <p> If an I\/O error occurs reading from the input stream, then it may do\n+     * so after some, but not all, bytes of {@code b} have been updated with\n+     * data from the input stream. Consequently, the input stream and {@code b}\n+     * may be in an inconsistent state. It is strongly recommended that the\n+     * stream be promptly closed if an I\/O error occurs.\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\n+     * @since 9\n+     *\/\n+    @Override\n+    public int readNBytes(byte[] b, int off, int len) throws IOException {\n+        return super.readNBytes(b, off, len);\n+    }\n+\n+    \/**\n+     * Skips over and discards exactly {@code n} bytes of data from this input\n+     * stream for the current ZIP entry.\n+     * If {@code n} is zero, then no bytes are skipped.\n+     * If {@code n} is negative, then no bytes are skipped.\n+     * Subclasses may handle the negative value differently.\n+     *\n+     * <p> This method blocks until the requested number of bytes has been\n+     * skipped, end of file is reached, or an exception is thrown.\n+     *\n+     * <p> If end of stream is reached before the stream is at the desired\n+     * position, then an {@code EOFException} is thrown.\n+     *\n+     * <p> If an I\/O error occurs, then the input stream may be\n+     * in an inconsistent state. It is strongly recommended that the\n+     * stream be promptly closed if an I\/O error occurs.\n+     *\n+     * @since 12\n+     *\/\n+    @Override\n+    public void skipNBytes(long n) throws IOException {\n+        super.skipNBytes(n);\n+    }\n+\n+    \/**\n+     * Reads all bytes from this input stream for the current ZIP entry\n+     * and writes the bytes to the given output stream in the order that they\n+     * are read. On return, this input stream will be at end of stream.\n+     * This method does not close either stream.\n+     * <p>\n+     * This method may block indefinitely reading from the input stream, or\n+     * writing to the output stream. The behavior for the case where the input\n+     * and\/or output stream is <i>asynchronously closed<\/i>, or the thread\n+     * interrupted during the transfer, is highly input and output stream\n+     * specific, and therefore not specified.\n+     * <p>\n+     * If an I\/O error occurs reading from the input stream or writing to the\n+     * output stream, then it may do so after some bytes have been read or\n+     * written. Consequently, the input stream may not be at end of stream and\n+     * one, or both, streams may be in an inconsistent state. It is strongly\n+     * recommended that both streams be promptly closed if an I\/O error occurs.\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     *\n+     * @since 9\n+     *\/\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        return super.transferTo(out);\n+    }\n+\n+    \/**\n+     * Reads the requested number of bytes from the input stream into the given\n+     * byte array for the current ZIP entry returning the number of\n@@ -270,1 +444,2 @@\n-     * Skips specified number of bytes in the current ZIP entry.\n+     * Skips over and discards {@code n} bytes of data from this input stream\n+     * for the current ZIP entry.\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":182,"deletions":7,"binary":false,"changes":189,"status":"modified"}]}