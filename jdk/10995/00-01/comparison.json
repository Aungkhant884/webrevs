{"files":[{"patch":"@@ -220,4 +220,0 @@\n-     * <p> The behavior for the case where the input stream is <i>asynchronously\n-     * closed<\/i>, or the thread interrupted during the read, is highly input\n-     * stream specific, and therefore not specified.\n-     *\n@@ -261,4 +257,0 @@\n-     * <p> The behavior for the case where the input stream is <i>asynchronously\n-     * closed<\/i>, or the thread interrupted during the read, is highly input\n-     * stream specific, and therefore not specified.\n-     *\n@@ -272,2 +264,1 @@\n-     * The number of bytes allocated to read data from this stream and return\n-     * the result is bounded by {@code 2*(long)len}, inclusive.\n+     * This method calls {@code super.readNBytes(int len)}.\n@@ -307,4 +298,0 @@\n-     * <p> The behavior for the case where the input stream is <i>asynchronously\n-     * closed<\/i>, or the thread interrupted during the read, is highly input\n-     * stream specific, and therefore not specified.\n-     *\n@@ -344,13 +331,0 @@\n-     * @implSpec\n-     * If {@code n} is zero or negative, then no bytes are skipped.\n-     * If {@code n} is positive, the default implementation of this method\n-     * invokes {@link #skip(long) skip()} repeatedly with its parameter equal\n-     * to the remaining number of bytes to skip until the requested number\n-     * of bytes has been skipped or an error condition occurs.  If at any\n-     * point the return value of {@code skip()} is negative or greater than the\n-     * remaining number of bytes to be skipped, then an {@code IOException} is\n-     * thrown.  If {@code skip()} ever returns zero, then {@link #read()} is\n-     * invoked to read a single byte, and if it returns {@code -1}, then an\n-     * {@code EOFException} is thrown.  Any exception thrown by {@code skip()}\n-     * or {@code read()} will be propagated.\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"}]}