{"files":[{"patch":"@@ -509,1 +509,1 @@\n-  if (is_busy()) {\n+  if (is_busy() != 0) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -59,0 +60,25 @@\n+class MonitorList {\n+  ObjectMonitor* volatile _head;\n+  volatile size_t _count;\n+  volatile size_t _max;\n+\n+public:\n+  void add(ObjectMonitor* monitor);\n+  size_t unlink_deflated(Thread* self, LogStream* ls, elapsedTimer* timer_p,\n+                         GrowableArray<ObjectMonitor*>* unlinked_list);\n+  size_t count() const;\n+  size_t max() const;\n+\n+  class Iterator;\n+  Iterator iterator() const;\n+};\n+\n+class MonitorList::Iterator {\n+  ObjectMonitor* _current;\n+\n+public:\n+  Iterator(ObjectMonitor* head) : _current(head) {}\n+  bool has_next() const { return _current != NULL; }\n+  ObjectMonitor* next();\n+};\n+\n@@ -207,1 +233,12 @@\n-MonitorList ObjectSynchronizer::_in_use_list;\n+static MonitorList _in_use_list;\n+\/\/ The ratio of the current _in_use_list count to the ceiling is used\n+\/\/ to determine if we are above MonitorUsedDeflationThreshold and need\n+\/\/ to do an async monitor deflation cycle. The ceiling is increased by\n+\/\/ AvgMonitorsPerThreadEstimate when a thread is added to the system\n+\/\/ and is decreased by AvgMonitorsPerThreadEstimate when a thread is\n+\/\/ removed from the system.\n+\/\/ Note: If the _in_use_list max exceeds the ceiling, then\n+\/\/ monitors_used_above_threshold() will use the in_use_list max instead\n+\/\/ of the thread count derived ceiling because we have used more\n+\/\/ ObjectMonitors than the estimated average.\n+\/\/\n@@ -209,1 +246,1 @@\n-jint ObjectSynchronizer::_in_use_list_ceiling = AvgMonitorsPerThreadEstimate;\n+jint _in_use_list_ceiling = AvgMonitorsPerThreadEstimate;\n@@ -1133,0 +1170,4 @@\n+size_t ObjectSynchronizer::in_use_list_ceiling() {\n+  return (size_t)_in_use_list_ceiling;\n+}\n+\n@@ -1182,1 +1223,3 @@\n-      ThreadBlockInVM tbivm(self->as_Java_thread());\n+      {\n+        ThreadBlockInVM tbivm(self->as_Java_thread());\n+      }\n@@ -1412,2 +1455,4 @@\n-  \/\/ Honor block request.\n-  ThreadBlockInVM tbivm(self);\n+  {\n+    \/\/ Honor block request.\n+    ThreadBlockInVM tbivm(self);\n+  }\n@@ -1631,1 +1676,1 @@\n-\/\/ by the VMThread (at VM exit time).\n+\/\/ by the VMThread at VM exit time.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":51,"deletions":6,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -35,0 +34,1 @@\n+class LogStream;\n@@ -38,25 +38,0 @@\n-class MonitorList {\n-  ObjectMonitor* volatile _head;\n-  volatile size_t _count;\n-  volatile size_t _max;\n-\n-public:\n-  void add(ObjectMonitor* monitor);\n-  size_t unlink_deflated(Thread* self, LogStream* ls, elapsedTimer* timer_p,\n-                         GrowableArray<ObjectMonitor*>* unlinked_list);\n-  size_t count() const;\n-  size_t max() const;\n-\n-  class Iterator;\n-  Iterator iterator() const;\n-};\n-\n-class MonitorList::Iterator {\n-  ObjectMonitor* _current;\n-\n-public:\n-  Iterator(ObjectMonitor* head) : _current(head) {}\n-  bool has_next() const { return _current != NULL; }\n-  ObjectMonitor* next();\n-};\n-\n@@ -152,1 +127,1 @@\n-  static size_t in_use_list_ceiling() { return (size_t)_in_use_list_ceiling; }\n+  static size_t in_use_list_ceiling();\n@@ -175,12 +150,0 @@\n-  static MonitorList   _in_use_list;\n-  \/\/ The ratio of the current _in_use_list count to the ceiling is used\n-  \/\/ to determine if we are above MonitorUsedDeflationThreshold and need\n-  \/\/ to do an async monitor deflation cycle. The ceiling is increased by\n-  \/\/ AvgMonitorsPerThreadEstimate when a thread is added to the system\n-  \/\/ and is decreased by AvgMonitorsPerThreadEstimate when a thread is\n-  \/\/ removed from the system.\n-  \/\/ Note: If the _in_use_list max exceeds the ceiling, then\n-  \/\/ monitors_used_above_threshold() will use the in_use_list max instead\n-  \/\/ of the thread count derived ceiling because we have used more\n-  \/\/ ObjectMonitors than the estimated average.\n-  static jint          _in_use_list_ceiling;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"}]}