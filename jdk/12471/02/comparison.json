{"files":[{"patch":"@@ -44,1 +44,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -66,2 +65,3 @@\n-class IsAliveClosure: public BoolObjectClosure {\n-  Generation* _young_gen;\n+class ScavengeHelper {\n+  DefNewGeneration* _young_gen;\n+  HeapWord*         _young_gen_end;\n@@ -69,3 +69,6 @@\n-  IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {\n-    assert(_young_gen->kind() == Generation::DefNew,\n-        \"Expected the young generation here\");\n+  ScavengeHelper(DefNewGeneration* young_gen) :\n+    _young_gen(young_gen),\n+    _young_gen_end(young_gen->reserved().end()) {}\n+\n+  bool is_in_young_gen(void* p) const {\n+    return p < _young_gen_end;\n@@ -74,2 +77,16 @@\n-  bool do_object_b(oop p) {\n-    return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n+  template <typename T, typename Func>\n+  void try_scavenge(T* p, Func&& f) {\n+    T heap_oop = RawAccess<>::oop_load(p);\n+    \/\/ Should we copy the obj?\n+    if (!CompressedOops::is_null(heap_oop)) {\n+      oop obj = CompressedOops::decode_not_null(heap_oop);\n+      if (is_in_young_gen(obj)) {\n+        assert(!_young_gen->to()->is_in_reserved(obj), \"Scanning field twice?\");\n+        oop new_obj = obj->is_forwarded() ? obj->forwardee()\n+                                          : _young_gen->copy_to_survivor_space(obj);\n+        RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+\n+        \/\/ callback\n+        f(new_obj);\n+      }\n+    }\n@@ -79,2 +96,33 @@\n-class KeepAliveClosure: public OopClosure {\n-  ScanWeakRefClosure* _cl;\n+class InHeapScanClosure : public BasicOopIterateClosure {\n+  ScavengeHelper _helper;\n+protected:\n+  bool is_in_young_gen(void* p) const {\n+    return _helper.is_in_young_gen(p);\n+  }\n+\n+  template <typename T, typename Func>\n+  void try_scavenge(T* p, Func&& f) {\n+    _helper.try_scavenge(p, f);\n+  }\n+\n+  InHeapScanClosure(DefNewGeneration* young_gen) :\n+    BasicOopIterateClosure(young_gen->ref_processor()),\n+    _helper(young_gen) {}\n+};\n+\n+class OffHeapScanClosure : public OopClosure {\n+  ScavengeHelper _helper;\n+protected:\n+  bool is_in_young_gen(void* p) const {\n+    return _helper.is_in_young_gen(p);\n+  }\n+\n+  template <typename T, typename Func>\n+  void try_scavenge(T* p, Func&& f) {\n+    _helper.try_scavenge(p, f);\n+  }\n+\n+  OffHeapScanClosure(DefNewGeneration* young_gen) :  _helper(young_gen) {}\n+};\n+\n+class OldGenScanClosure : public InHeapScanClosure {\n@@ -82,1 +130,0 @@\n-  HeapWord* _boundary;\n@@ -84,8 +131,77 @@\n-  template <class T>\n-  inline void do_oop_work(T* p) {\n-#ifdef ASSERT\n-    {\n-      \/\/ We never expect to see a null reference being processed\n-      \/\/ as a weak reference.\n-      oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-      assert (oopDesc::is_oop(obj), \"expected an oop while scanning weak refs\");\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    assert(!is_in_young_gen(p), \"precondition\");\n+\n+    try_scavenge(p, [&] (oop new_obj) {\n+      \/\/ If p points to a younger generation, mark the card.\n+      if (is_in_young_gen(new_obj)) {\n+        _rs->inline_write_ref_field_gc(p);\n+      }\n+    });\n+  }\n+public:\n+  OldGenScanClosure(DefNewGeneration* g) : InHeapScanClosure(g),\n+    _rs(SerialHeap::heap()->rem_set()) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n+class PromoteFailureClosure : public InHeapScanClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    assert(is_in_young_gen(p), \"promote-fail objs must be in young-gen\");\n+    assert(!SerialHeap::heap()->young_gen()->to()->is_in_reserved(p), \"must not be in to-space\");\n+\n+    try_scavenge(p, [] (auto) {});\n+  }\n+public:\n+  PromoteFailureClosure(DefNewGeneration* g) : InHeapScanClosure(g) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n+class YoungGenScanClosure : public InHeapScanClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    assert(SerialHeap::heap()->young_gen()->to()->is_in_reserved(p), \"precondition\");\n+\n+    try_scavenge(p, [] (auto) {});\n+  }\n+public:\n+  YoungGenScanClosure(DefNewGeneration* g) : InHeapScanClosure(g) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n+class RootScanClosure : public OffHeapScanClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    assert(!SerialHeap::heap()->is_in_reserved(p), \"outside the heap\");\n+\n+    try_scavenge(p,  [] (auto) {});\n+  }\n+public:\n+  RootScanClosure(DefNewGeneration* g) : OffHeapScanClosure(g) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n+class CLDScanClosure: public CLDClosure {\n+\n+  class CLDOopClosure : public OffHeapScanClosure {\n+    ClassLoaderData* _scanned_cld;\n+\n+    template <typename T>\n+    void do_oop_work(T* p) {\n+      assert(!SerialHeap::heap()->is_in_reserved(p), \"outside the heap\");\n+\n+      try_scavenge(p, [&] (oop new_obj) {\n+        assert(_scanned_cld != nullptr, \"inv\");\n+        if (is_in_young_gen(new_obj) && !_scanned_cld->has_modified_oops()) {\n+          _scanned_cld->record_modified_oops();\n+        }\n+      });\n@@ -93,1 +209,0 @@\n-#endif \/\/ ASSERT\n@@ -95,1 +210,3 @@\n-    Devirtualizer::do_oop(_cl, p);\n+  public:\n+    CLDOopClosure(DefNewGeneration* g) : OffHeapScanClosure(g),\n+      _scanned_cld(nullptr) {}\n@@ -97,6 +214,26 @@\n-    \/\/ Optimized for Defnew generation if it's the youngest generation:\n-    \/\/ we set a younger_gen card if we have an older->youngest\n-    \/\/ generation pointer.\n-    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-    if ((cast_from_oop<HeapWord*>(obj) < _boundary) && GenCollectedHeap::heap()->is_in_reserved(p)) {\n-      _rs->inline_write_ref_field_gc(p);\n+    void set_scanned_cld(ClassLoaderData* cld) {\n+      assert(cld == nullptr || _scanned_cld == nullptr, \"Must be\");\n+      _scanned_cld = cld;\n+    }\n+\n+    void do_oop(oop* p)       { do_oop_work(p); }\n+    void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+  };\n+\n+  CLDOopClosure _oop_closure;\n+ public:\n+  CLDScanClosure(DefNewGeneration* g) : _oop_closure(g) {}\n+\n+  void do_cld(ClassLoaderData* cld) {\n+    \/\/ If the cld has not been dirtied we know that there's\n+    \/\/ no references into  the young gen and we can skip it.\n+    if (cld->has_modified_oops()) {\n+\n+      \/\/ Tell the closure which CLD is being scanned so that it can be dirtied\n+      \/\/ if oops are left pointing into the young gen.\n+      _oop_closure.set_scanned_cld(cld);\n+\n+      \/\/ Clean the cld since we're going to scavenge all the metadata.\n+      cld->oops_do(&_oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n+\n+      _oop_closure.set_scanned_cld(nullptr);\n@@ -105,0 +242,1 @@\n+};\n@@ -106,0 +244,2 @@\n+class IsAliveClosure: public BoolObjectClosure {\n+  HeapWord*         _young_gen_end;\n@@ -107,4 +247,4 @@\n-  KeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :\n-    _cl(cl) {\n-    _rs = GenCollectedHeap::heap()->rem_set();\n-    _boundary = g->reserved().end();\n+  IsAliveClosure(DefNewGeneration* g): _young_gen_end(g->reserved().end()) {}\n+\n+  bool do_object_b(oop p) {\n+    return cast_from_oop<HeapWord*>(p) >= _young_gen_end || p->is_forwarded();\n@@ -112,0 +252,51 @@\n+};\n+\n+class AdjustWeakRootClosure: public OffHeapScanClosure {\n+  template <class T>\n+  void do_oop_work(T* p) {\n+    DEBUG_ONLY(SerialHeap* heap = SerialHeap::heap();)\n+    assert(!heap->is_in_reserved(p), \"outside the heap\");\n+\n+    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    if (is_in_young_gen(obj)) {\n+      assert(!heap->young_gen()->to()->is_in_reserved(obj), \"inv\");\n+      assert(obj->is_forwarded(), \"forwarded before weak-root-processing\");\n+      oop new_obj = obj->forwardee();\n+      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+    }\n+  }\n+ public:\n+  AdjustWeakRootClosure(DefNewGeneration* g): OffHeapScanClosure(g) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+};\n+\n+class KeepAliveClosure: public OopClosure {\n+  DefNewGeneration* _young_gen;\n+  HeapWord*         _young_gen_end;\n+  CardTableRS* _rs;\n+\n+  bool is_in_young_gen(void* p) const {\n+    return p < _young_gen_end;\n+  }\n+\n+  template <class T>\n+  void do_oop_work(T* p) {\n+    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n+\n+    if (is_in_young_gen(obj)) {\n+      oop new_obj = obj->is_forwarded() ? obj->forwardee()\n+                                        : _young_gen->copy_to_survivor_space(obj);\n+      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+\n+      if (is_in_young_gen(new_obj) && !is_in_young_gen(p)) {\n+        _rs->inline_write_ref_field_gc(p);\n+      }\n+    }\n+  }\n+public:\n+  KeepAliveClosure(DefNewGeneration* g) :\n+    _young_gen(g),\n+    _young_gen_end(g->reserved().end()),\n+    _rs(SerialHeap::heap()->rem_set()) {}\n@@ -119,2 +310,2 @@\n-  DefNewScanClosure* _scan_cur_or_nonheap;\n-  DefNewYoungerGenClosure* _scan_older;\n+  YoungGenScanClosure* _young_cl;\n+  OldGenScanClosure* _old_cl;\n@@ -123,3 +314,3 @@\n-                               DefNewScanClosure* cur,\n-                               DefNewYoungerGenClosure* older) :\n-    _heap(heap), _scan_cur_or_nonheap(cur), _scan_older(older)\n+                               YoungGenScanClosure* young_cl,\n+                               OldGenScanClosure* old_cl) :\n+    _heap(heap), _young_cl(young_cl), _old_cl(old_cl)\n@@ -130,1 +321,1 @@\n-      _heap->oop_since_save_marks_iterate(_scan_cur_or_nonheap, _scan_older);\n+      _heap->oop_since_save_marks_iterate(_young_cl, _old_cl);\n@@ -136,28 +327,0 @@\n-void CLDScanClosure::do_cld(ClassLoaderData* cld) {\n-  NOT_PRODUCT(ResourceMark rm);\n-  log_develop_trace(gc, scavenge)(\"CLDScanClosure::do_cld \" PTR_FORMAT \", %s, dirty: %s\",\n-                                  p2i(cld),\n-                                  cld->loader_name_and_id(),\n-                                  cld->has_modified_oops() ? \"true\" : \"false\");\n-\n-  \/\/ If the cld has not been dirtied we know that there's\n-  \/\/ no references into  the young gen and we can skip it.\n-  if (cld->has_modified_oops()) {\n-\n-    \/\/ Tell the closure which CLD is being scanned so that it can be dirtied\n-    \/\/ if oops are left pointing into the young gen.\n-    _scavenge_closure->set_scanned_cld(cld);\n-\n-    \/\/ Clean the cld since we're going to scavenge all the metadata.\n-    cld->oops_do(_scavenge_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n-\n-    _scavenge_closure->set_scanned_cld(nullptr);\n-  }\n-}\n-\n-ScanWeakRefClosure::ScanWeakRefClosure(DefNewGeneration* g) :\n-  _g(g)\n-{\n-  _boundary = _g->reserved().end();\n-}\n-\n@@ -579,1 +742,0 @@\n-  ScanWeakRefClosure scan_weak_ref(this);\n@@ -589,2 +751,2 @@\n-  DefNewScanClosure       scan_closure(this);\n-  DefNewYoungerGenClosure younger_gen_closure(this, _old_gen);\n+  YoungGenScanClosure young_gen_cl(this);\n+  OldGenScanClosure   old_gen_cl(this);\n@@ -592,3 +754,0 @@\n-  CLDScanClosure cld_scan_closure(&scan_closure);\n-\n-  set_promo_failure_scan_stack_closure(&scan_closure);\n@@ -596,2 +755,2 @@\n-                                                  &scan_closure,\n-                                                  &younger_gen_closure);\n+                                                  &young_gen_cl,\n+                                                  &old_gen_cl);\n@@ -604,0 +763,2 @@\n+    RootScanClosure root_cl{this};\n+    CLDScanClosure cld_scan_closure{this};\n@@ -605,2 +766,2 @@\n-    heap->young_process_roots(&scan_closure,\n-                              &younger_gen_closure,\n+    heap->young_process_roots(&root_cl,\n+                              &old_gen_cl,\n@@ -613,9 +774,11 @@\n-  KeepAliveClosure keep_alive(this, &scan_weak_ref);\n-  ReferenceProcessor* rp = ref_processor();\n-  ReferenceProcessorPhaseTimes pt(_gc_timer, rp->max_num_queues());\n-  SerialGCRefProcProxyTask task(is_alive, keep_alive, evacuate_followers);\n-  const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n-  _gc_tracer->report_gc_reference_stats(stats);\n-  _gc_tracer->report_tenuring_threshold(tenuring_threshold());\n-  pt.print_all_references();\n-\n+  {\n+    \/\/ Reference processing\n+    KeepAliveClosure keep_alive(this);\n+    ReferenceProcessor* rp = ref_processor();\n+    ReferenceProcessorPhaseTimes pt(_gc_timer, rp->max_num_queues());\n+    SerialGCRefProcProxyTask task(is_alive, keep_alive, evacuate_followers);\n+    const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n+    _gc_tracer->report_gc_reference_stats(stats);\n+    _gc_tracer->report_tenuring_threshold(tenuring_threshold());\n+    pt.print_all_references();\n+  }\n@@ -624,1 +787,4 @@\n-  WeakProcessor::weak_oops_do(&is_alive, &keep_alive);\n+  {\n+    AdjustWeakRootClosure cl{this};\n+    WeakProcessor::weak_oops_do(&is_alive, &cl);\n+  }\n@@ -786,0 +952,1 @@\n+  PromoteFailureClosure cl{this};\n@@ -788,1 +955,1 @@\n-     obj->oop_iterate(_promo_failure_scan_stack_closure);\n+     obj->oop_iterate(&cl);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":253,"deletions":86,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-class DefNewYoungerGenClosure;\n-class DefNewScanClosure;\n+class OldGenScanClosure;\n+class YoungGenScanClosure;\n@@ -103,6 +103,0 @@\n-  \/\/ Promotion failure handling\n-  OopIterateClosure *_promo_failure_scan_stack_closure;\n-  void set_promo_failure_scan_stack_closure(OopIterateClosure *scan_stack_closure) {\n-    _promo_failure_scan_stack_closure = scan_stack_closure;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/cardTableRS.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-void SerialHeap::young_process_roots(OopIterateClosure* root_closure,\n+void SerialHeap::young_process_roots(OopClosure* root_closure,\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  void young_process_roots(OopIterateClosure* root_closure,\n+  void young_process_roots(OopClosure* root_closure,\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/cardTableRS.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_GENOOPCLOSURES_HPP\n-#define SHARE_GC_SHARED_GENOOPCLOSURES_HPP\n-\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-class Generation;\n-class CardTableRS;\n-class CardTableBarrierSet;\n-class DefNewGeneration;\n-class Method;\n-class nmethod;\n-\n-#if INCLUDE_SERIALGC\n-\n-\/\/ Super closure class for scanning DefNewGeneration.\n-\/\/\n-\/\/ - Derived: The derived type provides necessary barrier\n-\/\/            after an oop has been updated.\n-template <typename Derived>\n-class FastScanClosure : public BasicOopIterateClosure {\n-private:\n-  DefNewGeneration* _young_gen;\n-  HeapWord*         _young_gen_end;\n-\n-  template <typename T>\n-  void do_oop_work(T* p);\n-\n-protected:\n-  FastScanClosure(DefNewGeneration* g);\n-\n-public:\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n-\n-\/\/ Closure for scanning DefNewGeneration when iterating over the old generation.\n-\/\/\n-\/\/ This closure performs barrier store calls on pointers into the DefNewGeneration.\n-class DefNewYoungerGenClosure : public FastScanClosure<DefNewYoungerGenClosure> {\n-private:\n-  Generation*  _old_gen;\n-  HeapWord*    _old_gen_start;\n-  CardTableRS* _rs;\n-\n-public:\n-  DefNewYoungerGenClosure(DefNewGeneration* young_gen, Generation* old_gen);\n-\n-  template <typename T>\n-  void barrier(T* p);\n-};\n-\n-\/\/ Closure for scanning DefNewGeneration when *not* iterating over the old generation.\n-\/\/\n-\/\/ This closures records changes to oops in CLDs.\n-class DefNewScanClosure : public FastScanClosure<DefNewScanClosure> {\n-  ClassLoaderData* _scanned_cld;\n-\n-public:\n-  DefNewScanClosure(DefNewGeneration* g);\n-\n-  void set_scanned_cld(ClassLoaderData* cld) {\n-    assert(cld == nullptr || _scanned_cld == nullptr, \"Must be\");\n-    _scanned_cld = cld;\n-  }\n-\n-  template <typename T>\n-  void barrier(T* p);\n-};\n-\n-class CLDScanClosure: public CLDClosure {\n-  DefNewScanClosure* _scavenge_closure;\n- public:\n-  CLDScanClosure(DefNewScanClosure* scavenge_closure) :\n-       _scavenge_closure(scavenge_closure) {}\n-  void do_cld(ClassLoaderData* cld);\n-};\n-\n-\/\/ Closure for scanning DefNewGeneration's weak references.\n-\/\/  -- weak references are processed all at once,\n-\/\/  with no notion of which generation they were in.\n-class ScanWeakRefClosure: public OopClosure {\n- protected:\n-  DefNewGeneration* _g;\n-  HeapWord*         _boundary;\n-  template <class T> inline void do_oop_work(T* p);\n- public:\n-  ScanWeakRefClosure(DefNewGeneration* g);\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n-\n-#endif \/\/ INCLUDE_SERIALGC\n-\n-#endif \/\/ SHARE_GC_SHARED_GENOOPCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.hpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP\n-#define SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP\n-\n-#include \"gc\/shared\/genOopClosures.hpp\"\n-\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"gc\/shared\/cardTableRS.hpp\"\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n-#include \"gc\/shared\/generation.hpp\"\n-#include \"gc\/shared\/space.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#if INCLUDE_SERIALGC\n-#include \"gc\/serial\/defNewGeneration.inline.hpp\"\n-#endif\n-\n-#if INCLUDE_SERIALGC\n-\n-template <typename Derived>\n-inline FastScanClosure<Derived>::FastScanClosure(DefNewGeneration* g) :\n-    BasicOopIterateClosure(g->ref_processor()),\n-    _young_gen(g),\n-    _young_gen_end(g->reserved().end()) {}\n-\n-template <typename Derived>\n-template <typename T>\n-inline void FastScanClosure<Derived>::do_oop_work(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  \/\/ Should we copy the obj?\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (cast_from_oop<HeapWord*>(obj) < _young_gen_end) {\n-      assert(!_young_gen->to()->is_in_reserved(obj), \"Scanning field twice?\");\n-      oop new_obj = obj->is_forwarded() ? obj->forwardee()\n-                                        : _young_gen->copy_to_survivor_space(obj);\n-      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-\n-      static_cast<Derived*>(this)->barrier(p);\n-    }\n-  }\n-}\n-\n-template <typename Derived>\n-inline void FastScanClosure<Derived>::do_oop(oop* p)       { do_oop_work(p); }\n-template <typename Derived>\n-inline void FastScanClosure<Derived>::do_oop(narrowOop* p) { do_oop_work(p); }\n-\n-inline DefNewYoungerGenClosure::DefNewYoungerGenClosure(DefNewGeneration* young_gen, Generation* old_gen) :\n-    FastScanClosure<DefNewYoungerGenClosure>(young_gen),\n-    _old_gen(old_gen),\n-    _old_gen_start(old_gen->reserved().start()),\n-    _rs(GenCollectedHeap::heap()->rem_set()) {}\n-\n-template <typename T>\n-void DefNewYoungerGenClosure::barrier(T* p) {\n-  assert(_old_gen->is_in_reserved(p), \"expected ref in generation\");\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  assert(!CompressedOops::is_null(heap_oop), \"expected non-null oop\");\n-  oop obj = CompressedOops::decode_not_null(heap_oop);\n-  \/\/ If p points to a younger generation, mark the card.\n-  if (cast_from_oop<HeapWord*>(obj) < _old_gen_start) {\n-    _rs->inline_write_ref_field_gc(p);\n-  }\n-}\n-\n-inline DefNewScanClosure::DefNewScanClosure(DefNewGeneration* g) :\n-    FastScanClosure<DefNewScanClosure>(g), _scanned_cld(nullptr) {}\n-\n-template <class T>\n-void DefNewScanClosure::barrier(T* p) {\n-  if (_scanned_cld != nullptr && !_scanned_cld->has_modified_oops()) {\n-    _scanned_cld->record_modified_oops();\n-  }\n-}\n-\n-\/\/ Note similarity to FastScanClosure; the difference is that\n-\/\/ the barrier set is taken care of outside this closure.\n-template <class T> inline void ScanWeakRefClosure::do_oop_work(T* p) {\n-  oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-  \/\/ weak references are sometimes scanned twice; must check\n-  \/\/ that to-space doesn't already contain this object\n-  if (cast_from_oop<HeapWord*>(obj) < _boundary && !_g->to()->is_in_reserved(obj)) {\n-    oop new_obj = obj->is_forwarded() ? obj->forwardee()\n-                                      : _g->copy_to_survivor_space(obj);\n-    RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-  }\n-}\n-\n-inline void ScanWeakRefClosure::do_oop(oop* p)       { ScanWeakRefClosure::do_oop_work(p); }\n-inline void ScanWeakRefClosure::do_oop(narrowOop* p) { ScanWeakRefClosure::do_oop_work(p); }\n-\n-#endif \/\/ INCLUDE_SERIALGC\n-\n-#endif \/\/ SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.inline.hpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}