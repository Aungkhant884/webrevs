{"files":[{"patch":"@@ -521,2 +521,1 @@\n-              if (searchAllSourceNames(env, clazz,\n-                           desiredNamePattern) != 1) {\n+              if (searchAllSourceNames(env, clazz, desiredNamePattern) != 1) {\n@@ -946,1 +945,0 @@\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventFilter.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n- * events, METHOD_ENTRY is  always reported first and BREAKPOINT\n+ * events, METHOD_ENTRY is always reported first and BREAKPOINT\n@@ -537,1 +537,2 @@\n-\/* The JVMTI generic event callback. Each event is passed to a sequence of\n+\/*\n+ * The JVMTI generic event callback. Each event is passed to a sequence of\n@@ -548,0 +549,1 @@\n+    EventIndex ei = evinfo->ei;\n@@ -549,1 +551,1 @@\n-    LOG_MISC((\"event_callback(): ei=%s\", eventText(evinfo->ei)));\n+    LOG_MISC((\"event_callback(): ei=%s\", eventText(ei)));\n@@ -605,2 +607,1 @@\n-        eventBag = threadControl_onEventHandlerEntry(eventSessionID,\n-                                 evinfo->ei, thread, currentException);\n+        eventBag = threadControl_onEventHandlerEntry(eventSessionID, evinfo, currentException);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1048,1 +1048,1 @@\n-                         struct bag *eventBag)\n+                        struct bag *eventBag)\n@@ -1053,1 +1053,1 @@\n-        EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,\"badAdd(eventBag)\");\n+        EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,\"bagAdd(eventBag)\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHelper.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+\/* HandlerFunction - Invoked from event_callback() *\/\n@@ -78,0 +79,1 @@\n+\/* HandlerFunction - Invoked from event_callback() *\/\n@@ -86,0 +88,1 @@\n+\/* HandlerFunction - Invoked from event_callback() for METHOD_ENTRY and METHOD_EXIT. *\/\n@@ -125,0 +128,1 @@\n+\/* HandlerFunction - Invoked from event_callback() *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/standardHandlers.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,12 +344,15 @@\n-        } else if (step->methodEnterHandlerNode != NULL &&\n-                   fromDepth >= afterPopDepth) {\n-            \/*\n-             * We installed a method entry event handler as part of a\n-             * step into operation. We've popped back to the original\n-             * stepping frame without finding a place to stop.\n-             * Resume stepping in the original frame.\n-             *\/\n-            LOG_STEP((\"handleFramePopEvent: starting singlestep, have methodEnter handler && depth==OUT && fromDepth >= afterPopDepth (%d>%d)\",fromDepth, afterPopDepth));\n-            enableStepping(thread);\n-            (void)eventHandler_free(step->methodEnterHandlerNode);\n-            step->methodEnterHandlerNode = NULL;\n+        } else if (step->methodEnterHandlerNode != NULL) {\n+            \/* We installed a method entry event handler as part of a step into operation. *\/\n+            JDI_ASSERT(step->depth == JDWP_STEP_DEPTH(INTO));\n+            if (fromDepth >= afterPopDepth) {\n+                \/*\n+                 * We've popped back to the original stepping frame without finding a place to stop.\n+                 * Resume stepping in the original frame.\n+                 *\/\n+                LOG_STEP((\"handleFramePopEvent: starting singlestep, have methodEnter handler && depth==INTO && fromDepth >= afterPopDepth (%d>=%d)\", fromDepth, afterPopDepth));\n+                enableStepping(thread);\n+                (void)eventHandler_free(step->methodEnterHandlerNode);\n+                step->methodEnterHandlerNode = NULL;\n+            } else {\n+                LOG_STEP((\"handleFramePopEvent: starting singlestep, have methodEnter handler && depth==INTO && fromDepth < afterPopDepth (%d<%d)\", fromDepth, afterPopDepth));\n+            }\n@@ -606,0 +609,2 @@\n+            LOG_STEP((\"stepControl_handleStep: NotifyFramePop (fromDepth=%d currentDepth=%d)\",\n+                      fromDepth, currentDepth));\n@@ -742,0 +747,1 @@\n+        JDI_ASSERT(step->framePopHandlerNode == NULL);\n@@ -796,1 +802,1 @@\n-                        thread, size, depth));\n+              thread, size, depth));\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+ *\n+ * See comment above deferEventReport() for an explanation of co-located events.\n@@ -66,5 +68,5 @@\n-    unsigned int toBeResumed : 1;\n-    unsigned int pendingInterrupt : 1;\n-    unsigned int isDebugThread : 1;\n-    unsigned int suspendOnStart : 1;\n-    unsigned int isStarted : 1;\n+    unsigned int toBeResumed : 1;      \/* true if this thread was successfully suspended. *\/\n+    unsigned int pendingInterrupt : 1; \/* true if thread is interrupted while handling an event. *\/\n+    unsigned int isDebugThread : 1;    \/* true if this is one of our debug agent threads. *\/\n+    unsigned int suspendOnStart : 1;   \/* true for new threads if we are currently in a VM.suspend(). *\/\n+    unsigned int isStarted : 1;        \/* THREAD_START or VIRTUAL_THREAD_SCHEDULED event received. *\/\n@@ -74,2 +76,2 @@\n-    EventIndex current_ei;\n-    jobject pendingStop;\n+    EventIndex current_ei; \/* Used to determine if we are currently handling an event on this thread. *\/\n+    jobject pendingStop;   \/* Object we are throwing to stop the thread (ThreadReferenceImpl.stop). *\/\n@@ -81,2 +83,2 @@\n-    struct bag *eventBag;\n-    CoLocatedEventInfo cleInfo;\n+    struct bag *eventBag;       \/* Accumulation of JDWP events to be sent as a reply. *\/\n+    CoLocatedEventInfo cleInfo; \/* See comment above deferEventReport() for an explanation. *\/\n@@ -85,2 +87,3 @@\n-    jlong frameGeneration;\n-    struct ThreadList *list;  \/* Tells us what list this thread is in *\/\n+    jlong frameGeneration;    \/* used to generate a unique frameID. Incremented whenever existing frameID\n+                                 needs to be invalidated, such as when the thread is resumed. *\/\n+    struct ThreadList *list;  \/* Tells us what list this thread is in. *\/\n@@ -231,1 +234,4 @@\n- * If list==NULL, search both lists.\n+ *\/\n+\n+\/*\n+ * Search for a thread on the list. If list==NULL, search all lists.\n@@ -675,0 +681,4 @@\n+\/*\n+ * Event handler for FRAME_POP and EXCEPTION_CATCH when in Thread.resume()\n+ * so we can detect its completion.\n+ *\/\n@@ -759,0 +769,1 @@\n+\/* Global breakpoint handler for Thread.resume() *\/\n@@ -930,1 +941,1 @@\n-          node->suspendCount--;\n+            node->suspendCount--;\n@@ -1083,0 +1094,3 @@\n+#if 0\n+    tty_message(\"commonSuspend: node(%p) suspendCount(%d) %s\", node, node->suspendCount, node->name);\n+#endif\n@@ -1390,1 +1404,0 @@\n-\n@@ -1402,0 +1415,3 @@\n+#if 0\n+    tty_message(\"commonResume: node(%p) suspendCount(%d) %s\", node, node->suspendCount, node->name);\n+#endif\n@@ -1523,0 +1539,3 @@\n+#if 0\n+    tty_message(\"threadControl_suspendAll: suspendAllCount(%d)\", suspendAllCount);\n+#endif\n@@ -1596,0 +1615,3 @@\n+#if 0\n+    tty_message(\"threadControl_resumeAll: suspendAllCount(%d)\", suspendAllCount);\n+#endif\n@@ -2053,1 +2075,1 @@\n-threadControl_onEventHandlerEntry(jbyte sessionID, EventIndex ei, jthread thread, jobject currentException)\n+threadControl_onEventHandlerEntry(jbyte sessionID, EventInfo *evinfo, jobject currentException)\n@@ -2060,0 +2082,2 @@\n+    EventIndex  ei = evinfo->ei;\n+    jthread     thread = evinfo->thread;\n@@ -2486,1 +2510,2 @@\n-jthread threadControl_currentThread(void)\n+jthread\n+threadControl_currentThread(void)\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-struct bag *threadControl_onEventHandlerEntry(jbyte sessionID,\n-                  EventIndex ei, jthread thread, jobject currentException);\n+struct bag *threadControl_onEventHandlerEntry(jbyte sessionID, EventInfo *evinfo, jobject currentException);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}