{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -31,0 +32,297 @@\n+#include \"testutils.hpp\"\n+\n+#define ASSERT_CONTAINS(ar, p) ASSERT_TRUE(ar.contains(p))\n+\n+\/\/ Note:\n+\/\/ - Amalloc returns 64bit aligned pointer (also on 32-bit)\n+\/\/ - AmallocWords returns word-aligned pointer\n+#define ASSERT_ALIGN_AMALLOC(p)       ASSERT_ALIGN(p, ARENA_AMALLOC_ALIGNMENT)\n+#define ASSERT_ALIGN_AMALLOCWORDS(p)  ASSERT_ALIGN(p, BytesPerWords)\n+\n+\/\/ Do a couple of checks on the return of a successful Amalloc\n+#define ASSERT_AMALLOC(ar, p) \\\n+  ASSERT_NOT_NULL(p); \\\n+  ASSERT_CONTAINS(ar, p); \\\n+  ASSERT_ALIGN_AMALLOC(p);\n+\n+\/\/ #define LOG(s) tty->print_cr s;\n+#define LOG(s)\n+\n+\/\/ Test behavior for Amalloc(0).\n+\/\/ Amalloc just ignores Amalloc(0) and returns the current hwm without increasing it.\n+\/\/ Therefore, the returned pointer should be not null, aligned, but not (!) contained\n+\/\/ in the arena since hwm points beyond the arena.\n+TEST_VM(Arena, alloc_size_0) {\n+  Arena ar(mtTest);\n+  void* p = ar.Amalloc(0);\n+  ASSERT_NOT_NULL(p);\n+  ASSERT_ALIGN_AMALLOC(p);\n+  if (!UseMallocOnly) {\n+    \/\/ contains works differently for malloced mode (and there its broken anyway)\n+    ASSERT_FALSE(ar.contains(p));\n+  }\n+  \/\/ Allocate again. The new allocations should have the same position as the 0-sized\n+  \/\/ first one.\n+  if (!UseMallocOnly) {\n+    void* p2 = ar.Amalloc(1);\n+    ASSERT_AMALLOC(ar, p2);\n+    ASSERT_EQ(p2, p);\n+  }\n+}\n+\n+\/\/ Test behavior for Arealloc(p, 0)\n+TEST_VM(Arena, realloc_size_0) {\n+  \/\/ Arealloc(p, 0) behaves like Afree(p). It should release the memory\n+  \/\/ and, if top position, roll back the hwm.\n+  Arena ar(mtTest);\n+  void* p1 = ar.Amalloc(0x10);\n+  ASSERT_AMALLOC(ar, p1);\n+  void* p2 = ar.Arealloc(p1, 0x10, 0);\n+  ASSERT_NULL(p2);\n+\n+  \/\/ a subsequent allocation should get the same pointer\n+  if (!UseMallocOnly) {\n+    void* p3 = ar.Amalloc(0x20);\n+    ASSERT_EQ(p3, p1);\n+  }\n+}\n+\n+\/\/ Realloc equal sizes is a noop\n+TEST_VM(Arena, realloc_same_size) {\n+  Arena ar(mtTest);\n+  void* p1 = ar.Amalloc(0x200);\n+  ASSERT_AMALLOC(ar, p1);\n+  GtestUtils::mark_range(p1, 0x200);\n+\n+  void* p2 = ar.Arealloc(p1, 0x200, 0x200);\n+\n+  if (!UseMallocOnly) {\n+    ASSERT_EQ(p2, p1);\n+  }\n+  ASSERT_RANGE_IS_MARKED(p2, 0x200);\n+}\n+\n+\/\/ Test behavior for Afree(NULL) and Arealloc(NULL, x)\n+TEST_VM(Arena, free_null) {\n+  Arena ar(mtTest);\n+  ar.Afree(NULL, 10); \/\/ should just be ignored\n+}\n+\n+TEST_VM(Arena, realloc_null) {\n+  Arena ar(mtTest);\n+  void* p = ar.Arealloc(NULL, 0, 20); \/\/ equivalent to Amalloc(20)\n+  ASSERT_AMALLOC(ar, p);\n+}\n+\n+\/\/ Check Arena.Afree in a non-top position.\n+\/\/ The free'd allocation should be zapped (debug only),\n+\/\/ surrounding blocks should be unaffected.\n+TEST_VM(Arena, free_nontop) {\n+  Arena ar(mtTest);\n+\n+  void* p_before = ar.Amalloc(0x10);\n+  ASSERT_AMALLOC(ar, p_before);\n+  GtestUtils::mark_range(p_before, 0x10);\n+\n+  void* p = ar.Amalloc(0x10);\n+  ASSERT_AMALLOC(ar, p);\n+  GtestUtils::mark_range_with(p, 0x10, 'Z');\n+\n+  void* p_after = ar.Amalloc(0x10);\n+  ASSERT_AMALLOC(ar, p_after);\n+  GtestUtils::mark_range(p_after, 0x10);\n+\n+  ASSERT_RANGE_IS_MARKED(p_before, 0x10);\n+  ASSERT_RANGE_IS_MARKED_WITH(p, 0x10, 'Z');\n+  ASSERT_RANGE_IS_MARKED(p_after, 0x10);\n+\n+  ar.Afree(p, 0x10);\n+\n+  ASSERT_RANGE_IS_MARKED(p_before, 0x10);\n+  DEBUG_ONLY(ASSERT_RANGE_IS_MARKED_WITH(p, 0x10, badResourceValue);)\n+  ASSERT_RANGE_IS_MARKED(p_after, 0x10);\n+}\n+\n+\/\/ Check Arena.Afree in a top position.\n+\/\/ The free'd allocation (non-top) should be zapped (debug only),\n+\/\/ the hwm should have been rolled back.\n+TEST_VM(Arena, free_top) {\n+  Arena ar(mtTest);\n+\n+  void* p = ar.Amalloc(0x10);\n+  ASSERT_AMALLOC(ar, p);\n+  GtestUtils::mark_range_with(p, 0x10, 'Z');\n+\n+  ar.Afree(p, 0x10);\n+  DEBUG_ONLY(ASSERT_RANGE_IS_MARKED_WITH(p, 0x10, badResourceValue);)\n+\n+  \/\/ a subsequent allocation should get the same pointer\n+  if (!UseMallocOnly) {\n+    void* p2 = ar.Amalloc(0x20);\n+    ASSERT_EQ(p2, p);\n+  }\n+}\n+\n+\/\/ In-place shrinking.\n+TEST_VM(Arena, realloc_top_shrink) {\n+  if (!UseMallocOnly) {\n+    Arena ar(mtTest);\n+\n+    void* p1 = ar.Amalloc(0x200);\n+    ASSERT_AMALLOC(ar, p1);\n+    GtestUtils::mark_range(p1, 0x200);\n+\n+    void* p2 = ar.Arealloc(p1, 0x200, 0x100);\n+    ASSERT_EQ(p1, p2);\n+    ASSERT_RANGE_IS_MARKED(p2, 0x100); \/\/ realloc should preserve old content\n+\n+    \/\/ A subsequent allocation should be placed right after the end of the first, shrunk, allocation\n+    void* p3 = ar.Amalloc(1);\n+    ASSERT_EQ(p3, ((char*)p1) + 0x100);\n+  }\n+}\n+\n+\/\/ not-in-place shrinking.\n+TEST_VM(Arena, realloc_nontop_shrink) {\n+  Arena ar(mtTest);\n+\n+  void* p1 = ar.Amalloc(200);\n+  ASSERT_AMALLOC(ar, p1);\n+  GtestUtils::mark_range(p1, 200);\n+\n+  void* p_other = ar.Amalloc(20); \/\/ new top, p1 not top anymore\n+\n+  void* p2 = ar.Arealloc(p1, 200, 100);\n+  if (!UseMallocOnly) {\n+    ASSERT_EQ(p1, p2); \/\/ should still shrink in place\n+  }\n+  ASSERT_RANGE_IS_MARKED(p2, 100); \/\/ realloc should preserve old content\n+}\n+\n+\/\/ in-place growing.\n+TEST_VM(Arena, realloc_top_grow) {\n+  Arena ar(mtTest); \/\/ initial chunk size large enough to ensure below allocation grows in-place.\n+\n+  void* p1 = ar.Amalloc(0x10);\n+  ASSERT_AMALLOC(ar, p1);\n+  GtestUtils::mark_range(p1, 0x10);\n+\n+  void* p2 = ar.Arealloc(p1, 0x10, 0x20);\n+  if (!UseMallocOnly) {\n+    ASSERT_EQ(p1, p2);\n+  }\n+  ASSERT_RANGE_IS_MARKED(p2, 0x10); \/\/ realloc should preserve old content\n+}\n+\n+\/\/ not-in-place growing.\n+TEST_VM(Arena, realloc_nontop_grow) {\n+  Arena ar(mtTest);\n+\n+  void* p1 = ar.Amalloc(10);\n+  ASSERT_AMALLOC(ar, p1);\n+  GtestUtils::mark_range(p1, 10);\n+\n+  void* p_other = ar.Amalloc(20); \/\/ new top, p1 not top anymore\n+\n+  void* p2 = ar.Arealloc(p1, 10, 20);\n+  ASSERT_AMALLOC(ar, p2);\n+  ASSERT_RANGE_IS_MARKED(p2, 10); \/\/ realloc should preserve old content\n+}\n+\n+\/\/ -------- random alloc test -------------\n+\n+static uint8_t canary(int i) {\n+  return (uint8_t)('A' + i % 26);\n+}\n+\n+\/\/ Randomly allocate and reallocate with random sizes and differing alignments;\n+\/\/  check alignment; check for overwriters.\n+\/\/ We do this a number of times, to give chunk pool handling a good workout too.\n+TEST_VM(Arena, random_allocs) {\n+\n+  const int num_allocs = 250 * 1000;\n+  const int avg_alloc_size = 64;\n+\n+  void** ptrs = NEW_C_HEAP_ARRAY(void*, num_allocs, mtTest);\n+  size_t* sizes = NEW_C_HEAP_ARRAY(size_t, num_allocs, mtTest);\n+  size_t* alignments = NEW_C_HEAP_ARRAY(size_t, num_allocs, mtTest);\n+\n+  Arena ar(mtTest);\n+\n+  \/\/ Allocate\n+  for (int i = 0; i < num_allocs; i ++) {\n+    size_t size = os::random() % (avg_alloc_size * 2); \/\/ Note: size==0 is okay; we want to test that too\n+    size_t alignment = 0;\n+    void* p = NULL;\n+    if (os::random() % 2) { \/\/ randomly switch between Amalloc and AmallocWords\n+      p = ar.Amalloc(size);\n+      alignment = BytesPerLong;\n+    } else {\n+      \/\/ Inconsistency: AmallocWords wants its input size word aligned, whereas Amalloc takes\n+      \/\/  care of alignment itself. We may want to clean this up, but for now just go with it.\n+      size = align_up(size, BytesPerWord);\n+      p = ar.AmallocWords(size);\n+      alignment = BytesPerWord;\n+    }\n+    LOG((\"[%d]: \" PTR_FORMAT \", size \" SIZE_FORMAT \", aligned \" SIZE_FORMAT,\n+         i, p2i(p), size, alignment));\n+    ASSERT_NOT_NULL(p);\n+    ASSERT_ALIGN(p, alignment);\n+    if (size > 0) {\n+      ASSERT_CONTAINS(ar, p);\n+    }\n+    GtestUtils::mark_range_with(p, size, canary(i));\n+    ptrs[i] = p; sizes[i] = size; alignments[i] = alignment;\n+  }\n+\n+  \/\/ Check pattern in allocations for overwriters.\n+  for (int i = 0; i < num_allocs; i ++) {\n+    ASSERT_RANGE_IS_MARKED_WITH(ptrs[i], sizes[i], canary(i));\n+  }\n+\n+  \/\/ realloc all of them\n+  for (int i = 0; i < num_allocs; i ++) {\n+    size_t new_size = os::random() % (avg_alloc_size * 2);  \/\/ Note: 0 is possible and should work\n+    void* p2 = ar.Arealloc(ptrs[i], sizes[i], new_size);\n+    if (new_size > 0) {\n+      ASSERT_NOT_NULL(p2);\n+      ASSERT_CONTAINS(ar, p2);\n+      ASSERT_ALIGN(p2, alignments[i]); \/\/ Realloc guarantees at least the original alignment\n+      ASSERT_RANGE_IS_MARKED_WITH(p2, MIN2(sizes[i], new_size), canary(i)); \/\/ old content should have been preserved\n+\n+      GtestUtils::mark_range_with(p2, new_size, canary(i)); \/\/ mark new range with canary\n+    } else {\n+      ASSERT_NULL(p2);\n+    }\n+    ptrs[i] = p2; sizes[i] = new_size;\n+    LOG((\"[%d]: realloc \" PTR_FORMAT \", size \" SIZE_FORMAT \", aligned \" SIZE_FORMAT,\n+         i, p2i(p2), new_size, alignments[i]));\n+  }\n+\n+  \/\/ Check test pattern again\n+  \/\/  Note that we don't check the gap pattern anymore since if allocations had been shrunk in place\n+  \/\/  this now gets difficult.\n+  for (int i = 0; i < num_allocs; i ++) {\n+    ASSERT_RANGE_IS_MARKED_WITH(ptrs[i], sizes[i], canary(i));\n+  }\n+\n+  \/\/ Randomly free a bunch of allocations.\n+  for (int i = 0; i < num_allocs; i ++) {\n+    if (os::random() % 10 == 0) {\n+      ar.Afree(ptrs[i], sizes[i]);\n+      \/\/ In debug builds the freed space should be filled the space with badResourceValue\n+      DEBUG_ONLY(ASSERT_RANGE_IS_MARKED_WITH(ptrs[i], sizes[i], badResourceValue));\n+      ptrs[i] = NULL;\n+    }\n+  }\n+\n+  \/\/ Check test pattern again\n+  for (int i = 0; i < num_allocs; i ++) {\n+    ASSERT_RANGE_IS_MARKED_WITH(ptrs[i], sizes[i], canary(i));\n+  }\n+\n+  \/\/ Free temp data\n+  FREE_C_HEAP_ARRAY(char*, ptrs);\n+  FREE_C_HEAP_ARRAY(size_t, sizes);\n+  FREE_C_HEAP_ARRAY(size_t, alignments);\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":298,"deletions":0,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <string.h>\n+\n+\/\/ Note: these could be made more suitable for covering large ranges (e.g. just mark one byte per page).\n+\n+void GtestUtils::mark_range_with(void* p, size_t s, uint8_t mark) {\n+  if (p != NULL && s > 0) {\n+    ::memset(p, mark, s);\n+  }\n+}\n+\n+bool GtestUtils::check_range(const void* p, size_t s, uint8_t expected) {\n+  if (p == NULL || s == 0) {\n+    return true;\n+  }\n+\n+  const char* first_wrong = NULL;\n+  char* p2 = (char*)p;\n+  const char* const end = p2 + s;\n+  while (p2 < end) {\n+    if (*p2 != (char)expected) {\n+      first_wrong = p2;\n+      break;\n+    }\n+    p2 ++;\n+  }\n+\n+  if (first_wrong != NULL) {\n+    tty->print_cr(\"wrong pattern around \" PTR_FORMAT, p2i(first_wrong));\n+    \/\/ Note: We deliberately print the surroundings too without bounds check. Might be interesting,\n+    \/\/ and os::print_hex_dump uses SafeFetch, so this is fine without bounds checks.\n+    os::print_hex_dump(tty, (address)(align_down(p2, 0x10) - 0x10),\n+                            (address)(align_up(end, 0x10) + 0x10), 1);\n+  }\n+\n+  return first_wrong == NULL;\n+}\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef TESTUTILS_HPP\n+#define TESTUTILS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+class GtestUtils : public AllStatic {\n+public:\n+\n+  \/\/ Fill range with a byte mark.\n+  \/\/ Tolerates p == NULL or s == 0.\n+  static void mark_range_with(void* p, size_t s, uint8_t mark);\n+\n+  \/\/ Given a memory range, check that the whole range is filled with the expected byte.\n+  \/\/ If not, hex dump around first non-matching address and return false.\n+  \/\/ If p == NULL or size == 0, returns true.\n+  static bool check_range(const void* p, size_t s, uint8_t expected);\n+\n+  \/\/ Convenience method with a predefined byte mark.\n+  static void mark_range(void* p, size_t s)           { mark_range_with(p, s, 32); }\n+  static bool check_range(const void* p, size_t s)    { return check_range(p, s, 32); }\n+\n+};\n+\n+#define ASSERT_RANGE_IS_MARKED_WITH(p, size, mark)  ASSERT_TRUE(GtestUtils::check_range(p, size, mark))\n+#define ASSERT_RANGE_IS_MARKED(p, size)             ASSERT_TRUE(GtestUtils::check_range(p, size))\n+\n+\/\/ Convenience asserts\n+#define ASSERT_NOT_NULL(p)  ASSERT_NE(p, (char*)NULL)\n+#define ASSERT_NULL(p)      ASSERT_EQ(p, (char*)NULL)\n+\n+#define ASSERT_ALIGN(p, n) ASSERT_TRUE(is_aligned(p, n))\n+\n+#endif \/\/ TESTUTILS_HPP\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Note: This runs the Arena portion of the gtests with UseMallocOnly\n+ * (restricted to debug since UseMallocOnly is debug-only)\n+ *\/\n+\n+\/* @test\n+ * @bug 8271242\n+ * @summary Run arena tests with UseMallocOnly\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=Arena* -XX:+UseMallocOnly\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/ArenaGtests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"}]}