{"files":[{"patch":"@@ -385,1 +385,0 @@\n-  int   _unc_bci;               \/\/ speculative bci for unstable_if trap\n@@ -387,1 +386,1 @@\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt), _unc_bci(-1) {\n+    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n@@ -403,6 +402,0 @@\n-  int unc_bci() const { return _unc_bci; }\n-  void set_unc_bci(int bci) {\n-    assert(bci == -1 || _unc_bci == -1, \"attempt to overwrite unc_bci\");\n-    _unc_bci = bci;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -775,0 +775,2 @@\n+    preprocess_unstable_ifs();\n+\n@@ -1858,2 +1860,17 @@\n-void Compile::record_unstable_if(IfNode *iff) {\n-  CallStaticJavaNode *unc;\n+void Compile::record_unstable_if(UnstableIfTrap* trap) {\n+  _unstable_ifs.append(trap);\n+}\n+\n+\/\/ TODO: hashmap, or Unique_Node_List\n+void Compile::invalidate_unstable_if(CallStaticJavaNode* unc) {\n+  for (int i=0; i < _unstable_ifs.length(); ++i) {\n+    UnstableIfTrap* trap = _unstable_ifs.at(i);\n+    if (trap->uncommon_trap() == unc) {\n+      trap->set_bci(-1);\n+      break;\n+    }\n+  }\n+}\n+\n+uint trivial_unstable_ifs          = 0;\n+uint unstable_ifs_all              = 0;\n@@ -1861,3 +1878,15 @@\n-  if (aggressive_unstable_if() && iff->unc_bci() != -1 && iff->outcnt() == 2\n-      && iff->uncommon_trap_proj(unc, Deoptimization::Reason_unstable_if) != nullptr) {\n-    _unstable_ifs.append(iff);\n+void Compile::preprocess_unstable_ifs() {\n+  Atomic::add(&unstable_ifs_all, (uint)_unstable_ifs.length());\n+\n+  for (int i=0; i < _unstable_ifs.length(); i++) {\n+    UnstableIfTrap* trap = _unstable_ifs.at(i);\n+    if (trap->is_trivial()) {\n+#ifndef PRODUCT\n+      if (Verbose) {\n+        tty->print(\"trivial unstable_if: \");\n+        trap->uncommon_trap()->dump();\n+        trap->path()->flow()->print_on(tty);\n+      }\n+#endif\n+      Atomic::inc(&trivial_unstable_ifs);\n+    }\n@@ -1872,26 +1901,20 @@\n-    IfNode *iff = _unstable_ifs.pop();\n-    int next_bci = iff->unc_bci();\n-\n-    if (next_bci != -1 && !_dead_node_list.test(iff->_idx)) {\n-      CallStaticJavaNode *unc;\n-      ProjNode *proj = iff->uncommon_trap_proj(unc, Deoptimization::Reason_unstable_if);\n-\n-      if (proj != nullptr) {\n-        ProjNode *other_proj = proj->other_if_proj();\n-        \/\/ give up if 2 branches are unstable. It could happen if program is under-profiling.\n-        if (other_proj->is_uncommon_trap_proj(Deoptimization::Reason_unstable_if) == nullptr) {\n-          JVMState *jvms = unc->jvms();\n-          ciMethod *method = jvms->method();\n-          ciBytecodeStream iter(method);\n-\n-          iter.force_bci(jvms->bci());\n-          assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n-          Bytecodes::Code c = iter.cur_bc();\n-          Node *lhs = nullptr;\n-          Node *rhs = nullptr;\n-          if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n-            lhs = unc->peek_operand(0);\n-            rhs = unc->peek_operand(1);\n-          } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n-            lhs = unc->peek_operand(0);\n-          }\n+    UnstableIfTrap* trap = _unstable_ifs.pop();\n+    CallStaticJavaNode* unc = trap->uncommon_trap();\n+    int next_bci = trap->next_bci();\n+\n+    if (next_bci != -1 && !_dead_node_list.test(unc->_idx)) {\n+      JVMState* jvms = unc->jvms();\n+      ciMethod* method = jvms->method();\n+      ciBytecodeStream iter(method);\n+\n+      iter.force_bci(jvms->bci());\n+      assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n+      Bytecodes::Code c = iter.cur_bc();\n+      Node* lhs = nullptr;\n+      Node* rhs = nullptr;\n+      if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n+        lhs = unc->peek_operand(0);\n+        rhs = unc->peek_operand(1);\n+      } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n+        lhs = unc->peek_operand(0);\n+      }\n@@ -1899,11 +1922,11 @@\n-          ResourceMark rm;\n-          const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n-          assert(live_locals.is_valid(), \"broken liveness info\");\n-\n-          int len = (int)live_locals.size();\n-          for (int i = 0; i < len; i++) {\n-            Node *local = unc->local(jvms, i);\n-            \/\/ kill local using the liveness of next_bci.\n-            \/\/ yield when local looks like an operand to secure reexecution.\n-            if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n-              uint idx = jvms->locoff() + i;\n+      ResourceMark rm;\n+      const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n+      assert(live_locals.is_valid(), \"broken liveness info\");\n+\n+      int len = (int)live_locals.size();\n+      for (int i = 0; i < len; i++) {\n+        Node *local = unc->local(jvms, i);\n+        \/\/ kill local using the liveness of next_bci.\n+        \/\/ yield when local looks like an operand to secure reexecution.\n+        if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+          uint idx = jvms->locoff() + i;\n@@ -1911,8 +1934,4 @@\n-              if (Verbose) {\n-                tty->print(\"[unstable_if] kill local#%d: \", idx);\n-                local->dump();\n-                tty->cr();\n-              }\n-#endif\n-              igvn.replace_input_of(unc, idx, top());\n-            }\n+          if (Verbose) {\n+            tty->print(\"[unstable_if] kill local#%d: \", idx);\n+            local->dump();\n+            tty->cr();\n@@ -1920,1 +1939,2 @@\n-          igvn._worklist.push(iff);\n+#endif\n+          igvn.replace_input_of(unc, idx, top());\n@@ -1923,1 +1943,0 @@\n-      iff->set_unc_bci(-1);\n@@ -2236,1 +2255,1 @@\n-  process_for_unstable_ifs(igvn);\n+  \/\/process_for_unstable_ifs(igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":72,"deletions":53,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class CallStaticJavaNode;\n@@ -93,0 +94,1 @@\n+class UnstableIfTrap;\n@@ -97,0 +99,1 @@\n+\n@@ -360,1 +363,1 @@\n-  GrowableArray<IfNode *> _unstable_ifs;        \/\/ List of ifnodes after IGVN\n+  GrowableArray<UnstableIfTrap*> _unstable_ifs;        \/\/ List of ifnodes after IGVN\n@@ -740,1 +743,1 @@\n-\n+  void preprocess_unstable_ifs();\n@@ -809,1 +812,2 @@\n-  void         record_unstable_if(IfNode *iff);\n+  void         record_unstable_if(UnstableIfTrap* trap);\n+  void         invalidate_unstable_if(CallStaticJavaNode* trap);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2021,1 +2021,1 @@\n-void GraphKit::uncommon_trap(int trap_request,\n+Node* GraphKit::uncommon_trap(int trap_request,\n@@ -2026,1 +2026,1 @@\n-  if (stopped())  return; \/\/ trap reachable?\n+  if (stopped())  return NULL; \/\/ trap reachable?\n@@ -2142,0 +2142,1 @@\n+  return call;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  void uncommon_trap(int trap_request,\n+  Node* uncommon_trap(int trap_request,\n@@ -736,1 +736,1 @@\n-  void uncommon_trap(Deoptimization::DeoptReason reason,\n+  Node* uncommon_trap(Deoptimization::DeoptReason reason,\n@@ -740,1 +740,1 @@\n-    uncommon_trap(Deoptimization::make_trap_request(reason, action),\n+    return uncommon_trap(Deoptimization::make_trap_request(reason, action),\n@@ -745,1 +745,1 @@\n-  void uncommon_trap_exact(Deoptimization::DeoptReason reason,\n+  Node* uncommon_trap_exact(Deoptimization::DeoptReason reason,\n@@ -749,1 +749,1 @@\n-    uncommon_trap(Deoptimization::make_trap_request(reason, action),\n+    return uncommon_trap(Deoptimization::make_trap_request(reason, action),\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -844,0 +844,1 @@\n+        igvn->C->invalidate_unstable_if(dom_unc);\n@@ -1091,2 +1092,2 @@\n-    \/\/ suppress unstable_if optimization for the dominating if.\n-    proj->in(0)->as_If()->set_unc_bci(-1);\n+    \/\/\/\/ suppress unstable_if optimization for the dominating if.\n+    \/\/proj->in(0)->as_If()->set_unc_bci(-1);\n@@ -1300,2 +1301,2 @@\n-  \/\/ suppress unstable_if optimization for the dominating if.\n-  c->in(0)->as_If()->set_unc_bci(-1);\n+  \/\/\/\/ suppress unstable_if optimization for the dominating if.\n+  \/\/c->in(0)->as_If()->set_unc_bci(-1);\n@@ -1472,2 +1473,0 @@\n-  igvn->C->record_unstable_if(this);\n-\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -606,0 +606,46 @@\n+\/\/ Specialized uncommon_trap of unstable_if\n+\/\/ We have 2 optimizations for them:\n+\/\/   1. remove trivial UnstableIf traps, which do not prune any basic block\n+\/\/   2. use next_bci of _path to update live locals.\n+class UnstableIfTrap {\n+  CallStaticJavaNode* _unc;\n+  Parse::Block* _path;  \/\/ the pruned path, which is only invalid in parse time.\n+  int _next_bci;        \/\/ speculative bci which takes _path.\n+\n+public:\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path), _next_bci(-1) {\n+    assert(_unc != NULL && Deoptimization::trap_request_reason(_unc->uncommon_trap_request()) == Deoptimization::Reason_unstable_if,\n+          \"invalid uncommon_trap call!\");\n+\n+    if (_path != NULL) {\n+      _next_bci = _path->start();\n+    }\n+  }\n+\n+  int next_bci() const { return _next_bci; }\n+\n+  void set_bci(int bci) {\n+    assert(bci == -1 || _next_bci == -1, \"attempt to overwrite unc_bci\");\n+    _next_bci = bci;\n+  }\n+\n+  \/\/ This can only be determined in parse-time.\n+  \/\/ if _path has only one predecessor, it's trivial if this block is smaller.\n+  \/\/ if _path has more than one predecessor and itself has been parsed, unc does not mask out _path.\n+  \/\/ It is trivial.\n+  bool is_trivial() const {\n+    return _path->is_parsed();\n+  }\n+  Parse::Block* path() const {\n+    return _path;\n+  }\n+  CallStaticJavaNode* uncommon_trap() const {\n+    return _unc;\n+  }\n+\n+  inline void* operator new(size_t x) throw() {\n+    Compile* C = Compile::current();\n+    return C->node_arena()->AmallocWords(x);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+extern uint trivial_unstable_ifs;\n+extern uint unstable_ifs_all;\n@@ -95,0 +97,5 @@\n+  if (unstable_ifs_all) {\n+    tty->print_cr(\"%u trivial unstable_ifs (%2d%%)\", trivial_unstable_ifs,\n+                  (100 * trivial_unstable_ifs \/ unstable_ifs_all));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1588,4 +1588,0 @@\n-    IfNode *iff = control()->in(0)->as_If();\n-    int next_bci = is_fallthrough ? iter().next_bci() : iter().get_dest();\n-    iff->set_unc_bci(next_bci);\n-\n@@ -1593,1 +1589,1 @@\n-    uncommon_trap(Deoptimization::Reason_unstable_if,\n+    Node* call = uncommon_trap(Deoptimization::Reason_unstable_if,\n@@ -1597,0 +1593,1 @@\n+    C->record_unstable_if(new UnstableIfTrap(call->as_CallStaticJava(), path));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}