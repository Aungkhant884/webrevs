{"files":[{"patch":"@@ -1880,2 +1880,6 @@\n-\n-\/\/ remove unstable_if trap of unc from candicates. It is either dead or fold-compares case.\n+\/\/\n+\/\/ Remove unstable_if trap of unc from candicates. It is either dead or fold-compares case.\n+\/\/ Return true if succeed or not found.\n+\/\/\n+\/\/ In rare cases, the found traps have been processed. It is too late to delete. return false\n+\/\/ and ask fold-compares to yield.\n@@ -1886,1 +1890,2 @@\n-void Compile::remove_unstable_if_trap(CallStaticJavaNode* unc) {\n+\/\/\n+bool Compile::remove_unstable_if_trap(CallStaticJavaNode* unc) {\n@@ -1890,0 +1895,3 @@\n+      if (trap->modified()) {\n+        return false;\n+      }\n@@ -1894,0 +1902,1 @@\n+  return true;\n@@ -1917,2 +1926,2 @@\n-  while (_unstable_if_traps.length() > 0) {\n-    UnstableIfTrap* trap = _unstable_if_traps.pop();\n+  for (int i = 0; i < _unstable_if_traps.length(); ++i) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n@@ -1922,1 +1931,1 @@\n-    if (next_bci != -1) {\n+    if (next_bci != -1 && !trap->modified()) {\n@@ -1943,1 +1952,1 @@\n-\n+      bool changed = false;\n@@ -1959,0 +1968,1 @@\n+          changed = true;\n@@ -1961,0 +1971,3 @@\n+      if (changed) {\n+        trap->set_modified();\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n-  void remove_unstable_if_trap(CallStaticJavaNode* trap);\n+  bool remove_unstable_if_trap(CallStaticJavaNode* trap);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -841,1 +841,2 @@\n-          !igvn->C->too_many_traps(dom_method, dom_bci, Deoptimization::Reason_range_check)) {\n+          !igvn->C->too_many_traps(dom_method, dom_bci, Deoptimization::Reason_range_check) &&\n+          igvn->C->remove_unstable_if_trap(dom_unc)) {\n@@ -844,1 +845,0 @@\n-        igvn->C->remove_unstable_if_trap(dom_unc);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -613,1 +613,2 @@\n-  Parse::Block* const _path; \/\/ The pruned path.\n+  Parse::Block* const _path; \/\/ the pruned path\n+  bool _modified;            \/\/ modified locals based on next_bci()\n@@ -616,1 +617,1 @@\n-  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path) {\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path), _modified(false) {\n@@ -627,0 +628,8 @@\n+  bool modified() const {\n+    return _modified;\n+  }\n+\n+  void set_modified() {\n+    _modified = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8286104\n+ * @summary Test Fold-compares are safe when C2 optimizes unstable_if traps\n+ *          (-XX:+AggressiveLivenessForUnstableIf)\n+ *\n+ * @run main\/othervm -XX:CompileCommand=compileOnly,java.lang.Short::valueOf\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.TestFoldCompares2$Numbers::isSupported\n+ *                   -Xbatch compiler.c2.TestFoldCompares2\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestFoldCompares2 {\n+    public static Short value = Short.valueOf((short) 0);\n+    static void testShort() {\n+        \/\/ trigger compilation and bias to a cached value.\n+        for (int i=0; i<20_000; ++i) {\n+            value = Short.valueOf((short) 0);\n+        }\n+\n+        \/\/ trigger deoptimization on purpose\n+        \/\/ the size of ShortCache.cache is hard-coded in java.lang.Short\n+        Short x = Short.valueOf((short) 128);\n+        if (x != 128) {\n+            throw new RuntimeException(\"wrong result!\");\n+        }\n+    }\n+\n+    static enum Numbers {\n+        One,\n+        Two,\n+        Three,\n+        Four,\n+        Five;\n+\n+        boolean isSupported() {\n+            \/\/ ordinal() is inlined and leaves a copy region node, which blocks\n+            \/\/ fold-compares in the 1st iterGVN.\n+            return ordinal() >= Two.ordinal() && ordinal() <= Four.ordinal();\n+        }\n+    }\n+\n+    static void testEnumValues() {\n+        Numbers local = Numbers.Two;\n+\n+        for (int i = 0; i < 2_000_000; ++i) {\n+            local.isSupported();\n+        }\n+        \/\/ deoptimize\n+        Numbers.Five.isSupported();\n+    }\n+\n+    public static void main(String[] args) {\n+        testShort();\n+        testEnumValues();\n+        System.out.println(\"Test passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestFoldCompares2.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}