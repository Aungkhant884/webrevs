{"files":[{"patch":"@@ -49,1 +49,1 @@\n-  bool is_valid() { return _is_valid; }\n+  bool is_valid() const { return _is_valid; }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,3 @@\n+  product(bool, AggressiveLivenessForUnstableIf, true, DIAGNOSTIC,          \\\n+          \"Use aggressive liveness for UnstableIf traps\")                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1447,0 +1447,6 @@\n+Node *SafePointNode::peek_operand(uint off) const {\n+  assert(jvms()->sp() > 0, \"must have an operand\");\n+  assert(off < jvms()->sp(), \"off is out-of-range\");\n+  return stack(jvms(), jvms()->sp() - off - 1);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -419,0 +419,2 @@\n+  \/\/ peek Operand Stacks, JVMS 2.6.2\n+  Node *peek_operand(uint off = 0) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call) const;\n@@ -316,0 +315,1 @@\n+  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -608,0 +608,1 @@\n+                  _unstable_ifs      (comp_arena(), 8, 0, NULL),\n@@ -774,0 +775,2 @@\n+    preprocess_unstable_ifs();\n+\n@@ -1855,0 +1858,90 @@\n+\/\/ only record well-formed if nodes.\n+\/\/ we only process a node once,so it is fine with duplication.\n+void Compile::record_unstable_if(UnstableIfTrap* trap) {\n+  _unstable_ifs.append(trap);\n+}\n+\n+\/\/ TODO: hashmap, or Unique_Node_List\n+void Compile::invalidate_unstable_if(CallStaticJavaNode* unc) {\n+  for (int i=0; i < _unstable_ifs.length(); ++i) {\n+    UnstableIfTrap* trap = _unstable_ifs.at(i);\n+    if (trap->uncommon_trap() == unc) {\n+      trap->set_bci(-1);\n+      break;\n+    }\n+  }\n+}\n+\n+uint trivial_unstable_ifs          = 0;\n+uint unstable_ifs_all              = 0;\n+\n+void Compile::preprocess_unstable_ifs() {\n+  Atomic::add(&unstable_ifs_all, (uint)_unstable_ifs.length());\n+\n+  for (int i=0; i < _unstable_ifs.length(); i++) {\n+    UnstableIfTrap* trap = _unstable_ifs.at(i);\n+    if (trap->is_trivial()) {\n+#ifndef PRODUCT\n+      if (Verbose) {\n+        tty->print(\"trivial unstable_if: \");\n+        trap->uncommon_trap()->dump();\n+        trap->path()->flow()->print_on(tty);\n+      }\n+#endif\n+      Atomic::inc(&trivial_unstable_ifs);\n+    }\n+  }\n+}\n+\n+\/\/ Re-calculate unstable_if traps with the liveness of next_bci, which points to the unlikely path.\n+\/\/ It needs to be done after igvn because fold-compares may fuse uncommon_traps and\n+\/\/ before renumbering.\n+void Compile::process_for_unstable_ifs(PhaseIterGVN& igvn) {\n+  while (_unstable_ifs.length() > 0) {\n+    UnstableIfTrap* trap = _unstable_ifs.pop();\n+    CallStaticJavaNode* unc = trap->uncommon_trap();\n+    int next_bci = trap->next_bci();\n+\n+    if (next_bci != -1 && !_dead_node_list.test(unc->_idx)) {\n+      JVMState* jvms = unc->jvms();\n+      ciMethod* method = jvms->method();\n+      ciBytecodeStream iter(method);\n+\n+      iter.force_bci(jvms->bci());\n+      assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n+      Bytecodes::Code c = iter.cur_bc();\n+      Node* lhs = nullptr;\n+      Node* rhs = nullptr;\n+      if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n+        lhs = unc->peek_operand(0);\n+        rhs = unc->peek_operand(1);\n+      } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n+        lhs = unc->peek_operand(0);\n+      }\n+\n+      ResourceMark rm;\n+      const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n+      assert(live_locals.is_valid(), \"broken liveness info\");\n+\n+      int len = (int)live_locals.size();\n+      for (int i = 0; i < len; i++) {\n+        Node *local = unc->local(jvms, i);\n+        \/\/ kill local using the liveness of next_bci.\n+        \/\/ yield when local looks like an operand to secure reexecution.\n+        if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+          uint idx = jvms->locoff() + i;\n+#ifndef PRODUCT\n+          if (Verbose) {\n+            tty->print(\"[unstable_if] kill local#%d: \", idx);\n+            local->dump();\n+            tty->cr();\n+          }\n+#endif\n+          igvn.replace_input_of(unc, idx, top());\n+        }\n+      }\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n@@ -2141,0 +2234,2 @@\n+  process_for_unstable_ifs(igvn);\n+\n@@ -2160,0 +2255,2 @@\n+  \/\/process_for_unstable_ifs(igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class CallStaticJavaNode;\n@@ -93,0 +94,1 @@\n+class UnstableIfTrap;\n@@ -97,0 +99,1 @@\n+\n@@ -360,0 +363,1 @@\n+  GrowableArray<UnstableIfTrap*> _unstable_ifs;        \/\/ List of ifnodes after IGVN\n@@ -550,0 +554,4 @@\n+  \/** Adjust liveness for unstable ifs. *\/\n+  bool              aggressive_unstable_if() const {\n+    return AggressiveLivenessForUnstableIf && !env()->should_retain_local_variables();\n+  }\n@@ -734,1 +742,2 @@\n-\n+  void process_for_unstable_ifs(PhaseIterGVN& igvn);\n+  void preprocess_unstable_ifs();\n@@ -803,0 +812,2 @@\n+  void         record_unstable_if(UnstableIfTrap* trap);\n+  void         invalidate_unstable_if(CallStaticJavaNode* trap);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2021,1 +2021,1 @@\n-void GraphKit::uncommon_trap(int trap_request,\n+Node* GraphKit::uncommon_trap(int trap_request,\n@@ -2026,1 +2026,1 @@\n-  if (stopped())  return; \/\/ trap reachable?\n+  if (stopped())  return NULL; \/\/ trap reachable?\n@@ -2142,0 +2142,1 @@\n+  return call;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  void uncommon_trap(int trap_request,\n+  Node* uncommon_trap(int trap_request,\n@@ -736,1 +736,1 @@\n-  void uncommon_trap(Deoptimization::DeoptReason reason,\n+  Node* uncommon_trap(Deoptimization::DeoptReason reason,\n@@ -740,1 +740,1 @@\n-    uncommon_trap(Deoptimization::make_trap_request(reason, action),\n+    return uncommon_trap(Deoptimization::make_trap_request(reason, action),\n@@ -745,1 +745,1 @@\n-  void uncommon_trap_exact(Deoptimization::DeoptReason reason,\n+  Node* uncommon_trap_exact(Deoptimization::DeoptReason reason,\n@@ -749,1 +749,1 @@\n-    uncommon_trap(Deoptimization::make_trap_request(reason, action),\n+    return uncommon_trap(Deoptimization::make_trap_request(reason, action),\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call) const {\n+ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason) const {\n@@ -797,1 +797,1 @@\n-    call = proj_out(i)->is_uncommon_trap_proj(Deoptimization::Reason_none);\n+    call = proj_out(i)->is_uncommon_trap_proj(reason);\n@@ -844,0 +844,1 @@\n+        igvn->C->invalidate_unstable_if(dom_unc);\n@@ -1090,0 +1091,3 @@\n+\n+    \/\/\/\/ suppress unstable_if optimization for the dominating if.\n+    \/\/proj->in(0)->as_If()->set_unc_bci(-1);\n@@ -1297,0 +1301,2 @@\n+  \/\/\/\/ suppress unstable_if optimization for the dominating if.\n+  \/\/c->in(0)->as_If()->set_unc_bci(-1);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -606,0 +606,46 @@\n+\/\/ Specialized uncommon_trap of unstable_if\n+\/\/ We have 2 optimizations for them:\n+\/\/   1. remove trivial UnstableIf traps, which do not prune any basic block\n+\/\/   2. use next_bci of _path to update live locals.\n+class UnstableIfTrap {\n+  CallStaticJavaNode* _unc;\n+  Parse::Block* _path;  \/\/ the pruned path, which is only invalid in parse time.\n+  int _next_bci;        \/\/ speculative bci which takes _path.\n+\n+public:\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path), _next_bci(-1) {\n+    assert(_unc != NULL && Deoptimization::trap_request_reason(_unc->uncommon_trap_request()) == Deoptimization::Reason_unstable_if,\n+          \"invalid uncommon_trap call!\");\n+\n+    if (_path != NULL) {\n+      _next_bci = _path->start();\n+    }\n+  }\n+\n+  int next_bci() const { return _next_bci; }\n+\n+  void set_bci(int bci) {\n+    assert(bci == -1 || _next_bci == -1, \"attempt to overwrite unc_bci\");\n+    _next_bci = bci;\n+  }\n+\n+  \/\/ This can only be determined in parse-time.\n+  \/\/ if _path has only one predecessor, it's trivial if this block is smaller.\n+  \/\/ if _path has more than one predecessor and itself has been parsed, unc does not mask out _path.\n+  \/\/ It is trivial.\n+  bool is_trivial() const {\n+    return _path->is_parsed();\n+  }\n+  Parse::Block* path() const {\n+    return _path;\n+  }\n+  CallStaticJavaNode* uncommon_trap() const {\n+    return _unc;\n+  }\n+\n+  inline void* operator new(size_t x) throw() {\n+    Compile* C = Compile::current();\n+    return C->node_arena()->AmallocWords(x);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+extern uint trivial_unstable_ifs;\n+extern uint unstable_ifs_all;\n@@ -95,0 +97,5 @@\n+  if (unstable_ifs_all) {\n+    tty->print_cr(\"%u trivial unstable_ifs (%2d%%)\", trivial_unstable_ifs,\n+                  (100 * trivial_unstable_ifs \/ unstable_ifs_all));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1589,1 +1589,1 @@\n-    uncommon_trap(Deoptimization::Reason_unstable_if,\n+    Node* call = uncommon_trap(Deoptimization::Reason_unstable_if,\n@@ -1593,0 +1593,1 @@\n+    C->record_unstable_if(new UnstableIfTrap(call->as_CallStaticJava(), path));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8286104\n+ * @summary Test C2 uses aggressive liveness to get rid of the boxing object which is\n+ *  only consumed by uncommon_trap.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestAggressiveLivenessForUnstableIf\n+ *\/\n+public class TestAggressiveLivenessForUnstableIf {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.MAX}) \/\/ the argument needs to be big enough to fall out of cache.\n+    @IR(applyIf = {\"AggressiveLivenessForUnstableIf\", \"true\"}, failOn = {IRNode.ALLOC_OF, \"Integer\"})\n+    public static int boxing_object(int value) {\n+        Integer ii = Integer.valueOf(value);\n+        int sum = 0;\n+\n+        if (value > 999_999) {\n+            sum += ii.intValue();\n+        }\n+\n+        return sum;\n+    }\n+\n+    @Check(test = \"boxing_object\")\n+    public void checkWithTestInfo(int result, TestInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ Accessing the cached boxing object during warm-up phase. It prevents parser from pruning that branch of Interger.valueOf();\n+            \/\/ This guarantees that a phi node is generated, which merge a cached object and the newly allocated object. eg.\n+            \/\/ 112:  Phi  ===  108  168  188  [[ 50 ]]  #java\/lang\/Integer:NotNull:exact *  Oop:java\/lang\/Integer:NotNull:exact *\n+            \/\/ 168: a cached object\n+            \/\/ 188: result of AllocateNode\n+            \/\/  50: uncommon_trap unstable_if\n+            value += Integer.valueOf(0);\n+        }\n+\n+        Asserts.assertEQ(result, Integer.MAX_VALUE);\n+    }\n+\n+    public static Integer value = Integer.valueOf(0);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAggressiveLivenessForUnstableIf.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}