{"files":[{"patch":"@@ -49,1 +49,1 @@\n-  bool is_valid() { return _is_valid; }\n+  bool is_valid() const { return _is_valid; }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,3 @@\n+  product(bool, AggressiveLivenessForUnstableIf, true, DIAGNOSTIC,          \\\n+          \"Use aggressive liveness for UnstableIf traps\")                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1447,0 +1447,6 @@\n+Node* SafePointNode::peek_operand(uint off) const {\n+  assert(jvms()->sp() > 0, \"must have an operand\");\n+  assert(off < jvms()->sp(), \"off is out-of-range\");\n+  return stack(jvms(), jvms()->sp() - off - 1);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -419,0 +419,2 @@\n+  \/\/ Peek Operand Stacks, JVMS 2.6.2\n+  Node* peek_operand(uint off = 0) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -399,0 +399,4 @@\n+\n+    if (dead->is_CallStaticJava()) {\n+      remove_unstable_if_trap(dead->as_CallStaticJava());\n+    }\n@@ -437,0 +441,1 @@\n+  remove_useless_unstable_if_traps(useful);          \/\/ remove useless unstable_if traps\n@@ -610,0 +615,1 @@\n+                  _unstable_if_traps (comp_arena(), 8, 0, NULL),\n@@ -788,0 +794,2 @@\n+  preprocess_unstable_if_traps();\n+\n@@ -1857,0 +1865,101 @@\n+void Compile::record_unstable_if(UnstableIfTrap* trap) {\n+  if (AggressiveLivenessForUnstableIf) {\n+    _unstable_if_traps.append(trap);\n+  }\n+}\n+\n+void Compile::remove_useless_unstable_if_traps(Unique_Node_List& useful) {\n+  for (int i = _unstable_if_traps.length() - 1; i >= 0; i--) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    Node* n = trap->uncommon_trap();\n+    if (!useful.member(n)) {\n+      _unstable_if_traps.delete_at(i); \/\/ replaces i-th with last element which is known to be useful (already processed)\n+    }\n+  }\n+}\n+\n+\/\/ remove unstable_if trap of unc from candicates. It is either dead or fold-compares case.\n+\/\/\n+\/\/ 'fold-compares' may use the uncommon_trap of the dominating IfNode to cover the fused\n+\/\/ IfNode. This breaks the unstable_if trap invariant: control takes the unstable path\n+\/\/ when deoptimization does happen.\n+void Compile::remove_unstable_if_trap(CallStaticJavaNode* unc) {\n+  for (int i = 0; i < _unstable_if_traps.length(); ++i) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    if (trap->uncommon_trap() == unc) {\n+      _unstable_if_traps.delete_at(i);\n+      break;\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+uint trivial_unstable_if_traps          = 0;\n+uint unstable_if_traps_all              = 0;\n+#endif\n+\n+void Compile::preprocess_unstable_if_traps() {\n+#ifndef PRODUCT\n+  Atomic::add(&unstable_if_traps_all, (uint)_unstable_if_traps.length());\n+\n+  for (int i = 0; i < _unstable_if_traps.length(); i++) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    if (trap->is_trivial()) {\n+      Atomic::inc(&trivial_unstable_if_traps);\n+    }\n+  }\n+#endif\n+}\n+\n+\/\/ Re-calculate unstable_if traps with the liveness of next_bci, which points to the unlikely path.\n+\/\/ It needs to be done after igvn because fold-compares may fuse uncommon_traps and before renumbering.\n+void Compile::process_for_unstable_if_traps(PhaseIterGVN& igvn) {\n+  while (_unstable_if_traps.length() > 0) {\n+    UnstableIfTrap* trap = _unstable_if_traps.pop();\n+    CallStaticJavaNode* unc = trap->uncommon_trap();\n+    int next_bci = trap->next_bci();\n+\n+    if (next_bci != -1) {\n+      assert(!_dead_node_list.test(unc->_idx), \"changing a dead node!\");\n+      JVMState* jvms = unc->jvms();\n+      ciMethod* method = jvms->method();\n+      ciBytecodeStream iter(method);\n+\n+      iter.force_bci(jvms->bci());\n+      assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n+      Bytecodes::Code c = iter.cur_bc();\n+      Node* lhs = nullptr;\n+      Node* rhs = nullptr;\n+      if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n+        lhs = unc->peek_operand(0);\n+        rhs = unc->peek_operand(1);\n+      } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n+        lhs = unc->peek_operand(0);\n+      }\n+\n+      ResourceMark rm;\n+      const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n+      assert(live_locals.is_valid(), \"broken liveness info\");\n+\n+      int len = (int)live_locals.size();\n+      for (int i = 0; i < len; i++) {\n+        Node* local = unc->local(jvms, i);\n+        \/\/ kill local using the liveness of next_bci.\n+        \/\/ give up when the local looks like an operand to secure reexecution.\n+        if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+          uint idx = jvms->locoff() + i;\n+#ifndef PRODUCT\n+          if (Verbose) {\n+            tty->print(\"[unstable_if] kill local#%d: \", idx);\n+            local->dump();\n+            tty->cr();\n+          }\n+#endif\n+          igvn.replace_input_of(unc, idx, top());\n+        }\n+      }\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n@@ -2141,0 +2250,2 @@\n+  process_for_unstable_if_traps(igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class CallStaticJavaNode;\n@@ -93,0 +94,1 @@\n+class UnstableIfTrap;\n@@ -360,0 +362,1 @@\n+  GrowableArray<UnstableIfTrap*> _unstable_if_traps;        \/\/ List of ifnodes after IGVN\n@@ -735,0 +738,5 @@\n+  void remove_unstable_if_trap(CallStaticJavaNode* trap);\n+  void remove_useless_unstable_if_traps(Unique_Node_List &useful);\n+  void preprocess_unstable_if_traps();\n+  void process_for_unstable_if_traps(PhaseIterGVN& igvn);\n+\n@@ -803,0 +811,1 @@\n+  void         record_unstable_if(UnstableIfTrap* trap);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2021,1 +2021,1 @@\n-void GraphKit::uncommon_trap(int trap_request,\n+Node* GraphKit::uncommon_trap(int trap_request,\n@@ -2026,1 +2026,1 @@\n-  if (stopped())  return; \/\/ trap reachable?\n+  if (stopped())  return NULL; \/\/ trap reachable?\n@@ -2142,0 +2142,1 @@\n+  return call;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  void uncommon_trap(int trap_request,\n+  Node* uncommon_trap(int trap_request,\n@@ -736,1 +736,1 @@\n-  void uncommon_trap(Deoptimization::DeoptReason reason,\n+  Node* uncommon_trap(Deoptimization::DeoptReason reason,\n@@ -740,1 +740,1 @@\n-    uncommon_trap(Deoptimization::make_trap_request(reason, action),\n+    return uncommon_trap(Deoptimization::make_trap_request(reason, action),\n@@ -745,1 +745,1 @@\n-  void uncommon_trap_exact(Deoptimization::DeoptReason reason,\n+  Node* uncommon_trap_exact(Deoptimization::DeoptReason reason,\n@@ -749,1 +749,1 @@\n-    uncommon_trap(Deoptimization::make_trap_request(reason, action),\n+    return uncommon_trap(Deoptimization::make_trap_request(reason, action),\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -844,0 +844,1 @@\n+        igvn->C->remove_unstable_if_trap(dom_unc);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -606,0 +606,42 @@\n+\/\/ Specialized uncommon_trap of unstable_if, we have 2 optimizations for them:\n+\/\/   1. suppress trivial Unstable_If traps\n+\/\/   2. use next_bci of _path to update live locals.\n+class UnstableIfTrap {\n+  CallStaticJavaNode* const _unc;\n+  \/\/ Parse::_blocks outlive Parse object itself.\n+  \/\/ They are reclaimed by ResourceMark in CompileBroker::invoke_compiler_on_method().\n+  Parse::Block* const _path; \/\/ The pruned path.\n+\n+public:\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path) {\n+    assert(_unc != NULL && Deoptimization::trap_request_reason(_unc->uncommon_trap_request()) == Deoptimization::Reason_unstable_if,\n+          \"invalid uncommon_trap call!\");\n+  }\n+\n+  \/\/ The starting point of the pruned block, where control should go\n+  \/\/ when deoptimization does happen.\n+  int next_bci() const {\n+    return _path == nullptr ? -1 : _path->start();\n+  }\n+\n+  Parse::Block* path() const {\n+    return _path;\n+  }\n+\n+  \/\/ This can only be determined in parse-time.\n+  \/\/ if _path has only one predecessor, it is trivial if this block is small(1~2 bytecodes)\n+  \/\/ or if _path has more than one predecessor and has been parsed, _unc does not mask out any real code.\n+  bool is_trivial() const {\n+    return _path != nullptr && _path->is_parsed();\n+  }\n+\n+  CallStaticJavaNode* uncommon_trap() const {\n+    return _unc;\n+  }\n+\n+  inline void* operator new(size_t x) throw() {\n+    Compile* C = Compile::current();\n+    return C->comp_arena()->AmallocWords(x);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+extern uint trivial_unstable_if_traps;\n+extern uint unstable_if_traps_all;\n@@ -95,0 +97,5 @@\n+  if (unstable_if_traps_all) {\n+    tty->print_cr(\"%u trivial unstable_if traps (%2u%%)\", trivial_unstable_if_traps,\n+                  (100 * trivial_unstable_if_traps \/ unstable_if_traps_all));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1589,1 +1589,1 @@\n-    uncommon_trap(Deoptimization::Reason_unstable_if,\n+    Node* call = uncommon_trap(Deoptimization::Reason_unstable_if,\n@@ -1593,0 +1593,4 @@\n+\n+    if (call != nullptr) {\n+      C->record_unstable_if(new UnstableIfTrap(call->as_CallStaticJava(), path));\n+    }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8286104\n+ * @summary Test C2 uses aggressive liveness to get rid of the boxing object which is\n+ *  only consumed by uncommon_trap.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestAggressiveLivenessForUnstableIf\n+ *\/\n+public class TestAggressiveLivenessForUnstableIf {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.MAX}) \/\/ the argument needs to be big enough to fall out of cache.\n+    @IR(applyIf = {\"AggressiveLivenessForUnstableIf\", \"true\"}, failOn = {IRNode.ALLOC_OF, \"Integer\"})\n+    public static int boxing_object(int value) {\n+        Integer ii = Integer.valueOf(value);\n+        int sum = 0;\n+\n+        if (value > 999_999) {\n+            sum += ii.intValue();\n+        }\n+\n+        return sum;\n+    }\n+\n+    @Check(test = \"boxing_object\")\n+    public void checkWithTestInfo(int result, TestInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ Accessing the cached boxing object during warm-up phase. It prevents parser from pruning that branch of Interger.valueOf();\n+            \/\/ This guarantees that a phi node is generated, which merge a cached object and the newly allocated object. eg.\n+            \/\/ 112:  Phi  ===  108  168  188  [[ 50 ]]  #java\/lang\/Integer:NotNull:exact *  Oop:java\/lang\/Integer:NotNull:exact *\n+            \/\/ 168: a cached object\n+            \/\/ 188: result of AllocateNode\n+            \/\/  50: uncommon_trap unstable_if\n+            value += Integer.valueOf(0);\n+        }\n+\n+        Asserts.assertEQ(result, Integer.MAX_VALUE);\n+    }\n+\n+    public static Integer value = Integer.valueOf(0);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAggressiveLivenessForUnstableIf.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}