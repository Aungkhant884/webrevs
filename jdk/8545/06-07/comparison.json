{"files":[{"patch":"@@ -397,0 +397,4 @@\n+\n+    if (dead->is_CallStaticJava()) {\n+      invalidate_unstable_if(dead->as_CallStaticJava());\n+    }\n@@ -435,0 +439,1 @@\n+  remove_useless_unstable_ifs(useful); \/\/ remove useless unstable_if traps\n@@ -608,1 +613,1 @@\n-                  _unstable_ifs      (comp_arena(), 8, 0, NULL),\n+                  _unstable_if_traps (comp_arena(), 8, 0, NULL),\n@@ -1860,1 +1865,11 @@\n-    _unstable_ifs.append(trap);\n+    _unstable_if_traps.append(trap);\n+  }\n+}\n+\n+void Compile::remove_useless_unstable_ifs(Unique_Node_List& useful) {\n+  for (int i = _unstable_if_traps.length() - 1; i >= 0; i--) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    Node* n = trap->uncommon_trap();\n+    if (!useful.member(n)) {\n+      _unstable_if_traps.delete_at(i); \/\/ replaces i-th with last element which is known to be useful (already processed)\n+    }\n@@ -1864,0 +1879,5 @@\n+\/\/ Invalidate the speculative bci of unstable_if trap and skip the optimization.\n+\/\/\n+\/\/ 'fold-compares' may use the uncommon_trap of the dominating IfNode to cover the fused\n+\/\/ IfNode. This breaks the unstable_if trap invariant: control takes the unstable path\n+\/\/ when deoptimization does happen.\n@@ -1865,2 +1885,2 @@\n-  for (int i = 0; i < _unstable_ifs.length(); ++i) {\n-    UnstableIfTrap* trap = _unstable_ifs.at(i);\n+  for (int i = 0; i < _unstable_if_traps.length(); ++i) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n@@ -1868,1 +1888,1 @@\n-      trap->set_bci(-1);\n+      _unstable_if_traps.delete_at(i); \/\/ replaces i-th with last element which is known to be useful (already processed)\n@@ -1874,2 +1894,4 @@\n-uint trivial_unstable_ifs          = 0;\n-uint unstable_ifs_all              = 0;\n+#ifndef PRODUCT\n+uint trivial_unstable_if_traps          = 0;\n+uint unstable_if_traps_all              = 0;\n+#endif\n@@ -1878,1 +1900,2 @@\n-  Atomic::add(&unstable_ifs_all, (uint)_unstable_ifs.length());\n+#ifndef PRODUCT\n+  Atomic::add(&unstable_if_traps_all, (uint)_unstable_if_traps.length());\n@@ -1880,2 +1903,2 @@\n-  for (int i=0; i < _unstable_ifs.length(); i++) {\n-    UnstableIfTrap* trap = _unstable_ifs.at(i);\n+  for (int i = 0; i < _unstable_if_traps.length(); i++) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n@@ -1883,1 +1906,1 @@\n-      Atomic::inc(&trivial_unstable_ifs);\n+      Atomic::inc(&trivial_unstable_if_traps);\n@@ -1886,0 +1909,1 @@\n+#endif\n@@ -1891,5 +1915,2 @@\n-  if (!AggressiveLivenessForUnstableIf)\n-    return;\n-\n-  while (_unstable_ifs.length() > 0) {\n-    UnstableIfTrap* trap = _unstable_ifs.pop();\n+  while (_unstable_if_traps.length() > 0) {\n+    UnstableIfTrap* trap = _unstable_if_traps.pop();\n@@ -1899,1 +1920,2 @@\n-    if (next_bci != -1 && !_dead_node_list.test(unc->_idx)) {\n+    if (next_bci != -1) {\n+      assert(!_dead_node_list.test(unc->_idx), \"changing a dead node!\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  GrowableArray<UnstableIfTrap*> _unstable_ifs;        \/\/ List of ifnodes after IGVN\n+  GrowableArray<UnstableIfTrap*> _unstable_if_traps;        \/\/ List of ifnodes after IGVN\n@@ -981,0 +981,1 @@\n+  void remove_useless_unstable_ifs(Unique_Node_List &useful);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -610,3 +610,2 @@\n-  CallStaticJavaNode* _unc;\n-  Parse::Block* _path;  \/\/ the pruned path\n-  int _next_bci;        \/\/ speculative bci which takes _path.\n+  CallStaticJavaNode* const _unc;\n+  Parse::Block* const _path;  \/\/ the pruned path\n@@ -615,1 +614,1 @@\n-  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path), _next_bci(-1) {\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _path(path){\n@@ -618,4 +617,0 @@\n-\n-    if (_path != NULL) {\n-      _next_bci = _path->start();\n-    }\n@@ -624,5 +619,2 @@\n-  int next_bci() const { return _next_bci; }\n-\n-  void set_bci(int bci) {\n-    assert(bci == -1 || _next_bci == -1, \"attempt to overwrite next_bci\");\n-    _next_bci = bci;\n+  int next_bci() const {\n+    return _path == nullptr ? -1 : _path->start();\n@@ -635,1 +627,1 @@\n-    return _path->is_parsed();\n+    return _path != nullptr && _path->is_parsed();\n@@ -648,1 +640,1 @@\n-    return C->node_arena()->AmallocWords(x);\n+    return C->comp_arena()->AmallocWords(x);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-extern uint trivial_unstable_ifs;\n-extern uint unstable_ifs_all;\n+extern uint trivial_unstable_if_traps;\n+extern uint unstable_if_traps_all;\n@@ -97,3 +97,3 @@\n-  if (unstable_ifs_all) {\n-    tty->print_cr(\"%u trivial unstable_ifs (%2d%%)\", trivial_unstable_ifs,\n-                  (100 * trivial_unstable_ifs \/ unstable_ifs_all));\n+  if (unstable_if_traps_all) {\n+    tty->print_cr(\"%u trivial unstable_if traps (%2u%%)\", trivial_unstable_if_traps,\n+                  (100 * trivial_unstable_if_traps \/ unstable_if_traps_all));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}