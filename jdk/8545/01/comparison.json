{"files":[{"patch":"@@ -49,1 +49,1 @@\n-  bool is_valid() { return _is_valid; }\n+  bool is_valid() const { return _is_valid; }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,3 @@\n+  product(bool, AggressiveLivenessForUnstableIf, true, DIAGNOSTIC,          \\\n+          \"Use aggressive liveness for UnstableIf traps\")                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1550,0 +1550,6 @@\n+Node *SafePointNode::peek_operand(uint off) const {\n+  assert(jvms()->sp() > 0, \"must have an operand\");\n+  assert(off < jvms()->sp(), \"off is out-of-range\");\n+  return stack(jvms(), jvms()->sp() - off - 1);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -420,0 +420,2 @@\n+  \/\/ peek Operand Stacks, JVMS 2.6.2\n+  Node *peek_operand(uint off = 0) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call) const;\n@@ -316,0 +315,1 @@\n+  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n@@ -385,0 +385,1 @@\n+  int   _unc_bci;               \/\/ speculative bci for unstable_if trap\n@@ -386,1 +387,1 @@\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n+    : MultiBranchNode(2), _prob(p), _fcnt(fcnt), _unc_bci(-1) {\n@@ -402,0 +403,6 @@\n+  int unc_bci() const { return _unc_bci; }\n+  void set_unc_bci(int bci) {\n+    assert(bci == -1 || _unc_bci == -1, \"attempt to overwrite unc_bci\");\n+    _unc_bci = bci;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -608,0 +608,1 @@\n+                  _unstable_ifs      (comp_arena(), 8, 0, NULL),\n@@ -1829,0 +1830,73 @@\n+\/\/ only record well-formed if nodes.\n+\/\/ we only process a node once,so it is fine with duplication.\n+void Compile::record_unstable_if(IfNode *iff) {\n+  CallStaticJavaNode *unc;\n+\n+  if (aggressive_unstable_if() && iff->unc_bci() != -1 && iff->outcnt() == 2\n+      && iff->uncommon_trap_proj(unc, Deoptimization::Reason_unstable_if) != nullptr) {\n+    _unstable_ifs.append(iff);\n+  }\n+}\n+\n+\/\/ Re-calculate unstable_if traps with the liveness of next_bci, which points to the unlikely path.\n+\/\/ It needs to be done after igvn because fold-compares may fuse uncommon_traps and\n+\/\/ before renumbering.\n+void Compile::process_for_unstable_ifs(PhaseIterGVN& igvn) {\n+  while (_unstable_ifs.length() > 0) {\n+    IfNode *iff = _unstable_ifs.pop();\n+    int next_bci = iff->unc_bci();\n+\n+    if (next_bci != -1 && !_dead_node_list.test(iff->_idx)) {\n+      CallStaticJavaNode *unc;\n+      ProjNode *proj = iff->uncommon_trap_proj(unc, Deoptimization::Reason_unstable_if);\n+\n+      if (proj != nullptr) {\n+        ProjNode *other_proj = proj->other_if_proj();\n+        \/\/ give up if 2 branches are unstable. It could happen if program is under-profiling.\n+        if (other_proj->is_uncommon_trap_proj(Deoptimization::Reason_unstable_if) == nullptr) {\n+          JVMState *jvms = unc->jvms();\n+          ciMethod *method = jvms->method();\n+          ciBytecodeStream iter(method);\n+\n+          iter.force_bci(jvms->bci());\n+          assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n+          Bytecodes::Code c = iter.cur_bc();\n+          Node *lhs = nullptr;\n+          Node *rhs = nullptr;\n+          if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n+            lhs = unc->peek_operand(0);\n+            rhs = unc->peek_operand(1);\n+          } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n+            lhs = unc->peek_operand(0);\n+          }\n+\n+          ResourceMark rm;\n+          const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n+          assert(live_locals.is_valid(), \"broken liveness info\");\n+\n+          int len = (int)live_locals.size();\n+          for (int i = 0; i < len; i++) {\n+            Node *local = unc->local(jvms, i);\n+            \/\/ kill local using the liveness of next_bci.\n+            \/\/ yield when local looks like an operand to secure reexecution.\n+            if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+              uint idx = jvms->locoff() + i;\n+#ifndef PRODUCT\n+              if (Verbose) {\n+                tty->print(\"[unstable_if] kill local#%d: \", idx);\n+                local->dump();\n+                tty->cr();\n+              }\n+#endif\n+              igvn.replace_input_of(unc, idx, top());\n+            }\n+          }\n+          igvn._worklist.push(iff);\n+        }\n+      }\n+      iff->set_unc_bci(-1);\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n@@ -2115,0 +2189,2 @@\n+  process_for_unstable_ifs(igvn);\n+\n@@ -2134,0 +2210,2 @@\n+  process_for_unstable_ifs(igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -358,0 +358,1 @@\n+  GrowableArray<IfNode *> _unstable_ifs;        \/\/ List of ifnodes after IGVN\n@@ -550,0 +551,4 @@\n+  \/** Adjust liveness for unstable ifs. *\/\n+  bool              aggressive_unstable_if() const {\n+    return AggressiveLivenessForUnstableIf && !env()->should_retain_local_variables();\n+  }\n@@ -732,0 +737,1 @@\n+  void process_for_unstable_ifs(PhaseIterGVN& igvn);\n@@ -801,0 +807,1 @@\n+  void         record_unstable_if(IfNode *iff);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call) const {\n+ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason) const {\n@@ -797,1 +797,1 @@\n-    call = proj_out(i)->is_uncommon_trap_proj(Deoptimization::Reason_none);\n+    call = proj_out(i)->is_uncommon_trap_proj(reason);\n@@ -1090,0 +1090,3 @@\n+\n+    \/\/ suppress unstable_if optimization for the dominating if.\n+    proj->in(0)->as_If()->set_unc_bci(-1);\n@@ -1297,0 +1300,2 @@\n+  \/\/ suppress unstable_if optimization for the dominating if.\n+  c->in(0)->as_If()->set_unc_bci(-1);\n@@ -1467,0 +1472,2 @@\n+  igvn->C->record_unstable_if(this);\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1587,0 +1587,4 @@\n+    IfNode *iff = control()->in(0)->as_If();\n+    int next_bci = is_fallthrough ? iter().next_bci() : iter().get_dest();\n+    iff->set_unc_bci(next_bci);\n+\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8286104\n+ * @summary Test C2 uses aggressive liveness to get rid of the boxing object which is\n+ *  only consumed by uncommon_trap.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestAggressiveLivenessForUnstableIf\n+ *\/\n+public class TestAggressiveLivenessForUnstableIf {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.MAX}) \/\/ the argument needs to be big enough to fall out of cache.\n+    @IR(applyIf = {\"AggressiveLivenessForUnstableIf\", \"true\"}, failOn = {IRNode.ALLOC_OF, \"Integer\"})\n+    public static int boxing_object(int value) {\n+        Integer ii = Integer.valueOf(value);\n+        int sum = 0;\n+\n+        if (value > 999_999) {\n+            sum += ii.intValue();\n+        }\n+\n+        return sum;\n+    }\n+\n+    @Check(test = \"boxing_object\")\n+    public void checkWithTestInfo(int result, TestInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ Accessing the cached boxing object during warm-up phase. It prevents parser from pruning that branch of Interger.valueOf();\n+            \/\/ This guarantees that a phi node is generated, which merge a cached object and the newly allocated object. eg.\n+            \/\/ 112:  Phi  ===  108  168  188  [[ 50 ]]  #java\/lang\/Integer:NotNull:exact *  Oop:java\/lang\/Integer:NotNull:exact *\n+            \/\/ 168: a cached object\n+            \/\/ 188: result of AllocateNode\n+            \/\/  50: uncommon_trap unstable_if\n+            value += Integer.valueOf(0);\n+        }\n+\n+        Asserts.assertEQ(result, Integer.MAX_VALUE);\n+    }\n+\n+    public static Integer value = Integer.valueOf(0);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAggressiveLivenessForUnstableIf.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}