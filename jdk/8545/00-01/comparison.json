{"files":[{"patch":"@@ -49,1 +49,1 @@\n-  bool is_valid() { return _is_valid; }\n+  bool is_valid() const { return _is_valid; }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-  develop(bool, AggressiveLivenessForUnstableIf, true,                      \\\n+  product(bool, AggressiveLivenessForUnstableIf, true, DIAGNOSTIC,          \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1550,0 +1550,6 @@\n+Node *SafePointNode::peek_operand(uint off) const {\n+  assert(jvms()->sp() > 0, \"must have an operand\");\n+  assert(off < jvms()->sp(), \"off is out-of-range\");\n+  return stack(jvms(), jvms()->sp() - off - 1);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -420,0 +420,2 @@\n+  \/\/ peek Operand Stacks, JVMS 2.6.2\n+  Node *peek_operand(uint off = 0) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call) const;\n@@ -316,0 +315,1 @@\n+  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n@@ -385,0 +385,1 @@\n+  int   _unc_bci;               \/\/ speculative bci for unstable_if trap\n@@ -386,1 +387,1 @@\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n+    : MultiBranchNode(2), _prob(p), _fcnt(fcnt), _unc_bci(-1) {\n@@ -402,0 +403,6 @@\n+  int unc_bci() const { return _unc_bci; }\n+  void set_unc_bci(int bci) {\n+    assert(bci == -1 || _unc_bci == -1, \"attempt to overwrite unc_bci\");\n+    _unc_bci = bci;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -608,0 +608,1 @@\n+                  _unstable_ifs      (comp_arena(), 8, 0, NULL),\n@@ -1829,0 +1830,73 @@\n+\/\/ only record well-formed if nodes.\n+\/\/ we only process a node once,so it is fine with duplication.\n+void Compile::record_unstable_if(IfNode *iff) {\n+  CallStaticJavaNode *unc;\n+\n+  if (aggressive_unstable_if() && iff->unc_bci() != -1 && iff->outcnt() == 2\n+      && iff->uncommon_trap_proj(unc, Deoptimization::Reason_unstable_if) != nullptr) {\n+    _unstable_ifs.append(iff);\n+  }\n+}\n+\n+\/\/ Re-calculate unstable_if traps with the liveness of next_bci, which points to the unlikely path.\n+\/\/ It needs to be done after igvn because fold-compares may fuse uncommon_traps and\n+\/\/ before renumbering.\n+void Compile::process_for_unstable_ifs(PhaseIterGVN& igvn) {\n+  while (_unstable_ifs.length() > 0) {\n+    IfNode *iff = _unstable_ifs.pop();\n+    int next_bci = iff->unc_bci();\n+\n+    if (next_bci != -1 && !_dead_node_list.test(iff->_idx)) {\n+      CallStaticJavaNode *unc;\n+      ProjNode *proj = iff->uncommon_trap_proj(unc, Deoptimization::Reason_unstable_if);\n+\n+      if (proj != nullptr) {\n+        ProjNode *other_proj = proj->other_if_proj();\n+        \/\/ give up if 2 branches are unstable. It could happen if program is under-profiling.\n+        if (other_proj->is_uncommon_trap_proj(Deoptimization::Reason_unstable_if) == nullptr) {\n+          JVMState *jvms = unc->jvms();\n+          ciMethod *method = jvms->method();\n+          ciBytecodeStream iter(method);\n+\n+          iter.force_bci(jvms->bci());\n+          assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n+          Bytecodes::Code c = iter.cur_bc();\n+          Node *lhs = nullptr;\n+          Node *rhs = nullptr;\n+          if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n+            lhs = unc->peek_operand(0);\n+            rhs = unc->peek_operand(1);\n+          } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n+            lhs = unc->peek_operand(0);\n+          }\n+\n+          ResourceMark rm;\n+          const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n+          assert(live_locals.is_valid(), \"broken liveness info\");\n+\n+          int len = (int)live_locals.size();\n+          for (int i = 0; i < len; i++) {\n+            Node *local = unc->local(jvms, i);\n+            \/\/ kill local using the liveness of next_bci.\n+            \/\/ yield when local looks like an operand to secure reexecution.\n+            if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+              uint idx = jvms->locoff() + i;\n+#ifndef PRODUCT\n+              if (Verbose) {\n+                tty->print(\"[unstable_if] kill local#%d: \", idx);\n+                local->dump();\n+                tty->cr();\n+              }\n+#endif\n+              igvn.replace_input_of(unc, idx, top());\n+            }\n+          }\n+          igvn._worklist.push(iff);\n+        }\n+      }\n+      iff->set_unc_bci(-1);\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n@@ -2115,0 +2189,2 @@\n+  process_for_unstable_ifs(igvn);\n+\n@@ -2134,0 +2210,2 @@\n+  process_for_unstable_ifs(igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -358,0 +358,1 @@\n+  GrowableArray<IfNode *> _unstable_ifs;        \/\/ List of ifnodes after IGVN\n@@ -550,0 +551,4 @@\n+  \/** Adjust liveness for unstable ifs. *\/\n+  bool              aggressive_unstable_if() const {\n+    return AggressiveLivenessForUnstableIf && !env()->should_retain_local_variables();\n+  }\n@@ -732,0 +737,1 @@\n+  void process_for_unstable_ifs(PhaseIterGVN& igvn);\n@@ -801,0 +807,1 @@\n+  void         record_unstable_if(IfNode *iff);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-PreserveJVMState::PreserveJVMState(GraphKit* kit, bool clone_map, bool recover_bci) {\n+PreserveJVMState::PreserveJVMState(GraphKit* kit, bool clone_map) {\n@@ -664,2 +664,0 @@\n-  _bci    = kit->bci();\n-  _recover_bci = recover_bci;\n@@ -668,0 +666,1 @@\n+  _bci    = kit->bci();\n@@ -676,1 +675,1 @@\n-  assert(_recover_bci || kit->bci() == _bci, \"bci must not shift\");\n+  assert(kit->bci() == _bci, \"bci must not shift\");\n@@ -681,3 +680,0 @@\n-  if (_recover_bci) {\n-    kit->set_bci(_bci);\n-  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -918,1 +918,0 @@\n-#endif\n@@ -920,2 +919,1 @@\n-  \/\/ AggressiveLivenessForUnstableIf updates bci. Force parser to recovery bci.\n-  bool           _recover_bci;\n+#endif\n@@ -926,1 +924,1 @@\n-  PreserveJVMState(GraphKit* kit, bool clone_map = true, bool recover_bci = false);\n+  PreserveJVMState(GraphKit* kit, bool clone_map = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call) const {\n+ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason) const {\n@@ -797,1 +797,1 @@\n-    call = proj_out(i)->is_uncommon_trap_proj(Deoptimization::Reason_none);\n+    call = proj_out(i)->is_uncommon_trap_proj(reason);\n@@ -1090,0 +1090,3 @@\n+\n+    \/\/ suppress unstable_if optimization for the dominating if.\n+    proj->in(0)->as_If()->set_unc_bci(-1);\n@@ -1297,0 +1300,2 @@\n+  \/\/ suppress unstable_if optimization for the dominating if.\n+  c->in(0)->as_If()->set_unc_bci(-1);\n@@ -1467,0 +1472,2 @@\n+  igvn->C->record_unstable_if(this);\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1401,1 +1401,1 @@\n-  { PreserveJVMState pjvms(this, true, true\/*recover_bci*\/);\n+  { PreserveJVMState pjvms(this);\n@@ -1515,1 +1515,1 @@\n-  { PreserveJVMState pjvms(this, true, true\/*recover_bci*\/);\n+  { PreserveJVMState pjvms(this);\n@@ -1587,9 +1587,3 @@\n-    if (AggressiveLivenessForUnstableIf) {\n-      if (is_fallthrough) {\n-        set_bci(iter().next_bci());\n-      } else {\n-        set_bci(iter().get_dest());\n-      }\n-    } else {\n-      repush_if_args();\n-    }\n+    IfNode *iff = control()->in(0)->as_If();\n+    int next_bci = is_fallthrough ? iter().next_bci() : iter().get_dest();\n+    iff->set_unc_bci(next_bci);\n@@ -1597,0 +1591,1 @@\n+    repush_if_args();\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-    @IR(counts = {IRNode.UNSTABLE_IF_TRAP, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAggressiveLivenessForUnstableIf.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,0 @@\n-        Label destLocation = new Label();\n@@ -149,1 +148,0 @@\n-        boolean adjustBciForUnstableIf = WB.getBooleanVMFlag(\"AggressiveLivenessForUnstableIf\");\n@@ -153,1 +151,1 @@\n-                    generateTest(unstableIfLocation, destLocation));\n+                    generateTest(unstableIfLocation));\n@@ -178,8 +176,1 @@\n-        int bci = unstableIfLocation.getOffset();\n-        if (adjustBciForUnstableIf) {\n-          if (!testCase.predicate) {\n-            bci += 3; \/\/ fall-through. ifeq 2: branchbyte1, branchbyte2\n-          } else {\n-            bci = destLocation.getOffset();\n-          }\n-        }\n+\n@@ -199,1 +190,1 @@\n-                Integer.toString(bci));\n+                Integer.toString(unstableIfLocation.getOffset()));\n@@ -242,1 +233,1 @@\n-    private static byte[] generateTest(Label unstableIfLocation, Label destLocation) {\n+    private static byte[] generateTest(Label unstableIfLocation) {\n@@ -251,1 +242,1 @@\n-        generateTestMethod(cw, unstableIfLocation, destLocation);\n+        generateTestMethod(cw, unstableIfLocation);\n@@ -257,1 +248,1 @@\n-            Label unstableIfLocation, Label falseBranch) {\n+            Label unstableIfLocation) {\n@@ -263,0 +254,1 @@\n+        Label falseBranch = new Label();\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestUnstableIfTrap.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"}]}