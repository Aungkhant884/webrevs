{"files":[{"patch":"@@ -1685,0 +1685,1 @@\n+  G1FromCardCache::initialize(max_reserved_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"gc\/g1\/g1ConcurrentRefine.hpp\"\n+#include \"gc\/g1\/g1DirtyCardQueue.hpp\"\n@@ -27,1 +29,0 @@\n-#include \"gc\/g1\/g1RemSet.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -38,1 +40,1 @@\n-void G1FromCardCache::initialize(uint num_par_rem_sets, uint max_reserved_regions) {\n+void G1FromCardCache::initialize(uint max_reserved_regions) {\n@@ -44,1 +46,1 @@\n-  _max_workers = num_par_rem_sets;\n+  _max_workers = num_par_rem_sets();\n@@ -47,1 +49,1 @@\n-                                                             num_par_rem_sets,\n+                                                             num_par_rem_sets(),\n@@ -62,1 +64,1 @@\n-  for (uint i = 0; i < G1RemSet::num_par_rem_sets(); i++) {\n+  for (uint i = 0; i < num_par_rem_sets(); i++) {\n@@ -71,1 +73,1 @@\n-  for (uint i = 0; i < G1RemSet::num_par_rem_sets(); i++) {\n+  for (uint i = 0; i < num_par_rem_sets(); i++) {\n@@ -80,0 +82,4 @@\n+uint G1FromCardCache::num_par_rem_sets() {\n+  return G1DirtyCardQueueSet::num_par_ids() + G1ConcurrentRefine::max_num_threads() + MAX2(ConcGCThreads, ParallelGCThreads);\n+}\n+\n@@ -81,1 +87,1 @@\n-  uint num_par_remsets = G1RemSet::num_par_rem_sets();\n+  uint num_par_remsets = num_par_rem_sets();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+  \/\/ Gives an approximation on how many threads can be expected to add records to\n+  \/\/ a remembered set in parallel. This is used for sizing the G1FromCardCache to\n+  \/\/ decrease performance losses due to data structure sharing.\n+  \/\/ Examples for quantities that influence this value are the maximum number of\n+  \/\/ mutator threads, maximum number of concurrent refinement or GC threads.\n+  static uint num_par_rem_sets();\n+\n@@ -82,1 +89,1 @@\n-  static void initialize(uint num_par_rem_sets, uint max_reserved_regions);\n+  static void initialize(uint max_reserved_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/g1\/g1_globals.hpp\"\n@@ -484,4 +485,0 @@\n-uint G1RemSet::num_par_rem_sets() {\n-  return G1DirtyCardQueueSet::num_par_ids() + G1ConcurrentRefine::max_num_threads() + MAX2(ConcGCThreads, ParallelGCThreads);\n-}\n-\n@@ -489,1 +486,0 @@\n-  G1FromCardCache::initialize(num_par_rem_sets(), max_reserved_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,6 +73,0 @@\n-  \/\/ Gives an approximation on how many threads can be expected to add records to\n-  \/\/ a remembered set in parallel. This can be used for sizing data structures to\n-  \/\/ decrease performance losses due to data structure sharing.\n-  \/\/ Examples for quantities that influence this value are the maximum number of\n-  \/\/ mutator threads, maximum number of concurrent refinement or GC threads.\n-  static uint num_par_rem_sets();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}