{"files":[{"patch":"@@ -800,0 +800,2 @@\n+                    final WeakReference<ExecutorService> executorServiceRef =\n+                        new WeakReference<ExecutorService>(es);\n@@ -805,2 +807,0 @@\n-                            final WeakReference<ExecutorService> executorServiceRef =\n-                                new WeakReference<ExecutorService>(es);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingWorker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+import sun.awt.SunToolkit;\n+import sun.awt.AppContext;\n+\n+import java.awt.Toolkit;\n+\n+import javax.swing.SwingWorker;\n+import java.lang.ref.WeakReference;\n+import java.util.concurrent.ExecutorService;\n+import java.beans.PropertyChangeListener;\n+\n+\/**\n+ * @test\n+ * @bug 8314755\n+ * @summary SwingWorker listener should not keep strong reference to executor\n+ * @run main SwingWorkerExecutorLeakTest\n+ *\/\n+public class SwingWorkerExecutorLeakTest {\n+\n+  private static AppContext appContext;\n+\n+  public static void main(String[] args) throws Exception {\n+\n+    \/\/ AppContext must be in different thread group, otherwise dispose() throws\n+    Thread thread = new Thread(new ThreadGroup(\"Test\"), \"Test\") {\n+      public void run() {\n+        if (true) {\n+          \/\/ AppContext.getAppContext() creates AppContext in root thread group unless\n+          \/\/ (javaplugin.version != null || javawebstart.version != null) && javafx.version != null\n+          System.setProperty(\"javaplugin.version\", \"foo\");\n+          System.setProperty(\"javawebstart.version\", \"foo\");\n+          System.setProperty(\"javafx.version\", \"foo\");\n+        }\n+        else {\n+          \/\/ alternative: call SunToolkit.createNewAppContext() directly, uses current thread group\n+          SunToolkit.createNewAppContext();\n+        }\n+\n+        \/\/ SwingWorker.execute() calls SwingWorker.getWorkersExecutorService(),\n+        \/\/ which calls AppContext.getAppContext() and stores reference to executor in AppContext\n+        new SwingWorker<Void, Void>() {\n+          protected Void doInBackground() {\n+            return null;\n+          }\n+        }.execute();\n+\n+        \/\/ remember AppContext created in this thread group\n+        appContext = AppContext.getAppContext();\n+      }\n+    };\n+    thread.start();\n+    thread.join();\n+\n+    \/\/ SwingWorker.getWorkersExecutorService() stored the executor in the AppContext map\n+    WeakReference<ExecutorService> executor = new WeakReference<>((ExecutorService)appContext.get(SwingWorker.class));\n+\n+    appContext.dispose();\n+\n+    \/\/ dispose() cleared the AppContext map\n+    if (appContext.get(SwingWorker.class) != null) throw new AssertionError();\n+\n+    \/\/ dispose() called the listener defined in SwingWorker.getWorkersExecutorService(),\n+    \/\/ which called shutdown() on the executor\n+    if (! executor.get().isShutdown()) throw new AssertionError();\n+\n+    \/\/ but the listener retains a strong reference to the executor,\n+    \/\/ and dispose() doesn't clear the list of listeners\n+    \/\/ reference chain: appContext -> listener -> executor\n+\n+    if (false) {\n+      \/\/ this would make the executor unreachable\n+      appContext = null;\n+    }\n+\n+    if (false) {\n+      \/\/ this would make the executor unreachable\n+      PropertyChangeListener listener = appContext.getPropertyChangeListeners(AppContext.DISPOSED_PROPERTY_NAME)[0];\n+      appContext.removePropertyChangeListener(AppContext.DISPOSED_PROPERTY_NAME, listener);\n+      listener = null;\n+    }\n+\n+    System.gc();\n+    if (executor.get() != null) {\n+      throw new RuntimeException(\"executor created by SwingWorker.getWorkersExecutorService() is still strongly referenced\");\n+    }\n+  }\n+}\n","filename":"test\/jdk\/javax\/swing\/SwingWorker\/8314755\/SwingWorkerExecutorLeakTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}