{"files":[{"patch":"@@ -190,1 +190,1 @@\n-                } else if (!isOverridingMethod && !isSynthetic() && !isAnonymous()) {\n+                } else if (!isOverridingMethod && !isSynthetic() && !isAnonymous() && !isRecordComponentOrField()) {\n@@ -251,17 +251,19 @@\n-        if (!isOverridingMethod) {\n-            switch (env.currElement.getKind()) {\n-                case METHOD:\n-                case CONSTRUCTOR: {\n-                    ExecutableElement ee = (ExecutableElement) env.currElement;\n-                    checkParamsDocumented(ee.getTypeParameters());\n-                    checkParamsDocumented(ee.getParameters());\n-                    switch (ee.getReturnType().getKind()) {\n-                        case VOID:\n-                        case NONE:\n-                            break;\n-                        default:\n-                            if (!foundReturn\n-                                    && !foundInheritDoc\n-                                    && !env.types.isSameType(ee.getReturnType(), env.java_lang_Void)) {\n-                                reportMissing(\"dc.missing.return\");\n-                            }\n+        \/\/ the following checks are made after the scan, which will record @param tags\n+        if (isDeclaredType()) {\n+            TypeElement te = (TypeElement) env.currElement;\n+            \/\/ checkParamsDocumented(te.getTypeParameters()); \/\/ See JDK-8285496\n+            checkParamsDocumented(te.getRecordComponents());\n+        } else if (isExecutable()) {\n+            if (!isOverridingMethod) {\n+                ExecutableElement ee = (ExecutableElement) env.currElement;\n+                checkParamsDocumented(ee.getTypeParameters());\n+                checkParamsDocumented(ee.getParameters());\n+                switch (ee.getReturnType().getKind()) {\n+                    case VOID, NONE -> {\n+                    }\n+                    default -> {\n+                        if (!foundReturn\n+                                && !foundInheritDoc\n+                                && !env.types.isSameType(ee.getReturnType(), env.java_lang_Void)) {\n+                            reportMissing(\"dc.missing.return\");\n+                        }\n@@ -269,1 +271,0 @@\n-                    checkThrowsDocumented(ee.getThrownTypes());\n@@ -271,0 +272,1 @@\n+                checkThrowsDocumented(ee.getThrownTypes());\n@@ -1210,0 +1212,20 @@\n+    private boolean isDeclaredType() {\n+        ElementKind ek = env.currElement.getKind();\n+        return ek.isClass() || ek.isInterface();\n+    }\n+\n+    private boolean isExecutable() {\n+        ElementKind ek = env.currElement.getKind();\n+        return switch (ek) {\n+            case CONSTRUCTOR, METHOD -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean isRecordComponentOrField() {\n+        return env.currElement.getKind() == ElementKind.RECORD_COMPONENT\n+            || env.currElement.getEnclosingElement() != null\n+                && env.currElement.getEnclosingElement().getKind() == ElementKind.RECORD\n+                && env.currElement.getKind() == ElementKind.FIELD;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":41,"deletions":19,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8004832 8284994\n+ * @summary Add new doclint package\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.doclint\n+ * @build DocLintTester\n+ * @run main DocLintTester -Xmsgs:-missing MissingRecordParamsTest.java\n+ * @run main DocLintTester -Xmsgs:missing -ref MissingRecordParamsTest.out MissingRecordParamsTest.java\n+ *\/\n+\n+\/** . *\/\n+public record MissingRecordParamsTest(int x) {  }\n","filename":"test\/langtools\/tools\/doclint\/MissingRecordParamsTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+MissingRecordParamsTest.java:12: warning: no @param for x\n+public record MissingRecordParamsTest(int x) {  }\n+       ^\n+1 warning\n","filename":"test\/langtools\/tools\/doclint\/MissingRecordParamsTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8004832 8284994\n+ * @summary Add new doclint package\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.doclint\n+ * @build DocLintTester\n+ * @run main DocLintTester -Xmsgs:all -ref RecordParamsTest.out RecordParamsTest.java\n+ *\/\n+\n+\/**\n+ * Comment.\n+ * @param a aaa\n+ * @param a aaa\n+ * @param z zzz\n+ *\/\n+public record RecordParamsTest(int a, int b, int c) {  }\n","filename":"test\/langtools\/tools\/doclint\/RecordParamsTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+RecordParamsTest.java:13: warning: @param \"a\" has already been specified\n+ * @param a aaa\n+   ^\n+RecordParamsTest.java:14: error: invalid use of @param\n+ * @param z zzz\n+   ^\n+RecordParamsTest.java:16: warning: no @param for b\n+public record RecordParamsTest(int a, int b, int c) {  }\n+       ^\n+RecordParamsTest.java:16: warning: no @param for c\n+public record RecordParamsTest(int a, int b, int c) {  }\n+       ^\n+1 error\n+3 warnings\n","filename":"test\/langtools\/tools\/doclint\/RecordParamsTest.out","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"}]}