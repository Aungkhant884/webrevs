{"files":[{"patch":"@@ -39,10 +39,3 @@\n-G1ServiceThread::G1ServiceThread() :\n-    ConcurrentGCThread(),\n-    _monitor(Mutex::nonleaf,\n-             \"G1ServiceThread monitor\",\n-             true,\n-             Monitor::_safepoint_check_never),\n-    _last_periodic_gc_attempt_s(os::elapsedTime()),\n-    _vtime_accum(0) {\n-  set_name(\"G1 Service\");\n-  create_and_start();\n+G1SentinelTask::G1SentinelTask() : G1ServiceTask(\"Sentinel Task\") {\n+  set_time(DBL_MAX);\n+  set_next(this);\n@@ -51,6 +44,2 @@\n-void G1ServiceThread::sleep_before_next_cycle() {\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  if (!should_terminate()) {\n-    uintx waitms = G1ConcRefinementServiceIntervalMillis;\n-    ml.wait(waitms);\n-  }\n+void G1SentinelTask::execute() {\n+  guarantee(false, \"Sentinel service task should never be executed.\");\n@@ -59,7 +48,4 @@\n-bool G1ServiceThread::should_start_periodic_gc() {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n-  if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n-    log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n-    return false;\n-  }\n+uint64_t G1SentinelTask::delay_ms() {\n+  guarantee(false, \"Sentinel service task should never be scheduled.\");\n+  return 0;\n+}\n@@ -67,7 +53,4 @@\n-  \/\/ Check if enough time has passed since the last GC.\n-  uintx time_since_last_gc = (uintx)g1h->time_since_last_collection().milliseconds();\n-  if ((time_since_last_gc < G1PeriodicGCInterval)) {\n-    log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n-                            time_since_last_gc, G1PeriodicGCInterval);\n-    return false;\n-  }\n+bool G1SentinelTask::should_reschedule() {\n+  guarantee(false, \"Sentinel service task should never be scheduled.\");\n+  return false;\n+}\n@@ -75,8 +58,9 @@\n-  \/\/ Check if load is lower than max.\n-  double recent_load;\n-  if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n-      (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n-    log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n-                            recent_load, G1PeriodicGCSystemLoadThreshold);\n-    return false;\n-  }\n+\/\/ Task handling periodic GCs\n+class G1PeriodicGCTask : public G1ServiceTask {\n+  bool should_start_periodic_gc() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n+    if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n+      log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n+      return false;\n+    }\n@@ -84,2 +68,7 @@\n-  return true;\n-}\n+    \/\/ Check if enough time has passed since the last GC.\n+    uintx time_since_last_gc = (uintx)g1h->time_since_last_collection().milliseconds();\n+    if ((time_since_last_gc < G1PeriodicGCInterval)) {\n+      log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n+                              time_since_last_gc, G1PeriodicGCInterval);\n+      return false;\n+    }\n@@ -87,4 +76,9 @@\n-void G1ServiceThread::check_for_periodic_gc(){\n-  \/\/ If disabled, just return.\n-  if (G1PeriodicGCInterval == 0) {\n-    return;\n+    \/\/ Check if load is lower than max.\n+    double recent_load;\n+    if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n+        (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n+      log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n+                              recent_load, G1PeriodicGCSystemLoadThreshold);\n+      return false;\n+    }\n+    return true;\n@@ -92,1 +86,7 @@\n-  if ((os::elapsedTime() - _last_periodic_gc_attempt_s) > (G1PeriodicGCInterval \/ 1000.0)) {\n+\n+  void check_for_periodic_gc(){\n+    \/\/ If disabled, just return.\n+    if (G1PeriodicGCInterval == 0) {\n+      return;\n+    }\n+\n@@ -99,1 +99,0 @@\n-    _last_periodic_gc_attempt_s = os::elapsedTime();\n@@ -101,13 +100,2 @@\n-}\n-\n-void G1ServiceThread::run_service() {\n-  double vtime_start = os::elapsedVTime();\n-\n-  while (!should_terminate()) {\n-    sample_young_list_rs_length();\n-\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n+public:\n+  G1PeriodicGCTask(const char* name) : G1ServiceTask(name) { }\n@@ -115,0 +103,1 @@\n+  virtual void execute() {\n@@ -116,0 +105,1 @@\n+  }\n@@ -117,1 +107,6 @@\n-    sleep_before_next_cycle();\n+  virtual uint64_t delay_ms() {\n+    \/\/ G1PeriodicGCInterval is a manageable flag and can be updated\n+    \/\/ during runtime. If no value is set, wait a second and run it\n+    \/\/ again to see if the value has been updated. Otherwise use the\n+    \/\/ real value provided.\n+    return G1PeriodicGCInterval == 0 ? 1000 : G1PeriodicGCInterval;\n@@ -119,1 +114,0 @@\n-}\n@@ -121,4 +115,4 @@\n-void G1ServiceThread::stop_service() {\n-  MutexLocker x(&_monitor, Mutex::_no_safepoint_check_flag);\n-  _monitor.notify();\n-}\n+  virtual bool should_reschedule() {\n+    return true;\n+  }\n+};\n@@ -158,4 +152,61 @@\n-void G1ServiceThread::sample_young_list_rs_length() {\n-  SuspendibleThreadSetJoiner sts;\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  G1Policy* policy = g1h->policy();\n+\/\/ Task handling young gen remembered set sampling.\n+class G1RemSetSamplingTask : public G1ServiceTask {\n+  \/\/ Sample the current length of remembered sets for young.\n+  \/\/\n+  \/\/ At the end of the GC G1 determines the length of the young gen based on\n+  \/\/ how much time the next GC can take, and when the next GC may occur\n+  \/\/ according to the MMU.\n+  \/\/\n+  \/\/ The assumption is that a significant part of the GC is spent on scanning\n+  \/\/ the remembered sets (and many other components), so this thread constantly\n+  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n+  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n+  \/\/ increase the young gen size to keep pause time length goal.\n+  void sample_young_list_rs_length(){\n+    SuspendibleThreadSetJoiner sts;\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1Policy* policy = g1h->policy();\n+\n+    if (policy->use_adaptive_young_list_length()) {\n+      G1YoungRemSetSamplingClosure cl(&sts);\n+\n+      G1CollectionSet* g1cs = g1h->collection_set();\n+      g1cs->iterate(&cl);\n+\n+      if (cl.is_complete()) {\n+        policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+      }\n+    }\n+  }\n+public:\n+  G1RemSetSamplingTask(const char* name) : G1ServiceTask(name) { }\n+  virtual void execute() {\n+    sample_young_list_rs_length();\n+  }\n+\n+  virtual uint64_t delay_ms() {\n+    return G1ConcRefinementServiceIntervalMillis;\n+  }\n+\n+  virtual bool should_reschedule() {\n+    return true;\n+  }\n+};\n+\n+G1ServiceThread::G1ServiceThread() :\n+    ConcurrentGCThread(),\n+    _monitor(Mutex::nonleaf,\n+             \"G1ServiceThread monitor\",\n+             true,\n+             Monitor::_safepoint_check_never),\n+    _task_queue(),\n+    _vtime_accum(0) {\n+  set_name(\"G1 Service\");\n+  create_and_start();\n+}\n+\n+void G1ServiceThread::register_task(G1ServiceTask* task) {\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  _task_queue.add_ordered(task);\n+\n+  log_debug(gc, task)(\"G1 Service Thread (%s) (register)\", task->name());\n@@ -163,2 +214,18 @@\n-  if (policy->use_adaptive_young_list_length()) {\n-    G1YoungRemSetSamplingClosure cl(&sts);\n+  \/\/ Notify the service thread that there is a new task, thread might\n+  \/\/ be waiting and the newly added task might be first in the list.\n+  ml.notify();\n+}\n+\n+int64_t G1ServiceThread::time_to_next_task_ms() {\n+  assert(_monitor.owned_by_self(), \"Must be owner of lock\");\n+  assert(!_task_queue.is_empty(), \"Should not be called for empty list\");\n+\n+  double time_diff = _task_queue.peek()->time() - os::elapsedTime();\n+  if (time_diff < 0) {\n+    \/\/ Run without sleeping.\n+    return 0;\n+  }\n+\n+  \/\/ Return sleep time in milliseconds.\n+  return (int64_t) (time_diff * MILLIUNITS);\n+}\n@@ -166,2 +233,4 @@\n-    G1CollectionSet* g1cs = g1h->collection_set();\n-    g1cs->iterate(&cl);\n+void G1ServiceThread::sleep_before_next_cycle() {\n+  if (should_terminate()) {\n+    return;\n+  }\n@@ -169,2 +238,10 @@\n-    if (cl.is_complete()) {\n-      policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  if (_task_queue.is_empty()) {\n+    \/\/ Sleep until new task is registered if no tasks available.\n+    log_trace(gc, task)(\"G1 Service Thread (wait for new tasks)\");\n+    ml.wait(0);\n+  } else {\n+    int64_t sleep_ms = time_to_next_task_ms();\n+    if (sleep_ms > 0) {\n+      log_trace(gc, task)(\"G1 Service Thread (wait) %1.3fs\", sleep_ms \/ 1000.0);\n+      ml.wait(sleep_ms);\n@@ -174,0 +251,147 @@\n+\n+void G1ServiceThread::reschedule_task(G1ServiceTask* task) {\n+  if (!task->should_reschedule()) {\n+    log_trace(gc, task)(\"G1 Service Thread (%s) (done)\", task->name());\n+    return;\n+  }\n+\n+  \/\/ Reschedule task by updating task time and add back to queue.\n+  double delay = task->delay_ms() \/ 1000.0;\n+  task->set_time(os::elapsedTime() + delay);\n+\n+  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  _task_queue.add_ordered(task);\n+\n+  log_trace(gc, task)(\"G1 Service Thread (%s) (schedule) @%1.3fs\", task->name(), task->time());;\n+}\n+\n+G1ServiceTask* G1ServiceThread::pop_due_task() {\n+  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  if (_task_queue.is_empty() || time_to_next_task_ms() != 0) {\n+    return NULL;\n+  }\n+\n+  return _task_queue.pop();\n+}\n+\n+void G1ServiceThread::run_task(G1ServiceTask* task) {\n+  double start = os::elapsedVTime();\n+\n+  log_debug(gc, task, start)(\"G1 Service Thread (%s) (run)\", task->name());\n+  task->execute();\n+\n+  double duration = os::elapsedVTime() - start;\n+  log_debug(gc, task)(\"G1 Service Thread (%s) (run) %1.3fms\", task->name(), duration * MILLIUNITS);\n+}\n+\n+void G1ServiceThread::run_service() {\n+  double vtime_start = os::elapsedVTime();\n+\n+  \/\/ Setup the tasks handeled by the service thread and\n+  \/\/ add them to the task list.\n+  G1PeriodicGCTask gc_task(\"Periodic GC Task\");\n+  register_task(&gc_task);\n+\n+  G1RemSetSamplingTask remset_task(\"Remembered Set Sampling Task\");\n+  register_task(&remset_task);\n+\n+  while (!should_terminate()) {\n+    G1ServiceTask* task = pop_due_task();\n+    if (task != NULL) {\n+      run_task(task);\n+      reschedule_task(task);\n+    }\n+\n+    if (os::supports_vtime()) {\n+      _vtime_accum = (os::elapsedVTime() - vtime_start);\n+    } else {\n+      _vtime_accum = 0.0;\n+    }\n+    sleep_before_next_cycle();\n+  }\n+}\n+\n+void G1ServiceThread::stop_service() {\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  ml.notify();\n+}\n+\n+G1ServiceTask::G1ServiceTask(const char* name) :\n+  _time(),\n+  _name(name),\n+  _next(NULL) { }\n+\n+const char* G1ServiceTask::name() {\n+  return _name;\n+}\n+\n+void G1ServiceTask::set_time(double time) {\n+  _time = time;\n+}\n+\n+double G1ServiceTask::time() {\n+  return _time;\n+}\n+\n+void G1ServiceTask::set_next(G1ServiceTask* next) {\n+  _next = next;\n+}\n+\n+G1ServiceTask* G1ServiceTask::next() {\n+  return _next;\n+}\n+\n+G1ServiceTaskQueue::G1ServiceTaskQueue() : _sentinel() { }\n+\n+G1ServiceTask* G1ServiceTaskQueue::pop() {\n+  verify_task_queue();\n+\n+  G1ServiceTask* task = _sentinel.next();\n+  _sentinel.set_next(task->next());\n+  task->set_next(NULL);\n+\n+  return task;\n+}\n+\n+G1ServiceTask* G1ServiceTaskQueue::peek() {\n+  verify_task_queue();\n+  return _sentinel.next();\n+}\n+\n+bool G1ServiceTaskQueue::is_empty() {\n+  return &_sentinel == _sentinel.next();\n+}\n+\n+void G1ServiceTaskQueue::add_ordered(G1ServiceTask* task) {\n+  assert(task->next() == NULL, \"invariant\");\n+  assert(task->time() != DBL_MAX, \"invalid time for task\");\n+\n+  G1ServiceTask* current = &_sentinel;\n+  while (task->time() >= current->next()->time()) {\n+    assert(task != current, \"Task should only be added once.\");\n+    current = current->next();\n+  }\n+\n+  \/\/ Update the links.\n+  task->set_next(current->next());\n+  current->set_next(task);\n+\n+  verify_task_queue();\n+}\n+\n+#ifdef ASSERT\n+void G1ServiceTaskQueue::verify_task_queue() {\n+  G1ServiceTask* cur = _sentinel.next();\n+\n+  assert(cur != &_sentinel, \"Should never try to verify empty queue\");\n+  while (cur != &_sentinel) {\n+    G1ServiceTask* next = cur->next();\n+    assert(cur->time() <= next->time(),\n+           \"Tasks out of order, prev: %s (%1.3fs), next: %s (%1.3fs)\",\n+           cur->name(), cur->time(), next->name(), next->time());\n+\n+    assert(cur != next, \"Invariant\");\n+    cur = next;\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":299,"deletions":75,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -31,0 +31,51 @@\n+class G1ServiceTask : public CHeapObj<mtGC> {\n+  \/\/ The next time this task should be executed.\n+  double _time;\n+  \/\/ Name of the task.\n+  const char* _name;\n+  \/\/ Next task in the task queue.\n+  G1ServiceTask* _next;\n+\n+public:\n+  G1ServiceTask(const char* name);\n+  const char* name();\n+\n+  void set_time(double time);\n+  double time();\n+\n+  void set_next(G1ServiceTask* next);\n+  G1ServiceTask* next();\n+\n+  \/\/ Do the actual work for the task.\n+  virtual void execute() = 0;\n+  \/\/ Delay to the next invocation.\n+  virtual uint64_t delay_ms() = 0;\n+  \/\/ Return if the task should be rescheduled or not.\n+  virtual bool should_reschedule() = 0;\n+};\n+\n+class G1SentinelTask : public G1ServiceTask {\n+public:\n+  G1SentinelTask();\n+  virtual void execute();\n+  virtual uint64_t delay_ms();\n+  virtual bool should_reschedule();\n+};\n+\n+class G1ServiceTaskQueue {\n+  \/\/ The sentinel task is the entry point of this priority queue holding the\n+  \/\/ service tasks. The queue is ordered by the time the tasks are scheduled\n+  \/\/ to run and the sentinel task has the time set to DBL_MAX. This guarantees\n+  \/\/ that any new task will be added just before the sentinel at the latest.\n+  G1SentinelTask _sentinel;\n+\n+  \/\/ Verify that the queue is ordered.\n+  void verify_task_queue() NOT_DEBUG_RETURN;\n+public:\n+  G1ServiceTaskQueue();\n+  G1ServiceTask* pop();\n+  G1ServiceTask* peek();\n+  void add_ordered(G1ServiceTask* task);\n+  bool is_empty();\n+};\n+\n@@ -37,0 +88,2 @@\n+  \/\/ The monitor is used to ensure thread saftey for the task queue\n+  \/\/ and allow other threads to signal the service thread to wake up.\n@@ -38,2 +91,1 @@\n-\n-  double _last_periodic_gc_attempt_s;\n+  G1ServiceTaskQueue _task_queue;\n@@ -43,13 +95,0 @@\n-  \/\/ Sample the current length of remembered sets for young.\n-  \/\/\n-  \/\/ At the end of the GC G1 determines the length of the young gen based on\n-  \/\/ how much time the next GC can take, and when the next GC may occur\n-  \/\/ according to the MMU.\n-  \/\/\n-  \/\/ The assumption is that a significant part of the GC is spent on scanning\n-  \/\/ the remembered sets (and many other components), so this thread constantly\n-  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n-  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n-  \/\/ increase the young gen size to keep pause time length goal.\n-  void sample_young_list_rs_length();\n-\n@@ -57,2 +96,0 @@\n-  void check_for_periodic_gc();\n-\n@@ -61,0 +98,4 @@\n+  \/\/ Returns the time in milliseconds until the next task is due.\n+  \/\/ Used both to determine if there are tasks ready to run and\n+  \/\/ how long to sleep when nothing is ready.\n+  int64_t time_to_next_task_ms();\n@@ -63,1 +104,3 @@\n-  bool should_start_periodic_gc();\n+  G1ServiceTask* pop_due_task();\n+  void run_task(G1ServiceTask* task);\n+  void reschedule_task(G1ServiceTask* task);\n@@ -68,0 +111,1 @@\n+  void register_task(G1ServiceTask* task);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/autoRestore.hpp\"\n+#include \"unittest.hpp\"\n+\n+class CheckTask : public G1ServiceTask {\n+  int _execution_count;\n+  bool _reschedule;\n+\n+public:\n+  CheckTask(const char* name) :\n+      G1ServiceTask(name),\n+      _execution_count(0),\n+      _reschedule(true) { }\n+  virtual void execute() { _execution_count++; }\n+  virtual uint64_t delay_ms() { return 100; }\n+  virtual bool should_reschedule() { return _reschedule; }\n+\n+  int execution_count() { return _execution_count;}\n+  void set_reschedule(bool reschedule) { _reschedule = reschedule; }\n+};\n+\n+static void stop_service_thread(G1ServiceThread* thread) {\n+  ThreadInVMfromNative tvn(JavaThread::current());\n+  thread->stop();\n+}\n+\n+\/\/ Test that a task that is added during runtime gets run.\n+TEST_VM(G1ServiceThread, test_add) {\n+  \/\/ Create thread and let it start.\n+  G1ServiceThread* st = new G1ServiceThread();\n+  os::naked_short_sleep(500);\n+\n+  CheckTask ct(\"AddAndRun\");\n+  st->register_task(&ct);\n+\n+  \/\/ Give CheckTask time to run.\n+  os::naked_short_sleep(500);\n+  stop_service_thread(st);\n+\n+  ASSERT_GT(ct.execution_count(), 0);\n+}\n+\n+\/\/ Test that a task that is added while the service thread is\n+\/\/ waiting gets run in a timely manner.\n+TEST_VM(G1ServiceThread, test_add_while_waiting) {\n+  \/\/ Make sure default tasks use long intervals.\n+  AutoModifyRestore<uintx> f1(G1PeriodicGCInterval, 100000);\n+  AutoModifyRestore<uintx> f2(G1ConcRefinementServiceIntervalMillis, 100000);\n+\n+  \/\/ Create thread and let it start.\n+  G1ServiceThread* st = new G1ServiceThread();\n+  os::naked_short_sleep(500);\n+\n+  CheckTask ct(\"AddWhileWaiting\");\n+  st->register_task(&ct);\n+\n+  \/\/ Give CheckTask time to run.\n+  os::naked_short_sleep(500);\n+  stop_service_thread(st);\n+\n+  ASSERT_GT(ct.execution_count(), 0);\n+}\n+\n+\/\/ Test that a task with negative timeout is not rescheduled.\n+TEST_VM(G1ServiceThread, test_add_run_once) {\n+  \/\/ Create thread and let it start.\n+  G1ServiceThread* st = new G1ServiceThread();\n+  os::naked_short_sleep(500);\n+\n+  \/\/ Set reschedule to false to only run once.\n+  CheckTask ct(\"AddRunOnce\");\n+  ct.set_reschedule(false);\n+  st->register_task(&ct);\n+\n+  \/\/ Give CheckTask time to run.\n+  os::naked_short_sleep(500);\n+  stop_service_thread(st);\n+\n+  \/\/ Should be exactly 1 since negative timeout should\n+  \/\/ prevent rescheduling.\n+  ASSERT_EQ(ct.execution_count(), 1);\n+}\n+\n+class TestTask : public G1ServiceTask {\n+  int64_t _delay_ms;\n+public:\n+  TestTask(int64_t delay) :\n+      G1ServiceTask(\"TestTask\"),\n+      _delay_ms(delay) {\n+    set_time(delay \/ 1000.0);\n+  }\n+  virtual void execute() { }\n+  virtual uint64_t delay_ms() { return _delay_ms; }\n+  virtual bool should_reschedule() { return true; }\n+};\n+\n+TEST_VM(G1ServiceTaskQueue, add_ordered) {\n+  G1ServiceTaskQueue queue;\n+\n+  int num_test_tasks = 5;\n+  for (int i = 1; i <= num_test_tasks; i++) {\n+    \/\/ Create tasks with different timeout.\n+    TestTask* task = new TestTask(100 * i);\n+    queue.add_ordered(task);\n+  }\n+\n+  \/\/ Now fake a run-loop, that reschedules the tasks using a\n+  \/\/ random multiplyer.\n+  for (double now = 0; now < 1000; now++) {\n+    \/\/ Random multiplyier is at least 1 to ensure progress.\n+    int multiplyer = 1 + os::random() % 10;\n+    while (queue.peek()->time() < now) {\n+      G1ServiceTask* task = queue.pop();\n+      task->execute();\n+      task->set_time(now + ((task->delay_ms() * multiplyer) \/ 1000.0));\n+      \/\/ All additions will verify that the queue is sorted.\n+      queue.add_ordered(task);\n+    }\n+  }\n+\n+  while (!queue.is_empty()) {\n+    G1ServiceTask* task = queue.pop();\n+    delete task;\n+  }\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, pop_empty,\n+    \"Should never try to verify empty queue\") {\n+  G1ServiceTaskQueue queue;\n+  queue.pop();\n+}\n+\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, peek_empty,\n+    \"Should never try to verify empty queue\") {\n+  G1ServiceTaskQueue queue;\n+  queue.peek();\n+}\n+\n+#endif\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1ServiceThread.cpp","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"}]}