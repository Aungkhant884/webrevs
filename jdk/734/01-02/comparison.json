{"files":[{"patch":"@@ -48,1 +48,1 @@\n-int64_t G1SentinelTask::timeout_ms() {\n+uint64_t G1SentinelTask::delay_ms() {\n@@ -53,0 +53,5 @@\n+bool G1SentinelTask::should_reschedule() {\n+  guarantee(false, \"Sentinel service task should never be scheduled.\");\n+  return false;\n+}\n+\n@@ -102,1 +107,1 @@\n-  virtual int64_t timeout_ms() {\n+  virtual uint64_t delay_ms() {\n@@ -109,0 +114,4 @@\n+\n+  virtual bool should_reschedule() {\n+    return true;\n+  }\n@@ -178,1 +187,1 @@\n-  virtual int64_t timeout_ms() {\n+  virtual uint64_t delay_ms() {\n@@ -181,0 +190,4 @@\n+\n+  virtual bool should_reschedule() {\n+    return true;\n+  }\n@@ -189,1 +202,1 @@\n-    _task_list(),\n+    _task_queue(),\n@@ -197,1 +210,1 @@\n-  _task_list.add_ordered(task);\n+  _task_queue.add_ordered(task);\n@@ -206,1 +219,1 @@\n-int64_t G1ServiceThread::sleep_time() {\n+int64_t G1ServiceThread::time_to_next_task_ms() {\n@@ -208,1 +221,1 @@\n-  assert(!_task_list.is_empty(), \"Should not be called for empty list\");\n+  assert(!_task_queue.is_empty(), \"Should not be called for empty list\");\n@@ -210,1 +223,1 @@\n-  double time_diff = _task_list.peek()->time() - os::elapsedTime();\n+  double time_diff = _task_queue.peek()->time() - os::elapsedTime();\n@@ -226,1 +239,1 @@\n-  if (_task_list.is_empty()) {\n+  if (_task_queue.is_empty()) {\n@@ -231,4 +244,4 @@\n-    int64_t sleep = sleep_time();\n-    if (sleep > 0) {\n-      log_trace(gc, task)(\"G1 Service Thread (wait) %1.3fs\", sleep \/ 1000.0);\n-      ml.wait(sleep);\n+    int64_t sleep_ms = time_to_next_task_ms();\n+    if (sleep_ms > 0) {\n+      log_trace(gc, task)(\"G1 Service Thread (wait) %1.3fs\", sleep_ms \/ 1000.0);\n+      ml.wait(sleep_ms);\n@@ -240,3 +253,1 @@\n-  int64_t timeout_ms = task->timeout_ms();\n-  if (timeout_ms < 0) {\n-    \/\/ Negative timeout, don't reschedule.\n+  if (!task->should_reschedule()) {\n@@ -248,1 +259,2 @@\n-  task->set_time(os::elapsedTime() + (timeout_ms \/ 1000.0));\n+  double delay_ms = task->delay_ms() \/ 1000.0;\n+  task->set_time(os::elapsedTime() + delay_ms);\n@@ -251,1 +263,1 @@\n-  _task_list.add_ordered(task);\n+  _task_queue.add_ordered(task);\n@@ -258,1 +270,1 @@\n-  if (_task_list.is_empty() || sleep_time() != 0) {\n+  if (_task_queue.is_empty() || time_to_next_task_ms() != 0) {\n@@ -262,1 +274,1 @@\n-  return _task_list.pop();\n+  return _task_queue.pop();\n@@ -342,1 +354,1 @@\n-G1ServiceTaskList::G1ServiceTaskList() : _sentinel() { }\n+G1ServiceTaskQueue::G1ServiceTaskQueue() : _sentinel() { }\n@@ -344,2 +356,2 @@\n-G1ServiceTask* G1ServiceTaskList::pop() {\n-  verify_task_list();\n+G1ServiceTask* G1ServiceTaskQueue::pop() {\n+  verify_task_queue();\n@@ -354,2 +366,2 @@\n-G1ServiceTask* G1ServiceTaskList::peek() {\n-  verify_task_list();\n+G1ServiceTask* G1ServiceTaskQueue::peek() {\n+  verify_task_queue();\n@@ -359,1 +371,1 @@\n-bool G1ServiceTaskList::is_empty() {\n+bool G1ServiceTaskQueue::is_empty() {\n@@ -363,1 +375,1 @@\n-void G1ServiceTaskList::add_ordered(G1ServiceTask* task) {\n+void G1ServiceTaskQueue::add_ordered(G1ServiceTask* task) {\n@@ -377,1 +389,1 @@\n-  verify_task_list();\n+  verify_task_queue();\n@@ -381,1 +393,1 @@\n-void G1ServiceTaskList::verify_task_list() {\n+void G1ServiceTaskQueue::verify_task_queue() {\n@@ -384,1 +396,1 @@\n-  assert(cur != &_sentinel, \"Should never try to verify empty list\");\n+  assert(cur != &_sentinel, \"Should never try to verify empty queue\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":42,"deletions":30,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  \/\/ Next task in the task list.\n+  \/\/ Next task in the task queue.\n@@ -51,3 +51,4 @@\n-  \/\/ Timeout to the next invocation. A negative value can be used\n-  \/\/ to stop the task from being rescheduled and run again.\n-  virtual int64_t timeout_ms() = 0;\n+  \/\/ Delay to the next invocation.\n+  virtual uint64_t delay_ms() = 0;\n+  \/\/ Return if the task should be rescheduled or not.\n+  virtual bool should_reschedule() = 0;\n@@ -60,1 +61,2 @@\n-  virtual int64_t timeout_ms();\n+  virtual uint64_t delay_ms();\n+  virtual bool should_reschedule();\n@@ -63,3 +65,3 @@\n-class G1ServiceTaskList {\n-  \/\/ The sentinel task is the entry point of this ordered circular list holding\n-  \/\/ the service tasks. The list is ordered by the time the tasks are scheduled\n+class G1ServiceTaskQueue {\n+  \/\/ The sentinel task is the entry point of this priority queue holding the\n+  \/\/ service tasks. The queue is ordered by the time the tasks are scheduled\n@@ -70,2 +72,2 @@\n-  \/\/ Verify that the list is ordered.\n-  void verify_task_list() NOT_DEBUG_RETURN;\n+  \/\/ Verify that the queue is ordered.\n+  void verify_task_queue() NOT_DEBUG_RETURN;\n@@ -73,1 +75,1 @@\n-  G1ServiceTaskList();\n+  G1ServiceTaskQueue();\n@@ -86,1 +88,1 @@\n-  \/\/ The monitor is used to ensure thread saftey for the task list\n+  \/\/ The monitor is used to ensure thread saftey for the task queue\n@@ -89,1 +91,1 @@\n-  G1ServiceTaskList _task_list;\n+  G1ServiceTaskQueue _task_queue;\n@@ -96,1 +98,4 @@\n-  int64_t sleep_time();\n+  \/\/ Returns the time in milliseconds until the next task is due.\n+  \/\/ Used both to determine if there are tasks ready to run and\n+  \/\/ how long to sleep when nothing is ready.\n+  int64_t time_to_next_task_ms();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-  virtual int64_t timeout_ms() { return _timeout; }\n+  virtual uint64_t delay_ms() { return _timeout; }\n+  virtual bool should_reschedule() { return true; }\n+\n@@ -119,1 +121,2 @@\n-  virtual int64_t timeout_ms() { return _timeout; }\n+  virtual uint64_t delay_ms() { return _timeout; }\n+  virtual bool should_reschedule() { return true; }\n@@ -122,2 +125,2 @@\n-TEST_VM(G1ServiceTaskList, add_ordered) {\n-  G1ServiceTaskList list;\n+TEST_VM(G1ServiceTaskQueue, add_ordered) {\n+  G1ServiceTaskQueue queue;\n@@ -129,1 +132,1 @@\n-    list.add_ordered(task);\n+    queue.add_ordered(task);\n@@ -137,2 +140,2 @@\n-    while (list.peek()->time() < now) {\n-      G1ServiceTask* task = list.pop();\n+    while (queue.peek()->time() < now) {\n+      G1ServiceTask* task = queue.pop();\n@@ -140,3 +143,3 @@\n-      task->set_time(now + ((task->timeout_ms() * multiplyer) \/ 1000.0));\n-      \/\/ All additions will verify that the list is sorted.\n-      list.add_ordered(task);\n+      task->set_time(now + ((task->delay_ms() * multiplyer) \/ 1000.0));\n+      \/\/ All additions will verify that the queue is sorted.\n+      queue.add_ordered(task);\n@@ -146,2 +149,2 @@\n-  while (!list.is_empty()) {\n-    G1ServiceTask* task = list.pop();\n+  while (!queue.is_empty()) {\n+    G1ServiceTask* task = queue.pop();\n@@ -153,4 +156,4 @@\n-TEST_VM_ASSERT_MSG(G1ServiceTaskList, pop_empty,\n-    \"Should never try to verify empty list\") {\n-  G1ServiceTaskList list;\n-  list.pop();\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, pop_empty,\n+    \"Should never try to verify empty queue\") {\n+  G1ServiceTaskQueue queue;\n+  queue.pop();\n@@ -159,4 +162,4 @@\n-TEST_VM_ASSERT_MSG(G1ServiceTaskList, peek_empty,\n-    \"Should never try to verify empty list\") {\n-  G1ServiceTaskList list;\n-  list.peek();\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, peek_empty,\n+    \"Should never try to verify empty queue\") {\n+  G1ServiceTaskQueue queue;\n+  queue.peek();\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1ServiceThread.cpp","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"}]}