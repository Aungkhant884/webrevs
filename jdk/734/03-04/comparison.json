{"files":[{"patch":"@@ -40,1 +40,1 @@\n-  set_time(DBL_MAX);\n+  set_time(max_jlong);\n@@ -48,10 +48,0 @@\n-uint64_t G1SentinelTask::delay_ms() {\n-  guarantee(false, \"Sentinel service task should never be scheduled.\");\n-  return 0;\n-}\n-\n-bool G1SentinelTask::should_reschedule() {\n-  guarantee(false, \"Sentinel service task should never be scheduled.\");\n-  return false;\n-}\n-\n@@ -105,3 +95,0 @@\n-  }\n-\n-  virtual uint64_t delay_ms() {\n@@ -112,5 +99,1 @@\n-    return G1PeriodicGCInterval == 0 ? 1000 : G1PeriodicGCInterval;\n-  }\n-\n-  virtual bool should_reschedule() {\n-    return true;\n+    schedule(G1PeriodicGCInterval == 0 ? 1000 : G1PeriodicGCInterval);\n@@ -185,8 +168,1 @@\n-  }\n-\n-  virtual uint64_t delay_ms() {\n-    return G1ConcRefinementServiceIntervalMillis;\n-  }\n-\n-  virtual bool should_reschedule() {\n-    return true;\n+    schedule(G1ConcRefinementServiceIntervalMillis);\n@@ -208,4 +184,1 @@\n-void G1ServiceThread::register_task(G1ServiceTask* task) {\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  _task_queue.add_ordered(task);\n-\n+void G1ServiceThread::register_task(G1ServiceTask* task, jlong delay) {\n@@ -214,0 +187,6 @@\n+  \/\/ Associate the task with the service thread.\n+  task->set_service_thread(this);\n+\n+  \/\/ Schedule the task to run after the given delay.\n+  schedule_task(task, delay);\n+\n@@ -216,0 +195,1 @@\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n@@ -219,0 +199,12 @@\n+void G1ServiceThread::schedule_task(G1ServiceTask* task, jlong delay_ms) {\n+  \/\/ Schedule task by setting the task time and adding it to queue.\n+  jlong delay = TimeHelper::millis_to_counter(delay_ms);\n+  task->set_time(os::elapsed_counter() + delay);\n+\n+  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  _task_queue.add_ordered(task);\n+\n+  log_trace(gc, task)(\"G1 Service Thread (%s) (schedule) @%1.3fs\",\n+                      task->name(), TimeHelper::counter_to_seconds(task->time()));\n+}\n+\n@@ -223,1 +215,1 @@\n-  double time_diff = _task_queue.peek()->time() - os::elapsedTime();\n+  jlong time_diff = _task_queue.peek()->time() - os::elapsed_counter();\n@@ -230,1 +222,1 @@\n-  return (int64_t) (time_diff * MILLIUNITS);\n+  return (int64_t) TimeHelper::counter_to_millis(time_diff);\n@@ -252,16 +244,0 @@\n-void G1ServiceThread::reschedule_task(G1ServiceTask* task) {\n-  if (!task->should_reschedule()) {\n-    log_trace(gc, task)(\"G1 Service Thread (%s) (done)\", task->name());\n-    return;\n-  }\n-\n-  \/\/ Reschedule task by updating task time and add back to queue.\n-  double delay = task->delay_ms() \/ 1000.0;\n-  task->set_time(os::elapsedTime() + delay);\n-\n-  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  _task_queue.add_ordered(task);\n-\n-  log_trace(gc, task)(\"G1 Service Thread (%s) (schedule) @%1.3fs\", task->name(), task->time());;\n-}\n-\n@@ -302,1 +278,0 @@\n-      reschedule_task(task);\n@@ -324,0 +299,8 @@\n+void G1ServiceTask::set_service_thread(G1ServiceThread* thread) {\n+  _service_thread = thread;\n+}\n+\n+void G1ServiceTask::schedule(jlong delay_ms) {\n+  _service_thread->schedule_task(this, delay_ms);\n+}\n+\n@@ -328,1 +311,2 @@\n-void G1ServiceTask::set_time(double time) {\n+void G1ServiceTask::set_time(jlong time) {\n+  assert(_next == NULL, \"Not allowed to update time while in queue\");\n@@ -332,1 +316,1 @@\n-double G1ServiceTask::time() {\n+jlong G1ServiceTask::time() {\n@@ -366,0 +350,1 @@\n+  assert(task != NULL, \"not a valid task\");\n@@ -391,1 +376,1 @@\n-           cur->name(), cur->time(), next->name(), next->time());\n+           cur->name(), TimeHelper::counter_to_seconds(cur->time()), next->name(), TimeHelper::counter_to_seconds(next->time()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":38,"deletions":53,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class G1ServiceThread;\n+\n@@ -32,2 +34,2 @@\n-  \/\/ The next time this task should be executed.\n-  double _time;\n+  \/\/ The next absolute time this task should be executed.\n+  jlong _time;\n@@ -38,0 +40,2 @@\n+  \/\/ The service thread this task is associated with.\n+  G1ServiceThread* _service_thread;\n@@ -42,0 +46,1 @@\n+  void set_service_thread(G1ServiceThread* thread);\n@@ -43,2 +48,2 @@\n-  void set_time(double time);\n-  double time();\n+  void set_time(jlong time);\n+  jlong time();\n@@ -49,1 +54,2 @@\n-  \/\/ Do the actual work for the task.\n+  \/\/ Do the actual work for the task. To get added back to the\n+  \/\/ execution queue a task can call schedule(delay_ms).\n@@ -51,4 +57,5 @@\n-  \/\/ Delay to the next invocation.\n-  virtual uint64_t delay_ms() = 0;\n-  \/\/ Return if the task should be rescheduled or not.\n-  virtual bool should_reschedule() = 0;\n+\n+protected:\n+  \/\/ Schedule the task on the associated service thread\n+  \/\/ using the provided delay in milliseconds.\n+  void schedule(jlong delay_ms);\n@@ -61,2 +68,0 @@\n-  virtual uint64_t delay_ms();\n-  virtual bool should_reschedule();\n@@ -87,2 +92,1 @@\n-private:\n-  \/\/ The monitor is used to ensure thread saftey for the task queue\n+  \/\/ The monitor is used to ensure thread safety for the task queue\n@@ -106,1 +110,0 @@\n-  void reschedule_task(G1ServiceTask* task);\n@@ -111,1 +114,2 @@\n-  void register_task(G1ServiceTask* task);\n+  void register_task(G1ServiceTask* task, jlong delay = 0);\n+  void schedule_task(G1ServiceTask* task, jlong delay);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,3 +41,6 @@\n-  virtual void execute() { _execution_count++; }\n-  virtual uint64_t delay_ms() { return 100; }\n-  virtual bool should_reschedule() { return _reschedule; }\n+  virtual void execute() {\n+    _execution_count++;\n+    if (_reschedule) {\n+      schedule(100);\n+    }\n+  }\n@@ -73,1 +76,2 @@\n-  \/\/ Make sure default tasks use long intervals.\n+  \/\/ Make sure default tasks use long intervals so that the service thread\n+  \/\/ is doing a long wait for the next execution.\n@@ -81,0 +85,1 @@\n+  \/\/ Register a new task that should run right away.\n@@ -112,1 +117,1 @@\n-  int64_t _delay_ms;\n+  jlong _delay_ms;\n@@ -114,1 +119,1 @@\n-  TestTask(int64_t delay) :\n+  TestTask(jlong delay) :\n@@ -117,1 +122,1 @@\n-    set_time(delay \/ 1000.0);\n+    set_time(delay);\n@@ -119,3 +124,2 @@\n-  virtual void execute() { }\n-  virtual uint64_t delay_ms() { return _delay_ms; }\n-  virtual bool should_reschedule() { return true; }\n+  virtual void execute() {}\n+  jlong delay_ms() { return _delay_ms; }\n@@ -135,4 +139,4 @@\n-  \/\/ random multiplyer.\n-  for (double now = 0; now < 1000; now++) {\n-    \/\/ Random multiplyier is at least 1 to ensure progress.\n-    int multiplyer = 1 + os::random() % 10;\n+  \/\/ random multiplier.\n+  for (jlong now = 0; now < 1000000; now++) {\n+    \/\/ Random multiplier is at least 1 to ensure progress.\n+    int multiplier = 1 + os::random() % 10;\n@@ -140,1 +144,2 @@\n-      G1ServiceTask* task = queue.pop();\n+      TestTask* task = (TestTask*) queue.pop();\n+      \/\/ Update delay multiplier.\n@@ -142,1 +147,1 @@\n-      task->set_time(now + ((task->delay_ms() * multiplyer) \/ 1000.0));\n+      task->set_time(now + (task->delay_ms() * multiplier));\n@@ -167,1 +172,10 @@\n-#endif\n\\ No newline at end of file\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, set_time_in_queue,\n+    \"Not allowed to update time while in queue\") {\n+  G1ServiceTaskQueue queue;\n+  TestTask a(100);\n+  queue.add_ordered(&a);\n+  \/\/ Not allowed to update time while in queue.\n+  a.set_time(500);\n+}\n+\n+#endif\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1ServiceThread.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"}]}