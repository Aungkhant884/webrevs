{"files":[{"patch":"@@ -35,0 +35,9 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+\n@@ -241,0 +250,15 @@\n+  ciInstanceKlass* iklass = vec_box->box_type()->klass()->as_instance_klass();\n+  int n_fields = iklass->nof_nonstatic_fields();\n+  assert(n_fields == 1, \"sanity\");\n+\n+  \/\/ If a mask is feeding into safepoint[s], then its value should be\n+  \/\/ packed into a boolean\/byte vector first, this will simplify the\n+  \/\/ re-materialization logic for both predicated and non-predicated\n+  \/\/ targets.\n+  bool is_mask = is_vector_mask(iklass);\n+  if (is_mask && vec_value->Opcode() != Op_VectorStoreMask) {\n+    const TypeVect* vt = vec_value->bottom_type()->is_vect();\n+    BasicType bt = vt->element_basic_type();\n+    vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n+  }\n+\n@@ -244,4 +268,0 @@\n-    ciInstanceKlass* iklass = vec_box->box_type()->klass()->as_instance_klass();\n-    int n_fields = iklass->nof_nonstatic_fields();\n-    assert(n_fields == 1, \"sanity\");\n-\n@@ -308,8 +328,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  } else if (is_vector_mask(ik)) {\n+    return T_BOOLEAN;\n@@ -89,30 +91,18 @@\n-void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n-  if (is_mask) {\n-    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-    \/\/ occupies the whole 512-bit vector register when scalarized.\n-    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n-    \/\/\n-    \/\/ TODO: revisit when predicate registers are fully supported.\n-    switch (elem_bt) {\n-      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n-      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n-      case T_INT:    \/\/ fall-through\n-      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n-      case T_LONG:   \/\/ fall-through\n-      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n-\n-      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-    }\n-  } else {\n-    switch (elem_bt) {\n-      case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n-      case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n-      case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n-      case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n-      case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n-      case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n-\n-      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-    }\n+\/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+\/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+\/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+\/\/ occupies the whole 512-bit vector register when scalarized.\n+\/\/ During scalarization inserting a VectorStoreMask node between mask\n+\/\/ and safepoint node always ensures the existence of masks in a boolean array.\n+\n+void VectorSupport::init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr) {\n+  switch (elem_bt) {\n+    case T_BOOLEAN: arr->  byte_at_put(index,   *(jboolean*)addr); break;\n+    case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n+    case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n+    case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n+    case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n+    case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n+    case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n+\n+    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -123,2 +113,0 @@\n-  bool is_mask = is_vector_mask(ik);\n-\n@@ -130,1 +118,1 @@\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(is_mask ? T_BOOLEAN : elem_bt));\n+  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n@@ -143,1 +131,1 @@\n-      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n+      init_payload_element(arr, elem_bt, i, elem_addr);\n@@ -149,1 +137,1 @@\n-      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n+      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":23,"deletions":35,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n+  static void init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}