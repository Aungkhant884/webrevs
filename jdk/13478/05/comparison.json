{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.classfile.instruction.DiscontinuedInstruction;\n@@ -59,3 +60,3 @@\n-                ConstantInstruction, ConvertInstruction, FieldInstruction,\n-                InvokeDynamicInstruction, InvokeInstruction, LoadInstruction,\n-                StoreInstruction, IncrementInstruction,\n+                ConstantInstruction, ConvertInstruction, DiscontinuedInstruction,\n+                FieldInstruction, InvokeDynamicInstruction, InvokeInstruction,\n+                LoadInstruction, StoreInstruction, IncrementInstruction,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Instruction.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -207,2 +207,2 @@\n-    JSR(Classfile.JSR, 3, Kind.UNSUPPORTED),\n-    RET(Classfile.RET, 2, Kind.UNSUPPORTED),\n+    JSR(Classfile.JSR, 3, Kind.DISCONTINUED_JSR),\n+    RET(Classfile.RET, 2, Kind.DISCONTINUED_RET),\n@@ -239,1 +239,1 @@\n-    JSR_W(Classfile.JSR_W, 5, Kind.UNSUPPORTED),\n+    JSR_W(Classfile.JSR_W, 5, Kind.DISCONTINUED_JSR),\n@@ -250,1 +250,1 @@\n-    RET_W((Classfile.WIDE << 8) | Classfile.RET, 4, Kind.UNSUPPORTED),\n+    RET_W((Classfile.WIDE << 8) | Classfile.RET, 4, Kind.DISCONTINUED_RET),\n@@ -261,1 +261,1 @@\n-        MONITOR, NOP, UNSUPPORTED;\n+        MONITOR, NOP, DISCONTINUED_JSR, DISCONTINUED_RET;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Opcode.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.classfile.instruction.DiscontinuedInstruction;\n@@ -92,1 +93,2 @@\n-            FMT_Unbound = \"%s[op=%s]\";\n+            FMT_Unbound = \"%s[op=%s]\",\n+            FMT_Discontinued = \"Discontinued[OP=%s]\";\n@@ -708,0 +710,53 @@\n+    public static final class BoundJsrInstruction\n+            extends BoundInstruction implements DiscontinuedInstruction.JsrInstruction {\n+\n+        public BoundJsrInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public Label target() {\n+            return offsetToLabel(branchByteOffset());\n+        }\n+\n+        public int branchByteOffset() {\n+            return size == 3\n+                   ? code.classReader.readS2(pos + 1)\n+                   : code.classReader.readInt(pos + 1);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBranch(opcode(), target());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+\n+    }\n+\n+    public static final class BoundRetInstruction\n+            extends BoundInstruction implements DiscontinuedInstruction.RetInstruction {\n+\n+        public BoundRetInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return switch (size) {\n+                case 2 -> code.classReader.readU1(pos + 1);\n+                case 4 -> code.classReader.readU2(pos + 2);\n+                default -> throw new IllegalArgumentException(\"Unexpected op size: \" + op.sizeIfFixed() + \" -- \" + op);\n+            };\n+        }\n+\n+    }\n+\n@@ -747,1 +802,1 @@\n-            writer.writeLoad(op, slot);\n+            writer.writeLocalVar(op, slot);\n@@ -778,1 +833,1 @@\n-            writer.writeStore(op, slot);\n+            writer.writeLocalVar(op, slot);\n@@ -1342,0 +1397,50 @@\n+\n+    public static final class UnboundJsrInstruction\n+            extends UnboundInstruction implements DiscontinuedInstruction.JsrInstruction {\n+        final Label target;\n+\n+        public UnboundJsrInstruction(Opcode op, Label target) {\n+            super(op);\n+            this.target = target;\n+        }\n+\n+        @Override\n+        public Label target() {\n+            return target;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBranch(op, target);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+    }\n+\n+    public static final class UnboundRetInstruction\n+            extends UnboundInstruction implements DiscontinuedInstruction.RetInstruction {\n+        final int slot;\n+\n+        public UnboundRetInstruction(Opcode op, int slot) {\n+            super(op);\n+            this.slot = slot;\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return slot;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeLocalVar(op, slot);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":108,"deletions":3,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    private ClassEntry thisClass;\n+    private final ClassEntry thisClass;\n+    private final int majorVersion;\n@@ -48,1 +49,1 @@\n-        this(constantPool, 64);\n+        this(constantPool, 64, null, 0);\n@@ -52,0 +53,4 @@\n+        this(constantPool, initialSize, null, 0);\n+    }\n+\n+    public BufWriterImpl(ConstantPoolBuilder constantPool, int initialSize, ClassEntry thisClass, int majorVersion) {\n@@ -54,0 +59,2 @@\n+        this.thisClass = thisClass;\n+        this.majorVersion = majorVersion;\n@@ -77,2 +84,2 @@\n-    public void setThisClass(ClassEntry thisClass) {\n-        this.thisClass = thisClass;\n+    public int getMajorVersion() {\n+        return majorVersion;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -854,0 +854,4 @@\n+                        case DiscontinuedInstruction.JsrInstruction jsr -> in.with(leaf(\n+                                \"target\", com.labelToBci(jsr.target())));\n+                        case DiscontinuedInstruction.RetInstruction ret ->  in.with(leaf(\n+                                \"slot\", ret.slot()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,1 +245,13 @@\n-        if (a.isEmpty())\n+        if (a.isEmpty()) {\n+            if (classReader.readU2(6) <= Classfile.JAVA_6_VERSION) {\n+                \/\/fallback to jump targets inflation without StackMapTableAttribute\n+                for (int pos=codeStart; pos<codeEnd; ) {\n+                    var i = bcToInstruction(classReader.readU1(pos), pos);\n+                    switch (i) {\n+                        case BranchInstruction br -> br.target();\n+                        case DiscontinuedInstruction.JsrInstruction jsr -> jsr.target();\n+                        default -> {}\n+                    }\n+                    pos += i.sizeInBytes();\n+                }\n+            }\n@@ -247,0 +259,1 @@\n+        }\n@@ -445,1 +458,1 @@\n-                    case RET -> throw new UnsupportedOperationException(\"RET_W instruction not supported\");\n+                    case RET ->  new AbstractInstruction.BoundRetInstruction(Opcode.RET_W, this, pos);\n@@ -455,3 +468,3 @@\n-            case JSR -> throw new UnsupportedOperationException(\"JSR instruction not supported\");\n-            case RET -> throw new UnsupportedOperationException(\"RET instruction not supported\");\n-            case JSR_W -> throw new UnsupportedOperationException(\"JSR_W instruction not supported\");\n+            case JSR -> new AbstractInstruction.BoundJsrInstruction(Opcode.JSR, CodeImpl.this, pos);\n+            case RET ->  new AbstractInstruction.BoundRetInstruction(Opcode.RET, this, pos);\n+            case JSR_W -> new AbstractInstruction.BoundJsrInstruction(Opcode.JSR_W, CodeImpl.this, pos);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -170,2 +170,1 @@\n-        BufWriterImpl tail = new BufWriterImpl(constantPool, size);\n-        tail.setThisClass(thisClassEntry);\n+        BufWriterImpl tail = new BufWriterImpl(constantPool, size, thisClassEntry, majorVersion);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+import static jdk.internal.classfile.Opcode.JSR;\n+import static jdk.internal.classfile.Opcode.JSR_W;\n@@ -76,1 +78,1 @@\n-    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers = new ArrayList<>();\n+    final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers = new ArrayList<>();\n@@ -81,1 +83,1 @@\n-    private final MethodInfo methodInfo;\n+    final MethodInfo methodInfo;\n@@ -317,1 +319,3 @@\n-                    maxStack = maxLocals = 255;\n+                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n+                    maxStack = cntr.maxStack();\n+                    maxLocals = cntr.maxLocals();\n@@ -325,1 +329,1 @@\n-                else {\n+                else if (buf.getMajorVersion() >= Classfile.JAVA_7_VERSION) {\n@@ -328,8 +332,1 @@\n-                    StackMapGenerator gen = new StackMapGenerator(DirectCodeBuilder.this,\n-                                                  buf.thisClass().asSymbol(),\n-                                                  methodInfo.methodName().stringValue(),\n-                                                  MethodTypeDesc.ofDescriptor(methodInfo.methodType().stringValue()),\n-                                                  (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0,\n-                                                  bytecodesBufWriter.asByteBuffer().slice(0, codeLength),\n-                                                  constantPool,\n-                                                  handlers);\n+                    StackMapGenerator gen = StackMapGenerator.of(DirectCodeBuilder.this, buf);\n@@ -340,0 +337,7 @@\n+                else {\n+                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n+                    maxStack = cntr.maxStack();\n+                    maxLocals = cntr.maxLocals();\n+                    stackMapAttr = null;\n+                }\n+\n@@ -452,11 +456,1 @@\n-    public void writeLoad(Opcode opcode, int localVar) {\n-        writeBytecode(opcode);\n-        switch (opcode.sizeIfFixed()) {\n-            case 1 -> { }\n-            case 2 -> bytecodesBufWriter.writeU1(localVar);\n-            case 4 -> bytecodesBufWriter.writeU2(localVar);\n-            default -> throw new IllegalArgumentException(\"Unexpected instruction size: \" + opcode);\n-        }\n-    }\n-\n-    public void writeStore(Opcode opcode, int localVar) {\n+    public void writeLocalVar(Opcode opcode, int localVar) {\n@@ -497,0 +491,3 @@\n+            } else if (op == JSR) {\n+                writeBytecode(JSR_W);\n+                writeLabelOffset(4, instructionPc, target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.nio.ByteBuffer;\n+import java.util.BitSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.DynamicConstantPoolEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+\n+public final class StackCounter {\n+\n+    static StackCounter of(DirectCodeBuilder dcb, BufWriterImpl buf) {\n+        return new StackCounter(\n+                dcb,\n+                buf.thisClass().asSymbol(),\n+                dcb.methodInfo.methodName().stringValue(),\n+                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                (dcb.methodInfo.methodFlags() & ACC_STATIC) != 0,\n+                dcb.bytecodesBufWriter.asByteBuffer().slice(0, dcb.bytecodesBufWriter.size()),\n+                dcb.constantPool,\n+                dcb.handlers);\n+    }\n+\n+    private int stack, maxStack, maxLocals, rets;\n+\n+    private final RawBytecodeHelper bcs;\n+    private final String methodName;\n+    private final MethodTypeDesc methodDesc;\n+    private final SplitConstantPool cp;\n+    private final LinkedHashMap<Integer, Integer> map;\n+    private final BitSet visited;\n+\n+    private void jump(int targetBci) {\n+        if (!visited.get(targetBci)) {\n+            map.put(targetBci, stack);\n+        }\n+    }\n+\n+    private void stack(int delta) {\n+        stack += delta;\n+        if (stack > maxStack) maxStack = stack;\n+    }\n+\n+    private void local(int index) {\n+        if (index >= maxLocals) maxLocals = index + 1;\n+    }\n+\n+    private boolean next() {\n+        var it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            var en = it.next();\n+            it.remove();\n+            if (!visited.get(en.getKey())) {\n+                bcs.nextBci = en.getKey();\n+                stack = en.getValue();\n+                return true;\n+            }\n+        }\n+        bcs.nextBci = bcs.endBci;\n+        return false;\n+    }\n+\n+    public StackCounter(LabelContext labelContext,\n+                     ClassDesc thisClass,\n+                     String methodName,\n+                     MethodTypeDesc methodDesc,\n+                     boolean isStatic,\n+                     ByteBuffer bytecode,\n+                     SplitConstantPool cp,\n+                     List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {\n+        this.methodName = methodName;\n+        this.methodDesc = methodDesc;\n+        this.cp = cp;\n+        map = new LinkedHashMap<>();\n+        maxStack = stack = rets = 0;\n+        for (var h : handlers) map.put(labelContext.labelToBci(h.handler), 1);\n+        maxLocals = isStatic ? 0 : 1;\n+        for (var cd : methodDesc.parameterList()) {\n+            maxLocals += TypeKind.fromDescriptor(cd.descriptorString()).slotSize();\n+        }\n+        bcs = new RawBytecodeHelper(bytecode);\n+        visited = new BitSet(bcs.endBci);\n+        map.put(0, 0);\n+        while (next()) {\n+            while (!bcs.isLastBytecode()) {\n+                bcs.rawNext();\n+                int opcode = bcs.rawCode;\n+                int bci = bcs.bci;\n+                visited.set(bci);\n+                switch (opcode) {\n+                    case NOP, LALOAD, DALOAD, SWAP, INEG, ARRAYLENGTH, INSTANCEOF, LNEG, FNEG, DNEG, I2F, L2D, F2I, D2L, I2B, I2C, I2S,\n+                         NEWARRAY, CHECKCAST, ANEWARRAY -> {}\n+                    case RETURN ->\n+                        next();\n+                    case ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, SIPUSH, BIPUSH,\n+                         FCONST_0, FCONST_1, FCONST_2, DUP, DUP_X1, DUP_X2, I2L, I2D, F2L, F2D, NEW ->\n+                        stack(+1);\n+                    case LCONST_0, LCONST_1, DCONST_0, DCONST_1, DUP2, DUP2_X1, DUP2_X2 ->\n+                        stack(+2);\n+                    case POP, MONITORENTER, MONITOREXIT, IADD, ISUB, IMUL, IDIV, IREM, ISHL, ISHR, IUSHR, IOR, IXOR, IAND,\n+                         LSHL, LSHR, LUSHR, FADD, FSUB, FMUL, FDIV, FREM, L2I, L2F, D2F, FCMPL, FCMPG, D2I ->\n+                        stack(-1);\n+                    case POP2, LADD, LSUB, LMUL, LDIV, LREM, LAND, LOR, LXOR, DADD, DSUB, DMUL, DDIV, DREM ->\n+                        stack(-2);\n+                    case IASTORE, BASTORE, CASTORE, SASTORE, FASTORE, AASTORE, LCMP, DCMPL, DCMPG ->\n+                        stack(-3);\n+                    case LASTORE, DASTORE ->\n+                        stack(-4);\n+                    case LDC ->\n+                        processLdc(bcs.getIndexU1());\n+                    case LDC_W, LDC2_W ->\n+                        processLdc(bcs.getIndexU2());\n+                    case ILOAD, FLOAD, ALOAD -> {\n+                        local(bcs.getIndex());\n+                        stack(+1);\n+                    }\n+                    case LLOAD, DLOAD -> {\n+                        local(bcs.getIndex() + 1);\n+                        stack(+2);\n+                    }\n+                    case ILOAD_0, FLOAD_0, ALOAD_0 -> {\n+                        local(0);\n+                        stack(+1);\n+                    }\n+                    case ILOAD_1, FLOAD_1, ALOAD_1 -> {\n+                        local(1);\n+                        stack(+1);\n+                    }\n+                    case ILOAD_2, FLOAD_2, ALOAD_2 -> {\n+                        local(2);\n+                        stack(+1);\n+                    }\n+                    case ILOAD_3, FLOAD_3, ALOAD_3 -> {\n+                        local(3);\n+                        stack(+1);\n+                    }\n+                    case LLOAD_0, DLOAD_0 -> {\n+                        local(1);\n+                        stack(+2);\n+                    }\n+                    case LLOAD_1, DLOAD_1 -> {\n+                        local(2);\n+                        stack(+2);\n+                    }\n+                    case LLOAD_2, DLOAD_2 -> {\n+                        local(3);\n+                        stack(+2);\n+                    }\n+                    case LLOAD_3, DLOAD_3 -> {\n+                        local(4);\n+                        stack(+2);\n+                    }\n+                    case IALOAD, BALOAD, CALOAD, SALOAD, FALOAD, AALOAD ->  {\n+                        stack(-1);\n+                    }\n+                    case ISTORE, FSTORE, ASTORE -> {\n+                        local(bcs.getIndex());\n+                        stack(-1);\n+                    }\n+                    case LSTORE, DSTORE -> {\n+                        local(bcs.getIndex() + 1);\n+                        stack(-2);\n+                    }\n+                    case ISTORE_0, FSTORE_0, ASTORE_0 -> {\n+                        local(0);\n+                        stack(-1);\n+                    }\n+                    case ISTORE_1, FSTORE_1, ASTORE_1 -> {\n+                        local(1);\n+                        stack(-1);\n+                    }\n+                    case ISTORE_2, FSTORE_2, ASTORE_2 -> {\n+                        local(2);\n+                        stack(-1);\n+                    }\n+                    case ISTORE_3, FSTORE_3, ASTORE_3 -> {\n+                        local(3);\n+                        stack(-1);\n+                    }\n+                    case LSTORE_0, DSTORE_0 -> {\n+                        local(1);\n+                        stack(-2);\n+                    }\n+                    case LSTORE_1, DSTORE_1 -> {\n+                        local(2);\n+                        stack(-2);\n+                    }\n+                    case LSTORE_2, DSTORE_2 -> {\n+                        local(3);\n+                        stack(-2);\n+                    }\n+                    case LSTORE_3, DSTORE_3 -> {\n+                        local(4);\n+                        stack(-2);\n+                    }\n+                    case IINC ->\n+                        local(bcs.getIndex());\n+                    case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE -> {\n+                        stack(-2);\n+                        jump(bcs.dest());\n+                    }\n+                    case IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IFNULL, IFNONNULL -> {\n+                        stack(-1);\n+                        jump(bcs.dest());\n+                    }\n+                    case GOTO -> {\n+                        jump(bcs.dest());\n+                        next();\n+                    }\n+                    case GOTO_W -> {\n+                        jump(bcs.destW());\n+                        next();\n+                    }\n+                    case TABLESWITCH, LOOKUPSWITCH -> {\n+                        int alignedBci = RawBytecodeHelper.align(bci + 1);\n+                        int defaultOfset = bcs.getInt(alignedBci);\n+                        int keys, delta;\n+                        stack(-1);\n+                        if (bcs.rawCode == TABLESWITCH) {\n+                            int low = bcs.getInt(alignedBci + 4);\n+                            int high = bcs.getInt(alignedBci + 2 * 4);\n+                            if (low > high) {\n+                                error(\"low must be less than or equal to high in tableswitch\");\n+                            }\n+                            keys = high - low + 1;\n+                            if (keys < 0) {\n+                                error(\"too many keys in tableswitch\");\n+                            }\n+                            delta = 1;\n+                        } else {\n+                            keys = bcs.getInt(alignedBci + 4);\n+                            if (keys < 0) {\n+                                error(\"number of keys in lookupswitch less than 0\");\n+                            }\n+                            delta = 2;\n+                            for (int i = 0; i < (keys - 1); i++) {\n+                                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n+                                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                                if (this_key >= next_key) {\n+                                    error(\"Bad lookupswitch instruction\");\n+                                }\n+                            }\n+                        }\n+                        int target = bci + defaultOfset;\n+                        jump(target);\n+                        for (int i = 0; i < keys; i++) {\n+                            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n+                            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+                            jump(target);\n+                        }\n+                        next();\n+                    }\n+                    case LRETURN, DRETURN -> {\n+                        stack(-2);\n+                        next();\n+                    }\n+                    case IRETURN, FRETURN, ARETURN, ATHROW -> {\n+                        stack(-1);\n+                        next();\n+                    }\n+                    case GETSTATIC, PUTSTATIC, GETFIELD, PUTFIELD -> {\n+                        var tk = TypeKind.fromDescriptor(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType().type().stringValue());\n+                        switch (bcs.rawCode) {\n+                            case GETSTATIC ->\n+                                stack(tk.slotSize());\n+                            case PUTSTATIC ->\n+                                stack(-tk.slotSize());\n+                            case GETFIELD ->\n+                                stack(tk.slotSize() - 1);\n+                            case PUTFIELD ->\n+                                stack(-tk.slotSize() - 1);\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                    case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE, INVOKEDYNAMIC -> {\n+                        var cpe = cp.entryByIndex(bcs.getIndexU2());\n+                        var nameAndType = opcode == INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n+                        var mDesc = MethodTypeDesc.ofDescriptor(nameAndType.type().stringValue());\n+                        for (var arg : mDesc.parameterList()) {\n+                            stack(-TypeKind.fromDescriptor(arg.descriptorString()).slotSize());\n+                        }\n+                        if (opcode != INVOKESTATIC && opcode != INVOKEDYNAMIC) {\n+                            stack(-1);\n+                        }\n+                        stack(TypeKind.fromDescriptor(mDesc.returnType().descriptorString()).slotSize());\n+                    }\n+                    case MULTIANEWARRAY ->\n+                        stack (1 - bcs.getU1(bcs.bci + 3));\n+                    case JSR -> {\n+                        stack(+1);\n+                        jump(bcs.dest());\n+                    }\n+                    case JSR_W -> {\n+                        stack(+1);\n+                        jump(bcs.destW());\n+                    }\n+                    case RET -> {\n+                        local(bcs.getIndex());\n+                        rets++;\n+                        next();\n+                    }\n+                    default ->\n+                        error(String.format(\"Bad instruction: %02x\", opcode));\n+                }\n+            }\n+        }\n+        \/\/heuristic calculation of upper bounds of maxStack when subroutines are present\n+        maxStack += rets * maxStack;\n+    }\n+\n+    \/**\n+     * Calculated maximum number of the locals required\n+     * @return maximum number of the locals required\n+     *\/\n+    public int maxLocals() {\n+        return maxLocals;\n+    }\n+\n+    \/**\n+     * Calculated maximum stack size required\n+     * @return maximum stack size required\n+     *\/\n+    public int maxStack() {\n+        return maxStack;\n+    }\n+\n+    private void processLdc(int index) {\n+        switch (cp.entryByIndex(index).tag()) {\n+            case TAG_UTF8, TAG_STRING, TAG_CLASS, TAG_INTEGER, TAG_FLOAT, TAG_METHODHANDLE, TAG_METHODTYPE ->\n+                stack(+1);\n+            case TAG_DOUBLE, TAG_LONG ->\n+                stack(+2);\n+            case TAG_CONSTANTDYNAMIC ->\n+                stack(((ConstantDynamicEntry)cp.entryByIndex(index)).typeKind().slotSize());\n+            default ->\n+                error(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        throw new IllegalArgumentException(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+                msg,\n+                bcs.bci,\n+                methodName,\n+                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -158,0 +158,12 @@\n+    static StackMapGenerator of(DirectCodeBuilder dcb, BufWriterImpl buf) {\n+        return new StackMapGenerator(\n+                dcb,\n+                buf.thisClass().asSymbol(),\n+                dcb.methodInfo.methodName().stringValue(),\n+                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                (dcb.methodInfo.methodFlags() & ACC_STATIC) != 0,\n+                dcb.bytecodesBufWriter.asByteBuffer().slice(0, dcb.bytecodesBufWriter.size()),\n+                dcb.constantPool,\n+                dcb.handlers);\n+    }\n+\n@@ -310,1 +322,1 @@\n-                    bytecode.put((byte) Classfile.NOP);\n+                    bytecode.put((byte) NOP);\n@@ -312,1 +324,1 @@\n-                bytecode.put((byte) Classfile.ATHROW);\n+                bytecode.put((byte) ATHROW);\n@@ -436,2 +448,2 @@\n-            case Classfile.NOP -> {}\n-            case Classfile.RETURN -> {\n+            case NOP -> {}\n+            case RETURN -> {\n@@ -440,1 +452,1 @@\n-            case Classfile.ACONST_NULL ->\n+            case ACONST_NULL ->\n@@ -442,1 +454,1 @@\n-            case Classfile.ICONST_M1, Classfile.ICONST_0, Classfile.ICONST_1, Classfile.ICONST_2, Classfile.ICONST_3, Classfile.ICONST_4, Classfile.ICONST_5, Classfile.SIPUSH, Classfile.BIPUSH ->\n+            case ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, SIPUSH, BIPUSH ->\n@@ -444,1 +456,1 @@\n-            case Classfile.LCONST_0, Classfile.LCONST_1 ->\n+            case LCONST_0, LCONST_1 ->\n@@ -446,1 +458,1 @@\n-            case Classfile.FCONST_0, Classfile.FCONST_1, Classfile.FCONST_2 ->\n+            case FCONST_0, FCONST_1, FCONST_2 ->\n@@ -448,1 +460,1 @@\n-            case Classfile.DCONST_0, Classfile.DCONST_1 ->\n+            case DCONST_0, DCONST_1 ->\n@@ -450,1 +462,1 @@\n-            case Classfile.LDC ->\n+            case LDC ->\n@@ -452,1 +464,1 @@\n-            case Classfile.LDC_W, Classfile.LDC2_W ->\n+            case LDC_W, LDC2_W ->\n@@ -454,1 +466,1 @@\n-            case Classfile.ILOAD ->\n+            case ILOAD ->\n@@ -456,3 +468,3 @@\n-            case Classfile.ILOAD_0, Classfile.ILOAD_1, Classfile.ILOAD_2, Classfile.ILOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.ILOAD_0).pushStack(Type.INTEGER_TYPE);\n-            case Classfile.LLOAD ->\n+            case ILOAD_0, ILOAD_1, ILOAD_2, ILOAD_3 ->\n+                currentFrame.checkLocal(opcode - ILOAD_0).pushStack(Type.INTEGER_TYPE);\n+            case LLOAD ->\n@@ -460,3 +472,3 @@\n-            case Classfile.LLOAD_0, Classfile.LLOAD_1, Classfile.LLOAD_2, Classfile.LLOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.LLOAD_0 + 1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-            case Classfile.FLOAD ->\n+            case LLOAD_0, LLOAD_1, LLOAD_2, LLOAD_3 ->\n+                currentFrame.checkLocal(opcode - LLOAD_0 + 1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case FLOAD ->\n@@ -464,3 +476,3 @@\n-            case Classfile.FLOAD_0, Classfile.FLOAD_1, Classfile.FLOAD_2, Classfile.FLOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.FLOAD_0).pushStack(Type.FLOAT_TYPE);\n-            case Classfile.DLOAD ->\n+            case FLOAD_0, FLOAD_1, FLOAD_2, FLOAD_3 ->\n+                currentFrame.checkLocal(opcode - FLOAD_0).pushStack(Type.FLOAT_TYPE);\n+            case DLOAD ->\n@@ -468,3 +480,3 @@\n-            case Classfile.DLOAD_0, Classfile.DLOAD_1, Classfile.DLOAD_2, Classfile.DLOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.DLOAD_0 + 1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-            case Classfile.ALOAD ->\n+            case DLOAD_0, DLOAD_1, DLOAD_2, DLOAD_3 ->\n+                currentFrame.checkLocal(opcode - DLOAD_0 + 1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case ALOAD ->\n@@ -472,3 +484,3 @@\n-            case Classfile.ALOAD_0, Classfile.ALOAD_1, Classfile.ALOAD_2, Classfile.ALOAD_3 ->\n-                currentFrame.pushStack(currentFrame.getLocal(opcode - Classfile.ALOAD_0));\n-            case Classfile.IALOAD, Classfile.BALOAD, Classfile.CALOAD, Classfile.SALOAD ->\n+            case ALOAD_0, ALOAD_1, ALOAD_2, ALOAD_3 ->\n+                currentFrame.pushStack(currentFrame.getLocal(opcode - ALOAD_0));\n+            case IALOAD, BALOAD, CALOAD, SALOAD ->\n@@ -476,1 +488,1 @@\n-            case Classfile.LALOAD ->\n+            case LALOAD ->\n@@ -478,1 +490,1 @@\n-            case Classfile.FALOAD ->\n+            case FALOAD ->\n@@ -480,1 +492,1 @@\n-            case Classfile.DALOAD ->\n+            case DALOAD ->\n@@ -482,1 +494,1 @@\n-            case Classfile.AALOAD ->\n+            case AALOAD ->\n@@ -484,1 +496,1 @@\n-            case Classfile.ISTORE ->\n+            case ISTORE ->\n@@ -486,3 +498,3 @@\n-            case Classfile.ISTORE_0, Classfile.ISTORE_1, Classfile.ISTORE_2, Classfile.ISTORE_3 ->\n-                currentFrame.decStack(1).setLocal(opcode - Classfile.ISTORE_0, Type.INTEGER_TYPE);\n-            case Classfile.LSTORE ->\n+            case ISTORE_0, ISTORE_1, ISTORE_2, ISTORE_3 ->\n+                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+            case LSTORE ->\n@@ -490,3 +502,3 @@\n-            case Classfile.LSTORE_0, Classfile.LSTORE_1, Classfile.LSTORE_2, Classfile.LSTORE_3 ->\n-                currentFrame.decStack(2).setLocal2(opcode - Classfile.LSTORE_0, Type.LONG_TYPE, Type.LONG2_TYPE);\n-            case Classfile.FSTORE ->\n+            case LSTORE_0, LSTORE_1, LSTORE_2, LSTORE_3 ->\n+                currentFrame.decStack(2).setLocal2(opcode - LSTORE_0, Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case FSTORE ->\n@@ -494,3 +506,3 @@\n-            case Classfile.FSTORE_0, Classfile.FSTORE_1, Classfile.FSTORE_2, Classfile.FSTORE_3 ->\n-                currentFrame.decStack(1).setLocal(opcode - Classfile.FSTORE_0, Type.FLOAT_TYPE);\n-            case Classfile.DSTORE ->\n+            case FSTORE_0, FSTORE_1, FSTORE_2, FSTORE_3 ->\n+                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+            case DSTORE ->\n@@ -498,3 +510,3 @@\n-            case Classfile.DSTORE_0, Classfile.DSTORE_1, Classfile.DSTORE_2, Classfile.DSTORE_3 ->\n-                currentFrame.decStack(2).setLocal2(opcode - Classfile.DSTORE_0, Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-            case Classfile.ASTORE ->\n+            case DSTORE_0, DSTORE_1, DSTORE_2, DSTORE_3 ->\n+                currentFrame.decStack(2).setLocal2(opcode - DSTORE_0, Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case ASTORE ->\n@@ -502,3 +514,3 @@\n-            case Classfile.ASTORE_0, Classfile.ASTORE_1, Classfile.ASTORE_2, Classfile.ASTORE_3 ->\n-                currentFrame.setLocal(opcode - Classfile.ASTORE_0, currentFrame.popStack());\n-            case Classfile.LASTORE, Classfile.DASTORE ->\n+            case ASTORE_0, ASTORE_1, ASTORE_2, ASTORE_3 ->\n+                currentFrame.setLocal(opcode - ASTORE_0, currentFrame.popStack());\n+            case LASTORE, DASTORE ->\n@@ -506,1 +518,1 @@\n-            case Classfile.IASTORE, Classfile.BASTORE, Classfile.CASTORE, Classfile.SASTORE, Classfile.FASTORE, Classfile.AASTORE ->\n+            case IASTORE, BASTORE, CASTORE, SASTORE, FASTORE, AASTORE ->\n@@ -508,1 +520,1 @@\n-            case Classfile.POP, Classfile.MONITORENTER, Classfile.MONITOREXIT ->\n+            case POP, MONITORENTER, MONITOREXIT ->\n@@ -510,1 +522,1 @@\n-            case Classfile.POP2 ->\n+            case POP2 ->\n@@ -512,1 +524,1 @@\n-            case Classfile.DUP ->\n+            case DUP ->\n@@ -514,1 +526,1 @@\n-            case Classfile.DUP_X1 -> {\n+            case DUP_X1 -> {\n@@ -519,1 +531,1 @@\n-            case Classfile.DUP_X2 -> {\n+            case DUP_X2 -> {\n@@ -525,1 +537,1 @@\n-            case Classfile.DUP2 -> {\n+            case DUP2 -> {\n@@ -530,1 +542,1 @@\n-            case Classfile.DUP2_X1 -> {\n+            case DUP2_X1 -> {\n@@ -536,1 +548,1 @@\n-            case Classfile.DUP2_X2 -> {\n+            case DUP2_X2 -> {\n@@ -543,1 +555,1 @@\n-            case Classfile.SWAP -> {\n+            case SWAP -> {\n@@ -549,1 +561,1 @@\n-            case Classfile.IADD, Classfile.ISUB, Classfile.IMUL, Classfile.IDIV, Classfile.IREM, Classfile.ISHL, Classfile.ISHR, Classfile.IUSHR, Classfile.IOR, Classfile.IXOR, Classfile.IAND ->\n+            case IADD, ISUB, IMUL, IDIV, IREM, ISHL, ISHR, IUSHR, IOR, IXOR, IAND ->\n@@ -551,1 +563,1 @@\n-            case Classfile.INEG, Classfile.ARRAYLENGTH, Classfile.INSTANCEOF ->\n+            case INEG, ARRAYLENGTH, INSTANCEOF ->\n@@ -553,1 +565,1 @@\n-            case Classfile.LADD, Classfile.LSUB, Classfile.LMUL, Classfile.LDIV, Classfile.LREM, Classfile.LAND, Classfile.LOR, Classfile.LXOR ->\n+            case LADD, LSUB, LMUL, LDIV, LREM, LAND, LOR, LXOR ->\n@@ -555,1 +567,1 @@\n-            case Classfile.LNEG ->\n+            case LNEG ->\n@@ -557,1 +569,1 @@\n-            case Classfile.LSHL, Classfile.LSHR, Classfile.LUSHR ->\n+            case LSHL, LSHR, LUSHR ->\n@@ -559,1 +571,1 @@\n-            case Classfile.FADD, Classfile.FSUB, Classfile.FMUL, Classfile.FDIV, Classfile.FREM ->\n+            case FADD, FSUB, FMUL, FDIV, FREM ->\n@@ -561,1 +573,1 @@\n-            case Classfile.FNEG ->\n+            case FNEG ->\n@@ -563,1 +575,1 @@\n-            case Classfile.DADD, Classfile.DSUB, Classfile.DMUL, Classfile.DDIV, Classfile.DREM ->\n+            case DADD, DSUB, DMUL, DDIV, DREM ->\n@@ -565,1 +577,1 @@\n-            case Classfile.DNEG ->\n+            case DNEG ->\n@@ -567,1 +579,1 @@\n-            case Classfile.IINC ->\n+            case IINC ->\n@@ -569,1 +581,1 @@\n-            case Classfile.I2L ->\n+            case I2L ->\n@@ -571,1 +583,1 @@\n-            case Classfile.L2I ->\n+            case L2I ->\n@@ -573,1 +585,1 @@\n-            case Classfile.I2F ->\n+            case I2F ->\n@@ -575,1 +587,1 @@\n-            case Classfile.I2D ->\n+            case I2D ->\n@@ -577,1 +589,1 @@\n-            case Classfile.L2F ->\n+            case L2F ->\n@@ -579,1 +591,1 @@\n-            case Classfile.L2D ->\n+            case L2D ->\n@@ -581,1 +593,1 @@\n-            case Classfile.F2I ->\n+            case F2I ->\n@@ -583,1 +595,1 @@\n-            case Classfile.F2L ->\n+            case F2L ->\n@@ -585,1 +597,1 @@\n-            case Classfile.F2D ->\n+            case F2D ->\n@@ -587,1 +599,1 @@\n-            case Classfile.D2L ->\n+            case D2L ->\n@@ -589,1 +601,1 @@\n-            case Classfile.D2F ->\n+            case D2F ->\n@@ -591,1 +603,1 @@\n-            case Classfile.I2B, Classfile.I2C, Classfile.I2S ->\n+            case I2B, I2C, I2S ->\n@@ -593,1 +605,1 @@\n-            case Classfile.LCMP, Classfile.DCMPL, Classfile.DCMPG ->\n+            case LCMP, DCMPL, DCMPG ->\n@@ -595,1 +607,1 @@\n-            case Classfile.FCMPL, Classfile.FCMPG, Classfile.D2I ->\n+            case FCMPL, FCMPG, D2I ->\n@@ -597,1 +609,1 @@\n-            case Classfile.IF_ICMPEQ, Classfile.IF_ICMPNE, Classfile.IF_ICMPLT, Classfile.IF_ICMPGE, Classfile.IF_ICMPGT, Classfile.IF_ICMPLE, Classfile.IF_ACMPEQ, Classfile.IF_ACMPNE ->\n+            case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE ->\n@@ -599,1 +611,1 @@\n-            case Classfile.IFEQ, Classfile.IFNE, Classfile.IFLT, Classfile.IFGE, Classfile.IFGT, Classfile.IFLE, Classfile.IFNULL, Classfile.IFNONNULL ->\n+            case IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IFNULL, IFNONNULL ->\n@@ -601,1 +613,1 @@\n-            case Classfile.GOTO -> {\n+            case GOTO -> {\n@@ -605,1 +617,1 @@\n-            case Classfile.GOTO_W -> {\n+            case GOTO_W -> {\n@@ -609,1 +621,1 @@\n-            case Classfile.TABLESWITCH, Classfile.LOOKUPSWITCH -> {\n+            case TABLESWITCH, LOOKUPSWITCH -> {\n@@ -613,1 +625,1 @@\n-            case Classfile.LRETURN, Classfile.DRETURN -> {\n+            case LRETURN, DRETURN -> {\n@@ -617,1 +629,1 @@\n-            case Classfile.IRETURN, Classfile.FRETURN, Classfile.ARETURN, Classfile.ATHROW -> {\n+            case IRETURN, FRETURN, ARETURN, ATHROW -> {\n@@ -621,1 +633,1 @@\n-            case Classfile.GETSTATIC, Classfile.PUTSTATIC, Classfile.GETFIELD, Classfile.PUTFIELD ->\n+            case GETSTATIC, PUTSTATIC, GETFIELD, PUTFIELD ->\n@@ -623,1 +635,1 @@\n-            case Classfile.INVOKEVIRTUAL, Classfile.INVOKESPECIAL, Classfile.INVOKESTATIC, Classfile.INVOKEINTERFACE, Classfile.INVOKEDYNAMIC ->\n+            case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE, INVOKEDYNAMIC ->\n@@ -625,1 +637,1 @@\n-            case Classfile.NEW ->\n+            case NEW ->\n@@ -627,1 +639,1 @@\n-            case Classfile.NEWARRAY ->\n+            case NEWARRAY ->\n@@ -629,1 +641,1 @@\n-            case Classfile.ANEWARRAY ->\n+            case ANEWARRAY ->\n@@ -631,1 +643,1 @@\n-            case Classfile.CHECKCAST ->\n+            case CHECKCAST ->\n@@ -633,1 +645,1 @@\n-            case Classfile.MULTIANEWARRAY -> {\n+            case MULTIANEWARRAY -> {\n@@ -641,0 +653,2 @@\n+            case JSR, JSR_W, RET ->\n+                generatorError(\"Instructions jsr, jsr_w, or ret must not appear in the class file version >= 51.0\");\n@@ -697,1 +711,1 @@\n-        if (bcs.rawCode == Classfile.TABLESWITCH) {\n+        if (bcs.rawCode == TABLESWITCH) {\n@@ -734,1 +748,1 @@\n-            case Classfile.GETSTATIC ->\n+            case GETSTATIC ->\n@@ -736,1 +750,1 @@\n-            case Classfile.PUTSTATIC -> {\n+            case PUTSTATIC -> {\n@@ -740,1 +754,1 @@\n-            case Classfile.GETFIELD -> {\n+            case GETFIELD -> {\n@@ -744,1 +758,1 @@\n-            case Classfile.PUTFIELD -> {\n+            case PUTFIELD -> {\n@@ -757,1 +771,1 @@\n-        var nameAndType = opcode == Classfile.INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n+        var nameAndType = opcode == INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n@@ -789,1 +803,1 @@\n-        if (opcode != Classfile.INVOKESTATIC && opcode != Classfile.INVOKEDYNAMIC) {\n+        if (opcode != INVOKESTATIC && opcode != INVOKEDYNAMIC) {\n@@ -902,1 +916,1 @@\n-                case Classfile.GOTO -> {\n+                case GOTO -> {\n@@ -906,1 +920,1 @@\n-                case Classfile.GOTO_W -> {\n+                case GOTO_W -> {\n@@ -910,4 +924,4 @@\n-                case Classfile.IF_ICMPEQ, Classfile.IF_ICMPNE, Classfile.IF_ICMPLT, Classfile.IF_ICMPGE,\n-                     Classfile.IF_ICMPGT, Classfile.IF_ICMPLE, Classfile.IFEQ, Classfile.IFNE,\n-                     Classfile.IFLT, Classfile.IFGE, Classfile.IFGT, Classfile.IFLE, Classfile.IF_ACMPEQ,\n-                     Classfile.IF_ACMPNE , Classfile.IFNULL , Classfile.IFNONNULL -> {\n+                case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE,\n+                     IF_ICMPGT, IF_ICMPLE, IFEQ, IFNE,\n+                     IFLT, IFGE, IFGT, IFLE, IF_ACMPEQ,\n+                     IF_ACMPNE , IFNULL , IFNONNULL -> {\n@@ -917,1 +931,1 @@\n-                case Classfile.TABLESWITCH, Classfile.LOOKUPSWITCH -> {\n+                case TABLESWITCH, LOOKUPSWITCH -> {\n@@ -921,1 +935,1 @@\n-                            if (bcs.rawCode == Classfile.TABLESWITCH) {\n+                            if (bcs.rawCode == TABLESWITCH) {\n@@ -936,2 +950,2 @@\n-                case Classfile.IRETURN, Classfile.LRETURN, Classfile.FRETURN, Classfile.DRETURN,\n-                     Classfile.ARETURN, Classfile.RETURN, Classfile.ATHROW -> true;\n+                case IRETURN, LRETURN, FRETURN, DRETURN,\n+                     ARETURN, RETURN, ATHROW -> true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":126,"deletions":112,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models instruction discontinued from the {@code code} array of a {@code Code}\n+ * attribute. Delivered as a {@link CodeElement} when traversing the elements of\n+ * a {@link CodeModel}.\n+ *\/\n+public sealed interface DiscontinuedInstruction extends Instruction {\n+\n+    \/**\n+     * Models JSR and JSR_W instructions discontinued from the {@code code}\n+     * array of a {@code Code} attribute since class file version 51.0.\n+     * Corresponding opcodes will have a {@code kind} of\n+     * {@link Opcode.Kind#DISCONTINUED_JSR}.  Delivered as a {@link CodeElement}\n+     * when traversing the elements of a {@link CodeModel}.\n+     *\/\n+    sealed interface JsrInstruction extends DiscontinuedInstruction\n+            permits AbstractInstruction.BoundJsrInstruction,\n+                    AbstractInstruction.UnboundJsrInstruction {\n+\n+        \/**\n+         * {@return the target of the JSR instruction}\n+         *\/\n+        Label target();\n+\n+        \/**\n+         * {@return a JSR instruction}\n+         *\n+         * @param op the opcode for the specific type of JSR instruction,\n+         *           which must be of kind {@link Opcode.Kind#DISCONTINUED_JSR}\n+         * @param target target label of the subroutine\n+         *\/\n+        static JsrInstruction of(Opcode op, Label target) {\n+            Util.checkKind(op, Opcode.Kind.DISCONTINUED_JSR);\n+            return new AbstractInstruction.UnboundJsrInstruction(op, target);\n+        }\n+\n+        \/**\n+         * {@return a JSR instruction}\n+         *\n+         * @param target target label of the subroutine\n+         *\/\n+        static JsrInstruction of(Label target) {\n+            return of(Opcode.JSR, target);\n+        }\n+    }\n+\n+    \/**\n+     * Models RET and RET_W instructions discontinued from the {@code code}\n+     * array of a {@code Code} attribute since class file version 51.0.\n+     * Corresponding opcodes will have a {@code kind} of\n+     * {@link Opcode.Kind#DISCONTINUED_RET}.  Delivered as a {@link CodeElement}\n+     * when traversing the elements of a {@link CodeModel}.\n+     *\/\n+    sealed interface RetInstruction extends DiscontinuedInstruction\n+            permits AbstractInstruction.BoundRetInstruction,\n+                    AbstractInstruction.UnboundRetInstruction {\n+\n+        \/**\n+         * {@return the local variable slot with return address}\n+         *\/\n+        int slot();\n+\n+        \/**\n+         * {@return a RET or RET_W instruction}\n+         *\n+         * @param op the opcode for the specific type of RET instruction,\n+         *           which must be of kind {@link Opcode.Kind#DISCONTINUED_RET}\n+         * @param slot the local variable slot to load return address from\n+         *\/\n+        static RetInstruction of(Opcode op, int slot) {\n+            Util.checkKind(op, Opcode.Kind.DISCONTINUED_RET);\n+            return new AbstractInstruction.UnboundRetInstruction(op, slot);\n+        }\n+\n+        \/**\n+         * {@return a RET instruction}\n+         *\n+         * @param slot the local variable slot to load return address from\n+         *\/\n+        static RetInstruction of(int slot) {\n+            return of(slot < 256 ? Opcode.RET : Opcode.RET_W, slot);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/DiscontinuedInstruction.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+import jdk.internal.classfile.CodeTransform;\n@@ -206,1 +207,1 @@\n-        var newModel = Classfile.parse(newBytes);\n+        var newModel = Classfile.parse(newBytes, Classfile.Option.generateStackmap(false));\n@@ -212,0 +213,17 @@\n+\n+        \/\/testing maxStack and maxLocals are calculated identically by StackMapGenerator and StackCounter\n+        byte[] noStackMaps = newModel.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+        var noStackModel = Classfile.parse(noStackMaps);\n+        var itStack = newModel.methods().iterator();\n+        var itNoStack = noStackModel.methods().iterator();\n+        while (itStack.hasNext()) {\n+            assertTrue(itNoStack.hasNext());\n+            var m1 = itStack.next();\n+            var m2 = itNoStack.next();\n+            var text1 = m1.methodName().stringValue() + m1.methodType().stringValue() + \": \"\n+                      + m1.code().map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n+            var text2 = m2.methodName().stringValue() + m2.methodType().stringValue() + \": \"\n+                      + m2.code().map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n+            assertEquals(text1, text2);\n+        }\n+        assertFalse(itNoStack.hasNext());\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile handling JSR and RET instructions.\n+ * @run junit DiscontinuedInstructionsTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.instruction.DiscontinuedInstruction;\n+import helpers.ByteArrayClassLoader;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+class DiscontinuedInstructionsTest {\n+\n+    @Test\n+    void testJsrAndRetProcessing() throws Exception {\n+        var testClass = \"JsrAndRetSample\";\n+        var testMethod = \"testMethod\";\n+        var cd_list = ArrayList.class.describeConstable().get();\n+        var bytes = Classfile.build(ClassDesc.of(testClass), clb -> clb\n+                .withVersion(JAVA_5_VERSION, 0)\n+                .withMethodBody(testMethod, MethodTypeDesc.of(CD_void, cd_list), ACC_PUBLIC | ACC_STATIC, cob -> cob\n+                        .block(bb -> {\n+                            bb.constantInstruction(\"Hello\")\n+                              .with(DiscontinuedInstruction.JsrInstruction.of(bb.breakLabel()));\n+                            bb.constantInstruction(\"World\")\n+                              .with(DiscontinuedInstruction.JsrInstruction.of(Opcode.JSR_W, bb.breakLabel()))\n+                              .return_();\n+                        })\n+                        .astore(355)\n+                        .aload(0)\n+                        .swap()\n+                        .invokevirtual(cd_list, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n+                        .pop()\n+                        .with(DiscontinuedInstruction.RetInstruction.of(355))));\n+\n+        var c = Classfile.parse(bytes).methods().get(0).code().get();\n+        assertEquals(356, c.maxLocals());\n+        assertEquals(8, c.maxStack());\n+\n+\n+        var list = new ArrayList<String>();\n+        new ByteArrayClassLoader(DiscontinuedInstructionsTest.class.getClassLoader(), testClass, bytes)\n+                .getMethod(testClass, testMethod)\n+                .invoke(null, list);\n+        assertEquals(list, List.of(\"Hello\", \"World\"));\n+\n+        bytes = Classfile.parse(bytes).transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+\n+        new ByteArrayClassLoader(DiscontinuedInstructionsTest.class.getClassLoader(), testClass, bytes)\n+                .getMethod(testClass, testMethod)\n+                .invoke(null, list);\n+        assertEquals(list, List.of(\"Hello\", \"World\", \"Hello\", \"World\"));\n+\n+        var clm = Classfile.parse(bytes);\n+        var exception = assertThrows(IllegalStateException.class, () ->\n+                clm.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                   .andThen(ClassTransform.endHandler(clb -> clb.withVersion(JAVA_7_VERSION, 0)))));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+ * @bug 8305990\n@@ -33,1 +34,2 @@\n-import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -218,0 +220,14 @@\n+    @Test\n+    void testClassVersions() throws Exception {\n+        var actualVersion = Classfile.parse(StackMapsTest.class.getResourceAsStream(\"\/testdata\/Pattern1.class\").readAllBytes());\n+\n+        \/\/test transformation to class version 49 with removal of StackMapTable attributes\n+        var version49 = Classfile.parse(actualVersion.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.endHandler(clb -> clb.withVersion(49, 0)))));\n+        assertFalse(ClassPrinter.toTree(version49, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES).walk().anyMatch(n -> n.name().equals(\"stack map frames\")));\n+\n+        \/\/test transformation to class version 51 with re-generation of StackMapTable attributes\n+         assertEmpty(Classfile.parse(version49.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.endHandler(clb -> clb.withVersion(51, 0))))).verify(null));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -203,0 +203,4 @@\n+                                                case DiscontinuedInstruction.JsrInstruction i ->\n+                                                    cob.with(DiscontinuedInstruction.JsrInstruction.of(i.opcode(), labels.computeIfAbsent(i.target(), l -> cob.newLabel())));\n+                                                case DiscontinuedInstruction.RetInstruction i ->\n+                                                    cob.with(DiscontinuedInstruction.RetInstruction.of(i.opcode(), i.slot()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}