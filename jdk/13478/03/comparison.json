{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.classfile.instruction.DiscontinuedInstruction;\n@@ -59,3 +60,3 @@\n-                ConstantInstruction, ConvertInstruction, FieldInstruction,\n-                InvokeDynamicInstruction, InvokeInstruction, LoadInstruction,\n-                StoreInstruction, IncrementInstruction,\n+                ConstantInstruction, ConvertInstruction, DiscontinuedInstruction,\n+                FieldInstruction, InvokeDynamicInstruction, InvokeInstruction,\n+                LoadInstruction, StoreInstruction, IncrementInstruction,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Instruction.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -207,2 +207,2 @@\n-    JSR(Classfile.JSR, 3, Kind.UNSUPPORTED),\n-    RET(Classfile.RET, 2, Kind.UNSUPPORTED),\n+    JSR(Classfile.JSR, 3, Kind.DISCONTINUED_JSR),\n+    RET(Classfile.RET, 2, Kind.DISCONTINUED_RET),\n@@ -239,1 +239,1 @@\n-    JSR_W(Classfile.JSR_W, 5, Kind.UNSUPPORTED),\n+    JSR_W(Classfile.JSR_W, 5, Kind.DISCONTINUED_JSR),\n@@ -250,1 +250,1 @@\n-    RET_W((Classfile.WIDE << 8) | Classfile.RET, 4, Kind.UNSUPPORTED),\n+    RET_W((Classfile.WIDE << 8) | Classfile.RET, 4, Kind.DISCONTINUED_RET),\n@@ -261,1 +261,1 @@\n-        MONITOR, NOP, UNSUPPORTED;\n+        MONITOR, NOP, DISCONTINUED_JSR, DISCONTINUED_RET;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Opcode.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.classfile.instruction.DiscontinuedInstruction;\n@@ -92,1 +93,2 @@\n-            FMT_Unbound = \"%s[op=%s]\";\n+            FMT_Unbound = \"%s[op=%s]\",\n+            FMT_Discontinued = \"Discontinued[OP=%s]\";\n@@ -708,0 +710,53 @@\n+    public static final class BoundJsrInstruction\n+            extends BoundInstruction implements DiscontinuedInstruction.JsrInstruction {\n+\n+        public BoundJsrInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public Label target() {\n+            return offsetToLabel(branchByteOffset());\n+        }\n+\n+        public int branchByteOffset() {\n+            return size == 3\n+                   ? code.classReader.readS2(pos + 1)\n+                   : code.classReader.readInt(pos + 1);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBranch(opcode(), target());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+\n+    }\n+\n+    public static final class BoundRetInstruction\n+            extends BoundInstruction implements DiscontinuedInstruction.RetInstruction {\n+\n+        public BoundRetInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return switch (size) {\n+                case 2 -> code.classReader.readU1(pos + 1);\n+                case 4 -> code.classReader.readU2(pos + 2);\n+                default -> throw new IllegalArgumentException(\"Unexpected op size: \" + op.sizeIfFixed() + \" -- \" + op);\n+            };\n+        }\n+\n+    }\n+\n@@ -747,1 +802,1 @@\n-            writer.writeLoad(op, slot);\n+            writer.writeLocalVar(op, slot);\n@@ -778,1 +833,1 @@\n-            writer.writeStore(op, slot);\n+            writer.writeLocalVar(op, slot);\n@@ -1342,0 +1397,50 @@\n+\n+    public static final class UnboundJsrInstruction\n+            extends UnboundInstruction implements DiscontinuedInstruction.JsrInstruction {\n+        final Label target;\n+\n+        public UnboundJsrInstruction(Opcode op, Label target) {\n+            super(op);\n+            this.target = target;\n+        }\n+\n+        @Override\n+        public Label target() {\n+            return target;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBranch(op, target);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+    }\n+\n+    public static final class UnboundRetInstruction\n+            extends UnboundInstruction implements DiscontinuedInstruction.RetInstruction {\n+        final int slot;\n+\n+        public UnboundRetInstruction(Opcode op, int slot) {\n+            super(op);\n+            this.slot = slot;\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return slot;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeLocalVar(op, slot);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(FMT_Discontinued, this.opcode());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":108,"deletions":3,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    private int majorVersion;\n@@ -81,0 +82,8 @@\n+    public int getMajorVersion() {\n+        return majorVersion;\n+    }\n+\n+    public void setMajorVersion(int majorVersion) {\n+        this.majorVersion = majorVersion;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -854,0 +854,4 @@\n+                        case DiscontinuedInstruction.JsrInstruction jsr -> in.with(leaf(\n+                                \"target\", com.labelToBci(jsr.target())));\n+                        case DiscontinuedInstruction.RetInstruction ret ->  in.with(leaf(\n+                                \"slot\", ret.slot()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,1 +245,13 @@\n-        if (a.isEmpty())\n+        if (a.isEmpty()) {\n+            if (classReader.readU2(6) <= Classfile.JAVA_6_VERSION) {\n+                \/\/fallback to jump targets inflation without StackMapTableAttribute\n+                for (int pos=codeStart; pos<codeEnd; ) {\n+                    var i = bcToInstruction(classReader.readU1(pos), pos);\n+                    switch (i) {\n+                        case BranchInstruction br -> br.target();\n+                        case DiscontinuedInstruction.JsrInstruction jsr -> jsr.target();\n+                        default -> {}\n+                    }\n+                    pos += i.sizeInBytes();\n+                }\n+            }\n@@ -247,0 +259,1 @@\n+        }\n@@ -445,1 +458,1 @@\n-                    case RET -> throw new UnsupportedOperationException(\"RET_W instruction not supported\");\n+                    case RET ->  new AbstractInstruction.BoundRetInstruction(Opcode.RET_W, this, pos);\n@@ -455,3 +468,3 @@\n-            case JSR -> throw new UnsupportedOperationException(\"JSR instruction not supported\");\n-            case RET -> throw new UnsupportedOperationException(\"RET instruction not supported\");\n-            case JSR_W -> throw new UnsupportedOperationException(\"JSR_W instruction not supported\");\n+            case JSR -> new AbstractInstruction.BoundJsrInstruction(Opcode.JSR, CodeImpl.this, pos);\n+            case RET ->  new AbstractInstruction.BoundRetInstruction(Opcode.RET, this, pos);\n+            case JSR_W -> new AbstractInstruction.BoundJsrInstruction(Opcode.JSR_W, CodeImpl.this, pos);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+        tail.setMajorVersion(majorVersion);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+import static jdk.internal.classfile.Opcode.JSR;\n+import static jdk.internal.classfile.Opcode.JSR_W;\n@@ -325,1 +327,1 @@\n-                else {\n+                else if (buf.getMajorVersion() >= Classfile.JAVA_7_VERSION) {\n@@ -340,0 +342,5 @@\n+                else {\n+                    maxStack = maxLocals = 255;\n+                    stackMapAttr = null;\n+                }\n+\n@@ -452,11 +459,1 @@\n-    public void writeLoad(Opcode opcode, int localVar) {\n-        writeBytecode(opcode);\n-        switch (opcode.sizeIfFixed()) {\n-            case 1 -> { }\n-            case 2 -> bytecodesBufWriter.writeU1(localVar);\n-            case 4 -> bytecodesBufWriter.writeU2(localVar);\n-            default -> throw new IllegalArgumentException(\"Unexpected instruction size: \" + opcode);\n-        }\n-    }\n-\n-    public void writeStore(Opcode opcode, int localVar) {\n+    public void writeLocalVar(Opcode opcode, int localVar) {\n@@ -497,0 +494,3 @@\n+            } else if (op == JSR) {\n+                writeBytecode(JSR_W);\n+                writeLabelOffset(4, instructionPc, target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -641,0 +641,2 @@\n+            case Classfile.JSR, Classfile.JSR_W, Classfile.RET ->\n+                generatorError(\"Instructions jsr, jsr_w, or ret must not appear in the class file version >= 51.0\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models instruction discontinued from the {@code code} array of a {@code Code}\n+ * attribute. Delivered as a {@link CodeElement} when traversing the elements of\n+ * a {@link CodeModel}.\n+ *\/\n+public sealed interface DiscontinuedInstruction extends Instruction {\n+\n+    \/**\n+     * Models JSR and JSR_W instructions discontinued from the {@code code}\n+     * array of a {@code Code} attribute since class file version 51.0.\n+     * Corresponding opcodes will have a {@code kind} of\n+     * {@link Opcode.Kind#DISCONTINUED_JSR}.  Delivered as a {@link CodeElement}\n+     * when traversing the elements of a {@link CodeModel}.\n+     *\/\n+    sealed interface JsrInstruction extends DiscontinuedInstruction\n+            permits AbstractInstruction.BoundJsrInstruction,\n+                    AbstractInstruction.UnboundJsrInstruction {\n+\n+        \/**\n+         * {@return the target of the JSR instruction}\n+         *\/\n+        Label target();\n+\n+        \/**\n+         * {@return a JSR instruction}\n+         *\n+         * @param op the opcode for the specific type of JSR instruction,\n+         *           which must be of kind {@link Opcode.Kind#DISCONTINUED_JSR}\n+         * @param target target label of the subroutine\n+         *\/\n+        static JsrInstruction of(Opcode op, Label target) {\n+            Util.checkKind(op, Opcode.Kind.DISCONTINUED_JSR);\n+            return new AbstractInstruction.UnboundJsrInstruction(op, target);\n+        }\n+\n+        \/**\n+         * {@return a JSR instruction}\n+         *\n+         * @param target target label of the subroutine\n+         *\/\n+        static JsrInstruction of(Label target) {\n+            return of(Opcode.JSR, target);\n+        }\n+    }\n+\n+    \/**\n+     * Models RET and RET_W instructions discontinued from the {@code code}\n+     * array of a {@code Code} attribute since class file version 51.0.\n+     * Corresponding opcodes will have a {@code kind} of\n+     * {@link Opcode.Kind#DISCONTINUED_RET}.  Delivered as a {@link CodeElement}\n+     * when traversing the elements of a {@link CodeModel}.\n+     *\/\n+    sealed interface RetInstruction extends DiscontinuedInstruction\n+            permits AbstractInstruction.BoundRetInstruction,\n+                    AbstractInstruction.UnboundRetInstruction {\n+\n+        \/**\n+         * {@return the local variable slot with return address}\n+         *\/\n+        int slot();\n+\n+        \/**\n+         * {@return a RET or RET_W instruction}\n+         *\n+         * @param op the opcode for the specific type of RET instruction,\n+         *           which must be of kind {@link Opcode.Kind#DISCONTINUED_RET}\n+         * @param slot the local variable slot to load return address from\n+         *\/\n+        static RetInstruction of(Opcode op, int slot) {\n+            Util.checkKind(op, Opcode.Kind.DISCONTINUED_RET);\n+            return new AbstractInstruction.UnboundRetInstruction(op, slot);\n+        }\n+\n+        \/**\n+         * {@return a RET instruction}\n+         *\n+         * @param slot the local variable slot to load return address from\n+         *\/\n+        static RetInstruction of(int slot) {\n+            return of(slot < 256 ? Opcode.RET : Opcode.RET_W, slot);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/DiscontinuedInstruction.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile handling JSR and RET instructions.\n+ * @run junit DiscontinuedInstructionsTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.instruction.DiscontinuedInstruction;\n+import helpers.ByteArrayClassLoader;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+class DiscontinuedInstructionsTest {\n+\n+    @Test\n+    void testJsrAndRetProcessing() throws Exception {\n+        var testClass = \"JsrAndRetSample\";\n+        var testMethod = \"testMethod\";\n+        var cd_list = ArrayList.class.describeConstable().get();\n+        var bytes = Classfile.build(ClassDesc.of(testClass), clb -> clb\n+                .withVersion(JAVA_5_VERSION, 0)\n+                .withMethodBody(testMethod, MethodTypeDesc.of(CD_void, cd_list), ACC_PUBLIC | ACC_STATIC, cob -> cob\n+                        .block(bb -> {\n+                            bb.constantInstruction(\"Hello\")\n+                              .with(DiscontinuedInstruction.JsrInstruction.of(bb.breakLabel()));\n+                            bb.constantInstruction(\"World\")\n+                              .with(DiscontinuedInstruction.JsrInstruction.of(Opcode.JSR_W, bb.breakLabel()))\n+                              .return_();\n+                        })\n+                        .astore(55)\n+                        .aload(0)\n+                        .swap()\n+                        .invokevirtual(cd_list, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n+                        .pop()\n+                        .with(DiscontinuedInstruction.RetInstruction.of(55))));\n+\n+        var list = new ArrayList<String>();\n+        new ByteArrayClassLoader(DiscontinuedInstructionsTest.class.getClassLoader(), testClass, bytes)\n+                .getMethod(testClass, testMethod)\n+                .invoke(null, list);\n+        assertEquals(list, List.of(\"Hello\", \"World\"));\n+\n+        bytes = Classfile.parse(bytes).transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+\n+        new ByteArrayClassLoader(DiscontinuedInstructionsTest.class.getClassLoader(), testClass, bytes)\n+                .getMethod(testClass, testMethod)\n+                .invoke(null, list);\n+        assertEquals(list, List.of(\"Hello\", \"World\", \"Hello\", \"World\"));\n+\n+        var clm = Classfile.parse(bytes);\n+        var exception = assertThrows(IllegalStateException.class, () ->\n+                clm.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                   .andThen(ClassTransform.endHandler(clb -> clb.withVersion(JAVA_7_VERSION, 0)))));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+ * @bug 8305990\n@@ -33,1 +34,2 @@\n-import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -218,0 +220,14 @@\n+    @Test\n+    void testClassVersions() throws Exception {\n+        var actualVersion = Classfile.parse(StackMapsTest.class.getResourceAsStream(\"\/testdata\/Pattern1.class\").readAllBytes());\n+\n+        \/\/test transformation to class version 49 with removal of StackMapTable attributes\n+        var version49 = Classfile.parse(actualVersion.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.endHandler(clb -> clb.withVersion(49, 0)))));\n+        assertFalse(ClassPrinter.toTree(version49, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES).walk().anyMatch(n -> n.name().equals(\"stack map frames\")));\n+\n+        \/\/test transformation to class version 51 with re-generation of StackMapTable attributes\n+         assertEmpty(Classfile.parse(version49.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.endHandler(clb -> clb.withVersion(51, 0))))).verify(null));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -203,0 +203,4 @@\n+                                                case DiscontinuedInstruction.JsrInstruction i ->\n+                                                    cob.with(DiscontinuedInstruction.JsrInstruction.of(i.opcode(), labels.computeIfAbsent(i.target(), l -> cob.newLabel())));\n+                                                case DiscontinuedInstruction.RetInstruction i ->\n+                                                    cob.with(DiscontinuedInstruction.RetInstruction.of(i.opcode(), i.slot()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}