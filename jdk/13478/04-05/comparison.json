{"files":[{"patch":"@@ -78,1 +78,1 @@\n-    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers = new ArrayList<>();\n+    final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers = new ArrayList<>();\n@@ -83,1 +83,1 @@\n-    private final MethodInfo methodInfo;\n+    final MethodInfo methodInfo;\n@@ -319,1 +319,3 @@\n-                    maxStack = maxLocals = 255;\n+                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n+                    maxStack = cntr.maxStack();\n+                    maxLocals = cntr.maxLocals();\n@@ -330,8 +332,1 @@\n-                    StackMapGenerator gen = new StackMapGenerator(DirectCodeBuilder.this,\n-                                                  buf.thisClass().asSymbol(),\n-                                                  methodInfo.methodName().stringValue(),\n-                                                  MethodTypeDesc.ofDescriptor(methodInfo.methodType().stringValue()),\n-                                                  (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0,\n-                                                  bytecodesBufWriter.asByteBuffer().slice(0, codeLength),\n-                                                  constantPool,\n-                                                  handlers);\n+                    StackMapGenerator gen = StackMapGenerator.of(DirectCodeBuilder.this, buf);\n@@ -343,1 +338,3 @@\n-                    maxStack = maxLocals = 255;\n+                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n+                    maxStack = cntr.maxStack();\n+                    maxLocals = cntr.maxLocals();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.nio.ByteBuffer;\n+import java.util.BitSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.DynamicConstantPoolEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+\n+public final class StackCounter {\n+\n+    static StackCounter of(DirectCodeBuilder dcb, BufWriterImpl buf) {\n+        return new StackCounter(\n+                dcb,\n+                buf.thisClass().asSymbol(),\n+                dcb.methodInfo.methodName().stringValue(),\n+                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                (dcb.methodInfo.methodFlags() & ACC_STATIC) != 0,\n+                dcb.bytecodesBufWriter.asByteBuffer().slice(0, dcb.bytecodesBufWriter.size()),\n+                dcb.constantPool,\n+                dcb.handlers);\n+    }\n+\n+    private int stack, maxStack, maxLocals, rets;\n+\n+    private final RawBytecodeHelper bcs;\n+    private final String methodName;\n+    private final MethodTypeDesc methodDesc;\n+    private final SplitConstantPool cp;\n+    private final LinkedHashMap<Integer, Integer> map;\n+    private final BitSet visited;\n+\n+    private void jump(int targetBci) {\n+        if (!visited.get(targetBci)) {\n+            map.put(targetBci, stack);\n+        }\n+    }\n+\n+    private void stack(int delta) {\n+        stack += delta;\n+        if (stack > maxStack) maxStack = stack;\n+    }\n+\n+    private void local(int index) {\n+        if (index >= maxLocals) maxLocals = index + 1;\n+    }\n+\n+    private boolean next() {\n+        var it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            var en = it.next();\n+            it.remove();\n+            if (!visited.get(en.getKey())) {\n+                bcs.nextBci = en.getKey();\n+                stack = en.getValue();\n+                return true;\n+            }\n+        }\n+        bcs.nextBci = bcs.endBci;\n+        return false;\n+    }\n+\n+    public StackCounter(LabelContext labelContext,\n+                     ClassDesc thisClass,\n+                     String methodName,\n+                     MethodTypeDesc methodDesc,\n+                     boolean isStatic,\n+                     ByteBuffer bytecode,\n+                     SplitConstantPool cp,\n+                     List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {\n+        this.methodName = methodName;\n+        this.methodDesc = methodDesc;\n+        this.cp = cp;\n+        map = new LinkedHashMap<>();\n+        maxStack = stack = rets = 0;\n+        for (var h : handlers) map.put(labelContext.labelToBci(h.handler), 1);\n+        maxLocals = isStatic ? 0 : 1;\n+        for (var cd : methodDesc.parameterList()) {\n+            maxLocals += TypeKind.fromDescriptor(cd.descriptorString()).slotSize();\n+        }\n+        bcs = new RawBytecodeHelper(bytecode);\n+        visited = new BitSet(bcs.endBci);\n+        map.put(0, 0);\n+        while (next()) {\n+            while (!bcs.isLastBytecode()) {\n+                bcs.rawNext();\n+                int opcode = bcs.rawCode;\n+                int bci = bcs.bci;\n+                visited.set(bci);\n+                switch (opcode) {\n+                    case NOP, LALOAD, DALOAD, SWAP, INEG, ARRAYLENGTH, INSTANCEOF, LNEG, FNEG, DNEG, I2F, L2D, F2I, D2L, I2B, I2C, I2S,\n+                         NEWARRAY, CHECKCAST, ANEWARRAY -> {}\n+                    case RETURN ->\n+                        next();\n+                    case ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, SIPUSH, BIPUSH,\n+                         FCONST_0, FCONST_1, FCONST_2, DUP, DUP_X1, DUP_X2, I2L, I2D, F2L, F2D, NEW ->\n+                        stack(+1);\n+                    case LCONST_0, LCONST_1, DCONST_0, DCONST_1, DUP2, DUP2_X1, DUP2_X2 ->\n+                        stack(+2);\n+                    case POP, MONITORENTER, MONITOREXIT, IADD, ISUB, IMUL, IDIV, IREM, ISHL, ISHR, IUSHR, IOR, IXOR, IAND,\n+                         LSHL, LSHR, LUSHR, FADD, FSUB, FMUL, FDIV, FREM, L2I, L2F, D2F, FCMPL, FCMPG, D2I ->\n+                        stack(-1);\n+                    case POP2, LADD, LSUB, LMUL, LDIV, LREM, LAND, LOR, LXOR, DADD, DSUB, DMUL, DDIV, DREM ->\n+                        stack(-2);\n+                    case IASTORE, BASTORE, CASTORE, SASTORE, FASTORE, AASTORE, LCMP, DCMPL, DCMPG ->\n+                        stack(-3);\n+                    case LASTORE, DASTORE ->\n+                        stack(-4);\n+                    case LDC ->\n+                        processLdc(bcs.getIndexU1());\n+                    case LDC_W, LDC2_W ->\n+                        processLdc(bcs.getIndexU2());\n+                    case ILOAD, FLOAD, ALOAD -> {\n+                        local(bcs.getIndex());\n+                        stack(+1);\n+                    }\n+                    case LLOAD, DLOAD -> {\n+                        local(bcs.getIndex() + 1);\n+                        stack(+2);\n+                    }\n+                    case ILOAD_0, FLOAD_0, ALOAD_0 -> {\n+                        local(0);\n+                        stack(+1);\n+                    }\n+                    case ILOAD_1, FLOAD_1, ALOAD_1 -> {\n+                        local(1);\n+                        stack(+1);\n+                    }\n+                    case ILOAD_2, FLOAD_2, ALOAD_2 -> {\n+                        local(2);\n+                        stack(+1);\n+                    }\n+                    case ILOAD_3, FLOAD_3, ALOAD_3 -> {\n+                        local(3);\n+                        stack(+1);\n+                    }\n+                    case LLOAD_0, DLOAD_0 -> {\n+                        local(1);\n+                        stack(+2);\n+                    }\n+                    case LLOAD_1, DLOAD_1 -> {\n+                        local(2);\n+                        stack(+2);\n+                    }\n+                    case LLOAD_2, DLOAD_2 -> {\n+                        local(3);\n+                        stack(+2);\n+                    }\n+                    case LLOAD_3, DLOAD_3 -> {\n+                        local(4);\n+                        stack(+2);\n+                    }\n+                    case IALOAD, BALOAD, CALOAD, SALOAD, FALOAD, AALOAD ->  {\n+                        stack(-1);\n+                    }\n+                    case ISTORE, FSTORE, ASTORE -> {\n+                        local(bcs.getIndex());\n+                        stack(-1);\n+                    }\n+                    case LSTORE, DSTORE -> {\n+                        local(bcs.getIndex() + 1);\n+                        stack(-2);\n+                    }\n+                    case ISTORE_0, FSTORE_0, ASTORE_0 -> {\n+                        local(0);\n+                        stack(-1);\n+                    }\n+                    case ISTORE_1, FSTORE_1, ASTORE_1 -> {\n+                        local(1);\n+                        stack(-1);\n+                    }\n+                    case ISTORE_2, FSTORE_2, ASTORE_2 -> {\n+                        local(2);\n+                        stack(-1);\n+                    }\n+                    case ISTORE_3, FSTORE_3, ASTORE_3 -> {\n+                        local(3);\n+                        stack(-1);\n+                    }\n+                    case LSTORE_0, DSTORE_0 -> {\n+                        local(1);\n+                        stack(-2);\n+                    }\n+                    case LSTORE_1, DSTORE_1 -> {\n+                        local(2);\n+                        stack(-2);\n+                    }\n+                    case LSTORE_2, DSTORE_2 -> {\n+                        local(3);\n+                        stack(-2);\n+                    }\n+                    case LSTORE_3, DSTORE_3 -> {\n+                        local(4);\n+                        stack(-2);\n+                    }\n+                    case IINC ->\n+                        local(bcs.getIndex());\n+                    case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE -> {\n+                        stack(-2);\n+                        jump(bcs.dest());\n+                    }\n+                    case IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IFNULL, IFNONNULL -> {\n+                        stack(-1);\n+                        jump(bcs.dest());\n+                    }\n+                    case GOTO -> {\n+                        jump(bcs.dest());\n+                        next();\n+                    }\n+                    case GOTO_W -> {\n+                        jump(bcs.destW());\n+                        next();\n+                    }\n+                    case TABLESWITCH, LOOKUPSWITCH -> {\n+                        int alignedBci = RawBytecodeHelper.align(bci + 1);\n+                        int defaultOfset = bcs.getInt(alignedBci);\n+                        int keys, delta;\n+                        stack(-1);\n+                        if (bcs.rawCode == TABLESWITCH) {\n+                            int low = bcs.getInt(alignedBci + 4);\n+                            int high = bcs.getInt(alignedBci + 2 * 4);\n+                            if (low > high) {\n+                                error(\"low must be less than or equal to high in tableswitch\");\n+                            }\n+                            keys = high - low + 1;\n+                            if (keys < 0) {\n+                                error(\"too many keys in tableswitch\");\n+                            }\n+                            delta = 1;\n+                        } else {\n+                            keys = bcs.getInt(alignedBci + 4);\n+                            if (keys < 0) {\n+                                error(\"number of keys in lookupswitch less than 0\");\n+                            }\n+                            delta = 2;\n+                            for (int i = 0; i < (keys - 1); i++) {\n+                                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n+                                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                                if (this_key >= next_key) {\n+                                    error(\"Bad lookupswitch instruction\");\n+                                }\n+                            }\n+                        }\n+                        int target = bci + defaultOfset;\n+                        jump(target);\n+                        for (int i = 0; i < keys; i++) {\n+                            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n+                            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+                            jump(target);\n+                        }\n+                        next();\n+                    }\n+                    case LRETURN, DRETURN -> {\n+                        stack(-2);\n+                        next();\n+                    }\n+                    case IRETURN, FRETURN, ARETURN, ATHROW -> {\n+                        stack(-1);\n+                        next();\n+                    }\n+                    case GETSTATIC, PUTSTATIC, GETFIELD, PUTFIELD -> {\n+                        var tk = TypeKind.fromDescriptor(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType().type().stringValue());\n+                        switch (bcs.rawCode) {\n+                            case GETSTATIC ->\n+                                stack(tk.slotSize());\n+                            case PUTSTATIC ->\n+                                stack(-tk.slotSize());\n+                            case GETFIELD ->\n+                                stack(tk.slotSize() - 1);\n+                            case PUTFIELD ->\n+                                stack(-tk.slotSize() - 1);\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                    case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE, INVOKEDYNAMIC -> {\n+                        var cpe = cp.entryByIndex(bcs.getIndexU2());\n+                        var nameAndType = opcode == INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n+                        var mDesc = MethodTypeDesc.ofDescriptor(nameAndType.type().stringValue());\n+                        for (var arg : mDesc.parameterList()) {\n+                            stack(-TypeKind.fromDescriptor(arg.descriptorString()).slotSize());\n+                        }\n+                        if (opcode != INVOKESTATIC && opcode != INVOKEDYNAMIC) {\n+                            stack(-1);\n+                        }\n+                        stack(TypeKind.fromDescriptor(mDesc.returnType().descriptorString()).slotSize());\n+                    }\n+                    case MULTIANEWARRAY ->\n+                        stack (1 - bcs.getU1(bcs.bci + 3));\n+                    case JSR -> {\n+                        stack(+1);\n+                        jump(bcs.dest());\n+                    }\n+                    case JSR_W -> {\n+                        stack(+1);\n+                        jump(bcs.destW());\n+                    }\n+                    case RET -> {\n+                        local(bcs.getIndex());\n+                        rets++;\n+                        next();\n+                    }\n+                    default ->\n+                        error(String.format(\"Bad instruction: %02x\", opcode));\n+                }\n+            }\n+        }\n+        \/\/heuristic calculation of upper bounds of maxStack when subroutines are present\n+        maxStack += rets * maxStack;\n+    }\n+\n+    \/**\n+     * Calculated maximum number of the locals required\n+     * @return maximum number of the locals required\n+     *\/\n+    public int maxLocals() {\n+        return maxLocals;\n+    }\n+\n+    \/**\n+     * Calculated maximum stack size required\n+     * @return maximum stack size required\n+     *\/\n+    public int maxStack() {\n+        return maxStack;\n+    }\n+\n+    private void processLdc(int index) {\n+        switch (cp.entryByIndex(index).tag()) {\n+            case TAG_UTF8, TAG_STRING, TAG_CLASS, TAG_INTEGER, TAG_FLOAT, TAG_METHODHANDLE, TAG_METHODTYPE ->\n+                stack(+1);\n+            case TAG_DOUBLE, TAG_LONG ->\n+                stack(+2);\n+            case TAG_CONSTANTDYNAMIC ->\n+                stack(((ConstantDynamicEntry)cp.entryByIndex(index)).typeKind().slotSize());\n+            default ->\n+                error(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        throw new IllegalArgumentException(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+                msg,\n+                bcs.bci,\n+                methodName,\n+                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -158,0 +158,12 @@\n+    static StackMapGenerator of(DirectCodeBuilder dcb, BufWriterImpl buf) {\n+        return new StackMapGenerator(\n+                dcb,\n+                buf.thisClass().asSymbol(),\n+                dcb.methodInfo.methodName().stringValue(),\n+                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                (dcb.methodInfo.methodFlags() & ACC_STATIC) != 0,\n+                dcb.bytecodesBufWriter.asByteBuffer().slice(0, dcb.bytecodesBufWriter.size()),\n+                dcb.constantPool,\n+                dcb.handlers);\n+    }\n+\n@@ -310,1 +322,1 @@\n-                    bytecode.put((byte) Classfile.NOP);\n+                    bytecode.put((byte) NOP);\n@@ -312,1 +324,1 @@\n-                bytecode.put((byte) Classfile.ATHROW);\n+                bytecode.put((byte) ATHROW);\n@@ -436,2 +448,2 @@\n-            case Classfile.NOP -> {}\n-            case Classfile.RETURN -> {\n+            case NOP -> {}\n+            case RETURN -> {\n@@ -440,1 +452,1 @@\n-            case Classfile.ACONST_NULL ->\n+            case ACONST_NULL ->\n@@ -442,1 +454,1 @@\n-            case Classfile.ICONST_M1, Classfile.ICONST_0, Classfile.ICONST_1, Classfile.ICONST_2, Classfile.ICONST_3, Classfile.ICONST_4, Classfile.ICONST_5, Classfile.SIPUSH, Classfile.BIPUSH ->\n+            case ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, SIPUSH, BIPUSH ->\n@@ -444,1 +456,1 @@\n-            case Classfile.LCONST_0, Classfile.LCONST_1 ->\n+            case LCONST_0, LCONST_1 ->\n@@ -446,1 +458,1 @@\n-            case Classfile.FCONST_0, Classfile.FCONST_1, Classfile.FCONST_2 ->\n+            case FCONST_0, FCONST_1, FCONST_2 ->\n@@ -448,1 +460,1 @@\n-            case Classfile.DCONST_0, Classfile.DCONST_1 ->\n+            case DCONST_0, DCONST_1 ->\n@@ -450,1 +462,1 @@\n-            case Classfile.LDC ->\n+            case LDC ->\n@@ -452,1 +464,1 @@\n-            case Classfile.LDC_W, Classfile.LDC2_W ->\n+            case LDC_W, LDC2_W ->\n@@ -454,1 +466,1 @@\n-            case Classfile.ILOAD ->\n+            case ILOAD ->\n@@ -456,3 +468,3 @@\n-            case Classfile.ILOAD_0, Classfile.ILOAD_1, Classfile.ILOAD_2, Classfile.ILOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.ILOAD_0).pushStack(Type.INTEGER_TYPE);\n-            case Classfile.LLOAD ->\n+            case ILOAD_0, ILOAD_1, ILOAD_2, ILOAD_3 ->\n+                currentFrame.checkLocal(opcode - ILOAD_0).pushStack(Type.INTEGER_TYPE);\n+            case LLOAD ->\n@@ -460,3 +472,3 @@\n-            case Classfile.LLOAD_0, Classfile.LLOAD_1, Classfile.LLOAD_2, Classfile.LLOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.LLOAD_0 + 1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-            case Classfile.FLOAD ->\n+            case LLOAD_0, LLOAD_1, LLOAD_2, LLOAD_3 ->\n+                currentFrame.checkLocal(opcode - LLOAD_0 + 1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case FLOAD ->\n@@ -464,3 +476,3 @@\n-            case Classfile.FLOAD_0, Classfile.FLOAD_1, Classfile.FLOAD_2, Classfile.FLOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.FLOAD_0).pushStack(Type.FLOAT_TYPE);\n-            case Classfile.DLOAD ->\n+            case FLOAD_0, FLOAD_1, FLOAD_2, FLOAD_3 ->\n+                currentFrame.checkLocal(opcode - FLOAD_0).pushStack(Type.FLOAT_TYPE);\n+            case DLOAD ->\n@@ -468,3 +480,3 @@\n-            case Classfile.DLOAD_0, Classfile.DLOAD_1, Classfile.DLOAD_2, Classfile.DLOAD_3 ->\n-                currentFrame.checkLocal(opcode - Classfile.DLOAD_0 + 1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-            case Classfile.ALOAD ->\n+            case DLOAD_0, DLOAD_1, DLOAD_2, DLOAD_3 ->\n+                currentFrame.checkLocal(opcode - DLOAD_0 + 1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case ALOAD ->\n@@ -472,3 +484,3 @@\n-            case Classfile.ALOAD_0, Classfile.ALOAD_1, Classfile.ALOAD_2, Classfile.ALOAD_3 ->\n-                currentFrame.pushStack(currentFrame.getLocal(opcode - Classfile.ALOAD_0));\n-            case Classfile.IALOAD, Classfile.BALOAD, Classfile.CALOAD, Classfile.SALOAD ->\n+            case ALOAD_0, ALOAD_1, ALOAD_2, ALOAD_3 ->\n+                currentFrame.pushStack(currentFrame.getLocal(opcode - ALOAD_0));\n+            case IALOAD, BALOAD, CALOAD, SALOAD ->\n@@ -476,1 +488,1 @@\n-            case Classfile.LALOAD ->\n+            case LALOAD ->\n@@ -478,1 +490,1 @@\n-            case Classfile.FALOAD ->\n+            case FALOAD ->\n@@ -480,1 +492,1 @@\n-            case Classfile.DALOAD ->\n+            case DALOAD ->\n@@ -482,1 +494,1 @@\n-            case Classfile.AALOAD ->\n+            case AALOAD ->\n@@ -484,1 +496,1 @@\n-            case Classfile.ISTORE ->\n+            case ISTORE ->\n@@ -486,3 +498,3 @@\n-            case Classfile.ISTORE_0, Classfile.ISTORE_1, Classfile.ISTORE_2, Classfile.ISTORE_3 ->\n-                currentFrame.decStack(1).setLocal(opcode - Classfile.ISTORE_0, Type.INTEGER_TYPE);\n-            case Classfile.LSTORE ->\n+            case ISTORE_0, ISTORE_1, ISTORE_2, ISTORE_3 ->\n+                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+            case LSTORE ->\n@@ -490,3 +502,3 @@\n-            case Classfile.LSTORE_0, Classfile.LSTORE_1, Classfile.LSTORE_2, Classfile.LSTORE_3 ->\n-                currentFrame.decStack(2).setLocal2(opcode - Classfile.LSTORE_0, Type.LONG_TYPE, Type.LONG2_TYPE);\n-            case Classfile.FSTORE ->\n+            case LSTORE_0, LSTORE_1, LSTORE_2, LSTORE_3 ->\n+                currentFrame.decStack(2).setLocal2(opcode - LSTORE_0, Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case FSTORE ->\n@@ -494,3 +506,3 @@\n-            case Classfile.FSTORE_0, Classfile.FSTORE_1, Classfile.FSTORE_2, Classfile.FSTORE_3 ->\n-                currentFrame.decStack(1).setLocal(opcode - Classfile.FSTORE_0, Type.FLOAT_TYPE);\n-            case Classfile.DSTORE ->\n+            case FSTORE_0, FSTORE_1, FSTORE_2, FSTORE_3 ->\n+                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+            case DSTORE ->\n@@ -498,3 +510,3 @@\n-            case Classfile.DSTORE_0, Classfile.DSTORE_1, Classfile.DSTORE_2, Classfile.DSTORE_3 ->\n-                currentFrame.decStack(2).setLocal2(opcode - Classfile.DSTORE_0, Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-            case Classfile.ASTORE ->\n+            case DSTORE_0, DSTORE_1, DSTORE_2, DSTORE_3 ->\n+                currentFrame.decStack(2).setLocal2(opcode - DSTORE_0, Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case ASTORE ->\n@@ -502,3 +514,3 @@\n-            case Classfile.ASTORE_0, Classfile.ASTORE_1, Classfile.ASTORE_2, Classfile.ASTORE_3 ->\n-                currentFrame.setLocal(opcode - Classfile.ASTORE_0, currentFrame.popStack());\n-            case Classfile.LASTORE, Classfile.DASTORE ->\n+            case ASTORE_0, ASTORE_1, ASTORE_2, ASTORE_3 ->\n+                currentFrame.setLocal(opcode - ASTORE_0, currentFrame.popStack());\n+            case LASTORE, DASTORE ->\n@@ -506,1 +518,1 @@\n-            case Classfile.IASTORE, Classfile.BASTORE, Classfile.CASTORE, Classfile.SASTORE, Classfile.FASTORE, Classfile.AASTORE ->\n+            case IASTORE, BASTORE, CASTORE, SASTORE, FASTORE, AASTORE ->\n@@ -508,1 +520,1 @@\n-            case Classfile.POP, Classfile.MONITORENTER, Classfile.MONITOREXIT ->\n+            case POP, MONITORENTER, MONITOREXIT ->\n@@ -510,1 +522,1 @@\n-            case Classfile.POP2 ->\n+            case POP2 ->\n@@ -512,1 +524,1 @@\n-            case Classfile.DUP ->\n+            case DUP ->\n@@ -514,1 +526,1 @@\n-            case Classfile.DUP_X1 -> {\n+            case DUP_X1 -> {\n@@ -519,1 +531,1 @@\n-            case Classfile.DUP_X2 -> {\n+            case DUP_X2 -> {\n@@ -525,1 +537,1 @@\n-            case Classfile.DUP2 -> {\n+            case DUP2 -> {\n@@ -530,1 +542,1 @@\n-            case Classfile.DUP2_X1 -> {\n+            case DUP2_X1 -> {\n@@ -536,1 +548,1 @@\n-            case Classfile.DUP2_X2 -> {\n+            case DUP2_X2 -> {\n@@ -543,1 +555,1 @@\n-            case Classfile.SWAP -> {\n+            case SWAP -> {\n@@ -549,1 +561,1 @@\n-            case Classfile.IADD, Classfile.ISUB, Classfile.IMUL, Classfile.IDIV, Classfile.IREM, Classfile.ISHL, Classfile.ISHR, Classfile.IUSHR, Classfile.IOR, Classfile.IXOR, Classfile.IAND ->\n+            case IADD, ISUB, IMUL, IDIV, IREM, ISHL, ISHR, IUSHR, IOR, IXOR, IAND ->\n@@ -551,1 +563,1 @@\n-            case Classfile.INEG, Classfile.ARRAYLENGTH, Classfile.INSTANCEOF ->\n+            case INEG, ARRAYLENGTH, INSTANCEOF ->\n@@ -553,1 +565,1 @@\n-            case Classfile.LADD, Classfile.LSUB, Classfile.LMUL, Classfile.LDIV, Classfile.LREM, Classfile.LAND, Classfile.LOR, Classfile.LXOR ->\n+            case LADD, LSUB, LMUL, LDIV, LREM, LAND, LOR, LXOR ->\n@@ -555,1 +567,1 @@\n-            case Classfile.LNEG ->\n+            case LNEG ->\n@@ -557,1 +569,1 @@\n-            case Classfile.LSHL, Classfile.LSHR, Classfile.LUSHR ->\n+            case LSHL, LSHR, LUSHR ->\n@@ -559,1 +571,1 @@\n-            case Classfile.FADD, Classfile.FSUB, Classfile.FMUL, Classfile.FDIV, Classfile.FREM ->\n+            case FADD, FSUB, FMUL, FDIV, FREM ->\n@@ -561,1 +573,1 @@\n-            case Classfile.FNEG ->\n+            case FNEG ->\n@@ -563,1 +575,1 @@\n-            case Classfile.DADD, Classfile.DSUB, Classfile.DMUL, Classfile.DDIV, Classfile.DREM ->\n+            case DADD, DSUB, DMUL, DDIV, DREM ->\n@@ -565,1 +577,1 @@\n-            case Classfile.DNEG ->\n+            case DNEG ->\n@@ -567,1 +579,1 @@\n-            case Classfile.IINC ->\n+            case IINC ->\n@@ -569,1 +581,1 @@\n-            case Classfile.I2L ->\n+            case I2L ->\n@@ -571,1 +583,1 @@\n-            case Classfile.L2I ->\n+            case L2I ->\n@@ -573,1 +585,1 @@\n-            case Classfile.I2F ->\n+            case I2F ->\n@@ -575,1 +587,1 @@\n-            case Classfile.I2D ->\n+            case I2D ->\n@@ -577,1 +589,1 @@\n-            case Classfile.L2F ->\n+            case L2F ->\n@@ -579,1 +591,1 @@\n-            case Classfile.L2D ->\n+            case L2D ->\n@@ -581,1 +593,1 @@\n-            case Classfile.F2I ->\n+            case F2I ->\n@@ -583,1 +595,1 @@\n-            case Classfile.F2L ->\n+            case F2L ->\n@@ -585,1 +597,1 @@\n-            case Classfile.F2D ->\n+            case F2D ->\n@@ -587,1 +599,1 @@\n-            case Classfile.D2L ->\n+            case D2L ->\n@@ -589,1 +601,1 @@\n-            case Classfile.D2F ->\n+            case D2F ->\n@@ -591,1 +603,1 @@\n-            case Classfile.I2B, Classfile.I2C, Classfile.I2S ->\n+            case I2B, I2C, I2S ->\n@@ -593,1 +605,1 @@\n-            case Classfile.LCMP, Classfile.DCMPL, Classfile.DCMPG ->\n+            case LCMP, DCMPL, DCMPG ->\n@@ -595,1 +607,1 @@\n-            case Classfile.FCMPL, Classfile.FCMPG, Classfile.D2I ->\n+            case FCMPL, FCMPG, D2I ->\n@@ -597,1 +609,1 @@\n-            case Classfile.IF_ICMPEQ, Classfile.IF_ICMPNE, Classfile.IF_ICMPLT, Classfile.IF_ICMPGE, Classfile.IF_ICMPGT, Classfile.IF_ICMPLE, Classfile.IF_ACMPEQ, Classfile.IF_ACMPNE ->\n+            case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE ->\n@@ -599,1 +611,1 @@\n-            case Classfile.IFEQ, Classfile.IFNE, Classfile.IFLT, Classfile.IFGE, Classfile.IFGT, Classfile.IFLE, Classfile.IFNULL, Classfile.IFNONNULL ->\n+            case IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IFNULL, IFNONNULL ->\n@@ -601,1 +613,1 @@\n-            case Classfile.GOTO -> {\n+            case GOTO -> {\n@@ -605,1 +617,1 @@\n-            case Classfile.GOTO_W -> {\n+            case GOTO_W -> {\n@@ -609,1 +621,1 @@\n-            case Classfile.TABLESWITCH, Classfile.LOOKUPSWITCH -> {\n+            case TABLESWITCH, LOOKUPSWITCH -> {\n@@ -613,1 +625,1 @@\n-            case Classfile.LRETURN, Classfile.DRETURN -> {\n+            case LRETURN, DRETURN -> {\n@@ -617,1 +629,1 @@\n-            case Classfile.IRETURN, Classfile.FRETURN, Classfile.ARETURN, Classfile.ATHROW -> {\n+            case IRETURN, FRETURN, ARETURN, ATHROW -> {\n@@ -621,1 +633,1 @@\n-            case Classfile.GETSTATIC, Classfile.PUTSTATIC, Classfile.GETFIELD, Classfile.PUTFIELD ->\n+            case GETSTATIC, PUTSTATIC, GETFIELD, PUTFIELD ->\n@@ -623,1 +635,1 @@\n-            case Classfile.INVOKEVIRTUAL, Classfile.INVOKESPECIAL, Classfile.INVOKESTATIC, Classfile.INVOKEINTERFACE, Classfile.INVOKEDYNAMIC ->\n+            case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE, INVOKEDYNAMIC ->\n@@ -625,1 +637,1 @@\n-            case Classfile.NEW ->\n+            case NEW ->\n@@ -627,1 +639,1 @@\n-            case Classfile.NEWARRAY ->\n+            case NEWARRAY ->\n@@ -629,1 +641,1 @@\n-            case Classfile.ANEWARRAY ->\n+            case ANEWARRAY ->\n@@ -631,1 +643,1 @@\n-            case Classfile.CHECKCAST ->\n+            case CHECKCAST ->\n@@ -633,1 +645,1 @@\n-            case Classfile.MULTIANEWARRAY -> {\n+            case MULTIANEWARRAY -> {\n@@ -641,1 +653,1 @@\n-            case Classfile.JSR, Classfile.JSR_W, Classfile.RET ->\n+            case JSR, JSR_W, RET ->\n@@ -699,1 +711,1 @@\n-        if (bcs.rawCode == Classfile.TABLESWITCH) {\n+        if (bcs.rawCode == TABLESWITCH) {\n@@ -736,1 +748,1 @@\n-            case Classfile.GETSTATIC ->\n+            case GETSTATIC ->\n@@ -738,1 +750,1 @@\n-            case Classfile.PUTSTATIC -> {\n+            case PUTSTATIC -> {\n@@ -742,1 +754,1 @@\n-            case Classfile.GETFIELD -> {\n+            case GETFIELD -> {\n@@ -746,1 +758,1 @@\n-            case Classfile.PUTFIELD -> {\n+            case PUTFIELD -> {\n@@ -759,1 +771,1 @@\n-        var nameAndType = opcode == Classfile.INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n+        var nameAndType = opcode == INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n@@ -791,1 +803,1 @@\n-        if (opcode != Classfile.INVOKESTATIC && opcode != Classfile.INVOKEDYNAMIC) {\n+        if (opcode != INVOKESTATIC && opcode != INVOKEDYNAMIC) {\n@@ -904,1 +916,1 @@\n-                case Classfile.GOTO -> {\n+                case GOTO -> {\n@@ -908,1 +920,1 @@\n-                case Classfile.GOTO_W -> {\n+                case GOTO_W -> {\n@@ -912,4 +924,4 @@\n-                case Classfile.IF_ICMPEQ, Classfile.IF_ICMPNE, Classfile.IF_ICMPLT, Classfile.IF_ICMPGE,\n-                     Classfile.IF_ICMPGT, Classfile.IF_ICMPLE, Classfile.IFEQ, Classfile.IFNE,\n-                     Classfile.IFLT, Classfile.IFGE, Classfile.IFGT, Classfile.IFLE, Classfile.IF_ACMPEQ,\n-                     Classfile.IF_ACMPNE , Classfile.IFNULL , Classfile.IFNONNULL -> {\n+                case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE,\n+                     IF_ICMPGT, IF_ICMPLE, IFEQ, IFNE,\n+                     IFLT, IFGE, IFGT, IFLE, IF_ACMPEQ,\n+                     IF_ACMPNE , IFNULL , IFNONNULL -> {\n@@ -919,1 +931,1 @@\n-                case Classfile.TABLESWITCH, Classfile.LOOKUPSWITCH -> {\n+                case TABLESWITCH, LOOKUPSWITCH -> {\n@@ -923,1 +935,1 @@\n-                            if (bcs.rawCode == Classfile.TABLESWITCH) {\n+                            if (bcs.rawCode == TABLESWITCH) {\n@@ -938,2 +950,2 @@\n-                case Classfile.IRETURN, Classfile.LRETURN, Classfile.FRETURN, Classfile.DRETURN,\n-                     Classfile.ARETURN, Classfile.RETURN, Classfile.ATHROW -> true;\n+                case IRETURN, LRETURN, FRETURN, DRETURN,\n+                     ARETURN, RETURN, ATHROW -> true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":125,"deletions":113,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import jdk.internal.classfile.CodeTransform;\n@@ -206,1 +207,1 @@\n-        var newModel = Classfile.parse(newBytes);\n+        var newModel = Classfile.parse(newBytes, Classfile.Option.generateStackmap(false));\n@@ -212,0 +213,17 @@\n+\n+        \/\/testing maxStack and maxLocals are calculated identically by StackMapGenerator and StackCounter\n+        byte[] noStackMaps = newModel.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+        var noStackModel = Classfile.parse(noStackMaps);\n+        var itStack = newModel.methods().iterator();\n+        var itNoStack = noStackModel.methods().iterator();\n+        while (itStack.hasNext()) {\n+            assertTrue(itNoStack.hasNext());\n+            var m1 = itStack.next();\n+            var m2 = itNoStack.next();\n+            var text1 = m1.methodName().stringValue() + m1.methodType().stringValue() + \": \"\n+                      + m1.code().map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n+            var text2 = m2.methodName().stringValue() + m2.methodType().stringValue() + \": \"\n+                      + m2.code().map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n+            assertEquals(text1, text2);\n+        }\n+        assertFalse(itNoStack.hasNext());\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                        .astore(55)\n+                        .astore(355)\n@@ -65,1 +65,6 @@\n-                        .with(DiscontinuedInstruction.RetInstruction.of(55))));\n+                        .with(DiscontinuedInstruction.RetInstruction.of(355))));\n+\n+        var c = Classfile.parse(bytes).methods().get(0).code().get();\n+        assertEquals(356, c.maxLocals());\n+        assertEquals(8, c.maxStack());\n+\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}