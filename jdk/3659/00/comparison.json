{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#include \"oops\/instanceMirrorKlass.hpp\"\n@@ -252,12 +253,0 @@\n-C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))\n-  requireInHotSpot(\"getObjectAtAddress\", JVMCI_CHECK_NULL);\n-  if (oop_address == 0) {\n-    JVMCI_THROW_MSG_NULL(InternalError, \"Handle must be non-zero\");\n-  }\n-  oop obj = *((oopDesc**) oop_address);\n-  if (obj != NULL) {\n-    oopDesc::verify(obj);\n-  }\n-  return JNIHandles::make_local(THREAD, obj);\n-C2V_END\n-\n@@ -643,0 +632,1 @@\n+      JVMCIObject kind;\n@@ -646,17 +636,9 @@\n-        case T_BOOLEAN: raw_value = value.z; break;\n-        case T_BYTE:    raw_value = value.b; break;\n-        case T_SHORT:   raw_value = value.s; break;\n-        case T_CHAR:    raw_value = value.c; break;\n-        case T_INT:     raw_value = value.i; break;\n-        case T_LONG:    raw_value = value.j; break;\n-        case T_FLOAT: {\n-          JVMCIObject result = JVMCIENV->call_JavaConstant_forFloat(value.f, JVMCI_CHECK_NULL);\n-          return JVMCIENV->get_jobject(result);\n-        }\n-        case T_DOUBLE: {\n-          JVMCIObject result = JVMCIENV->call_JavaConstant_forDouble(value.d, JVMCI_CHECK_NULL);\n-          return JVMCIENV->get_jobject(result);\n-        }\n-        default: {\n-          return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_ILLEGAL());\n-        }\n+        case T_LONG:    kind = JVMCIENV->get_JavaKind_Long();    raw_value = value.j; break;\n+        case T_DOUBLE:  kind = JVMCIENV->get_JavaKind_Double();  raw_value = value.j; break;\n+        case T_FLOAT:   kind = JVMCIENV->get_JavaKind_Float();   raw_value = value.i; break;\n+        case T_INT:     kind = JVMCIENV->get_JavaKind_Int();     raw_value = value.i; break;\n+        case T_SHORT:   kind = JVMCIENV->get_JavaKind_Short();   raw_value = value.s; break;\n+        case T_BYTE:    kind = JVMCIENV->get_JavaKind_Byte();    raw_value = value.b; break;\n+        case T_CHAR:    kind = JVMCIENV->get_JavaKind_Char();    raw_value = value.c; break;\n+        case T_BOOLEAN: kind = JVMCIENV->get_JavaKind_Boolean(); raw_value = value.z; break;\n+        default:        return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_ILLEGAL());\n@@ -665,1 +647,1 @@\n-      JVMCIObject result = JVMCIENV->call_PrimitiveConstant_forTypeChar(type2char(bt2), raw_value, JVMCI_CHECK_NULL);\n+      JVMCIObject result = JVMCIENV->call_JavaConstant_forPrimitive(kind, raw_value, JVMCI_CHECK_NULL);\n@@ -1194,5 +1176,0 @@\n-C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))\n-  oop ret = RawAccess<>::oop_load((oop*)(address)addr);\n-  return JVMCIENV->get_jobject(JVMCIENV->get_object_constant(ret));\n- C2V_END\n-\n@@ -1952,2 +1929,2 @@\n-C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))\n-  if (object == NULL || field == NULL) {\n+C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject expected_type, long displacement, jboolean is_volatile, jobject kind_object))\n+  if (object == NULL || kind_object == NULL) {\n@@ -1956,18 +1933,7 @@\n-  JVMCIObject field_object = JVMCIENV->wrap(field);\n-  JVMCIObject java_type = JVMCIENV->get_HotSpotResolvedJavaFieldImpl_type(field_object);\n-  int modifiers = JVMCIENV->get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);\n-  Klass* holder = JVMCIENV->asKlass(JVMCIENV->get_HotSpotResolvedJavaFieldImpl_holder(field_object));\n-  if (!holder->is_instance_klass()) {\n-    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Holder %s must be instance klass\", holder->external_name()));\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(holder);\n-  BasicType constant_type;\n-  if (JVMCIENV->isa_HotSpotResolvedPrimitiveType(java_type)) {\n-    constant_type = JVMCIENV->kindToBasicType(JVMCIENV->get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);\n-  } else {\n-    constant_type = T_OBJECT;\n-  }\n-  int displacement = JVMCIENV->get_HotSpotResolvedJavaFieldImpl_offset(field_object);\n-  fieldDescriptor fd;\n-  if (!ik->find_local_field_from_offset(displacement, (modifiers & JVM_ACC_STATIC) != 0, &fd)) {\n-    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Can't find field with displacement %d\", displacement));\n+\n+  JVMCIObject kind = JVMCIENV->wrap(kind_object);\n+  BasicType basic_type = JVMCIENV->kindToBasicType(kind, JVMCI_CHECK_NULL);\n+\n+  InstanceKlass* holder = NULL;\n+  if (expected_type != NULL) {\n+    holder = InstanceKlass::cast(JVMCIENV->asKlass(JVMCIENV->wrap(expected_type)));\n@@ -1975,1 +1941,2 @@\n-  JVMCIObject base = JVMCIENV->wrap(object);\n+\n+  bool is_static = false;\n@@ -1977,0 +1944,1 @@\n+  JVMCIObject base = JVMCIENV->wrap(object);\n@@ -1979,0 +1947,10 @@\n+    \/\/ asConstant will throw an NPE if a constant contains NULL\n+\n+    if (holder != NULL && !obj->is_a(holder)) {\n+      \/\/ Not a subtype of field holder\n+      return NULL;\n+    }\n+    is_static = false;\n+    if (holder == NULL && java_lang_Class::is_instance(obj()) && displacement >= InstanceMirrorKlass::offset_of_static_fields()) {\n+      is_static = true;\n+    }\n@@ -1980,0 +1958,1 @@\n+    is_static = true;\n@@ -1981,0 +1960,3 @@\n+    if (holder != NULL && holder != klass) {\n+      return NULL;\n+    }\n@@ -1983,2 +1965,2 @@\n-    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-                         err_msg(\"Unexpected type: %s\", JVMCIENV->klass_name(base)));\n+    \/\/ The Java code is expected to guard against this path\n+    ShouldNotReachHere();\n@@ -1987,5 +1969,41 @@\n-  if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(obj()) &&\n-      !java_lang_Class::as_Klass(obj())->is_array_klass()) {\n-    \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n-    \/\/ used for locking so always return null to mimic Class.getComponentType()\n-    return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+  if (displacement < 0 || ((long) displacement + type2aelembytes(basic_type) > HeapWordSize * obj->size())) {\n+    \/\/ Reading outside of the object bounds\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"reading outside object bounds\");\n+  }\n+\n+  \/\/ Perform basic sanity checks on the read.  Primitive reads are permitted to read outside the\n+  \/\/ bounds of their fields but object reads must map exactly onto the underlying oop slot.\n+  if (basic_type == T_OBJECT) {\n+    if (obj->is_objArray()) {\n+      if (displacement < arrayOopDesc::base_offset_in_bytes(T_OBJECT)) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"reading from array header\");\n+      }\n+      if (displacement + heapOopSize > arrayOopDesc::base_offset_in_bytes(T_OBJECT) + arrayOop(obj())->length() * heapOopSize) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"reading after last array element\");\n+      }\n+      if (((displacement - arrayOopDesc::base_offset_in_bytes(T_OBJECT)) % heapOopSize) != 0) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"misaligned object read from array\");\n+      }\n+    } else if (obj->is_instance()) {\n+      InstanceKlass* klass = InstanceKlass::cast(is_static ? java_lang_Class::as_Klass(obj()) : obj->klass());\n+      fieldDescriptor fd;\n+      if (!klass->find_field_from_offset(displacement, is_static, &fd)) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(\"Can't find field at displacement %d in object of type %s\", (int) displacement, klass->external_name()));\n+      }\n+      if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(\"Field at displacement %d in object of type %s is %s but expected %s\", (int) displacement,\n+                                                               klass->external_name(), type2name(fd.field_type()), type2name(basic_type)));\n+      }\n+    } else if (obj->is_typeArray()) {\n+      JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"Can't read objects from primitive array\");\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else {\n+    if (obj->is_objArray()) {\n+      JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"Reading primitive from object array\");\n+    } else if (obj->is_typeArray()) {\n+      if (displacement < arrayOopDesc::base_offset_in_bytes(ArrayKlass::cast(obj->klass())->element_type())) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"reading from array header\");\n+      }\n+    }\n@@ -1995,2 +2013,10 @@\n-  JVMCIObject kind;\n-  switch (constant_type) {\n+  switch (basic_type) {\n+    case T_BOOLEAN: value = is_volatile ? obj->bool_field_acquire(displacement)   : obj->bool_field(displacement);  break;\n+    case T_BYTE:    value = is_volatile ? obj->byte_field_acquire(displacement)   : obj->byte_field(displacement);  break;\n+    case T_SHORT:   value = is_volatile ? obj->short_field_acquire(displacement)  : obj->short_field(displacement); break;\n+    case T_CHAR:    value = is_volatile ? obj->char_field_acquire(displacement)   : obj->char_field(displacement);  break;\n+    case T_FLOAT:\n+    case T_INT:     value = is_volatile ? obj->int_field_acquire(displacement)    : obj->int_field(displacement);   break;\n+    case T_DOUBLE:\n+    case T_LONG:    value = is_volatile ? obj->long_field_acquire(displacement)   : obj->long_field(displacement);  break;\n+\n@@ -1998,3 +2024,4 @@\n-      oop object = is_volatile ? obj->obj_field_acquire(displacement) : obj->obj_field(displacement);\n-      JVMCIObject result = JVMCIENV->get_object_constant(object);\n-      if (result.is_null()) {\n+      if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(obj()) &&\n+          (java_lang_Class::as_Klass(obj()) == NULL || !java_lang_Class::as_Klass(obj())->is_array_klass())) {\n+        \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n+        \/\/ used for locking so always return null to mimic Class.getComponentType()\n@@ -2003,11 +2030,17 @@\n-      return JVMCIENV->get_jobject(result);\n-    }\n-    case T_FLOAT: {\n-      float f = is_volatile ? obj->float_field_acquire(displacement) : obj->float_field(displacement);\n-      JVMCIObject result = JVMCIENV->call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);\n-      return JVMCIENV->get_jobject(result);\n-    }\n-    case T_DOUBLE: {\n-      double f = is_volatile ? obj->double_field_acquire(displacement) : obj->double_field(displacement);\n-      JVMCIObject result = JVMCIENV->call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);\n-      return JVMCIENV->get_jobject(result);\n+\n+      oop value = is_volatile ? obj->obj_field_acquire(displacement) : obj->obj_field(displacement);\n+      if (value == NULL) {\n+        return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+      } else {\n+        if (value != NULL && !oopDesc::is_oop(value)) {\n+          \/\/ Throw an exception to improve debuggability.  This check isn't totally reliable because\n+          \/\/ is_oop doesn't try to be completety safe but for most invalid values it provides a good\n+          \/\/ enough answer.  It possible to crash in the is_oop call but that just means the crash happens\n+          \/\/ closer to where things went wrong.\n+          JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Read bad oop \" INTPTR_FORMAT \" at offset \" JLONG_FORMAT \" in object \" INTPTR_FORMAT \" of type %s\",\n+                                                      p2i(value), displacement, p2i(obj()), obj->klass()->external_name()));\n+        }\n+\n+        JVMCIObject result = JVMCIENV->get_object_constant(value);\n+        return JVMCIENV->get_jobject(result);\n+      }\n@@ -2015,6 +2048,1 @@\n-    case T_BOOLEAN: value = is_volatile ? obj->bool_field_acquire(displacement) : obj->bool_field(displacement); break;\n-    case T_BYTE: value = is_volatile ? obj->byte_field_acquire(displacement) : obj->byte_field(displacement); break;\n-    case T_SHORT: value = is_volatile ? obj->short_field_acquire(displacement) : obj->short_field(displacement); break;\n-    case T_CHAR: value = is_volatile ? obj->char_field_acquire(displacement) : obj->char_field(displacement); break;\n-    case T_INT: value = is_volatile ? obj->int_field_acquire(displacement) : obj->int_field(displacement); break;\n-    case T_LONG: value = is_volatile ? obj->long_field_acquire(displacement) : obj->long_field(displacement); break;\n+\n@@ -2024,1 +2052,1 @@\n-  JVMCIObject result = JVMCIENV->call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);\n+  JVMCIObject result = JVMCIENV->call_JavaConstant_forPrimitive(kind, value, JVMCI_CHECK_NULL);\n@@ -2182,49 +2210,0 @@\n-C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))\n-  if (x == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  Handle xobj = JVMCIENV->asConstant(JVMCIENV->wrap(x), JVMCI_CHECK_0);\n-  return xobj->byte_field(displacement);\n-}\n-\n-C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))\n-  if (x == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  Handle xobj = JVMCIENV->asConstant(JVMCIENV->wrap(x), JVMCI_CHECK_0);\n-  return xobj->short_field(displacement);\n-}\n-\n-C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))\n-  if (x == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  Handle xobj = JVMCIENV->asConstant(JVMCIENV->wrap(x), JVMCI_CHECK_0);\n-  return xobj->int_field(displacement);\n-}\n-\n-C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))\n-  if (x == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  Handle xobj = JVMCIENV->asConstant(JVMCIENV->wrap(x), JVMCI_CHECK_0);\n-  return xobj->long_field(displacement);\n-}\n-\n-C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))\n-  if (x == NULL) {\n-    JVMCI_THROW_0(NullPointerException);\n-  }\n-  Handle xobj = JVMCIENV->asConstant(JVMCIENV->wrap(x), JVMCI_CHECK_0);\n-  if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(xobj()) &&\n-      !java_lang_Class::as_Klass(xobj())->is_array_klass()) {\n-    \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n-    \/\/ used for locking so always return null to mimic Class.getComponentType()\n-    return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n-  }\n-\n-  oop res = xobj->obj_field(displacement);\n-  JVMCIObject result = JVMCIENV->get_object_constant(res);\n-  return JVMCIENV->get_jobject(result);\n-}\n-\n@@ -2771,1 +2750,0 @@\n-  {CC \"readUncompressedOop\",                          CC \"(J)\" OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},\n@@ -2790,1 +2768,0 @@\n-  {CC \"getObjectAtAddress\",                           CC \"(J)\" OBJECT,                                                                      FN_PTR(getObjectAtAddress)},\n@@ -2801,2 +2778,2 @@\n-  {CC \"readFieldValue\",                               CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_FIELD \"Z)\" JAVACONSTANT,                         FN_PTR(readFieldValue)},\n-  {CC \"readFieldValue\",                               CC \"(\" OBJECTCONSTANT HS_RESOLVED_FIELD \"Z)\" JAVACONSTANT,                            FN_PTR(readFieldValue)},\n+  {CC \"readFieldValue\",                               CC \"(\" HS_RESOLVED_KLASS HS_RESOLVED_KLASS \"JZLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT, FN_PTR(readFieldValue)},\n+  {CC \"readFieldValue\",                               CC \"(\" OBJECTCONSTANT HS_RESOLVED_KLASS \"JZLjdk\/vm\/ci\/meta\/JavaKind;)\" JAVACONSTANT,  FN_PTR(readFieldValue)},\n@@ -2814,5 +2791,0 @@\n-  {CC \"getByte\",                                      CC \"(\" OBJECTCONSTANT \"J)B\",                                                          FN_PTR(getByte)},\n-  {CC \"getShort\",                                     CC \"(\" OBJECTCONSTANT \"J)S\",                                                          FN_PTR(getShort)},\n-  {CC \"getInt\",                                       CC \"(\" OBJECTCONSTANT \"J)I\",                                                          FN_PTR(getInt)},\n-  {CC \"getLong\",                                      CC \"(\" OBJECTCONSTANT \"J)J\",                                                          FN_PTR(getLong)},\n-  {CC \"getObject\",                                    CC \"(\" OBJECTCONSTANT \"J)\" OBJECTCONSTANT,                                            FN_PTR(getObject)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":116,"deletions":144,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {\n+JVMCIObject JVMCIEnv::call_JavaConstant_forPrimitive(JVMCIObject kind, jlong value, JVMCI_TRAPS) {\n@@ -808,1 +808,1 @@\n-    jargs.push_int(kind);\n+    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(kind)));\n@@ -811,46 +811,0 @@\n-    JavaCalls::call_static(&result,\n-                           HotSpotJVMCI::PrimitiveConstant::klass(),\n-                           vmSymbols::forTypeChar_name(),\n-                           vmSymbols::forTypeChar_signature(), &jargs, CHECK_(JVMCIObject()));\n-    return wrap(result.get_oop());\n-  } else {\n-    JNIAccessMark jni(this, THREAD);\n-    jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),\n-                                                     JNIJVMCI::PrimitiveConstant::forTypeChar_method(),\n-                                                     kind, value);\n-    if (jni()->ExceptionCheck()) {\n-      return JVMCIObject();\n-    }\n-    return wrap(result);\n-  }\n-}\n-\n-JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {\n-  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current());\n-  if (is_hotspot()) {\n-    JavaCallArguments jargs;\n-    jargs.push_float(value);\n-    JavaValue result(T_OBJECT);\n-    JavaCalls::call_static(&result,\n-                           HotSpotJVMCI::JavaConstant::klass(),\n-                           vmSymbols::forFloat_name(),\n-                           vmSymbols::forFloat_signature(), &jargs, CHECK_(JVMCIObject()));\n-    return wrap(result.get_oop());\n-  } else {\n-    JNIAccessMark jni(this, THREAD);\n-    jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),\n-                                                     JNIJVMCI::JavaConstant::forFloat_method(),\n-                                                     value);\n-    if (jni()->ExceptionCheck()) {\n-      return JVMCIObject();\n-    }\n-    return wrap(result);\n-  }\n-}\n-\n-JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {\n-  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current());\n-  if (is_hotspot()) {\n-    JavaCallArguments jargs;\n-    jargs.push_double(value);\n-    JavaValue result(T_OBJECT);\n@@ -859,2 +813,2 @@\n-                           vmSymbols::forDouble_name(),\n-                           vmSymbols::forDouble_signature(), &jargs, CHECK_(JVMCIObject()));\n+                           vmSymbols::forPrimitive_name(),\n+                           vmSymbols::forPrimitive_signature(), &jargs, CHECK_(JVMCIObject()));\n@@ -865,2 +819,2 @@\n-                                                     JNIJVMCI::JavaConstant::forDouble_method(),\n-                                                     value);\n+                                                             JNIJVMCI::JavaConstant::forPrimitive_method(),\n+                                                             kind.as_jobject(), value);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":6,"deletions":52,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -310,3 +310,1 @@\n-  JVMCIObject call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS);\n-  JVMCIObject call_JavaConstant_forFloat(float value, JVMCI_TRAPS);\n-  JVMCIObject call_JavaConstant_forDouble(double value, JVMCI_TRAPS);\n+  JVMCIObject call_JavaConstant_forPrimitive(JVMCIObject kind, jlong value, JVMCI_TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,2 +250,1 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forFloat, forFloat_signature, (JVMCIObject kind, jlong value, JVMCI_TRAPS)) \\\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forDouble, forDouble_signature, (JVMCIObject kind, jlong value, JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, JavaConstant, forPrimitive, forPrimitive_signature, (JVMCIObject kind, jlong value, JVMCI_TRAPS)) \\\n@@ -258,1 +257,0 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, PrimitiveConstant, forTypeChar, forTypeChar_signature, (JVMCIObject kind, jlong value, JVMCI_TRAPS)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,6 +128,2 @@\n-  template(forTypeChar_name,                                      \"forTypeChar\")                                                          \\\n-  template(forTypeChar_signature,                                 \"(CJ)Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")                               \\\n-  template(forFloat_name,                                         \"forFloat\")                                                             \\\n-  template(forFloat_signature,                                    \"(F)Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")                                \\\n-  template(forDouble_name,                                        \"forDouble\")                                                            \\\n-  template(forDouble_signature,                                   \"(D)Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")                                \\\n+  template(forPrimitive_name,                                     \"forPrimitive\")                                                         \\\n+  template(forPrimitive_signature,                                \"(Ljdk\/vm\/ci\/meta\/JavaKind;J)Ljdk\/vm\/ci\/meta\/PrimitiveConstant;\")       \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -515,13 +515,0 @@\n-    \/**\n-     * Reads an object pointer within a VM data structure. That is, any {@link VMField} whose\n-     * {@link VMField#type type} is {@code \"oop\"} (e.g., {@code Klass::_java_mirror},\n-     * {@code JavaThread::_threadObj}).\n-     *\n-     * Note that {@code Unsafe.getObject(Object, long)} cannot be used for this since it does a\n-     * {@code narrowOop} read if the VM is using compressed oops whereas oops within VM data\n-     * structures are (currently) always uncompressed.\n-     *\n-     * @param address address of an oop field within a VM data structure\n-     *\/\n-    native HotSpotObjectConstantImpl readUncompressedOop(long address);\n-\n@@ -743,7 +730,0 @@\n-    \/**\n-     * Gets the object at the address {@code oopAddress}.\n-     *\n-     * @param oopAddress a valid {@code oopDesc**} value\n-     *\/\n-    native Object getObjectAtAddress(long oopAddress);\n-\n@@ -809,1 +789,3 @@\n-     * Reads the current value of a static field.\n+     * Reads the current value of a static field. If {@code expectedType} is non-null, then the\n+     * object is exptected to be a subtype of {@code expectedType} and extra sanity checking is\n+     * performed on the offset and kind of the read being performed.\n@@ -811,1 +793,1 @@\n-    native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl resolvedObjectType, HotSpotResolvedJavaField field, boolean isVolatile);\n+    native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, boolean isVolatile, JavaKind kind);\n@@ -814,1 +796,3 @@\n-     * Reads the current value of an instance field.\n+     * Reads the current value of an instance field. If {@code expectedType} is non-null, then the\n+     * object is exptected to be a subtype of {@code expectedType} and extra sanity checking is\n+     * performed on the offset and kind of the read being performed.\n@@ -816,1 +800,1 @@\n-    native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile);\n+    native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedObjectTypeImpl expectedType, long offset, boolean isVolatile, JavaKind kind);\n@@ -860,25 +844,0 @@\n-    \/**\n-     * Reads a byte sized value from {@code displacement} in {@code object}.\n-     *\/\n-    native byte getByte(HotSpotObjectConstantImpl object, long displacement);\n-\n-    \/**\n-     * Reads a short sized value from {@code displacement} in {@code object}.\n-     *\/\n-    native short getShort(HotSpotObjectConstantImpl object, long displacement);\n-\n-    \/**\n-     * Reads an int sized value from {@code displacement} in {@code object}.\n-     *\/\n-    native int getInt(HotSpotObjectConstantImpl object, long displacement);\n-\n-    \/**\n-     * Reads a long sized value from {@code displacement} in {@code object}.\n-     *\/\n-    native long getLong(HotSpotObjectConstantImpl object, long displacement);\n-\n-    \/**\n-     * Reads a Java object from {@code displacement} in {@code object}.\n-     *\/\n-    native HotSpotObjectConstantImpl getObject(HotSpotObjectConstantImpl object, long displacement);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n+\n@@ -167,8 +169,2 @@\n-                return holder.readFieldValue(hotspotField, field.isVolatile());\n-            }\n-        } else {\n-            if (receiver.isNonNull() && receiver instanceof HotSpotObjectConstantImpl) {\n-                HotSpotObjectConstantImpl object = ((HotSpotObjectConstantImpl) receiver);\n-                if (hotspotField.isInObject(receiver)) {\n-                    return object.readFieldValue(hotspotField, field.isVolatile());\n-                }\n+                return runtime().compilerToVm.readFieldValue(holder, (HotSpotResolvedObjectTypeImpl) hotspotField.getDeclaringClass(), hotspotField.getOffset(), field.isVolatile(),\n+                                hotspotField.getType().getJavaKind());\n@@ -176,0 +172,4 @@\n+        } else if (receiver instanceof HotSpotObjectConstantImpl) {\n+            return ((HotSpotObjectConstantImpl) receiver).readFieldValue(hotspotField, field.isVolatile());\n+        } else if (receiver == null) {\n+            throw new NullPointerException(\"receiver is null\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotConstantReflectionProvider.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -40,2 +39,0 @@\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaField;\n@@ -109,12 +106,0 @@\n-    @Override\n-    JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedJavaField field, boolean isVolatile) {\n-        Class<?> javaMirror = getMirror(holder);\n-        return readFieldValue(field, javaMirror, isVolatile);\n-    }\n-\n-    @Override\n-    JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile) {\n-        Object value = resolveObject(object);\n-        return readFieldValue(field, value, isVolatile);\n-    }\n-\n@@ -126,4 +111,2 @@\n-    @Override\n-    JavaConstant getJavaMirror(HotSpotResolvedPrimitiveType holder) {\n-        return holder.mirror;\n-    }\n+    \/\/ This field is being kept around for compatibility with libgraal\n+    @SuppressWarnings(\"unused\") private long oopSizeOffset;\n@@ -299,146 +282,0 @@\n-    @Override\n-    int getInt(HotSpotObjectConstantImpl object, long displacement) {\n-        return UNSAFE.getInt((resolveObject(object)), displacement);\n-    }\n-\n-    @Override\n-    byte getByte(HotSpotObjectConstantImpl object, long displacement) {\n-        return UNSAFE.getByte(resolveObject(object), displacement);\n-    }\n-\n-    @Override\n-    short getShort(HotSpotObjectConstantImpl object, long displacement) {\n-        return UNSAFE.getShort(resolveObject(object), displacement);\n-    }\n-\n-    @Override\n-    long getLong(HotSpotObjectConstantImpl object, long displacement) {\n-        return UNSAFE.getLong(resolveObject(object), displacement);\n-    }\n-\n-    @Override\n-    void checkRead(HotSpotObjectConstantImpl constant, JavaKind kind, long displacement, HotSpotResolvedObjectType type) {\n-        checkRead(kind, displacement, type, resolveObject(constant));\n-    }\n-\n-    \/**\n-     * Offset of injected {@code java.lang.Class::oop_size} field. No need to make {@code volatile}\n-     * as initialization is idempotent.\n-     *\/\n-    private long oopSizeOffset;\n-\n-    private static int computeOopSizeOffset(HotSpotJVMCIRuntime runtime) {\n-        MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();\n-        ResolvedJavaType staticType = metaAccess.lookupJavaType(Class.class);\n-        for (ResolvedJavaField f : staticType.getInstanceFields(false)) {\n-            if (f.getName().equals(\"oop_size\")) {\n-                int offset = f.getOffset();\n-                assert offset != 0 : \"not expecting offset of java.lang.Class::oop_size to be 0\";\n-                return offset;\n-            }\n-        }\n-        throw new JVMCIError(\"Could not find injected java.lang.Class::oop_size field\");\n-    }\n-\n-    long oopSizeOffset() {\n-        if (oopSizeOffset == 0) {\n-            oopSizeOffset = computeOopSizeOffset(runtime());\n-        }\n-        return oopSizeOffset;\n-    }\n-\n-    private boolean checkRead(JavaKind kind, long displacement, HotSpotResolvedObjectType type, Object object) {\n-        if (type.isArray()) {\n-            ResolvedJavaType componentType = type.getComponentType();\n-            JavaKind componentKind = componentType.getJavaKind();\n-            final int headerSize = runtime().getArrayBaseOffset(componentKind);\n-            int sizeOfElement = runtime().getArrayIndexScale(componentKind);\n-            int length = Array.getLength(object);\n-            long arrayEnd = headerSize + (sizeOfElement * length);\n-            boolean aligned = ((displacement - headerSize) % sizeOfElement) == 0;\n-            if (displacement < 0 || displacement > (arrayEnd - sizeOfElement) || (kind == JavaKind.Object && !aligned)) {\n-                int index = (int) ((displacement - headerSize) \/ sizeOfElement);\n-                throw new IllegalArgumentException(\"Unsafe array access: reading element of kind \" + kind +\n-                                \" at offset \" + displacement + \" (index ~ \" + index + \") in \" +\n-                                type.toJavaName() + \" object of length \" + length);\n-            }\n-        } else if (kind != JavaKind.Object) {\n-            long size;\n-            if (object instanceof Class) {\n-                int wordSize = runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordSize;\n-                size = UNSAFE.getInt(object, oopSizeOffset()) * wordSize;\n-            } else {\n-                size = Math.abs(type.instanceSize());\n-            }\n-            int bytesToRead = kind.getByteCount();\n-            if (displacement + bytesToRead > size || displacement < 0) {\n-                throw new IllegalArgumentException(\"Unsafe access: reading \" + bytesToRead + \" bytes at offset \" + displacement + \" in \" +\n-                                type.toJavaName() + \" object of size \" + size);\n-            }\n-        } else {\n-            ResolvedJavaField field = null;\n-            if (object instanceof Class) {\n-                \/\/ Read of a static field\n-                HotSpotResolvedJavaType hotSpotResolvedJavaType = runtime().fromClass((Class<?>) object);\n-                if (hotSpotResolvedJavaType instanceof HotSpotResolvedObjectTypeImpl) {\n-                    HotSpotResolvedObjectTypeImpl staticFieldsHolder = (HotSpotResolvedObjectTypeImpl) hotSpotResolvedJavaType;\n-                    field = staticFieldsHolder.findStaticFieldWithOffset(displacement, JavaKind.Object);\n-                }\n-            }\n-            if (field == null) {\n-                field = type.findInstanceFieldWithOffset(displacement, JavaKind.Object);\n-            }\n-            if (field == null) {\n-                throw new IllegalArgumentException(\"Unsafe object access: field not found for read of kind Object\" +\n-                                \" at offset \" + displacement + \" in \" + type.toJavaName() + \" object\");\n-            }\n-            if (field.getJavaKind() != JavaKind.Object) {\n-                throw new IllegalArgumentException(\"Unsafe object access: field \" + field.format(\"%H.%n:%T\") + \" not of expected kind Object\" +\n-                                \" at offset \" + displacement + \" in \" + type.toJavaName() + \" object\");\n-            }\n-        }\n-        return true;\n-    }\n-\n-    JavaConstant readFieldValue(HotSpotResolvedJavaField field, Object obj, boolean isVolatile) {\n-        assert obj != null;\n-        assert !field.isStatic() || obj instanceof Class;\n-        long displacement = field.getOffset();\n-        if (obj instanceof Class && field.getName().equals(\"componentType\")) {\n-            Class<?> clazz = (Class<?>) obj;\n-            if (!clazz.isArray()) {\n-                \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n-                \/\/ used for locking so always return null to mimic Class.getComponentType()\n-                return JavaConstant.NULL_POINTER;\n-            }\n-        }\n-\n-        assert checkRead(field.getJavaKind(), displacement,\n-                        (HotSpotResolvedObjectType) runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaType(field.isStatic() ? (Class<?>) obj : obj.getClass()),\n-                        obj);\n-        JavaKind kind = field.getJavaKind();\n-        switch (kind) {\n-            case Boolean:\n-                return JavaConstant.forBoolean(isVolatile ? UNSAFE.getBooleanVolatile(obj, displacement) : UNSAFE.getBoolean(obj, displacement));\n-            case Byte:\n-                return JavaConstant.forByte(isVolatile ? UNSAFE.getByteVolatile(obj, displacement) : UNSAFE.getByte(obj, displacement));\n-            case Char:\n-                return JavaConstant.forChar(isVolatile ? UNSAFE.getCharVolatile(obj, displacement) : UNSAFE.getChar(obj, displacement));\n-            case Short:\n-                return JavaConstant.forShort(isVolatile ? UNSAFE.getShortVolatile(obj, displacement) : UNSAFE.getShort(obj, displacement));\n-            case Int:\n-                return JavaConstant.forInt(isVolatile ? UNSAFE.getIntVolatile(obj, displacement) : UNSAFE.getInt(obj, displacement));\n-            case Long:\n-                return JavaConstant.forLong(isVolatile ? UNSAFE.getLongVolatile(obj, displacement) : UNSAFE.getLong(obj, displacement));\n-            case Float:\n-                return JavaConstant.forFloat(isVolatile ? UNSAFE.getFloatVolatile(obj, displacement) : UNSAFE.getFloat(obj, displacement));\n-            case Double:\n-                return JavaConstant.forDouble(isVolatile ? UNSAFE.getDoubleVolatile(obj, displacement) : UNSAFE.getDouble(obj, displacement));\n-            case Object:\n-                return forObject(isVolatile ? UNSAFE.getReferenceVolatile(obj, displacement) : UNSAFE.getReference(obj, displacement));\n-            default:\n-                throw new IllegalArgumentException(\"Unsupported kind: \" + kind);\n-\n-        }\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJDKReflection.java","additions":2,"deletions":165,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.vm.ci.meta.JavaKind;\n@@ -34,1 +33,1 @@\n- * Reflection interface for reflecting on the internals of HotSpot JVMCI types and objects.\n+ * API for reflecting on the internals of HotSpot JVMCI types and objects.\n@@ -54,4 +53,0 @@\n-    abstract JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedJavaField field, boolean isVolatile);\n-\n-    abstract JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile);\n-\n@@ -60,2 +55,0 @@\n-    abstract JavaConstant getJavaMirror(HotSpotResolvedPrimitiveType hotSpotResolvedJavaType);\n-\n@@ -103,10 +96,0 @@\n-    abstract int getInt(HotSpotObjectConstantImpl object, long displacement);\n-\n-    abstract byte getByte(HotSpotObjectConstantImpl object, long displacement);\n-\n-    abstract short getShort(HotSpotObjectConstantImpl object, long displacement);\n-\n-    abstract long getLong(HotSpotObjectConstantImpl object, long displacement);\n-\n-    abstract void checkRead(HotSpotObjectConstantImpl constant, JavaKind kind, long displacement, HotSpotResolvedObjectType type);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIReflection.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,33 +45,0 @@\n-    \/**\n-     * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read\n-     * from it at the offset {@code displacement}.\n-     *\n-     * @param base constant value containing the base address for a pending read\n-     * @return {@code null} if {@code base} does not box an object otherwise the object boxed in\n-     *         {@code base}\n-     *\/\n-    private static HotSpotObjectConstantImpl asObject(Constant base, JavaKind kind, long displacement) {\n-        if (base instanceof HotSpotObjectConstantImpl) {\n-            HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;\n-            HotSpotResolvedObjectType type = constant.getType();\n-            runtime().reflection.checkRead(constant, kind, displacement, type);\n-            return constant;\n-        }\n-        return null;\n-    }\n-\n-    private boolean isValidObjectFieldDisplacement(Constant base, long displacement) {\n-        if (base instanceof HotSpotMetaspaceConstant) {\n-            MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);\n-            if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {\n-                if (displacement == runtime.getConfig().javaMirrorOffset) {\n-                    \/\/ Klass::_java_mirror is valid for all Klass* values\n-                    return true;\n-                }\n-            } else {\n-                throw new IllegalArgumentException(String.valueOf(metaspaceObject));\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -91,14 +58,25 @@\n-    private static long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {\n-        HotSpotObjectConstantImpl base = asObject(baseConstant, kind, displacement);\n-        if (base != null) {\n-            switch (bits) {\n-                case Byte.SIZE:\n-                    return runtime().reflection.getByte(base, displacement);\n-                case Short.SIZE:\n-                    return runtime().reflection.getShort(base, displacement);\n-                case Integer.SIZE:\n-                    return runtime().reflection.getInt(base, displacement);\n-                case Long.SIZE:\n-                    return runtime().reflection.getLong(base, displacement);\n-                default:\n-                    throw new IllegalArgumentException(String.valueOf(bits));\n+    @Override\n+    public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {\n+        if (baseConstant instanceof HotSpotObjectConstantImpl) {\n+            JavaKind readKind = kind;\n+            if (kind.getBitCount() != bits) {\n+                switch (bits) {\n+                    case Byte.SIZE:\n+                        readKind = JavaKind.Byte;\n+                        break;\n+                    case Short.SIZE:\n+                        readKind = JavaKind.Short;\n+                        break;\n+                    case Integer.SIZE:\n+                        readKind = JavaKind.Int;\n+                        break;\n+                    case Long.SIZE:\n+                        readKind = JavaKind.Long;\n+                        break;\n+                    default:\n+                        throw new IllegalArgumentException(String.valueOf(bits));\n+                }\n+            }\n+            JavaConstant result = runtime().compilerToVm.readFieldValue((HotSpotObjectConstantImpl) baseConstant, null, initialDisplacement, true, readKind);\n+            if (result != null && kind != readKind) {\n+                return JavaConstant.forPrimitive(kind, result.asLong());\n@@ -106,0 +84,1 @@\n+            return result;\n@@ -108,0 +87,1 @@\n+            long value;\n@@ -110,1 +90,2 @@\n-                    return UNSAFE.getByte(pointer + displacement);\n+                    value = UNSAFE.getByte(pointer + initialDisplacement);\n+                    break;\n@@ -112,1 +93,2 @@\n-                    return UNSAFE.getShort(pointer + displacement);\n+                    value = UNSAFE.getShort(pointer + initialDisplacement);\n+                    break;\n@@ -114,1 +96,2 @@\n-                    return UNSAFE.getInt(pointer + displacement);\n+                    value = UNSAFE.getInt(pointer + initialDisplacement);\n+                    break;\n@@ -116,1 +99,2 @@\n-                    return UNSAFE.getLong(pointer + displacement);\n+                    value = UNSAFE.getLong(pointer + initialDisplacement);\n+                    break;\n@@ -120,0 +104,1 @@\n+            return JavaConstant.forPrimitive(kind, value);\n@@ -123,1 +108,5 @@\n-    private boolean verifyReadRawObject(JavaConstant expected, Constant base, long displacement) {\n+    @Override\n+    public JavaConstant readObjectConstant(Constant base, long displacement) {\n+        if (base instanceof HotSpotObjectConstantImpl) {\n+            return runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, true, JavaKind.Object);\n+        }\n@@ -127,0 +116,1 @@\n+                HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) metaspaceObject;\n@@ -128,2 +118,2 @@\n-                    HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) metaspaceObject;\n-                    assert expected.equals(type.getJavaMirror());\n+                    \/\/ Klass::_java_mirror is valid for all Klass* values\n+                    return type.getJavaMirror();\n@@ -131,0 +121,3 @@\n+                return null;\n+            } else {\n+                throw new IllegalArgumentException(String.valueOf(metaspaceObject));\n@@ -133,46 +126,1 @@\n-        return true;\n-    }\n-\n-    private JavaConstant readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {\n-        long displacement = initialDisplacement;\n-        JavaConstant ret;\n-        HotSpotObjectConstantImpl base = asObject(baseConstant, JavaKind.Object, displacement);\n-        if (base == null) {\n-            assert !compressed;\n-            displacement += asRawPointer(baseConstant);\n-            ret = runtime.getCompilerToVM().readUncompressedOop(displacement);\n-            assert verifyReadRawObject(ret, baseConstant, initialDisplacement);\n-        } else {\n-            assert runtime.getConfig().useCompressedOops == compressed;\n-            ret = runtime.getCompilerToVM().getObject(base, displacement);\n-        }\n-        return ret == null ? JavaConstant.NULL_POINTER : ret;\n-    }\n-\n-    @Override\n-    public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {\n-        try {\n-            long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);\n-            switch (kind) {\n-                case Boolean:\n-                    return JavaConstant.forBoolean(rawValue != 0);\n-                case Byte:\n-                    return JavaConstant.forByte((byte) rawValue);\n-                case Char:\n-                    return JavaConstant.forChar((char) rawValue);\n-                case Short:\n-                    return JavaConstant.forShort((short) rawValue);\n-                case Int:\n-                    return JavaConstant.forInt((int) rawValue);\n-                case Long:\n-                    return JavaConstant.forLong(rawValue);\n-                case Float:\n-                    return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));\n-                case Double:\n-                    return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported kind: \" + kind);\n-            }\n-        } catch (NullPointerException e) {\n-            return null;\n-        }\n+        return null;\n@@ -182,1 +130,1 @@\n-    public JavaConstant readObjectConstant(Constant base, long displacement) {\n+    public JavaConstant readNarrowOopConstant(Constant base, long displacement) {\n@@ -184,9 +132,5 @@\n-            return readRawObject(base, displacement, runtime.getConfig().useCompressedOops);\n-        }\n-        if (!isValidObjectFieldDisplacement(base, displacement)) {\n-            return null;\n-        }\n-        if (base instanceof HotSpotMetaspaceConstant &&\n-            displacement == runtime.getConfig().javaMirrorOffset) {\n-            MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);\n-            return ((HotSpotResolvedObjectTypeImpl) metaspaceObject).getJavaMirror();\n+            assert runtime.getConfig().useCompressedOops;\n+            JavaConstant res = runtime.getCompilerToVM().readFieldValue((HotSpotObjectConstantImpl) base, null, displacement, true, JavaKind.Object);\n+            if (res != null) {\n+                return JavaConstant.NULL_POINTER.equals(res) ? HotSpotCompressedNullConstant.COMPRESSED_NULL : ((HotSpotObjectConstant) res).compress();\n+            }\n@@ -194,7 +138,1 @@\n-        return readRawObject(base, displacement, false);\n-    }\n-\n-    @Override\n-    public JavaConstant readNarrowOopConstant(Constant base, long displacement) {\n-        JavaConstant res = readRawObject(base, displacement, true);\n-        return JavaConstant.NULL_POINTER.equals(res) ? HotSpotCompressedNullConstant.COMPRESSED_NULL : ((HotSpotObjectConstant) res).compress();\n+        return null;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMemoryAccessProviderImpl.java","additions":55,"deletions":117,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;\n@@ -187,1 +188,9 @@\n-        return runtime().reflection.readFieldValue(this, field, isVolatile);\n+        if (IS_IN_NATIVE_IMAGE && this instanceof DirectHotSpotObjectConstantImpl) {\n+            \/\/ cannot read fields from objects due to lack of\n+            \/\/ general reflection support in native image\n+            return null;\n+        }\n+        if (field.isStatic()) {\n+            return null;\n+        }\n+        return runtime().compilerToVm.readFieldValue(this, (HotSpotResolvedObjectTypeImpl) field.getDeclaringClass(), field.getOffset(), isVolatile, field.getType().getJavaKind());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1039,4 +1039,0 @@\n-    JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {\n-        return runtime().reflection.readFieldValue(this, field, isVolatile);\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;\n@@ -323,1 +322,1 @@\n-        return runtime().reflection.getJavaMirror(this);\n+        return mirror;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.vm.ci.meta.JavaKind;\n@@ -75,23 +74,0 @@\n-    @Override\n-    JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedJavaField field, boolean isVolatile) {\n-        JavaConstant javaConstant = runtime().compilerToVm.readFieldValue(holder, field, isVolatile);\n-        if (javaConstant == null) {\n-            return JavaConstant.NULL_POINTER;\n-        }\n-        return javaConstant;\n-    }\n-\n-    @Override\n-    JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile) {\n-        if (object instanceof DirectHotSpotObjectConstantImpl) {\n-            \/\/ cannot read fields from objects due to lack of\n-            \/\/ general reflection support in native image\n-            return null;\n-        }\n-        JavaConstant javaConstant = runtime().compilerToVm.readFieldValue(object, field, isVolatile);\n-        if (javaConstant == null) {\n-            return JavaConstant.NULL_POINTER;\n-        }\n-        return javaConstant;\n-    }\n-\n@@ -120,5 +96,0 @@\n-    @Override\n-    JavaConstant getJavaMirror(HotSpotResolvedPrimitiveType hotSpotResolvedPrimitiveType) {\n-        return runtime().compilerToVm.getJavaMirror(hotSpotResolvedPrimitiveType);\n-    }\n-\n@@ -345,25 +316,0 @@\n-\n-    @Override\n-    int getInt(HotSpotObjectConstantImpl object, long displacement) {\n-        return runtime().compilerToVm.getInt(object, displacement);\n-    }\n-\n-    @Override\n-    byte getByte(HotSpotObjectConstantImpl object, long displacement) {\n-        return runtime().compilerToVm.getByte(object, displacement);\n-    }\n-\n-    @Override\n-    short getShort(HotSpotObjectConstantImpl object, long displacement) {\n-        return runtime().compilerToVm.getShort(object, displacement);\n-    }\n-\n-    @Override\n-    long getLong(HotSpotObjectConstantImpl object, long displacement) {\n-        return runtime().compilerToVm.getLong(object, displacement);\n-    }\n-\n-    @Override\n-    void checkRead(HotSpotObjectConstantImpl constant, JavaKind kind, long displacement, HotSpotResolvedObjectType type) {\n-\n-    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/SharedLibraryJVMCIReflection.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -304,0 +304,23 @@\n+    static PrimitiveConstant forPrimitive(JavaKind kind, long rawValue) {\n+        switch (kind) {\n+            case Boolean:\n+                return JavaConstant.forBoolean(rawValue != 0);\n+            case Byte:\n+                return JavaConstant.forByte((byte) rawValue);\n+            case Char:\n+                return JavaConstant.forChar((char) rawValue);\n+            case Short:\n+                return JavaConstant.forShort((short) rawValue);\n+            case Int:\n+                return JavaConstant.forInt((int) rawValue);\n+            case Long:\n+                return JavaConstant.forLong(rawValue);\n+            case Float:\n+                return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));\n+            case Double:\n+                return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported kind: \" + kind);\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/JavaConstant.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-    private static KindData[] PRIMITIVE_KIND_DATA = {\n+\n+    private static final KindData[] PRIMITIVE_KIND_DATA = {\n@@ -111,0 +112,22 @@\n+    @DataProvider(name = \"outOfBoundsObjectArray\")\n+    public static Object[][] getOutOfBoundsObjectArrayReads() {\n+        List<Object[]> result = new ArrayList<>();\n+\n+        for (int i = 0; i < 8; i++) {\n+            Object[] objects = new Object[i];\n+            for (int e = 0; e < i; e++) {\n+                objects[e] = e;\n+            }\n+            long firstValidOffset = UNSAFE.ARRAY_OBJECT_BASE_OFFSET;\n+            long endOfObjectOffset = UNSAFE.ARRAY_OBJECT_BASE_OFFSET + i * UNSAFE.ARRAY_OBJECT_INDEX_SCALE;\n+            JavaConstant constant = CONSTANT_REFLECTION.forObject(objects);\n+            result.add(new Object[] {JavaKind.Object, constant, firstValidOffset, i == 0});\n+            result.add(new Object[] {JavaKind.Object, constant, (long) 0, true});\n+            result.add(new Object[] {JavaKind.Object, constant, (long) -1, true});\n+            result.add(new Object[] {JavaKind.Object, constant, endOfObjectOffset - UNSAFE.ARRAY_OBJECT_INDEX_SCALE, i == 0});\n+            result.add(new Object[] {JavaKind.Object, constant, endOfObjectOffset, true});\n+            result.add(new Object[] {JavaKind.Object, constant, endOfObjectOffset + 100, true});\n+        }\n+        return result.toArray(new Object[result.size()][]);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderData.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            Assert.assertTrue(isOutOfBounds);\n+            Assert.assertTrue(isOutOfBounds, iae.getMessage());\n@@ -88,1 +88,11 @@\n-            Assert.assertTrue(isOutOfBounds);\n+            Assert.assertTrue(isOutOfBounds, iae.getMessage());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"outOfBoundsObjectArray\", dataProviderClass = MemoryAccessProviderData.class)\n+    public void testReadObjectOutOfBoundsObjectArray(JavaKind kind, Constant base, Long offset, boolean isOutOfBounds) {\n+        try {\n+            PROVIDER.readObjectConstant(base, offset);\n+            Assert.assertFalse(isOutOfBounds);\n+        } catch (IllegalArgumentException iae) {\n+            Assert.assertTrue(isOutOfBounds, iae.getMessage());\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderTest.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}