{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.net.SocketAddress;\n@@ -357,0 +358,34 @@\n+        \/**\n+         * Binds the socket to this local address when creating\n+         * connections for sending requests.\n+         *\n+         * <p> If no local address is set or {@code null} is passed\n+         * to this method then sockets created by the\n+         * HTTP client will be bound to an automatically\n+         * assigned socket address.\n+         *\n+         * <p> Common usages of the {@code HTTPClient} do not require\n+         * this method to be called. Setting a local address, through this\n+         * method, is only for advanced usages where users of the {@code HTTPClient}\n+         * require specific control on which network interface gets used\n+         * for the HTTP communication. Callers of this method are expected to\n+         * be aware of the networking configurations of the system where the\n+         * {@code HTTPClient} will be used and care should be taken to ensure the\n+         * correct {@code localAddr} is passed. Failure to do so can result in\n+         * requests sent through the {@code HTTPClient} to fail.\n+         *\n+         * @implSpec The default implementation of this method throws\n+         * {@code UnsupportedOperationException}. {@code Builder}s obtained\n+         * through {@link HttpClient#newBuilder()} provide an implementation\n+         * of this method that allows setting the local address.\n+         *\n+         * @param localAddr The local socket address. Can be null.\n+         * @return this builder\n+         * @throws UnsupportedOperationException if this builder doesn't support\n+         *         configuring a local address\n+         * @since 19\n+         *\/\n+        default Builder localAddress(SocketAddress localAddr) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n@@ -361,0 +396,5 @@\n+         * @implSpec If the {@link #localAddress(SocketAddress) local address} is a non-null\n+         * <i>Internet Protocol<\/i> socket address and a security manager is installed, then\n+         * this method calls {@link SecurityManager#checkListen checkListen} to check that\n+         * the caller has necessary permission to bind to that local address.\n+         *\n@@ -367,0 +407,5 @@\n+         * @throws SecurityException If a security manager has been installed and\n+         *         the {@link #localAddress(SocketAddress) local address} is an\n+         *         <i>Internet Protocol<\/i> socket address\n+         *         and the security manager's {@link SecurityManager#checkListen checkListen}\n+         *         method disallows binding to the given socket address.\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.net.SocketAddress;\n@@ -52,0 +53,1 @@\n+    SocketAddress localAddr;\n@@ -133,0 +135,6 @@\n+    @Override\n+    public HttpClient.Builder localAddress(final SocketAddress localAddr) {\n+        this.localAddr = localAddr;\n+        return this;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientBuilderImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.net.InetSocketAddress;\n@@ -40,0 +41,1 @@\n+import java.net.SocketAddress;\n@@ -191,0 +193,1 @@\n+    private final SocketAddress localAddr;\n@@ -279,0 +282,8 @@\n+        if (builder.localAddr instanceof InetSocketAddress isa) {\n+            @SuppressWarnings(\"removal\")\n+            var sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkListen(isa.getPort());\n+            }\n+        }\n+        localAddr = builder.localAddr;\n@@ -1184,0 +1195,4 @@\n+    SocketAddress localAddress() {\n+        return localAddr;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -182,0 +182,20 @@\n+            var localAddr = client().localAddress();\n+            if (localAddr != null) {\n+                if (debug.on()) {\n+                    debug.log(\"binding to configured local address \" + localAddr);\n+                }\n+                PrivilegedExceptionAction<SocketChannel> pa = () -> chan.bind(localAddr);\n+                try {\n+                    AccessController.doPrivileged(pa);\n+                    if (debug.on()) {\n+                        debug.log(\"bind completed \" + localAddr);\n+                    }\n+                } catch (PrivilegedActionException e) {\n+                    var cause = e.getCause();\n+                    if (debug.on()) {\n+                        debug.log(\"bind to \" + localAddr + \" failed: \" + cause.getMessage());\n+                    }\n+                    throw cause;\n+                }\n+            }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Predicate;\n+\n+\/*\n+ * @test\n+ * @summary Tests HttpClient usage when configured with a local address to bind\n+ *          to, when sending requests\n+ * @bug 8209137\n+ * @modules jdk.httpserver\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *\n+ * @library \/test\/lib http2\/server\n+ *\n+ * @run testng\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=frames,ssl,requests,responses,errors\n+ *      -Djdk.internal.httpclient.debug=true\n+ *      HttpClientLocalAddrTest\n+ *\n+ * @run testng\/othervm\/java.security.policy=httpclient-localaddr-security.policy\n+ *      -Djdk.httpclient.HttpClient.log=frames,ssl,requests,responses,errors\n+ *      -Djdk.internal.httpclient.debug=true\n+ *      HttpClientLocalAddrTest\n+ *\n+ *\/\n+public class HttpClientLocalAddrTest {\n+\n+    private static SSLContext sslContext;\n+    private static HttpServerAdapters.HttpTestServer http1_1_Server;\n+    private static URI httpURI;\n+    private static HttpServerAdapters.HttpTestServer https_1_1_Server;\n+    private static URI httpsURI;\n+    private static HttpServerAdapters.HttpTestServer http2_Server;\n+    private static URI http2URI;\n+    private static HttpServerAdapters.HttpTestServer https2_Server;\n+    private static URI https2URI;\n+\n+    \/\/ start various HTTP\/HTTPS servers that will be invoked against in the tests\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        Assert.assertNotNull(sslContext, \"Unexpected null sslContext\");\n+\n+        HttpServerAdapters.HttpTestHandler handler = (exchange) -> {\n+            \/\/ the handler receives a request and sends back a 200 response with the\n+            \/\/ response body containing the hostname\/ip of the client from whom\n+            \/\/ the request was received\n+            var clientAddr = exchange.getRemoteAddress();\n+            System.out.println(\"Received a request from client address \" + clientAddr);\n+            var responseContent = clientAddr.getHostName().getBytes(StandardCharsets.UTF_8);\n+            exchange.sendResponseHeaders(200, responseContent.length);\n+            try (var os = exchange.getResponseBody()) {\n+                \/\/ write out the client address as a response\n+                os.write(responseContent);\n+            }\n+            exchange.close();\n+        };\n+\n+        \/\/ HTTP\/1.1 - create servers with http and https\n+        final var sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        final int backlog = 0;\n+        http1_1_Server = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, backlog));\n+        http1_1_Server.addHandler(handler, \"\/\");\n+        http1_1_Server.start();\n+        System.out.println(\"Started HTTP v1.1 server at \" + http1_1_Server.serverAuthority());\n+        httpURI = new URI(\"http:\/\/\" + http1_1_Server.serverAuthority() + \"\/\");\n+\n+        final HttpsServer httpsServer = HttpsServer.create(sa, 0);\n+        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        https_1_1_Server = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        https_1_1_Server.addHandler(handler, \"\/\");\n+        https_1_1_Server.start();\n+        System.out.println(\"Started HTTPS v1.1 server at \" + https_1_1_Server.serverAuthority());\n+        httpsURI = new URI(\"https:\/\/\" + https_1_1_Server.serverAuthority() + \"\/\");\n+\n+        \/\/ HTTP\/2 - create servers with http and https\n+        http2_Server = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(sa.getHostString(), false, null));\n+        http2_Server.addHandler(handler, \"\/\");\n+        http2_Server.start();\n+        System.out.println(\"Started HTTP v2 server at \" + http2_Server.serverAuthority());\n+        http2URI = new URI(\"http:\/\/\" + http2_Server.serverAuthority() + \"\/\");\n+\n+        https2_Server = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(sa.getHostString(), true, sslContext));\n+        https2_Server.addHandler(handler, \"\/\");\n+        https2_Server.start();\n+        System.out.println(\"Started HTTPS v2 server at \" + https2_Server.serverAuthority());\n+        https2URI = new URI(\"https:\/\/\" + https2_Server.serverAuthority() + \"\/\");\n+    }\n+\n+    \/\/ stop each of the started servers\n+    @AfterClass\n+    public static void afterClass() throws Exception {\n+        \/\/ stop each of the server and accumulate any exception\n+        \/\/ that might happen during stop and finally throw\n+        \/\/ the accumulated exception(s)\n+        var e = safeStop(http1_1_Server, null);\n+        e = safeStop(https_1_1_Server, e);\n+        e = safeStop(http2_Server, e);\n+        e = safeStop(https2_Server, e);\n+        \/\/ throw any exception that happened during stop\n+        if (e != null) {\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Stops the server and returns (instead of throwing) any exception that might\n+     * have occurred during stop. If {@code prevException} is not null then any\n+     * exception during stop of the {@code server} will be added as a suppressed\n+     * exception to the {@code prevException} and the {@code prevException} will be\n+     * returned.\n+     *\/\n+    private static Exception safeStop(HttpServerAdapters.HttpTestServer server, Exception prevException) {\n+        if (server == null) {\n+            return null;\n+        }\n+        var serverAuthority = server.serverAuthority();\n+        try {\n+            server.stop();\n+        } catch (Exception e) {\n+            System.err.println(\"Failed to stop server \" + serverAuthority);\n+            if (prevException == null) {\n+                return e;\n+            }\n+            prevException.addSuppressed(e);\n+            return prevException;\n+        }\n+        return prevException;\n+    }\n+\n+    @DataProvider(name = \"params\")\n+    private Object[][] paramsProvider() throws Exception {\n+        final List<Object[]> clients = new ArrayList();\n+        final URI[] requestURIs = new URI[]{httpURI, httpsURI, http2URI, https2URI};\n+        final Predicate<URI> requiresSSLContext = (uri) -> uri.getScheme().equals(\"https\");\n+        for (var requestURI : requestURIs) {\n+            final var configureClientSSL = requiresSSLContext.test(requestURI);\n+            \/\/ no localAddr set\n+            clients.add(new Object[]{\n+                    newBuilder(configureClientSSL).build(),\n+                    requestURI,\n+                    null\n+            });\n+            \/\/ null localAddr set\n+            clients.add(new Object[]{\n+                    newBuilder(configureClientSSL).localAddress(null).build(),\n+                    requestURI,\n+                    null\n+            });\n+            \/\/ localAddr set to loopback address\n+            final var loopbackAddr = InetAddress.getLoopbackAddress();\n+            clients.add(new Object[]{\n+                    newBuilder(configureClientSSL)\n+                            .localAddress(new InetSocketAddress(loopbackAddr, 0))\n+                            .build(),\n+                    requestURI,\n+                    loopbackAddr\n+            });\n+            \/\/ anyAddress\n+            if (IPSupport.hasIPv6()) {\n+                \/\/ ipv6 wildcard\n+                final var localAddr = InetAddress.getByName(\"::\");\n+                clients.add(new Object[]{\n+                        newBuilder(configureClientSSL)\n+                                .localAddress(new InetSocketAddress(localAddr, 0))\n+                                .build(),\n+                        requestURI,\n+                        localAddr\n+                });\n+            }\n+            if (IPSupport.hasIPv4()) {\n+                \/\/ ipv4 wildcard\n+                final var localAddr = InetAddress.getByName(\"0.0.0.0\");\n+                clients.add(new Object[]{\n+                        newBuilder(configureClientSSL)\n+                                .localAddress(new InetSocketAddress(localAddr, 0))\n+                                .build(),\n+                        requestURI,\n+                        localAddr\n+                });\n+            }\n+        }\n+        return clients.stream().toArray(Object[][]::new);\n+    }\n+\n+    private static HttpClient.Builder newBuilder(boolean configureClientSSL) {\n+        var builder = HttpClient.newBuilder();\n+        \/\/ don't let proxies interfere with the client addresses received on the\n+        \/\/ HTTP request, by the server side handler used in this test.\n+        builder.proxy(HttpClient.Builder.NO_PROXY);\n+        if (configureClientSSL) {\n+            builder.sslContext(sslContext);\n+        }\n+        return builder;\n+    }\n+\n+    \/**\n+     * Sends a GET request using the {@code client} and expects a 200 response.\n+     * The returned response body is then tested to see if the client address\n+     * seen by the server side handler is the same one as that is set on the\n+     * {@code client}\n+     *\/\n+    @Test(dataProvider = \"params\")\n+    public void testSend(HttpClient client, URI requestURI, InetAddress localAddress) throws Exception {\n+        System.out.println(\"Testing using a HTTP client \" + client.version() + \" with local address \" + localAddress\n+                + \" against request URI \" + requestURI);\n+        \/\/ GET request\n+        var req = HttpRequest.newBuilder(requestURI).build();\n+        var resp = client.send(req, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+        Assert.assertEquals(resp.statusCode(), 200, \"Unexpected status code\");\n+        \/\/ verify the address only if a specific one was set on the client\n+        if (localAddress != null && !localAddress.isAnyLocalAddress()) {\n+            Assert.assertEquals(resp.body(), localAddress.getHostName(),\n+                    \"Unexpected client address seen by the server handler\");\n+        }\n+    }\n+\n+    \/**\n+     * Sends a GET request using the {@code sendAsync} method on the {@code client} and\n+     * expects a 200 response. The returned response body is then tested to see if the client address\n+     * seen by the server side handler is the same one as that is set on the\n+     * {@code client}\n+     *\/\n+    @Test(dataProvider = \"params\")\n+    public void testSendAsync(HttpClient client, URI requestURI, InetAddress localAddress) throws Exception {\n+        System.out.println(\"Testing using a HTTP client \" + client.version() + \" with local address \" + localAddress\n+                + \" against request URI \" + requestURI);\n+        \/\/ GET request\n+        var req = HttpRequest.newBuilder(requestURI).build();\n+        var cf = client.sendAsync(req,\n+                HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+        var resp = cf.get();\n+        Assert.assertEquals(resp.statusCode(), 200, \"Unexpected status code\");\n+        \/\/ verify the address only if a specific one was set on the client\n+        if (localAddress != null && !localAddress.isAnyLocalAddress()) {\n+            Assert.assertEquals(resp.body(), localAddress.getHostName(),\n+                    \"Unexpected client address seen by the server handler\");\n+        }\n+    }\n+\n+    \/**\n+     * Invokes the {@link #testSend(HttpClient)} and {@link #testSendAsync(HttpClient)}\n+     * tests, concurrently in multiple threads to verify that the correct local address\n+     * is used when multiple concurrent threads are involved in sending requests from\n+     * the {@code client}\n+     *\/\n+    @Test(dataProvider = \"params\")\n+    public void testMultiSendRequests(HttpClient client, URI requestURI, InetAddress localAddress) throws Exception {\n+        int numThreads = 4;\n+        ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n+        List<Future<Void>> taskResults = new ArrayList<>();\n+        try {\n+            for (int i = 0; i < numThreads; i++) {\n+                final var currentIdx = i;\n+                var f = executor.submit(new Callable<Void>() {\n+                    @Override\n+                    public Void call() throws Exception {\n+                        \/\/ test some for send and some for sendAsync\n+                        if (currentIdx % 2 == 0) {\n+                            testSend(client, requestURI, localAddress);\n+                        } else {\n+                            testSendAsync(client, requestURI, localAddress);\n+                        }\n+                        return null;\n+                    }\n+                });\n+                taskResults.add(f);\n+            }\n+            \/\/ wait for results\n+            for (var r : taskResults) {\n+                r.get();\n+            }\n+        } finally {\n+            executor.shutdownNow();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientLocalAddrTest.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,0 +211,1 @@\n+        public abstract InetSocketAddress getRemoteAddress();\n@@ -268,0 +269,6 @@\n+\n+            @Override\n+            public InetSocketAddress getRemoteAddress() {\n+                return exchange.getRemoteAddress();\n+            }\n+\n@@ -323,0 +330,6 @@\n+\n+            @Override\n+            public InetSocketAddress getRemoteAddress() {\n+                return exchange.getRemoteAddress();\n+            }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+maxOutputSize = 2500000\n","filename":"test\/jdk\/java\/net\/httpclient\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,0 +316,1 @@\n+                        e.printStackTrace();\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestServer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+\/\/ for JTwork\/classes\/0\/test\/lib\/jdk\/test\/lib\/net\/SimpleSSLContext.class\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/test\/lib\/-\" {\n+    permission java.util.PropertyPermission \"test.src.path\", \"read\";\n+    permission java.io.FilePermission \"${test.src}\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/net\/testkeys\", \"read\";\n+};\n+\n+\/\/ for JTwork\/\/classes\/0\/java\/net\/httpclient\/http2\/server\/*\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/java\/net\/httpclient\/http2\/server\/*\" {\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.common\";\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.frame\";\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.hpack\";\n+    permission java.lang.RuntimePermission \"accessClassInPackage.sun.net.www.http\";\n+\n+    permission java.net.SocketPermission \"localhost:*\", \"listen,accept,resolve\";\n+    permission java.lang.RuntimePermission \"modifyThread\";\n+};\n+\n+grant codeBase \"file:${test.classes}\/-\" {\n+\n+    \/\/ test issues HTTP GET requests\n+    permission java.net.URLPermission \"http:\/\/localhost:*\/-\",   \"GET\";\n+    permission java.net.URLPermission \"https:\/\/localhost:*\/-\", \"GET\";\n+    permission java.net.URLPermission \"http:\/\/localhost:*\/-\",   \"GET\";\n+    permission java.net.URLPermission \"https:\/\/localhost:*\/-\", \"GET\";\n+\n+    \/\/ needed to grant permission to the HTTP\/2 server\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.common\";\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.frame\";\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.hpack\";\n+    permission java.lang.RuntimePermission \"accessClassInPackage.sun.net.www.http\";\n+\n+    \/\/ for HTTP\/1.1 server logging\n+    permission java.util.logging.LoggingPermission \"control\";\n+\n+    \/\/ needed to grant the HTTP servers\n+    permission java.net.SocketPermission \"localhost:*\", \"accept,resolve\";\n+\n+    permission java.util.PropertyPermission \"*\", \"read\";\n+    permission java.lang.RuntimePermission \"modifyThread\";\n+\n+};\n","filename":"test\/jdk\/java\/net\/httpclient\/httpclient-localaddr-security.policy","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}