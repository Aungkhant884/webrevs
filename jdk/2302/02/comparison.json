{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -2929,1 +2929,0 @@\n-  assert(patch_code == lir_patch_none, \"Patch code not supported\");\n@@ -2932,0 +2931,1 @@\n+\n@@ -2933,1 +2933,8 @@\n-    __ add_const_optimized(dest->as_pointer_register(), addr->base()->as_pointer_register(), addr->disp());\n+    if (patch_code != lir_patch_none) {\n+      PatchingStub* patch = new PatchingStub(_masm, PatchingStub::access_field_id);\n+      __ load_const32(R0, 0); \/\/ patchable int\n+      __ add(dest->as_pointer_register(), addr->base()->as_pointer_register(), R0);\n+      patching_epilog(patch, patch_code, addr->base()->as_register(), info);\n+    } else {\n+      __ add_const_optimized(dest->as_pointer_register(), addr->base()->as_pointer_register(), addr->disp());\n+    }\n@@ -2935,0 +2942,1 @@\n+    assert(patch_code == lir_patch_none, \"Patch code not supported\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -110,2 +110,4 @@\n-void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm, DecoratorSet decorators, Register obj, RegisterOrConstant ind_or_offs, Register pre_val,\n-                                                 Register tmp1, Register tmp2, bool needs_frame) {\n+void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm, DecoratorSet decorators,\n+                                                 Register obj, RegisterOrConstant ind_or_offs, Register pre_val,\n+                                                 Register tmp1, Register tmp2,\n+                                                 MacroAssembler::PreservationLevel preservation_level) {\n@@ -190,0 +192,5 @@\n+  \/\/ Determine necessary runtime invocation preservation measures\n+  const bool needs_frame = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR;\n+  assert(preservation_level <= MacroAssembler::PRESERVATION_FRAME_LR,\n+         \"g1_write_barrier_pre doesn't support preservation levels higher than PRESERVATION_FRAME_LR\");\n+\n@@ -208,2 +215,4 @@\n-void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm, DecoratorSet decorators, Register store_addr, Register new_val,\n-                                                  Register tmp1, Register tmp2, Register tmp3) {\n+void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm, DecoratorSet decorators,\n+                                                  Register store_addr, Register new_val,\n+                                                  Register tmp1, Register tmp2, Register tmp3,\n+                                                  MacroAssembler::PreservationLevel preservation_level) {\n@@ -274,0 +283,3 @@\n+  assert(preservation_level == MacroAssembler::PRESERVATION_NONE,\n+         \"g1_write_barrier_post doesn't support preservation levels higher than PRESERVATION_NONE\");\n+\n@@ -282,1 +294,2 @@\n-                                       Register tmp1, Register tmp2, Register tmp3, bool needs_frame) {\n+                                       Register tmp1, Register tmp2, Register tmp3,\n+                                       MacroAssembler::PreservationLevel preservation_level) {\n@@ -287,2 +300,4 @@\n-  g1_write_barrier_pre(masm, decorators, base, ind_or_offs,\n-                       tmp1, tmp2, tmp3, needs_frame);\n+  g1_write_barrier_pre(masm, decorators,\n+                       base, ind_or_offs,\n+                       tmp1, tmp2, tmp3,\n+                       preservation_level);\n@@ -290,1 +305,4 @@\n-  BarrierSetAssembler::store_at(masm, decorators, type, base, ind_or_offs, val, tmp1, tmp2, tmp3, needs_frame);\n+  BarrierSetAssembler::store_at(masm, decorators,\n+                                type, base, ind_or_offs, val,\n+                                tmp1, tmp2, tmp3,\n+                                preservation_level);\n@@ -301,1 +319,4 @@\n-    g1_write_barrier_post(masm, decorators, base, val, tmp1, tmp2, tmp3);\n+    g1_write_barrier_post(masm, decorators,\n+                          base, val,\n+                          tmp1, tmp2, tmp3,\n+                          preservation_level);\n@@ -307,1 +328,2 @@\n-                                    Register tmp1, Register tmp2, bool needs_frame, Label *L_handle_null) {\n+                                    Register tmp1, Register tmp2,\n+                                    MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null) {\n@@ -315,1 +337,4 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, base, ind_or_offs, dst, tmp1, tmp2, needs_frame, L_handle_null);\n+  ModRefBarrierSetAssembler::load_at(masm, decorators, type,\n+                                     base, ind_or_offs, dst,\n+                                     tmp1, tmp2,\n+                                     preservation_level, L_handle_null);\n@@ -322,2 +347,4 @@\n-    g1_write_barrier_pre(masm, decorators | IS_NOT_NULL, noreg \/* obj *\/, (intptr_t)0, dst \/* pre_val *\/,\n-                         tmp1, tmp2, needs_frame);\n+    g1_write_barrier_pre(masm, decorators | IS_NOT_NULL,\n+                         noreg \/* obj *\/, (intptr_t)0, dst \/* pre_val *\/,\n+                         tmp1, tmp2,\n+                         preservation_level);\n@@ -328,1 +355,3 @@\n-void G1BarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2, bool needs_frame) {\n+void G1BarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value,\n+                                            Register tmp1, Register tmp2,\n+                                            MacroAssembler::PreservationLevel preservation_level) {\n@@ -341,1 +370,2 @@\n-                       tmp1, tmp2, needs_frame);\n+                       tmp1, tmp2,\n+                       preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":47,"deletions":17,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -40,1 +40,2 @@\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators, Register from, Register to, Register count,\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register from, Register to, Register count,\n@@ -42,1 +43,3 @@\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count, Register preserve);\n+  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                Register addr, Register count,\n+                                                Register preserve);\n@@ -44,4 +47,8 @@\n-  void g1_write_barrier_pre(MacroAssembler* masm, DecoratorSet decorators, Register obj, RegisterOrConstant ind_or_offs, Register pre_val,\n-                            Register tmp1, Register tmp2, bool needs_frame);\n-  void g1_write_barrier_post(MacroAssembler* masm, DecoratorSet decorators, Register store_addr, Register new_val,\n-                             Register tmp1, Register tmp2, Register tmp3);\n+  void g1_write_barrier_pre(MacroAssembler* masm, DecoratorSet decorators,\n+                            Register obj, RegisterOrConstant ind_or_offs, Register pre_val,\n+                            Register tmp1, Register tmp2,\n+                            MacroAssembler::PreservationLevel preservation_level);\n+  void g1_write_barrier_post(MacroAssembler* masm, DecoratorSet decorators,\n+                             Register store_addr, Register new_val,\n+                             Register tmp1, Register tmp2, Register tmp3,\n+                             MacroAssembler::PreservationLevel preservation_level);\n@@ -51,1 +58,2 @@\n-                            Register tmp1, Register tmp2, Register tmp3, bool needs_frame);\n+                            Register tmp1, Register tmp2, Register tmp3,\n+                            MacroAssembler::PreservationLevel preservation_level);\n@@ -64,1 +72,3 @@\n-                       Register tmp1, Register tmp2, bool needs_frame, Label *L_handle_null = NULL);\n+                       Register tmp1, Register tmp2,\n+                       MacroAssembler::PreservationLevel preservation_level,\n+                       Label *L_handle_null = NULL);\n@@ -66,1 +76,3 @@\n-  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2, bool needs_frame);\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value,\n+                               Register tmp1, Register tmp2,\n+                               MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.hpp","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -37,1 +37,2 @@\n-                                   Register tmp1, Register tmp2, Register tmp3, bool needs_frame) {\n+                                   Register tmp1, Register tmp2, Register tmp3,\n+                                   MacroAssembler::PreservationLevel preservation_level) {\n@@ -70,1 +71,2 @@\n-                                  Register tmp1, Register tmp2, bool needs_frame, Label *L_handle_null) {\n+                                  Register tmp1, Register tmp2,\n+                                  MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null) {\n@@ -108,1 +110,2 @@\n-                                          Register tmp1, Register tmp2, bool needs_frame) {\n+                                          Register tmp1, Register tmp2,\n+                                          MacroAssembler::PreservationLevel preservation_level) {\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -44,1 +44,2 @@\n-                        Register tmp1, Register tmp2, Register tmp3, bool needs_frame);\n+                        Register tmp1, Register tmp2, Register tmp3,\n+                        MacroAssembler::PreservationLevel preservation_level);\n@@ -48,1 +49,2 @@\n-                       Register tmp1, Register tmp2, bool needs_frame, Label *L_handle_null = NULL);\n+                       Register tmp1, Register tmp2,\n+                       MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = NULL);\n@@ -50,1 +52,3 @@\n-  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2, bool needs_frame);\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value,\n+                               Register tmp1, Register tmp2,\n+                               MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -94,1 +94,2 @@\n-                                                Register tmp1, Register tmp2, Register tmp3, bool needs_frame) {\n+                                                Register tmp1, Register tmp2, Register tmp3,\n+                                                MacroAssembler::PreservationLevel preservation_level) {\n@@ -99,1 +100,4 @@\n-  BarrierSetAssembler::store_at(masm, decorators, type, base, ind_or_offs, val, tmp1, tmp2, tmp3, needs_frame);\n+  BarrierSetAssembler::store_at(masm, decorators, type,\n+                                base, ind_or_offs, val,\n+                                tmp1, tmp2, tmp3,\n+                                preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -43,1 +43,2 @@\n-                            Register tmp1, Register tmp2, Register tmp3, bool needs_frame);\n+                            Register tmp1, Register tmp2, Register tmp3,\n+                            MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -35,1 +35,3 @@\n-    gen_write_ref_array_pre_barrier(masm, decorators, src, dst, count, preserve1, preserve2);\n+    gen_write_ref_array_pre_barrier(masm, decorators,\n+                                    src, dst, count,\n+                                    preserve1, preserve2);\n@@ -61,1 +63,2 @@\n-                                         Register tmp1, Register tmp2, Register tmp3, bool needs_frame) {\n+                                         Register tmp1, Register tmp2, Register tmp3,\n+                                         MacroAssembler::PreservationLevel preservation_level) {\n@@ -63,1 +66,4 @@\n-    oop_store_at(masm, decorators, type, base, ind_or_offs, val, tmp1, tmp2, tmp3, needs_frame);\n+    oop_store_at(masm, decorators, type,\n+                 base, ind_or_offs, val,\n+                 tmp1, tmp2, tmp3,\n+                 preservation_level);\n@@ -65,1 +71,4 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, base, ind_or_offs, val, tmp1, tmp2, tmp3, needs_frame);\n+    BarrierSetAssembler::store_at(masm, decorators, type,\n+                                  base, ind_or_offs, val,\n+                                  tmp1, tmp2, tmp3,\n+                                  preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n@@ -38,1 +38,2 @@\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators, Register from, Register to, Register count,\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register from, Register to, Register count,\n@@ -40,1 +41,2 @@\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count, Register preserve) {}\n+  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                Register addr, Register count, Register preserve) {}\n@@ -44,1 +46,2 @@\n-                            Register tmp1, Register tmp2, Register tmp3, bool needs_frame) = 0;\n+                            Register tmp1, Register tmp2, Register tmp3,\n+                            MacroAssembler::PreservationLevel preservation_level) = 0;\n@@ -47,1 +50,2 @@\n-                                  Register src, Register dst, Register count, Register preserve1, Register preserve2);\n+                                  Register src, Register dst, Register count,\n+                                  Register preserve1, Register preserve2);\n@@ -49,1 +53,2 @@\n-                                  Register dst, Register count, Register preserve);\n+                                  Register dst, Register count,\n+                                  Register preserve);\n@@ -53,1 +58,2 @@\n-                        Register tmp1, Register tmp2, Register tmp3, bool needs_frame);\n+                        Register tmp1, Register tmp2, Register tmp3,\n+                        MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -80,1 +80,1 @@\n-  void load_resolved_reference_at_index(Register result, Register index, Label *L_handle_null = NULL);\n+  void load_resolved_reference_at_index(Register result, Register index, Register tmp1, Label *L_handle_null = NULL);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -478,1 +478,4 @@\n-void InterpreterMacroAssembler::load_resolved_reference_at_index(Register result, Register index, Label *L_handle_null) {\n+\/\/ Kills:\n+\/\/   - index\n+void InterpreterMacroAssembler::load_resolved_reference_at_index(Register result, Register index, Register tmp1,\n+                                                                 Label *L_handle_null) {\n@@ -484,2 +487,2 @@\n-  Register tmp = index;  \/\/ reuse\n-  sldi(tmp, index, LogBytesPerHeapOop);\n+  Register tmp2 = index;  \/\/ reuse\n+  sldi(tmp1, index, LogBytesPerHeapOop);\n@@ -494,1 +497,1 @@\n-  cmpd(CCR0, tmp, R0);\n+  cmpd(CCR0, tmp1, R0);\n@@ -500,2 +503,5 @@\n-  add(result, tmp, result);\n-  load_heap_oop(result, arrayOopDesc::base_offset_in_bytes(T_OBJECT), result, tmp, R0, false, 0, L_handle_null);\n+  add(result, tmp1, result);\n+  load_heap_oop(result, arrayOopDesc::base_offset_in_bytes(T_OBJECT), result,\n+                tmp1, tmp2,\n+                MacroAssembler::PRESERVATION_FRAME_LR,\n+                0, L_handle_null);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -710,0 +710,24 @@\n+void MacroAssembler::clobber_volatile_gprs(Register excluded_register) {\n+  const int magic_number = 0x42;\n+\n+  \/\/ Preserve stack pointer register (R1_SP) and system thread id register (R13);\n+  \/\/ although they're technically volatile\n+  for (int i = 2; i < 13; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == excluded_register) {\n+      continue;\n+    }\n+\n+    li(reg, magic_number);\n+  }\n+}\n+\n+void MacroAssembler::clobber_carg_stack_slots(Register tmp) {\n+  const int magic_number = 0x43;\n+\n+  li(tmp, magic_number);\n+  for (int m = 0; m <= 7; m++) {\n+    std(tmp, frame::abi_minframe_size + m * 8, R1_SP);\n+  }\n+}\n+\n@@ -800,1 +824,1 @@\n-void MacroAssembler::save_volatile_gprs(Register dst, int offset) {\n+void MacroAssembler::save_volatile_gprs(Register dst, int offset, bool include_fp_regs, bool include_R3_RET_reg) {\n@@ -802,1 +826,3 @@\n-  std(R3,  offset, dst);   offset += 8;\n+  if (include_R3_RET_reg) {\n+    std(R3, offset, dst);  offset += 8;\n+  }\n@@ -813,14 +839,16 @@\n-  stfd(F0, offset, dst);   offset += 8;\n-  stfd(F1, offset, dst);   offset += 8;\n-  stfd(F2, offset, dst);   offset += 8;\n-  stfd(F3, offset, dst);   offset += 8;\n-  stfd(F4, offset, dst);   offset += 8;\n-  stfd(F5, offset, dst);   offset += 8;\n-  stfd(F6, offset, dst);   offset += 8;\n-  stfd(F7, offset, dst);   offset += 8;\n-  stfd(F8, offset, dst);   offset += 8;\n-  stfd(F9, offset, dst);   offset += 8;\n-  stfd(F10, offset, dst);  offset += 8;\n-  stfd(F11, offset, dst);  offset += 8;\n-  stfd(F12, offset, dst);  offset += 8;\n-  stfd(F13, offset, dst);\n+  if (include_fp_regs) {\n+    stfd(F0, offset, dst);   offset += 8;\n+    stfd(F1, offset, dst);   offset += 8;\n+    stfd(F2, offset, dst);   offset += 8;\n+    stfd(F3, offset, dst);   offset += 8;\n+    stfd(F4, offset, dst);   offset += 8;\n+    stfd(F5, offset, dst);   offset += 8;\n+    stfd(F6, offset, dst);   offset += 8;\n+    stfd(F7, offset, dst);   offset += 8;\n+    stfd(F8, offset, dst);   offset += 8;\n+    stfd(F9, offset, dst);   offset += 8;\n+    stfd(F10, offset, dst);  offset += 8;\n+    stfd(F11, offset, dst);  offset += 8;\n+    stfd(F12, offset, dst);  offset += 8;\n+    stfd(F13, offset, dst);\n+  }\n@@ -830,1 +858,1 @@\n-void MacroAssembler::restore_volatile_gprs(Register src, int offset) {\n+void MacroAssembler::restore_volatile_gprs(Register src, int offset, bool include_fp_regs, bool include_R3_RET_reg) {\n@@ -832,1 +860,3 @@\n-  ld(R3,  offset, src);   offset += 8;\n+  if (include_R3_RET_reg) {\n+    ld(R3,  offset, src);   offset += 8;\n+  }\n@@ -843,14 +873,16 @@\n-  lfd(F0, offset, src);   offset += 8;\n-  lfd(F1, offset, src);   offset += 8;\n-  lfd(F2, offset, src);   offset += 8;\n-  lfd(F3, offset, src);   offset += 8;\n-  lfd(F4, offset, src);   offset += 8;\n-  lfd(F5, offset, src);   offset += 8;\n-  lfd(F6, offset, src);   offset += 8;\n-  lfd(F7, offset, src);   offset += 8;\n-  lfd(F8, offset, src);   offset += 8;\n-  lfd(F9, offset, src);   offset += 8;\n-  lfd(F10, offset, src);  offset += 8;\n-  lfd(F11, offset, src);  offset += 8;\n-  lfd(F12, offset, src);  offset += 8;\n-  lfd(F13, offset, src);\n+  if (include_fp_regs) {\n+    lfd(F0, offset, src);   offset += 8;\n+    lfd(F1, offset, src);   offset += 8;\n+    lfd(F2, offset, src);   offset += 8;\n+    lfd(F3, offset, src);   offset += 8;\n+    lfd(F4, offset, src);   offset += 8;\n+    lfd(F5, offset, src);   offset += 8;\n+    lfd(F6, offset, src);   offset += 8;\n+    lfd(F7, offset, src);   offset += 8;\n+    lfd(F8, offset, src);   offset += 8;\n+    lfd(F9, offset, src);   offset += 8;\n+    lfd(F10, offset, src);  offset += 8;\n+    lfd(F11, offset, src);  offset += 8;\n+    lfd(F12, offset, src);  offset += 8;\n+    lfd(F13, offset, src);\n+  }\n@@ -3035,1 +3067,2 @@\n-void MacroAssembler::resolve_jobject(Register value, Register tmp1, Register tmp2, bool needs_frame) {\n+void MacroAssembler::resolve_jobject(Register value, Register tmp1, Register tmp2,\n+                                     MacroAssembler::PreservationLevel preservation_level) {\n@@ -3037,1 +3070,1 @@\n-  bs->resolve_jobject(this, value, tmp1, tmp2, needs_frame);\n+  bs->resolve_jobject(this, value, tmp1, tmp2, preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":68,"deletions":35,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -42,0 +42,8 @@\n+  \/\/ Indicates whether and, if so, which registers must be preserved when calling runtime code.\n+  enum PreservationLevel {\n+    PRESERVATION_NONE,\n+    PRESERVATION_FRAME_LR,\n+    PRESERVATION_FRAME_LR_GP_REGS,\n+    PRESERVATION_FRAME_LR_GP_FP_REGS\n+  };\n+\n@@ -263,0 +271,7 @@\n+\n+  \/\/ Clobbers all volatile, (non-floating-point) general-purpose registers for debugging purposes.\n+  \/\/ This is especially useful for making calls to the JRT in places in which this hasn't been done before;\n+  \/\/ e.g. with the introduction of LRBs (load reference barriers) for concurrent garbage collection.\n+  void clobber_volatile_gprs(Register excluded_register = noreg);\n+  void clobber_carg_stack_slots(Register tmp);\n+\n@@ -265,3 +280,11 @@\n-  enum { num_volatile_regs = 11 + 14 }; \/\/ GPR + FPR\n-  void save_volatile_gprs(   Register dst_base, int offset);\n-  void restore_volatile_gprs(Register src_base, int offset);\n+\n+  enum {\n+    num_volatile_gp_regs = 11,\n+    num_volatile_fp_regs = 14,\n+    num_volatile_regs = num_volatile_gp_regs + num_volatile_fp_regs\n+  };\n+\n+  void save_volatile_gprs(   Register dst_base, int offset,\n+                             bool include_fp_regs = true, bool include_R3_RET_reg = true);\n+  void restore_volatile_gprs(Register src_base, int offset,\n+                             bool include_fp_regs = true, bool include_R3_RET_reg = true);\n@@ -648,1 +671,2 @@\n-  void resolve_jobject(Register value, Register tmp1, Register tmp2, bool needs_frame);\n+  void resolve_jobject(Register value, Register tmp1, Register tmp2,\n+                       MacroAssembler::PreservationLevel preservation_level);\n@@ -689,1 +713,2 @@\n-                              Register tmp1, Register tmp2, Register tmp3, bool needs_frame);\n+                              Register tmp1, Register tmp2, Register tmp3,\n+                              MacroAssembler::PreservationLevel preservation_level);\n@@ -692,1 +717,2 @@\n-                             Register tmp1, Register tmp2, bool needs_frame, Label *L_handle_null = NULL);\n+                             Register tmp1, Register tmp2,\n+                             MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = NULL);\n@@ -698,1 +724,2 @@\n-                            Register tmp1, Register tmp2, bool needs_frame,\n+                            Register tmp1, Register tmp2,\n+                            MacroAssembler::PreservationLevel preservation_level,\n@@ -702,2 +729,2 @@\n-                             Register tmp1, Register tmp2, Register tmp3, bool needs_frame,\n-                             DecoratorSet decorators = 0);\n+                             Register tmp1, Register tmp2, Register tmp3,\n+                             MacroAssembler::PreservationLevel preservation_level, DecoratorSet decorators = 0);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -353,1 +353,2 @@\n-                                            Register tmp1, Register tmp2, Register tmp3, bool needs_frame) {\n+                                            Register tmp1, Register tmp2, Register tmp3,\n+                                            MacroAssembler::PreservationLevel preservation_level) {\n@@ -362,1 +363,1 @@\n-                                      tmp1, tmp2, tmp3, needs_frame);\n+                                      tmp1, tmp2, tmp3, preservation_level);\n@@ -366,1 +367,1 @@\n-                 tmp1, tmp2, tmp3, needs_frame);\n+                 tmp1, tmp2, tmp3, preservation_level);\n@@ -372,1 +373,3 @@\n-                                           Register tmp1, Register tmp2, bool needs_frame, Label *L_handle_null) {\n+                                           Register tmp1, Register tmp2,\n+                                           MacroAssembler::PreservationLevel preservation_level,\n+                                           Label *L_handle_null) {\n@@ -381,1 +384,1 @@\n-                                     tmp1, tmp2, needs_frame, L_handle_null);\n+                                     tmp1, tmp2, preservation_level, L_handle_null);\n@@ -385,1 +388,1 @@\n-                tmp1, tmp2, needs_frame, L_handle_null);\n+                tmp1, tmp2, preservation_level, L_handle_null);\n@@ -391,2 +394,4 @@\n-                                          bool needs_frame, DecoratorSet decorators, Label *L_handle_null) {\n-  access_load_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, needs_frame, L_handle_null);\n+                                          MacroAssembler::PreservationLevel preservation_level,\n+                                          DecoratorSet decorators, Label *L_handle_null) {\n+  access_load_at(T_OBJECT, decorators | IN_HEAP, s1, offs, d, tmp1, tmp2,\n+                 preservation_level, L_handle_null);\n@@ -397,2 +402,3 @@\n-                                           bool needs_frame, DecoratorSet decorators) {\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, tmp3, needs_frame);\n+                                           MacroAssembler::PreservationLevel preservation_level,\n+                                           DecoratorSet decorators) {\n+  access_store_at(T_OBJECT, decorators | IN_HEAP, s1, offs, d, tmp1, tmp2, tmp3, preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -176,1 +176,1 @@\n-  assert_different_registers(recv, method_temp, temp2);  \/\/ temp3 is only passed on\n+  assert_different_registers(recv, method_temp, temp2, temp3);\n@@ -181,0 +181,5 @@\n+\n+  const MacroAssembler::PreservationLevel preservation_level = for_compiler_entry\n+    ? MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS\n+    : MacroAssembler::PRESERVATION_FRAME_LR;\n+\n@@ -182,1 +187,1 @@\n-                   temp2, noreg, false, IS_NOT_NULL);\n+                   temp2, temp3, preservation_level, IS_NOT_NULL);\n@@ -185,1 +190,1 @@\n-                   temp2, noreg, false, IS_NOT_NULL);\n+                   temp2, temp3, preservation_level, IS_NOT_NULL);\n@@ -188,1 +193,1 @@\n-                   temp2, noreg, false, IS_NOT_NULL);\n+                   temp2, temp3, preservation_level, IS_NOT_NULL);\n@@ -233,4 +238,3 @@\n-  Register argbase    = R15_esp; \/\/ parameter (preserved)\n-  Register argslot    = R3;\n-  Register temp1      = R6;\n-  Register param_size = R7;\n+  Register R15_argbase   = R15_esp; \/\/ parameter (preserved)\n+  Register R30_tmp1      = R30;\n+  Register R7_param_size = R7;\n@@ -247,1 +251,1 @@\n-    __ load_sized_value(temp1, Method::intrinsic_id_offset_in_bytes(), R19_method,\n+    __ load_sized_value(R30_tmp1, Method::intrinsic_id_offset_in_bytes(), R19_method,\n@@ -249,1 +253,1 @@\n-    __ cmpwi(CCR1, temp1, (int) iid);\n+    __ cmpwi(CCR1, R30_tmp1, (int) iid);\n@@ -265,2 +269,2 @@\n-    __ ld(param_size, in_bytes(Method::const_offset()), R19_method);\n-    __ load_sized_value(param_size, in_bytes(ConstMethod::size_of_parameters_offset()), param_size,\n+    __ ld(R7_param_size, in_bytes(Method::const_offset()), R19_method);\n+    __ load_sized_value(R7_param_size, in_bytes(ConstMethod::size_of_parameters_offset()), R7_param_size,\n@@ -270,1 +274,1 @@\n-    DEBUG_ONLY(param_size = noreg);\n+    DEBUG_ONLY(R7_param_size = noreg);\n@@ -275,2 +279,2 @@\n-    __ ld(tmp_mh = temp1, __ argument_offset(param_size, param_size, 0), argbase);\n-    DEBUG_ONLY(param_size = noreg);\n+    __ ld(tmp_mh = R30_tmp1, __ argument_offset(R7_param_size, R7_param_size, 0), R15_argbase);\n+    DEBUG_ONLY(R7_param_size = noreg);\n@@ -294,2 +298,2 @@\n-      __ ld(tmp_recv = temp1, __ argument_offset(param_size, param_size, 0), argbase);\n-      DEBUG_ONLY(param_size = noreg);\n+      __ ld(tmp_recv = R30_tmp1, __ argument_offset(R7_param_size, R7_param_size, 0), R15_argbase);\n+      DEBUG_ONLY(R7_param_size = noreg);\n@@ -298,2 +302,2 @@\n-    __ ld(R19_member, RegisterOrConstant((intptr_t)8), argbase);\n-    __ add(argbase, Interpreter::stackElementSize, argbase);\n+    __ ld(R19_member, RegisterOrConstant((intptr_t)8), R15_argbase);\n+    __ add(R15_argbase, Interpreter::stackElementSize, R15_argbase);\n@@ -312,1 +316,1 @@\n-  Register temp1 = (for_compiler_entry ? R25_tmp5 : R7);\n+  Register temp1 = (for_compiler_entry ? R25_tmp5 : R31); \/\/ must be non-volatile due to runtime calls\n@@ -319,0 +323,4 @@\n+  const MacroAssembler::PreservationLevel preservation_level = for_compiler_entry\n+    ? MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS\n+    : MacroAssembler::PRESERVATION_FRAME_LR;\n+\n@@ -336,12 +344,0 @@\n-      __ verify_oop(receiver_reg, FILE_AND_LINE);\n-      if (iid == vmIntrinsics::_linkToSpecial) {\n-        \/\/ Don't actually load the klass; just null-check the receiver.\n-        __ null_check_throw(receiver_reg, -1, temp1,\n-                            Interpreter::throw_NullPointerException_entry());\n-      } else {\n-        \/\/ load receiver klass itself\n-        __ null_check_throw(receiver_reg, oopDesc::klass_offset_in_bytes(), temp1,\n-                            Interpreter::throw_NullPointerException_entry());\n-        __ load_klass(temp1_recv_klass, receiver_reg);\n-        __ verify_klass_ptr(temp1_recv_klass);\n-      }\n@@ -349,4 +345,9 @@\n-      \/\/ The receiver for the MemberName must be in receiver_reg.\n-      \/\/ Check the receiver against the MemberName.clazz\n-      if (VerifyMethodHandles && iid == vmIntrinsics::_linkToSpecial) {\n-        \/\/ Did not load it above...\n+      __ verify_oop(receiver_reg, FILE_AND_LINE);\n+\n+      const int klass_offset = iid == vmIntrinsics::_linkToSpecial\n+        ? -1                                  \/\/ enforce receiver null check\n+        : oopDesc::klass_offset_in_bytes();   \/\/ regular null-checking behavior\n+\n+      __ null_check_throw(receiver_reg, klass_offset, temp1, Interpreter::throw_NullPointerException_entry());\n+\n+      if (iid != vmIntrinsics::_linkToSpecial || VerifyMethodHandles) {\n@@ -356,0 +357,1 @@\n+\n@@ -359,0 +361,1 @@\n+\n@@ -360,1 +363,1 @@\n-                         temp3, noreg, false, IS_NOT_NULL);\n+                         temp3, temp4, preservation_level, IS_NOT_NULL);\n@@ -378,2 +381,0 @@\n-    \/\/  O5_savedSP - interpreter linkage (if interpreted)\n-    \/\/  O0..O5 - compiler arguments (if compiled)\n@@ -388,1 +389,1 @@\n-                       temp3, noreg, false, IS_NOT_NULL);\n+                       temp3, temp4, preservation_level, IS_NOT_NULL);\n@@ -397,1 +398,1 @@\n-                       temp3, noreg, false, IS_NOT_NULL);\n+                       temp3, temp4, preservation_level, IS_NOT_NULL);\n@@ -440,1 +441,1 @@\n-                       temp3, noreg, false, IS_NOT_NULL);\n+                       temp3, temp4, preservation_level, IS_NOT_NULL);\n@@ -470,1 +471,0 @@\n-    \/\/   O5_savedSP (if interpreted)\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -2433,1 +2433,1 @@\n-    __ resolve_jobject(R3_RET, r_temp_1, r_temp_2, \/* needs_frame *\/ false);\n+    __ resolve_jobject(R3_RET, r_temp_1, r_temp_2, MacroAssembler::PRESERVATION_NONE);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -2229,1 +2229,4 @@\n-    __ load_heap_oop(R10_oop, R8_offset, R3_from, R12_tmp, noreg, false, AS_RAW, &store_null);\n+    __ load_heap_oop(R10_oop, R8_offset, R3_from,\n+                     R11_scratch1, R12_tmp,\n+                     MacroAssembler::PRESERVATION_FRAME_LR_GP_REGS,\n+                     AS_RAW, &store_null);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2015, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2021 SAP SE. All rights reserved.\n@@ -408,1 +408,1 @@\n-    __ resolve_jobject(R3_RET, R11_scratch1, R31, \/* needs_frame *\/ true); \/\/ kills R31\n+    __ resolve_jobject(R3_RET, R11_scratch1, R31, MacroAssembler::PRESERVATION_FRAME_LR); \/\/ kills R31\n@@ -529,1 +529,3 @@\n-                   \/* non-volatile temp *\/ R31, R11_scratch1, true, ON_WEAK_OOP_REF);\n+                   \/* non-volatile temp *\/ R31, R11_scratch1,\n+                   MacroAssembler::PRESERVATION_FRAME_LR,\n+                   ON_WEAK_OOP_REF);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2013, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2013, 2021 SAP SE. All rights reserved.\n@@ -71,1 +71,1 @@\n-  __ store_heap_oop(val, offset, base, tmp1, tmp2, tmp3, false, decorators);\n+  __ store_heap_oop(val, offset, base, tmp1, tmp2, tmp3, MacroAssembler::PRESERVATION_NONE, decorators);\n@@ -83,1 +83,1 @@\n-  __ load_heap_oop(dst, offset, base, tmp1, tmp2, false, decorators);\n+  __ load_heap_oop(dst, offset, base, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE, decorators);\n@@ -308,1 +308,0 @@\n-  const Register Rscratch = R11_scratch1;\n@@ -313,2 +312,2 @@\n-  __ get_cache_index_at_bcp(Rscratch, 1, index_size);  \/\/ Load index.\n-  __ load_resolved_reference_at_index(R17_tos, Rscratch, &is_null);\n+  __ get_cache_index_at_bcp(R11_scratch1, 1, index_size);  \/\/ Load index.\n+  __ load_resolved_reference_at_index(R17_tos, R11_scratch1, R12_scratch2, &is_null);\n@@ -317,4 +316,4 @@\n-  int simm16_rest = __ load_const_optimized(Rscratch, Universe::the_null_sentinel_addr(), R0, true);\n-  __ ld(Rscratch, simm16_rest, Rscratch);\n-  __ resolve_oop_handle(Rscratch);\n-  __ cmpld(CCR0, R17_tos, Rscratch);\n+  int simm16_rest = __ load_const_optimized(R11_scratch1, Universe::the_null_sentinel_addr(), R0, true);\n+  __ ld(R11_scratch1, simm16_rest, R11_scratch1);\n+  __ resolve_oop_handle(R11_scratch1);\n+  __ cmpld(CCR0, R17_tos, R11_scratch1);\n@@ -2430,1 +2429,1 @@\n-                 Rbc           = R6_ARG4,\n+                 Rbc           = R30,\n@@ -2465,1 +2464,1 @@\n-  __ cmpwi(CCR6, Rscratch, 1); \/\/ Volatile?\n+  __ cmpwi(CCR2, Rscratch, 1); \/\/ Volatile?\n@@ -2516,1 +2515,1 @@\n-    __ beq(CCR6, acquire_double); \/\/ Volatile?\n+    __ beq(CCR2, acquire_double); \/\/ Volatile?\n@@ -2537,1 +2536,1 @@\n-    __ beq(CCR6, acquire_float); \/\/ Volatile?\n+    __ beq(CCR2, acquire_float); \/\/ Volatile?\n@@ -2556,1 +2555,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -2569,1 +2568,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -2583,1 +2582,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -2597,1 +2596,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -2610,1 +2609,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -2623,1 +2622,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -2638,1 +2637,1 @@\n-  __ beq(CCR6, Lacquire); \/\/ Volatile?\n+  __ beq(CCR2, Lacquire); \/\/ Volatile?\n@@ -3335,1 +3334,2 @@\n-  assert_different_registers(Rret_addr, Rscratch);\n+  \/\/ Rret_addr and Rindex have to be distinct as Rret_addr is used as a second temp register\n+  assert_different_registers(Rret_addr, Rindex, Rscratch);\n@@ -3344,0 +3344,2 @@\n+    Register reference = Rret_addr; \/\/ safe to use here; first use comes later\n+\n@@ -3349,3 +3351,3 @@\n-    __ load_resolved_reference_at_index(Rscratch, Rindex);\n-    __ verify_oop(Rscratch);\n-    __ push_ptr(Rscratch);\n+    __ load_resolved_reference_at_index(reference, Rindex, Rscratch);\n+    __ verify_oop(reference);\n+    __ push_ptr(reference);\n@@ -3652,1 +3654,1 @@\n-                 Rflags    = R4_ARG2,\n+                 Rflags    = R31,\n@@ -3676,1 +3678,1 @@\n-                 Rflags    = R4_ARG2,\n+                 Rflags    = R31,\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"}]}