{"files":[{"patch":"@@ -108,21 +108,0 @@\n-    \/\/ returns true if extended attributes enabled on file system where given\n-    \/\/ file resides, returns false if disabled or unable to determine.\n-    private boolean isExtendedAttributesEnabled(UnixPath path) {\n-        int fd = -1;\n-        try {\n-            fd = path.openForAttributeAccess(false);\n-\n-            \/\/ fgetxattr returns size if called with size==0\n-            byte[] name = Util.toBytes(\"user.java\");\n-            LinuxNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n-            return true;\n-        } catch (UnixException e) {\n-            \/\/ attribute does not exist\n-            if (e.errno() == UnixConstants.ENODATA)\n-                return true;\n-        } finally {\n-            UnixNativeDispatcher.close(fd);\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileStore.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        LinuxUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);\n+        UnixUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,55 +72,0 @@\n-    \/**\n-     * ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size);\n-     *\/\n-    static int fgetxattr(int filedes, byte[] name, long valueAddress,\n-                         int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native int fgetxattr0(int filedes, long nameAddress,\n-        long valueAddress, int valueLen) throws UnixException;\n-\n-    \/**\n-     *  fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags);\n-     *\/\n-    static void fsetxattr(int filedes, byte[] name, long valueAddress,\n-        int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fsetxattr0(int filedes, long nameAddress,\n-        long valueAddress, int valueLen) throws UnixException;\n-\n-    \/**\n-     * fremovexattr(int filedes, const char *name);\n-     *\/\n-    static void fremovexattr(int filedes, byte[] name) throws UnixException {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fremovexattr0(filedes, buffer.address());\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fremovexattr0(int filedes, long nameAddress)\n-        throws UnixException;\n-\n-    \/**\n-     * size_t flistxattr(int filedes, const char *list, size_t size)\n-     *\/\n-    static native int flistxattr(int filedes, long listAddress, int size)\n-        throws UnixException;\n-\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -28,13 +28,0 @@\n-import java.nio.file.*;\n-import java.nio.ByteBuffer;\n-import java.io.IOException;\n-import java.util.*;\n-import jdk.internal.misc.Unsafe;\n-\n-import static sun.nio.fs.UnixConstants.*;\n-import static sun.nio.fs.LinuxNativeDispatcher.*;\n-\n-\/**\n- * Linux implementation of UserDefinedFileAttributeView using extended attributes.\n- *\/\n-\n@@ -42,1 +29,1 @@\n-    extends AbstractUserDefinedFileAttributeView\n+    extends UnixUserDefinedFileAttributeView\n@@ -44,45 +31,0 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ namespace for extended user attributes\n-    private static final String USER_NAMESPACE = \"user.\";\n-\n-    \/\/ maximum bytes in extended attribute name (includes namespace)\n-    private static final int XATTR_NAME_MAX = 255;\n-\n-    private byte[] nameAsBytes(UnixPath file, String name) throws IOException {\n-        if (name == null)\n-            throw new NullPointerException(\"'name' is null\");\n-        name = USER_NAMESPACE + name;\n-        byte[] bytes = Util.toBytes(name);\n-        if (bytes.length > XATTR_NAME_MAX) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"'\" + name + \"' is too big\");\n-        }\n-        return bytes;\n-    }\n-\n-    \/\/ Parses buffer as array of NULL-terminated C strings.\n-    private List<String> asList(long address, int size) {\n-        List<String> list = new ArrayList<>();\n-        int start = 0;\n-        int pos = 0;\n-        while (pos < size) {\n-            if (unsafe.getByte(address + pos) == 0) {\n-                int len = pos - start;\n-                byte[] value = new byte[len];\n-                unsafe.copyMemory(null, address+start, value,\n-                    Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                String s = Util.toString(value);\n-                if (s.startsWith(USER_NAMESPACE)) {\n-                    s = s.substring(USER_NAMESPACE.length());\n-                    list.add(s);\n-                }\n-                start = pos + 1;\n-            }\n-            pos++;\n-        }\n-        return list;\n-    }\n-\n-    private final UnixPath file;\n-    private final boolean followLinks;\n@@ -91,127 +33,1 @@\n-        this.file = file;\n-        this.followLinks = followLinks;\n-    }\n-\n-    @Override\n-    public List<String> list() throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        NativeBuffer buffer = null;\n-        try {\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    int n = flistxattr(fd, buffer.address(), size);\n-                    List<String> list = asList(buffer.address(), n);\n-                    return Collections.unmodifiableList(list);\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-                    throw new FileSystemException(file.getPathForExceptionMessage(),\n-                        null, \"Unable to get list of extended attributes: \" +\n-                        x.getMessage());\n-                }\n-            }\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int size(String name) throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            \/\/ fgetxattr returns size if called with size==0\n-            return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to get size of extended attribute '\" + name +\n-                \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int read(String name, ByteBuffer dst) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        if (dst.isReadOnly())\n-            throw new IllegalArgumentException(\"Read-only buffer\");\n-        int pos = dst.position();\n-        int lim = dst.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (dst instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);\n-\n-                \/\/ if remaining is zero then fgetxattr returns the size\n-                if (rem == 0) {\n-                    if (n > 0)\n-                        throw new UnixException(ERANGE);\n-                    return 0;\n-                }\n-\n-                \/\/ copy from buffer into backing array if necessary\n-                if (nb != null) {\n-                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                    unsafe.copyMemory(null, address, dst.array(), off, n);\n-                }\n-                dst.position(pos + n);\n-                return n;\n-            } catch (UnixException x) {\n-                String msg = (x.errno() == ERANGE) ?\n-                    \"Insufficient space in buffer\" : x.getMessage();\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error reading extended attribute '\" + name + \"': \" + msg);\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+        super(file, followLinks);\n@@ -221,55 +37,2 @@\n-    public int write(String name, ByteBuffer src) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int pos = src.position();\n-        int lim = src.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (src instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)src).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-\n-            if (src.hasArray()) {\n-                \/\/ copy from backing array into buffer\n-                int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                unsafe.copyMemory(src.array(), off, null, address, rem);\n-            } else {\n-                \/\/ backing array not accessible so transfer via temporary array\n-                byte[] tmp = new byte[rem];\n-                src.get(tmp);\n-                src.position(pos);  \/\/ reset position as write may fail\n-                unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n-                    address, rem);\n-            }\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                fsetxattr(fd, nameAsBytes(file,name), address, rem);\n-                src.position(pos + rem);\n-                return rem;\n-            } catch (UnixException x) {\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error writing extended attribute '\" + name + \"': \" +\n-                    x.getMessage());\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+    protected int maxNameLength() {\n+        return 255;\n@@ -278,97 +41,0 @@\n-    @Override\n-    public void delete(String name) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            fremovexattr(fd, nameAsBytes(file,name));\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to delete extended attribute '\" + name + \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    \/**\n-     * Used by copyTo\/moveTo to copy extended attributes from source to target.\n-     *\n-     * @param   ofd\n-     *          file descriptor for source file\n-     * @param   nfd\n-     *          file descriptor for target file\n-     *\/\n-    static void copyExtendedAttributes(int ofd, int nfd) {\n-        NativeBuffer buffer = null;\n-        try {\n-\n-            \/\/ call flistxattr to get list of extended attributes.\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    size = flistxattr(ofd, buffer.address(), size);\n-                    break;\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-\n-                    \/\/ unable to get list of attributes\n-                    return;\n-                }\n-            }\n-\n-            \/\/ parse buffer as array of NULL-terminated C strings.\n-            long address = buffer.address();\n-            int start = 0;\n-            int pos = 0;\n-            while (pos < size) {\n-                if (unsafe.getByte(address + pos) == 0) {\n-                    \/\/ extract attribute name and copy attribute to target.\n-                    \/\/ FIXME: We can avoid needless copying by using address+pos\n-                    \/\/ as the address of the name.\n-                    int len = pos - start;\n-                    byte[] name = new byte[len];\n-                    unsafe.copyMemory(null, address+start, name,\n-                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                    try {\n-                        copyExtendedAttribute(ofd, name, nfd);\n-                    } catch (UnixException ignore) {\n-                        \/\/ ignore\n-                    }\n-                    start = pos + 1;\n-                }\n-                pos++;\n-            }\n-\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-        }\n-    }\n-\n-    private static void copyExtendedAttribute(int ofd, byte[] name, int nfd)\n-        throws UnixException\n-    {\n-        int size = fgetxattr(ofd, name, 0L, 0);\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n-            long address = buffer.address();\n-            size = fgetxattr(ofd, name, address, size);\n-            fsetxattr(nfd, name, address, size);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxUserDefinedFileAttributeView.java","additions":4,"deletions":338,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -39,10 +39,0 @@\n-typedef size_t fgetxattr_func(int fd, const char* name, void* value, size_t size);\n-typedef int fsetxattr_func(int fd, const char* name, void* value, size_t size, int flags);\n-typedef int fremovexattr_func(int fd, const char* name);\n-typedef int flistxattr_func(int fd, char* list, size_t size);\n-\n-fgetxattr_func* my_fgetxattr_func = NULL;\n-fsetxattr_func* my_fsetxattr_func = NULL;\n-fremovexattr_func* my_fremovexattr_func = NULL;\n-flistxattr_func* my_flistxattr_func = NULL;\n-\n@@ -65,5 +55,0 @@\n-    my_fgetxattr_func = (fgetxattr_func*)dlsym(RTLD_DEFAULT, \"fgetxattr\");\n-    my_fsetxattr_func = (fsetxattr_func*)dlsym(RTLD_DEFAULT, \"fsetxattr\");\n-    my_fremovexattr_func = (fremovexattr_func*)dlsym(RTLD_DEFAULT, \"fremovexattr\");\n-    my_flistxattr_func = (flistxattr_func*)dlsym(RTLD_DEFAULT, \"flistxattr\");\n-\n@@ -82,72 +67,0 @@\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n-{\n-    size_t res = -1;\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    if (my_fgetxattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_fgetxattr_func)(fd, name, value, valueLen);\n-    }\n-    if (res == (size_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n-{\n-    int res = -1;\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    if (my_fsetxattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_fsetxattr_func)(fd, name, value, valueLen, 0);\n-    }\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress)\n-{\n-    int res = -1;\n-    const char* name = jlong_to_ptr(nameAddress);\n-\n-    if (my_fremovexattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_fremovexattr_func)(fd, name);\n-    }\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_flistxattr(JNIEnv* env, jclass clazz,\n-    jint fd, jlong listAddress, jint size)\n-{\n-    size_t res = -1;\n-    char* list = jlong_to_ptr(listAddress);\n-\n-    if (my_flistxattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_flistxattr_func)(fd, list, (size_t)size);\n-    }\n-    if (res == (size_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n-\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -83,21 +83,0 @@\n-    \/\/ returns true if extended attributes enabled on file system where given\n-    \/\/ file resides, returns false if disabled or unable to determine.\n-    private boolean isExtendedAttributesEnabled(UnixPath path) {\n-        int fd = -1;\n-        try {\n-            fd = path.openForAttributeAccess(false);\n-\n-            \/\/ fgetxattr returns size if called with size==0\n-            byte[] name = Util.toBytes(\"user.java\");\n-            BsdNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n-            return true;\n-        } catch (UnixException e) {\n-            \/\/ attribute does not exist\n-            if (e.errno() == UnixConstants.ENOATTR)\n-                return true;\n-        } finally {\n-            UnixNativeDispatcher.close(fd);\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+        UnixUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,61 +65,0 @@\n-    \/**\n-     * ssize_t fgetxattr(int fd, const char *name, void *value, size_t size,\n-     *  u_int32_t position, int options);\n-     *\/\n-    static int fgetxattr(int fd, byte[] name, long valueAddress,\n-                         int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            return fgetxattr0(fd, buffer.address(), valueAddress, valueLen, 0L, 0);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native int fgetxattr0(int fd, long nameAddress,\n-        long valueAddress, int valueLen, long position, int options) throws UnixException;\n-\n-    \/**\n-     * int fsetxattr(int fd, const char *name, void *value, size_t size,\n-     *  u_int32_t position, int options);\n-     *\/\n-    static void fsetxattr(int fd, byte[] name, long valueAddress,\n-                          int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fsetxattr0(fd, buffer.address(), valueAddress, valueLen, 0L, 0);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fsetxattr0(int fd, long nameAddress,\n-        long valueAddress, int valueLen, long position, int options) throws UnixException;\n-\n-    \/**\n-     * int fremovexattr(int fd, const char *name, int options);\n-     *\/\n-    static void fremovexattr(int fd, byte[] name) throws UnixException {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fremovexattr0(fd, buffer.address(), 0);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fremovexattr0(int fd, long nameAddress, int options)\n-        throws UnixException;\n-\n-    \/**\n-     * ssize_t flistxattr(int fd, char *namebuf, size_t size, int options);\n-     *\/\n-    static int flistxattr(int fd, long nameBufAddress, int size) throws UnixException {\n-        return flistxattr0(fd, nameBufAddress, size, 0);\n-    }\n-\n-    private static native int flistxattr0(int fd, long nameBufAddress, int size,\n-        int options) throws UnixException;\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -28,13 +28,0 @@\n-import java.nio.file.*;\n-import java.nio.ByteBuffer;\n-import java.io.IOException;\n-import java.util.*;\n-import jdk.internal.misc.Unsafe;\n-\n-import static sun.nio.fs.UnixConstants.*;\n-import static sun.nio.fs.BsdNativeDispatcher.*;\n-\n-\/**\n- * BSD implementation of UserDefinedFileAttributeView using extended attributes.\n- *\/\n-\n@@ -42,1 +29,1 @@\n-    extends AbstractUserDefinedFileAttributeView\n+    extends UnixUserDefinedFileAttributeView\n@@ -44,46 +31,0 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ namespace for extended user attributes\n-    private static final String USER_NAMESPACE = \"user.\";\n-\n-    \/\/ maximum bytes in extended attribute name (includes namespace),\n-    \/\/ see XATTR_MAXNAMELEN in https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/sys\/xattr.h\n-    private static final int XATTR_NAME_MAX = 127;\n-\n-    private byte[] nameAsBytes(UnixPath file, String name) throws IOException {\n-        if (name == null)\n-            throw new NullPointerException(\"'name' is null\");\n-        name = USER_NAMESPACE + name;\n-        byte[] bytes = Util.toBytes(name);\n-        if (bytes.length > XATTR_NAME_MAX) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"'\" + name + \"' is too big\");\n-        }\n-        return bytes;\n-    }\n-\n-    \/\/ Parses buffer as array of NULL-terminated C strings.\n-    private List<String> asList(long address, int size) {\n-        List<String> list = new ArrayList<>();\n-        int start = 0;\n-        int pos = 0;\n-        while (pos < size) {\n-            if (unsafe.getByte(address + pos) == 0) {\n-                int len = pos - start;\n-                byte[] value = new byte[len];\n-                unsafe.copyMemory(null, address+start, value,\n-                    Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                String s = Util.toString(value);\n-                if (s.startsWith(USER_NAMESPACE)) {\n-                    s = s.substring(USER_NAMESPACE.length());\n-                    list.add(s);\n-                }\n-                start = pos + 1;\n-            }\n-            pos++;\n-        }\n-        return list;\n-    }\n-\n-    private final UnixPath file;\n-    private final boolean followLinks;\n@@ -92,127 +33,1 @@\n-        this.file = file;\n-        this.followLinks = followLinks;\n-    }\n-\n-    @Override\n-    public List<String> list() throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        NativeBuffer buffer = null;\n-        try {\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    int n = flistxattr(fd, buffer.address(), size);\n-                    List<String> list = asList(buffer.address(), n);\n-                    return Collections.unmodifiableList(list);\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-                    throw new FileSystemException(file.getPathForExceptionMessage(),\n-                        null, \"Unable to get list of extended attributes: \" +\n-                        x.getMessage());\n-                }\n-            }\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int size(String name) throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            \/\/ fgetxattr returns size if called with size==0\n-            return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to get size of extended attribute '\" + name +\n-                \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int read(String name, ByteBuffer dst) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        if (dst.isReadOnly())\n-            throw new IllegalArgumentException(\"Read-only buffer\");\n-        int pos = dst.position();\n-        int lim = dst.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (dst instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);\n-\n-                \/\/ if remaining is zero then fgetxattr returns the size\n-                if (rem == 0) {\n-                    if (n > 0)\n-                        throw new UnixException(ERANGE);\n-                    return 0;\n-                }\n-\n-                \/\/ copy from buffer into backing array if necessary\n-                if (nb != null) {\n-                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                    unsafe.copyMemory(null, address, dst.array(), off, n);\n-                }\n-                dst.position(pos + n);\n-                return n;\n-            } catch (UnixException x) {\n-                String msg = (x.errno() == ERANGE) ?\n-                    \"Insufficient space in buffer\" : x.getMessage();\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error reading extended attribute '\" + name + \"': \" + msg);\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+        super(file, followLinks);\n@@ -222,55 +37,3 @@\n-    public int write(String name, ByteBuffer src) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int pos = src.position();\n-        int lim = src.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (src instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)src).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-\n-            if (src.hasArray()) {\n-                \/\/ copy from backing array into buffer\n-                int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                unsafe.copyMemory(src.array(), off, null, address, rem);\n-            } else {\n-                \/\/ backing array not accessible so transfer via temporary array\n-                byte[] tmp = new byte[rem];\n-                src.get(tmp);\n-                src.position(pos);  \/\/ reset position as write may fail\n-                unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n-                    address, rem);\n-            }\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                fsetxattr(fd, nameAsBytes(file,name), address, rem);\n-                src.position(pos + rem);\n-                return rem;\n-            } catch (UnixException x) {\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error writing extended attribute '\" + name + \"': \" +\n-                    x.getMessage());\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+    protected int maxNameLength() {\n+        \/\/ see XATTR_MAXNAMELEN in https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/sys\/xattr.h\n+        return 127;\n@@ -279,97 +42,0 @@\n-    @Override\n-    public void delete(String name) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            fremovexattr(fd, nameAsBytes(file,name));\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to delete extended attribute '\" + name + \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    \/**\n-     * Used by copyTo\/moveTo to copy extended attributes from source to target.\n-     *\n-     * @param   ofd\n-     *          file descriptor for source file\n-     * @param   nfd\n-     *          file descriptor for target file\n-     *\/\n-    static void copyExtendedAttributes(int ofd, int nfd) {\n-        NativeBuffer buffer = null;\n-        try {\n-\n-            \/\/ call flistxattr to get list of extended attributes.\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    size = flistxattr(ofd, buffer.address(), size);\n-                    break;\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-\n-                    \/\/ unable to get list of attributes\n-                    return;\n-                }\n-            }\n-\n-            \/\/ parse buffer as array of NULL-terminated C strings.\n-            long address = buffer.address();\n-            int start = 0;\n-            int pos = 0;\n-            while (pos < size) {\n-                if (unsafe.getByte(address + pos) == 0) {\n-                    \/\/ extract attribute name and copy attribute to target.\n-                    \/\/ FIXME: We can avoid needless copying by using address+pos\n-                    \/\/ as the address of the name.\n-                    int len = pos - start;\n-                    byte[] name = new byte[len];\n-                    unsafe.copyMemory(null, address+start, name,\n-                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                    try {\n-                        copyExtendedAttribute(ofd, name, nfd);\n-                    } catch (UnixException ignore) {\n-                        \/\/ ignore\n-                    }\n-                    start = pos + 1;\n-                }\n-                pos++;\n-            }\n-\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-        }\n-    }\n-\n-    private static void copyExtendedAttribute(int ofd, byte[] name, int nfd)\n-        throws UnixException\n-    {\n-        int size = fgetxattr(ofd, name, 0L, 0);\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n-            long address = buffer.address();\n-            size = fgetxattr(ofd, name, address, size);\n-            fsetxattr(nfd, name, address, size);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdUserDefinedFileAttributeView.java","additions":5,"deletions":339,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include <sys\/xattr.h>\n@@ -228,49 +227,0 @@\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen, jlong position, jint options)\n-{\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    ssize_t res = fgetxattr(fd, name, value, valueLen, (u_int32_t)position, options);\n-    if (res == (ssize_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen, jlong position, jint options)\n-{\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    int res = fsetxattr(fd, name, value, valueLen, (u_int32_t)position, options);\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jint options)\n-{\n-    const char* name = jlong_to_ptr(nameAddress);\n-\n-    int res = fremovexattr(fd, name, options);\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_flistxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameBufAddress, jint size, jint options)\n-{\n-    char* nameBuf = jlong_to_ptr(nameBufAddress);\n-\n-    ssize_t res = flistxattr(fd, nameBuf, (size_t)size, options);\n-\n-    if (res == (ssize_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class NativeBuffer {\n+class NativeBuffer implements AutoCloseable {\n@@ -64,0 +64,5 @@\n+    @Override\n+    public void close() {\n+        release();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/NativeBuffer.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,3 +120,8 @@\n-#ifdef ENOATTR\n-    \/\/ BSD uses ENOATTR instead of ENODATA during xattr calls\n-    static final int PREFIX_ENOATTR = ENOATTR;\n+\/\/ fgetxattr error codes for absent attributes depend on the OS:\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_XATTR_NOT_FOUND = ENOATTR;\n+#elif __linux__\n+    static final int PREFIX_XATTR_NOT_FOUND = ENODATA;\n+#else\n+    \/\/ not supported (dummy values will not be used at runtime).\n+    static final int PREFIX_XATTR_NOT_FOUND = 00;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -175,0 +175,25 @@\n+    \/**\n+     * Checks whether extended attributes are enabled on the file system where the given file resides.\n+     *\n+     * @param path A path pointing to an existing node, such as the file system's root\n+     * @return <code>true<\/code> if enabled, <code>false<\/code> if disabled or unable to determine\n+     *\/\n+    protected boolean isExtendedAttributesEnabled(UnixPath path) {\n+        int fd = -1;\n+        try {\n+            fd = path.openForAttributeAccess(false);\n+\n+            \/\/ fgetxattr returns size if called with size==0\n+            byte[] name = Util.toBytes(\"user.java\");\n+            UnixNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n+            return true;\n+        } catch (UnixException e) {\n+            \/\/ attribute does not exist\n+            if (e.errno() == UnixConstants.XATTR_NOT_FOUND)\n+                return true;\n+        } finally {\n+            UnixNativeDispatcher.close(fd);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileStore.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -566,0 +566,46 @@\n+    \/**\n+     * ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size);\n+     *\/\n+    static int fgetxattr(int filedes, byte[] name, long valueAddress,\n+                         int valueLen) throws UnixException\n+    {\n+        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(name)) {\n+            return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n+        }\n+    }\n+\n+    private static native int fgetxattr0(int filedes, long nameAddress,\n+        long valueAddress, int valueLen) throws UnixException;\n+\n+    \/**\n+     *  fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags);\n+     *\/\n+    static void fsetxattr(int filedes, byte[] name, long valueAddress,\n+                          int valueLen) throws UnixException\n+    {\n+        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(name)) {\n+            fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n+        }\n+    }\n+\n+    private static native void fsetxattr0(int filedes, long nameAddress,\n+        long valueAddress, int valueLen) throws UnixException;\n+\n+    \/**\n+     * fremovexattr(int filedes, const char *name);\n+     *\/\n+    static void fremovexattr(int filedes, byte[] name) throws UnixException {\n+        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(name)) {\n+            fremovexattr0(filedes, buffer.address());\n+        }\n+    }\n+\n+    private static native void fremovexattr0(int filedes, long nameAddress)\n+        throws UnixException;\n+\n+    \/**\n+     * size_t flistxattr(int filedes, const char *list, size_t size)\n+     *\/\n+    static native int flistxattr(int filedes, long listAddress, int size)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import static sun.nio.fs.LinuxNativeDispatcher.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n@@ -38,1 +38,1 @@\n- * Linux implementation of UserDefinedFileAttributeView using extended attributes.\n+ * Unix implementation of UserDefinedFileAttributeView using extended attributes.\n@@ -40,2 +40,1 @@\n-\n-class LinuxUserDefinedFileAttributeView\n+abstract class UnixUserDefinedFileAttributeView\n@@ -49,3 +48,0 @@\n-    \/\/ maximum bytes in extended attribute name (includes namespace)\n-    private static final int XATTR_NAME_MAX = 255;\n-\n@@ -57,1 +53,1 @@\n-        if (bytes.length > XATTR_NAME_MAX) {\n+        if (bytes.length > maxNameLength()) {\n@@ -90,1 +86,1 @@\n-    LinuxUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n+    UnixUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n@@ -95,0 +91,5 @@\n+    \/**\n+     * @return the maximum supported length of xattr names (in bytes, including namespace)\n+     *\/\n+    protected abstract int maxNameLength();\n+\n@@ -220,1 +221,0 @@\n-    @Override\n@@ -375,1 +375,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":11,"deletions":11,"binary":false,"changes":22,"previous_filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxUserDefinedFileAttributeView.java","status":"copied"},{"patch":"@@ -44,0 +44,4 @@\n+#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n+#include <sys\/xattr.h>\n+#endif\n+\n@@ -1244,0 +1248,80 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n+{\n+    size_t res = -1;\n+    const char* name = jlong_to_ptr(nameAddress);\n+    void* value = jlong_to_ptr(valueAddress);\n+\n+#ifdef __linux__\n+    res = fgetxattr(fd, name, value, valueLen);\n+#elif _ALLBSD_SOURCE\n+    res = fgetxattr(fd, name, value, valueLen, 0, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == (size_t)-1)\n+        throwUnixException(env, errno);\n+    return (jint)res;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n+{\n+    int res = -1;\n+    const char* name = jlong_to_ptr(nameAddress);\n+    void* value = jlong_to_ptr(valueAddress);\n+\n+#ifdef __linux__\n+    res = fsetxattr(fd, name, value, valueLen, 0);\n+#elif _ALLBSD_SOURCE\n+    res = fsetxattr(fd, name, value, valueLen, 0, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == -1)\n+        throwUnixException(env, errno);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress)\n+{\n+    int res = -1;\n+    const char* name = jlong_to_ptr(nameAddress);\n+\n+#ifdef __linux__\n+    res = fremovexattr(fd, name);\n+#elif _ALLBSD_SOURCE\n+    res = fremovexattr(fd, name, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == -1)\n+        throwUnixException(env, errno);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_flistxattr(JNIEnv* env, jclass clazz,\n+    jint fd, jlong listAddress, jint size)\n+{\n+    size_t res = -1;\n+    char* list = jlong_to_ptr(listAddress);\n+\n+#ifdef __linux__\n+    res = flistxattr(fd, list, (size_t)size);\n+#elif _ALLBSD_SOURCE\n+    res = flistxattr(fd, list, (size_t)size, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == (size_t)-1)\n+        throwUnixException(env, errno);\n+    return (jint)res;\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"}]}