{"files":[{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classPrinter.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ClassPrinter::KlassPrintClosure : public KlassClosure {\n+  const char* _class_name_pattern;\n+  const char* _method_name_pattern;\n+  const char* _method_signature_pattern;\n+  int _flags;\n+  outputStream* _st;\n+  int _num;\n+  bool _last_printed_methods;\n+public:\n+  KlassPrintClosure(const char* class_name_pattern,\n+                    const char* method_name_pattern,\n+                    const char* method_signature_pattern,\n+                    int flags, outputStream* st)\n+    : _class_name_pattern(class_name_pattern),\n+      _method_name_pattern(method_name_pattern),\n+      _method_signature_pattern(method_signature_pattern),\n+      _flags(flags), _st(st), _num(0), _last_printed_methods(false) {}\n+\n+  virtual void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_loaded() && matches_klass(_class_name_pattern, ik)) {\n+      ResourceMark rm;\n+      if (_last_printed_methods) {\n+        _st->cr();\n+      }\n+      _last_printed_methods = false;\n+      _st->print(\"[%3d] \" INTPTR_FORMAT \" %s \", _num++, p2i(k), ik->external_name());\n+      ik->class_loader_data()->print_value_on(_st);\n+      _st->cr();\n+\n+      if (has_mode(_flags, ClassPrinter::PRINT_METHOD_NAME)) {\n+        bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n+        int len = ik->methods()->length();\n+        int num_methods_printed = 0;\n+\n+        for (int index = 0; index < len; index++) {\n+          Method* m = ik->methods()->at(index);\n+          if (_method_name_pattern != NULL &&\n+              !matches(_method_name_pattern, m->name())) {\n+            continue;\n+          }\n+          if (_method_signature_pattern != NULL &&\n+              !matches(_method_signature_pattern, m->signature())) {\n+            continue;\n+          }\n+          if (print_codes && num_methods_printed++ > 0) {\n+            _st->cr();\n+          }\n+          _st->print_cr(INTPTR_FORMAT \" %s : %s\", p2i(m),\n+                        m->name()->as_C_string(), m->signature()->as_C_string());\n+          if (print_codes) {\n+            m->print_codes_on(_st, _flags);\n+          }\n+          _last_printed_methods = true;\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+bool ClassPrinter::matches(const char *pattern, const char *candidate, int p, int c) {\n+  if (pattern[p] == '\\0') {\n+    return candidate[c] == '\\0';\n+  } else if (pattern[p] == '*') {\n+    for (; candidate[c] != '\\0'; c++) {\n+      if (matches(pattern, candidate, p+1, c))\n+        return true;\n+    }\n+    return matches(pattern, candidate, p+1, c);\n+  } else if (pattern[p] != '?' && pattern[p] != candidate[c]) {\n+    return false;\n+  }  else {\n+    return matches(pattern, candidate, p+1, c+1);\n+  }\n+}\n+\n+bool ClassPrinter::matches(const char* pattern, Symbol* symbol) {\n+  if (strchr(pattern, '*') == NULL) {\n+    return symbol->equals(pattern);\n+  } else {\n+    ResourceMark rm;\n+    char* buf = symbol->as_C_string();\n+    return matches(pattern, buf, 0, 0);\n+  }\n+}\n+\n+bool ClassPrinter::matches_klass(const char* pattern, InstanceKlass* ik) {\n+  if (ik->is_hidden()) {\n+    ResourceMark rm;\n+    return matches(pattern, ik->external_name(), 0, 0);\n+  } else {\n+    return matches(pattern, ik->name());\n+  }\n+}\n+\n+\n+void ClassPrinter::print_classes_unlocked(const char* class_name_pattern, int flags) {\n+  KlassPrintClosure closure(class_name_pattern, NULL, NULL, flags, tty);\n+  ClassLoaderDataGraph::classes_do(&closure);\n+}\n+\n+void ClassPrinter::print_methods_unlocked(const char* class_name_pattern,\n+                                          const char* method_name_pattern, int flags) {\n+  KlassPrintClosure closure(class_name_pattern, method_name_pattern, NULL,\n+                            flags | PRINT_METHOD_NAME, tty);\n+  ClassLoaderDataGraph::classes_do(&closure);\n+\n+}\n+\n+void ClassPrinter::print_methods_unlocked(const char* class_name_pattern,\n+                                          const char* method_name_pattern,\n+                                          const char* method_signature_pattern, int flags) {\n+  KlassPrintClosure closure(class_name_pattern, method_name_pattern, method_signature_pattern,\n+                            flags | PRINT_METHOD_NAME, tty);\n+  ClassLoaderDataGraph::classes_do(&closure);\n+}\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.cpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_CLASSPRINTER_HPP\n+#define SHARE_CLASSFILE_CLASSPRINTER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+\n+\/\/ ClassPrinter is intended to be called from findclass\/findmethod\/findmethod2\n+\/\/ in debug.cpp (inside a debugger, such as gdb). To avoid deadlocks (as the JVM\n+\/\/ may be at an arbitrary native breakpoint), ClassPrinter calls\n+\/\/ ClassLoaderDataGraph::classes_do without holding any locks. The down side is\n+\/\/ that the printing may proceed while other threads are running, so race conditions\n+\/\/ are possible. Use with care.\n+\/\/\n+\/\/ If you want to call these functions programmatically, make sure the caller\n+\/\/ holds the appropriate locks.\n+class ClassPrinter : public AllStatic {\n+  class KlassPrintClosure;\n+\n+  static bool matches(const char *pattern, const char *candidate, int p, int c);\n+  static bool matches(const char* pattern, Symbol* symbol);\n+  static bool matches_klass(const char* pattern, InstanceKlass* ik);\n+\n+public:\n+\n+  enum Mode : int {\n+    PRINT_METHOD_NAME       = 1 << 0,\n+    PRINT_BYTECODE          = 1 << 1,\n+    PRINT_BYTECODE_ADDR     = 1 << 2,\n+    PRINT_DYNAMIC           = 1 << 3, \/\/ extra information for invokedynamic (and dynamic constant ...)\n+  };\n+\n+  \/\/ flags must be OR'ed from ClassPrinter::Mode for the next 3 functions\n+  static void print_classes_unlocked(const char* class_name_pattern, int flags);\n+  static void print_methods_unlocked(const char* class_name_pattern,\n+                                     const char* method_name_pattern, int flags);\n+  static void print_methods_unlocked(const char* class_name_pattern,\n+                                     const char* method_name_pattern,\n+                                     const char* method_signature_pattern, int flags);\n+\n+  static bool has_mode(int flags, Mode mode) {\n+    return (flags & static_cast<int>(mode)) != 0;\n+  }\n+};\n+\n+#endif \/\/ SHARE_CLASSFILE_CLASSPRINTER_HPP\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -36,0 +38,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n@@ -41,0 +44,1 @@\n+\/\/ Prints the current bytecode and its attributes using bytecode-specific information.\n@@ -42,4 +46,1 @@\n-\/\/ Standard closure for BytecodeTracer: prints the current bytecode\n-\/\/ and its attributes using bytecode-specific information.\n-\n-class BytecodePrinter: public BytecodeClosure {\n+class BytecodePrinter {\n@@ -55,0 +56,1 @@\n+  int       _flags;\n@@ -77,0 +79,1 @@\n+  void      print_constant_nocheck(int i, outputStream* st = tty);\n@@ -83,1 +86,1 @@\n-  BytecodePrinter() {\n+  BytecodePrinter(int flags = 0) {\n@@ -86,0 +89,1 @@\n+    _flags = flags;\n@@ -144,0 +148,3 @@\n+    if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_BYTECODE_ADDR)) {\n+      st->print(INTPTR_FORMAT \" \", p2i(bcp));\n+    }\n@@ -145,1 +152,1 @@\n-      st->print(\"%d %s_w\", bci, Bytecodes::name(code));\n+      st->print(\"%4d %s_w\", bci, Bytecodes::name(code));\n@@ -147,1 +154,1 @@\n-      st->print(\"%d %s\", bci, Bytecodes::name(code));\n+      st->print(\"%4d %s\", bci, Bytecodes::name(code));\n@@ -155,0 +162,3 @@\n+\/\/ We need a global instance to keep track of the states when the bytecodes\n+\/\/ are executed. Access by multiple threads are controlled by ttyLocker.\n+static BytecodePrinter _interpreter_printer;\n@@ -156,21 +166,1 @@\n-\/\/ Implementation of BytecodeTracer\n-\n-\/\/ %%% This set_closure thing seems overly general, given that\n-\/\/ nobody uses it.  Also, if BytecodePrinter weren't hidden\n-\/\/ then Method* could use instances of it directly and it\n-\/\/ would be easier to remove races on _current_method and bcp.\n-\/\/ Since this is not product functionality, we can defer cleanup.\n-\n-BytecodeClosure* BytecodeTracer::_closure = NULL;\n-\n-static BytecodePrinter std_closure;\n-BytecodeClosure* BytecodeTracer::std_closure() {\n-  return &::std_closure;\n-}\n-\n-\n-void BytecodeTracer::trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {\n-  if (_closure == NULL) {\n-    return;\n-  }\n-\n+void BytecodeTracer::trace_interpreter(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {\n@@ -181,3 +171,0 @@\n-    \/\/ Using the ttyLocker prevents the system from coming to\n-    \/\/ a safepoint within this code, which is sensitive to Method*\n-    \/\/ movement.\n@@ -187,5 +174,1 @@\n-    \/\/\n-    \/\/ We put the locker on the static trace method, not the\n-    \/\/ virtual one, because the clients of this module go through\n-    \/\/ the static method.\n-    _closure->trace(method, bcp, tos, tos2, st);\n+    _interpreter_printer.trace(method, bcp, tos, tos2, st);\n@@ -195,4 +178,4 @@\n-void BytecodeTracer::trace(const methodHandle& method, address bcp, outputStream* st) {\n-  if (_closure == NULL) {\n-    return;\n-  }\n+void BytecodeTracer::print_method_codes(const methodHandle& method, int from, int to, outputStream* st, int flags) {\n+  BytecodePrinter method_printer(flags);\n+  BytecodeStream s(method);\n+  s.set_interval(from, to);\n@@ -200,2 +183,4 @@\n-  ttyLocker ttyl;  \/\/ 5065316: keep the following output coherent\n-  _closure->trace(method, bcp, st);\n+  ttyLocker ttyl;  \/\/ keep the following output coherent\n+  while (s.next() >= 0) {\n+    method_printer.trace(method, s.bcp(), st);\n+  }\n@@ -327,0 +312,4 @@\n+  print_constant_nocheck(i, st);\n+}\n+\n+void BytecodePrinter::print_constant_nocheck(int i, outputStream* st) {\n@@ -399,1 +388,0 @@\n-}\n@@ -401,0 +389,51 @@\n+  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC) &&\n+      (tag.is_dynamic_constant() || tag.is_invoke_dynamic())) {\n+    int bsm = constants->bootstrap_method_ref_index_at(i);\n+    const char* ref_kind = \"\";\n+    switch (constants->method_handle_ref_kind_at(bsm)) {\n+    case JVM_REF_getField         : ref_kind = \"REF_getField\"; break;\n+    case JVM_REF_getStatic        : ref_kind = \"REF_getStatic\"; break;\n+    case JVM_REF_putField         : ref_kind = \"REF_putField\"; break;\n+    case JVM_REF_putStatic        : ref_kind = \"REF_putStatic\"; break;\n+    case JVM_REF_invokeVirtual    : ref_kind = \"REF_invokeVirtual\"; break;\n+    case JVM_REF_invokeStatic     : ref_kind = \"REF_invokeStatic\"; break;\n+    case JVM_REF_invokeSpecial    : ref_kind = \"REF_invokeSpecial\"; break;\n+    case JVM_REF_newInvokeSpecial : ref_kind = \"REF_newInvokeSpecial\"; break;\n+    case JVM_REF_invokeInterface  : ref_kind = \"REF_invokeInterface\"; break;\n+    default                       : ShouldNotReachHere();\n+    }\n+    st->print(\"  BSM: %s\", ref_kind);\n+    print_field_or_method(-i, constants->method_handle_index_at(bsm), st);\n+    int argc = constants->bootstrap_argument_count_at(i);\n+    st->print(\"  arguments[%d] = {\", argc);\n+    if (argc > 0) {\n+      st->cr();\n+      for (int arg_i = 0; arg_i < argc; arg_i++) {\n+        int arg = constants->bootstrap_argument_index_at(i, arg_i);\n+        st->print(\"    \");\n+        print_constant_nocheck(arg);\n+      }\n+    }\n+    st->print_cr(\"  }\");\n+    if (tag.is_invoke_dynamic()) {\n+      int indy_index = orig_i;\n+      ConstantPoolCacheEntry* cpce = constants->invokedynamic_cp_cache_entry_at(indy_index);\n+      int cp_cache_index = constants->invokedynamic_cp_cache_index(indy_index);\n+      st->print(\"  ConstantPoolCacheEntry: \");\n+      cpce->print(st, cp_cache_index);\n+      constantPoolHandle cph(Thread::current(), constants);\n+      Method* m = cpce->method_if_resolved(cph);\n+      oop appendix = cpce->appendix_if_resolved(cph);\n+      if (m != NULL) {\n+        st->print_cr(\"  Method: %s.%s%s\", m->method_holder()->name()->as_C_string(),\n+                     m->name()->as_C_string(), m->signature()->as_C_string());\n+      }\n+      if (appendix != NULL) {\n+        st->print(\"  appendix: \");\n+        appendix->print_on(st);\n+      }\n+    } else {\n+      \/\/ TODO: print info for tag.is_dynamic_constant()\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":82,"deletions":43,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,1 +32,1 @@\n-\/\/ bytecode tracing. If bytecode tracing is turned on, trace() will be called\n+\/\/ bytecode tracing. If TraceBytecodes turned on, trace_interpreter() will be called\n@@ -34,5 +34,0 @@\n-\/\/\n-\/\/ By specialising the BytecodeClosure, all kinds of bytecode traces can\n-\/\/ be done.\n-\n-\/\/ class BytecodeTracer is used by TraceBytecodes option and PrintMethodData\n@@ -41,0 +36,1 @@\n+class outputStream;\n@@ -44,16 +40,0 @@\n- private:\n-  static BytecodeClosure* _closure;\n-\n- public:\n-  static BytecodeClosure* std_closure();                        \/\/ a printing closure\n-  static BytecodeClosure* closure()                                                   { return _closure; }\n-  static void             set_closure(BytecodeClosure* closure) { _closure = closure; }\n-\n-  static void             trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st = tty);\n-  static void             trace(const methodHandle& method, address bcp, outputStream* st = tty);\n-};\n-\n-\n-\/\/ For each bytecode, a BytecodeClosure's trace() routine will be called.\n-\n-class BytecodeClosure {\n@@ -61,2 +41,2 @@\n-  virtual void trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) = 0;\n-  virtual void trace(const methodHandle& method, address bcp, outputStream* st) = 0;\n+  static void trace_interpreter(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st = tty);\n+  static void print_method_codes(const methodHandle& method, int from, int to, outputStream* st, int flags);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.hpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,3 +138,0 @@\n-#ifndef PRODUCT\n-  if (TraceBytecodes) BytecodeTracer::set_closure(BytecodeTracer::std_closure());\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"interpreter\/bytecodeTracer.hpp\"\n@@ -1516,1 +1517,1 @@\n-  BytecodeTracer::trace(mh, last_frame.bcp(), tos, tos2);\n+  BytecodeTracer::trace_interpreter(mh, last_frame.bcp(), tos, tos2);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n-  friend class BytecodeClosure; \/\/ for method and bcp\n-  friend class PrintingClosure; \/\/ for method and bcp\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1835,2 +1835,2 @@\n-void Method::print_codes_on(outputStream* st) const {\n-  print_codes_on(0, code_size(), st);\n+void Method::print_codes_on(outputStream* st, int flags) const {\n+  print_codes_on(0, code_size(), st, flags);\n@@ -1839,1 +1839,1 @@\n-void Method::print_codes_on(int from, int to, outputStream* st) const {\n+void Method::print_codes_on(int from, int to, outputStream* st, int flags) const {\n@@ -1843,4 +1843,1 @@\n-  BytecodeStream s(mh);\n-  s.set_interval(from, to);\n-  BytecodeTracer::set_closure(BytecodeTracer::std_closure());\n-  while (s.next() >= 0) BytecodeTracer::trace(mh, s.bcp(), st);\n+  BytecodeTracer::print_method_codes(mh, from, to, st, flags);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -541,3 +541,3 @@\n-  void print_codes() const            { print_codes_on(tty); }\n-  void print_codes_on(outputStream* st) const;\n-  void print_codes_on(int from, int to, outputStream* st) const;\n+  void print_codes(int flags = 0) const { print_codes_on(tty, flags); }\n+  void print_codes_on(outputStream* st, int flags = 0) const;\n+  void print_codes_on(int from, int to, outputStream* st, int flags = 0) const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"interpreter\/bytecodeTracer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -639,0 +640,23 @@\n+\/\/ flags must be OR'ed from ClassPrinter::Mode for the next 3 functions.\n+\/\/ Examples (in gdb):\n+\/\/   call findclass(\"java\/lang\/Object\", 0x3)\n+\/\/   call findmethod(\"*ang\/Object*\", \"wait\", 0x7)\n+\/\/   call findmethod2(\"*ang\/Object*\", \"wait\", \"(J*\", 0x1)\n+extern \"C\" JNIEXPORT void findclass(const char* class_name_pattern, int flags) {\n+  Command c(\"findclass\");\n+  ClassPrinter::print_classes_unlocked(class_name_pattern, flags);\n+}\n+\n+extern \"C\" JNIEXPORT void findmethod(const char* class_name_pattern,\n+                                     const char* method_name_pattern, int flags) {\n+  Command c(\"findmethod\");\n+  ClassPrinter::print_methods_unlocked(class_name_pattern, method_name_pattern, flags);\n+}\n+\n+extern \"C\" JNIEXPORT void findmethod2(const char* class_name_pattern,\n+                                      const char* method_name_pattern,\n+                                      const char* method_signature_pattern, int flags) {\n+  Command c(\"findmethod2\");\n+  ClassPrinter::print_methods_unlocked(class_name_pattern, method_name_pattern,\n+                                       method_signature_pattern, flags);\n+}\n@@ -640,1 +664,1 @@\n-\/\/ Need method pointer to find bcp, when not in permgen.\n+\/\/ Need method pointer to find bcp\n@@ -673,0 +697,4 @@\n+  tty->print_cr(\"class metadata.\");\n+  tty->print_cr(\"  findclass(name, flags)\");\n+  tty->print_cr(\"  findmethod(classname, methodname, flags)\");\n+  tty->print_cr(\"  findmethod2(classname, methodname, methodsig, flags)\");\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}