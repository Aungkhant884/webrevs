{"files":[{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classPrinter.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ClassPrinter::KlassPrintClosure : public LockedClassesDo {\n+  const char* _class_name_pattern;\n+  const char* _method_name_pattern;\n+  const char* _method_signature_pattern;\n+  bool _always_print_class_name;\n+  int _flags;\n+  outputStream* _st;\n+  int _num;\n+  bool _has_printed_methods;\n+public:\n+  KlassPrintClosure(const char* class_name_pattern,\n+                    const char* method_name_pattern,\n+                    const char* method_signature_pattern,\n+                    bool always_print_class_name,\n+                    int flags, outputStream* st)\n+    : _class_name_pattern(class_name_pattern),\n+      _method_name_pattern(method_name_pattern),\n+      _method_signature_pattern(method_signature_pattern),\n+      _always_print_class_name(always_print_class_name),\n+      _flags(flags), _st(st), _num(0), _has_printed_methods(false)\n+  {\n+    if (has_mode(_flags, PRINT_METHOD_HANDLE)) {\n+      _flags |= (PRINT_METHOD_NAME | PRINT_BYTECODE);\n+    }\n+    if (has_mode(_flags, PRINT_DYNAMIC)) {\n+      _flags |= (PRINT_METHOD_NAME | PRINT_BYTECODE);\n+    }\n+    if (has_mode(_flags, PRINT_BYTECODE_ADDR)) {\n+      _flags |= (PRINT_METHOD_NAME | PRINT_BYTECODE);\n+    }\n+    if (has_mode(_flags, PRINT_BYTECODE)) {\n+      _flags |= (PRINT_METHOD_NAME);\n+    }\n+  }\n+\n+  virtual void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    print_instance_klass(InstanceKlass::cast(k));\n+  }\n+\n+  static bool match(const char* pattern, Symbol* sym) {\n+    return (pattern == NULL || sym->is_star_match(pattern));\n+  }\n+\n+  void print_klass_name(InstanceKlass* ik) {\n+    _st->print(\"[%3d] \" INTPTR_FORMAT \" class %s \", _num++, p2i(ik), ik->name()->as_C_string());\n+    ik->class_loader_data()->print_value_on(_st);\n+    _st->cr();\n+  }\n+\n+  void print_instance_klass(InstanceKlass* ik) {\n+    if (ik->is_loaded() && ik->name()->is_star_match(_class_name_pattern)) {\n+      ResourceMark rm;\n+      if (_has_printed_methods) {\n+        \/\/ We have printed some methods in the previous class.\n+        \/\/ Print a new line to separate the two classes\n+        _st->cr();\n+      }\n+      _has_printed_methods = false;\n+      if (_always_print_class_name) {\n+        print_klass_name(ik);\n+      }\n+\n+      if (has_mode(_flags, ClassPrinter::PRINT_METHOD_NAME)) {\n+        bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n+        int len = ik->methods()->length();\n+        int num_methods_printed = 0;\n+\n+        for (int index = 0; index < len; index++) {\n+          Method* m = ik->methods()->at(index);\n+          if (match(_method_name_pattern, m->name()) &&\n+              match(_method_signature_pattern, m->signature())) {\n+            if (print_codes && num_methods_printed++ > 0) {\n+              _st->cr();\n+            }\n+\n+            if (_has_printed_methods == false) {\n+              if (!_always_print_class_name) {\n+                print_klass_name(ik);\n+              }\n+              _has_printed_methods = true;\n+            }\n+            print_method(m);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  void print_method(Method* m) {\n+    bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n+    _st->print_cr(INTPTR_FORMAT \" %smethod %s : %s\", p2i(m),\n+                  m->is_static() ? \"static \" : \"\",\n+                  m->name()->as_C_string(), m->signature()->as_C_string());\n+    if (print_codes) {\n+      m->print_codes_on(_st, _flags);\n+    }\n+  }\n+};\n+\n+void ClassPrinter::print_flags_help(outputStream* os) {\n+  os->print_cr(\"flags (bitmask):\");\n+  os->print_cr(\"   0x%02x  - print names of methods\", PRINT_METHOD_NAME);\n+  os->print_cr(\"   0x%02x  - print bytecodes\", PRINT_BYTECODE);\n+  os->print_cr(\"   0x%02x  - print the address of bytecodes\", PRINT_BYTECODE_ADDR);\n+  os->print_cr(\"   0x%02x  - print info for invokedynamic\", PRINT_DYNAMIC);\n+  os->print_cr(\"   0x%02x  - print info for invokehandle\",  PRINT_METHOD_HANDLE);\n+  os->cr();\n+}\n+\n+void ClassPrinter::print_classes(const char* class_name_pattern, int flags, outputStream* os) {\n+  KlassPrintClosure closure(class_name_pattern, NULL, NULL, true, flags, os);\n+  ClassLoaderDataGraph::classes_do(&closure);\n+}\n+\n+void ClassPrinter::print_methods(const char* class_name_pattern,\n+                                 const char* method_pattern, int flags, outputStream* os) {\n+  ResourceMark rm;\n+  const char* method_name_pattern;\n+  const char* method_signature_pattern;\n+\n+  const char* colon = strchr(method_pattern, ':');\n+  if (colon == NULL) {\n+    method_name_pattern = method_pattern;\n+    method_signature_pattern = NULL;\n+  } else {\n+    ptrdiff_t name_pat_len = colon - method_pattern;\n+    assert(name_pat_len >= 0, \"sanity\");\n+    char* buf = NEW_RESOURCE_ARRAY(char, name_pat_len + 1);\n+    strncpy(buf, method_pattern, name_pat_len);\n+    buf[name_pat_len] = 0;\n+\n+    method_name_pattern = buf;\n+    method_signature_pattern = colon + 1;\n+  }\n+\n+  KlassPrintClosure closure(class_name_pattern, method_name_pattern, method_signature_pattern,\n+                            false, flags | PRINT_METHOD_NAME, os);\n+  ClassLoaderDataGraph::classes_do(&closure);\n+}\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_CLASSPRINTER_HPP\n+#define SHARE_CLASSFILE_CLASSPRINTER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class outputStream;\n+class Symbol;\n+\n+\/\/ ClassPrinter is intended to be called from findclass() and findmethod()\n+\/\/ in debug.cpp (inside a debugger, such as gdb).\n+\/\/\n+\/\/ The ClassPrinter::print_xxx() functions hold the ClassLoaderDataGraph_lock\n+\/\/ (and the ttyLocker if ClassPrinter::PRINT_BYTECODE is selected). A deadlock\n+\/\/ may happen if these functions are called in a context where these locks\n+\/\/ are already held. Use with caution.\n+\n+class ClassPrinter : public AllStatic {\n+  class KlassPrintClosure;\n+\n+public:\n+\n+  enum Mode : int {\n+    PRINT_METHOD_NAME       = 1 << 0,\n+    PRINT_BYTECODE          = 1 << 1,\n+    PRINT_BYTECODE_ADDR     = 1 << 2,\n+    PRINT_DYNAMIC           = 1 << 3, \/\/ extra information for invokedynamic (and dynamic constant ...)\n+    PRINT_METHOD_HANDLE     = 1 << 4, \/\/ extra information for invokehandle\n+  };\n+  static bool has_mode(int flags, Mode mode) {\n+    return (flags & static_cast<int>(mode)) != 0;\n+  }\n+\n+  static void print_flags_help(outputStream* os);\n+\n+  \/\/ flags must be OR'ed from ClassPrinter::Mode for the these two functions\n+  static void print_classes(const char* class_name_pattern, int flags, outputStream* os);\n+  static void print_methods(const char* class_name_pattern,\n+                            const char* method_name_pattern, int flags, outputStream* os);\n+};\n+\n+#endif \/\/ SHARE_CLASSFILE_CLASSPRINTER_HPP\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -36,0 +38,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n@@ -41,0 +44,1 @@\n+\/\/ Prints the current bytecode and its attributes using bytecode-specific information.\n@@ -42,4 +46,1 @@\n-\/\/ Standard closure for BytecodeTracer: prints the current bytecode\n-\/\/ and its attributes using bytecode-specific information.\n-\n-class BytecodePrinter: public BytecodeClosure {\n+class BytecodePrinter {\n@@ -55,0 +56,1 @@\n+  int       _flags;\n@@ -72,9 +74,13 @@\n-  bool      check_index(int i, int& cp_index, outputStream* st = tty);\n-  bool      check_cp_cache_index(int i, int& cp_index, outputStream* st = tty);\n-  bool      check_obj_index(int i, int& cp_index, outputStream* st = tty);\n-  bool      check_invokedynamic_index(int i, int& cp_index, outputStream* st = tty);\n-  void      print_constant(int i, outputStream* st = tty);\n-  void      print_field_or_method(int i, outputStream* st = tty);\n-  void      print_field_or_method(int orig_i, int i, outputStream* st = tty);\n-  void      print_attributes(int bci, outputStream* st = tty);\n-  void      bytecode_epilog(int bci, outputStream* st = tty);\n+  bool      check_index(int i, int& cp_index, outputStream* st);\n+  bool      check_cp_cache_index(int i, int& cp_index, outputStream* st);\n+  bool      check_obj_index(int i, int& cp_index, outputStream* st);\n+  bool      check_invokedynamic_index(int i, int& cp_index, outputStream* st);\n+  void      print_constant(int i, outputStream* st);\n+  void      print_constant_nocheck(int i, outputStream* st);\n+  void      print_cpcache_entry(int cpc_index, outputStream* st);\n+  void      print_dynamic(int orig_i, int i, constantTag tag, outputStream* st);\n+  void      print_field_or_method(int i, outputStream* st);\n+  void      print_field_or_method(int orig_i, int i, outputStream* st);\n+  void      print_invoke_handle(int i, outputStream* st);\n+  void      print_attributes(int bci, outputStream* st);\n+  void      bytecode_epilog(int bci, outputStream* st);\n@@ -83,1 +89,1 @@\n-  BytecodePrinter() {\n+  BytecodePrinter(int flags = 0) {\n@@ -86,0 +92,1 @@\n+    _flags = flags;\n@@ -123,1 +130,1 @@\n-    print_attributes(bci);\n+    print_attributes(bci, st);\n@@ -144,0 +151,3 @@\n+    if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_BYTECODE_ADDR)) {\n+      st->print(INTPTR_FORMAT \" \", p2i(bcp));\n+    }\n@@ -145,1 +155,1 @@\n-      st->print(\"%d %s_w\", bci, Bytecodes::name(code));\n+      st->print(\"%4d %s_w\", bci, Bytecodes::name(code));\n@@ -147,1 +157,1 @@\n-      st->print(\"%d %s\", bci, Bytecodes::name(code));\n+      st->print(\"%4d %s\", bci, Bytecodes::name(code));\n@@ -155,0 +165,3 @@\n+\/\/ We need a global instance to keep track of the states when the bytecodes\n+\/\/ are executed. Access by multiple threads are controlled by ttyLocker.\n+static BytecodePrinter _interpreter_printer;\n@@ -156,21 +169,1 @@\n-\/\/ Implementation of BytecodeTracer\n-\n-\/\/ %%% This set_closure thing seems overly general, given that\n-\/\/ nobody uses it.  Also, if BytecodePrinter weren't hidden\n-\/\/ then Method* could use instances of it directly and it\n-\/\/ would be easier to remove races on _current_method and bcp.\n-\/\/ Since this is not product functionality, we can defer cleanup.\n-\n-BytecodeClosure* BytecodeTracer::_closure = NULL;\n-\n-static BytecodePrinter std_closure;\n-BytecodeClosure* BytecodeTracer::std_closure() {\n-  return &::std_closure;\n-}\n-\n-\n-void BytecodeTracer::trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {\n-  if (_closure == NULL) {\n-    return;\n-  }\n-\n+void BytecodeTracer::trace_interpreter(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) {\n@@ -181,3 +174,0 @@\n-    \/\/ Using the ttyLocker prevents the system from coming to\n-    \/\/ a safepoint within this code, which is sensitive to Method*\n-    \/\/ movement.\n@@ -187,5 +177,1 @@\n-    \/\/\n-    \/\/ We put the locker on the static trace method, not the\n-    \/\/ virtual one, because the clients of this module go through\n-    \/\/ the static method.\n-    _closure->trace(method, bcp, tos, tos2, st);\n+    _interpreter_printer.trace(method, bcp, tos, tos2, st);\n@@ -195,4 +181,4 @@\n-void BytecodeTracer::trace(const methodHandle& method, address bcp, outputStream* st) {\n-  if (_closure == NULL) {\n-    return;\n-  }\n+void BytecodeTracer::print_method_codes(const methodHandle& method, int from, int to, outputStream* st, int flags) {\n+  BytecodePrinter method_printer(flags);\n+  BytecodeStream s(method);\n+  s.set_interval(from, to);\n@@ -200,2 +186,4 @@\n-  ttyLocker ttyl;  \/\/ 5065316: keep the following output coherent\n-  _closure->trace(method, bcp, st);\n+  ttyLocker ttyl;  \/\/ keep the following output coherent\n+  while (s.next() >= 0) {\n+    method_printer.trace(method, s.bcp(), st);\n+  }\n@@ -327,0 +315,4 @@\n+  print_constant_nocheck(i, st);\n+}\n+\n+void BytecodePrinter::print_constant_nocheck(int i, outputStream* st) {\n@@ -399,0 +391,43 @@\n+\n+  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC) &&\n+      (tag.is_dynamic_constant() || tag.is_invoke_dynamic())) {\n+    print_dynamic(orig_i, i, tag, st);\n+  }\n+}\n+\n+void BytecodePrinter::print_dynamic(int orig_i, int bsm_cpindex, constantTag tag, outputStream* st) {\n+  ConstantPool* constants = method()->constants();\n+  int bsm = constants->bootstrap_method_ref_index_at(bsm_cpindex);\n+  const char* ref_kind = \"\";\n+  switch (constants->method_handle_ref_kind_at(bsm)) {\n+  case JVM_REF_getField         : ref_kind = \"REF_getField\"; break;\n+  case JVM_REF_getStatic        : ref_kind = \"REF_getStatic\"; break;\n+  case JVM_REF_putField         : ref_kind = \"REF_putField\"; break;\n+  case JVM_REF_putStatic        : ref_kind = \"REF_putStatic\"; break;\n+  case JVM_REF_invokeVirtual    : ref_kind = \"REF_invokeVirtual\"; break;\n+  case JVM_REF_invokeStatic     : ref_kind = \"REF_invokeStatic\"; break;\n+  case JVM_REF_invokeSpecial    : ref_kind = \"REF_invokeSpecial\"; break;\n+  case JVM_REF_newInvokeSpecial : ref_kind = \"REF_newInvokeSpecial\"; break;\n+  case JVM_REF_invokeInterface  : ref_kind = \"REF_invokeInterface\"; break;\n+  default                       : ShouldNotReachHere();\n+  }\n+  st->print(\"  BSM: %s\", ref_kind);\n+  print_field_or_method(-1, constants->method_handle_index_at(bsm), st);\n+  int argc = constants->bootstrap_argument_count_at(bsm_cpindex);\n+  st->print(\"  arguments[%d] = {\", argc);\n+  if (argc > 0) {\n+    st->cr();\n+    for (int arg_i = 0; arg_i < argc; arg_i++) {\n+      int arg = constants->bootstrap_argument_index_at(bsm_cpindex, arg_i);\n+      st->print(\"    \");\n+      print_constant_nocheck(arg, st);\n+    }\n+  }\n+  st->print_cr(\"  }\");\n+  if (tag.is_invoke_dynamic()) {\n+    int indy_index = orig_i;\n+    int cpc_index = constants->invokedynamic_cp_cache_index(indy_index);\n+    print_cpcache_entry(cpc_index, st);\n+  } else {\n+    \/\/ TODO: print info for tag.is_dynamic_constant()\n+  }\n@@ -401,0 +436,10 @@\n+void BytecodePrinter::print_invoke_handle(int i, outputStream* st) {\n+  print_cpcache_entry(ConstantPool::decode_cpcache_index(i), st);\n+}\n+\n+void BytecodePrinter::print_cpcache_entry(int cpc_index, outputStream* st) {\n+  ConstantPool* constants = method()->constants();\n+  ConstantPoolCacheEntry* cpce = constants->cache()->entry_at(cpc_index);\n+  st->print(\"  ConstantPoolCacheEntry: \");\n+  cpce->print(st, cpc_index, constants->cache());\n+}\n@@ -562,1 +607,8 @@\n-      print_field_or_method(get_index_u2_cpcache(), st);\n+      {\n+        int i = get_index_u2_cpcache();\n+        print_field_or_method(i, st);\n+        if (raw_code() == Bytecodes::_invokehandle &&\n+            ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_METHOD_HANDLE)) {\n+          print_invoke_handle(i, st);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":105,"deletions":53,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,1 +32,1 @@\n-\/\/ bytecode tracing. If bytecode tracing is turned on, trace() will be called\n+\/\/ bytecode tracing. If TraceBytecodes turned on, trace_interpreter() will be called\n@@ -34,5 +34,0 @@\n-\/\/\n-\/\/ By specialising the BytecodeClosure, all kinds of bytecode traces can\n-\/\/ be done.\n-\n-\/\/ class BytecodeTracer is used by TraceBytecodes option and PrintMethodData\n@@ -41,0 +36,1 @@\n+class outputStream;\n@@ -44,16 +40,0 @@\n- private:\n-  static BytecodeClosure* _closure;\n-\n- public:\n-  static BytecodeClosure* std_closure();                        \/\/ a printing closure\n-  static BytecodeClosure* closure()                                                   { return _closure; }\n-  static void             set_closure(BytecodeClosure* closure) { _closure = closure; }\n-\n-  static void             trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st = tty);\n-  static void             trace(const methodHandle& method, address bcp, outputStream* st = tty);\n-};\n-\n-\n-\/\/ For each bytecode, a BytecodeClosure's trace() routine will be called.\n-\n-class BytecodeClosure {\n@@ -61,2 +41,2 @@\n-  virtual void trace(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st) = 0;\n-  virtual void trace(const methodHandle& method, address bcp, outputStream* st) = 0;\n+  static void trace_interpreter(const methodHandle& method, address bcp, uintptr_t tos, uintptr_t tos2, outputStream* st = tty);\n+  static void print_method_codes(const methodHandle& method, int from, int to, outputStream* st, int flags);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.hpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,3 +138,0 @@\n-#ifndef PRODUCT\n-  if (TraceBytecodes) BytecodeTracer::set_closure(BytecodeTracer::std_closure());\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"interpreter\/bytecodeTracer.hpp\"\n@@ -1512,1 +1513,1 @@\n-  BytecodeTracer::trace(mh, last_frame.bcp(), tos, tos2);\n+  BytecodeTracer::trace_interpreter(mh, last_frame.bcp(), tos, tos2);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n-  friend class BytecodeClosure; \/\/ for method and bcp\n-  friend class PrintingClosure; \/\/ for method and bcp\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-    this->print(log_stream, 0);\n+    this->print(log_stream, 0, cpool->cache());\n@@ -483,1 +483,1 @@\n-Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle& cpool) {\n+Method* ConstantPoolCacheEntry::method_if_resolved(const constantPoolHandle& cpool) const {\n@@ -530,1 +530,1 @@\n-oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle& cpool) {\n+oop ConstantPoolCacheEntry::appendix_if_resolved(const constantPoolHandle& cpool) const {\n@@ -623,1 +623,1 @@\n-void ConstantPoolCacheEntry::print(outputStream* st, int index) const {\n+void ConstantPoolCacheEntry::print(outputStream* st, int index, const ConstantPoolCache* cache) const {\n@@ -633,0 +633,19 @@\n+\n+  if ((bytecode_1() == Bytecodes::_invokehandle ||\n+       bytecode_1() == Bytecodes::_invokedynamic)) {\n+    constantPoolHandle cph(Thread::current(), cache->constant_pool());\n+    Method* m = method_if_resolved(cph);\n+    oop appendix = appendix_if_resolved(cph);\n+    ResourceMark rm;\n+    if (m != NULL) {\n+      st->print_cr(\"  Method%s: \" INTPTR_FORMAT \" %s.%s%s\",\n+                   m->is_native() ? \" (native)\" : \"\",\n+                   p2i(m),\n+                   m->method_holder()->name()->as_C_string(),\n+                   m->name()->as_C_string(), m->signature()->as_C_string());\n+    }\n+    if (appendix != NULL) {\n+      st->print(\"  appendix: \");\n+      appendix->print_on(st);\n+    }\n+  }\n@@ -787,1 +806,1 @@\n-      entry_at(i)->print(tty, i);\n+      entry_at(i)->print(tty, i, this);\n@@ -804,1 +823,1 @@\n-  for (int i = 0; i < length(); i++) entry_at(i)->print(st, i);\n+  for (int i = 0; i < length(); i++) entry_at(i)->print(st, i, this);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -295,2 +295,2 @@\n-  Method*      method_if_resolved(const constantPoolHandle& cpool);\n-  oop        appendix_if_resolved(const constantPoolHandle& cpool);\n+  Method*      method_if_resolved(const constantPoolHandle& cpool) const;\n+  oop        appendix_if_resolved(const constantPoolHandle& cpool) const;\n@@ -382,1 +382,1 @@\n-  void print (outputStream* st, int index) const;\n+  void print (outputStream* st, int index, const ConstantPoolCache* cache) const;\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1814,2 +1814,2 @@\n-void Method::print_codes_on(outputStream* st) const {\n-  print_codes_on(0, code_size(), st);\n+void Method::print_codes_on(outputStream* st, int flags) const {\n+  print_codes_on(0, code_size(), st, flags);\n@@ -1818,1 +1818,1 @@\n-void Method::print_codes_on(int from, int to, outputStream* st) const {\n+void Method::print_codes_on(int from, int to, outputStream* st, int flags) const {\n@@ -1822,4 +1822,1 @@\n-  BytecodeStream s(mh);\n-  s.set_interval(from, to);\n-  BytecodeTracer::set_closure(BytecodeTracer::std_closure());\n-  while (s.next() >= 0) BytecodeTracer::trace(mh, s.bcp(), st);\n+  BytecodeTracer::print_method_codes(mh, from, to, st, flags);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -531,3 +531,3 @@\n-  void print_codes() const            { print_codes_on(tty); }\n-  void print_codes_on(outputStream* st) const;\n-  void print_codes_on(int from, int to, outputStream* st) const;\n+  void print_codes(int flags = 0) const { print_codes_on(tty, flags); }\n+  void print_codes_on(outputStream* st, int flags = 0) const;\n+  void print_codes_on(int from, int to, outputStream* st, int flags = 0) const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -146,0 +147,9 @@\n+bool Symbol::is_star_match(const char* star_pattern) const {\n+  if (strchr(star_pattern, '*') == NULL) {\n+    return equals(star_pattern);\n+  } else {\n+    ResourceMark rm;\n+    char* buf = as_C_string();\n+    return StringUtils::is_star_match(star_pattern, buf);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+  bool is_star_match(const char* star_pattern) const;\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"interpreter\/bytecodeTracer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -640,0 +641,21 @@\n+\/\/ For findmethod() and findclass():\n+\/\/ - The patterns are matched by StringUtils::is_star_match()\n+\/\/ - class_name_pattern matches Klass::external_name(). E.g., \"java\/lang\/Object\" or \"*ang\/Object\"\n+\/\/ - method_pattern may optionally the signature. E.g., \"wait\", \"wait:()V\" or \"*ai*t:(*)V\"\n+\/\/ - flags must be OR'ed from ClassPrinter::Mode for findclass\/findmethod\n+\/\/ Examples (in gdb):\n+\/\/   call findclass(\"java\/lang\/Object\", 0x3)             -> find j.l.Object and disasm all of its methods\n+\/\/   call findmethod(\"*ang\/Object*\", \"wait\", 0xff)       -> detailed disasm of all \"wait\" methods in j.l.Object\n+\/\/   call findmethod(\"*ang\/Object*\", \"wait:(*J*)V\", 0x1) -> list all \"wait\" methods in j.l.Object that have a long parameter\n+extern \"C\" JNIEXPORT void findclass(const char* class_name_pattern, int flags) {\n+  Command c(\"findclass\");\n+  ClassPrinter::print_flags_help(tty);\n+  ClassPrinter::print_classes(class_name_pattern, flags, tty);\n+}\n+\n+extern \"C\" JNIEXPORT void findmethod(const char* class_name_pattern,\n+                                     const char* method_pattern, int flags) {\n+  Command c(\"findmethod\");\n+  ClassPrinter::print_flags_help(tty);\n+  ClassPrinter::print_methods(class_name_pattern, method_pattern, flags, tty);\n+}\n@@ -641,1 +663,1 @@\n-\/\/ Need method pointer to find bcp, when not in permgen.\n+\/\/ Need method pointer to find bcp\n@@ -705,0 +727,3 @@\n+  tty->print_cr(\"class metadata.\");\n+  tty->print_cr(\"  findclass(name_pattern, flags)\");\n+  tty->print_cr(\"  findmethod(class_name_pattern, method_pattern, flags)\");\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classPrinter.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(ClassPrinter, print_classes) {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+  ResourceMark rm;\n+\n+  stringStream ss;\n+  ClassPrinter::print_classes(\"java\/lang\/Object\", 0x03, &ss);\n+  const char* output = ss.freeze();\n+\n+  ASSERT_TRUE(strstr(output, \"class java\/lang\/Object loader data:\") != NULL) << \"must find java\/lang\/Object\";\n+  ASSERT_TRUE(strstr(output, \"method wait : (J)V\") != NULL) << \"must find java\/lang\/Object::wait\";\n+  ASSERT_TRUE(strstr(output, \"method finalize : ()V\\n   0 return\") != NULL) << \"must find java\/lang\/Object::finalize and disasm\";\n+}\n+\n+TEST_VM(ClassPrinter, print_methods) {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+  ResourceMark rm;\n+\n+  stringStream s1;\n+  ClassPrinter::print_methods(\"*ang\/Object*\", \"wait\", 0x1, &s1);\n+  const char* o1 = s1.freeze();\n+  ASSERT_TRUE(strstr(o1, \"class java\/lang\/Object loader data:\") != NULL) << \"must find java\/lang\/Object\";\n+  ASSERT_TRUE(strstr(o1, \"method wait : (J)V\")    != NULL) << \"must find java\/lang\/Object::wait(long)\";\n+  ASSERT_TRUE(strstr(o1, \"method wait : ()V\")     != NULL) << \"must find java\/lang\/Object::wait()\";\n+  ASSERT_TRUE(strstr(o1, \"method finalize : ()V\") == NULL) << \"must not find java\/lang\/Object::finalize\";\n+\n+  stringStream s2;\n+  ClassPrinter::print_methods(\"j*ang\/Object*\", \"wait:(*J*)V\", 0x1, &s2);\n+  const char* o2 = s2.freeze();\n+  ASSERT_TRUE(strstr(o2, \"class java\/lang\/Object loader data:\") != NULL) << \"must find java\/lang\/Object\";\n+  ASSERT_TRUE(strstr(o2, \"method wait : (J)V\")  != NULL) << \"must find java\/lang\/Object::wait(long)\";\n+  ASSERT_TRUE(strstr(o2, \"method wait : (JI)V\") != NULL) << \"must find java\/lang\/Object::wait(long,int)\";\n+  ASSERT_TRUE(strstr(o2, \"method wait : ()V\")   == NULL) << \"must not find java\/lang\/Object::wait()\";\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_classPrinter.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}