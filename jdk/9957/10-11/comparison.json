{"files":[{"patch":"@@ -77,1 +77,1 @@\n-    if (ik->is_loaded() && matches(_class_name_pattern, ik->name())) {\n+    if (ik->is_loaded() && ik->name()->is_star_match(_class_name_pattern)) {\n@@ -95,1 +95,1 @@\n-              !matches(_method_name_pattern, m->name())) {\n+              !m->name()->is_star_match(_method_name_pattern)) {\n@@ -99,1 +99,1 @@\n-              !matches(_method_signature_pattern, m->signature())) {\n+              !m->signature()->is_star_match(_method_signature_pattern)) {\n@@ -123,37 +123,8 @@\n-bool ClassPrinter::matches(const char *pattern, const char *candidate, int p, int c) {\n-  if (pattern[p] == '\\0') {\n-    return candidate[c] == '\\0';\n-  } else if (pattern[p] == '*') {\n-    for (; candidate[c] != '\\0'; c++) {\n-      if (matches(pattern, candidate, p+1, c))\n-        return true;\n-    }\n-    return matches(pattern, candidate, p+1, c);\n-  } else if (pattern[p] != '?' && pattern[p] != candidate[c]) {\n-    return false;\n-  }  else {\n-    return matches(pattern, candidate, p+1, c+1);\n-  }\n-}\n-\n-bool ClassPrinter::matches(const char* pattern, Symbol* symbol) {\n-  if (pattern == NULL) {\n-    return true;\n-  }\n-  if (strchr(pattern, '*') == NULL) {\n-    return symbol->equals(pattern);\n-  } else {\n-    ResourceMark rm;\n-    char* buf = symbol->as_C_string();\n-    return matches(pattern, buf, 0, 0);\n-  }\n-}\n-\n-void ClassPrinter::print_help() {\n-  tty->print_cr(\"flags (bitmask):\");\n-  tty->print_cr(\"   0x%02x  - print names of methods\", PRINT_METHOD_NAME);\n-  tty->print_cr(\"   0x%02x  - print bytecodes\", PRINT_BYTECODE);\n-  tty->print_cr(\"   0x%02x  - print the address of bytecodes\", PRINT_BYTECODE_ADDR);\n-  tty->print_cr(\"   0x%02x  - print info for invokedynamic\", PRINT_DYNAMIC);\n-  tty->print_cr(\"   0x%02x  - print info for invokehandle\",  PRINT_METHOD_HANDLE);\n-  tty->cr();\n+void ClassPrinter::print_flags_help(outputStream* os) {\n+  os->print_cr(\"flags (bitmask):\");\n+  os->print_cr(\"   0x%02x  - print names of methods\", PRINT_METHOD_NAME);\n+  os->print_cr(\"   0x%02x  - print bytecodes\", PRINT_BYTECODE);\n+  os->print_cr(\"   0x%02x  - print the address of bytecodes\", PRINT_BYTECODE_ADDR);\n+  os->print_cr(\"   0x%02x  - print info for invokedynamic\", PRINT_DYNAMIC);\n+  os->print_cr(\"   0x%02x  - print info for invokehandle\",  PRINT_METHOD_HANDLE);\n+  os->cr();\n@@ -163,1 +134,0 @@\n-  print_help();\n@@ -169,7 +139,18 @@\n-                                 const char* method_name_pattern, int flags, outputStream* os) {\n-  print_help();\n-  KlassPrintClosure closure(class_name_pattern, method_name_pattern, NULL,\n-                            flags | PRINT_METHOD_NAME, os);\n-  ClassLoaderDataGraph::classes_do(&closure);\n-\n-}\n+                                 const char* method_pattern, int flags, outputStream* os) {\n+  const char* method_name_pattern;\n+  const char* method_signature_pattern;\n+\n+  const char* colon = strchr(method_pattern, ':');\n+  if (colon == NULL) {\n+    method_name_pattern = method_pattern;\n+    method_signature_pattern = NULL;\n+  } else {\n+    ptrdiff_t name_pat_len = colon - method_pattern;\n+    assert(name_pat_len >= 0, \"sanity\");\n+    char* buf = NEW_RESOURCE_ARRAY(char, name_pat_len + 1);\n+    strncpy(buf, method_pattern, name_pat_len);\n+    buf[name_pat_len] = 0;\n+\n+    method_name_pattern = buf;\n+    method_signature_pattern = colon + 1;\n+  }\n@@ -177,4 +158,0 @@\n-void ClassPrinter::print_methods(const char* class_name_pattern,\n-                                 const char* method_name_pattern,\n-                                 const char* method_signature_pattern, int flags, outputStream* os) {\n-  print_help();\n@@ -185,13 +162,0 @@\n-\n-void ClassPrinter::print_class(InstanceKlass* k, int flags, outputStream* os) {\n-  print_help();\n-  KlassPrintClosure closure(NULL, NULL, NULL, flags, os);\n-  closure.print_instance_klass(k);\n-}\n-\n-void ClassPrinter::print_method(Method* m, int flags, outputStream* os) {\n-  print_help();\n-  KlassPrintClosure closure(NULL, \"\", \"\", flags | PRINT_METHOD_NAME | PRINT_BYTECODE, os);\n-  closure.print_instance_klass(m->method_holder());\n-  closure.print_method(m);\n-}\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.cpp","additions":29,"deletions":65,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ ClassPrinter is intended to be called from findclass\/findmethod\/findmethod2\n+\/\/ ClassPrinter is intended to be called from findclass() and findmethod()\n@@ -47,5 +47,0 @@\n-  static bool matches(const char *pattern, const char *candidate, int p, int c);\n-  static bool matches(const char* pattern, Symbol* symbol);\n-  static bool matches_klass(const char* pattern, InstanceKlass* ik);\n-  static void print_help();\n-\n@@ -61,0 +56,5 @@\n+  static bool has_mode(int flags, Mode mode) {\n+    return (flags & static_cast<int>(mode)) != 0;\n+  }\n+\n+  static void print_flags_help(outputStream* os);\n@@ -62,1 +62,1 @@\n-  \/\/ flags must be OR'ed from ClassPrinter::Mode for the next 5 functions\n+  \/\/ flags must be OR'ed from ClassPrinter::Mode for the these two functions\n@@ -66,11 +66,0 @@\n-  static void print_methods(const char* class_name_pattern,\n-                            const char* method_name_pattern,\n-                            const char* method_signature_pattern, int flags, outputStream* os);\n-\n-  static void print_class(InstanceKlass* k, int flags, outputStream* os);\n-  static void print_method(Method* k, int flags, outputStream* os);\n-\n-\n-  static bool has_mode(int flags, Mode mode) {\n-    return (flags & static_cast<int>(mode)) != 0;\n-  }\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.hpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -146,0 +147,9 @@\n+bool Symbol::is_star_match(const char* star_pattern) const {\n+  if (strchr(star_pattern, '*') == NULL) {\n+    return equals(star_pattern);\n+  } else {\n+    ResourceMark rm;\n+    char* buf = as_C_string();\n+    return StringUtils::is_star_match(star_pattern, buf);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+  bool is_star_match(const char* star_pattern) const;\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -641,1 +641,5 @@\n-\/\/ flags must be OR'ed from ClassPrinter::Mode for the next 5 functions.\n+\/\/ For findmethod() and findclass():\n+\/\/ - The patterns are matched by StringUtils::is_star_match()\n+\/\/ - class_name_pattern matches Klass::external_name(). E.g., \"java\/lang\/Object\" or \"*ang\/Object\"\n+\/\/ - method_pattern may optionally the signature. E.g., \"wait\", \"wait:()V\" or \"*ai*t:(*)V\"\n+\/\/ - flags must be OR'ed from ClassPrinter::Mode for findclass\/findmethod\n@@ -643,3 +647,3 @@\n-\/\/   call findclass(\"java\/lang\/Object\", 0x3)\n-\/\/   call findmethod(\"*ang\/Object*\", \"wait\", 0x7)\n-\/\/   call findmethod2(\"*ang\/Object*\", \"wait\", \"(J*\", 0x1)\n+\/\/   call findclass(\"java\/lang\/Object\", 0x3)             -> find j.l.Object and disasm all of its methods\n+\/\/   call findmethod(\"*ang\/Object*\", \"wait\", 0xff)       -> detailed disasm of all \"wait\" methods in j.l.Object\n+\/\/   call findmethod(\"*ang\/Object*\", \"wait:(*J*)V\", 0x1) -> list all \"wait\" methods in j.l.Object that have a long parameter\n@@ -648,0 +652,1 @@\n+  ClassPrinter::print_flags_help(tty);\n@@ -652,1 +657,1 @@\n-                                     const char* method_name_pattern, int flags) {\n+                                     const char* method_pattern, int flags) {\n@@ -654,19 +659,2 @@\n-  ClassPrinter::print_methods(class_name_pattern, method_name_pattern, flags, tty);\n-}\n-\n-extern \"C\" JNIEXPORT void findmethod2(const char* class_name_pattern,\n-                                      const char* method_name_pattern,\n-                                      const char* method_signature_pattern, int flags) {\n-  Command c(\"findmethod2\");\n-  ClassPrinter::print_methods(class_name_pattern, method_name_pattern,\n-                              method_signature_pattern, flags, tty);\n-}\n-\n-extern \"C\" JNIEXPORT void printclass(intptr_t k, int flags) {\n-  Command c(\"printclass\");\n-  ClassPrinter::print_class((InstanceKlass*)k, flags, tty);\n-}\n-\n-extern \"C\" JNIEXPORT void printmethod(intptr_t m, int flags) {\n-  Command c(\"printmethod\");\n-  ClassPrinter::print_method((Method*)m, flags, tty);\n+  ClassPrinter::print_flags_help(tty);\n+  ClassPrinter::print_methods(class_name_pattern, method_pattern, flags, tty);\n@@ -740,5 +728,2 @@\n-  tty->print_cr(\"  findclass(name, flags)\");\n-  tty->print_cr(\"  findmethod(classname, methodname, flags)\");\n-  tty->print_cr(\"  findmethod2(classname, methodname, methodsig, flags)\");\n-  tty->print_cr(\"  printclass(klass, flags)\");\n-  tty->print_cr(\"  printmethod(method, flags)\");\n+  tty->print_cr(\"  findclass(name_pattern, flags)\");\n+  tty->print_cr(\"  findmethod(class_name_pattern, method_pattern, flags)\");\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":14,"deletions":29,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classPrinter.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(ClassPrinter, print_classes) {\n+  ResourceMark rm;\n+\n+  stringStream ss;\n+  ClassPrinter::print_classes(\"java\/lang\/Object\", 0x03, &ss);\n+  const char* output = ss.freeze();\n+\n+  ASSERT_TRUE(strstr(output, \"class java\/lang\/Object loader data:\") != NULL) << \"must find java\/lang\/Object\";\n+  ASSERT_TRUE(strstr(output, \"method wait : (J)V\") != NULL) << \"must find java\/lang\/Object::wait\";\n+  ASSERT_TRUE(strstr(output, \"method finalize : ()V\\n   0 return\") != NULL) << \"must find java\/lang\/Object::finalize and disasm\";\n+}\n+\n+TEST_VM(ClassPrinter, print_methods) {\n+  ResourceMark rm;\n+\n+  stringStream s1;\n+  ClassPrinter::print_methods(\"*ang\/Object*\", \"wait\", 0x1, &s1);\n+  const char* o1 = s1.freeze();\n+  ASSERT_TRUE(strstr(o1, \"class java\/lang\/Object loader data:\") != NULL) << \"must find java\/lang\/Object\";\n+  ASSERT_TRUE(strstr(o1, \"method wait : (J)V\")    != NULL) << \"must find java\/lang\/Object::wait(long)\";\n+  ASSERT_TRUE(strstr(o1, \"method wait : ()V\")     != NULL) << \"must find java\/lang\/Object::wait()\";\n+  ASSERT_TRUE(strstr(o1, \"method finalize : ()V\") == NULL) << \"must not find java\/lang\/Object::finalize\";\n+\n+  stringStream s2;\n+  ClassPrinter::print_methods(\"j*ang\/Object*\", \"wait:(*J*)V\", 0x1, &s2);\n+  const char* o2 = s2.freeze();\n+  ASSERT_TRUE(strstr(o2, \"class java\/lang\/Object loader data:\") != NULL) << \"must find java\/lang\/Object\";\n+  ASSERT_TRUE(strstr(o2, \"method wait : (J)V\")  != NULL) << \"must find java\/lang\/Object::wait(long)\";\n+  ASSERT_TRUE(strstr(o2, \"method wait : (JI)V\") != NULL) << \"must find java\/lang\/Object::wait(long,int)\";\n+  ASSERT_TRUE(strstr(o2, \"method wait : ()V\")   == NULL) << \"must not find java\/lang\/Object::wait()\";\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_classPrinter.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}