{"files":[{"patch":"@@ -57,1 +57,1 @@\n-    LIBS_linux := $(LIBDL) -lpthread, \\\n+    LIBS_linux := $(LIBDL), \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,378 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This file contains implementations of NET_... functions. The NET_.. functions are\n- * wrappers for common file- and socket functions plus provisions for non-blocking IO.\n- *\n- * (basically, the layers remember all  file descriptors waiting for a particular fd;\n- *  all threads waiting on a certain fd can be woken up by sending them a signal; this\n- *  is done e.g. when the fd is closed.)\n- *\n- * This was originally copied from the linux_close.c implementation.\n- *\n- * Side Note: This coding needs initialization. Under Linux this is done\n- * automatically via __attribute((constructor)), on AIX this is done manually\n- * (see aix_close_init).\n- *\n- *\/\n-\n-\/*\n-   AIX needs a workaround for I\/O cancellation, see:\n-   http:\/\/publib.boulder.ibm.com\/infocenter\/pseries\/v5r3\/index.jsp?topic=\/com.ibm.aix.basetechref\/doc\/basetrf1\/close.htm\n-   ...\n-   The close subroutine is blocked until all subroutines which use the file\n-   descriptor return to usr space. For example, when a thread is calling close\n-   and another thread is calling select with the same file descriptor, the\n-   close subroutine does not return until the select call returns.\n-   ...\n-*\/\n-\n-#include <assert.h>\n-#include <limits.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <signal.h>\n-#include <pthread.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/time.h>\n-#include <sys\/resource.h>\n-#include <sys\/uio.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <poll.h>\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-\/*\n- * Stack allocated by thread when doing blocking operation\n- *\/\n-typedef struct threadEntry {\n-    pthread_t thr;                      \/* this thread *\/\n-    struct threadEntry *next;           \/* next thread *\/\n-    int intr;                           \/* interrupted *\/\n-} threadEntry_t;\n-\n-\/*\n- * Heap allocated during initialized - one entry per fd\n- *\/\n-typedef struct {\n-    pthread_mutex_t lock;               \/* fd lock *\/\n-    threadEntry_t *threads;             \/* threads blocked on fd *\/\n-} fdEntry_t;\n-\n-\/*\n- * Signal to unblock thread\n- *\/\n-static int sigWakeup = (SIGRTMAX - 1);\n-\n-\/*\n- * fdTable holds one entry per file descriptor, up to a certain\n- * maximum.\n- * Theoretically, the number of possible file descriptors can get\n- * large, though usually it does not. Entries for small value file\n- * descriptors are kept in a simple table, which covers most scenarios.\n- * Entries for large value file descriptors are kept in an overflow\n- * table, which is organized as a sparse two dimensional array whose\n- * slabs are allocated on demand. This covers all corner cases while\n- * keeping memory consumption reasonable.\n- *\/\n-\n-\/* Base table for low value file descriptors *\/\n-static fdEntry_t* fdTable = NULL;\n-\/* Maximum size of base table (in number of entries). *\/\n-static const int fdTableMaxSize = 0x1000; \/* 4K *\/\n-\/* Actual size of base table (in number of entries) *\/\n-static int fdTableLen = 0;\n-\/* Max. theoretical number of file descriptors on system. *\/\n-static int fdLimit = 0;\n-\n-\/* Overflow table, should base table not be large enough. Organized as\n- *   an array of n slabs, each holding 64k entries.\n- *\/\n-static fdEntry_t** fdOverflowTable = NULL;\n-\/* Number of slabs in the overflow table *\/\n-static int fdOverflowTableLen = 0;\n-\/* Number of entries in one slab *\/\n-static const int fdOverflowTableSlabSize = 0x10000; \/* 64k *\/\n-pthread_mutex_t fdOverflowTableLock = PTHREAD_MUTEX_INITIALIZER;\n-\n-\/*\n- * Null signal handler\n- *\/\n-static void sig_wakeup(int sig) {\n-}\n-\n-\/*\n- * Initialization routine (executed when library is loaded)\n- * Allocate fd tables and sets up signal handler.\n- *\n- * On AIX we don't have __attribute((constructor)) so we need to initialize\n- * manually (from JNI_OnLoad() in 'src\/share\/native\/java\/net\/net_util.c')\n- *\/\n-void aix_close_init() {\n-    struct rlimit nbr_files;\n-    sigset_t sigset;\n-    struct sigaction sa;\n-    int i = 0;\n-\n-    \/* Determine the maximum number of possible file descriptors. *\/\n-    if (-1 == getrlimit(RLIMIT_NOFILE, &nbr_files)) {\n-        fprintf(stderr, \"library initialization failed - \"\n-                \"unable to get max # of allocated fds\\n\");\n-        abort();\n-    }\n-    if (nbr_files.rlim_max != RLIM_INFINITY) {\n-        fdLimit = nbr_files.rlim_max;\n-    } else {\n-        \/* We just do not know. *\/\n-        fdLimit = INT_MAX;\n-    }\n-\n-    \/* Allocate table for low value file descriptors. *\/\n-    fdTableLen = fdLimit < fdTableMaxSize ? fdLimit : fdTableMaxSize;\n-    fdTable = (fdEntry_t*) calloc(fdTableLen, sizeof(fdEntry_t));\n-    if (fdTable == NULL) {\n-        fprintf(stderr, \"library initialization failed - \"\n-                \"unable to allocate file descriptor table - out of memory\");\n-        abort();\n-    } else {\n-        for (i = 0; i < fdTableLen; i ++) {\n-            pthread_mutex_init(&fdTable[i].lock, NULL);\n-        }\n-    }\n-\n-    \/* Allocate overflow table, if needed *\/\n-    if (fdLimit > fdTableMaxSize) {\n-        fdOverflowTableLen = ((fdLimit - fdTableMaxSize) \/ fdOverflowTableSlabSize) + 1;\n-        fdOverflowTable = (fdEntry_t**) calloc(fdOverflowTableLen, sizeof(fdEntry_t*));\n-        if (fdOverflowTable == NULL) {\n-            fprintf(stderr, \"library initialization failed - \"\n-                    \"unable to allocate file descriptor overflow table - out of memory\");\n-            abort();\n-        }\n-    }\n-\n-    \/*\n-     * Setup the signal handler\n-     *\/\n-    sa.sa_handler = sig_wakeup;\n-    sa.sa_flags   = 0;\n-    sigemptyset(&sa.sa_mask);\n-    sigaction(sigWakeup, &sa, NULL);\n-\n-    sigemptyset(&sigset);\n-    sigaddset(&sigset, sigWakeup);\n-    sigprocmask(SIG_UNBLOCK, &sigset, NULL);\n-}\n-\n-\/*\n- * Return the fd table for this fd.\n- *\/\n-static inline fdEntry_t *getFdEntry(int fd)\n-{\n-    fdEntry_t* result = NULL;\n-\n-    if (fd < 0) {\n-        return NULL;\n-    }\n-\n-    \/* This should not happen. If it does, our assumption about\n-     * max. fd value was wrong. *\/\n-    assert(fd < fdLimit);\n-\n-    if (fd < fdTableMaxSize) {\n-        \/* fd is in base table. *\/\n-        assert(fd < fdTableLen);\n-        result = &fdTable[fd];\n-    } else {\n-        \/* fd is in overflow table. *\/\n-        const int indexInOverflowTable = fd - fdTableMaxSize;\n-        const int rootindex = indexInOverflowTable \/ fdOverflowTableSlabSize;\n-        const int slabindex = indexInOverflowTable % fdOverflowTableSlabSize;\n-        fdEntry_t* slab = NULL;\n-        assert(rootindex < fdOverflowTableLen);\n-        assert(slabindex < fdOverflowTableSlabSize);\n-        pthread_mutex_lock(&fdOverflowTableLock);\n-        \/* Allocate new slab in overflow table if needed *\/\n-        if (fdOverflowTable[rootindex] == NULL) {\n-            fdEntry_t* const newSlab =\n-                (fdEntry_t*)calloc(fdOverflowTableSlabSize, sizeof(fdEntry_t));\n-            if (newSlab == NULL) {\n-                fprintf(stderr, \"Unable to allocate file descriptor overflow\"\n-                        \" table slab - out of memory\");\n-                pthread_mutex_unlock(&fdOverflowTableLock);\n-                abort();\n-            } else {\n-                int i;\n-                for (i = 0; i < fdOverflowTableSlabSize; i ++) {\n-                    pthread_mutex_init(&newSlab[i].lock, NULL);\n-                }\n-                fdOverflowTable[rootindex] = newSlab;\n-            }\n-        }\n-        pthread_mutex_unlock(&fdOverflowTableLock);\n-        slab = fdOverflowTable[rootindex];\n-        result = &slab[slabindex];\n-    }\n-\n-    return result;\n-\n-}\n-\n-\n-\/*\n- * Start a blocking operation :-\n- *    Insert thread onto thread list for the fd.\n- *\/\n-static inline void startOp(fdEntry_t *fdEntry, threadEntry_t *self)\n-{\n-    self->thr = pthread_self();\n-    self->intr = 0;\n-\n-    pthread_mutex_lock(&(fdEntry->lock));\n-    {\n-        self->next = fdEntry->threads;\n-        fdEntry->threads = self;\n-    }\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-}\n-\n-\/*\n- * End a blocking operation :-\n- *     Remove thread from thread list for the fd\n- *     If fd has been interrupted then set errno to EBADF\n- *\/\n-static inline void endOp\n-    (fdEntry_t *fdEntry, threadEntry_t *self)\n-{\n-    int orig_errno = errno;\n-    pthread_mutex_lock(&(fdEntry->lock));\n-    {\n-        threadEntry_t *curr, *prev=NULL;\n-        curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            if (curr == self) {\n-                if (curr->intr) {\n-                    orig_errno = EBADF;\n-                }\n-                if (prev == NULL) {\n-                    fdEntry->threads = curr->next;\n-                } else {\n-                    prev->next = curr->next;\n-                }\n-                break;\n-            }\n-            prev = curr;\n-            curr = curr->next;\n-        }\n-    }\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-}\n-\n-\/************** Basic I\/O operations here ***************\/\n-\n-\/*\n- * Macro to perform a blocking IO operation. Restarts\n- * automatically if interrupted by signal (other than\n- * our wakeup signal)\n- *\/\n-#define BLOCKING_IO_RETURN_INT(FD, FUNC) {      \\\n-    int ret;                                    \\\n-    threadEntry_t self;                         \\\n-    fdEntry_t *fdEntry = getFdEntry(FD);        \\\n-    if (fdEntry == NULL) {                      \\\n-        errno = EBADF;                          \\\n-        return -1;                              \\\n-    }                                           \\\n-    do {                                        \\\n-        startOp(fdEntry, &self);                \\\n-        ret = FUNC;                             \\\n-        endOp(fdEntry, &self);                  \\\n-    } while (ret == -1 && errno == EINTR);      \\\n-    return ret;                                 \\\n-}\n-\n-\n-int NET_Connect(int s, struct sockaddr *addr, int addrlen) {\n-    int crc = -1, prc = -1;\n-    threadEntry_t self;\n-    fdEntry_t* fdEntry = getFdEntry(s);\n-\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/* On AIX, when the system call connect() is interrupted, the connection\n-     * is not aborted and it will be established asynchronously by the kernel.\n-     * Hence, no need to restart connect() when EINTR is received\n-     *\/\n-    startOp(fdEntry, &self);\n-    crc = connect(s, addr, addrlen);\n-    endOp(fdEntry, &self);\n-\n-    if (crc == -1 && errno == EINTR) {\n-        struct pollfd s_pollfd;\n-        int sockopt_arg = 0;\n-        socklen_t len;\n-\n-        s_pollfd.fd = s;\n-        s_pollfd.events = POLLOUT | POLLERR;\n-\n-        \/* poll the file descriptor *\/\n-        do {\n-            startOp(fdEntry, &self);\n-            prc = poll(&s_pollfd, 1, -1);\n-            endOp(fdEntry, &self);\n-        } while (prc == -1  && errno == EINTR);\n-\n-        if (prc < 0)\n-            return prc;\n-\n-        len = sizeof(sockopt_arg);\n-\n-        \/* Check whether the connection has been established *\/\n-        if (getsockopt(s, SOL_SOCKET, SO_ERROR, &sockopt_arg, &len) == -1)\n-            return -1;\n-\n-        if (sockopt_arg != 0 ) {\n-            errno = sockopt_arg;\n-            return -1;\n-        }\n-    } else {\n-        return crc;\n-    }\n-\n-    \/* At this point, fd is connected. Set successful return code *\/\n-    return 0;\n-}\n-\n-int NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout) {\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n-}\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":0,"deletions":378,"binary":false,"changes":378,"status":"deleted"},{"patch":"@@ -1,295 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <assert.h>\n-#include <limits.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <signal.h>\n-#include <pthread.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/time.h>\n-#include <sys\/resource.h>\n-#include <sys\/uio.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <poll.h>\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-\/*\n- * Stack allocated by thread when doing blocking operation\n- *\/\n-typedef struct threadEntry {\n-    pthread_t thr;                      \/* this thread *\/\n-    struct threadEntry *next;           \/* next thread *\/\n-    int intr;                           \/* interrupted *\/\n-} threadEntry_t;\n-\n-\/*\n- * Heap allocated during initialized - one entry per fd\n- *\/\n-typedef struct {\n-    pthread_mutex_t lock;               \/* fd lock *\/\n-    threadEntry_t *threads;             \/* threads blocked on fd *\/\n-} fdEntry_t;\n-\n-\/*\n- * Signal to unblock thread\n- *\/\n-#define WAKEUP_SIGNAL (SIGRTMAX - 2)\n-\n-\/*\n- * fdTable holds one entry per file descriptor, up to a certain\n- * maximum.\n- * Theoretically, the number of possible file descriptors can get\n- * large, though usually it does not. Entries for small value file\n- * descriptors are kept in a simple table, which covers most scenarios.\n- * Entries for large value file descriptors are kept in an overflow\n- * table, which is organized as a sparse two dimensional array whose\n- * slabs are allocated on demand. This covers all corner cases while\n- * keeping memory consumption reasonable.\n- *\/\n-\n-\/* Base table for low value file descriptors *\/\n-static fdEntry_t* fdTable = NULL;\n-\/* Maximum size of base table (in number of entries). *\/\n-static const int fdTableMaxSize = 0x1000; \/* 4K *\/\n-\/* Actual size of base table (in number of entries) *\/\n-static int fdTableLen = 0;\n-\/* Max. theoretical number of file descriptors on system. *\/\n-static int fdLimit = 0;\n-\n-\/* Overflow table, should base table not be large enough. Organized as\n- *   an array of n slabs, each holding 64k entries.\n- *\/\n-static fdEntry_t** fdOverflowTable = NULL;\n-\/* Number of slabs in the overflow table *\/\n-static int fdOverflowTableLen = 0;\n-\/* Number of entries in one slab *\/\n-static const int fdOverflowTableSlabSize = 0x10000; \/* 64k *\/\n-pthread_mutex_t fdOverflowTableLock = PTHREAD_MUTEX_INITIALIZER;\n-\n-\/*\n- * Null signal handler\n- *\/\n-static void sig_wakeup(int sig) {\n-}\n-\n-\/*\n- * Initialization routine (executed when library is loaded)\n- * Allocate fd tables and sets up signal handler.\n- *\/\n-static void __attribute((constructor)) init() {\n-    struct rlimit nbr_files;\n-    sigset_t sigset;\n-    struct sigaction sa;\n-    int i = 0;\n-\n-    \/* Determine the maximum number of possible file descriptors. *\/\n-    if (-1 == getrlimit(RLIMIT_NOFILE, &nbr_files)) {\n-        fprintf(stderr, \"library initialization failed - \"\n-                \"unable to get max # of allocated fds\\n\");\n-        abort();\n-    }\n-    if (nbr_files.rlim_max != RLIM_INFINITY) {\n-        fdLimit = nbr_files.rlim_max;\n-    } else {\n-        \/* We just do not know. *\/\n-        fdLimit = INT_MAX;\n-    }\n-\n-    \/* Allocate table for low value file descriptors. *\/\n-    fdTableLen = fdLimit < fdTableMaxSize ? fdLimit : fdTableMaxSize;\n-    fdTable = (fdEntry_t*) calloc(fdTableLen, sizeof(fdEntry_t));\n-    if (fdTable == NULL) {\n-        fprintf(stderr, \"library initialization failed - \"\n-                \"unable to allocate file descriptor table - out of memory\");\n-        abort();\n-    } else {\n-        for (i = 0; i < fdTableLen; i ++) {\n-            pthread_mutex_init(&fdTable[i].lock, NULL);\n-        }\n-    }\n-\n-    \/* Allocate overflow table, if needed *\/\n-    if (fdLimit > fdTableMaxSize) {\n-        fdOverflowTableLen = ((fdLimit - fdTableMaxSize) \/ fdOverflowTableSlabSize) + 1;\n-        fdOverflowTable = (fdEntry_t**) calloc(fdOverflowTableLen, sizeof(fdEntry_t*));\n-        if (fdOverflowTable == NULL) {\n-            fprintf(stderr, \"library initialization failed - \"\n-                    \"unable to allocate file descriptor overflow table - out of memory\");\n-            abort();\n-        }\n-    }\n-\n-    \/*\n-     * Setup the signal handler\n-     *\/\n-    sa.sa_handler = sig_wakeup;\n-    sa.sa_flags   = 0;\n-    sigemptyset(&sa.sa_mask);\n-    sigaction(WAKEUP_SIGNAL, &sa, NULL);\n-\n-    sigemptyset(&sigset);\n-    sigaddset(&sigset, WAKEUP_SIGNAL);\n-    sigprocmask(SIG_UNBLOCK, &sigset, NULL);\n-}\n-\n-\/*\n- * Return the fd table for this fd.\n- *\/\n-static inline fdEntry_t *getFdEntry(int fd)\n-{\n-    fdEntry_t* result = NULL;\n-\n-    if (fd < 0) {\n-        return NULL;\n-    }\n-\n-    \/* This should not happen. If it does, our assumption about\n-     * max. fd value was wrong. *\/\n-    assert(fd < fdLimit);\n-\n-    if (fd < fdTableMaxSize) {\n-        \/* fd is in base table. *\/\n-        assert(fd < fdTableLen);\n-        result = &fdTable[fd];\n-    } else {\n-        \/* fd is in overflow table. *\/\n-        const int indexInOverflowTable = fd - fdTableMaxSize;\n-        const int rootindex = indexInOverflowTable \/ fdOverflowTableSlabSize;\n-        const int slabindex = indexInOverflowTable % fdOverflowTableSlabSize;\n-        fdEntry_t* slab = NULL;\n-        assert(rootindex < fdOverflowTableLen);\n-        assert(slabindex < fdOverflowTableSlabSize);\n-        pthread_mutex_lock(&fdOverflowTableLock);\n-        \/* Allocate new slab in overflow table if needed *\/\n-        if (fdOverflowTable[rootindex] == NULL) {\n-            fdEntry_t* const newSlab =\n-                (fdEntry_t*)calloc(fdOverflowTableSlabSize, sizeof(fdEntry_t));\n-            if (newSlab == NULL) {\n-                fprintf(stderr, \"Unable to allocate file descriptor overflow\"\n-                        \" table slab - out of memory\");\n-                pthread_mutex_unlock(&fdOverflowTableLock);\n-                abort();\n-            } else {\n-                int i;\n-                for (i = 0; i < fdOverflowTableSlabSize; i ++) {\n-                    pthread_mutex_init(&newSlab[i].lock, NULL);\n-                }\n-                fdOverflowTable[rootindex] = newSlab;\n-            }\n-        }\n-        pthread_mutex_unlock(&fdOverflowTableLock);\n-        slab = fdOverflowTable[rootindex];\n-        result = &slab[slabindex];\n-    }\n-\n-    return result;\n-\n-}\n-\n-\/*\n- * Start a blocking operation :-\n- *    Insert thread onto thread list for the fd.\n- *\/\n-static inline void startOp(fdEntry_t *fdEntry, threadEntry_t *self)\n-{\n-    self->thr = pthread_self();\n-    self->intr = 0;\n-\n-    pthread_mutex_lock(&(fdEntry->lock));\n-    {\n-        self->next = fdEntry->threads;\n-        fdEntry->threads = self;\n-    }\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-}\n-\n-\/*\n- * End a blocking operation :-\n- *     Remove thread from thread list for the fd\n- *     If fd has been interrupted then set errno to EBADF\n- *\/\n-static inline void endOp\n-    (fdEntry_t *fdEntry, threadEntry_t *self)\n-{\n-    int orig_errno = errno;\n-    pthread_mutex_lock(&(fdEntry->lock));\n-    {\n-        threadEntry_t *curr, *prev=NULL;\n-        curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            if (curr == self) {\n-                if (curr->intr) {\n-                    orig_errno = EBADF;\n-                }\n-                if (prev == NULL) {\n-                    fdEntry->threads = curr->next;\n-                } else {\n-                    prev->next = curr->next;\n-                }\n-                break;\n-            }\n-            prev = curr;\n-            curr = curr->next;\n-        }\n-    }\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-}\n-\n-\/************** Basic I\/O operations here ***************\/\n-\n-\/*\n- * Macro to perform a blocking IO operation. Restarts\n- * automatically if interrupted by signal (other than\n- * our wakeup signal)\n- *\/\n-#define BLOCKING_IO_RETURN_INT(FD, FUNC) {      \\\n-    int ret;                                    \\\n-    threadEntry_t self;                         \\\n-    fdEntry_t *fdEntry = getFdEntry(FD);        \\\n-    if (fdEntry == NULL) {                      \\\n-        errno = EBADF;                          \\\n-        return -1;                              \\\n-    }                                           \\\n-    do {                                        \\\n-        startOp(fdEntry, &self);                \\\n-        ret = FUNC;                             \\\n-        endOp(fdEntry, &self);                  \\\n-    } while (ret == -1 && errno == EINTR);      \\\n-    return ret;                                 \\\n-}\n-\n-int NET_Connect(int s, struct sockaddr *addr, int addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );\n-}\n-\n-int NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout) {\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n-}\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":0,"deletions":295,"binary":false,"changes":295,"status":"deleted"},{"patch":"@@ -1,298 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <assert.h>\n-#include <limits.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <sys\/param.h>\n-#include <signal.h>\n-#include <pthread.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/select.h>\n-#include <sys\/time.h>\n-#include <sys\/resource.h>\n-#include <sys\/uio.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <poll.h>\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-\/*\n- * Stack allocated by thread when doing blocking operation\n- *\/\n-typedef struct threadEntry {\n-    pthread_t thr;                      \/* this thread *\/\n-    struct threadEntry *next;           \/* next thread *\/\n-    int intr;                           \/* interrupted *\/\n-} threadEntry_t;\n-\n-\/*\n- * Heap allocated during initialized - one entry per fd\n- *\/\n-typedef struct {\n-    pthread_mutex_t lock;               \/* fd lock *\/\n-    threadEntry_t *threads;             \/* threads blocked on fd *\/\n-} fdEntry_t;\n-\n-\/*\n- * Signal to unblock thread\n- *\/\n-static int sigWakeup = SIGIO;\n-\n-\/*\n- * fdTable holds one entry per file descriptor, up to a certain\n- * maximum.\n- * Theoretically, the number of possible file descriptors can get\n- * large, though usually it does not. Entries for small value file\n- * descriptors are kept in a simple table, which covers most scenarios.\n- * Entries for large value file descriptors are kept in an overflow\n- * table, which is organized as a sparse two dimensional array whose\n- * slabs are allocated on demand. This covers all corner cases while\n- * keeping memory consumption reasonable.\n- *\/\n-\n-\/* Base table for low value file descriptors *\/\n-static fdEntry_t* fdTable = NULL;\n-\/* Maximum size of base table (in number of entries). *\/\n-static const int fdTableMaxSize = 0x1000; \/* 4K *\/\n-\/* Actual size of base table (in number of entries) *\/\n-static int fdTableLen = 0;\n-\/* Max. theoretical number of file descriptors on system. *\/\n-static int fdLimit = 0;\n-\n-\/* Overflow table, should base table not be large enough. Organized as\n- *   an array of n slabs, each holding 64k entries.\n- *\/\n-static fdEntry_t** fdOverflowTable = NULL;\n-\/* Number of slabs in the overflow table *\/\n-static int fdOverflowTableLen = 0;\n-\/* Number of entries in one slab *\/\n-static const int fdOverflowTableSlabSize = 0x10000; \/* 64k *\/\n-pthread_mutex_t fdOverflowTableLock = PTHREAD_MUTEX_INITIALIZER;\n-\n-\/*\n- * Null signal handler\n- *\/\n-static void sig_wakeup(int sig) {\n-}\n-\n-\/*\n- * Initialization routine (executed when library is loaded)\n- * Allocate fd tables and sets up signal handler.\n- *\/\n-static void __attribute((constructor)) init() {\n-    struct rlimit nbr_files;\n-    sigset_t sigset;\n-    struct sigaction sa;\n-    int i = 0;\n-\n-    \/* Determine the maximum number of possible file descriptors. *\/\n-    if (-1 == getrlimit(RLIMIT_NOFILE, &nbr_files)) {\n-        fprintf(stderr, \"library initialization failed - \"\n-                \"unable to get max # of allocated fds\\n\");\n-        abort();\n-    }\n-    if (nbr_files.rlim_max != RLIM_INFINITY) {\n-        fdLimit = nbr_files.rlim_max;\n-    } else {\n-        \/* We just do not know. *\/\n-        fdLimit = INT_MAX;\n-    }\n-\n-    \/* Allocate table for low value file descriptors. *\/\n-    fdTableLen = fdLimit < fdTableMaxSize ? fdLimit : fdTableMaxSize;\n-    fdTable = (fdEntry_t*) calloc(fdTableLen, sizeof(fdEntry_t));\n-    if (fdTable == NULL) {\n-        fprintf(stderr, \"library initialization failed - \"\n-                \"unable to allocate file descriptor table - out of memory\");\n-        abort();\n-    } else {\n-        for (i = 0; i < fdTableLen; i ++) {\n-            pthread_mutex_init(&fdTable[i].lock, NULL);\n-        }\n-    }\n-\n-    \/* Allocate overflow table, if needed *\/\n-    if (fdLimit > fdTableMaxSize) {\n-        fdOverflowTableLen = ((fdLimit - fdTableMaxSize) \/ fdOverflowTableSlabSize) + 1;\n-        fdOverflowTable = (fdEntry_t**) calloc(fdOverflowTableLen, sizeof(fdEntry_t*));\n-        if (fdOverflowTable == NULL) {\n-            fprintf(stderr, \"library initialization failed - \"\n-                    \"unable to allocate file descriptor overflow table - out of memory\");\n-            abort();\n-        }\n-    }\n-\n-    \/*\n-     * Setup the signal handler\n-     *\/\n-    sa.sa_handler = sig_wakeup;\n-    sa.sa_flags   = 0;\n-    sigemptyset(&sa.sa_mask);\n-    sigaction(sigWakeup, &sa, NULL);\n-\n-    sigemptyset(&sigset);\n-    sigaddset(&sigset, sigWakeup);\n-    sigprocmask(SIG_UNBLOCK, &sigset, NULL);\n-}\n-\n-\/*\n- * Return the fd table for this fd.\n- *\/\n-static inline fdEntry_t *getFdEntry(int fd)\n-{\n-    fdEntry_t* result = NULL;\n-\n-    if (fd < 0) {\n-        return NULL;\n-    }\n-\n-    \/* This should not happen. If it does, our assumption about\n-     * max. fd value was wrong. *\/\n-    assert(fd < fdLimit);\n-\n-    if (fd < fdTableMaxSize) {\n-        \/* fd is in base table. *\/\n-        assert(fd < fdTableLen);\n-        result = &fdTable[fd];\n-    } else {\n-        \/* fd is in overflow table. *\/\n-        const int indexInOverflowTable = fd - fdTableMaxSize;\n-        const int rootindex = indexInOverflowTable \/ fdOverflowTableSlabSize;\n-        const int slabindex = indexInOverflowTable % fdOverflowTableSlabSize;\n-        fdEntry_t* slab = NULL;\n-        assert(rootindex < fdOverflowTableLen);\n-        assert(slabindex < fdOverflowTableSlabSize);\n-        pthread_mutex_lock(&fdOverflowTableLock);\n-        \/* Allocate new slab in overflow table if needed *\/\n-        if (fdOverflowTable[rootindex] == NULL) {\n-            fdEntry_t* const newSlab =\n-                (fdEntry_t*)calloc(fdOverflowTableSlabSize, sizeof(fdEntry_t));\n-            if (newSlab == NULL) {\n-                fprintf(stderr, \"Unable to allocate file descriptor overflow\"\n-                        \" table slab - out of memory\");\n-                pthread_mutex_unlock(&fdOverflowTableLock);\n-                abort();\n-            } else {\n-                int i;\n-                for (i = 0; i < fdOverflowTableSlabSize; i ++) {\n-                    pthread_mutex_init(&newSlab[i].lock, NULL);\n-                }\n-                fdOverflowTable[rootindex] = newSlab;\n-            }\n-        }\n-        pthread_mutex_unlock(&fdOverflowTableLock);\n-        slab = fdOverflowTable[rootindex];\n-        result = &slab[slabindex];\n-    }\n-\n-    return result;\n-\n-}\n-\n-\n-\/*\n- * Start a blocking operation :-\n- *    Insert thread onto thread list for the fd.\n- *\/\n-static inline void startOp(fdEntry_t *fdEntry, threadEntry_t *self)\n-{\n-    self->thr = pthread_self();\n-    self->intr = 0;\n-\n-    pthread_mutex_lock(&(fdEntry->lock));\n-    {\n-        self->next = fdEntry->threads;\n-        fdEntry->threads = self;\n-    }\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-}\n-\n-\/*\n- * End a blocking operation :-\n- *     Remove thread from thread list for the fd\n- *     If fd has been interrupted then set errno to EBADF\n- *\/\n-static inline void endOp\n-    (fdEntry_t *fdEntry, threadEntry_t *self)\n-{\n-    int orig_errno = errno;\n-    pthread_mutex_lock(&(fdEntry->lock));\n-    {\n-        threadEntry_t *curr, *prev=NULL;\n-        curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            if (curr == self) {\n-                if (curr->intr) {\n-                    orig_errno = EBADF;\n-                }\n-                if (prev == NULL) {\n-                    fdEntry->threads = curr->next;\n-                } else {\n-                    prev->next = curr->next;\n-                }\n-                break;\n-            }\n-            prev = curr;\n-            curr = curr->next;\n-        }\n-    }\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-}\n-\n-\/************** Basic I\/O operations here ***************\/\n-\n-\/*\n- * Macro to perform a blocking IO operation. Restarts\n- * automatically if interrupted by signal (other than\n- * our wakeup signal)\n- *\/\n-#define BLOCKING_IO_RETURN_INT(FD, FUNC) {      \\\n-    int ret;                                    \\\n-    threadEntry_t self;                         \\\n-    fdEntry_t *fdEntry = getFdEntry(FD);        \\\n-    if (fdEntry == NULL) {                      \\\n-        errno = EBADF;                          \\\n-        return -1;                              \\\n-    }                                           \\\n-    do {                                        \\\n-        startOp(fdEntry, &self);                \\\n-        ret = FUNC;                             \\\n-        endOp(fdEntry, &self);                  \\\n-    } while (ret == -1 && errno == EINTR);      \\\n-    return ret;                                 \\\n-}\n-\n-int NET_Connect(int s, struct sockaddr *addr, int addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );\n-}\n-\n-int NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout) {\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n-}\n","filename":"src\/java.base\/macosx\/native\/libnet\/bsd_close.c","additions":0,"deletions":298,"binary":false,"changes":298,"status":"deleted"},{"patch":"@@ -84,1 +84,0 @@\n-    platformInit();\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,2 +145,0 @@\n-void platformInit();\n-\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-    connect_rv = NET_Connect(fd, &sa->sa, sizeof(struct sockaddr_in));\n+    connect_rv = connect(fd, &sa->sa, sizeof(struct sockaddr_in));\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-    connect_rv = NET_Connect(fd, &sa->sa, sizeof(struct sockaddr_in6));\n+    connect_rv = connect(fd, &sa->sa, sizeof(struct sockaddr_in6));\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -227,15 +227,0 @@\n-#if defined(_AIX)\n-\n-\/* Initialize stubs for blocking I\/O workarounds (see src\/solaris\/native\/java\/net\/linux_close.c) *\/\n-extern void aix_close_init();\n-\n-void platformInit () {\n-    aix_close_init();\n-}\n-\n-#else\n-\n-void platformInit () {}\n-\n-#endif\n-\n@@ -718,1 +703,1 @@\n-        read_rv = NET_Poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n+        read_rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-\n-int NET_Connect(int s, struct sockaddr *addr, int addrlen);\n-int NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout);\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,2 +129,0 @@\n-void platformInit() {}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4796166\n- * @library \/test\/lib\n- * @summary Linger interval delays usage of released file descriptor\n- * @run main LingerTest\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true LingerTest\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import jdk.test.lib.net.IPSupport;\n-\n-public class LingerTest {\n-\n-    static class Sender implements Runnable {\n-        Socket s;\n-\n-        public Sender(Socket s) {\n-            this.s = s;\n-        }\n-\n-        public void run() {\n-            System.out.println (\"Sender starts\");\n-            try {\n-                s.getOutputStream().write(new byte[128*1024]);\n-            }\n-            catch (IOException ioe) {\n-            }\n-            System.out.println (\"Sender ends\");\n-        }\n-    }\n-\n-    static class Closer implements Runnable {\n-        Socket s;\n-\n-        public Closer(Socket s) {\n-            this.s = s;\n-        }\n-\n-        public void run() {\n-            System.out.println (\"Closer starts\");\n-            try {\n-                s.close();\n-            }\n-            catch (IOException ioe) {\n-            }\n-            System.out.println (\"Closer ends\");\n-        }\n-    }\n-\n-    static class Other implements Runnable {\n-        final InetAddress address;\n-        final int port;\n-        final long delay;\n-        boolean connected = false;\n-\n-        public Other(InetAddress address, int port, long delay) {\n-            this.address = address;\n-            this.port = port;\n-            this.delay = delay;\n-        }\n-\n-        public void run() {\n-            System.out.println (\"Other starts: sleep \" + delay);\n-            try {\n-                Thread.sleep(delay);\n-                System.out.println (\"Other opening socket\");\n-                Socket s = new Socket(address, port);\n-                synchronized (this) {\n-                    connected = true;\n-                }\n-                s.close();\n-            }\n-            catch (Exception ioe) {\n-                ioe.printStackTrace();\n-            }\n-            System.out.println (\"Other ends\");\n-        }\n-\n-        public synchronized boolean connected() {\n-            return connected;\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        IPSupport.throwSkippedExceptionIfNonOperational();\n-\n-        InetAddress loopback = InetAddress.getLoopbackAddress();\n-        ServerSocket ss = new ServerSocket(0, 50, loopback);\n-\n-        Socket s1 = new Socket(loopback, ss.getLocalPort());\n-        Socket s2 = ss.accept();\n-\n-        \/\/ setup conditions for untransmitted data and lengthy\n-        \/\/ linger interval\n-        s1.setSendBufferSize(128*1024);\n-        s1.setSoLinger(true, 30);\n-        s2.setReceiveBufferSize(1*1024);\n-\n-        \/\/ start sender\n-        Thread senderThread = new Thread(new Sender(s1));\n-        senderThread.start();\n-\n-        \/\/ other thread that will connect after 5 seconds.\n-        Other other = new Other(loopback, ss.getLocalPort(), 5000);\n-        Thread otherThread = new Thread(other);\n-        otherThread.start();\n-\n-        \/\/ give sender time to queue the data\n-        System.out.println (\"Main sleep 1000\");\n-        Thread.sleep(1000);\n-        System.out.println (\"Main continue\");\n-\n-        \/\/ close the socket asynchronously\n-        Thread closerThread = new Thread(new Closer(s1));\n-        closerThread.start();\n-\n-        System.out.println (\"Main sleep 15000\");\n-        \/\/ give other time to run\n-        Thread.sleep(15000);\n-        System.out.println (\"Main closing serversocket\");\n-\n-        ss.close();\n-        \/\/ check that other is done\n-        if (!other.connected()) {\n-            throw new RuntimeException(\"Other thread is blocked\");\n-        }\n-\n-        \/\/ await termination of all test related threads\n-        senderThread.join(60_000);\n-        otherThread.join(60_000);\n-        closerThread.join(60_000);\n-\n-        System.out.println (\"Main ends\");\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/Socket\/LingerTest.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"}]}