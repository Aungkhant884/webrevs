{"files":[{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClassesImpl.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/continuationJavaClasses.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+\n+\/\/ Support for jdk.internal.vm.ContinuationScope\n+\n+int jdk_internal_vm_ContinuationScope::_name_offset;\n+\n+#define CONTINUATIONSCOPE_FIELDS_DO(macro) \\\n+  macro(_name_offset, k, vmSymbols::name_name(), string_signature, false);\n+\n+void jdk_internal_vm_ContinuationScope::compute_offsets() {\n+  InstanceKlass* k = vmClasses::ContinuationScope_klass();\n+  CONTINUATIONSCOPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_vm_ContinuationScope::serialize_offsets(SerializeClosure* f) {\n+  CONTINUATIONSCOPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+\/\/ Support for jdk.internal.vm.Continuation\n+int jdk_internal_vm_Continuation::_scope_offset;\n+int jdk_internal_vm_Continuation::_target_offset;\n+int jdk_internal_vm_Continuation::_tail_offset;\n+int jdk_internal_vm_Continuation::_parent_offset;\n+int jdk_internal_vm_Continuation::_yieldInfo_offset;\n+int jdk_internal_vm_Continuation::_mounted_offset;\n+int jdk_internal_vm_Continuation::_done_offset;\n+int jdk_internal_vm_Continuation::_preempted_offset;\n+\n+#define CONTINUATION_FIELDS_DO(macro) \\\n+  macro(_scope_offset,     k, vmSymbols::scope_name(),     continuationscope_signature, false); \\\n+  macro(_target_offset,    k, vmSymbols::target_name(),    runnable_signature,          false); \\\n+  macro(_parent_offset,    k, vmSymbols::parent_name(),    continuation_signature,      false); \\\n+  macro(_yieldInfo_offset, k, vmSymbols::yieldInfo_name(), object_signature,            false); \\\n+  macro(_tail_offset,      k, vmSymbols::tail_name(),      stackchunk_signature,        false); \\\n+  macro(_mounted_offset,   k, vmSymbols::mounted_name(),   bool_signature,              false); \\\n+  macro(_done_offset,      k, vmSymbols::done_name(),      bool_signature,              false); \\\n+  macro(_preempted_offset, k, \"preempted\",                 bool_signature,              false);\n+\n+void jdk_internal_vm_Continuation::compute_offsets() {\n+  InstanceKlass* k = vmClasses::Continuation_klass();\n+  CONTINUATION_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_vm_Continuation::serialize_offsets(SerializeClosure* f) {\n+  CONTINUATION_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+\/\/ Support for jdk.internal.vm.StackChunk\n+\n+int jdk_internal_vm_StackChunk::_parent_offset;\n+int jdk_internal_vm_StackChunk::_size_offset;\n+int jdk_internal_vm_StackChunk::_sp_offset;\n+int jdk_internal_vm_StackChunk::_pc_offset;\n+int jdk_internal_vm_StackChunk::_argsize_offset;\n+int jdk_internal_vm_StackChunk::_flags_offset;\n+int jdk_internal_vm_StackChunk::_maxThawingSize_offset;\n+int jdk_internal_vm_StackChunk::_cont_offset;\n+\n+#define STACKCHUNK_FIELDS_DO(macro) \\\n+  macro(_parent_offset,  k, vmSymbols::parent_name(),  stackchunk_signature, false); \\\n+  macro(_size_offset,    k, vmSymbols::size_name(),    int_signature,        false); \\\n+  macro(_sp_offset,      k, vmSymbols::sp_name(),      int_signature,        false); \\\n+  macro(_argsize_offset, k, vmSymbols::argsize_name(), int_signature,        false);\n+\n+void jdk_internal_vm_StackChunk::compute_offsets() {\n+  InstanceKlass* k = vmClasses::StackChunk_klass();\n+  STACKCHUNK_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  STACKCHUNK_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_vm_StackChunk::serialize_offsets(SerializeClosure* f) {\n+  STACKCHUNK_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+  STACKCHUNK_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/classfile\/continuationJavaClasses.cpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_CONTINUATIONJAVACLASSES_HPP\n+#define SHARE_CLASSFILE_CONTINUATIONJAVACLASSES_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oop.hpp\"\n+\n+class SerializeClosure;\n+\n+\/\/ Interface to jdk.internal.vm.ContinuationScope objects\n+class jdk_internal_vm_ContinuationScope: AllStatic {\n+  friend class JavaClasses;\n+ private:\n+  static int _name_offset;\n+\n+  static void compute_offsets();\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  static inline oop name(oop ref);\n+};\n+\n+\/\/ Interface to jdk.internal.vm.Continuation objects\n+class jdk_internal_vm_Continuation: AllStatic {\n+  friend class JavaClasses;\n+ private:\n+  static int _scope_offset;\n+  static int _target_offset;\n+  static int _parent_offset;\n+  static int _yieldInfo_offset;\n+  static int _tail_offset;\n+  static int _mounted_offset;\n+  static int _done_offset;\n+  static int _preempted_offset;\n+\n+  static void compute_offsets();\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+  \/\/ Accessors\n+  static inline oop scope(oop continuation);\n+  static inline oop target(oop continuation);\n+  static inline oop parent(oop continuation);\n+  static inline oop yieldInfo(oop continuation);\n+  static inline void set_yieldInfo(oop continuation, oop value);\n+  static inline stackChunkOop tail(oop continuation);\n+  static inline void set_tail(oop continuation, stackChunkOop value);\n+  static inline bool on_local_stack(oop continuation, address adr);\n+  static inline bool done(oop continuation);\n+  static inline bool is_preempted(oop continuation);\n+  static inline void set_preempted(oop continuation, bool value);\n+};\n+\n+\/\/ Interface to jdk.internal.vm.StackChunk objects\n+#define STACKCHUNK_INJECTED_FIELDS(macro)                                    \\\n+  macro(jdk_internal_vm_StackChunk, cont,           continuation_signature, false)  \\\n+  macro(jdk_internal_vm_StackChunk, flags,          byte_signature, false)          \\\n+  macro(jdk_internal_vm_StackChunk, pc,             intptr_signature, false)        \\\n+  macro(jdk_internal_vm_StackChunk, maxThawingSize, int_signature, false)           \\\n+\n+class jdk_internal_vm_StackChunk: AllStatic {\n+  friend class JavaClasses;\n+ private:\n+  static int _parent_offset;\n+  static int _size_offset;\n+  static int _sp_offset;\n+  static int _pc_offset;\n+  static int _argsize_offset;\n+  static int _flags_offset;\n+  static int _maxThawingSize_offset;\n+  static int _cont_offset;\n+\n+\n+  static void compute_offsets();\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  static inline int parent_offset() { return _parent_offset; }\n+  static inline int cont_offset()   { return _cont_offset; }\n+\n+  \/\/ Accessors\n+  static inline oop parent(oop chunk);\n+  static inline void set_parent(oop chunk, oop value);\n+  template<typename P>\n+  static inline bool is_parent_null(oop chunk); \/\/ bypasses barriers for a faster test\n+  template<typename P>\n+  static inline void set_parent_raw(oop chunk, oop value);\n+\n+  static inline int size(oop chunk);\n+  static inline void set_size(HeapWord* chunk, int value);\n+\n+  static inline int sp(oop chunk);\n+  static inline void set_sp(oop chunk, int value);\n+  static inline void set_sp(HeapWord* chunk, int value); \/\/ used while allocating\n+  static inline address pc(oop chunk);\n+  static inline void set_pc(oop chunk, address value);\n+  static inline int argsize(oop chunk);\n+  static inline void set_argsize(oop chunk, int value);\n+  static inline uint8_t flags(oop chunk);\n+  static inline void set_flags(oop chunk, uint8_t value);\n+  static inline uint8_t flags_acquire(oop chunk);\n+  static inline void release_set_flags(oop chunk, uint8_t value);\n+  static inline bool try_set_flags(oop chunk, uint8_t expected_value, uint8_t new_value);\n+\n+  static inline int maxThawingSize(oop chunk);\n+  static inline void set_maxThawingSize(oop chunk, int value);\n+\n+ \/\/ cont oop's processing is essential for the chunk's GC protocol\n+  static inline oop cont(oop chunk);\n+  static inline void set_cont(oop chunk, oop value);\n+  template<typename P>\n+  static inline oop cont_raw(oop chunk);\n+  template<typename P>\n+  static inline void set_cont_raw(oop chunk, oop value);\n+};\n+\n+#endif \/\/ SHARE_CLASSFILE_CONTINUATIONJAVACLASSES_HPP\n","filename":"src\/hotspot\/share\/classfile\/continuationJavaClasses.hpp","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_JDK_INTERNAL_VM_STACKCHUNK_INLINE_HPP\n+#define SHARE_CLASSFILE_JDK_INTERNAL_VM_STACKCHUNK_INLINE_HPP\n+\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/continuationJavaClasses.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/stackChunkOop.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+\n+inline oop jdk_internal_vm_ContinuationScope::name(oop ref) {\n+  return ref->obj_field(_name_offset);\n+}\n+\n+inline oop jdk_internal_vm_Continuation::scope(oop continuation) {\n+  return continuation->obj_field(_scope_offset);\n+}\n+\n+inline oop jdk_internal_vm_Continuation::target(oop continuation) {\n+  return continuation->obj_field(_target_offset);\n+}\n+\n+inline oop jdk_internal_vm_Continuation::parent(oop continuation) {\n+  return continuation->obj_field(_parent_offset);\n+}\n+\n+inline oop jdk_internal_vm_Continuation::yieldInfo(oop continuation) {\n+  return continuation->obj_field(_yieldInfo_offset);\n+}\n+\n+inline void jdk_internal_vm_Continuation::set_yieldInfo(oop continuation, oop value) {\n+  continuation->obj_field_put(_yieldInfo_offset, value);\n+}\n+\n+inline stackChunkOop jdk_internal_vm_Continuation::tail(oop continuation) {\n+  return stackChunkOopDesc::cast(continuation->obj_field(_tail_offset));\n+}\n+\n+inline void jdk_internal_vm_Continuation::set_tail(oop continuation, stackChunkOop value) {\n+  continuation->obj_field_put(_tail_offset, value);\n+}\n+\n+inline bool jdk_internal_vm_Continuation::done(oop continuation) {\n+  return continuation->bool_field(_done_offset);\n+}\n+\n+inline bool jdk_internal_vm_Continuation::is_preempted(oop continuation) {\n+  return continuation->bool_field(_preempted_offset);\n+}\n+\n+inline void jdk_internal_vm_Continuation::set_preempted(oop continuation, bool value) {\n+  continuation->bool_field_put(_preempted_offset, (jboolean)value);\n+}\n+\n+\/\/ ----------------------------------------------------------------------\n+\n+inline oop jdk_internal_vm_StackChunk::parent(oop chunk) {\n+  return chunk->obj_field(_parent_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_parent(oop chunk, oop value) {\n+  chunk->obj_field_put(_parent_offset, value);\n+}\n+\n+template<typename P>\n+inline bool jdk_internal_vm_StackChunk::is_parent_null(oop chunk) {\n+  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_parent_offset)) == NULL;\n+}\n+\n+template<typename P>\n+inline void jdk_internal_vm_StackChunk::set_parent_raw(oop chunk, oop value) {\n+  RawAccess<>::oop_store(chunk->field_addr<P>(_parent_offset), value);\n+}\n+\n+inline oop jdk_internal_vm_StackChunk::cont(oop chunk) {\n+  return chunk->obj_field(_cont_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_cont(oop chunk, oop value) {\n+  chunk->obj_field_put(_cont_offset, value);\n+}\n+\n+template<typename P>\n+inline oop jdk_internal_vm_StackChunk::cont_raw(oop chunk) {\n+  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_cont_offset));\n+}\n+\n+template<typename P>\n+inline void jdk_internal_vm_StackChunk::set_cont_raw(oop chunk, oop value) {\n+  RawAccess<>::oop_store(chunk->field_addr<P>(_cont_offset), value);\n+}\n+\n+inline int jdk_internal_vm_StackChunk::size(oop chunk) {\n+  return chunk->int_field(_size_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_size(HeapWord* chunk, int value) {\n+  \/\/ Used by StackChunkAllocator before the Object has been finished,\n+  \/\/ so don't cast too oop and use int_field_put in this function.\n+  assert(_size_offset != 0, \"must be set\");\n+  *(int*)(((char*)chunk) + _size_offset) = (int)value;\n+}\n+\n+inline int jdk_internal_vm_StackChunk::sp(oop chunk) {\n+  return chunk->int_field(_sp_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_sp(oop chunk, int value) {\n+  chunk->int_field_put(_sp_offset, value);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_sp(HeapWord* chunk, int value) {\n+  \/\/ Used by StackChunkAllocator before the Object has been finished,\n+  \/\/ so don't cast too oop and use int_field_put in this function.\n+  assert(_sp_offset != 0, \"must be set\");\n+  *(int*)(((char*)chunk) + _sp_offset) = (int)value;\n+}\n+\n+inline address jdk_internal_vm_StackChunk::pc(oop chunk) {\n+  return chunk->address_field(_pc_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_pc(oop chunk, address value) {\n+  chunk->address_field_put(_pc_offset, value);\n+}\n+\n+inline int jdk_internal_vm_StackChunk::argsize(oop chunk) {\n+  return chunk->int_field(_argsize_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_argsize(oop chunk, int value) {\n+  chunk->int_field_put(_argsize_offset, value);\n+}\n+\n+inline uint8_t jdk_internal_vm_StackChunk::flags(oop chunk) {\n+  return Atomic::load(chunk->field_addr<uint8_t>(_flags_offset));\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_flags(oop chunk, uint8_t value) {\n+  Atomic::store(chunk->field_addr<uint8_t>(_flags_offset), value);\n+}\n+\n+inline uint8_t jdk_internal_vm_StackChunk::flags_acquire(oop chunk) {\n+  return Atomic::load_acquire(chunk->field_addr<uint8_t>(_flags_offset));\n+}\n+\n+inline void jdk_internal_vm_StackChunk::release_set_flags(oop chunk, uint8_t value) {\n+  Atomic::release_store(chunk->field_addr<uint8_t>(_flags_offset), value);\n+}\n+\n+inline bool jdk_internal_vm_StackChunk::try_set_flags(oop chunk, uint8_t expected_value, uint8_t new_value) {\n+  return Atomic::cmpxchg(chunk->field_addr<uint8_t>(_flags_offset), expected_value, new_value) == expected_value;\n+}\n+\n+inline int jdk_internal_vm_StackChunk::maxThawingSize(oop chunk) {\n+  return chunk->int_field(_maxThawingSize_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_maxThawingSize(oop chunk, int value) {\n+#ifdef ASSERT\n+  jint old = maxThawingSize(chunk);\n+  log_develop_trace(continuations)(\"%s max_size: %d -> %d\", value >= old ? \"add\" : \"sub\", old, value);\n+#endif\n+  chunk->int_field_put(_maxThawingSize_offset, value);\n+}\n+\n+#endif \/\/ SHARE_CLASSFILE_JDK_INTERNAL_VM_STACKCHUNK_INLINE_HPP\n","filename":"src\/hotspot\/share\/classfile\/continuationJavaClasses.inline.hpp","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/javaClassesImpl.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"classfile\/continuationJavaClasses.inline.hpp\"\n@@ -91,8 +93,0 @@\n-#define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \\\n-  klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);\n-\n-#if INCLUDE_CDS\n-#define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \\\n-  f->do_u4((u4*)&_##name##_offset);\n-#endif\n-\n@@ -122,1 +116,1 @@\n-  return _injected_fields[id].compute_offset();\n+  return _injected_fields[(int)id].compute_offset();\n@@ -140,1 +134,1 @@\n-    if (start == -1) start = klass##_##name##_enum;                \\\n+    if (start == -1) start = (int)InjectedFieldID::klass##_##name##_enum; \\\n@@ -156,3 +150,3 @@\n-static void compute_offset(int &dest_offset,\n-                           InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,\n-                           bool is_static = false) {\n+void JavaClasses::compute_offset(int &dest_offset,\n+                                 InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,\n+                                 bool is_static) {\n@@ -182,3 +176,3 @@\n-static void compute_offset(int& dest_offset, InstanceKlass* ik,\n-                           const char* name_string, Symbol* signature_symbol,\n-                           bool is_static = false) {\n+void JavaClasses::compute_offset(int& dest_offset, InstanceKlass* ik,\n+                                 const char* name_string, Symbol* signature_symbol,\n+                                 bool is_static) {\n@@ -194,10 +188,0 @@\n-\n-#if INCLUDE_CDS\n-#define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \\\n-  f->do_u4((u4*)&offset)\n-#endif\n-\n-#define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \\\n-  compute_offset(offset, klass, name, vmSymbols::signature(), is_static)\n-\n-\n@@ -5109,80 +5093,0 @@\n-\/\/ Support for jdk.internal.vm.Continuation\n-\n-int jdk_internal_vm_ContinuationScope::_name_offset;\n-int jdk_internal_vm_Continuation::_scope_offset;\n-int jdk_internal_vm_Continuation::_target_offset;\n-int jdk_internal_vm_Continuation::_tail_offset;\n-int jdk_internal_vm_Continuation::_parent_offset;\n-int jdk_internal_vm_Continuation::_yieldInfo_offset;\n-int jdk_internal_vm_Continuation::_mounted_offset;\n-int jdk_internal_vm_Continuation::_done_offset;\n-int jdk_internal_vm_Continuation::_preempted_offset;\n-\n-#define CONTINUATIONSCOPE_FIELDS_DO(macro) \\\n-  macro(_name_offset, k, vmSymbols::name_name(), string_signature, false);\n-\n-void jdk_internal_vm_ContinuationScope::compute_offsets() {\n-  InstanceKlass* k = vmClasses::ContinuationScope_klass();\n-  CONTINUATIONSCOPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void jdk_internal_vm_ContinuationScope::serialize_offsets(SerializeClosure* f) {\n-  CONTINUATIONSCOPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-\/\/ Support for jdk.internal.vm.Continuation\n-\n-#define CONTINUATION_FIELDS_DO(macro) \\\n-  macro(_scope_offset,     k, vmSymbols::scope_name(),     continuationscope_signature, false); \\\n-  macro(_target_offset,    k, vmSymbols::target_name(),    runnable_signature,          false); \\\n-  macro(_parent_offset,    k, vmSymbols::parent_name(),    continuation_signature,      false); \\\n-  macro(_yieldInfo_offset, k, vmSymbols::yieldInfo_name(), object_signature,            false); \\\n-  macro(_tail_offset,      k, vmSymbols::tail_name(),      stackchunk_signature,        false); \\\n-  macro(_mounted_offset,   k, vmSymbols::mounted_name(),   bool_signature,              false); \\\n-  macro(_done_offset,      k, vmSymbols::done_name(),      bool_signature,              false); \\\n-  macro(_preempted_offset, k, \"preempted\",                 bool_signature,              false);\n-\n-void jdk_internal_vm_Continuation::compute_offsets() {\n-  InstanceKlass* k = vmClasses::Continuation_klass();\n-  CONTINUATION_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void jdk_internal_vm_Continuation::serialize_offsets(SerializeClosure* f) {\n-  CONTINUATION_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-\/\/ Support for jdk.internal.vm.StackChunk\n-\n-int jdk_internal_vm_StackChunk::_parent_offset;\n-int jdk_internal_vm_StackChunk::_size_offset;\n-int jdk_internal_vm_StackChunk::_sp_offset;\n-int jdk_internal_vm_StackChunk::_pc_offset;\n-int jdk_internal_vm_StackChunk::_argsize_offset;\n-int jdk_internal_vm_StackChunk::_flags_offset;\n-int jdk_internal_vm_StackChunk::_maxThawingSize_offset;\n-int jdk_internal_vm_StackChunk::_cont_offset;\n-\n-#define STACKCHUNK_FIELDS_DO(macro) \\\n-  macro(_parent_offset,  k, vmSymbols::parent_name(),  stackchunk_signature, false); \\\n-  macro(_size_offset,    k, vmSymbols::size_name(),    int_signature,        false); \\\n-  macro(_sp_offset,      k, vmSymbols::sp_name(),      int_signature,        false); \\\n-  macro(_argsize_offset, k, vmSymbols::argsize_name(), int_signature,        false);\n-\n-void jdk_internal_vm_StackChunk::compute_offsets() {\n-  InstanceKlass* k = vmClasses::StackChunk_klass();\n-  STACKCHUNK_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-  STACKCHUNK_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void jdk_internal_vm_StackChunk::serialize_offsets(SerializeClosure* f) {\n-  STACKCHUNK_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-  STACKCHUNK_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-\n@@ -5510,0 +5414,57 @@\n+#define BASIC_JAVA_CLASSES_DO_PART1(f) \\\n+  f(java_lang_Class) \\\n+  f(java_lang_String) \\\n+  f(java_lang_ref_Reference) \\\n+  \/\/end\n+\n+#define BASIC_JAVA_CLASSES_DO_PART2(f) \\\n+  f(java_lang_System) \\\n+  f(java_lang_ClassLoader) \\\n+  f(java_lang_Throwable) \\\n+  f(java_lang_Thread) \\\n+  f(java_lang_Thread_FieldHolder) \\\n+  f(java_lang_Thread_Constants) \\\n+  f(java_lang_ThreadGroup) \\\n+  f(java_lang_VirtualThread) \\\n+  f(java_lang_InternalError) \\\n+  f(java_lang_AssertionStatusDirectives) \\\n+  f(java_lang_ref_SoftReference) \\\n+  f(java_lang_invoke_MethodHandle) \\\n+  f(java_lang_invoke_DirectMethodHandle) \\\n+  f(java_lang_invoke_MemberName) \\\n+  f(java_lang_invoke_ResolvedMethodName) \\\n+  f(java_lang_invoke_LambdaForm) \\\n+  f(java_lang_invoke_MethodType) \\\n+  f(java_lang_invoke_CallSite) \\\n+  f(java_lang_invoke_ConstantCallSite) \\\n+  f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \\\n+  f(java_security_AccessControlContext) \\\n+  f(java_lang_reflect_AccessibleObject) \\\n+  f(java_lang_reflect_Method) \\\n+  f(java_lang_reflect_Constructor) \\\n+  f(java_lang_reflect_Field) \\\n+  f(java_lang_reflect_RecordComponent) \\\n+  f(reflect_ConstantPool) \\\n+  f(reflect_UnsafeStaticFieldAccessorImpl) \\\n+  f(java_lang_reflect_Parameter) \\\n+  f(java_lang_Module) \\\n+  f(java_lang_StackTraceElement) \\\n+  f(java_lang_StackFrameInfo) \\\n+  f(java_lang_LiveStackFrameInfo) \\\n+  f(jdk_internal_vm_ContinuationScope) \\\n+  f(jdk_internal_vm_Continuation) \\\n+  f(jdk_internal_vm_StackChunk) \\\n+  f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \\\n+  f(jdk_internal_foreign_abi_NativeEntryPoint) \\\n+  f(jdk_internal_foreign_abi_ABIDescriptor) \\\n+  f(jdk_internal_foreign_abi_VMStorage) \\\n+  f(jdk_internal_foreign_abi_CallConv) \\\n+  f(jdk_internal_misc_UnsafeConstants) \\\n+  f(java_lang_boxing_object) \\\n+  f(vector_VectorPayload) \\\n+  \/\/end\n+\n+#define BASIC_JAVA_CLASSES_DO(f) \\\n+        BASIC_JAVA_CLASSES_DO_PART1(f) \\\n+        BASIC_JAVA_CLASSES_DO_PART2(f)\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":67,"deletions":106,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"oops\/stackChunkOop.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -40,59 +38,0 @@\n-\/\/ Interface for manipulating the basic Java classes.\n-\n-#define BASIC_JAVA_CLASSES_DO_PART1(f) \\\n-  f(java_lang_Class) \\\n-  f(java_lang_String) \\\n-  f(java_lang_ref_Reference) \\\n-  \/\/end\n-\n-#define BASIC_JAVA_CLASSES_DO_PART2(f) \\\n-  f(java_lang_System) \\\n-  f(java_lang_ClassLoader) \\\n-  f(java_lang_Throwable) \\\n-  f(java_lang_Thread) \\\n-  f(java_lang_Thread_FieldHolder) \\\n-  f(java_lang_Thread_Constants) \\\n-  f(java_lang_ThreadGroup) \\\n-  f(java_lang_VirtualThread) \\\n-  f(java_lang_InternalError) \\\n-  f(java_lang_AssertionStatusDirectives) \\\n-  f(java_lang_ref_SoftReference) \\\n-  f(java_lang_invoke_MethodHandle) \\\n-  f(java_lang_invoke_DirectMethodHandle) \\\n-  f(java_lang_invoke_MemberName) \\\n-  f(java_lang_invoke_ResolvedMethodName) \\\n-  f(java_lang_invoke_LambdaForm) \\\n-  f(java_lang_invoke_MethodType) \\\n-  f(java_lang_invoke_CallSite) \\\n-  f(java_lang_invoke_ConstantCallSite) \\\n-  f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \\\n-  f(java_security_AccessControlContext) \\\n-  f(java_lang_reflect_AccessibleObject) \\\n-  f(java_lang_reflect_Method) \\\n-  f(java_lang_reflect_Constructor) \\\n-  f(java_lang_reflect_Field) \\\n-  f(java_lang_reflect_RecordComponent) \\\n-  f(reflect_ConstantPool) \\\n-  f(reflect_UnsafeStaticFieldAccessorImpl) \\\n-  f(java_lang_reflect_Parameter) \\\n-  f(java_lang_Module) \\\n-  f(java_lang_StackTraceElement) \\\n-  f(java_lang_StackFrameInfo) \\\n-  f(java_lang_LiveStackFrameInfo) \\\n-  f(jdk_internal_vm_ContinuationScope) \\\n-  f(jdk_internal_vm_Continuation) \\\n-  f(jdk_internal_vm_StackChunk) \\\n-  f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \\\n-  f(jdk_internal_foreign_abi_NativeEntryPoint) \\\n-  f(jdk_internal_foreign_abi_ABIDescriptor) \\\n-  f(jdk_internal_foreign_abi_VMStorage) \\\n-  f(jdk_internal_foreign_abi_CallConv) \\\n-  f(jdk_internal_misc_UnsafeConstants) \\\n-  f(java_lang_boxing_object) \\\n-  f(vector_VectorPayload) \\\n-  \/\/end\n-\n-#define BASIC_JAVA_CLASSES_DO(f) \\\n-        BASIC_JAVA_CLASSES_DO_PART1(f) \\\n-        BASIC_JAVA_CLASSES_DO_PART2(f)\n-\n@@ -1087,106 +1026,0 @@\n-\/\/ Interface to jdk.internal.vm.ContinuationScope objects\n-class jdk_internal_vm_ContinuationScope: AllStatic {\n-  friend class JavaClasses;\n- private:\n-  static int _name_offset;\n-\n-  static void compute_offsets();\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  static inline oop name(oop ref);\n-};\n-\n-\/\/ Interface to jdk.internal.vm.Continuation objects\n-class jdk_internal_vm_Continuation: AllStatic {\n-  friend class JavaClasses;\n- private:\n-  static int _scope_offset;\n-  static int _target_offset;\n-  static int _parent_offset;\n-  static int _yieldInfo_offset;\n-  static int _tail_offset;\n-  static int _mounted_offset;\n-  static int _done_offset;\n-  static int _preempted_offset;\n-\n-  static void compute_offsets();\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-  \/\/ Accessors\n-  static inline oop scope(oop continuation);\n-  static inline oop target(oop continuation);\n-  static inline oop parent(oop continuation);\n-  static inline oop yieldInfo(oop continuation);\n-  static inline void set_yieldInfo(oop continuation, oop value);\n-  static inline stackChunkOop tail(oop continuation);\n-  static inline void set_tail(oop continuation, stackChunkOop value);\n-  static inline bool on_local_stack(oop continuation, address adr);\n-  static inline bool done(oop continuation);\n-  static inline bool is_preempted(oop continuation);\n-  static inline void set_preempted(oop continuation, bool value);\n-};\n-\n-\/\/ Interface to jdk.internal.vm.StackChunk objects\n-#define STACKCHUNK_INJECTED_FIELDS(macro)                                    \\\n-  macro(jdk_internal_vm_StackChunk, cont,           continuation_signature, false)  \\\n-  macro(jdk_internal_vm_StackChunk, flags,          byte_signature, false)          \\\n-  macro(jdk_internal_vm_StackChunk, pc,             intptr_signature, false)        \\\n-  macro(jdk_internal_vm_StackChunk, maxThawingSize, int_signature, false)           \\\n-\n-class jdk_internal_vm_StackChunk: AllStatic {\n-  friend class JavaClasses;\n- private:\n-  static int _parent_offset;\n-  static int _size_offset;\n-  static int _sp_offset;\n-  static int _pc_offset;\n-  static int _argsize_offset;\n-  static int _flags_offset;\n-  static int _maxThawingSize_offset;\n-  static int _cont_offset;\n-\n-\n-  static void compute_offsets();\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n-  static inline int parent_offset() { return _parent_offset; }\n-  static inline int cont_offset()   { return _cont_offset; }\n-\n-  \/\/ Accessors\n-  static inline oop parent(oop chunk);\n-  static inline void set_parent(oop chunk, oop value);\n-  template<typename P>\n-  static inline bool is_parent_null(oop chunk); \/\/ bypasses barriers for a faster test\n-  template<typename P>\n-  static inline void set_parent_raw(oop chunk, oop value);\n-\n-  static inline int size(oop chunk);\n-  static inline void set_size(HeapWord* chunk, int value);\n-\n-  static inline int sp(oop chunk);\n-  static inline void set_sp(oop chunk, int value);\n-  static inline void set_sp(HeapWord* chunk, int value); \/\/ used while allocating\n-  static inline address pc(oop chunk);\n-  static inline void set_pc(oop chunk, address value);\n-  static inline int argsize(oop chunk);\n-  static inline void set_argsize(oop chunk, int value);\n-  static inline uint8_t flags(oop chunk);\n-  static inline void set_flags(oop chunk, uint8_t value);\n-  static inline uint8_t flags_acquire(oop chunk);\n-  static inline void release_set_flags(oop chunk, uint8_t value);\n-  static inline bool try_set_flags(oop chunk, uint8_t expected_value, uint8_t new_value);\n-\n-  static inline int maxThawingSize(oop chunk);\n-  static inline void set_maxThawingSize(oop chunk, int value);\n-\n- \/\/ cont oop's processing is essential for the chunk's GC protocol\n-  static inline oop cont(oop chunk);\n-  static inline void set_cont(oop chunk, oop value);\n-  template<typename P>\n-  static inline oop cont_raw(oop chunk);\n-  template<typename P>\n-  static inline void set_cont_raw(oop chunk, oop value);\n-};\n-\n@@ -2070,16 +1903,0 @@\n-#define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \\\n-  klass##_##name##_enum,\n-\n-#define ALL_INJECTED_FIELDS(macro)          \\\n-  STRING_INJECTED_FIELDS(macro)             \\\n-  CLASS_INJECTED_FIELDS(macro)              \\\n-  CLASSLOADER_INJECTED_FIELDS(macro)        \\\n-  RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \\\n-  MEMBERNAME_INJECTED_FIELDS(macro)         \\\n-  CALLSITECONTEXT_INJECTED_FIELDS(macro)    \\\n-  STACKFRAMEINFO_INJECTED_FIELDS(macro)     \\\n-  MODULE_INJECTED_FIELDS(macro)             \\\n-  THREAD_INJECTED_FIELDS(macro)             \\\n-  INTERNALERROR_INJECTED_FIELDS(macro)      \\\n-  STACKCHUNK_INJECTED_FIELDS(macro)\n-\n@@ -2089,0 +1906,2 @@\n+enum class InjectedFieldID : int;\n+\n@@ -2096,4 +1915,0 @@\n-  enum InjectedFieldID {\n-    ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)\n-    MAX_enum\n-  };\n@@ -2108,1 +1923,0 @@\n-};\n@@ -2110,1 +1924,7 @@\n-#undef DECLARE_INJECTED_FIELD_ENUM\n+  static void compute_offset(int &dest_offset,\n+                             InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,\n+                             bool is_static = false);\n+  static void compute_offset(int& dest_offset, InstanceKlass* ik,\n+                             const char* name_string, Symbol* signature_symbol,\n+                             bool is_static = false);\n+};\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":9,"deletions":189,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"logging\/log.hpp\"\n@@ -36,1 +35,0 @@\n-#include \"oops\/stackChunkOop.inline.hpp\"\n@@ -223,153 +221,0 @@\n-inline oop jdk_internal_vm_ContinuationScope::name(oop ref) {\n-  return ref->obj_field(_name_offset);\n-}\n-\n-inline oop jdk_internal_vm_Continuation::scope(oop continuation) {\n-  return continuation->obj_field(_scope_offset);\n-}\n-\n-inline oop jdk_internal_vm_Continuation::target(oop continuation) {\n-  return continuation->obj_field(_target_offset);\n-}\n-\n-inline oop jdk_internal_vm_Continuation::parent(oop continuation) {\n-  return continuation->obj_field(_parent_offset);\n-}\n-\n-inline oop jdk_internal_vm_Continuation::yieldInfo(oop continuation) {\n-  return continuation->obj_field(_yieldInfo_offset);\n-}\n-\n-inline void jdk_internal_vm_Continuation::set_yieldInfo(oop continuation, oop value) {\n-  continuation->obj_field_put(_yieldInfo_offset, value);\n-}\n-\n-inline stackChunkOop jdk_internal_vm_Continuation::tail(oop continuation) {\n-  return stackChunkOopDesc::cast(continuation->obj_field(_tail_offset));\n-}\n-\n-inline void jdk_internal_vm_Continuation::set_tail(oop continuation, stackChunkOop value) {\n-  continuation->obj_field_put(_tail_offset, value);\n-}\n-\n-inline bool jdk_internal_vm_Continuation::done(oop continuation) {\n-  return continuation->bool_field(_done_offset);\n-}\n-\n-inline bool jdk_internal_vm_Continuation::is_preempted(oop continuation) {\n-  return continuation->bool_field(_preempted_offset);\n-}\n-\n-inline void jdk_internal_vm_Continuation::set_preempted(oop continuation, bool value) {\n-  continuation->bool_field_put(_preempted_offset, (jboolean)value);\n-}\n-\n-inline oop jdk_internal_vm_StackChunk::parent(oop chunk) {\n-  return chunk->obj_field(_parent_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_parent(oop chunk, oop value) {\n-  chunk->obj_field_put(_parent_offset, value);\n-}\n-\n-template<typename P>\n-inline bool jdk_internal_vm_StackChunk::is_parent_null(oop chunk) {\n-  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_parent_offset)) == NULL;\n-}\n-\n-template<typename P>\n-inline void jdk_internal_vm_StackChunk::set_parent_raw(oop chunk, oop value) {\n-  RawAccess<>::oop_store(chunk->field_addr<P>(_parent_offset), value);\n-}\n-\n-inline oop jdk_internal_vm_StackChunk::cont(oop chunk) {\n-  return chunk->obj_field(_cont_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_cont(oop chunk, oop value) {\n-  chunk->obj_field_put(_cont_offset, value);\n-}\n-\n-template<typename P>\n-inline oop jdk_internal_vm_StackChunk::cont_raw(oop chunk) {\n-  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_cont_offset));\n-}\n-\n-template<typename P>\n-inline void jdk_internal_vm_StackChunk::set_cont_raw(oop chunk, oop value) {\n-  RawAccess<>::oop_store(chunk->field_addr<P>(_cont_offset), value);\n-}\n-\n-inline int jdk_internal_vm_StackChunk::size(oop chunk) {\n-  return chunk->int_field(_size_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_size(HeapWord* chunk, int value) {\n-  \/\/ Used by StackChunkAllocator before the Object has been finished,\n-  \/\/ so don't cast too oop and use int_field_put in this function.\n-  assert(_size_offset != 0, \"must be set\");\n-  *(int*)(((char*)chunk) + _size_offset) = (int)value;\n-}\n-\n-inline int jdk_internal_vm_StackChunk::sp(oop chunk) {\n-  return chunk->int_field(_sp_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_sp(oop chunk, int value) {\n-  chunk->int_field_put(_sp_offset, value);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_sp(HeapWord* chunk, int value) {\n-  \/\/ Used by StackChunkAllocator before the Object has been finished,\n-  \/\/ so don't cast too oop and use int_field_put in this function.\n-  assert(_sp_offset != 0, \"must be set\");\n-  *(int*)(((char*)chunk) + _sp_offset) = (int)value;\n-}\n-\n-inline address jdk_internal_vm_StackChunk::pc(oop chunk) {\n-  return chunk->address_field(_pc_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_pc(oop chunk, address value) {\n-  chunk->address_field_put(_pc_offset, value);\n-}\n-\n-inline int jdk_internal_vm_StackChunk::argsize(oop chunk) {\n-  return chunk->int_field(_argsize_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_argsize(oop chunk, int value) {\n-  chunk->int_field_put(_argsize_offset, value);\n-}\n-\n-inline uint8_t jdk_internal_vm_StackChunk::flags(oop chunk) {\n-  return Atomic::load(chunk->field_addr<uint8_t>(_flags_offset));\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_flags(oop chunk, uint8_t value) {\n-  Atomic::store(chunk->field_addr<uint8_t>(_flags_offset), value);\n-}\n-\n-inline uint8_t jdk_internal_vm_StackChunk::flags_acquire(oop chunk) {\n-  return Atomic::load_acquire(chunk->field_addr<uint8_t>(_flags_offset));\n-}\n-\n-inline void jdk_internal_vm_StackChunk::release_set_flags(oop chunk, uint8_t value) {\n-  Atomic::release_store(chunk->field_addr<uint8_t>(_flags_offset), value);\n-}\n-\n-inline bool jdk_internal_vm_StackChunk::try_set_flags(oop chunk, uint8_t expected_value, uint8_t new_value) {\n-  return Atomic::cmpxchg(chunk->field_addr<uint8_t>(_flags_offset), expected_value, new_value) == expected_value;\n-}\n-\n-inline int jdk_internal_vm_StackChunk::maxThawingSize(oop chunk) {\n-  return chunk->int_field(_maxThawingSize_offset);\n-}\n-\n-inline void jdk_internal_vm_StackChunk::set_maxThawingSize(oop chunk, int value) {\n-#ifdef ASSERT\n-  jint old = maxThawingSize(chunk);\n-  log_develop_trace(continuations)(\"%s max_size: %d -> %d\", value >= old ? \"add\" : \"sub\", old, value);\n-#endif\n-  chunk->int_field_put(_maxThawingSize_offset, value);\n-}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":155,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_JAVACLASSES_IMPL_HPP\n+#define SHARE_CLASSFILE_JAVACLASSES_IMPL_HPP\n+\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/continuationJavaClasses.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \\\n+  klass##_##name##_enum,\n+\n+#define ALL_INJECTED_FIELDS(macro)          \\\n+  STRING_INJECTED_FIELDS(macro)             \\\n+  CLASS_INJECTED_FIELDS(macro)              \\\n+  CLASSLOADER_INJECTED_FIELDS(macro)        \\\n+  RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \\\n+  MEMBERNAME_INJECTED_FIELDS(macro)         \\\n+  CALLSITECONTEXT_INJECTED_FIELDS(macro)    \\\n+  STACKFRAMEINFO_INJECTED_FIELDS(macro)     \\\n+  MODULE_INJECTED_FIELDS(macro)             \\\n+  THREAD_INJECTED_FIELDS(macro)             \\\n+  INTERNALERROR_INJECTED_FIELDS(macro)      \\\n+  STACKCHUNK_INJECTED_FIELDS(macro)\n+\n+#define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \\\n+  klass::_##name##_offset = JavaClasses::compute_injected_offset(InjectedFieldID::klass##_##name##_enum);\n+\n+#if INCLUDE_CDS\n+#define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \\\n+  f->do_u4((u4*)&_##name##_offset);\n+#endif\n+\n+#if INCLUDE_CDS\n+#define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \\\n+  f->do_u4((u4*)&offset)\n+#endif\n+\n+#define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \\\n+  JavaClasses::compute_offset(offset, klass, name, vmSymbols::signature(), is_static)\n+\n+\n+enum class InjectedFieldID : int {\n+  ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)\n+  MAX_enum\n+};\n+\n+#undef DECLARE_INJECTED_FIELD_ENUM\n+\n+#endif \/\/ SHARE_CLASSFILE_JAVACLASSES_IMPL_HPP\n","filename":"src\/hotspot\/share\/classfile\/javaClassesImpl.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/stackChunkOop.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/continuationJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/continuationJavaClasses.hpp\"\n@@ -44,0 +44,1 @@\n+#include \"oops\/stackChunkOop.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/continuationJavaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/codeCache.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}