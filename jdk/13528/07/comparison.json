{"files":[{"patch":"@@ -71,0 +71,2 @@\n+        @JEP(number=443, title=\"Unnamed Patterns and Variables\")\n+        UNNAMED,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,3 +134,4 @@\n-     * PackageElement#getSimpleName package} or unnamed {@linkplain\n-     * ModuleElement#getSimpleName module}, an {@linkplain\n-     * Name##empty_name empty name} is returned.\n+     * PackageElement#getSimpleName package}, an unnamed {@linkplain\n+     * ModuleElement#getSimpleName module} or an unnamed {@linkplain\n+     * VariableElement#getSimpleName module}, an {@linkplain Name##empty_name empty name}\n+     * is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -84,0 +86,3 @@\n+     *\n+     * <p>For variables, the name of each variable is returned or an empty name\n+     * if the variable is unnamed.\n@@ -96,0 +101,14 @@\n+\n+    \/**\n+     * {@return {@code true} if this is an unnamed variable and {@code\n+     * false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method returns {@code\n+     * false}.\n+     *\n+     * @jls 6.1 Declarations\n+     * @jls 14.4 Local Variable Declarations\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED, reflective = true)\n+    default boolean isUnnamed() { return false; }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -710,0 +712,15 @@\n+    \/**\n+     * {@return {@code true} if the element has an empty name, {@code false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method returns {@code\n+     * false}.\n+     *\n+     * @param element the element being examined\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED, reflective = true)\n+    default boolean isUnnamed(Element element) {\n+        return false;\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+\/**\n+ * A binding pattern tree\n+ *\n+ *\/\n+public interface AnyPatternTree extends PatternTree {\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/AnyPatternTree.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -222,0 +222,7 @@\n+        \/**\n+         * Used for instances of {@link BindingPatternTree}.\n+         *\n+         * @since 21\n+         *\/\n+        ANY_PATTERN(AnyPatternTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -260,0 +260,9 @@\n+    \/**\n+     * Visits a {@code AnyPatternTree} node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 21\n+     *\/\n+    R visitAnyPattern(AnyPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-     * Returns the name of the variable being declared.\n+     * Returns the name of the variable being declared or `_` if the variable\n+     * is unnamed.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/VariableTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -632,0 +632,15 @@\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 21\n+     *\/\n+    @Override\n+    public R visitAnyPattern(AnyPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -762,0 +762,15 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 21\n+     *\/\n+    @Override\n+    public R visitAnyPattern(AnyPatternTree node, P p) {\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-     * Currently available: Bit 48.\n+     * Flag that indicates that a local variable, a lambda parameter, or an unnamed pattern variable is unnamed.\n@@ -280,0 +280,1 @@\n+    public static final long UNNAMED = 1L<<48;\n@@ -520,0 +521,1 @@\n+        UNNAMED(Flags.UNNAMED),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+            case UNNAMED_VARIABLES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,0 +240,1 @@\n+        UNNAMED_VARIABLES(JDK21, Fragments.FeatureUnnamedVariables, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -438,0 +438,4 @@\n+    public boolean isUnnamed() {\n+        return (flags_field & UNNAMED) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1777,0 +1777,3 @@\n+                        } else if (guard != null) {\n+                            \/\/ if the label has multiple patterns and a guard (with binding from the switch environment)\n+                            attribExpr(guard, switchEnv, syms.booleanType);\n@@ -4148,0 +4151,5 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree.type = resultInfo.pt;\n+    }\n+\n@@ -4169,1 +4177,5 @@\n-        matchBindings = new MatchBindings(List.of(v), List.nil());\n+        if (v.isUnnamed()) {\n+            matchBindings = MatchBindingsComputer.EMPTY;\n+        } else {\n+            matchBindings = new MatchBindings(List.of(v), List.nil());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4550,2 +4550,5 @@\n-            } else {\n-                if (c.labels.tail.nonEmpty()) {\n+            } else if (c.labels.tail.nonEmpty()) {\n+                var patterCaseLabels = c.labels.stream().filter(ll -> ll instanceof JCPatternCaseLabel).map(cl -> (JCPatternCaseLabel)cl);\n+                var allUnderscore = patterCaseLabels.allMatch(pcl -> !hasBindings(pcl.getPattern()));\n+\n+                if (!allUnderscore) {\n@@ -4586,1 +4589,1 @@\n-                bindings[0] = true;\n+                bindings[0] = !tree.var.sym.isUnnamed();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-            public static PatternDescription from(Types types, Type selectorType, JCPattern pattern) {\n+            public static PatternDescription from(Types types, Type selectorType, JCPattern pattern, Symtab syms) {\n@@ -761,1 +761,1 @@\n-                        nestedDescriptions[i] = PatternDescription.from(types, componentTypes[i], it.head);\n+                        nestedDescriptions[i] = PatternDescription.from(types, types.erasure(componentTypes[i]), it.head, syms);\n@@ -764,0 +764,4 @@\n+                } else if (pattern instanceof JCAnyPattern) {\n+                    Type type = types.isSubtype(selectorType, syms.objectType)\n+                            ? selectorType : syms.objectType;\n+                    return new BindingPattern(type);\n@@ -836,1 +840,1 @@\n-                            patternSet.add(PatternDescription.from(types, component, patternLabel.pat));\n+                            patternSet.add(PatternDescription.from(types, component, patternLabel.pat, syms));\n@@ -2884,1 +2888,1 @@\n-                    if (unrefdResources.includes(resVar.sym)) {\n+                    if (unrefdResources.includes(resVar.sym) && !resVar.sym.isUnnamed()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -58,0 +59,2 @@\n+    \/** The Source language setting. *\/\n+    private final Source source;\n@@ -65,0 +68,1 @@\n+    private final Names names;\n@@ -84,0 +88,2 @@\n+        source = Source.instance(context);\n+        names = Names.instance(context);\n@@ -288,1 +294,7 @@\n-        VarSymbol v = new VarSymbol(0, tree.name, vartype, enclScope.owner);\n+        Name name;\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && (tree.mods.flags & UNNAMED) != 0) {\n+            name = names.empty;\n+        } else {\n+            name = tree.name;\n+        }\n+        VarSymbol v = new VarSymbol(0, name , vartype, enclScope.owner);\n@@ -300,6 +312,9 @@\n-        if (chk.checkUnique(tree.pos(), v, enclScope)) {\n-            chk.checkTransparentVar(tree.pos(), v, enclScope);\n-            enclScope.enter(v);\n-        } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {\n-            \/\/ if this is a parameter or a field obtained from a record component, enter it\n-            enclScope.enter(v);\n+\n+        if(!(Feature.UNNAMED_VARIABLES.allowedInSource(source) && tree.sym.isUnnamed())) {\n+            if (chk.checkUnique(tree.pos(), v, enclScope)) {\n+                chk.checkTransparentVar(tree.pos(), v, enclScope);\n+                enclScope.enter(v);\n+            } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {\n+                \/\/ if this is a parameter or a field obtained from a record component, enter it\n+                enclScope.enter(v);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCAnyPattern;\n@@ -68,2 +69,1 @@\n-import java.util.Collections;\n-import java.util.Map;\n+import java.util.*;\n@@ -71,4 +71,0 @@\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Set;\n@@ -264,0 +260,5 @@\n+    @Override\n+    public void visitAnyPattern(JCTree.JCAnyPattern that) {\n+        result = make.Literal(true);\n+    }\n+\n@@ -271,1 +272,1 @@\n-        if (bindingVar != null) {\n+        if (bindingVar != null && !bindingVar.isUnnamed()) {\n@@ -314,1 +315,1 @@\n-            JCBindingPattern nestedBinding;\n+            JCPattern nestedBinding;\n@@ -328,1 +329,5 @@\n-            } else {\n+            } else if (nestedPattern instanceof JCAnyPattern nestedRecordPattern) {\n+                allowNull = true;\n+                nestedBinding = nestedRecordPattern;\n+            }\n+            else {\n@@ -440,6 +445,5 @@\n-                            if (cse.guard != null) {\n-                                cse.guard = mergeConditions(guard, cse.guard);\n-                            } else {\n-                                cse.guard = guard;\n-                            }\n-                            return make.PatternCaseLabel(deconstructed.primaryPattern());\n+\n+                            JCPatternCaseLabel newPatternCaseLabel = make.PatternCaseLabel(deconstructed.primaryPattern());\n+                            newPatternCaseLabel.syntheticGuard = guard;\n+\n+                            return newPatternCaseLabel;\n@@ -527,2 +531,8 @@\n-                if (clearedPatterns.size() == 1 && clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL) && !previousCompletesNormally) {\n-                    JCPatternCaseLabel label = (JCPatternCaseLabel) clearedPatterns.head;\n+\n+                boolean validCaseLabelList;\n+                if (clearedPatterns.size() > 1) {\n+                    validCaseLabelList = clearedPatterns.stream().allMatch(cP -> cP.hasTag(Tag.PATTERNCASELABEL));\n+                } else validCaseLabelList = clearedPatterns.size() == 1 && clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL);\n+\n+                if (validCaseLabelList && !previousCompletesNormally) {\n+                    List<JCPatternCaseLabel> labels = clearedPatterns.stream().map(cp -> (JCPatternCaseLabel)cp).collect(List.collector());\n@@ -533,1 +543,27 @@\n-                        JCExpression test = (JCExpression) this.<JCTree>translate(label.pat);\n+                        JCExpression test = null;\n+                        JCExpression accTest = null;\n+                        boolean first = true;\n+\n+                        boolean multiplePatternsAndDifferent = labels.size() > 1 &&\n+                                !labels.stream().map(l -> l.pat.type.tsym).allMatch(labels.get(0).pat.type.tsym::equals);\n+\n+                        for (JCPatternCaseLabel label: labels) {\n+                            test = (JCExpression) this.<JCTree>translate(label.pat);\n+\n+                            if (multiplePatternsAndDifferent) {\n+                                test = makeBinary(Tag.AND, makeTypeTest(make.Ident(temp), make.Type(label.pat.type)), test);\n+                            }\n+\n+                            if (label.syntheticGuard != null) {\n+                                JCExpression guard = translate(label.syntheticGuard);\n+                                test = makeBinary(Tag.AND, test, guard);\n+                            }\n+\n+                            if (!first) {\n+                                accTest = makeBinary(Tag.OR, accTest, test);\n+                            } else {\n+                                accTest = test;\n+                                first = false;\n+                            }\n+                        }\n+\n@@ -535,2 +571,4 @@\n-                            JCExpression guard = translate(c.guard);\n-                            test = makeBinary(Tag.AND, test, guard);\n+                            test = makeBinary(Tag.AND, accTest, translate(c.guard));\n+                            c.guard = null;\n+                        } else {\n+                            test = accTest;\n@@ -538,0 +576,1 @@\n+\n@@ -543,1 +582,1 @@\n-                                                                                                       makeLit(syms.intType, i + 1))\n+                                                                                                       makeLit(syms.intType, i + labels.length()))\n@@ -701,1 +740,1 @@\n-                    JCExpression lastGuard = null;\n+                    boolean hasGuard = false;\n@@ -716,1 +755,1 @@\n-                        if (accummulated.guard instanceof JCBinary binOp) {\n+                        if (accummulatedFirstLabel.syntheticGuard instanceof JCBinary binOp) {\n@@ -721,1 +760,1 @@\n-                            instanceofCheck = (JCInstanceOf) accummulated.guard;\n+                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.syntheticGuard;\n@@ -728,0 +767,4 @@\n+\n+                        JCPatternCaseLabel jcPatternCaseLabelWithGuard = make.PatternCaseLabel(binding);\n+                        jcPatternCaseLabelWithGuard.syntheticGuard = newGuard;\n+\n@@ -730,1 +773,1 @@\n-                                    make.PatternCaseLabel(binding));\n+                                    jcPatternCaseLabelWithGuard);\n@@ -732,1 +775,1 @@\n-                            newLabel = List.of(make.PatternCaseLabel(binding));\n+                            newLabel = List.of(jcPatternCaseLabelWithGuard);\n@@ -734,1 +777,1 @@\n-                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, newGuard,\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.guard,\n@@ -736,1 +779,1 @@\n-                        lastGuard = newGuard;\n+                        hasGuard = newGuard != null || accummulated.guard != null;\n@@ -738,1 +781,1 @@\n-                    if (lastGuard != null || !hasUnconditional) {\n+                    if (hasGuard || !hasUnconditional) {\n@@ -754,0 +797,1 @@\n+                    leadingTest.syntheticGuard = null;\n@@ -778,1 +822,1 @@\n-                if (c.head.guard instanceof JCBinary binOp &&\n+                if (patternLabel.syntheticGuard instanceof JCBinary binOp &&\n@@ -785,1 +829,1 @@\n-                } else if (c.head.guard instanceof JCInstanceOf instanceofCheck &&\n+                } else if (patternLabel.syntheticGuard instanceof JCInstanceOf instanceofCheck &&\n@@ -1376,0 +1420,6 @@\n+\n+        @Override\n+        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+            super.visitPatternCaseLabel(tree);\n+            scan(tree.syntheticGuard);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":81,"deletions":31,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -559,0 +559,5 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+@SuppressWarnings(\"preview\")\n@@ -722,0 +723,6 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public boolean isUnnamed(Element element) {\n+        Symbol sym = (Symbol) element;\n+        return (sym.flags() & Flags.UNNAMED) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import java.util.function.BiFunction;\n@@ -593,0 +592,8 @@\n+        return ident(allowClass, false);\n+    }\n+\n+    public Name identOrUnderscore() {\n+        return ident(false, true);\n+    }\n+\n+    protected Name ident(boolean allowClass, boolean asVariable) {\n@@ -618,0 +625,2 @@\n+            } else if (asVariable) {\n+                checkSourceLevel(Feature.UNNAMED_VARIABLES);\n@@ -780,1 +789,0 @@\n-\n@@ -786,5 +794,13 @@\n-        if (parsedType == null) {\n-            boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n-            e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n-            if (var) {\n-                e = null;\n+        if (token.kind == UNDERSCORE && parsedType == null) {\n+            nextToken();\n+            pattern = toP(F.at(token.pos).AnyPattern());\n+        }\n+        else {\n+            if (parsedType == null) {\n+                boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n+                e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n+                if (var) {\n+                    e = null;\n+                }\n+            } else {\n+                e = parsedType;\n@@ -792,9 +808,11 @@\n-        } else {\n-            e = parsedType;\n-        }\n-        if (token.kind == LPAREN) {\n-            \/\/deconstruction pattern:\n-            checkSourceLevel(Feature.RECORD_PATTERNS);\n-            ListBuffer<JCPattern> nested = new ListBuffer<>();\n-            if (!peekToken(RPAREN)) {\n-                do {\n+            if (token.kind == LPAREN) {\n+                \/\/deconstruction pattern:\n+                checkSourceLevel(Feature.RECORD_PATTERNS);\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                if (!peekToken(RPAREN)) {\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                } else {\n@@ -802,3 +820,3 @@\n-                    JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n-                    nested.append(nestedPattern);\n-                } while (token.kind == COMMA);\n+                }\n+                accept(RPAREN);\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n@@ -806,9 +824,14 @@\n-                nextToken();\n-            }\n-            accept(RPAREN);\n-            pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n-        } else {\n-            \/\/type test pattern:\n-            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n-            if (e == null) {\n-                var.startPos = pos;\n+                \/\/type test pattern:\n+                int varPos = token.pos;\n+                Name name = identOrUnderscore();\n+                if (name == names.underscore) {\n+                    mods.flags |= Flags.UNNAMED;\n+                }\n+                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n+                if (e == null) {\n+                    var.startPos = pos;\n+                    if (name == names.underscore) {\n+                        log.error(DiagnosticFlag.SYNTAX, varPos, Errors.UnderscoreAsIdentifier);\n+                    }\n+                }\n+                pattern = toP(F.at(pos).BindingPattern(var));\n@@ -816,1 +839,0 @@\n-            pattern = toP(F.at(pos).BindingPattern(var));\n@@ -821,1 +843,0 @@\n-\n@@ -1018,0 +1039,3 @@\n+                    } else if (token.kind == UNDERSCORE) {\n+                        checkSourceLevel(token.pos, Feature.UNNAMED_VARIABLES);\n+                        pattern = parsePattern(patternPos, mods, type, false, false);\n@@ -2993,1 +3017,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, true, false, false);\n@@ -3159,1 +3183,1 @@\n-                case ASSERT, ENUM, IDENTIFIER, UNDERSCORE:\n+                case ASSERT, ENUM, IDENTIFIER:\n@@ -3168,0 +3192,12 @@\n+                case UNDERSCORE:\n+                    \/\/ TODO: REFACTOR to remove the code duplication\n+                    if (typeDepth == 0 && peekToken(lookahead, tk -> tk == RPAREN || tk == COMMA)) {\n+                        return PatternResult.PATTERN;\n+                    } else if (typeDepth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) {\n+                        if (parenDepth == 0) {\n+                            return PatternResult.PATTERN;\n+                        } else {\n+                            pendingResult = PatternResult.PATTERN;\n+                        }\n+                    }\n+                    break;\n@@ -3475,1 +3511,1 @@\n-        return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);\n+        return variableDeclaratorsRest(token.pos, mods, type, identOrUnderscore(), false, null, vdefs, localDecl);\n@@ -3508,1 +3544,1 @@\n-        return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);\n+        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true);\n@@ -3522,0 +3558,8 @@\n+\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+            mods.flags |= Flags.UNNAMED;\n+            if (!localDecl) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.UnderscoreAsIdentifier);\n+            }\n+        }\n+\n@@ -3609,5 +3653,1 @@\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {\n-        return variableDeclaratorId(mods, type, false, false);\n-    }\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean catchParameter, boolean lambdaParameter, boolean recordComponent) {\n@@ -3616,32 +3656,9 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n-            log.error(pos, Errors.UnderscoreAsIdentifierInLambda);\n-            name = token.name();\n-            nextToken();\n-        } else {\n-            if (allowThisIdent ||\n-                !lambdaParameter ||\n-                LAX_IDENTIFIER.test(token.kind) ||\n-                mods.flags != Flags.PARAMETER ||\n-                mods.annotations.nonEmpty()) {\n-                JCExpression pn = qualident(false);\n-                if (pn.hasTag(Tag.IDENT) && ((JCIdent)pn).name != names._this) {\n-                    name = ((JCIdent)pn).name;\n-                } else if (lambdaParameter && type == null) {\n-                    \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n-                    type = pn;\n-                    name = names.empty;\n-                    reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n-                } else {\n-                    if (allowThisIdent) {\n-                        if ((mods.flags & Flags.VARARGS) != 0) {\n-                            log.error(token.pos, Errors.VarargsAndReceiver);\n-                        }\n-                        if (token.kind == LBRACKET) {\n-                            log.error(token.pos, Errors.ArrayAndReceiver);\n-                        }\n-                        if (pn.hasTag(Tag.SELECT) && ((JCFieldAccess)pn).name != names._this) {\n-                            log.error(token.pos, Errors.WrongReceiver);\n-                        }\n-                    }\n-                    return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n-                }\n+        if (allowThisIdent ||\n+            !lambdaParameter ||\n+            LAX_IDENTIFIER.test(token.kind) ||\n+            mods.flags != Flags.PARAMETER ||\n+            mods.annotations.nonEmpty()) {\n+            JCExpression pn;\n+            if (token.kind == UNDERSCORE && (catchParameter || lambdaParameter)) {\n+                mods.flags |= Flags.UNNAMED;\n+                pn = toP(F.at(token.pos).Ident(identOrUnderscore()));\n@@ -3649,7 +3666,7 @@\n-                \/** if it is a lambda parameter and the token kind is not an identifier,\n-                 *  and there are no modifiers or annotations, then this means that the compiler\n-                 *  supposed the lambda to be explicit but it can contain a mix of implicit,\n-                 *  var or explicit parameters. So we assign the error name to the parameter name\n-                 *  instead of issuing an error and analyze the lambda parameters as a whole at\n-                 *  a higher level.\n-                 *\/\n+                pn = qualident(false);\n+            }\n+            if (pn.hasTag(Tag.IDENT) && ((JCIdent)pn).name != names._this) {\n+                name = ((JCIdent)pn).name;\n+            } else if (lambdaParameter && type == null) {\n+                \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n+                type = pn;\n@@ -3657,0 +3674,14 @@\n+                reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n+            } else {\n+                if (allowThisIdent) {\n+                    if ((mods.flags & Flags.VARARGS) != 0) {\n+                        log.error(token.pos, Errors.VarargsAndReceiver);\n+                    }\n+                    if (token.kind == LBRACKET) {\n+                        log.error(token.pos, Errors.ArrayAndReceiver);\n+                    }\n+                    if (pn.hasTag(Tag.SELECT) && ((JCFieldAccess)pn).name != names._this) {\n+                        log.error(token.pos, Errors.WrongReceiver);\n+                    }\n+                }\n+                return toP(F.at(pos).ReceiverVarDef(mods, pn, type));\n@@ -3658,0 +3689,9 @@\n+        } else {\n+            \/** if it is a lambda parameter and the token kind is not an identifier,\n+             *  and there are no modifiers or annotations, then this means that the compiler\n+             *  supposed the lambda to be explicit but it can contain a mix of implicit,\n+             *  var or explicit parameters. So we assign the error name to the parameter name\n+             *  instead of issuing an error and analyze the lambda parameters as a whole at\n+             *  a higher level.\n+             *\/\n+            name = names.empty;\n@@ -3668,0 +3708,4 @@\n+        if ((mods.flags & Flags.UNNAMED) != 0 && Feature.UNNAMED_VARIABLES.allowedInSource(source)) {\n+            name = names.empty;\n+        }\n+\n@@ -3703,1 +3747,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false);\n@@ -4855,1 +4899,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, false, lambdaParameter, recordComponent);\n@@ -4860,1 +4904,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, false, true, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":125,"deletions":81,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -3117,0 +3117,3 @@\n+compiler.misc.feature.unnamed.variables=\\\n+    unnamed variables\n+\n@@ -3138,4 +3141,0 @@\n-compiler.err.underscore.as.identifier.in.lambda=\\\n-    ''_'' used as an identifier\\n\\\n-    (use of ''_'' as an identifier is forbidden for lambda parameters)\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+        ANYPATTERN,\n@@ -2262,0 +2263,28 @@\n+    public static class JCAnyPattern extends JCPattern\n+            implements AnyPatternTree {\n+\n+        protected JCAnyPattern() {\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitAnyPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.ANY_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitAnyPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return ANYPATTERN;\n+        }\n+    }\n+\n@@ -2367,0 +2396,1 @@\n+        public JCExpression syntheticGuard;\n@@ -3489,0 +3519,1 @@\n+        public void visitAnyPattern(JCAnyPattern that)       { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -495,0 +495,7 @@\n+    public JCTree visitAnyPattern(AnyPatternTree node, P p) {\n+        JCBindingPattern t = (JCBindingPattern) node;\n+        JCVariableDecl var = copy(t.var, p);\n+        return M.at(t.pos).BindingPattern(var);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1338,0 +1338,1 @@\n+            case ANYPATTERN -> ((JCAnyPattern) pat).type;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -486,0 +486,6 @@\n+    public JCAnyPattern AnyPattern() {\n+        JCAnyPattern tree = new JCAnyPattern();\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -325,0 +325,4 @@\n+    @Override\n+    public void visitAnyPattern(JCAnyPattern that) {\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -367,0 +367,4 @@\n+    public void visitAnyPattern(JCAnyPattern tree) {\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    public final Name underscore;\n@@ -257,0 +258,1 @@\n+        underscore = fromString(\"_\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile\/ref=TwrLintUnderscore.out --enable-preview -source ${jdk.version} -Xlint:try -XDrawDiagnostics TwrLintUnderscore.java\n+ *\/\n+class TwrLintUnderscore implements AutoCloseable {\n+    private static void test1() {\n+        try(TwrLintUnderscore _ = new TwrLintUnderscore()) {\n+            \/\/ _ cannot be referenced so no lint warning for an unused resource should be emitted\n+        }\n+    }\n+\n+    \/**\n+     * The AutoCloseable method of a resource.\n+     *\/\n+    @Override\n+    public void close () {\n+        return;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrLintUnderscore.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+- compiler.note.preview.filename: TwrLintUnderscore.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrLintUnderscore.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -24,1 +24,4 @@\n-\/\/ key: compiler.err.underscore.as.identifier.in.lambda\n+\/\/ key: compiler.misc.feature.unnamed.variables\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreInLambdaExpression.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-IdentifierTest.java:45:20: compiler.err.underscore.as.identifier\n+IdentifierTest.java:45:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.variables)\n@@ -6,1 +6,0 @@\n-IdentifierTest.java:51:15: compiler.err.underscore.as.identifier\n@@ -10,2 +9,0 @@\n-IdentifierTest.java:61:21: compiler.err.underscore.as.identifier\n-IdentifierTest.java:62:42: compiler.err.underscore.as.identifier\n@@ -16,1 +13,0 @@\n-IdentifierTest.java:77:22: compiler.err.underscore.as.identifier\n@@ -30,1 +26,0 @@\n-IdentifierTest.java:138:17: compiler.err.underscore.as.identifier\n@@ -34,1 +29,0 @@\n-IdentifierTest.java:143:13: compiler.err.underscore.as.identifier\n@@ -39,1 +33,0 @@\n-IdentifierTest.java:157:16: compiler.err.underscore.as.identifier\n@@ -45,1 +38,1 @@\n-44 errors\n+37 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest9.out","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -9,2 +9,1 @@\n-UnderscoreAsIdent.java:15:16: compiler.err.underscore.as.identifier\n-UnderscoreAsIdent.java:18:18: compiler.err.underscore.as.identifier\n+UnderscoreAsIdent.java:15:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.unnamed.variables)\n@@ -13,1 +12,0 @@\n-UnderscoreAsIdent.java:21:34: compiler.err.underscore.as.identifier\n@@ -18,1 +16,1 @@\n-17 errors\n+15 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent9.out","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -15,1 +15,0 @@\n-        if (p instanceof P(_));\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,11 +1,10 @@\n-DeconstructionPatternErrors.java:15:28: compiler.err.underscore.as.identifier\n-DeconstructionPatternErrors.java:15:29: compiler.err.expected: token.identifier\n-DeconstructionPatternErrors.java:43:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:45:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:47:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:47:43: compiler.err.not.stmt\n-DeconstructionPatternErrors.java:16:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n-DeconstructionPatternErrors.java:17:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n-DeconstructionPatternErrors.java:18:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-DeconstructionPatternErrors.java:19:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n-DeconstructionPatternErrors.java:20:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:42:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:44:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:46:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:46:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:15:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n+DeconstructionPatternErrors.java:16:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n+DeconstructionPatternErrors.java:17:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+DeconstructionPatternErrors.java:18:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n+DeconstructionPatternErrors.java:19:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:20:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n@@ -13,17 +12,16 @@\n-DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n-DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n-DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n-DeconstructionPatternErrors.java:25:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n-DeconstructionPatternErrors.java:25:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n-DeconstructionPatternErrors.java:26:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:27:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:28:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-DeconstructionPatternErrors.java:28:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n-DeconstructionPatternErrors.java:29:40: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n-DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:32:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:35:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-28 errors\n+DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n+DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n+DeconstructionPatternErrors.java:24:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n+DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n+DeconstructionPatternErrors.java:25:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:26:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:27:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+DeconstructionPatternErrors.java:27:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:28:40: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:29:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n+DeconstructionPatternErrors.java:29:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n+DeconstructionPatternErrors.java:30:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+DeconstructionPatternErrors.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n+DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n+26 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":26,"deletions":28,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+import java.util.Objects;\n+\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile --enable-preview -source ${jdk.version} Unnamed.java\n+ * @run main Unnamed\n+ *\/\n+public class Unnamed {\n+    public static void main(String[] args) throws Throwable {\n+        new Unnamed().run();\n+    }\n+\n+    public void run() {\n+        assertEquals(1, testMultiValuesTopLevel(new R1()));\n+        assertEquals(2, testMultiValuesTopLevel(new R3()));\n+        assertEquals(1, testMultiValuesTopLevel2(new R1()));\n+        assertEquals(2, testMultiValuesTopLevel2(new R2()));\n+        assertEquals(2, testMultiValuesTopLevel2(new R4()));\n+        assertEquals(1, testMultiValuesNested(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNested(new Box<>(new R2())));\n+        assertEquals(2, testMultiValuesNested(new Box<>(new R3())));\n+        assertEquals(3, testMultiValuesNested(new Box<>(new R4())));\n+        assertEquals(1, testMultiValuesNestedUnnamedVarAndPattern(new Box<>(new R1())));\n+        assertEquals(2, testMultiValuesNestedUnnamedVarAndPattern(new Box<>(new R4())));\n+        assertEquals(1, testMultiValuesNestedMix(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix(new Box2<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix2(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesNestedMix2(\"BOX\"));\n+        assertEquals(2, testMultiValuesNestedMix2(new Box2<>(new R1())));\n+        assertEquals(1, testMultiValuesStatementBlock(42));\n+        assertEquals(1, testMultiValuesStatementBlock(42.0f));\n+        assertEquals(2, testMultiValuesStatementBlock(\"BOX\"));\n+        assertEquals(1, testMultiValuesStatementBlock2(new Box<>(new R1())));\n+        assertEquals(1, testMultiValuesStatementBlock2(\"BOX\"));\n+        assertEquals(2, testMultiValuesStatementBlock2(new Box2<>(new R1())));\n+        assertEquals(2, testMultiValuesGuards(new R3(), 1));\n+        assertEquals(3, testMultiValuesGuards(new R4(), 42));\n+        assertEquals(3, testMultiValuesGuards(new R3(), 42));\n+        assertEquals(1, testMultiValuesNestedGuards(new Box(new R2()), 42));\n+        assertEquals(2, testMultiValuesNestedGuards(new Box(new R3()), 1));\n+    }\n+\n+    private void unnamedTest() {\n+        int _ = 0;\n+        int _ = 1;\n+        try (Lock _ = null) {\n+            try (Lock _ = null) {\n+            } catch (Exception _) {\n+                try {\n+                } catch (Exception _) {}\n+            }\n+        }\n+        String[] strs = null;\n+        for (var _ : strs) {\n+            for (var _ : strs) {\n+            }\n+        }\n+        TwoParams p1 = (_, _) -> {};\n+        TwoParams p2 = (var _, var _) -> {};\n+        R r = new R(null);\n+        if (r instanceof R _) {}\n+        if (r instanceof R(_)) {}\n+        for (int _ = 0, _ = 1; ;) {}\n+    }\n+\n+    int testMultiValuesTopLevel(Object o) {\n+        return switch (o) {\n+            case R1 _, R2 _ -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesTopLevel2(Base o) {\n+        return switch (o) {\n+            case R1 r -> 1;\n+            case R2 _, R3 _, R4 _ -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNested(Box<?> b) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _) -> 2;\n+            case Box(_)  -> 3;\n+        };\n+    }\n+\n+    int testMultiValuesNestedUnnamedVarAndPattern(Box<?> b) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _), Box(_) -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNestedMix(Object b) {\n+        return switch (b) {\n+            case Box(_), Box2(_) -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesNestedMix2(Object b) {\n+        return switch (b) {\n+            case Box(_), String _ -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    int testMultiValuesStatementBlock(Object o) {\n+        switch (o) {\n+            case Integer _:\n+            case Number _:\n+                return 1;\n+            default:\n+                return 2;\n+        }\n+    }\n+\n+    int testMultiValuesStatementBlock2(Object o) {\n+        switch (o) {\n+            case Box(_):\n+            case String _:\n+                return 1;\n+            default:\n+                return 2;\n+        }\n+    }\n+\n+    int testMultiValuesGuards(Base b, int x) {\n+        return switch (b) {\n+            case R1 r -> 1;\n+            case R2 _, R3 _, R4 _ when x == 1 -> 2;\n+            case R2 _, R3 _, R4 _ -> 3;\n+        };\n+    }\n+\n+    int testMultiValuesNestedGuards(Box<?> b, int x) {\n+        return switch (b) {\n+            case Box(R1 _), Box(R2 _) -> 1;\n+            case Box(R3 _), Box(_) when x == 1 -> 2;\n+            case Box(_) -> 3;\n+        };\n+    }\n+\n+    \/\/ JEP\n+    record Point(int x, int y) { }\n+    enum Color { RED, GREEN, BLUE }\n+    record ColoredPoint(Point p, Color c) { }\n+\n+    void jep(ColoredPoint r) {\n+        if (r instanceof ColoredPoint(Point(int x, int y), _)) { }\n+        if (r instanceof ColoredPoint(_, Color c)) { }\n+        if (r instanceof ColoredPoint(Point(int x, _), _)) { }\n+        if (r instanceof ColoredPoint(Point(int x, int _), Color _)) { }\n+        if (r instanceof ColoredPoint _) { }\n+    }\n+\n+    class Lock implements AutoCloseable {\n+        @Override\n+        public void close() {}\n+    }\n+    interface TwoParams {\n+        public void run(Object o1, Object o2);\n+    }\n+    record R(Object o) {}\n+\n+    sealed abstract class Base permits R1, R2, R3, R4 { }\n+    final  class R1  extends Base { }\n+    final  class R2  extends Base { }\n+    final  class R3  extends Base { }\n+    final  class R4  extends Base { }\n+    record Box<T extends Base>(T content) { }\n+    record Box2<T extends Base>(T content) { }\n+\n+    void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/Unnamed.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304246\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @enablePreview\n+ * @compile\/fail\/ref=UnnamedErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW UnnamedErrors.java\n+ *\/\n+public class UnnamedErrors {\n+    private int _; \/\/ error\n+    private int _, x;  \/\/ error\n+    private int x, _, y, _, z, _;  \/\/ error\n+    private int _ = 0, _ = 1; \/\/ error\n+    private int a = 0, _ = 1; \/\/ error\n+\n+    record R(int _) {} \/\/no record components\n+    UnnamedErrors(int _) {} \/\/no constructor parameters\n+    void test(int _) {} \/\/no method parameters\n+\n+    record RR(int x) {}\n+    void test2() {\n+        Object o = Integer.valueOf(42);\n+        if (o instanceof _) {} \/\/no top level\n+\n+        if (o instanceof _(int x)) {} \/\/no record pattern head\n+\n+        switch (o) {\n+            case _:\n+                System.out.println(\"no underscore top level\");\n+            default:\n+                System.out.println(\"\");\n+        }\n+\n+        switch (o) {\n+            case var _:\n+                System.out.println(\"no var _ top level\");\n+            default:\n+                System.out.println(\"\");\n+        }\n+    }\n+\n+    void dominance_error(Object o) {\n+        switch (o) {\n+            case Number _ ->\n+                    System.out.println(\"A Number\");\n+            case Integer _, String _ ->             \/\/ Error - dominated case pattern: `Integer _`\n+                    System.out.println(\"An Integer or a String\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+    }\n+\n+    void mixed_named_unnamed_error(Object o) {\n+        switch (o) {\n+            case Integer i, String _ ->\n+                    System.out.println(\"named\/unnamed\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+\n+        switch (o) {\n+            case Integer _, String s ->\n+                    System.out.println(\"unnamed\/named\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+\n+        switch (o) {\n+            case PairIS(_, _), String s ->\n+                    System.out.println(\"unnamed patterns\/named\");\n+            default ->\n+                    System.out.println(\"rest\");\n+        }\n+    }\n+\n+    private void test1() {\n+        try (Lock _ = null) {\n+        } catch (_) { }\n+    }\n+    class Lock implements AutoCloseable {\n+        @Override\n+        public void close() {}\n+    }\n+    record PairIS(int i, String s) {}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+UnnamedErrors.java:9:17: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:10:17: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:11:20: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:11:26: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:11:32: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:12:17: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:12:24: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:13:24: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:15:18: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:16:23: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:17:19: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:22:26: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:24:26: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:27:18: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:34:18: compiler.err.restricted.type.not.allowed.here: var\n+UnnamedErrors.java:34:22: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:77:18: compiler.err.underscore.as.identifier\n+UnnamedErrors.java:77:19: compiler.err.expected: token.identifier\n+UnnamedErrors.java:36:13: compiler.err.unconditional.pattern.and.default\n+UnnamedErrors.java:45:18: compiler.err.pattern.dominated\n+UnnamedErrors.java:54:29: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:61:29: compiler.err.flows.through.from.pattern\n+UnnamedErrors.java:68:32: compiler.err.flows.through.from.pattern\n+- compiler.note.preview.filename: UnnamedErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+23 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.out","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -38,2 +38,0 @@\n-import javax.lang.model.SourceVersion;\n-import static javax.lang.model.SourceVersion.*;\n@@ -41,4 +39,0 @@\n-import javax.lang.model.util.*;\n-import static javax.lang.model.util.ElementFilter.*;\n-import static javax.tools.Diagnostic.Kind.*;\n-import static javax.tools.StandardLocation.*;\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestNames.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344 8307007\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @enablePreview\n+ * @compile TestUnnamedVariableElement.java\n+ * @compile --enable-preview -source ${jdk.version} -processor TestUnnamedVariableElement -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import java.util.*;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+\n+public class TestUnnamedVariableElement extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Elements vacuousElements = new VacuousElements();\n+            expectFalse( () -> vacuousElements.isUnnamed(null));\n+            expectNpe( () -> elements.isUnnamed(null));\n+\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Trees trees) {\n+            super();\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            Element element = trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            if (!elements.isUnnamed(element)) {\n+                throw new RuntimeException(\"Expected empty name for simple name of an unnamed variable, but got: \" +\n+                        element.getSimpleName());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+\n+    private void expectNpe(java.util.function.BooleanSupplier bs) {\n+        try {\n+            bs.getAsBoolean();\n+            messager.printError(\"Did not get expected NPE\");\n+        } catch (NullPointerException npe) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private void expectFalse(java.util.function.BooleanSupplier bs) {\n+        try {\n+            boolean result = bs.getAsBoolean();\n+            if (result) {\n+                messager.printError(\"Unexpected true result\");\n+            }\n+        } catch (NullPointerException npe) {\n+            messager.printError(\"Unexpected NPE thrown\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344 8307007\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @compile TestUnnamedVariableElement8.java\n+ * @compile -source 8 -processor TestUnnamedVariableElement8 -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import java.util.Set;\n+\n+public class TestUnnamedVariableElement8 extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Trees trees) {\n+            super();\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            Element element = trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            if (!element.getSimpleName().toString().equals(\"_\")) {\n+                throw new RuntimeException(\"Expected _ for simple name of an unnamed variable, but got: \" +\n+                        element.getSimpleName());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement8.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -24,1 +24,5 @@\n-package p;\n+public class TestUnnamedVariableElementData {\n+\n+    private void test() {\n+        int _ = 0;\n+    }\n@@ -26,2 +30,0 @@\n-public class C extends p.q.Q implements I {\n-    public static String cString =  \"CClass\";\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElementData.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/p\/C.java","status":"copied"}]}