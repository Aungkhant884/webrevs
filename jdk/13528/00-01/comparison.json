{"files":[{"patch":"@@ -134,3 +134,4 @@\n-     * PackageElement#getSimpleName package} or unnamed {@linkplain\n-     * ModuleElement#getSimpleName module}, an {@linkplain\n-     * Name##empty_name empty name} is returned.\n+     * PackageElement#getSimpleName package}, an unnamed {@linkplain\n+     * ModuleElement#getSimpleName module} or an unnamed {@linkplain\n+     * VariableElement#getSimpleName module}, an {@linkplain Name##empty_name empty name}\n+     * is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+     *\n+     * <p>For variables, the name of each variable is returned or an empty name\n+     * if the variable is unnamed.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -710,0 +710,10 @@\n+    \/**\n+     * {@return {@code true} if the element has an empty name, {@code false} otherwise}\n+     *\n+     * @param element the element being examined\n+     * @since 21\n+     *\/\n+    default boolean hasEmptyName(Element element) {\n+        return element.getSimpleName().isEmpty();\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-     * Returns the name of the variable being declared.\n+     * Returns the name of the variable being declared or `_` if the variable\n+     * is unnamed.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/VariableTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-     * Currently available: Bit 48.\n+     * Flag that indicates that a local variable, a lambda parameter, or an unnamed pattern variable is unnamed.\n@@ -280,0 +280,1 @@\n+    public static final long UNNAMED = 1L<<48;\n@@ -520,0 +521,1 @@\n+        UNNAMED(Flags.UNNAMED),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,0 +438,4 @@\n+    public boolean isUnnamed() {\n+        return (flags_field & UNNAMED) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4177,1 +4177,1 @@\n-        if (v.name == names.underscore) {\n+        if (v.isUnnamed()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4589,1 +4589,1 @@\n-                bindings[0] = tree.var.name != names.underscore;\n+                bindings[0] = !tree.var.sym.isUnnamed();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2888,1 +2888,1 @@\n-                    if (unrefdResources.includes(resVar.sym) && resVar.name != names.underscore) {\n+                    if (unrefdResources.includes(resVar.sym) && !resVar.sym.isUnnamed()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,1 +294,7 @@\n-        VarSymbol v = new VarSymbol(0, tree.name, vartype, enclScope.owner);\n+        Name name;\n+        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && (tree.mods.flags & UNNAMED) != 0) {\n+            name = names.empty;\n+        } else {\n+            name = tree.name;\n+        }\n+        VarSymbol v = new VarSymbol(0, name , vartype, enclScope.owner);\n@@ -307,1 +313,1 @@\n-        if(Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source) || tree.name != names.underscore) {\n+        if(!(Feature.UNNAMED_VARIABLES.allowedInSource(source) && tree.sym.isUnnamed())) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-        if (bindingVar != null && bindingVar.name != names.underscore) {\n+        if (bindingVar != null && !bindingVar.isUnnamed()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import java.util.function.BiFunction;\n@@ -826,3 +825,2 @@\n-                int varPos = token.pos;\n-                Name name = identOrUnderscore();\n-                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n+                UnnamedDetails result = identOrFlagUnderscore(mods);\n+                JCVariableDecl var = toP(F.at(result.varPos()).VarDef(mods, result.name(), e, null));\n@@ -831,2 +829,2 @@\n-                    if (name == names.underscore) {\n-                        log.error(DiagnosticFlag.SYNTAX, varPos, Errors.UnderscoreAsIdentifier);\n+                    if (result.name() == names.underscore) {\n+                        log.error(DiagnosticFlag.SYNTAX, result.varPos(), Errors.UnderscoreAsIdentifier);\n@@ -841,0 +839,13 @@\n+    private UnnamedDetails identOrFlagUnderscore(JCModifiers mods) {\n+        int varPos = token.pos;\n+        Name name = identOrUnderscore();\n+        if (name == names.underscore) {\n+            mods.flags |= Flags.UNNAMED;\n+        }\n+        UnnamedDetails result = new UnnamedDetails(varPos, name);\n+        return result;\n+    }\n+\n+    private record UnnamedDetails(int varPos, Name name) {\n+    }\n+\n@@ -3510,1 +3521,2 @@\n-        return variableDeclaratorsRest(token.pos, mods, type, identOrUnderscore(), false, null, vdefs, localDecl);\n+        UnnamedDetails result = identOrFlagUnderscore(mods);\n+        return variableDeclaratorsRest(result.varPos(), mods, type, result.name(), false, null, vdefs, localDecl);\n@@ -3543,1 +3555,2 @@\n-        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true);\n+        UnnamedDetails result = identOrFlagUnderscore(mods);\n+        return variableDeclaratorRest(result.varPos(), mods, type, result.name(), reqInit, dc, localDecl, true);\n@@ -3654,0 +3667,1 @@\n+                mods.flags |= Flags.UNNAMED;\n@@ -3698,0 +3712,4 @@\n+        if ((mods.flags & Flags.UNNAMED) != 0 && Feature.UNNAMED_VARIABLES.allowedInSource(source)) {\n+            name = names.empty;\n+        }\n+\n@@ -3733,1 +3751,2 @@\n-            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false);\n+            UnnamedDetails result = identOrFlagUnderscore(mods);\n+            return variableDeclaratorRest(result.varPos(), mods, t, result.name(), true, null, true, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import javax.lang.model.SourceVersion;\n-import static javax.lang.model.SourceVersion.*;\n@@ -41,4 +39,0 @@\n-import javax.lang.model.util.*;\n-import static javax.lang.model.util.ElementFilter.*;\n-import static javax.tools.Diagnostic.Kind.*;\n-import static javax.tools.StandardLocation.*;\n@@ -93,1 +87,1 @@\n-                    stringName != stringName2)\n+                    stringName != stringName2 || eltUtils.hasEmptyName(stringMirror2))\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestNames.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @compile TestUnnamedVariableElement.java\n+ * @compile --enable-preview -source ${jdk.version} -processor TestUnnamedVariableElement -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import java.util.*;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+\n+public class TestUnnamedVariableElement extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Trees trees) {\n+            super();\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            Element element = trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            if (!elements.hasEmptyName(element)) {\n+                throw new RuntimeException(\"Expected empty name for simple name of an unnamed variable, but got: \" +\n+                        element.getSimpleName());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302344\n+ * @summary Compiler Implementation for Unnamed patterns and variables\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\n+ * @build   JavacTestingAbstractProcessor\n+ * @compile TestUnnamedVariableElement8.java\n+ * @compile -source 8 -processor TestUnnamedVariableElement8 -proc:only TestUnnamedVariableElementData.java\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import java.util.Set;\n+\n+public class TestUnnamedVariableElement8 extends JavacTestingAbstractProcessor implements AutoCloseable {\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            for(Element rootElement : roundEnv.getRootElements()) {\n+                TreePath treePath = trees.getPath(rootElement);\n+\n+                (new UnnamedVariableScanner(trees)).\n+                        scan(treePath.getCompilationUnit(), null);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void close() {}\n+\n+    class UnnamedVariableScanner extends TreePathScanner<Void, Void> {\n+        private Trees trees;\n+\n+        public UnnamedVariableScanner(Trees trees) {\n+            super();\n+            this.trees = trees;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void unused) {\n+            handleTreeAsLocalVar(getCurrentPath());\n+            return super.visitVariable(node, unused);\n+        }\n+\n+        private void handleTreeAsLocalVar(TreePath tp) {\n+            Element element = trees.getElement(tp);\n+\n+            System.out.println(\"Name: \" + element.getSimpleName() +\n+                    \"\\tKind: \" + element.getKind());\n+            if (element.getKind() != ElementKind.LOCAL_VARIABLE) {\n+                throw new RuntimeException(\"Expected a local variable, but got: \" +\n+                        element.getKind());\n+            }\n+            if (!element.getSimpleName().toString().equals(\"_\")) {\n+                throw new RuntimeException(\"Expected _ for simple name of an unnamed variable, but got: \" +\n+                        element.getSimpleName());\n+            }\n+            testUnnamedVariable(element);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a local variable modeled as an element behaves\n+     * as expected under 6 and latest specific visitors.\n+     *\/\n+    private static void testUnnamedVariable(Element element) {\n+        ElementKindVisitor visitorLatest =\n+                new ElementKindVisitor<Object, Void>() {\n+                    @Override\n+                    public Object visitVariableAsLocalVariable(VariableElement e,\n+                                                               Void p) {\n+                        return e;\n+                    }\n+                };\n+\n+        if (visitorLatest.visit(element) == null) {\n+            throw new RuntimeException(\"Null result of a resource variable visitation.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement8.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -24,1 +24,5 @@\n-package p;\n+public class TestUnnamedVariableElementData {\n+\n+    private void test() {\n+        int _ = 0;\n+    }\n@@ -26,2 +30,0 @@\n-public class C extends p.q.Q implements I {\n-    public static String cString =  \"CClass\";\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElementData.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/p\/C.java","status":"copied"}]}