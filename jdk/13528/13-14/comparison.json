{"files":[{"patch":"@@ -107,2 +107,2 @@\n-     * The default implementation of this method returns {@code\n-     * false}.\n+     * The default implementation of this method examines whether {@code\n+     * getSimpleName()} returns an empty name.\n@@ -114,1 +114,1 @@\n-    default boolean isUnnamed() { return false; }\n+    default boolean isUnnamed() { return getSimpleName().isEmpty(); }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -716,2 +716,2 @@\n-     * The default implementation of this method returns {@code\n-     * false}.\n+     * The default implementation of this method examines whether {@code\n+     * getSimpleName()} returns an empty name.\n@@ -723,2 +723,2 @@\n-    default boolean isUnnamed(Element element) {\n-        return false;\n+    default boolean isUnnamed(VariableElement element) {\n+        return element.getSimpleName().isEmpty();\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -28,0 +27,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -29,1 +30,10 @@\n- * A binding pattern tree\n+ * A tree node for a binding pattern that matches a pattern\n+ * with a variable of any name and a type of the match candidate;\n+ * an unnamed pattern.\n+ *\n+ * For example the use of underscore {@code _} below:\n+ * <pre>\n+ *   if (r instanceof R(_)) {}\n+ * <\/pre>\n+ *\n+ * @jls 14.30.1 Kinds of Patterns\n@@ -31,0 +41,1 @@\n+ * @since 21\n@@ -32,0 +43,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/AnyPatternTree.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -227,0 +229,1 @@\n+        @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -267,0 +269,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-     * Returns the name of the variable being declared or `_` if the variable\n-     * is unnamed.\n+     * Returns the name of the variable being declared or empty name if both the variable\n+     * is unnamed and the preview features are enabled (Unnamed Patterns and Variables).\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/VariableTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -641,0 +642,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -438,4 +438,0 @@\n-    public boolean isUnnamed() {\n-        return name.isEmpty();\n-    }\n-\n@@ -1648,0 +1644,1 @@\n+    @SuppressWarnings(\"preview\")\n@@ -1790,0 +1787,5 @@\n+\n+        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+        public boolean isUnnamed() {\n+            return name.isEmpty();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1691,1 +1691,1 @@\n-                boolean wasUnconditionalPattern = hasUnconditionalPattern;\n+                MatchBindings guardBindings = null;\n@@ -1764,1 +1764,1 @@\n-                        if (labels.tail.isEmpty() && guard != null) {\n+                        if (guardBindings == null && guard != null) {\n@@ -1772,1 +1772,3 @@\n-                            matchBindings = matchBindingsComputer.caseGuard(c, afterPattern, matchBindings);\n+\n+                            guardBindings = matchBindings;\n+                            matchBindings = afterPattern;\n@@ -1777,3 +1779,0 @@\n-                        } else if (guard != null) {\n-                            \/\/ if the label has multiple patterns and a guard (with binding from the switch environment)\n-                            attribExpr(guard, switchEnv, syms.booleanType);\n@@ -1802,0 +1801,4 @@\n+                if (guardBindings != null) {\n+                    currentBindings = matchBindingsComputer.caseGuard(c, currentBindings, guardBindings);\n+                }\n+\n@@ -4164,3 +4167,1 @@\n-        Name name = tree.var.name;\n-        if (name == names.underscore) name = names.empty;\n-        BindingSymbol v = new BindingSymbol(tree.var.mods.flags, name, type, env.info.scope.owner);\n+        BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, type, env.info.scope.owner);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -745,85 +745,0 @@\n-        sealed interface PatternDescription {\n-            public static PatternDescription from(Types types, Type selectorType, JCPattern pattern, Symtab syms) {\n-                if (pattern instanceof JCBindingPattern binding) {\n-                    Type type = types.isSubtype(selectorType, binding.type)\n-                            ? selectorType : binding.type;\n-                    return new BindingPattern(type);\n-                } else if (pattern instanceof JCRecordPattern record) {\n-                    Type[] componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                            .map(r -> types.memberType(record.type, r))\n-                            .toArray(s -> new Type[s]);\n-                    PatternDescription[] nestedDescriptions =\n-                            new PatternDescription[record.nested.size()];\n-                    int i = 0;\n-                    for (List<JCPattern> it = record.nested;\n-                         it.nonEmpty();\n-                         it = it.tail, i++) {\n-                        nestedDescriptions[i] = PatternDescription.from(types, types.erasure(componentTypes[i]), it.head, syms);\n-                    }\n-                    return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-                } else if (pattern instanceof JCAnyPattern) {\n-                    Type type = types.isSubtype(selectorType, syms.objectType)\n-                            ? selectorType : syms.objectType;\n-                    return new BindingPattern(type);\n-                } else {\n-                    throw Assert.error();\n-                }\n-            }\n-        }\n-\n-        record BindingPattern(Type type) implements PatternDescription {\n-            @Override\n-            public int hashCode() {\n-                return type.tsym.hashCode();\n-            }\n-            @Override\n-            public boolean equals(Object o) {\n-                return o instanceof BindingPattern other &&\n-                       type.tsym == other.type.tsym;\n-            }\n-            @Override\n-            public String toString() {\n-                return type.tsym + \" _\";\n-            }\n-        }\n-\n-        record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-            public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-                this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-            }\n-\n-            @Override\n-            public int hashCode() {\n-                return _hashCode;\n-            }\n-\n-            @Override\n-            public boolean equals(Object o) {\n-                return o instanceof RecordPattern other &&\n-                       recordType.tsym == other.recordType.tsym &&\n-                       Arrays.equals(nested, other.nested);\n-            }\n-\n-            public int hashCode(int excludeComponent) {\n-                return hashCode(excludeComponent, recordType, nested);\n-            }\n-\n-            public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-                int hash = 5;\n-                hash =  41 * hash + recordType.tsym.hashCode();\n-                for (int  i = 0; i < nested.length; i++) {\n-                    if (i != excludeComponent) {\n-                        hash = 41 * hash + nested[i].hashCode();\n-                    }\n-                }\n-                return hash;\n-            }\n-            @Override\n-            public String toString() {\n-                return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                                                     .map(pd -> pd.toString())\n-                                                     .collect(Collectors.joining(\", \")) + \")\";\n-            }\n-        }\n-\n@@ -840,1 +755,1 @@\n-                            patternSet.add(PatternDescription.from(types, component, patternLabel.pat, syms));\n+                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n@@ -3535,0 +3450,81 @@\n+    sealed interface PatternDescription { }\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                    .map(r -> types.memberType(record.type, r))\n+                    .toArray(s -> new Type[s]);\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentTypes[i]), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            Type type = types.isSubtype(selectorType, syms.objectType)\n+                    ? selectorType : syms.objectType;\n+            return new BindingPattern(type);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type) implements PatternDescription {\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":82,"deletions":86,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n-        if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) name = names.empty;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-import java.util.*;\n+import java.util.Collections;\n+import java.util.Map;\n@@ -71,0 +72,4 @@\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n@@ -329,1 +334,1 @@\n-            } else if (nestedPattern instanceof JCAnyPattern nestedRecordPattern) {\n+            } else if (nestedPattern instanceof JCAnyPattern nestedAnyPattern) {\n@@ -331,1 +336,1 @@\n-                nestedBinding = nestedRecordPattern;\n+                nestedBinding = nestedAnyPattern;\n@@ -535,1 +540,3 @@\n-                } else validCaseLabelList = clearedPatterns.size() == 1 && clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL);\n+                } else {\n+                    validCaseLabelList = clearedPatterns.head.hasTag(Tag.PATTERNCASELABEL);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -724,2 +724,2 @@\n-    public boolean isUnnamed(Element element) {\n-        Symbol sym = (Symbol) element;\n+    public boolean isUnnamed(VariableElement element) {\n+        VarSymbol sym = (VarSymbol) element;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3559,0 +3559,1 @@\n+            name = names.empty;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-                writer.print(e.asType().toString() + \" \" + e.getSimpleName() );\n+                writer.print(e.asType().toString() + \" \" + (e.getSimpleName().isEmpty() ? \"_\" : e.getSimpleName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -717,1 +717,5 @@\n-                    print(tree.name);\n+                    if (tree.name.isEmpty()) {\n+                        print('_');\n+                    } else {\n+                        print(tree.name);\n+                    }\n@@ -943,0 +947,8 @@\n+    public void visitAnyPattern(JCAnyPattern patt) {\n+        try {\n+            print('_');\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -496,3 +496,2 @@\n-        JCBindingPattern t = (JCBindingPattern) node;\n-        JCVariableDecl var = copy(t.var, p);\n-        return M.at(t.pos).BindingPattern(var);\n+        JCAnyPattern t = (JCAnyPattern) node;\n+        return M.at(t.pos).AnyPattern();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -326,0 +327,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -51,0 +52,1 @@\n+                      \"         boolean _ = true;\\n\" +\n@@ -56,0 +58,3 @@\n+                      \"         b = o instanceof R(String _);\\n\" +\n+                      \"         b = o instanceof R2(R(var _), var _);\\n\" +\n+                      \"         b = o instanceof R2(R(_), var t);\\n\" +\n@@ -62,21 +67,25 @@\n-                          \\n\\\n-                          class Test {\n-                              \\n\\\n-                              boolean t(Object o) {\n-                                  boolean b;\n-                                  b = o instanceof String s;\n-                                  b = o instanceof R(String s);\n-                                  b = o instanceof R(\/*missing*\/ s);\n-                                  b = o instanceof R2(R(\/*missing*\/ s), String t);\n-                                  b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n-                              }\n-                              \\n\\\n-                              class R {\n-                                  private final String s;\n-                              }\n-                              \\n\\\n-                              class R2 {\n-                                  private final R r;\n-                                  private final String s;\n-                              }\n-                          }\"\"\";\n+                \\n\\\n+                class Test {\n+                    \\n\\\n+                    boolean t(Object o) {\n+                        boolean b;\n+                        boolean _ = true;\n+                        b = o instanceof String s;\n+                        b = o instanceof R(String s);\n+                        b = o instanceof R(\/*missing*\/ s);\n+                        b = o instanceof R2(R(\/*missing*\/ s), String t);\n+                        b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                        b = o instanceof R(String _);\n+                        b = o instanceof R2(R(\/*missing*\/ _), \/*missing*\/ _);\n+                        b = o instanceof R2(R(_), \/*missing*\/ t);\n+                    }\n+                    \\n\\\n+                    class R {\n+                        private final String s;\n+                    }\n+                    \\n\\\n+                    class R2 {\n+                        private final R r;\n+                        private final String s;\n+                    }\n+                }\"\"\";\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,1 +1,22 @@\n-import java.util.Objects;\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n@@ -4,1 +25,1 @@\n- * @test \/nodynamiccopyright\/\n+ * @test\n@@ -8,1 +29,1 @@\n- * @compile --enable-preview -source ${jdk.version} Unnamed.java\n+ * @compile Unnamed.java\n@@ -11,0 +32,3 @@\n+\n+import java.util.Objects;\n+\n@@ -52,0 +76,2 @@\n+        assertEquals(\"binding\", unnamedGuardAddsBindings(\"match1\", \"binding\"));\n+        assertEquals(\"any\", unnamedGuardAddsBindings(42, 42));\n@@ -221,0 +247,7 @@\n+    String unnamedGuardAddsBindings(Object o1, Object o2) {\n+        return switch (o1) {\n+            case String _, Object _ when o2 instanceof String s: yield s;\n+            case Object _: yield \"any\";\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Unnamed.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -16,1 +16,0 @@\n-UnnamedErrors.java:34:22: compiler.err.underscore.as.identifier\n@@ -34,1 +33,1 @@\n-31 errors\n\\ No newline at end of file\n+30 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.StringWriter;\n@@ -49,1 +50,1 @@\n-            expectFalse( () -> vacuousElements.isUnnamed(null));\n+            expectNpe( () -> vacuousElements.isUnnamed(null));\n@@ -57,1 +58,1 @@\n-                (new UnnamedVariableScanner(trees)).\n+                (new UnnamedVariableScanner(processingEnv.getElementUtils(), trees)).\n@@ -68,0 +69,2 @@\n+\n+        private final Elements elements;\n@@ -70,1 +73,1 @@\n-        public UnnamedVariableScanner(Trees trees) {\n+        public UnnamedVariableScanner(Elements elements, Trees trees) {\n@@ -72,0 +75,1 @@\n+            this.elements = elements;\n@@ -79,2 +83,2 @@\n-            if(!node.getName().toString().equals(\"_\")) {\n-                throw new RuntimeException(\"Expected the underscore as the name of the Tree API but got: \" + node.getName());\n+            if(!node.getName().isEmpty()) {\n+                throw new RuntimeException(\"Expected empty name as the name of the Tree API but got: \" + node.getName());\n@@ -87,1 +91,1 @@\n-            Element element = trees.getElement(tp);\n+            VariableElement element = (VariableElement) trees.getElement(tp);\n@@ -95,1 +99,1 @@\n-            if (!elements.isUnnamed(element) || !element.getSimpleName().isEmpty()) {\n+            if (!elements.isUnnamed(element)) {\n@@ -99,0 +103,6 @@\n+            StringWriter out = new StringWriter();\n+            String expected = \"int _;\";\n+            elements.printElements(out, element);\n+            if (!expected.equals(out.toString().trim())) {\n+                throw new RuntimeException(\"Expected: \" + expected + \", but got: \" + out.toString());\n+            }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElement.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -29,1 +28,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElementData.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-        test.run(\"java.util.function.IntBinaryOperator c = (var x, |testType|) -> 1;\",\n-                 \"testType \");\n","filename":"test\/langtools\/tools\/javac\/tree\/VarTree.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}