{"files":[{"patch":"@@ -575,3 +575,1 @@\n-instruct reduce_add8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+instruct reduce_addID(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp) %{\n@@ -579,7 +577,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction8B\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction integral (64 bits)\" %}\n@@ -587,4 +581,3 @@\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 8, as_FloatRegister($vtmp$$reg));\n@@ -595,3 +588,1 @@\n-instruct reduce_add16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+instruct reduce_addIX(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp) %{\n@@ -599,47 +590,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction8S\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction integral (128 bits)\" %}\n@@ -647,4 +594,3 @@\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n@@ -655,2 +601,1 @@\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n+instruct reduce_addL_neon(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX vtmp) %{\n@@ -658,6 +603,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction2L\" %}\n@@ -665,3 +607,3 @@\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n@@ -672,2 +614,2 @@\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n+\n+instruct reduce_mul_neon_8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2) %{\n@@ -676,13 +618,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8B\" %}\n@@ -690,14 +622,3 @@\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -708,2 +629,1 @@\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2) %{\n@@ -712,34 +632,7 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction16B\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -750,2 +643,1 @@\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp) %{\n@@ -754,11 +646,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n+  ins_cost(8 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4S\" %}\n@@ -766,10 +650,3 @@\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n@@ -780,2 +657,1 @@\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2) %{\n@@ -784,42 +660,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8S\" %}\n@@ -827,4 +664,3 @@\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -835,31 +671,6 @@\n-instruct reduce_max8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction16B\"\n-  %}\n+instruct reduce_mul_neon_2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2I\" %}\n@@ -867,4 +678,3 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   fnoreg, fnoreg);\n@@ -875,11 +685,6 @@\n-instruct reduce_max4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4S\"\n-  %}\n+instruct reduce_mul_neon_4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4I\" %}\n@@ -887,4 +692,3 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n@@ -895,11 +699,6 @@\n-instruct reduce_max8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8S\"\n-  %}\n+instruct reduce_mul_neon_2L(iRegLNoSp dst, iRegL isrc, vecX vsrc) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2L\" %}\n@@ -907,4 +706,3 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   fnoreg, fnoreg);\n@@ -915,11 +713,5 @@\n-instruct reduce_max4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4I\"\n-  %}\n+instruct reduce_mul_neon_2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\" %}\n@@ -927,4 +719,4 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -932,1 +724,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -935,11 +727,5 @@\n-instruct reduce_min8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8B\"\n-  %}\n+instruct reduce_mul_neon_4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction4F\" %}\n@@ -947,4 +733,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -952,1 +738,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -955,11 +741,5 @@\n-instruct reduce_min16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction16B\"\n-  %}\n+instruct reduce_mul_neon_2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D\" %}\n@@ -967,4 +747,3 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n@@ -972,1 +751,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -975,3 +754,4 @@\n-instruct reduce_min4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+instruct reduce_minID(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -979,7 +759,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4S\"\n-  %}\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_min_reduction_integral $dst, $isrc, $vsrc\\t# min reduction (D)\" %}\n@@ -987,4 +763,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 8, \/* is_min *\/ true,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -995,3 +771,4 @@\n-instruct reduce_min8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+instruct reduce_minIX(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -999,7 +776,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8S\"\n-  %}\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_min_reduction_integral $dst, $isrc, $vsrc\\t# min reduction (X)\" %}\n@@ -1007,4 +780,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 16, \/* is_min *\/ true,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -1015,11 +788,8 @@\n-instruct reduce_min4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4I\"\n-  %}\n+instruct reduce_maxID(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_max_reduction_integral $dst, $isrc, $vsrc\\t# max reduction (D)\" %}\n@@ -1027,4 +797,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 8, \/* is_min *\/ false,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -1035,3 +805,4 @@\n-instruct reduce_max2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+instruct reduce_maxIX(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -1039,7 +810,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction2I\"\n-  %}\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_max_reduction_integral $dst, $isrc, $vsrc\\t# max reduction (X)\" %}\n@@ -1047,4 +814,4 @@\n-    __ smaxp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 16, \/* is_min *\/ false,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -1055,3 +822,2 @@\n-instruct reduce_min2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+instruct reduce_min2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n@@ -1059,6 +825,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction2I\"\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"neon_minmax_reduction_integral $dst, $isrc, $vsrc\\t# min reduction (2L)\"\n@@ -1067,4 +830,3 @@\n-    __ sminp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                      as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                      \/* is_min *\/ true, fnoreg);\n@@ -1075,2 +837,1 @@\n-instruct reduce_max2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n+instruct reduce_max2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, rFlagsReg cr) %{\n@@ -1079,32 +840,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp GT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp GT\\t# max reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::GT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp LT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp LT\\t# min reduction2L\"\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"neon_minmax_reduction_integral $dst, $isrc, $vsrc\\t# max reduction (2L)\"\n@@ -1113,6 +845,3 @@\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::LT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                      as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                      \/* is_min *\/ false, fnoreg);\n@@ -3315,84 +3044,0 @@\n-instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addv  $vtmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp, TEMP dst);\n-  format %{ \"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -3451,52 +3096,0 @@\n-instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction2F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction4F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -3523,20 +3116,0 @@\n-instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVD dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuld $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"fmuld $dst, $dst, $tmp\\t# mul reduction2D\"\n-  %}\n-  ins_encode %{\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":167,"deletions":594,"binary":false,"changes":761,"status":"modified"},{"patch":"@@ -354,4 +354,2 @@\n-define(`REDUCE_ADD_BORS', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+define(`REDUCE_ADD', `\n+instruct reduce_addI$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$2 vsrc, vec$2 vtmp) %{\n@@ -359,7 +357,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T$1`'iTYPE2SIMD($2), $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, iTYPE2SIMD($2), 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxt$4  $dst, $dst\\t# add reduction$1$2\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction integral ($1 bits)\" %}\n@@ -367,4 +361,3 @@\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1`'iTYPE2SIMD($2), as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($2), 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxt$4($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ ifelse($1, 64, 8, 16), as_FloatRegister($vtmp$$reg));\n@@ -374,6 +367,2 @@\n-dnl             $1  $2 $3 $4\n-REDUCE_ADD_BORS(8,  B, D, b)\n-REDUCE_ADD_BORS(16, B, X, b)\n-REDUCE_ADD_BORS(4,  S, D, h)\n-REDUCE_ADD_BORS(8,  S, X, h)\n-dnl\n+REDUCE_ADD(64, D)\n+REDUCE_ADD(128, X)\n@@ -381,2 +370,1 @@\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n+instruct reduce_addL_neon(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX vtmp) %{\n@@ -384,31 +372,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction2L\" %}\n@@ -416,14 +376,3 @@\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n@@ -434,38 +383,26 @@\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+dnl REDUCE_MUL_NEON($1,       $2,           $3,                     $4)\n+dnl REDUCE_MUL_NEON(lane_cnt, element_type, vector_length_in_bytes, cost)\n+define(`REDUCE_MUL_NEON', `\n+instruct reduce_mul_neon_$1$2(ifelse($2, L, iRegLNoSp, iRegINoSp) dst,dnl\n+ ifelse($2, L, iRegL, iRegIorL2I) isrc, ifelse($3, 8, vecD, vecX) vsrc`'ifelse($1$2, 8B, `, vecD vtmp1, vecD vtmp2',\n+                                                          $1$2, 16B,`, vecX vtmp1, vecX vtmp2',\n+                                                          $1$2, 4S, `, vecD vtmp',\n+                                                          $1$2, 8S, `, vecX vtmp1, vecX vtmp2',\n+                                                          $1$2, 4I, `, vecX vtmp')) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (MulReductionV`'ifelse($2, L, L, I) isrc vsrc));\n+  ins_cost($4 * INSN_COST);\n+  effect(ifelse($2, B, `TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2',\n+                $1$2, 4S, `TEMP_DEF dst, TEMP vtmp',\n+                $1$2, 8S, `TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2',\n+                $1, 2, `TEMP_DEF dst',\n+                $1$2, 4I, `TEMP_DEF dst, TEMP vtmp'));\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction$1$2\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_`'TYPE2DATATYPE($2), as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ $3,\n+                                   ifelse($2, B, `as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg)',\n+                                          $1$2, 4S, `as_FloatRegister($vtmp$$reg), fnoreg',\n+                                          $1$2, 8S, `as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg)',\n+                                          $1,   2,  `fnoreg, fnoreg',\n+                                          $1$2, 4I, `as_FloatRegister($vtmp$$reg), fnoreg'));\n@@ -474,1 +411,8 @@\n-%}\n+%}')dnl\n+REDUCE_MUL_NEON(8,  B, 8,   10)\n+REDUCE_MUL_NEON(16, B, 16,  12)\n+REDUCE_MUL_NEON(4,  S, 8,   8)\n+REDUCE_MUL_NEON(8,  S, 16,  10)\n+REDUCE_MUL_NEON(2,  I, 8,   4)\n+REDUCE_MUL_NEON(4,  I, 16,  6)\n+REDUCE_MUL_NEON(2,  L, 16,  4)\n@@ -476,15 +420,5 @@\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n+instruct reduce_mul_neon_2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\" %}\n@@ -492,10 +426,4 @@\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -503,1 +431,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -506,17 +434,5 @@\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n+instruct reduce_mul_neon_4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction4F\" %}\n@@ -524,14 +440,4 @@\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -539,1 +445,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -542,10 +448,5 @@\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n+instruct reduce_mul_neon_2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D\" %}\n@@ -553,4 +454,3 @@\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n@@ -558,1 +458,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -561,44 +461,9 @@\n-define(`REDUCE_MAX_MIN_INT', `\n-instruct reduce_$1$2$3`'(iRegINoSp dst, iRegIorL2I isrc, vec$4 vsrc, vec$4 tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst ($5ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1v $tmp, T$2`'iTYPE2SIMD($3), $vsrc\\n\\t\"\n-            \"$6mov  $dst, $tmp, iTYPE2SIMD($3), 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $7\\t# $1 reduction$2$3\"\n-  %}\n-  ins_encode %{\n-    __ s$1v(as_FloatRegister($tmp$$reg), __ T$2`'iTYPE2SIMD($3), as_FloatRegister($vsrc$$reg));\n-    __ $6mov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($3), 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$7);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2  $3 $4 $5   $6 $7\n-REDUCE_MAX_MIN_INT(max, 8,  B, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 16, B, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  S, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 8,  S, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  I, X, Max, u, GT)\n-REDUCE_MAX_MIN_INT(min, 8,  B, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 16, B, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  S, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 8,  S, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  I, X, Min, u, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2I', `\n-instruct reduce_$1`'2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1p $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $3\\t# $1 reduction2I\"\n-  %}\n+define(`REDUCE_MAX_MIN_I', `\n+instruct reduce_$2I$1(iRegINoSp dst, iRegIorL2I isrc, vec$1 vsrc, vec$1 vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (ifelse($2, min, MinReductionV, MaxReductionV) isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_$2_reduction_integral $dst, $isrc, $vsrc\\t# $2 reduction ($1)\" %}\n@@ -606,4 +471,4 @@\n-    __ s$1p(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$3);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ ifelse($1, D, 8, 16), \/* is_min *\/ ifelse($2, min, true, false),\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -613,7 +478,8 @@\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2I(max, Max, GT)\n-REDUCE_MAX_MIN_2I(min, Min, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2L', `\n-instruct reduce_$1`'2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n+dnl              $1  $2\n+REDUCE_MAX_MIN_I(D,  min)\n+REDUCE_MAX_MIN_I(X,  min)\n+REDUCE_MAX_MIN_I(D,  max)\n+REDUCE_MAX_MIN_I(X,  max)\n+dnl\n+define(`REDUCE_MAX_MIN_L', `\n+instruct reduce_$1`2L'(iRegLNoSp dst, iRegL isrc, vecX vsrc, rFlagsReg cr) %{\n@@ -621,9 +487,4 @@\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp $3\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp $3\\t# $1 reduction2L\"\n+  match(Set dst (ifelse($1, min, MinReductionV, MaxReductionV) isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"neon_minmax_reduction_integral $dst, $isrc, $vsrc\\t# $1 reduction (2L)\"\n@@ -632,6 +493,3 @@\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::$3);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::$3);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                      as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                      \/* is_min *\/ ifelse($1, min, true, false), fnoreg);\n@@ -641,3 +499,3 @@\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2L(max, Max, GT)\n-REDUCE_MAX_MIN_2L(min, Min, LT)\n+dnl\n+REDUCE_MAX_MIN_L(min)\n+REDUCE_MAX_MIN_L(max)\n@@ -1622,62 +1480,2 @@\n-define(`REDUCE_ADD_INT', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ ifelse($1, 2, `\"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"',`\"addv  $vtmp, T4S, $vsrc\\n\\t\"')\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction$1I\"\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));', `__ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));')\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_ADD_INT(2, I, D)\n-REDUCE_ADD_INT(4, I, X)\n-dnl\n-define(`REDUCE_MUL_INT', `\n-instruct reduce_mul$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, ifelse($1, 2, iRegINoSp tmp`)', vecX vtmp`,' iRegINoSp itmp`)')\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP ifelse($1, 2, tmp, vtmp), TEMP ifelse($1, 2, dst, itmp`,' TEMP dst));\n-  format %{ ifelse($1, 2, `\"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"',`\"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"')\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);', `__ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_MUL_INT(2, I, D)\n-REDUCE_MUL_INT(4, I, X)\n-dnl\n-define(`REDUCE_MULORADD_FORD', `\n-instruct reduce_$6$2$3`'(vReg$3 dst, vReg$3 $4src, vec$5 vsrc, vec$5 tmp)\n+define(`REDUCE_ADD_FORD', `\n+instruct reduce_add$2$3`'(vReg$3 dst, vReg$3 $4src, vec$5 vsrc, vec$5 tmp)\n@@ -1685,1 +1483,1 @@\n-  match(Set dst (ifelse($6, add, Add, Mul)ReductionV$3 $4src vsrc));\n+  match(Set dst (AddReductionV$3 $4src vsrc));\n@@ -1690,1 +1488,1 @@\n-            ifelse($2, 2, `\"$1 $dst, $dst, $tmp\\t# $6 reduction$2$3\"',\n+            ifelse($2, 2, `\"$1 $dst, $dst, $tmp\\t# add reduction$2$3\"',\n@@ -1695,1 +1493,1 @@\n-            \"$1 $dst, $dst, $tmp\\t# $6 reduction4F\"')\n+            \"$1 $dst, $dst, $tmp\\t# add reduction4F\"')\n@@ -1715,7 +1513,4 @@\n-dnl                  $1     $2 $3 $4 $5 $6\n-REDUCE_MULORADD_FORD(fadds, 2, F, f, D, add)\n-REDUCE_MULORADD_FORD(fadds, 4, F, f, X, add)\n-REDUCE_MULORADD_FORD(fmuls, 2, F, f, D, mul)\n-REDUCE_MULORADD_FORD(fmuls, 4, F, f, X, mul)\n-REDUCE_MULORADD_FORD(faddd, 2, D, d, X, add)\n-REDUCE_MULORADD_FORD(fmuld, 2, D, d, X, mul)\n+dnl             $1     $2 $3 $4 $5\n+REDUCE_ADD_FORD(fadds, 2, F, f, D)\n+REDUCE_ADD_FORD(fadds, 4, F, f, X)\n+REDUCE_ADD_FORD(faddd, 2, D, d, X)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":120,"deletions":325,"binary":false,"changes":445,"status":"modified"},{"patch":"@@ -136,5 +136,0 @@\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n@@ -145,0 +140,5 @@\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return vlen >= 2 && length_in_bytes <= 16;\n@@ -159,0 +159,2 @@\n+  \/\/ If an opcode does not support mask, unpredicated node with VectorBlend node\n+  \/\/ will be used instead.\n@@ -160,1 +162,6 @@\n-    if (opcode == Op_VectorRearrange) {\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (opcode == Op_VectorRearrange ||\n+        opcode == Op_MulReductionVD ||\n+        opcode == Op_MulReductionVF ||\n+        opcode == Op_MulReductionVI ||\n+        opcode == Op_MulReductionVL) {\n@@ -163,0 +170,1 @@\n+\n@@ -2352,1 +2360,17 @@\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16);\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst,  $isrc,  $vsrc\\t# add reduction <128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                   as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg vtmp, pRegGov ptmp) %{\n@@ -2354,0 +2378,20 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -2357,1 +2401,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2368,1 +2412,17 @@\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addL_sve_128bits(iRegLNoSp dst, iRegL isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst, $isrc, $vsrc\\t# addL reduction 128 bits (sve)\"\n+  %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp, pRegGov ptmp) %{\n@@ -2370,0 +2430,18 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D,\n+                         Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -2409,36 +2487,0 @@\n-instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                             pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant, Matcher::vector_length(this, $src2));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                             pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AddReductionVL src1 src2));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D, Matcher::vector_length(this, $src2));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2538,1 +2580,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2644,1 +2686,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2750,1 +2792,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2848,0 +2890,1 @@\n+\n@@ -2851,1 +2894,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -2888,0 +2931,1 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n@@ -2923,0 +2967,21 @@\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_maxI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"neon_max_reduce_integral $dst, $isrc, $vsrc\\t# maxI reduction LE 128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                      \/* is_min *\/ false,\n+                                      as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3054,1 +3119,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -3091,0 +3156,1 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n@@ -3126,0 +3192,21 @@\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_minI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"neon_min_reduce_integral $dst, $isrc, $vsrc\\t# minI reduction LE 128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                      \/* is_min *\/ true,\n+                                      as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3254,0 +3341,148 @@\n+\/\/ vector mul reduction\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+\n+instruct reduce_mul_sve_8B(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8B (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_16B(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction16B (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_4S(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(8 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4S (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_8S(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8S (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_2I(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2I (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_4I(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4I (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_2L(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2L (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+instruct reduce_mul_sve_2F4F(vRegF dst, vRegF fsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            (n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 ||\n+             n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16));\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\/4F (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_2D(vRegD dst, vRegD dsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":285,"deletions":50,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -131,5 +131,0 @@\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n@@ -140,0 +135,5 @@\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return vlen >= 2 && length_in_bytes <= 16;\n@@ -154,0 +154,2 @@\n+  \/\/ If an opcode does not support mask, unpredicated node with VectorBlend node\n+  \/\/ will be used instead.\n@@ -155,1 +157,6 @@\n-    if (opcode == Op_VectorRearrange) {\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (opcode == Op_VectorRearrange ||\n+        opcode == Op_MulReductionVD ||\n+        opcode == Op_MulReductionVF ||\n+        opcode == Op_MulReductionVI ||\n+        opcode == Op_MulReductionVL) {\n@@ -158,0 +165,1 @@\n+\n@@ -1328,1 +1336,1 @@\n-       `predicate(UseSVE > 0 &&\n+       `predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -1335,1 +1343,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -1352,1 +1360,1 @@\n-       `predicate(UseSVE > 0 &&\n+       `predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -1513,0 +1521,37 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16);\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst,  $isrc,  $vsrc\\t# add reduction <128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                   as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg vtmp, pRegGov ptmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n@@ -1514,0 +1559,34 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addL_sve_128bits(iRegLNoSp dst, iRegL isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst, $isrc, $vsrc\\t# addL reduction 128 bits (sve)\"\n+  %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp, pRegGov ptmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D,\n+                         Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -1517,2 +1596,0 @@\n-REDUCE_I_PARTIAL(add, AddReductionVI)\n-REDUCE_L_PARTIAL(add, AddReductionVL)\n@@ -1563,1 +1640,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -1606,0 +1683,1 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n@@ -1739,0 +1817,21 @@\n+define(`REDUCE_MAXMIN_I_128BIT', `\n+instruct reduce_$1I_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (ifelse($1, min, MinReductionV, MaxReductionV) isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"neon_$1_reduce_integral $dst, $isrc, $vsrc\\t# $1I reduction LE 128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                      \/* is_min *\/ ifelse($1, min, true, false),\n+                                      as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n@@ -1744,0 +1843,3 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.dnl\n+REDUCE_MAXMIN_I_128BIT(max)\n@@ -1760,0 +1862,3 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.dnl\n+REDUCE_MAXMIN_I_128BIT(min)\n@@ -1771,0 +1876,74 @@\n+\/\/ vector mul reduction\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+dnl REDUCE_MUL_SVE_128BIT($1,       $2,           $3,                     $4)\n+dnl REDUCE_MUL_SVE_128BIT(lane_cnt, element_type, vector_length_in_bytes, cost)\n+define(`REDUCE_MUL_SVE_128BIT', `\n+instruct reduce_mul_sve_$1$2(ifelse($2, L, iRegLNoSp, iRegINoSp) dst,dnl\n+ ifelse($2, L, iRegL, iRegIorL2I) isrc, vReg vsrc`'ifelse($2, B, `, vReg vtmp1, vReg vtmp2',\n+                                                          $1$2, 4S, `, vReg vtmp',\n+                                                          $1$2, 8S, `, vReg vtmp1, vReg vtmp2',\n+                                                          $1$2, 4I, `, vReg vtmp')) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == $3 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  match(Set dst (MulReductionV`'ifelse($2, L, L, I) isrc vsrc));\n+  ins_cost($4 * INSN_COST);\n+  effect(ifelse($2, B, `TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2',\n+                $1$2, 4S, `TEMP_DEF dst, TEMP vtmp',\n+                $1$2, 8S, `TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2',\n+                $1, 2, `TEMP_DEF dst',\n+                $1$2, 4I, `TEMP_DEF dst, TEMP vtmp'));\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction$1$2 (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_`'TYPE2DATATYPE($2), as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ $3,\n+                                   ifelse($2, B, `as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg)',\n+                                          $1$2, 4S, `as_FloatRegister($vtmp$$reg), fnoreg',\n+                                          $1$2, 8S, `as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg)',\n+                                          $1,   2,  `fnoreg, fnoreg',\n+                                          $1$2, 4I, `as_FloatRegister($vtmp$$reg), fnoreg'));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+REDUCE_MUL_SVE_128BIT(8,  B, 8,   12)\n+REDUCE_MUL_SVE_128BIT(16, B, 16,  12)\n+REDUCE_MUL_SVE_128BIT(4,  S, 8,   8)\n+REDUCE_MUL_SVE_128BIT(8,  S, 16,  10)\n+REDUCE_MUL_SVE_128BIT(2,  I, 8,   4)\n+REDUCE_MUL_SVE_128BIT(4,  I, 16,  6)\n+REDUCE_MUL_SVE_128BIT(2,  L, 16,  4)\n+dnl\n+instruct reduce_mul_sve_2F4F(vRegF dst, vRegF fsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            (n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 ||\n+             n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16));\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\/4F (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_2D(vRegD dst, vRegD dsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":191,"deletions":12,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -906,0 +906,186 @@\n+\/\/ The input vector length is expected to be 8 bytes or 16 bytes.\n+\/\/ dst and isrc are expected to be different registers.\n+void C2_MacroAssembler::neon_add_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                                    FloatRegister vsrc, int vector_length_in_bytes,\n+                                                    FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  BLOCK_COMMENT(\"neon_add_reduction_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        addv(vtmp, vector_length_in_bytes == 16 ? T16B : T8B, vsrc);\n+        smov(dst, vtmp, B, 0);\n+        addw(dst, dst, isrc, ext::sxtb);\n+        break;\n+      case T_SHORT:\n+        addv(vtmp, vector_length_in_bytes == 16 ? T8H : T4H, vsrc);\n+        smov(dst, vtmp, H, 0);\n+        addw(dst, dst, isrc, ext::sxth);\n+        break;\n+      case T_INT:\n+        vector_length_in_bytes == 16 ? addv(vtmp, T4S, vsrc) : addpv(vtmp, T2S, vsrc, vsrc);\n+        umov(dst, vtmp, S, 0);\n+        addw(dst, dst, isrc);\n+        break;\n+      case T_LONG:\n+        assert(vector_length_in_bytes == 16, \"unsupported\");\n+        addpd(vtmp, vsrc);\n+        umov(dst, vtmp, D, 0);\n+        add(dst, dst, isrc);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_add_reduction_integral\");\n+}\n+\n+\/\/ The input vector length is expected to be 8 bytes or 16 bytes.\n+\/\/ vtmp1 and vtmp2 may not be used and are expected to be fnoreg for\n+\/\/ same cases.\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::neon_mul_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                                    FloatRegister vsrc, int vector_length_in_bytes,\n+                                                    FloatRegister vtmp1, FloatRegister vtmp2) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  BLOCK_COMMENT(\"neon_mul_reduction_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        if (vector_length_in_bytes == 8) {\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+        } else {\n+          \/\/ Multiply the lower half and higher half of vector iteratively.\n+          \/\/ vtmp1 = vsrc[8:15]\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          \/\/ vtmp1[n] = vsrc[n] * vsrc[n + 8], where n=[0, 7]\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+          \/\/ vtmp2 = vtmp1[4:7]\n+          ins(vtmp2, S, vtmp1, 0, 1);\n+          \/\/ vtmp1[n] = vtmp1[n] * vtmp1[n + 4], where n=[0, 3]\n+          mulv(vtmp1, T8B, vtmp2, vtmp1);\n+        }\n+        \/\/ vtmp2 = vtmp1[2:3]\n+        ins(vtmp2, H, vtmp1, 0, 1);\n+        \/\/ vtmp2[n] = vtmp1[n] * vtmp1[n + 2], where n=[0, 1]\n+        mulv(vtmp2, T8B, vtmp2, vtmp1);\n+        \/\/ dst = vtmp2[0] * isrc * vtmp2[1]\n+        umov(rscratch1, vtmp2, B, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxtb(dst, dst);\n+        umov(rscratch1, vtmp2, B, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxtb(dst, dst);\n+        break;\n+      case T_SHORT:\n+        if (vector_length_in_bytes == 8) {\n+          assert(vtmp2 == fnoreg, \"should be\");\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vsrc);\n+        } else {\n+          ins(vtmp2, D, vsrc, 0, 1);\n+          mulv(vtmp2, T4H, vtmp2, vsrc);\n+          ins(vtmp1, S, vtmp2, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vtmp2);\n+        }\n+        umov(rscratch1, vtmp1, H, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxth(dst, dst);\n+        umov(rscratch1, vtmp1, H, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxth(dst, dst);\n+        break;\n+      case T_INT:\n+        if (vector_length_in_bytes == 8) {\n+          assert(vtmp1 == fnoreg && vtmp2 == fnoreg, \"should be\");\n+          vtmp1 = vsrc;\n+        } else {\n+          assert(vtmp2 == fnoreg, \"should be\");\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          mulv(vtmp1, T2S, vtmp1, vsrc);\n+        }\n+        umov(rscratch1, vtmp1, S, 0);\n+        mul(dst, rscratch1, isrc);\n+        umov(rscratch1, vtmp1, S, 1);\n+        mul(dst, rscratch1, dst);\n+        break;\n+      case T_LONG:\n+        assert(vtmp1 == fnoreg && vtmp2 == fnoreg, \"should be\");\n+        umov(rscratch1, vsrc, D, 0);\n+        mul(dst, isrc, rscratch1);\n+        umov(rscratch1, vsrc, D, 1);\n+        mul(dst, dst, rscratch1);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_mul_reduction_integral\");\n+}\n+\n+void C2_MacroAssembler::neon_mul_reduction_fp(FloatRegister dst, BasicType bt, FloatRegister fsrc,\n+                                              FloatRegister vsrc, int vector_length_in_bytes,\n+                                              FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  BLOCK_COMMENT(\"neon_mul_reduction_fp {\");\n+    switch(bt) {\n+      case T_FLOAT:\n+        fmuls(dst, fsrc, vsrc);\n+        ins(vtmp, S, vsrc, 0, 1);\n+        fmuls(dst, dst, vtmp);\n+        if (vector_length_in_bytes == 16) {\n+          ins(vtmp, S, vsrc, 0, 2);\n+          fmuls(dst, dst, vtmp);\n+          ins(vtmp, S, vsrc, 0, 3);\n+          fmuls(dst, dst, vtmp);\n+         }\n+        break;\n+      case T_DOUBLE:\n+        assert(vector_length_in_bytes == 16, \"unsupported\");\n+        fmuld(dst, fsrc, vsrc);\n+        ins(vtmp, D, vsrc, 0, 1);\n+        fmuld(dst, dst, vtmp);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_mul_reduction_fp\");\n+}\n+\n+\/\/ The input vector length is expected to be 8 bytes or 16 bytes.\n+\/\/ dst and isrc are expected to be different registers.\n+\/\/ Clobbers: rflags\n+\/\/ vtmp will not be used when bt == T_LONG.\n+void C2_MacroAssembler::neon_minmax_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                                       FloatRegister vsrc, int vector_length_in_bytes,\n+                                                       bool is_min, FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+\n+  BLOCK_COMMENT(\"neon_minmax_reduction_integral {\");\n+    if (bt == T_LONG) {\n+      assert(vector_length_in_bytes == 16, \"should be\");\n+      umov(rscratch1, vsrc, D, 0);\n+      cmp(isrc, rscratch1);\n+      csel(dst, isrc, rscratch1, is_min ? LT : GT);\n+      umov(rscratch1, vsrc, D, 1);\n+      cmp(dst, rscratch1);\n+      csel(dst, dst, rscratch1, is_min ? LT : GT);\n+    } else {\n+      SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt),\n+                                                vector_length_in_bytes == 16);\n+      if (size == T2S) {\n+        assert(bt == T_INT && vector_length_in_bytes == 8, \"should be\");\n+        is_min ? sminp(vtmp, T2S, vsrc, vsrc) : smaxp(vtmp, T2S, vsrc, vsrc);\n+      } else {\n+        is_min ? sminv(vtmp, size, vsrc) : smaxv(vtmp, size, vsrc);\n+      }\n+      smov(dst, vtmp, elemType_to_regVariant(bt), 0);\n+      cmpw(dst, isrc);\n+      cselw(dst, dst, isrc, is_min ? LT : GT);\n+    }\n+  BLOCK_COMMENT(\"} neon_minmax_reduction_integral\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -61,0 +61,13 @@\n+  void neon_add_reduction_integral(Register dst, BasicType bt, Register isrc, FloatRegister vsrc,\n+                                   int vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_mul_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                   FloatRegister vsrc, int vector_length_in_bytes,\n+                                   FloatRegister vtmp1, FloatRegister vtmp2);\n+\n+  void neon_mul_reduction_fp(FloatRegister dst, BasicType bt, FloatRegister fsrc,\n+                             FloatRegister vsrc, int vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_minmax_reduction_integral(Register dst, BasicType bt, Register isrc, FloatRegister vsrc,\n+                                      int vector_length_in_bytes, bool is_min, FloatRegister vtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}