{"files":[{"patch":"@@ -568,43 +568,1 @@\n-instruct reduce_add8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+instruct reduce_addID(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp) %{\n@@ -612,7 +570,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction4S\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction integral (64 bits)\" %}\n@@ -620,4 +574,3 @@\n-    __ addv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 8, as_FloatRegister($vtmp$$reg));\n@@ -628,3 +581,1 @@\n-instruct reduce_add8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+instruct reduce_addIX(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp) %{\n@@ -632,7 +583,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction8S\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction integral (128 bits)\" %}\n@@ -640,4 +587,3 @@\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n@@ -648,2 +594,1 @@\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n+instruct reduce_addL_neon(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX vtmp) %{\n@@ -651,6 +596,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction2L\" %}\n@@ -658,3 +600,3 @@\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n@@ -665,2 +607,1 @@\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2) %{\n@@ -669,13 +610,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8B\" %}\n@@ -683,14 +614,3 @@\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -701,2 +621,1 @@\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2) %{\n@@ -705,34 +624,7 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction16B\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -743,2 +635,1 @@\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp) %{\n@@ -747,11 +638,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n+  ins_cost(8 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4S\" %}\n@@ -759,10 +642,3 @@\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n@@ -773,2 +649,1 @@\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2) %{\n@@ -777,13 +652,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8S\" %}\n@@ -791,14 +656,3 @@\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -809,30 +663,6 @@\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8B\"\n-  %}\n+instruct reduce_mul_neon_2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2I\" %}\n@@ -840,4 +670,3 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   fnoreg, fnoreg);\n@@ -845,1 +674,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -848,11 +677,6 @@\n-instruct reduce_max16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction16B\"\n-  %}\n+instruct reduce_mul_neon_4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4I\" %}\n@@ -860,4 +684,3 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n@@ -865,1 +688,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -868,11 +691,5 @@\n-instruct reduce_max4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4S\"\n-  %}\n+instruct reduce_mul_neon_2L(iRegLNoSp dst, iRegL isrc, vecX vsrc) %{\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2L\" %}\n@@ -880,4 +697,3 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   fnoreg, fnoreg);\n@@ -888,11 +704,5 @@\n-instruct reduce_max8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8S\"\n-  %}\n+instruct reduce_mul_neon_2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\" %}\n@@ -900,4 +710,4 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -905,1 +715,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -908,11 +718,5 @@\n-instruct reduce_max4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4I\"\n-  %}\n+instruct reduce_mul_neon_4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction4F\" %}\n@@ -920,4 +724,4 @@\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -925,1 +729,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -928,11 +732,5 @@\n-instruct reduce_min8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8B\"\n-  %}\n+instruct reduce_mul_neon_2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D\" %}\n@@ -940,4 +738,3 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n@@ -945,1 +742,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -948,3 +745,4 @@\n-instruct reduce_min16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+instruct reduce_minID(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -952,27 +750,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4S\"\n-  %}\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_min_reduction_integral $dst, $isrc, $vsrc\\t# min reduction (D)\" %}\n@@ -980,4 +754,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 8, \/* is_min *\/ true,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -988,3 +762,4 @@\n-instruct reduce_min8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+instruct reduce_minIX(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -992,7 +767,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8S\"\n-  %}\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_min_reduction_integral $dst, $isrc, $vsrc\\t# min reduction (X)\" %}\n@@ -1000,4 +771,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 16, \/* is_min *\/ true,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -1008,11 +779,8 @@\n-instruct reduce_min4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4I\"\n-  %}\n+instruct reduce_maxID(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_max_reduction_integral $dst, $isrc, $vsrc\\t# max reduction (D)\" %}\n@@ -1020,4 +788,4 @@\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 8, \/* is_min *\/ false,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -1028,3 +796,4 @@\n-instruct reduce_max2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+instruct reduce_maxIX(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -1032,7 +801,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction2I\"\n-  %}\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_max_reduction_integral $dst, $isrc, $vsrc\\t# max reduction (X)\" %}\n@@ -1040,4 +805,4 @@\n-    __ smaxp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ 16, \/* is_min *\/ false,\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -1048,3 +813,2 @@\n-instruct reduce_min2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+instruct reduce_min2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n@@ -1052,6 +816,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction2I\"\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"neon_minmax_reduction_integral $dst, $isrc, $vsrc\\t# min reduction (2L)\"\n@@ -1060,4 +821,3 @@\n-    __ sminp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                      as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                      \/* is_min *\/ true, fnoreg);\n@@ -1068,2 +828,1 @@\n-instruct reduce_max2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n+instruct reduce_max2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, rFlagsReg cr) %{\n@@ -1072,32 +831,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp GT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp GT\\t# max reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::GT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp LT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp LT\\t# min reduction2L\"\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"neon_minmax_reduction_integral $dst, $isrc, $vsrc\\t# max reduction (2L)\"\n@@ -1106,6 +836,3 @@\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::LT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::LT);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                      as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                      \/* is_min *\/ false, fnoreg);\n@@ -3313,84 +3040,0 @@\n-instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addv  $vtmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp, TEMP dst);\n-  format %{ \"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -3449,52 +3092,0 @@\n-instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction2F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction4F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -3521,20 +3112,0 @@\n-instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVD dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuld $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"fmuld $dst, $dst, $tmp\\t# mul reduction2D\"\n-  %}\n-  ins_encode %{\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":167,"deletions":596,"binary":false,"changes":763,"status":"modified"},{"patch":"@@ -347,4 +347,2 @@\n-define(`REDUCE_ADD_BORS', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+define(`REDUCE_ADD', `\n+instruct reduce_addI$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$2 vsrc, vec$2 vtmp) %{\n@@ -352,7 +350,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T$1`'iTYPE2SIMD($2), $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, iTYPE2SIMD($2), 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxt$4  $dst, $dst\\t# add reduction$1$2\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction integral ($1 bits)\" %}\n@@ -360,4 +354,3 @@\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1`'iTYPE2SIMD($2), as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($2), 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxt$4($dst$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ ifelse($1, 64, 8, 16), as_FloatRegister($vtmp$$reg));\n@@ -367,6 +360,2 @@\n-dnl             $1  $2 $3 $4\n-REDUCE_ADD_BORS(8,  B, D, b)\n-REDUCE_ADD_BORS(16, B, X, b)\n-REDUCE_ADD_BORS(4,  S, D, h)\n-REDUCE_ADD_BORS(8,  S, X, h)\n-dnl\n+REDUCE_ADD(64, D)\n+REDUCE_ADD(128, X)\n@@ -374,2 +363,1 @@\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n+instruct reduce_addL_neon(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX vtmp) %{\n@@ -377,6 +365,3 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral  $dst, $isrc, $vsrc\\t# add reduction2L\" %}\n@@ -384,3 +369,3 @@\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n@@ -391,2 +376,1 @@\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2) %{\n@@ -395,28 +379,7 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8B\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -427,2 +390,1 @@\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2) %{\n@@ -431,34 +393,7 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction16B\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -469,2 +404,1 @@\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp) %{\n@@ -473,22 +407,7 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+  ins_cost(8 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4S\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n@@ -499,2 +418,1 @@\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n+instruct reduce_mul_neon_8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2) %{\n@@ -503,28 +421,7 @@\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8S\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n@@ -535,9 +432,10 @@\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n+instruct reduce_mul_neon_2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2I\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   fnoreg, fnoreg);\n@@ -545,0 +443,9 @@\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_neon_4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4I\" %}\n@@ -546,4 +453,16 @@\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_neon_2L(iRegLNoSp dst, iRegL isrc, vecX vsrc) %{\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2L\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   fnoreg, fnoreg);\n@@ -553,12 +472,11 @@\n-dnl\n-define(`REDUCE_MAX_MIN_INT', `\n-instruct reduce_$1$2$3`'(iRegINoSp dst, iRegIorL2I isrc, vec$4 vsrc, vec$4 tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst ($5ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1v $tmp, T$2`'iTYPE2SIMD($3), $vsrc\\n\\t\"\n-            \"$6mov  $dst, $tmp, iTYPE2SIMD($3), 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $7\\t# $1 reduction$2$3\"\n+\n+instruct reduce_mul_neon_2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -566,0 +484,8 @@\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_neon_4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction4F\" %}\n@@ -567,4 +493,4 @@\n-    __ s$1v(as_FloatRegister($tmp$$reg), __ T$2`'iTYPE2SIMD($3), as_FloatRegister($vsrc$$reg));\n-    __ $6mov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($3), 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$7);\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n@@ -572,25 +498,12 @@\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2  $3 $4 $5   $6 $7\n-REDUCE_MAX_MIN_INT(max, 8,  B, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 16, B, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  S, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 8,  S, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  I, X, Max, u, GT)\n-REDUCE_MAX_MIN_INT(min, 8,  B, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 16, B, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  S, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 8,  S, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  I, X, Min, u, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2I', `\n-instruct reduce_$1`'2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1p $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $3\\t# $1 reduction2I\"\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_neon_2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX vtmp) %{\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n@@ -598,0 +511,12 @@\n+  ins_pipe(pipe_class_default);\n+%}\n+dnl\n+define(`REDUCE_MAX_MIN_I', `\n+instruct reduce_$2I$1(iRegINoSp dst, iRegIorL2I isrc, vec$1 vsrc, vec$1 vtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (ifelse($2, min, MinReductionV, MaxReductionV) isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  format %{ \"neon_$2_reduction_integral $dst, $isrc, $vsrc\\t# $2 reduction ($1)\" %}\n@@ -599,4 +524,4 @@\n-    __ s$1p(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$3);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ ifelse($1, D, 8, 16), \/* is_min *\/ ifelse($2, min, true, false),\n+                                      as_FloatRegister($vtmp$$reg));\n@@ -606,7 +531,8 @@\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2I(max, Max, GT)\n-REDUCE_MAX_MIN_2I(min, Min, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2L', `\n-instruct reduce_$1`'2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n+dnl              $1  $2\n+REDUCE_MAX_MIN_I(D,  min)\n+REDUCE_MAX_MIN_I(X,  min)\n+REDUCE_MAX_MIN_I(D,  max)\n+REDUCE_MAX_MIN_I(X,  max)\n+dnl\n+define(`REDUCE_MAX_MIN_L', `\n+instruct reduce_$1`2L'(iRegLNoSp dst, iRegL isrc, vecX vsrc, rFlagsReg cr) %{\n@@ -614,9 +540,4 @@\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp $3\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp $3\\t# $1 reduction2L\"\n+  match(Set dst (ifelse($1, min, MinReductionV, MaxReductionV) isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"neon_minmax_reduction_integral $dst, $isrc, $vsrc\\t# $1 reduction (2L)\"\n@@ -625,6 +546,3 @@\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::$3);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::$3);\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                      as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                      \/* is_min *\/ ifelse($1, min, true, false), fnoreg);\n@@ -634,3 +552,3 @@\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2L(max, Max, GT)\n-REDUCE_MAX_MIN_2L(min, Min, LT)\n+dnl\n+REDUCE_MAX_MIN_L(min)\n+REDUCE_MAX_MIN_L(max)\n@@ -1609,62 +1527,2 @@\n-define(`REDUCE_ADD_INT', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ ifelse($1, 2, `\"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"',`\"addv  $vtmp, T4S, $vsrc\\n\\t\"')\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction$1I\"\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));', `__ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));')\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_ADD_INT(2, I, D)\n-REDUCE_ADD_INT(4, I, X)\n-dnl\n-define(`REDUCE_MUL_INT', `\n-instruct reduce_mul$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, ifelse($1, 2, iRegINoSp tmp`)', vecX vtmp`,' iRegINoSp itmp`)')\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP ifelse($1, 2, tmp, vtmp), TEMP ifelse($1, 2, dst, itmp`,' TEMP dst));\n-  format %{ ifelse($1, 2, `\"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"',`\"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"')\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);', `__ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_MUL_INT(2, I, D)\n-REDUCE_MUL_INT(4, I, X)\n-dnl\n-define(`REDUCE_MULORADD_FORD', `\n-instruct reduce_$6$2$3`'(vReg$3 dst, vReg$3 $4src, vec$5 vsrc, vec$5 tmp)\n+define(`REDUCE_ADD_FORD', `\n+instruct reduce_add$2$3`'(vReg$3 dst, vReg$3 $4src, vec$5 vsrc, vec$5 tmp)\n@@ -1672,1 +1530,1 @@\n-  match(Set dst (ifelse($6, add, Add, Mul)ReductionV$3 $4src vsrc));\n+  match(Set dst (AddReductionV$3 $4src vsrc));\n@@ -1677,1 +1535,1 @@\n-            ifelse($2, 2, `\"$1 $dst, $dst, $tmp\\t# $6 reduction$2$3\"',\n+            ifelse($2, 2, `\"$1 $dst, $dst, $tmp\\t# add reduction$2$3\"',\n@@ -1682,1 +1540,1 @@\n-            \"$1 $dst, $dst, $tmp\\t# $6 reduction4F\"')\n+            \"$1 $dst, $dst, $tmp\\t# add reduction4F\"')\n@@ -1702,7 +1560,4 @@\n-dnl                  $1     $2 $3 $4 $5 $6\n-REDUCE_MULORADD_FORD(fadds, 2, F, f, D, add)\n-REDUCE_MULORADD_FORD(fadds, 4, F, f, X, add)\n-REDUCE_MULORADD_FORD(fmuls, 2, F, f, D, mul)\n-REDUCE_MULORADD_FORD(fmuls, 4, F, f, X, mul)\n-REDUCE_MULORADD_FORD(faddd, 2, D, d, X, add)\n-REDUCE_MULORADD_FORD(fmuld, 2, D, d, X, mul)\n+dnl             $1     $2 $3 $4 $5\n+REDUCE_ADD_FORD(fadds, 2, F, f, D)\n+REDUCE_ADD_FORD(fadds, 4, F, f, X)\n+REDUCE_ADD_FORD(faddd, 2, D, d, X)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":162,"deletions":307,"binary":false,"changes":469,"status":"modified"},{"patch":"@@ -136,5 +136,0 @@\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n@@ -145,0 +140,5 @@\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return vlen >= 2 && length_in_bytes <= 16;\n@@ -159,0 +159,2 @@\n+  \/\/ If an opcode does not support mask, unpredicated node with VectorBlend node\n+  \/\/ will be used instead.\n@@ -160,1 +162,6 @@\n-    if (opcode == Op_VectorRearrange) {\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (opcode == Op_VectorRearrange ||\n+        opcode == Op_MulReductionVD ||\n+        opcode == Op_MulReductionVF ||\n+        opcode == Op_MulReductionVI ||\n+        opcode == Op_MulReductionVL) {\n@@ -163,0 +170,11 @@\n+\n+    \/\/ These nodes generate lower cost NEON instructions when vector length is\n+    \/\/ 64 or 128 bits.\n+    if (opcode == Op_AddReductionVI || opcode == Op_AddReductionVL) {\n+      assert(is_integral_type(bt), \"should be\");\n+      return length_in_bytes > 16;\n+    }\n+    if ((opcode == Op_MinReductionV || opcode == Op_MaxReductionV) &&\n+        (bt == T_BYTE || bt == T_SHORT || bt == T_INT)) {\n+      return length_in_bytes > 16;\n+    }\n@@ -2207,1 +2225,17 @@\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16);\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst,  $isrc,  $vsrc\\t# add reduction <128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                   as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg vtmp, pRegGov ptmp) %{\n@@ -2209,0 +2243,20 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -2212,1 +2266,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2223,1 +2277,17 @@\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addL_sve_128bits(iRegLNoSp dst, iRegL isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst, $isrc, $vsrc\\t# addL reduction 128 bits (sve)\"\n+  %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp, pRegGov ptmp) %{\n@@ -2225,0 +2295,18 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D,\n+                         Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -2264,38 +2352,0 @@\n-instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,\n-                             pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), variant,\n-                          Matcher::vector_length(this, $src2));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,\n-                             pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (AddReductionVL src1 src2));\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ D,\n-                          Matcher::vector_length(this, $src2));\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2479,1 +2529,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2633,1 +2683,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2787,1 +2837,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -2936,1 +2986,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -2973,0 +3023,1 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n@@ -3010,0 +3061,21 @@\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_maxI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"neon_max_reduce_integral $dst, $isrc, $vsrc\\t# maxI reduction LE 128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                      \/* is_min *\/ false,\n+                                      as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3234,1 +3306,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -3271,0 +3343,1 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n@@ -3308,0 +3381,21 @@\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_minI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"neon_min_reduce_integral $dst, $isrc, $vsrc\\t# minI reduction LE 128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                      \/* is_min *\/ true,\n+                                      as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3529,0 +3623,133 @@\n+\/\/ vector mul reduction\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_mul_sve_8B16B(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            (n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 ||\n+             n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16) &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8B\/16B (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_4S(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(8 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4S (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_8S(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8S (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_2I(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2I (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_4I(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4I (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_2L(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2L (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_2F4F(vRegF dst, vRegF fsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            (n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 ||\n+             n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16));\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\/4F (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_2D(vRegD dst, vRegD dsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":279,"deletions":52,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -131,5 +131,0 @@\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n@@ -140,0 +135,5 @@\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return vlen >= 2 && length_in_bytes <= 16;\n@@ -154,0 +154,2 @@\n+  \/\/ If an opcode does not support mask, unpredicated node with VectorBlend node\n+  \/\/ will be used instead.\n@@ -155,1 +157,6 @@\n-    if (opcode == Op_VectorRearrange) {\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (opcode == Op_VectorRearrange ||\n+        opcode == Op_MulReductionVD ||\n+        opcode == Op_MulReductionVF ||\n+        opcode == Op_MulReductionVI ||\n+        opcode == Op_MulReductionVL) {\n@@ -158,0 +165,11 @@\n+\n+    \/\/ These nodes generate lower cost NEON instructions when vector length is\n+    \/\/ 64 or 128 bits.\n+    if (opcode == Op_AddReductionVI || opcode == Op_AddReductionVL) {\n+      assert(is_integral_type(bt), \"should be\");\n+      return length_in_bytes > 16;\n+    }\n+    if ((opcode == Op_MinReductionV || opcode == Op_MaxReductionV) &&\n+        (bt == T_BYTE || bt == T_SHORT || bt == T_INT)) {\n+      return length_in_bytes > 16;\n+    }\n@@ -1317,1 +1335,1 @@\n-       `predicate(UseSVE > 0 &&\n+       `predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -1324,1 +1342,1 @@\n-  ins_cost(SVE_COST);\n+  ins_cost(SVE_COST + 3 * INSN_COST);\n@@ -1341,1 +1359,1 @@\n-       `predicate(UseSVE > 0 &&\n+       `predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -1587,0 +1605,37 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addI_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16);\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst,  $isrc,  $vsrc\\t# add reduction <128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                   as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg vtmp, pRegGov ptmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction partial (sve) (may extend)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), variant,\n+                          Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n@@ -1588,0 +1643,34 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_addL_sve_128bits(iRegLNoSp dst, iRegL isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_add_reduction_integral $dst, $isrc, $vsrc\\t# addL reduction 128 bits (sve)\"\n+  %}\n+  ins_encode %{\n+    __ neon_add_reduction_integral(as_Register($dst$$reg), T_LONG,\n+                                   as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ 16, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp, pRegGov ptmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_ptrue_lanecnt(as_PRegister($ptmp$$reg), __ D,\n+                         Matcher::vector_length(this, $src2));\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $src1$$Register, as_FloatRegister($src2$$reg),\n+                           as_PRegister($ptmp$$reg), as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -1591,2 +1680,0 @@\n-REDUCE_I_PARTIAL(add, AddReductionVI)\n-REDUCE_L_PARTIAL(add, AddReductionVL)\n@@ -1641,1 +1728,0 @@\n-\n@@ -1647,1 +1733,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && MaxVectorSize > 16 &&\n@@ -1690,0 +1776,1 @@\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() > 16 &&\n@@ -1903,0 +1990,21 @@\n+define(`REDUCE_MAXMIN_I_128BIT', `\n+instruct reduce_$1I_sve_le128bits(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() <= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (ifelse($1, min, MinReductionV, MaxReductionV) isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP vtmp, KILL cr);\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"neon_$1_reduce_integral $dst, $isrc, $vsrc\\t# $1I reduction LE 128 bits (sve)\" %}\n+  ins_encode %{\n+    __ neon_minmax_reduction_integral(as_Register($dst$$reg), Matcher::vector_element_basic_type(this, $vsrc),\n+                                      as_Register($isrc$$reg), as_FloatRegister($vsrc$$reg),\n+                                      \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                      \/* is_min *\/ ifelse($1, min, true, false),\n+                                      as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n@@ -1908,0 +2016,3 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.dnl\n+REDUCE_MAXMIN_I_128BIT(max)\n@@ -1928,0 +2039,3 @@\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.dnl\n+REDUCE_MAXMIN_I_128BIT(min)\n@@ -1943,0 +2057,133 @@\n+\/\/ vector mul reduction\n+\n+\/\/ Generate lower cost NEON instructions for 64\/128 bits vectors.\n+instruct reduce_mul_sve_8B16B(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            (n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 ||\n+             n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16) &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(12 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8B\/16B (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_BYTE, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg),\n+                                   \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_4S(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(8 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4S (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_8S(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp1, vReg vtmp2) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(10 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction8S (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_SHORT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_2I(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2I (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 8,\n+                                   fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_4I(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  ins_cost(6 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction4I (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_INT, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   as_FloatRegister($vtmp$$reg), fnoreg);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_2L(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  ins_cost(4 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"neon_mul_reduction_integral $dst, $isrc, $vsrc\\t# mul reduction2L (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_integral(as_Register($dst$$reg), T_LONG, as_Register($isrc$$reg),\n+                                   as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                                   fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mul_sve_2F4F(vRegF dst, vRegF fsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            (n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 8 ||\n+             n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16));\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  ins_cost(7 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $fsrc, $vsrc\\t# mul reduction2F\/4F (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_FLOAT, as_FloatRegister($fsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg),\n+                             \/* vector_length_in_bytes *\/ Matcher::vector_length_in_bytes(this, $vsrc),\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reduce_mul_sve_2D(vRegD dst, vRegD dsrc, vReg vsrc, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  ins_cost(3 * INSN_COST);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"neon_mul_reduction_fp $dst, $dsrc, $vsrc\\t# mul reduction2D (sve)\" %}\n+  ins_encode %{\n+    __ neon_mul_reduction_fp(as_FloatRegister($dst$$reg), T_DOUBLE, as_FloatRegister($dsrc$$reg),\n+                             as_FloatRegister($vsrc$$reg), \/* vector_length_in_bytes *\/ 16,\n+                             as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":260,"deletions":13,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,0 +906,186 @@\n+\/\/ The input vector length is expected to be 8 bytes or 16 bytes.\n+\/\/ dst and isrc are expected to be different registers.\n+void C2_MacroAssembler::neon_add_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                                    FloatRegister vsrc, int vector_length_in_bytes,\n+                                                    FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  BLOCK_COMMENT(\"neon_add_reduction_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        addv(vtmp, vector_length_in_bytes == 16 ? T16B : T8B, vsrc);\n+        smov(dst, vtmp, B, 0);\n+        addw(dst, dst, isrc, ext::sxtb);\n+        break;\n+      case T_SHORT:\n+        addv(vtmp, vector_length_in_bytes == 16 ? T8H : T4H, vsrc);\n+        smov(dst, vtmp, H, 0);\n+        addw(dst, dst, isrc, ext::sxth);\n+        break;\n+      case T_INT:\n+        vector_length_in_bytes == 16 ? addv(vtmp, T4S, vsrc) : addpv(vtmp, T2S, vsrc, vsrc);\n+        umov(dst, vtmp, S, 0);\n+        addw(dst, dst, isrc);\n+        break;\n+      case T_LONG:\n+        assert(vector_length_in_bytes == 16, \"unsupported\");\n+        addpd(vtmp, vsrc);\n+        umov(dst, vtmp, D, 0);\n+        add(dst, dst, isrc);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_add_reduction_integral\");\n+}\n+\n+\/\/ The input vector length is expected to be 8 bytes or 16 bytes.\n+\/\/ vtmp1 and vtmp2 may not be used and are expected to be fnoreg for\n+\/\/ same cases.\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::neon_mul_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                                    FloatRegister vsrc, int vector_length_in_bytes,\n+                                                    FloatRegister vtmp1, FloatRegister vtmp2) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  BLOCK_COMMENT(\"neon_mul_reduction_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        if (vector_length_in_bytes == 8) {\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+        } else {\n+          \/\/ Multiply the lower half and higher half of vector iteratively.\n+          \/\/ vtmp1 = vsrc[8:15]\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          \/\/ vtmp1[n] = vsrc[n] * vsrc[n + 8], where n=[0, 7]\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+          \/\/ vtmp2 = vtmp1[4:7]\n+          ins(vtmp2, S, vtmp1, 0, 1);\n+          \/\/ vtmp1[n] = vtmp1[n] * vtmp1[n + 4], where n=[0, 3]\n+          mulv(vtmp1, T8B, vtmp2, vtmp1);\n+        }\n+        \/\/ vtmp2 = vtmp1[2:3]\n+        ins(vtmp2, H, vtmp1, 0, 1);\n+        \/\/ vtmp2[n] = vtmp1[n] * vtmp1[n + 2], where n=[0, 1]\n+        mulv(vtmp2, T8B, vtmp2, vtmp1);\n+        \/\/ dst = vtmp2[0] * isrc * vtmp2[1]\n+        umov(rscratch1, vtmp2, B, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxtb(dst, dst);\n+        umov(rscratch1, vtmp2, B, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxtb(dst, dst);\n+        break;\n+      case T_SHORT:\n+        if (vector_length_in_bytes == 8) {\n+          assert(vtmp2 == fnoreg, \"should be\");\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vsrc);\n+        } else {\n+          ins(vtmp2, D, vsrc, 0, 1);\n+          mulv(vtmp2, T4H, vtmp2, vsrc);\n+          ins(vtmp1, S, vtmp2, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vtmp2);\n+        }\n+        umov(rscratch1, vtmp1, H, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxth(dst, dst);\n+        umov(rscratch1, vtmp1, H, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxth(dst, dst);\n+        break;\n+      case T_INT:\n+        if (vector_length_in_bytes == 8) {\n+          assert(vtmp1 == fnoreg && vtmp2 == fnoreg, \"should be\");\n+          vtmp1 = vsrc;\n+        } else {\n+          assert(vtmp2 == fnoreg, \"should be\");\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          mulv(vtmp1, T2S, vtmp1, vsrc);\n+        }\n+        umov(rscratch1, vtmp1, S, 0);\n+        mul(dst, rscratch1, isrc);\n+        umov(rscratch1, vtmp1, S, 1);\n+        mul(dst, rscratch1, dst);\n+        break;\n+      case T_LONG:\n+        assert(vtmp1 == fnoreg && vtmp2 == fnoreg, \"should be\");\n+        umov(rscratch1, vsrc, D, 0);\n+        mul(dst, isrc, rscratch1);\n+        umov(rscratch1, vsrc, D, 1);\n+        mul(dst, dst, rscratch1);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_mul_reduction_integral\");\n+}\n+\n+void C2_MacroAssembler::neon_mul_reduction_fp(FloatRegister dst, BasicType bt, FloatRegister fsrc,\n+                                              FloatRegister vsrc, int vector_length_in_bytes,\n+                                              FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  BLOCK_COMMENT(\"neon_mul_reduction_fp {\");\n+    switch(bt) {\n+      case T_FLOAT:\n+        fmuls(dst, fsrc, vsrc);\n+        ins(vtmp, S, vsrc, 0, 1);\n+        fmuls(dst, dst, vtmp);\n+        if (vector_length_in_bytes == 16) {\n+          ins(vtmp, S, vsrc, 0, 2);\n+          fmuls(dst, dst, vtmp);\n+          ins(vtmp, S, vsrc, 0, 3);\n+          fmuls(dst, dst, vtmp);\n+         }\n+        break;\n+      case T_DOUBLE:\n+        assert(vector_length_in_bytes == 16, \"unsupported\");\n+        fmuld(dst, fsrc, vsrc);\n+        ins(vtmp, D, vsrc, 0, 1);\n+        fmuld(dst, dst, vtmp);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_mul_reduction_fp\");\n+}\n+\n+\/\/ The input vector length is expected to be 8 bytes or 16 bytes.\n+\/\/ dst and isrc are expected to be different registers.\n+\/\/ Clobbers: rflags\n+\/\/ vtmp will not be used when bt == T_LONG.\n+void C2_MacroAssembler::neon_minmax_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                                       FloatRegister vsrc, int vector_length_in_bytes,\n+                                                       bool is_min, FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+\n+  BLOCK_COMMENT(\"neon_minmax_reduction_integral {\");\n+    if (bt == T_LONG) {\n+      assert(vector_length_in_bytes == 16, \"should be\");\n+      umov(rscratch1, vsrc, D, 0);\n+      cmp(isrc, rscratch1);\n+      csel(dst, isrc, rscratch1, is_min ? LT : GT);\n+      umov(rscratch1, vsrc, D, 1);\n+      cmp(dst, rscratch1);\n+      csel(dst, dst, rscratch1, is_min ? LT : GT);\n+    } else {\n+      SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt),\n+                                                vector_length_in_bytes == 16);\n+      if (size == T2S) {\n+        assert(bt == T_INT && vector_length_in_bytes == 8, \"should be\");\n+        is_min ? sminp(vtmp, T2S, vsrc, vsrc) : smaxp(vtmp, T2S, vsrc, vsrc);\n+      } else {\n+        is_min ? sminv(vtmp, size, vsrc) : smaxv(vtmp, size, vsrc);\n+      }\n+      smov(dst, vtmp, elemType_to_regVariant(bt), 0);\n+      cmpw(dst, isrc);\n+      cselw(dst, dst, isrc, is_min ? LT : GT);\n+    }\n+  BLOCK_COMMENT(\"} neon_minmax_reduction_integral\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":187,"deletions":1,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,13 @@\n+  void neon_add_reduction_integral(Register dst, BasicType bt, Register isrc, FloatRegister vsrc,\n+                                   int vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_mul_reduction_integral(Register dst, BasicType bt, Register isrc,\n+                                   FloatRegister vsrc, int vector_length_in_bytes,\n+                                   FloatRegister vtmp1, FloatRegister vtmp2);\n+\n+  void neon_mul_reduction_fp(FloatRegister dst, BasicType bt, FloatRegister fsrc,\n+                             FloatRegister vsrc, int vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_minmax_reduction_integral(Register dst, BasicType bt, Register isrc, FloatRegister vsrc,\n+                                      int vector_length_in_bytes, bool is_min, FloatRegister vtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}