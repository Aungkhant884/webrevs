{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import static java.lang.Character.digit;\n@@ -541,2 +542,1 @@\n-                throws NumberFormatException\n-    {\n+                throws NumberFormatException {\n@@ -554,2 +554,2 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                                            \" less than Character.MIN_RADIX\");\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n@@ -559,23 +559,16 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                                            \" greater than Character.MAX_RADIX\");\n-        }\n-\n-        boolean negative = false;\n-        int i = 0, len = s.length();\n-        int limit = -Integer.MAX_VALUE;\n-\n-        if (len > 0) {\n-            char firstChar = s.charAt(0);\n-            if (firstChar < '0') { \/\/ Possible leading \"+\" or \"-\"\n-                if (firstChar == '-') {\n-                    negative = true;\n-                    limit = Integer.MIN_VALUE;\n-                } else if (firstChar != '+') {\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-\n-                if (len == 1) { \/\/ Cannot have lone \"+\" or \"-\"\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-                i++;\n-            }\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        }\n+\n+        int len = s.length();\n+        if (len == 0) {\n+            throw new NumberFormatException(\"\");\n+        }\n+        int digit = ~0xFF;\n+        int i = 0;\n+        char firstChar = s.charAt(i++);\n+        if (firstChar != '-' && firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && len > 1) {\n+            int limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n@@ -583,12 +576,10 @@\n-            int result = 0;\n-            while (i < len) {\n-                \/\/ Accumulating negatively avoids surprises near MAX_VALUE\n-                int digit = Character.digit(s.charAt(i++), radix);\n-                if (digit < 0 || result < multmin) {\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-                result *= radix;\n-                if (result < limit + digit) {\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-                result -= digit;\n+            int result = -(digit & 0xFF);\n+            boolean inRange = true;\n+            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = result > multmin\n+                        || result == multmin && digit <= radix * multmin - limit)) {\n+                result = radix * result - digit;\n+            }\n+            if (inRange && i == len && digit >= 0) {\n+                return firstChar != '-' ? -result : result;\n@@ -596,3 +587,0 @@\n-            return negative ? result : -result;\n-        } else {\n-            throw NumberFormatException.forInputString(s, radix);\n@@ -600,0 +588,1 @@\n+        throw NumberFormatException.forInputString(s, radix);\n@@ -635,2 +624,2 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                                            \" less than Character.MIN_RADIX\");\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n@@ -638,0 +627,1 @@\n+\n@@ -639,2 +629,2 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                                            \" greater than Character.MAX_RADIX\");\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n@@ -643,1 +633,10 @@\n-        boolean negative = false;\n+        \/*\n+         * While s can be concurrently modified, it is ensured that each\n+         * of its characters is read at most once, from lower to higher indices.\n+         * This is obtained by reading them using the pattern s.charAt(i++),\n+         * and by not updating i anywhere else.\n+         *\/\n+        if (beginIndex == endIndex) {\n+            throw new NumberFormatException(\"\");\n+        }\n+        int digit = ~0xFF;\n@@ -645,18 +644,6 @@\n-        int limit = -Integer.MAX_VALUE;\n-\n-        if (i < endIndex) {\n-            char firstChar = s.charAt(i);\n-            if (firstChar < '0') { \/\/ Possible leading \"+\" or \"-\"\n-                if (firstChar == '-') {\n-                    negative = true;\n-                    limit = Integer.MIN_VALUE;\n-                } else if (firstChar != '+') {\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-                i++;\n-                if (i == endIndex) { \/\/ Cannot have lone \"+\" or \"-\"\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-            }\n+        char firstChar = s.charAt(i++);\n+        if (firstChar != '-' && firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && endIndex - beginIndex > 1) {\n+            int limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n@@ -664,15 +651,10 @@\n-            int result = 0;\n-            while (i < endIndex) {\n-                \/\/ Accumulating negatively avoids surprises near MAX_VALUE\n-                int digit = Character.digit(s.charAt(i), radix);\n-                if (digit < 0 || result < multmin) {\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-                result *= radix;\n-                if (result < limit + digit) {\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-                i++;\n-                result -= digit;\n+            int result = -(digit & 0xFF);\n+            boolean inRange = true;\n+            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+            while (i < endIndex && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = result > multmin\n+                        || result == multmin && digit <= radix * multmin - limit)) {\n+                result = radix * result - digit;\n+            }\n+            if (inRange && i == endIndex && digit >= 0) {\n+                return firstChar != '-' ? -result : result;\n@@ -680,3 +662,0 @@\n-            return negative ? result : -result;\n-        } else {\n-            throw NumberFormatException.forInputString(\"\", radix);\n@@ -684,0 +663,2 @@\n+        throw NumberFormatException.forCharSequence(s, beginIndex,\n+            endIndex, i - (digit < -1 ? 0 : 1));\n@@ -704,1 +685,1 @@\n-        return parseInt(s,10);\n+        return parseInt(s, 10);\n@@ -756,0 +737,10 @@\n+        if (radix < Character.MIN_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n+        }\n+\n+        if (radix > Character.MAX_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        }\n+\n@@ -757,20 +748,21 @@\n-        if (len > 0) {\n-            char firstChar = s.charAt(0);\n-            if (firstChar == '-') {\n-                throw new\n-                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n-                                                       \"on unsigned string %s.\", s));\n-            } else {\n-                if (len <= 5 || \/\/ Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n-                    (radix == 10 && len <= 9) ) { \/\/ Integer.MAX_VALUE in base 10 is 10 digits\n-                    return parseInt(s, radix);\n-                } else {\n-                    long ell = Long.parseLong(s, radix);\n-                    if ((ell & 0xffff_ffff_0000_0000L) == 0) {\n-                        return (int) ell;\n-                    } else {\n-                        throw new\n-                            NumberFormatException(String.format(\"String value %s exceeds \" +\n-                                                                \"range of unsigned int.\", s));\n-                    }\n-                }\n+        if (len == 0) {\n+            throw NumberFormatException.forInputString(s, radix);\n+        }\n+        int i = 0;\n+        char firstChar = s.charAt(i++);\n+        if (firstChar == '-') {\n+            throw new NumberFormatException(String.format(\n+                \"Illegal leading minus sign on unsigned string %s.\", s));\n+        }\n+        int digit = ~0xFF;\n+        if (firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && len > 1) {\n+            int multmax = divideUnsigned(-1, radix);  \/\/ -1 is max unsigned int\n+            int result = digit & 0xFF;\n+            boolean inRange = true;\n+            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = compareUnsigned(result, multmax) < 0\n+                        || result == multmax && digit < -radix * multmax)) {\n+                result = radix * result + digit;\n@@ -778,1 +770,5 @@\n-        } else {\n+            if (inRange && i == len && digit >= 0) {\n+                return result;\n+            }\n+        }\n+        if (digit < 0) {\n@@ -781,0 +777,2 @@\n+        throw new NumberFormatException(String.format(\n+            \"String value %s exceeds range of unsigned int.\", s));\n@@ -815,24 +813,17 @@\n-        int start = beginIndex, len = endIndex - beginIndex;\n-\n-        if (len > 0) {\n-            char firstChar = s.charAt(start);\n-            if (firstChar == '-') {\n-                throw new\n-                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n-                                                       \"on unsigned string %s.\", s));\n-            } else {\n-                if (len <= 5 || \/\/ Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n-                        (radix == 10 && len <= 9)) { \/\/ Integer.MAX_VALUE in base 10 is 10 digits\n-                    return parseInt(s, start, start + len, radix);\n-                } else {\n-                    long ell = Long.parseLong(s, start, start + len, radix);\n-                    if ((ell & 0xffff_ffff_0000_0000L) == 0) {\n-                        return (int) ell;\n-                    } else {\n-                        throw new\n-                            NumberFormatException(String.format(\"String value %s exceeds \" +\n-                                                                \"range of unsigned int.\", s));\n-                    }\n-                }\n-            }\n-        } else {\n+        if (radix < Character.MIN_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n+        }\n+\n+        if (radix > Character.MAX_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        }\n+\n+        \/*\n+         * While s can be concurrently modified, it is ensured that each\n+         * of its characters is read at most once, from lower to higher indices.\n+         * This is obtained by reading them using the pattern s.charAt(i++),\n+         * and by not updating i anywhere else.\n+         *\/\n+        if (beginIndex == endIndex) {\n@@ -841,0 +832,29 @@\n+        int i = beginIndex;\n+        char firstChar = s.charAt(i++);\n+        if (firstChar == '-') {\n+            throw new NumberFormatException(\n+                \"Illegal leading minus sign on unsigned string \" + s + \".\");\n+        }\n+        int digit = ~0xFF;\n+        if (firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && endIndex - beginIndex > 1) {\n+            int multmax = divideUnsigned(-1, radix);  \/\/ -1 is max unsigned int\n+            int result = digit & 0xFF;\n+            boolean inRange = true;\n+            while (i < endIndex && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = compareUnsigned(result, multmax) < 0\n+                        || result == multmax && digit < -radix * multmax)) {\n+                result = radix * result + digit;\n+            }\n+            if (inRange && i == endIndex && digit >= 0) {\n+                return result;\n+            }\n+        }\n+        if (digit < 0) {\n+            throw NumberFormatException.forCharSequence(s, beginIndex,\n+                endIndex, i - (digit < -1 ? 0 : 1));\n+        }\n+        throw new NumberFormatException(String.format(\n+            \"String value %s exceeds range of unsigned int.\", s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":149,"deletions":129,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static java.lang.Character.digit;\n@@ -577,2 +578,1 @@\n-              throws NumberFormatException\n-    {\n+                throws NumberFormatException {\n@@ -584,2 +584,2 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                                            \" less than Character.MIN_RADIX\");\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n@@ -587,0 +587,1 @@\n+\n@@ -588,17 +589,3 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                                            \" greater than Character.MAX_RADIX\");\n-        }\n-\n-        boolean negative = false;\n-        int i = 0, len = s.length();\n-        long limit = -Long.MAX_VALUE;\n-\n-        if (len > 0) {\n-            char firstChar = s.charAt(0);\n-            if (firstChar < '0') { \/\/ Possible leading \"+\" or \"-\"\n-                if (firstChar == '-') {\n-                    negative = true;\n-                    limit = Long.MIN_VALUE;\n-                } else if (firstChar != '+') {\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        }\n@@ -606,5 +593,12 @@\n-                if (len == 1) { \/\/ Cannot have lone \"+\" or \"-\"\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-                i++;\n-            }\n+        int len = s.length();\n+        if (len == 0) {\n+            throw new NumberFormatException(\"\");\n+        }\n+        int digit = ~0xFF;\n+        int i = 0;\n+        char firstChar = s.charAt(i++);\n+        if (firstChar != '-' && firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && len > 1) {\n+            long limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n@@ -612,12 +606,10 @@\n-            long result = 0;\n-            while (i < len) {\n-                \/\/ Accumulating negatively avoids surprises near MAX_VALUE\n-                int digit = Character.digit(s.charAt(i++),radix);\n-                if (digit < 0 || result < multmin) {\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-                result *= radix;\n-                if (result < limit + digit) {\n-                    throw NumberFormatException.forInputString(s, radix);\n-                }\n-                result -= digit;\n+            long result = -(digit & 0xFF);\n+            boolean inRange = true;\n+            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = result > multmin\n+                        || result == multmin && digit <= (int) (radix * multmin - limit))) {\n+                result = radix * result - digit;\n+            }\n+            if (inRange && i == len && digit >= 0) {\n+                return firstChar != '-' ? -result : result;\n@@ -625,3 +617,0 @@\n-            return negative ? result : -result;\n-        } else {\n-            throw NumberFormatException.forInputString(s, radix);\n@@ -629,0 +618,1 @@\n+        throw NumberFormatException.forInputString(s, radix);\n@@ -664,2 +654,2 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                    \" less than Character.MIN_RADIX\");\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n@@ -667,0 +657,1 @@\n+\n@@ -668,2 +659,2 @@\n-            throw new NumberFormatException(\"radix \" + radix +\n-                    \" greater than Character.MAX_RADIX\");\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n@@ -672,1 +663,10 @@\n-        boolean negative = false;\n+        \/*\n+         * While s can be concurrently modified, it is ensured that each\n+         * of its characters is read at most once, from lower to higher indices.\n+         * This is obtained by reading them using the pattern s.charAt(i++),\n+         * and by not updating i anywhere else.\n+         *\/\n+        if (beginIndex == endIndex) {\n+            throw new NumberFormatException(\"\");\n+        }\n+        int digit = ~0xFF;  \/\/ ~0xFF means firstChar char is sign\n@@ -674,18 +674,6 @@\n-        long limit = -Long.MAX_VALUE;\n-\n-        if (i < endIndex) {\n-            char firstChar = s.charAt(i);\n-            if (firstChar < '0') { \/\/ Possible leading \"+\" or \"-\"\n-                if (firstChar == '-') {\n-                    negative = true;\n-                    limit = Long.MIN_VALUE;\n-                } else if (firstChar != '+') {\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-                i++;\n-            }\n-            if (i >= endIndex) { \/\/ Cannot have lone \"+\", \"-\" or \"\"\n-                throw NumberFormatException.forCharSequence(s, beginIndex,\n-                        endIndex, i);\n-            }\n+        char firstChar = s.charAt(i++);\n+        if (firstChar != '-' && firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && endIndex - beginIndex > 1) {\n+            long limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n@@ -693,15 +681,10 @@\n-            long result = 0;\n-            while (i < endIndex) {\n-                \/\/ Accumulating negatively avoids surprises near MAX_VALUE\n-                int digit = Character.digit(s.charAt(i), radix);\n-                if (digit < 0 || result < multmin) {\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-                result *= radix;\n-                if (result < limit + digit) {\n-                    throw NumberFormatException.forCharSequence(s, beginIndex,\n-                            endIndex, i);\n-                }\n-                i++;\n-                result -= digit;\n+            long result = -(digit & 0xFF);\n+            boolean inRange = true;\n+            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+            while (i < endIndex && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = result > multmin\n+                        || result == multmin && digit <= (int) (radix * multmin - limit))) {\n+                result = radix * result - digit;\n+            }\n+            if (inRange && i == endIndex && digit >= 0) {\n+                return firstChar != '-' ? -result : result;\n@@ -709,3 +692,0 @@\n-            return negative ? result : -result;\n-        } else {\n-            throw new NumberFormatException(\"\");\n@@ -713,0 +693,2 @@\n+        throw NumberFormatException.forCharSequence(s, beginIndex,\n+            endIndex, i - (digit < -1 ? 0 : 1));\n@@ -792,12 +774,4 @@\n-        int len = s.length();\n-        if (len > 0) {\n-            char firstChar = s.charAt(0);\n-            if (firstChar == '-') {\n-                throw new\n-                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n-                                                       \"on unsigned string %s.\", s));\n-            } else {\n-                if (len <= 12 || \/\/ Long.MAX_VALUE in Character.MAX_RADIX is 13 digits\n-                    (radix == 10 && len <= 18) ) { \/\/ Long.MAX_VALUE in base 10 is 19 digits\n-                    return parseLong(s, radix);\n-                }\n+        if (radix < Character.MIN_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n+        }\n@@ -805,63 +779,29 @@\n-                \/\/ No need for range checks on len due to testing above.\n-                long first = parseLong(s, 0, len - 1, radix);\n-                int second = Character.digit(s.charAt(len - 1), radix);\n-                if (second < 0) {\n-                    throw new NumberFormatException(\"Bad digit at end of \" + s);\n-                }\n-                long result = first * radix + second;\n-\n-                \/*\n-                 * Test leftmost bits of multiprecision extension of first*radix\n-                 * for overflow. The number of bits needed is defined by\n-                 * GUARD_BIT = ceil(log2(Character.MAX_RADIX)) + 1 = 7. Then\n-                 * int guard = radix*(int)(first >>> (64 - GUARD_BIT)) and\n-                 * overflow is tested by splitting guard in the ranges\n-                 * guard < 92, 92 <= guard < 128, and 128 <= guard, where\n-                 * 92 = 128 - Character.MAX_RADIX. Note that guard cannot take\n-                 * on a value which does not include a prime factor in the legal\n-                 * radix range.\n-                 *\/\n-                int guard = radix * (int) (first >>> 57);\n-                if (guard >= 128 ||\n-                    (result >= 0 && guard >= 128 - Character.MAX_RADIX)) {\n-                    \/*\n-                     * For purposes of exposition, the programmatic statements\n-                     * below should be taken to be multi-precision, i.e., not\n-                     * subject to overflow.\n-                     *\n-                     * A) Condition guard >= 128:\n-                     * If guard >= 128 then first*radix >= 2^7 * 2^57 = 2^64\n-                     * hence always overflow.\n-                     *\n-                     * B) Condition guard < 92:\n-                     * Define left7 = first >>> 57.\n-                     * Given first = (left7 * 2^57) + (first & (2^57 - 1)) then\n-                     * result <= (radix*left7)*2^57 + radix*(2^57 - 1) + second.\n-                     * Thus if radix*left7 < 92, radix <= 36, and second < 36,\n-                     * then result < 92*2^57 + 36*(2^57 - 1) + 36 = 2^64 hence\n-                     * never overflow.\n-                     *\n-                     * C) Condition 92 <= guard < 128:\n-                     * first*radix + second >= radix*left7*2^57 + second\n-                     * so that first*radix + second >= 92*2^57 + 0 > 2^63\n-                     *\n-                     * D) Condition guard < 128:\n-                     * radix*first <= (radix*left7) * 2^57 + radix*(2^57 - 1)\n-                     * so\n-                     * radix*first + second <= (radix*left7) * 2^57 + radix*(2^57 - 1) + 36\n-                     * thus\n-                     * radix*first + second < 128 * 2^57 + 36*2^57 - radix + 36\n-                     * whence\n-                     * radix*first + second < 2^64 + 2^6*2^57 = 2^64 + 2^63\n-                     *\n-                     * E) Conditions C, D, and result >= 0:\n-                     * C and D combined imply the mathematical result\n-                     * 2^63 < first*radix + second < 2^64 + 2^63. The lower\n-                     * bound is therefore negative as a signed long, but the\n-                     * upper bound is too small to overflow again after the\n-                     * signed long overflows to positive above 2^64 - 1. Hence\n-                     * result >= 0 implies overflow given C and D.\n-                     *\/\n-                    throw new NumberFormatException(String.format(\"String value %s exceeds \" +\n-                                                                  \"range of unsigned long.\", s));\n-                }\n+        if (radix > Character.MAX_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        }\n+\n+        int len = s.length();\n+        if (len == 0) {\n+            throw NumberFormatException.forInputString(s, radix);\n+        }\n+        int i = 0;\n+        char firstChar = s.charAt(i++);\n+        if (firstChar == '-') {\n+            throw new NumberFormatException(String.format(\n+                \"Illegal leading minus sign on unsigned string %s.\", s));\n+        }\n+        int digit = ~0xFF;\n+        if (firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && len > 1) {\n+            long multmax = divideUnsigned(-1L, radix);  \/\/ -1L is max unsigned long\n+            long result = digit & 0xFF;\n+            boolean inRange = true;\n+            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = compareUnsigned(result, multmax) < 0\n+                        || result == multmax && digit < (int) (-radix * multmax))) {\n+                result = radix * result + digit;\n+            }\n+            if (inRange && i == len && digit >= 0) {\n@@ -870,1 +810,2 @@\n-        } else {\n+        }\n+        if (digit < 0) {\n@@ -873,0 +814,2 @@\n+        throw new NumberFormatException(String.format(\n+            \"String value %s exceeds range of unsigned long.\", s));\n@@ -907,12 +850,4 @@\n-        int start = beginIndex, len = endIndex - beginIndex;\n-\n-        if (len > 0) {\n-            char firstChar = s.charAt(start);\n-            if (firstChar == '-') {\n-                throw new NumberFormatException(String.format(\"Illegal leading minus sign \" +\n-                        \"on unsigned string %s.\", s.subSequence(start, start + len)));\n-            } else {\n-                if (len <= 12 || \/\/ Long.MAX_VALUE in Character.MAX_RADIX is 13 digits\n-                    (radix == 10 && len <= 18) ) { \/\/ Long.MAX_VALUE in base 10 is 19 digits\n-                    return parseLong(s, start, start + len, radix);\n-                }\n+        if (radix < Character.MIN_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s less than Character.MIN_RADIX\", radix));\n+        }\n@@ -920,64 +855,34 @@\n-                \/\/ No need for range checks on end due to testing above.\n-                long first = parseLong(s, start, start + len - 1, radix);\n-                int second = Character.digit(s.charAt(start + len - 1), radix);\n-                if (second < 0) {\n-                    throw new NumberFormatException(\"Bad digit at end of \" +\n-                            s.subSequence(start, start + len));\n-                }\n-                long result = first * radix + second;\n-\n-                \/*\n-                 * Test leftmost bits of multiprecision extension of first*radix\n-                 * for overflow. The number of bits needed is defined by\n-                 * GUARD_BIT = ceil(log2(Character.MAX_RADIX)) + 1 = 7. Then\n-                 * int guard = radix*(int)(first >>> (64 - GUARD_BIT)) and\n-                 * overflow is tested by splitting guard in the ranges\n-                 * guard < 92, 92 <= guard < 128, and 128 <= guard, where\n-                 * 92 = 128 - Character.MAX_RADIX. Note that guard cannot take\n-                 * on a value which does not include a prime factor in the legal\n-                 * radix range.\n-                 *\/\n-                int guard = radix * (int) (first >>> 57);\n-                if (guard >= 128 ||\n-                        (result >= 0 && guard >= 128 - Character.MAX_RADIX)) {\n-                    \/*\n-                     * For purposes of exposition, the programmatic statements\n-                     * below should be taken to be multi-precision, i.e., not\n-                     * subject to overflow.\n-                     *\n-                     * A) Condition guard >= 128:\n-                     * If guard >= 128 then first*radix >= 2^7 * 2^57 = 2^64\n-                     * hence always overflow.\n-                     *\n-                     * B) Condition guard < 92:\n-                     * Define left7 = first >>> 57.\n-                     * Given first = (left7 * 2^57) + (first & (2^57 - 1)) then\n-                     * result <= (radix*left7)*2^57 + radix*(2^57 - 1) + second.\n-                     * Thus if radix*left7 < 92, radix <= 36, and second < 36,\n-                     * then result < 92*2^57 + 36*(2^57 - 1) + 36 = 2^64 hence\n-                     * never overflow.\n-                     *\n-                     * C) Condition 92 <= guard < 128:\n-                     * first*radix + second >= radix*left7*2^57 + second\n-                     * so that first*radix + second >= 92*2^57 + 0 > 2^63\n-                     *\n-                     * D) Condition guard < 128:\n-                     * radix*first <= (radix*left7) * 2^57 + radix*(2^57 - 1)\n-                     * so\n-                     * radix*first + second <= (radix*left7) * 2^57 + radix*(2^57 - 1) + 36\n-                     * thus\n-                     * radix*first + second < 128 * 2^57 + 36*2^57 - radix + 36\n-                     * whence\n-                     * radix*first + second < 2^64 + 2^6*2^57 = 2^64 + 2^63\n-                     *\n-                     * E) Conditions C, D, and result >= 0:\n-                     * C and D combined imply the mathematical result\n-                     * 2^63 < first*radix + second < 2^64 + 2^63. The lower\n-                     * bound is therefore negative as a signed long, but the\n-                     * upper bound is too small to overflow again after the\n-                     * signed long overflows to positive above 2^64 - 1. Hence\n-                     * result >= 0 implies overflow given C and D.\n-                     *\/\n-                    throw new NumberFormatException(String.format(\"String value %s exceeds \" +\n-                            \"range of unsigned long.\", s.subSequence(start, start + len)));\n-                }\n+        if (radix > Character.MAX_RADIX) {\n+            throw new NumberFormatException(String.format(\n+                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        }\n+\n+        \/*\n+         * While s can be concurrently modified, it is ensured that each\n+         * of its characters is read at most once, from lower to higher indices.\n+         * This is obtained by reading them using the pattern s.charAt(i++),\n+         * and by not updating i anywhere else.\n+         *\/\n+        if (beginIndex == endIndex) {\n+            throw new NumberFormatException(\"\");\n+        }\n+        int i = beginIndex;\n+        char firstChar = s.charAt(i++);\n+        if (firstChar == '-') {\n+            throw new NumberFormatException(\n+                \"Illegal leading minus sign on unsigned string \" + s + \".\");\n+        }\n+        int digit = ~0xFF;\n+        if (firstChar != '+') {\n+            digit = digit(firstChar, radix);\n+        }\n+        if (digit >= 0 || digit == ~0xFF && endIndex - beginIndex > 1) {\n+            long multmax = divideUnsigned(-1L, radix);  \/\/ -1L is max unsigned long\n+            long result = digit & 0xFF;\n+            boolean inRange = true;\n+            while (i < endIndex && (digit = digit(s.charAt(i++), radix)) >= 0\n+                    && (inRange = compareUnsigned(result, multmax) < 0\n+                        || result == multmax && digit < (int) (-radix * multmax))) {\n+                result = radix * result + digit;\n+            }\n+            if (inRange && i == endIndex && digit >= 0) {\n@@ -986,2 +891,0 @@\n-        } else {\n-            throw NumberFormatException.forInputString(\"\", radix);\n@@ -989,0 +892,6 @@\n+        if (digit < 0) {\n+            throw NumberFormatException.forCharSequence(s, beginIndex,\n+                endIndex, i - (digit < -1 ? 0 : 1));\n+        }\n+        throw new NumberFormatException(String.format(\n+            \"String value %s exceeds range of unsigned long.\", s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":145,"deletions":236,"binary":false,"changes":381,"status":"modified"}]}