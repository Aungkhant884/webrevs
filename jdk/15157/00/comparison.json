{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.HashMap;\n@@ -29,0 +30,1 @@\n+import java.util.Map;\n@@ -70,0 +72,166 @@\n+    \/**Call {@link #of(String, String)} to calculate the distance.\n+     *\/\n+    public static final class DamerauLevenshteinDistance {\n+\n+        \/*\n+         * This is a Java implementation of the algorithm from \"An Extension of\n+         * the String-to-String Correction Problem\" by R. Lowrance and\n+         * R. A. Wagner (https:\/\/dl.acm.org\/doi\/10.1145\/321879.321880).\n+         * That algorithm is O(|a|*|b|) in both space and time.\n+         *\n+         * This implementation encapsulates arrays and (most of) strings behind\n+         * methods to accommodate for algorithm indexing schemes which are -1,\n+         * 0, and 1 based and to offset memory and performance overhead if any\n+         * strings in the pair contain non-ASCII symbols.\n+         *\/\n+\n+        private final int INF;\n+        private final int[][] h;\n+        private final String a;\n+        private final String b;\n+\n+        private static final int Wi = 1; \/\/ insert\n+        private static final int Wd = 1; \/\/ delete\n+        private static final int Wc = 1; \/\/ change\n+        private static final int Ws = 1; \/\/ interchange\n+\n+        static {\n+            assert 2L * Ws >= Wi + Wd; \/\/ algorithm requirement\n+        }\n+\n+        private int[] smallDA;\n+        private Map<Character, Integer> bigDA;\n+\n+        \/** {@return the edit distance between two strings}\n+         * The distance returned from this method has the following properties:\n+         * <ol>\n+         *     <li> {@code a.equals(b) && of(a, b) == 0) || (!a.equals(b) && of(a, b) > 0)}\n+         *     <li> {@code of(a, b) == of(b, a)}\n+         *     <li> {@code of(a, b) + of(b, c) >= of(a, c)}\n+         * <\/ol>\n+         *\n+         * @implSpec\n+         * This method is safe to be called by multiple threads.\n+         * @throws NullPointerException if any of the two strings are null\n+         * @throws ArithmeticException if any step of the calculation\n+         *                             overflows an int\n+         *\/\n+        public static int of(String a, String b) {\n+            return new DamerauLevenshteinDistance(a, b).calculate();\n+        }\n+\n+        private int calculate() {\n+            for (int i = 0; i <= a.length(); i++) {\n+                h(i, 0, i * Wd);\n+                h(i, -1, INF);\n+            }\n+            for (int j = 0; j <= b.length(); j++) {\n+                h(0, j, j * Wi);\n+                h(-1, j, INF);\n+            }\n+            \/\/ algorithm's line #8 that initializes DA is not needed here\n+            \/\/ because this class encapsulates DA and initializes it\n+            \/\/ separately\n+            for (int i = 1; i <= a.length(); i++) {\n+                int db = 0;\n+                for (int j = 1; j <= b.length(); j++) {\n+                    int i1 = da(characterAt(b, j));\n+                    int j1 = db;\n+                    boolean eq = characterAt(a, i) == characterAt(b, j);\n+                    int d = eq ? 0 : Wc;\n+                    if (eq) {\n+                        db = j;\n+                    }\n+                    int m = min(h(i - 1, j - 1) + d,\n+                            h(i, j - 1) + Wi,\n+                            h(i - 1, j) + Wd,\n+                            h(i1 - 1, j1 - 1) + (i - i1 - 1) * Wd + Ws + (j - j1 - 1) * Wi);\n+                    h(i, j, m);\n+                }\n+                da(characterAt(a, i), i);\n+            }\n+            return h(a.length(), b.length());\n+        }\n+\n+        private int characterAt(String s, int i) {\n+            return s.charAt(i - 1);\n+        }\n+\n+        private void h(int i, int j, int value) {\n+            h[i + 1][j + 1] = value;\n+        }\n+\n+        private int h(int i, int j) {\n+            return h[i + 1][j + 1];\n+        }\n+\n+        \/*\n+         * This implementation works with UTF-16 strings, but favours strings\n+         * that comprise ASCII characters. Measuring distance between a pair\n+         * of ASCII strings is likely to be a typical use case for this\n+         * implementation.\n+         *\n+         * If a character for which the value is to be stored does not fit into\n+         * the ASCII range, this implementation switches to a different storage\n+         * dynamically. Since neither string lengths nor character values\n+         * change, any state accumulated so far, including any loops and local\n+         * variables, remains valid.\n+         *\n+         * Note, that if the provided character were a surrogate and this\n+         * implementation dealt with code points, which it does not, dynamic\n+         * switching of the storage would not be enough. The complete\n+         * representation would need to be changed. That would entail\n+         * discarding any accumulated state and repeating the computation.\n+         *\/\n+\n+        private int da(int i) {\n+            if (smallDA != null && i < '\\u0080') {\n+                return smallDA[i];\n+            }\n+            \/\/ if a character cannot be found, it means that the character\n+            \/\/ hasn't been updated, which means that the associated value\n+            \/\/ is the default value, which is 0\n+            if (bigDA != null) {\n+                Integer v = bigDA.get((char) i);\n+                return v == null ? 0 : v;\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        private void da(int i, int value) {\n+            if (bigDA == null && i < '\\u0080') {\n+                if (smallDA == null) {\n+                    smallDA = new int[127];\n+                }\n+                smallDA[i] = value;\n+            } else {\n+                if (bigDA == null) {\n+                    bigDA = new HashMap<>();\n+                    if (smallDA != null) { \/\/ rebuild DA accumulated so far\n+                        for (int j = 0; j < smallDA.length; j++) {\n+                            int v = smallDA[j];\n+                            if (v != 0)\n+                                bigDA.put((char) j, v);\n+                        }\n+                        smallDA = null; \/\/ no longer needed\n+                    }\n+                }\n+                bigDA.put((char) i, value);\n+            }\n+            assert smallDA == null ^ bigDA == null; \/\/ at most one in use\n+        }\n+\n+        private static int min(int a, int b, int c, int d) {\n+            return Math.min(a, Math.min(b, Math.min(c, d)));\n+        }\n+\n+        private DamerauLevenshteinDistance(String a, String b) {\n+            this.a = a;\n+            this.b = b;\n+            this.h = new int[this.a.length() + 2][this.b.length() + 2];\n+            INF = this.a.length() * Wd + this.b.length() * Wi + 1;\n+            if (INF < 0)\n+                throw new ArithmeticException(\"Overflow\");\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/StringUtils.java","additions":169,"deletions":1,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8029800 8043186\n+ * @bug 8029800 8043186 8313693\n@@ -32,0 +32,1 @@\n+import java.util.List;\n@@ -35,0 +36,1 @@\n+import com.sun.tools.javac.util.StringUtils.DamerauLevenshteinDistance;\n@@ -56,0 +58,51 @@\n+\n+        \/\/verify Damerau-Levenshtein\n+\n+        assertEquals(3, DamerauLevenshteinDistance.of(\"kitten\", \"sitting\"));\n+        \/\/ note that the unrestricted Damerau-Levenshtein distance would be 3, not 2:\n+        assertEquals(2, DamerauLevenshteinDistance.of(\"ca\", \"abc\"));\n+        \/\/verify strings comprising only non-LATIN1 characters\n+        assertEquals(1, DamerauLevenshteinDistance.of(\"\\u0438\\u044e\\u043d\\u044c\",\n+                \"\\u0438\\u044e\\u043b\\u044c\"));\n+        \/\/verify strings comprising mixed characters: non-LATIN1 and ASCII\n+        \/\/ it's important to start with ASCII characters, so that we\n+        \/\/ test switching a storage (see current implementation)\n+        assertEquals(2, DamerauLevenshteinDistance.of(\"c\\u043ede\", \"cod\\u0435\"));\n+\n+        \/\/verify metric properties\n+        for (String a : List.of(\"\", \"a\", \"b\", \"abc\")) {\n+            for (String b : List.of(\"\", \"a\", \"b\", \"abc\")) {\n+                assertNonNegativity(a, b);\n+                assertSymmetry(a, b);\n+            }\n+        }\n+\n+        for (String a : List.of(\"\", \"a\", \"b\", \"c\")) {\n+            for (String b : List.of(\"ab\", \"ac\", \"bc\")) {\n+                for (String c : List.of(\"abc\", \"bca\", \"cab\")) {\n+                    assertTriangleInequality(a, b, c);\n+                    assertTriangleInequality(b, c, a);\n+                    assertTriangleInequality(c, a, b);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void assertNonNegativity(String a, String b) {\n+        if (a.equals(b)) {\n+            assertEquals(0, DamerauLevenshteinDistance.of(a, b));\n+        } else {\n+            assertTrue(DamerauLevenshteinDistance.of(a, b) > 0);\n+        }\n+    }\n+\n+    private void assertSymmetry(String a, String b) {\n+        assertEquals(DamerauLevenshteinDistance.of(a, b),\n+                DamerauLevenshteinDistance.of(b, a));\n+    }\n+\n+    private void assertTriangleInequality(String a, String b, String c) {\n+        int ab = DamerauLevenshteinDistance.of(a, b);\n+        int bc = DamerauLevenshteinDistance.of(b, c);\n+        int ac = DamerauLevenshteinDistance.of(a, c);\n+        assertTrue(ab + bc >= ac);\n@@ -69,0 +122,6 @@\n+\n+    void assertTrue(boolean cond) {\n+        if (!cond) {\n+            throw new IllegalStateException();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/util\/StringUtilsTest.java","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"}]}