{"files":[{"patch":"@@ -41,1 +41,1 @@\n- * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 64 bits).\n+ * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 8 bytes).\n@@ -77,1 +77,1 @@\n-    AddressLayout withBitAlignment(long bitAlignment);\n+    AddressLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is less than {@code M}, where {@code M} is the maximum alignment\n+     * @throws IllegalArgumentException if {@code byteAlignment} is less than {@code M}, where {@code M} is the maximum alignment\n@@ -75,1 +75,1 @@\n-    GroupLayout withBitAlignment(long bitAlignment);\n+    GroupLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- *         MemoryLayout.paddingLayout(24),\n+ *         MemoryLayout.paddingLayout(3),\n@@ -87,1 +87,1 @@\n- * always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed\n+ * always has the same size in bytes, regardless of the platform in which it is used. For derived layouts, the size is computed\n@@ -107,1 +107,1 @@\n- * A layout's natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe\n+ * A layout's natural alignment can be overridden if needed (see {@link MemoryLayout#withByteAlignment(long)}), which can be useful to describe\n@@ -118,1 +118,1 @@\n- * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#bitOffset(PathElement...) offsets} of\n+ * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#byteOffset(PathElement...) offsets} of\n@@ -125,1 +125,1 @@\n- * in bits, of the member layout named <code>value<\/code> in the <em>first<\/em> sequence element, as follows:\n+ * in bytes, of the member layout named <code>value<\/code> in the <em>first<\/em> sequence element, as follows:\n@@ -127,2 +127,2 @@\n- * long valueOffset = taggedValues.bitOffset(PathElement.sequenceElement(0),\n- *                                           PathElement.groupElement(\"value\")); \/\/ yields 32\n+ * long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+ *                                           PathElement.groupElement(\"value\")); \/\/ yields 4\n@@ -154,1 +154,1 @@\n- * {@link #bitOffset(PathElement...)} or {@link #byteOffsetHandle(PathElement...)} method. Again, free dimensions are\n+ * {@link #byteOffset(PathElement...)} or {@link #byteOffsetHandle(PathElement...)} method. Again, free dimensions are\n@@ -175,5 +175,0 @@\n-    \/**\n-     * {@return the layout size, in bits}\n-     *\/\n-    long bitSize();\n-\n@@ -182,1 +177,0 @@\n-     * @throws UnsupportedOperationException if {@code bitSize()} is not a multiple of 8.\n@@ -213,18 +207,0 @@\n-    \/**\n-     * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power\n-     * of two {@code A} which is the bit-wise alignment of the layout. If {@code A <= 8} then {@code A\/8} is the number of\n-     * bytes that must be aligned for any pointer that correctly points to this layout. Thus:\n-     *\n-     * <ul>\n-     * <li>{@code A=8} means unaligned (in the usual sense), which is common in packets.<\/li>\n-     * <li>{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.<\/li>\n-     * <li>{@code A=512} is the most strict alignment required by the x86\/SV ABI (for AVX-512 data).<\/li>\n-     * <\/ul>\n-     *\n-     * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),\n-     * then this method returns the <a href=\"#layout-align\">natural alignment<\/a> constraint (in bits) associated with this layout.\n-     *\n-     * @return the layout alignment constraint, in bits.\n-     *\/\n-    long bitAlignment();\n-\n@@ -242,1 +218,1 @@\n-     * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),\n+     * If no explicit alignment constraint was set on this layout (see {@link #withByteAlignment(long)}),\n@@ -246,1 +222,0 @@\n-     * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.\n@@ -250,0 +225,1 @@\n+\n@@ -252,1 +228,1 @@\n-     * but with the specified alignment constraint (in bits).\n+     * but with the specified alignment constraint (in bytes).\n@@ -254,1 +230,1 @@\n-     * @param bitAlignment the layout alignment constraint, expressed in bits.\n+     * @param byteAlignment the layout alignment constraint, expressed in bytes.\n@@ -256,1 +232,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than 8.\n+     * @throws IllegalArgumentException if {@code byteAlignment} is not a power of two, or if it's less than 1.\n@@ -258,1 +234,1 @@\n-    MemoryLayout withBitAlignment(long bitAlignment);\n+    MemoryLayout withByteAlignment(long byteAlignment);\n@@ -260,52 +236,0 @@\n-    \/**\n-     * Computes the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this\n-     * layout.\n-     *\n-     * @param elements the layout path elements.\n-     * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.\n-     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the\n-     * layout path contains one or more path elements that select multiple sequence element indices\n-     * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n-     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n-     * in {@code elements} is {@code null}.\n-     *\/\n-    default long bitOffset(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n-    }\n-\n-    \/**\n-     * Creates a method handle that can be used to compute the offset, in bits, of the layout selected\n-     * by the given layout path, where the path is considered rooted in this layout.\n-     *\n-     * <p>The returned method handle has a return type of {@code long}, and features as many {@code long}\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n-     * where the order of the parameters corresponds to the order of the path elements.\n-     * The returned method handle can be used to compute a layout offset similar to {@link #bitOffset(PathElement...)},\n-     * but where some sequence indices are specified only when invoking the method handle.\n-     *\n-     * <p>The final offset returned by the method handle is computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n-     *\n-     * @param elements the layout path elements.\n-     * @return a method handle that can be used to compute the bit offset of the layout element\n-     * specified by the given layout path elements, when supplied with the missing sequence element indices.\n-     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n-     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n-     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n-     * (see {@link PathElement#dereferenceElement()}).\n-     *\/\n-    default MethodHandle bitOffsetHandle(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n-                EnumSet.of(PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n-    }\n@@ -324,1 +248,0 @@\n-     * @throws UnsupportedOperationException if {@code bitOffset(elements)} is not a multiple of 8.\n@@ -329,1 +252,2 @@\n-        return Utils.bitsToBytes(bitOffset(elements));\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -345,2 +269,1 @@\n-     * bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * offset = bitOffset \/ 8\n+     * byteOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -354,3 +277,0 @@\n-     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n-     * offset in bits is not a multiple of 8.\n-     *\n@@ -366,3 +286,2 @@\n-        MethodHandle mh = bitOffsetHandle(elements);\n-        mh = MethodHandles.filterReturnValue(mh, Utils.BITS_TO_BYTES);\n-        return mh;\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n+                EnumSet.of(PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -451,2 +370,1 @@\n-     * bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * offset = bitOffset \/ 8\n+     * byteOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -468,3 +386,0 @@\n-     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n-     * offset in bits is not a multiple of 8.\n-     *\n@@ -473,1 +388,0 @@\n-     * @throws UnsupportedOperationException if the size of the selected layout in bits is not a multiple of 8.\n@@ -690,1 +604,1 @@\n-     * Creates a padding layout with the given bitSize and a bit-alignment of eight.\n+     * Creates a padding layout with the given byte size and a byte-alignment of one.\n@@ -692,1 +606,1 @@\n-     * @param bitSize the padding size in bits.\n+     * @param byteSize the padding size (expressed in bytes).\n@@ -694,1 +608,1 @@\n-     * @throws IllegalArgumentException if {@code bitSize <= 0} or {@code bitSize % 8 != 0}\n+     * @throws IllegalArgumentException if {@code byteSize <= 0}.\n@@ -696,2 +610,2 @@\n-    static PaddingLayout paddingLayout(long bitSize) {\n-        return PaddingLayoutImpl.of(MemoryLayoutUtil.requireBitSizeValid(bitSize, false));\n+    static PaddingLayout paddingLayout(long byteSize) {\n+        return PaddingLayoutImpl.of(MemoryLayoutUtil.requireByteSizeValid(byteSize, false));\n@@ -707,1 +621,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n@@ -723,1 +637,1 @@\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n@@ -728,1 +642,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n@@ -732,1 +646,1 @@\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n@@ -740,1 +654,1 @@\n-     * @throws IllegalArgumentException if the sum of the {@linkplain #bitSize() bit sizes} of the member layouts\n+     * @throws IllegalArgumentException if the sum of the {@linkplain #byteSize() byte sizes} of the member layouts\n@@ -755,1 +669,1 @@\n-     * structLayout(JAVA_SHORT, MemoryLayout.ofPadding(16), JAVA_INT)\n+     * structLayout(JAVA_SHORT, MemoryLayout.ofPadding(2), JAVA_INT)\n@@ -762,1 +676,1 @@\n-     * structLayout(JAVA_SHORT, JAVA_INT.withBitAlignment(16))\n+     * structLayout(JAVA_SHORT, JAVA_INT.withByteAlignment(2))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":32,"deletions":118,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n- * to be read. For instance on a 64-bit platform, the size of an address layout is 64 bits. The access operation\n+ * to be read. For instance on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n@@ -464,1 +464,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n@@ -481,1 +481,1 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() % elementLayout.bitAlignment() != 0}.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,2 +59,1 @@\n-    @Override\n-    PaddingLayout withBitAlignment(long bitAlignment);\n+    PaddingLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment < elementLayout().bitAlignment()}.\n+     * @throws IllegalArgumentException if {@code byteAlignment < elementLayout().byteAlignment()}.\n@@ -148,1 +148,1 @@\n-    SequenceLayout withBitAlignment(long bitAlignment);\n+    SequenceLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    StructLayout withBitAlignment(long bitAlignment);\n+    StructLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    UnionLayout withBitAlignment(long bitAlignment);\n+    UnionLayout withByteAlignment(long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * Each value layout has a size, an alignment (in bits),\n+ * Each value layout has a size, an alignment (both expressed in bytes),\n@@ -132,1 +132,1 @@\n-     * @throws UnsupportedOperationException if {@code bitAlignment() > bitSize()}.\n+     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n@@ -155,1 +155,1 @@\n-    ValueLayout withBitAlignment(long bitAlignment);\n+    ValueLayout withByteAlignment(long byteAlignment);\n@@ -183,1 +183,1 @@\n-        OfBoolean withBitAlignment(long bitAlignment);\n+        OfBoolean withByteAlignment(long byteAlignment);\n@@ -219,1 +219,1 @@\n-        OfByte withBitAlignment(long bitAlignment);\n+        OfByte withByteAlignment(long byteAlignment);\n@@ -256,1 +256,1 @@\n-        OfChar withBitAlignment(long bitAlignment);\n+        OfChar withByteAlignment(long byteAlignment);\n@@ -293,1 +293,1 @@\n-        OfShort withBitAlignment(long bitAlignment);\n+        OfShort withByteAlignment(long byteAlignment);\n@@ -330,1 +330,1 @@\n-        OfInt withBitAlignment(long bitAlignment);\n+        OfInt withByteAlignment(long byteAlignment);\n@@ -366,1 +366,1 @@\n-        OfFloat withBitAlignment(long bitAlignment);\n+        OfFloat withByteAlignment(long byteAlignment);\n@@ -403,1 +403,1 @@\n-        OfLong withBitAlignment(long bitAlignment);\n+        OfLong withByteAlignment(long byteAlignment);\n@@ -440,1 +440,1 @@\n-        OfDouble withBitAlignment(long bitAlignment);\n+        OfDouble withByteAlignment(long byteAlignment);\n@@ -452,1 +452,1 @@\n-     * bit alignment set to {@code sizeof(size_t) * 8}, byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to {@code sizeof(size_t)}, byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -458,1 +458,1 @@\n-     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 1, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -464,1 +464,1 @@\n-     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 1, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -470,1 +470,1 @@\n-     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 2, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -476,1 +476,1 @@\n-     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 2, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -482,1 +482,1 @@\n-     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 4, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -488,1 +488,1 @@\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -494,1 +494,1 @@\n-     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 4, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -500,1 +500,1 @@\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * byte alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -509,1 +509,1 @@\n-     * ADDRESS.withBitAlignment(8);\n+     * ADDRESS.withByteAlignment(1);\n@@ -514,1 +514,1 @@\n-    AddressLayout ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+    AddressLayout ADDRESS_UNALIGNED = ADDRESS.withByteAlignment(1);\n@@ -521,1 +521,1 @@\n-     * JAVA_CHAR.withBitAlignment(8);\n+     * JAVA_CHAR.withByteAlignment(1);\n@@ -526,1 +526,1 @@\n-    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withByteAlignment(1);\n@@ -533,1 +533,1 @@\n-     * JAVA_SHORT.withBitAlignment(8);\n+     * JAVA_SHORT.withByteAlignment(1);\n@@ -538,1 +538,1 @@\n-    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withByteAlignment(1);\n@@ -545,1 +545,1 @@\n-     * JAVA_INT.withBitAlignment(8);\n+     * JAVA_INT.withByteAlignment(1);\n@@ -550,1 +550,1 @@\n-    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withByteAlignment(1);\n@@ -557,1 +557,1 @@\n-     * JAVA_LONG.withBitAlignment(8);\n+     * JAVA_LONG.withByteAlignment(1);\n@@ -562,1 +562,1 @@\n-    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withByteAlignment(1);\n@@ -569,1 +569,1 @@\n-     * JAVA_FLOAT.withBitAlignment(8);\n+     * JAVA_FLOAT.withByteAlignment(1);\n@@ -574,1 +574,1 @@\n-    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withByteAlignment(1);\n@@ -581,1 +581,1 @@\n-     * JAVA_DOUBLE.withBitAlignment(8);\n+     * JAVA_DOUBLE.withByteAlignment(1);\n@@ -586,1 +586,1 @@\n-    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n+    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withByteAlignment(1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -7967,1 +7967,1 @@\n-     *             MemoryLayout.paddingLayout(32),\n+     *             MemoryLayout.paddingLayout(4),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            long addressSize = ADDRESS.bitSize();\n+            long addressSize = ADDRESS.byteSize();\n@@ -60,1 +60,1 @@\n-            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 64) {\n+            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 8) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), derefAdapters, this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(elem.byteSize()), addBound(seq.elementCount()), derefAdapters, this);\n@@ -108,1 +108,1 @@\n-        long elemSize = elem.bitSize();\n+        long elemSize = elem.byteSize();\n@@ -121,1 +121,1 @@\n-        long elemSize = seq.elementLayout().bitSize();\n+        long elemSize = seq.elementLayout().byteSize();\n@@ -138,1 +138,1 @@\n-                offset += l.bitSize();\n+                offset += l.byteSize();\n@@ -159,1 +159,1 @@\n-                offset += elem.bitSize();\n+                offset += elem.byteSize();\n@@ -199,1 +199,1 @@\n-                    Utils.bitsToBytes(strides[i]),\n+                    strides[i],\n@@ -206,1 +206,1 @@\n-                Utils.bitsToBytes(offset));\n+                offset);\n@@ -235,2 +235,1 @@\n-        MethodHandle offsetHandle = offsetHandle(); \/\/ bit offset\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.BITS_TO_BYTES); \/\/ byte offset\n+        MethodHandle offsetHandle = offsetHandle(); \/\/ byte offset\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    \/\/ The maximum alignment supported by malloc - typically 16 on\n-    \/\/ 64-bit platforms and 8 on 32-bit platforms.\n+    \/\/ The maximum alignment supported by malloc - typically 16 bytes on\n+    \/\/ 64-bit platforms and 8 bytes on 32-bit platforms.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-    public static final MethodHandle BITS_TO_BYTES;\n@@ -79,2 +78,0 @@\n-            BITS_TO_BYTES = lookup.findStatic(Utils.class, \"bitsToBytes\",\n-                    MethodType.methodType(long.class, long.class));\n@@ -95,5 +92,0 @@\n-    public static long bitsToBytes(long bits) {\n-        assert Utils.isAligned(bits, 8);\n-        return bits \/ Byte.SIZE;\n-    }\n-\n@@ -180,1 +172,1 @@\n-        assert isPowerOfTwo(layout.bitSize());\n+        assert isPowerOfTwo(layout.byteSize());\n@@ -239,1 +231,1 @@\n-            long padding = computePadding(offset, l.bitAlignment());\n+            long padding = computePadding(offset, l.byteAlignment());\n@@ -245,2 +237,2 @@\n-            align = Math.max(align, l.bitAlignment());\n-            offset += l.bitSize();\n+            align = Math.max(align, l.byteAlignment());\n+            offset += l.byteSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-                offset += member.bitSize();\n+                offset += member.byteSize();\n@@ -174,1 +174,1 @@\n-                    maxUnpaddedLayout = Long.max(maxUnpaddedLayout, member.bitSize());\n+                    maxUnpaddedLayout = Long.max(maxUnpaddedLayout, member.byteSize());\n@@ -185,2 +185,2 @@\n-        long expectedSize = Utils.alignUp(maxUnpaddedOffset, gl.bitAlignment());\n-        if (gl.bitSize() != expectedSize) {\n+        long expectedSize = Utils.alignUp(maxUnpaddedOffset, gl.byteAlignment());\n+        if (gl.byteSize() != expectedSize) {\n@@ -188,1 +188,1 @@\n-                    + gl.bitSize() + \" != \" + expectedSize);\n+                    + gl.byteSize() + \" != \" + expectedSize);\n@@ -196,1 +196,1 @@\n-        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, memberLayout.bitAlignment());\n+        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, memberLayout.byteAlignment());\n@@ -205,1 +205,1 @@\n-            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \" + layout);\n+            throw new IllegalArgumentException(\"Layout alignment must be natural alignment: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-            .withBitAlignment(64)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n+        return type.byteSize() <= MAX_AGGREGATE_REGS_SIZE * 8;\n@@ -109,2 +109,2 @@\n-            if (elem.bitSize() != baseType.bitSize() ||\n-                    elem.bitAlignment() != baseType.bitAlignment() ||\n+            if (elem.byteSize() != baseType.byteSize() ||\n+                    elem.byteAlignment() != baseType.byteAlignment() ||\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.bitSize()) {\n-            case 64 -> JAVA_LONG;\n-            case 32 -> JAVA_INT;\n+    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n+            case 8 -> JAVA_LONG;\n+            case 4 -> JAVA_INT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n+        return type.byteSize() <= MAX_AGGREGATE_REGS_SIZE * 8;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.function.LongBinaryOperator;\n@@ -52,1 +51,1 @@\n-    final long minBitAlignment;\n+    final long minByteAlignment;\n@@ -54,2 +53,2 @@\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n-        super(bitSize, bitAlignment, name); \/\/ Subclassing creates toctou problems here\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long byteSize, long byteAlignment, long minByteAlignment, Optional<String> name) {\n+        super(byteSize, byteAlignment, name); \/\/ Subclassing creates toctou problems here\n@@ -58,1 +57,1 @@\n-        this.minBitAlignment = minBitAlignment;\n+        this.minByteAlignment = minByteAlignment;\n@@ -85,2 +84,2 @@\n-    public L withBitAlignment(long bitAlignment) {\n-        if (bitAlignment < minBitAlignment) {\n+    public L withByteAlignment(long byteAlignment) {\n+        if (byteAlignment < minByteAlignment) {\n@@ -89,1 +88,1 @@\n-        return super.withBitAlignment(bitAlignment);\n+        return super.withByteAlignment(byteAlignment);\n@@ -114,1 +113,1 @@\n-        return bitAlignment() == minBitAlignment;\n+        return byteAlignment() == minByteAlignment;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,3 +46,3 @@\n-    AbstractLayout(long bitSize, long bitAlignment, Optional<String> name) {\n-        this.byteSize = MemoryLayoutUtil.requireBitSizeValid(bitSize, true) \/ 8;\n-        this.byteAlignment = requirePowerOfTwoAndGreaterOrEqualToEight(bitAlignment) \/ 8;\n+    AbstractLayout(long byteSize, long byteAlignment, Optional<String> name) {\n+        this.byteSize = MemoryLayoutUtil.requireByteSizeValid(byteSize, true);\n+        this.byteAlignment = requirePowerOfTwoAndGreaterOrEqualToOne(byteAlignment);\n@@ -53,1 +53,1 @@\n-        return dup(bitAlignment(), Optional.of(name));\n+        return dup(byteAlignment(), Optional.of(name));\n@@ -57,1 +57,1 @@\n-        return dup(bitAlignment(), Optional.empty());\n+        return dup(byteAlignment(), Optional.empty());\n@@ -64,6 +64,2 @@\n-    public L withBitAlignment(long bitAlignment) {\n-        return dup(bitAlignment, name);\n-    }\n-\n-    public final long bitAlignment() {\n-        return byteAlignment * 8;\n+    public L withByteAlignment(long byteAlignment) {\n+        return dup(byteAlignment, name);\n@@ -80,4 +76,0 @@\n-    public final long bitSize() {\n-        return byteSize * 8;\n-    }\n-\n@@ -130,1 +122,1 @@\n-    abstract L dup(long bitAlignment, Optional<String> name);\n+    abstract L dup(long byteAlignment, Optional<String> name);\n@@ -137,1 +129,1 @@\n-            s = bitAlignment() + \"%\" + s;\n+            s = byteAlignment() + \"%\" + s;\n@@ -142,1 +134,1 @@\n-    private static long requirePowerOfTwoAndGreaterOrEqualToEight(long value) {\n+    private static long requirePowerOfTwoAndGreaterOrEqualToOne(long value) {\n@@ -144,1 +136,1 @@\n-                value < 8) { \/\/ value must be greater or equal to 8\n+                value < 1) { \/\/ value must be greater or equal to 1\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-    public static long requireBitSizeValid(long bitSize, boolean allowZero) {\n-        if ((bitSize == 0 && !allowZero) || bitSize < 0 || bitSize % 8 != 0) {\n-            throw new IllegalArgumentException(\"Invalid bitSize: \" + bitSize);\n+    public static long requireByteSizeValid(long byteSize, boolean allowZero) {\n+        if ((byteSize == 0 && !allowZero) || byteSize < 0) {\n+            throw new IllegalArgumentException(\"Invalid byte size: \" + byteSize);\n@@ -44,1 +44,1 @@\n-        return bitSize;\n+        return byteSize;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private PaddingLayoutImpl(long bitSize) {\n-        this(bitSize, 8, Optional.empty());\n+    private PaddingLayoutImpl(long byteSize) {\n+        this(byteSize, 1, Optional.empty());\n@@ -38,2 +38,2 @@\n-    private PaddingLayoutImpl(long bitSize, long bitAlignment, Optional<String> name) {\n-        super(bitSize, bitAlignment, name);\n+    private PaddingLayoutImpl(long byteSize, long byteAlignment, Optional<String> name) {\n+        super(byteSize, byteAlignment, name);\n@@ -44,1 +44,1 @@\n-        return decorateLayoutString(\"x\" + bitSize());\n+        return decorateLayoutString(\"x\" + byteSize());\n@@ -52,1 +52,1 @@\n-                bitSize() == otherPadding.bitSize();\n+                byteSize() == otherPadding.byteSize();\n@@ -57,1 +57,1 @@\n-        return Objects.hash(super.hashCode(), bitSize());\n+        return Objects.hash(super.hashCode(), byteSize());\n@@ -61,2 +61,2 @@\n-    PaddingLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new PaddingLayoutImpl(bitSize(), bitAlignment, name);\n+    PaddingLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new PaddingLayoutImpl(byteSize(), byteAlignment, name);\n@@ -70,2 +70,2 @@\n-    public static PaddingLayout of(long bitSize) {\n-        return new PaddingLayoutImpl(bitSize);\n+    public static PaddingLayout of(long byteSize) {\n+        return new PaddingLayoutImpl(byteSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n+        this(elemCount, elementLayout, elementLayout.byteAlignment(), Optional.empty());\n@@ -42,2 +42,2 @@\n-    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long bitAlignment, Optional<String> name) {\n-        super(Math.multiplyExact(elemCount, elementLayout.bitSize()), bitAlignment, name);\n+    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long byteAlignment, Optional<String> name) {\n+        super(Math.multiplyExact(elemCount, elementLayout.byteSize()), byteAlignment, name);\n@@ -71,1 +71,1 @@\n-        return new SequenceLayoutImpl(elementCount, elementLayout, bitAlignment(), name());\n+        return new SequenceLayoutImpl(elementCount, elementLayout, byteAlignment(), name());\n@@ -179,1 +179,1 @@\n-        boolean max = (Long.MAX_VALUE \/ elementLayout.bitSize()) == elemCount;\n+        boolean max = (Long.MAX_VALUE \/ elementLayout.byteSize()) == elemCount;\n@@ -199,2 +199,2 @@\n-    SequenceLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new SequenceLayoutImpl(elementCount(), elementLayout, bitAlignment, name);\n+    SequenceLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new SequenceLayoutImpl(elementCount(), elementLayout, byteAlignment, name);\n@@ -204,2 +204,2 @@\n-    public SequenceLayoutImpl withBitAlignment(long bitAlignment) {\n-        if (bitAlignment < elementLayout.bitAlignment()) {\n+    public SequenceLayoutImpl withByteAlignment(long byteAlignment) {\n+        if (byteAlignment < elementLayout.byteAlignment()) {\n@@ -208,1 +208,1 @@\n-        return super.withBitAlignment(bitAlignment);\n+        return super.withByteAlignment(byteAlignment);\n@@ -213,1 +213,1 @@\n-        return bitAlignment() == elementLayout.bitAlignment();\n+        return byteAlignment() == elementLayout.byteAlignment();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private StructLayoutImpl(List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n-        super(Kind.STRUCT, elements, bitSize, bitAlignment, minBitAlignment, name);\n+    private StructLayoutImpl(List<MemoryLayout> elements, long byteSize, long byteAlignment, long minByteAlignment, Optional<String> name) {\n+        super(Kind.STRUCT, elements, byteSize, byteAlignment, minByteAlignment, name);\n@@ -40,2 +40,2 @@\n-    StructLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new StructLayoutImpl(memberLayouts(), bitSize(), bitAlignment, minBitAlignment, name);\n+    StructLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new StructLayoutImpl(memberLayouts(), byteSize(), byteAlignment, minByteAlignment, name);\n@@ -46,1 +46,1 @@\n-        long align = 8;\n+        long align = 1;\n@@ -48,1 +48,1 @@\n-            if (size % elem.bitAlignment() != 0) {\n+            if (size % elem.byteAlignment() != 0) {\n@@ -51,2 +51,2 @@\n-            size = Math.addExact(size, elem.bitSize());\n-            align = Math.max(align, elem.bitAlignment());\n+            size = Math.addExact(size, elem.byteSize());\n+            align = Math.max(align, elem.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private UnionLayoutImpl(List<MemoryLayout> elements, long bitSize, long bitAlignment, long minBitAlignment, Optional<String> name) {\n-        super(Kind.UNION, elements, bitSize, bitAlignment, minBitAlignment, name);\n+    private UnionLayoutImpl(List<MemoryLayout> elements, long byteSize, long byteAlignment, long minByteAlignment, Optional<String> name) {\n+        super(Kind.UNION, elements, byteSize, byteAlignment, minByteAlignment, name);\n@@ -40,2 +40,2 @@\n-    UnionLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new UnionLayoutImpl(memberLayouts(), bitSize(), bitAlignment, minBitAlignment, name);\n+    UnionLayoutImpl dup(long byteAlignment, Optional<String> name) {\n+        return new UnionLayoutImpl(memberLayouts(), byteSize(), byteAlignment, minByteAlignment, name);\n@@ -46,1 +46,1 @@\n-        long align = 8;\n+        long align = 1;\n@@ -48,2 +48,2 @@\n-            size = Math.max(size, elem.bitSize());\n-            align = Math.max(align, elem.bitAlignment());\n+            size = Math.max(size, elem.byteSize());\n+            align = Math.max(align, elem.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (in bits),\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (expressed in bytes),\n@@ -67,1 +67,1 @@\n-        static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+        static final int ADDRESS_SIZE_BYTES = Unsafe.ADDRESS_SIZE;\n@@ -74,2 +74,2 @@\n-        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize, long bitAlignment, Optional<String> name) {\n-            super(bitSize, bitAlignment, name);\n+        AbstractValueLayout(Class<?> carrier, ByteOrder order, long byteSize, long byteAlignment, Optional<String> name) {\n+            super(byteSize, byteAlignment, name);\n@@ -78,1 +78,1 @@\n-            assertCarrierSize(carrier, bitSize);\n+            assertCarrierSize(carrier, byteSize);\n@@ -97,1 +97,1 @@\n-            return dup(order, bitAlignment(), name());\n+            return dup(order, byteAlignment(), name());\n@@ -106,1 +106,1 @@\n-            return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+            return decorateLayoutString(String.format(\"%s%d\", descriptor, byteSize()));\n@@ -146,2 +146,2 @@\n-        final V dup(long bitAlignment, Optional<String> name) {\n-            return dup(order(), bitAlignment, name);\n+        final V dup(long byteAlignment, Optional<String> name) {\n+            return dup(order(), byteAlignment, name);\n@@ -150,1 +150,1 @@\n-        abstract V dup(ByteOrder order, long bitAlignment, Optional<String> name);\n+        abstract V dup(ByteOrder order, long byteAlignment, Optional<String> name);\n@@ -152,1 +152,1 @@\n-        static void assertCarrierSize(Class<?> carrier, long bitSize) {\n+        static void assertCarrierSize(Class<?> carrier, long byteSize) {\n@@ -155,2 +155,2 @@\n-                    \/\/ MemorySegment bitSize must always equal ADDRESS_SIZE_BITS\n-                    || bitSize == ADDRESS_SIZE_BITS;\n+                    \/\/ MemorySegment byteSize must always equal ADDRESS_SIZE_BYTES\n+                    || byteSize == ADDRESS_SIZE_BYTES;\n@@ -158,2 +158,3 @@\n-                    \/\/ Primitive class bitSize must always correspond\n-                    bitSize == (carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth());\n+                    \/\/ Primitive class byteSize must always correspond\n+                    byteSize == (carrier == boolean.class ? 1 :\n+                            Utils.byteWidthOfPrimitive(carrier));\n@@ -192,2 +193,2 @@\n-        private OfBooleanImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(boolean.class, order, Byte.SIZE, bitAlignment, name);\n+        private OfBooleanImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(boolean.class, order, Byte.BYTES, byteAlignment, name);\n@@ -197,2 +198,2 @@\n-        OfBooleanImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfBooleanImpl(order, bitAlignment, name);\n+        OfBooleanImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfBooleanImpl(order, byteAlignment, name);\n@@ -202,1 +203,1 @@\n-            return new OfBooleanImpl(order, Byte.SIZE, Optional.empty());\n+            return new OfBooleanImpl(order, Byte.BYTES, Optional.empty());\n@@ -208,2 +209,2 @@\n-        private OfByteImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(byte.class, order, Byte.SIZE, bitAlignment, name);\n+        private OfByteImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(byte.class, order, Byte.BYTES, byteAlignment, name);\n@@ -213,2 +214,2 @@\n-        OfByteImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfByteImpl(order, bitAlignment, name);\n+        OfByteImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfByteImpl(order, byteAlignment, name);\n@@ -218,1 +219,1 @@\n-            return new OfByteImpl(order, Byte.SIZE, Optional.empty());\n+            return new OfByteImpl(order, Byte.BYTES, Optional.empty());\n@@ -224,2 +225,2 @@\n-        private OfCharImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(char.class, order, Character.SIZE, bitAlignment, name);\n+        private OfCharImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(char.class, order, Character.BYTES, byteAlignment, name);\n@@ -229,2 +230,2 @@\n-        OfCharImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfCharImpl(order, bitAlignment, name);\n+        OfCharImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfCharImpl(order, byteAlignment, name);\n@@ -234,1 +235,1 @@\n-            return new OfCharImpl(order, Character.SIZE, Optional.empty());\n+            return new OfCharImpl(order, Character.BYTES, Optional.empty());\n@@ -240,2 +241,2 @@\n-        private OfShortImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(short.class, order, Short.SIZE, bitAlignment, name);\n+        private OfShortImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(short.class, order, Short.BYTES, byteAlignment, name);\n@@ -245,2 +246,2 @@\n-        OfShortImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfShortImpl(order, bitAlignment, name);\n+        OfShortImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfShortImpl(order, byteAlignment, name);\n@@ -250,1 +251,1 @@\n-            return new OfShortImpl(order, Short.SIZE, Optional.empty());\n+            return new OfShortImpl(order, Short.BYTES, Optional.empty());\n@@ -256,2 +257,2 @@\n-        private OfIntImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(int.class, order, Integer.SIZE, bitAlignment, name);\n+        private OfIntImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(int.class, order, Integer.BYTES, byteAlignment, name);\n@@ -261,2 +262,2 @@\n-        OfIntImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfIntImpl(order, bitAlignment, name);\n+        OfIntImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfIntImpl(order, byteAlignment, name);\n@@ -266,1 +267,1 @@\n-            return new OfIntImpl(order, Integer.SIZE, Optional.empty());\n+            return new OfIntImpl(order, Integer.BYTES, Optional.empty());\n@@ -272,2 +273,2 @@\n-        private OfFloatImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(float.class, order, Float.SIZE, bitAlignment, name);\n+        private OfFloatImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(float.class, order, Float.BYTES, byteAlignment, name);\n@@ -277,2 +278,2 @@\n-        OfFloatImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfFloatImpl(order, bitAlignment, name);\n+        OfFloatImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfFloatImpl(order, byteAlignment, name);\n@@ -282,1 +283,1 @@\n-            return new OfFloatImpl(order, Float.SIZE, Optional.empty());\n+            return new OfFloatImpl(order, Float.BYTES, Optional.empty());\n@@ -288,2 +289,2 @@\n-        private OfLongImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(long.class, order, Long.SIZE, bitAlignment, name);\n+        private OfLongImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(long.class, order, Long.BYTES, byteAlignment, name);\n@@ -293,2 +294,2 @@\n-        OfLongImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfLongImpl(order, bitAlignment, name);\n+        OfLongImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfLongImpl(order, byteAlignment, name);\n@@ -298,1 +299,1 @@\n-            return new OfLongImpl(order, Long.SIZE, Optional.empty());\n+            return new OfLongImpl(order, Long.BYTES, Optional.empty());\n@@ -304,2 +305,2 @@\n-        private OfDoubleImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(double.class, order, Double.SIZE, bitAlignment, name);\n+        private OfDoubleImpl(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            super(double.class, order, Double.BYTES, byteAlignment, name);\n@@ -309,2 +310,2 @@\n-        OfDoubleImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfDoubleImpl(order, bitAlignment, name);\n+        OfDoubleImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfDoubleImpl(order, byteAlignment, name);\n@@ -314,1 +315,1 @@\n-            return new OfDoubleImpl(order, Double.SIZE, Optional.empty());\n+            return new OfDoubleImpl(order, Double.BYTES, Optional.empty());\n@@ -323,2 +324,2 @@\n-        private OfAddressImpl(ByteOrder order, long bitSize, long bitAlignment, MemoryLayout targetLayout, Optional<String> name) {\n-            super(MemorySegment.class, order, bitSize, bitAlignment, name);\n+        private OfAddressImpl(ByteOrder order, long byteSize, long byteAlignment, MemoryLayout targetLayout, Optional<String> name) {\n+            super(MemorySegment.class, order, byteSize, byteAlignment, name);\n@@ -329,2 +330,2 @@\n-        OfAddressImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            return new OfAddressImpl(order, bitSize(), bitAlignment,targetLayout, name);\n+        OfAddressImpl dup(ByteOrder order, long byteAlignment, Optional<String> name) {\n+            return new OfAddressImpl(order, byteSize(), byteAlignment,targetLayout, name);\n@@ -349,1 +350,1 @@\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment(), layout, name());\n+            return new OfAddressImpl(order(), byteSize(), byteAlignment(), layout, name());\n@@ -354,1 +355,1 @@\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment(), null, name());\n+            return new OfAddressImpl(order(), byteSize(), byteAlignment(), null, name());\n@@ -363,1 +364,1 @@\n-            return new OfAddressImpl(order, ADDRESS_SIZE_BITS, ADDRESS_SIZE_BITS, null, Optional.empty());\n+            return new OfAddressImpl(order, ADDRESS_SIZE_BYTES, ADDRESS_SIZE_BYTES, null, Optional.empty());\n@@ -372,1 +373,1 @@\n-            String str = decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+            String str = decorateLayoutString(String.format(\"%s%d\", descriptor, byteSize()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":64,"deletions":63,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n@@ -3305,1 +3305,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n@@ -2988,1 +2988,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_DOUBLE.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_DOUBLE.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n@@ -2994,1 +2994,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_FLOAT.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_FLOAT.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n@@ -3150,1 +3150,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n@@ -3029,1 +3029,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n@@ -3299,1 +3299,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n@@ -4101,1 +4101,1 @@\n-     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withBitAlignment(8), n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withByteAlignment(1), n);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final long BIT_ALIGNMENT = Byte.SIZE;\n+    private static final long BYTE_ALIGNMENT = Byte.BYTES;\n@@ -52,1 +52,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -62,1 +62,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -72,1 +72,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -82,1 +82,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -92,1 +92,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -102,1 +102,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -112,1 +112,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -122,1 +122,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -132,1 +132,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -142,1 +142,1 @@\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -159,2 +159,2 @@\n-        PaddingLayout v = MemoryLayout.paddingLayout(8)\n-                .withBitAlignment(BIT_ALIGNMENT)\n+        PaddingLayout v = MemoryLayout.paddingLayout(1)\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -169,3 +169,3 @@\n-                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n-                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                        JAVA_INT.withByteAlignment(BYTE_ALIGNMENT),\n+                        JAVA_LONG.withByteAlignment(BYTE_ALIGNMENT))\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -180,3 +180,3 @@\n-                        JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n-                        JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                        JAVA_INT.withByteAlignment(BYTE_ALIGNMENT),\n+                        JAVA_LONG.withByteAlignment(BYTE_ALIGNMENT))\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -191,3 +191,3 @@\n-                    JAVA_INT.withBitAlignment(BIT_ALIGNMENT),\n-                    JAVA_LONG.withBitAlignment(BIT_ALIGNMENT))\n-                .withBitAlignment(BIT_ALIGNMENT)\n+                    JAVA_INT.withByteAlignment(BYTE_ALIGNMENT),\n+                    JAVA_LONG.withByteAlignment(BYTE_ALIGNMENT))\n+                .withByteAlignment(BYTE_ALIGNMENT)\n@@ -209,2 +209,1 @@\n-        assertEquals(v.bitAlignment(), BIT_ALIGNMENT);\n-        assertEquals(v.byteSize() * 8, v.bitSize());\n+        assertEquals(v.byteAlignment(), BYTE_ALIGNMENT);\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n@@ -107,1 +107,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n@@ -112,1 +112,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n@@ -116,1 +116,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n@@ -120,1 +120,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n@@ -124,1 +124,1 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-                    MemoryLayout.paddingLayout(24)\n+                    MemoryLayout.paddingLayout(3)\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_BYTE.withBitAlignment(16), 0, 4);\n+        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_BYTE.withByteAlignment(2), 0, 4);\n@@ -263,1 +263,1 @@\n-        MemorySegment.copy(segment, JAVA_BYTE.withBitAlignment(16), 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n+        MemorySegment.copy(segment, JAVA_BYTE.withByteAlignment(2), 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n@@ -331,1 +331,1 @@\n-            this.elementLayout = (L)elementLayout.withBitAlignment(8);\n+            this.elementLayout = (L)elementLayout.withByteAlignment(1);\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,7 +80,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -105,6 +99,6 @@\n-    static final ValueLayout.OfChar BB_CHAR = JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfShort BB_SHORT = JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfInt BB_INT = JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfLong BB_LONG = JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfFloat BB_FLOAT = JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n-    static final ValueLayout.OfDouble BB_DOUBLE = JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8);\n+    static final ValueLayout.OfChar BB_CHAR = JAVA_CHAR_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfShort BB_SHORT = JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfInt BB_INT = JAVA_INT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfLong BB_LONG = JAVA_LONG_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfFloat BB_FLOAT = JAVA_FLOAT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n+    static final ValueLayout.OfDouble BB_DOUBLE = JAVA_DOUBLE_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -388,1 +382,1 @@\n-        if (layout.bitSize() > 32\n+        if (layout.byteSize() > 4\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                MemoryLayout.paddingLayout(32));\n+                MemoryLayout.paddingLayout(4));\n@@ -146,1 +146,1 @@\n-        FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(1));\n@@ -151,1 +151,1 @@\n-        FunctionDescriptor.of(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.of(MemoryLayout.paddingLayout(1));\n@@ -156,1 +156,1 @@\n-        FunctionDescriptor.ofVoid().appendArgumentLayouts(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid().appendArgumentLayouts(MemoryLayout.paddingLayout(1));\n@@ -161,1 +161,1 @@\n-        FunctionDescriptor.ofVoid().insertArgumentLayouts(0, MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid().insertArgumentLayouts(0, MemoryLayout.paddingLayout(1));\n@@ -166,1 +166,1 @@\n-        FunctionDescriptor.ofVoid().changeReturnLayout(MemoryLayout.paddingLayout(8));\n+        FunctionDescriptor.ofVoid().changeReturnLayout(MemoryLayout.paddingLayout(1));\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -88,8 +88,0 @@\n-    static final ValueLayout.OfChar JAVA_CHAR_ALIGNED = ValueLayout.JAVA_CHAR.withBitAlignment(16);\n-    static final ValueLayout.OfShort JAVA_SHORT_ALIGNED = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n-    static final ValueLayout.OfInt JAVA_INT_ALIGNED = ValueLayout.JAVA_INT.withBitAlignment(32);\n-    static final ValueLayout.OfFloat JAVA_FLOAT_ALIGNED = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n-    static final ValueLayout.OfLong JAVA_LONG_ALIGNED = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-    static final ValueLayout.OfDouble JAVA_DOUBLE_ALIGNED = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n-    static final AddressLayout ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n-\n@@ -121,7 +113,7 @@\n-            layouts.add(new Object[] { testCase.segment, testCase.align, (char) 42, new char[]{42}, JAVA_CHAR_ALIGNED, (Function<char[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, (short) 42, new short[]{42}, JAVA_SHORT_ALIGNED, (Function<short[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42, new int[]{42}, JAVA_INT_ALIGNED, (Function<int[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42f, new float[]{42}, JAVA_FLOAT_ALIGNED, (Function<float[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42L, new long[]{42}, JAVA_LONG_ALIGNED, (Function<long[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, 42d, new double[]{42}, JAVA_DOUBLE_ALIGNED, (Function<double[], MemorySegment>)MemorySegment::ofArray });\n-            layouts.add(new Object[] { testCase.segment, testCase.align, MemorySegment.ofAddress(42), null, ADDRESS_ALIGNED, null });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (char) 42, new char[]{42}, ValueLayout.JAVA_CHAR, (Function<char[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (short) 42, new short[]{42}, ValueLayout.JAVA_SHORT, (Function<short[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42, new int[]{42}, ValueLayout.JAVA_INT, (Function<int[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42f, new float[]{42}, ValueLayout.JAVA_FLOAT, (Function<float[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42L, new long[]{42}, ValueLayout.JAVA_LONG, (Function<long[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42d, new double[]{42}, ValueLayout.JAVA_DOUBLE, (Function<double[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, MemorySegment.ofAddress(42), null, ValueLayout.ADDRESS, null });\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-                    \"Unsupported layout: [2:i32]\"\n+                    \"Unsupported layout: [2:i4]\"\n@@ -118,1 +118,1 @@\n-                    \"Unsupported layout: [2:i32]\"\n+                    \"Unsupported layout: [2:i4]\"\n@@ -121,1 +121,1 @@\n-                    FunctionDescriptor.ofVoid(C_INT.withBitAlignment(16)),\n+                    FunctionDescriptor.ofVoid(C_INT.withByteAlignment(2)),\n@@ -125,1 +125,1 @@\n-                    FunctionDescriptor.ofVoid(C_POINTER.withBitAlignment(16)),\n+                    FunctionDescriptor.ofVoid(C_POINTER.withByteAlignment(2)),\n@@ -129,1 +129,1 @@\n-                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withBitAlignment(32)),\n+                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withByteAlignment(4)),\n@@ -134,4 +134,4 @@\n-                            C_CHAR.withName(\"x\").withBitAlignment(8),\n-                            C_SHORT.withName(\"y\").withBitAlignment(8),\n-                            C_INT.withName(\"z\").withBitAlignment(8)\n-                            ).withBitAlignment(8)),\n+                            C_CHAR.withName(\"x\").withByteAlignment(1),\n+                            C_SHORT.withName(\"y\").withByteAlignment(1),\n+                            C_INT.withName(\"z\").withByteAlignment(1)\n+                            ).withByteAlignment(1)),\n@@ -143,3 +143,3 @@\n-                                C_CHAR.withName(\"x\").withBitAlignment(8),\n-                                C_SHORT.withName(\"y\").withBitAlignment(8),\n-                                C_INT.withName(\"z\").withBitAlignment(8)\n+                                C_CHAR.withName(\"x\").withByteAlignment(1),\n+                                C_SHORT.withName(\"y\").withByteAlignment(1),\n+                                C_INT.withName(\"z\").withByteAlignment(1)\n@@ -152,1 +152,1 @@\n-                                C_INT.withBitAlignment(8)\n+                                C_INT.withByteAlignment(1)\n@@ -159,1 +159,1 @@\n-                            MemoryLayout.paddingLayout(32), \/\/ no excess padding\n+                            MemoryLayout.paddingLayout(4), \/\/ no excess padding\n@@ -184,1 +184,1 @@\n-                            MemoryLayout.paddingLayout(32))), \/\/ too much trailing padding\n+                            MemoryLayout.paddingLayout(4))), \/\/ too much trailing padding\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        seq.bitOffset(groupElement(\"foo\"));\n+        seq.byteOffset(groupElement(\"foo\"));\n@@ -61,6 +61,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadBitSelectFromStruct() {\n-        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n-        g.bitOffset(sequenceElement());\n-    }\n-\n@@ -73,6 +67,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadBitSelectFromValue() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(), sequenceElement());\n-    }\n-\n@@ -85,6 +73,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testUnknownBitStructField() {\n-        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n-        g.bitOffset(groupElement(\"foo\"));\n-    }\n-\n@@ -109,6 +91,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitOutOfBoundsSeqIndex() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(6));\n-    }\n-\n@@ -126,6 +102,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitNegativeSeqIndex() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(-2));\n-    }\n-\n@@ -141,1 +111,1 @@\n-        seq.bitOffset(sequenceElement(6, 2));\n+        seq.byteOffset(sequenceElement(6, 2));\n@@ -149,6 +119,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitNegativeSeqRange() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n-        seq.bitOffset(sequenceElement(-2, 2));\n-    }\n-\n@@ -167,6 +131,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBitOffsetHandleBadRange() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(5, MemoryLayout.structLayout(JAVA_INT));\n-        seq.bitOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n-    }\n-\n@@ -184,6 +142,0 @@\n-            try {\n-                seq.bitOffset(e);\n-                fail();\n-            } catch (IllegalArgumentException ex) {\n-                assertTrue(true);\n-            }\n@@ -214,1 +166,1 @@\n-        long[] offsets = { 0, 8, 24, 56 };\n+        long[] offsets = { 0, 1, 3, 7 };\n@@ -217,3 +169,3 @@\n-                ValueLayout.JAVA_CHAR.withBitAlignment(8).withName(\"1\"),\n-                ValueLayout.JAVA_FLOAT.withBitAlignment(8).withName(\"2\"),\n-                ValueLayout.JAVA_LONG.withBitAlignment(8).withName(\"3\")\n+                ValueLayout.JAVA_CHAR_UNALIGNED.withName(\"1\"),\n+                ValueLayout.JAVA_FLOAT_UNALIGNED.withName(\"2\"),\n+                ValueLayout.JAVA_LONG_UNALIGNED.withName(\"3\")\n@@ -232,2 +184,0 @@\n-            long bitOffset = g.bitOffset(groupSelector.apply(i));\n-            assertEquals(offsets[i], bitOffset);\n@@ -235,1 +185,1 @@\n-            assertEquals((offsets[i]) >>> 3, byteOffset);\n+            assertEquals(offsets[i], byteOffset);\n@@ -259,2 +209,0 @@\n-            long bitOffset = g.bitOffset(groupSelector.apply(i));\n-            assertEquals(offsets[i], bitOffset);\n@@ -262,1 +210,1 @@\n-            assertEquals((offsets[i]) >>> 3, byteOffset);\n+            assertEquals(offsets[i], byteOffset);\n@@ -276,1 +224,1 @@\n-        long[] offsets = { 0, 8, 16, 24 };\n+        long[] offsets = { 0, 1, 2, 3 };\n@@ -287,2 +235,0 @@\n-            long bitOffset = g.bitOffset(sequenceElement(i));\n-            assertEquals(offsets[i], bitOffset);\n@@ -290,1 +236,1 @@\n-            assertEquals((offsets[i]) >>> 3, byteOffset);\n+            assertEquals(offsets[i], byteOffset);\n@@ -296,11 +242,5 @@\n-                                 long expectedBitOffset) throws Throwable {\n-        MethodHandle bitOffsetHandle = layout.bitOffsetHandle(pathElements);\n-        bitOffsetHandle = bitOffsetHandle.asSpreader(long[].class, indexes.length);\n-        long actualBitOffset = (long) bitOffsetHandle.invokeExact(indexes);\n-        assertEquals(actualBitOffset, expectedBitOffset);\n-        if (expectedBitOffset % 8 == 0) {\n-            MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n-            byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n-            long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n-            assertEquals(actualByteOffset, expectedBitOffset \/ 8);\n-        }\n+                                 long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        assertEquals(actualByteOffset, expectedByteOffset);\n@@ -317,1 +257,1 @@\n-            JAVA_INT.bitSize() * 4\n+            JAVA_INT.byteSize() * 4\n@@ -323,1 +263,1 @@\n-            (JAVA_INT.bitSize() * 2) * 4 + JAVA_INT.bitSize()\n+            (JAVA_INT.byteSize() * 2) * 4 + JAVA_INT.byteSize()\n@@ -326,1 +266,1 @@\n-            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(4), JAVA_INT.withName(\"y\"))),\n@@ -329,1 +269,1 @@\n-            (JAVA_INT.bitSize() + 32) * 4 + 32\n+            (JAVA_INT.byteSize() + 4) * 4 + 4\n@@ -335,1 +275,1 @@\n-            JAVA_INT.bitSize() * 4\n+            JAVA_INT.byteSize() * 4\n@@ -343,1 +283,1 @@\n-            JAVA_INT.bitSize() * 4\n+            JAVA_INT.byteSize() * 4\n@@ -361,1 +301,1 @@\n-            (JAVA_INT.bitSize() * 2)\n+            (JAVA_INT.byteSize() * 2)\n@@ -367,1 +307,1 @@\n-            (JAVA_INT.bitSize() * 2) * 10\n+            (JAVA_INT.byteSize() * 2) * 10\n@@ -373,1 +313,1 @@\n-            (JAVA_INT.bitSize() * 2) + JAVA_INT.bitSize()\n+            (JAVA_INT.byteSize() * 2) + JAVA_INT.byteSize()\n@@ -379,1 +319,1 @@\n-            (JAVA_INT.bitSize() * 2) * 10 + JAVA_INT.bitSize()\n+            (JAVA_INT.byteSize() * 2) * 10 + JAVA_INT.byteSize()\n@@ -387,4 +327,1 @@\n-                                long expectedBitOffset) throws Throwable {\n-        if (expectedBitOffset % 8 != 0)\n-            throw new SkipException(\"Offset not a multiple of 8\");\n-\n+                                long expectedByteOffset) throws Throwable {\n@@ -398,1 +335,1 @@\n-            assertEquals(slice.address() - segment.address(), expectedBitOffset \/ 8);\n+            assertEquals(slice.address() - segment.address(), expectedByteOffset);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":27,"deletions":90,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        layout.withBitAlignment(alignment);\n+        layout.withByteAlignment(alignment);\n@@ -55,1 +55,1 @@\n-        MemoryLayout differentType = MemoryLayout.paddingLayout(8);\n+        MemoryLayout differentType = MemoryLayout.paddingLayout(1);\n@@ -63,1 +63,1 @@\n-        MemoryLayout differentAlignment = layout.withBitAlignment(layout.bitAlignment() * 2);\n+        MemoryLayout differentAlignment = layout.withByteAlignment(layout.byteAlignment() * 2);\n@@ -81,1 +81,1 @@\n-        MemoryLayout other = layout.withBitAlignment(128).withBitAlignment(layout.bitAlignment());\n+        MemoryLayout other = layout.withByteAlignment(16).withByteAlignment(layout.byteAlignment());\n@@ -127,1 +127,1 @@\n-        layout.withBitAlignment(3);\n+        layout.withByteAlignment(9);\n@@ -131,2 +131,2 @@\n-    public void testGroupIllegalAlignmentNotGreaterOrEqualTo8(MemoryLayout layout) {\n-        layout.withBitAlignment(4);\n+    public void testGroupIllegalAlignmentNotGreaterOrEqualTo1(MemoryLayout layout) {\n+        layout.withByteAlignment(0);\n@@ -137,1 +137,1 @@\n-        PaddingLayout paddingLayout = MemoryLayout.paddingLayout(16);\n+        PaddingLayout paddingLayout = MemoryLayout.paddingLayout(2);\n@@ -139,1 +139,1 @@\n-        PaddingLayout paddingLayout2 = MemoryLayout.paddingLayout(32);\n+        PaddingLayout paddingLayout2 = MemoryLayout.paddingLayout(4);\n@@ -146,2 +146,2 @@\n-        assertEquals(struct.bitSize(), 0);\n-        assertEquals(struct.bitAlignment(), 8);\n+        assertEquals(struct.byteSize(), 0);\n+        assertEquals(struct.byteAlignment(), 1);\n@@ -150,2 +150,2 @@\n-        assertEquals(union.bitSize(), 0);\n-        assertEquals(union.bitAlignment(), 8);\n+        assertEquals(union.byteSize(), 0);\n+        assertEquals(union.byteAlignment(), 1);\n@@ -157,1 +157,1 @@\n-                MemoryLayout.paddingLayout(8),\n+                MemoryLayout.paddingLayout(1),\n@@ -169,1 +169,1 @@\n-        assertEquals(MemoryLayout.paddingLayout(layout.bitSize()).bitAlignment(), 8);\n+        assertEquals(MemoryLayout.paddingLayout(layout.byteSize()).byteAlignment(), 1);\n@@ -175,2 +175,2 @@\n-                layout, MemoryLayout.paddingLayout(128 - layout.bitSize()));\n-        assertEquals(struct.bitAlignment(), layout.bitAlignment());\n+                layout, MemoryLayout.paddingLayout(16 - layout.byteSize()));\n+        assertEquals(struct.byteAlignment(), layout.byteAlignment());\n@@ -182,2 +182,2 @@\n-                layout, MemoryLayout.paddingLayout(128 - layout.bitSize()));\n-        assertEquals(struct.bitAlignment(), layout.bitAlignment());\n+                layout, MemoryLayout.paddingLayout(16 - layout.byteSize()));\n+        assertEquals(struct.byteAlignment(), layout.byteAlignment());\n@@ -207,1 +207,1 @@\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.bitSize(), layout));\n+                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout));\n@@ -236,1 +236,1 @@\n-        var padding = MemoryLayout.paddingLayout(8);\n+        var padding = MemoryLayout.paddingLayout(1);\n@@ -242,1 +242,1 @@\n-        var padding = MemoryLayout.paddingLayout(8);\n+        var padding = MemoryLayout.paddingLayout(1);\n@@ -248,2 +248,2 @@\n-    public void testPaddingIllegalBitSize() {\n-        for (long bitSize : List.of(-8L, -1L, 0L, 1L, 7L)) {\n+    public void testPaddingIllegalByteSize() {\n+        for (long byteSize : List.of(-1L, 0L)) {\n@@ -251,2 +251,2 @@\n-                MemoryLayout.paddingLayout(bitSize);\n-                fail(\"bitSize cannot be \" + bitSize);\n+                MemoryLayout.paddingLayout(byteSize);\n+                fail(\"byte size cannot be \" + byteSize);\n@@ -262,3 +262,3 @@\n-        assertEquals(padding.toString(), \"[i32](struct)\");\n-        var toStringUnaligned = padding.withBitAlignment(64).toString();\n-        assertEquals(toStringUnaligned, \"64%[i32](struct)\");\n+        assertEquals(padding.toString(), \"[i4](struct)\");\n+        var toStringUnaligned = padding.withByteAlignment(8).toString();\n+        assertEquals(toStringUnaligned, \"8%[i4](struct)\");\n@@ -273,2 +273,2 @@\n-    public void testAlignmentString(MemoryLayout layout, long bitAlign) {\n-        long[] alignments = { 8, 16, 32, 64, 128 };\n+    public void testAlignmentString(MemoryLayout layout, long byteAlign) {\n+        long[] alignments = { 1, 2, 4, 8, 16 };\n@@ -276,1 +276,1 @@\n-            if (layout.bitAlignment() == bitAlign) {\n+            if (layout.byteAlignment() == byteAlign) {\n@@ -278,2 +278,2 @@\n-                if (a >= layout.bitAlignment()) {\n-                    assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+                if (a >= layout.byteAlignment()) {\n+                    assertEquals(layout.withByteAlignment(a).toString().contains(\"%\"), a != byteAlign);\n@@ -286,2 +286,2 @@\n-    public void testBadBitAlignment(MemoryLayout layout, long bitAlign) {\n-        long[] alignments = { 8, 16, 32, 64, 128 };\n+    public void testBadByteAlignment(MemoryLayout layout, long byteAlign) {\n+        long[] alignments = { 1, 2, 4, 8, 16 };\n@@ -289,2 +289,2 @@\n-            if (a < bitAlign && !(layout instanceof ValueLayout)) {\n-                assertThrows(IllegalArgumentException.class, () -> layout.withBitAlignment(a));\n+            if (a < byteAlign && !(layout instanceof ValueLayout)) {\n+                assertThrows(IllegalArgumentException.class, () -> layout.withByteAlignment(a));\n@@ -296,2 +296,2 @@\n-    public void testBadSequenceElementAlignmentTooBig(MemoryLayout layout, long bitAlign) {\n-        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+    public void testBadSequenceElementAlignmentTooBig(MemoryLayout layout, long byteAlign) {\n+        layout = layout.withByteAlignment(layout.byteSize() * 2); \/\/ hyper-align\n@@ -302,1 +302,1 @@\n-    public void testBadSequenceElementSizeNotMultipleOfAlignment(MemoryLayout layout, long bitAlign) {\n+    public void testBadSequenceElementSizeNotMultipleOfAlignment(MemoryLayout layout, long byteAlign) {\n@@ -313,1 +313,1 @@\n-    public void testBadSpliteratorElementSizeNotMultipleOfAlignment(MemoryLayout layout, long bitAlign) {\n+    public void testBadSpliteratorElementSizeNotMultipleOfAlignment(MemoryLayout layout, long byteAlign) {\n@@ -325,1 +325,1 @@\n-    public void testBadElementsElementSizeNotMultipleOfAlignment(MemoryLayout layout, long bitAlign) {\n+    public void testBadElementsElementSizeNotMultipleOfAlignment(MemoryLayout layout, long byteAlign) {\n@@ -337,2 +337,2 @@\n-    public void testBadStruct(MemoryLayout layout, long bitAlign) {\n-        layout = layout.withBitAlignment(layout.bitSize() * 2); \/\/ hyper-align\n+    public void testBadStruct(MemoryLayout layout, long byteAlign) {\n+        layout = layout.withByteAlignment(layout.byteSize() * 2); \/\/ hyper-align\n@@ -354,2 +354,2 @@\n-            values[i * 2] = new Object[] { layoutKinds[i].layout, 3 }; \/\/ smaller than 8\n-            values[(i * 2) + 1] = new Object[] { layoutKinds[i].layout, 18 }; \/\/ not a power of 2\n+            values[i * 2] = new Object[] { layoutKinds[i].layout, 0 }; \/\/ smaller than 1\n+            values[(i * 2) + 1] = new Object[] { layoutKinds[i].layout, 5 }; \/\/ not a power of 2\n@@ -371,1 +371,1 @@\n-        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(8)));\n+        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(1)));\n@@ -396,4 +396,4 @@\n-        PADDING(MemoryLayout.paddingLayout(8)),\n-        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(8))),\n-        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8))),\n-        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8)));\n+        PADDING(MemoryLayout.paddingLayout(1)),\n+        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(1))),\n+        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(1), MemoryLayout.paddingLayout(1))),\n+        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(1), MemoryLayout.paddingLayout(1)));\n@@ -435,1 +435,1 @@\n-            layoutsAndAlignments.add(new Object[] { l, l.bitAlignment() });\n+            layoutsAndAlignments.add(new Object[] { l, l.byteAlignment() });\n@@ -439,1 +439,1 @@\n-            layoutsAndAlignments.add(new Object[] { MemoryLayout.sequenceLayout(4, l), l.bitAlignment() });\n+            layoutsAndAlignments.add(new Object[] { MemoryLayout.sequenceLayout(4, l), l.byteAlignment() });\n@@ -445,1 +445,1 @@\n-                long align = Math.max(l1.bitAlignment(), l2.bitAlignment());\n+                long align = Math.max(l1.byteAlignment(), l2.byteAlignment());\n@@ -452,1 +452,1 @@\n-                long align = Math.max(l1.bitAlignment(), l2.bitAlignment());\n+                long align = Math.max(l1.byteAlignment(), l2.byteAlignment());\n@@ -487,1 +487,1 @@\n-                MemoryLayout.structLayout(JAVA_INT, MemoryLayout.paddingLayout(32), JAVA_LONG),\n+                MemoryLayout.structLayout(JAVA_INT, MemoryLayout.paddingLayout(4), JAVA_LONG),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -92,4 +92,4 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32).withName(\"x\"), C_LONG_LONG)) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        GroupLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\"));\n+        GroupLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.byteSize()), elemLayout.withName(\"elem\"));\n@@ -77,1 +77,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\")));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.byteSize()), elemLayout.withName(\"elem\")));\n@@ -171,1 +171,1 @@\n-                MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\"))));\n+                MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.byteSize()), elemLayout.withName(\"elem\"))));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                L alignedLayout = (L)layout.withBitAlignment(layout.byteSize() * 8 * 2);\n+                L alignedLayout = (L)layout.withByteAlignment(layout.byteSize() * 2);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-                .withBitAlignment(32)\n@@ -46,3 +45,3 @@\n-        assertEquals(layout.bitAlignment(), 32);\n-        ValueLayout aligned = layout.withBitAlignment(align);\n-        assertEquals(aligned.bitAlignment(), align); \/\/unreasonable alignment here, to make sure access throws\n+        assertEquals(layout.byteAlignment(), 4);\n+        ValueLayout aligned = layout.withByteAlignment(align);\n+        assertEquals(aligned.byteAlignment(), align); \/\/unreasonable alignment here, to make sure access throws\n@@ -61,1 +60,0 @@\n-                .withBitAlignment(32)\n@@ -63,2 +61,2 @@\n-        assertEquals(layout.bitAlignment(), 32);\n-        ValueLayout aligned = layout.withBitAlignment(align);\n+        assertEquals(layout.byteAlignment(), 4);\n+        ValueLayout aligned = layout.withByteAlignment(align);\n@@ -66,2 +64,2 @@\n-            MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n-            assertEquals(alignedGroup.bitAlignment(), align);\n+            MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(1), aligned);\n+            assertEquals(alignedGroup.byteAlignment(), align);\n@@ -80,1 +78,1 @@\n-        MemoryLayout aligned = layout.withBitAlignment(align).withName(\"value\");\n+        MemoryLayout aligned = layout.withByteAlignment(align).withName(\"value\");\n@@ -82,1 +80,1 @@\n-            GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n+            GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(1), aligned);\n@@ -84,1 +82,1 @@\n-            assertEquals(align, 8); \/\/this is the only case where path is aligned\n+            assertEquals(align, 1); \/\/this is the only case where path is aligned\n@@ -86,1 +84,1 @@\n-            assertNotEquals(align, 8); \/\/if align != 8, path is always unaligned\n+            assertNotEquals(align, 1); \/\/if align != 8, path is always unaligned\n@@ -93,1 +91,1 @@\n-            SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n+            SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withByteAlignment(align));\n@@ -102,1 +100,1 @@\n-            assertTrue(align > 32); \/\/if align > 32, access is always unaligned (for some elements)\n+            assertTrue(align > 4); \/\/if align > 4, access is always unaligned (for some elements)\n@@ -112,4 +110,4 @@\n-        GroupLayout g = MemoryLayout.structLayout(vChar.withBitAlignment(8).withName(\"a\"),\n-                               vShort.withBitAlignment(8).withName(\"b\"),\n-                               vInt.withBitAlignment(8).withName(\"c\"));\n-        assertEquals(g.bitAlignment(), 8);\n+        GroupLayout g = MemoryLayout.structLayout(vChar.withByteAlignment(1).withName(\"a\"),\n+                               vShort.withByteAlignment(1).withName(\"b\"),\n+                               vInt.withByteAlignment(1).withName(\"c\"));\n+        assertEquals(g.byteAlignment(), 1);\n@@ -132,1 +130,1 @@\n-        return LongStream.range(3, 32)\n+        return LongStream.range(1, 20)\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-        addDefaultMapping(PaddingLayout.class, MemoryLayout.paddingLayout(32));\n+        addDefaultMapping(PaddingLayout.class, MemoryLayout.paddingLayout(4));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-    final static Class<?> ADDRESS_CARRIER = ValueLayout.ADDRESS.bitSize() == 64 ? long.class : int.class;\n@@ -64,1 +63,1 @@\n-        layout = (L)layout.withBitAlignment(layout.bitSize());\n+        layout = (L)layout.withByteAlignment(layout.byteSize());\n@@ -67,3 +66,3 @@\n-                layout.withBitAlignment(layout.bitAlignment() * 2),\n-                layout.withBitAlignment(layout.bitAlignment() * 4),\n-                layout.withBitAlignment(layout.bitAlignment() * 8)\n+                layout.withByteAlignment(layout.byteAlignment() * 2),\n+                layout.withByteAlignment(layout.byteAlignment() * 4),\n+                layout.withByteAlignment(layout.byteAlignment() * 8)\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        MemorySegment.copy(segment, 0, segment, JAVA_BYTE.withBitAlignment(16), 0, 4);\n+        MemorySegment.copy(segment, 0, segment, JAVA_BYTE.withByteAlignment(2), 0, 4);\n@@ -117,1 +117,1 @@\n-        MemorySegment.copy(segment, JAVA_BYTE.withBitAlignment(16), 0, segment, 0, 4);\n+        MemorySegment.copy(segment, JAVA_BYTE.withByteAlignment(2), 0, segment, 0, 4);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-        segment.elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withBitAlignment(bigByteAlign * 8)));\n+        segment.elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withByteAlignment(bigByteAlign)));\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        MemoryLayout.paddingLayout(32)\n+        MemoryLayout.paddingLayout(4)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        MemoryLayout.paddingLayout(32)\n+        MemoryLayout.paddingLayout(4)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        testAligned(JAVA_BYTE, byte.class, Byte.SIZE);\n+        testAligned(JAVA_BYTE, byte.class, Byte.BYTES);\n@@ -49,1 +49,1 @@\n-        testAligned(JAVA_BOOLEAN, boolean.class, Byte.SIZE);\n+        testAligned(JAVA_BOOLEAN, boolean.class, Byte.BYTES);\n@@ -54,1 +54,1 @@\n-        testAligned(JAVA_SHORT, short.class, Short.SIZE);\n+        testAligned(JAVA_SHORT, short.class, Short.BYTES);\n@@ -59,1 +59,1 @@\n-        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.SIZE);\n+        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.BYTES);\n@@ -64,1 +64,1 @@\n-        testAligned(JAVA_INT, int.class, Integer.SIZE);\n+        testAligned(JAVA_INT, int.class, Integer.BYTES);\n@@ -69,1 +69,1 @@\n-        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.SIZE);\n+        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.BYTES);\n@@ -74,1 +74,1 @@\n-        testAligned(JAVA_LONG, long.class, Long.SIZE);\n+        testAligned(JAVA_LONG, long.class, Long.BYTES);\n@@ -79,1 +79,1 @@\n-        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.SIZE);\n+        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.BYTES);\n@@ -84,1 +84,1 @@\n-        testAligned(JAVA_FLOAT, float.class, Float.SIZE);\n+        testAligned(JAVA_FLOAT, float.class, Float.BYTES);\n@@ -89,1 +89,1 @@\n-        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.SIZE);\n+        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.BYTES);\n@@ -94,1 +94,1 @@\n-        testAligned(JAVA_DOUBLE, double.class, Double.SIZE);\n+        testAligned(JAVA_DOUBLE, double.class, Double.BYTES);\n@@ -99,1 +99,1 @@\n-        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.SIZE);\n+        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.BYTES);\n@@ -104,1 +104,1 @@\n-        testAligned(JAVA_CHAR, char.class, Character.SIZE);\n+        testAligned(JAVA_CHAR, char.class, Character.BYTES);\n@@ -109,1 +109,1 @@\n-        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.SIZE);\n+        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.BYTES);\n@@ -114,1 +114,1 @@\n-        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE);\n@@ -119,1 +119,1 @@\n-        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE);\n@@ -124,2 +124,2 @@\n-                     long bitSize) {\n-        test(layout, carrier, bitSize, bitSize);\n+                     long byteSize) {\n+        test(layout, carrier, byteSize, byteSize);\n@@ -130,2 +130,2 @@\n-                       long bitSize) {\n-        test(layout, carrier, bitSize, Byte.SIZE);\n+                       long byteSize) {\n+        test(layout, carrier, byteSize, Byte.BYTES);\n@@ -136,2 +136,2 @@\n-              long bitSize,\n-              long bitAlignment) {\n+              long byteSize,\n+              long byteAlignment) {\n@@ -139,1 +139,1 @@\n-        assertEquals(layout.bitSize(), bitSize);\n+        assertEquals(layout.byteSize(), byteSize);\n@@ -141,1 +141,1 @@\n-        assertEquals(layout.bitAlignment(), bitAlignment);\n+        assertEquals(layout.byteAlignment(), byteAlignment);\n@@ -143,2 +143,0 @@\n-        assertEquals(layout.byteSize(), layout.bitSize() \/ 8);\n-        assertEquals(layout.byteAlignment(), layout.bitAlignment() \/ 8);\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n@@ -66,1 +66,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n@@ -76,2 +76,2 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT\n-                .withOrder(ByteOrder.LITTLE_ENDIAN).withBitAlignment(8));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n+                .withOrder(ByteOrder.LITTLE_ENDIAN));\n@@ -87,2 +87,2 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT\n-                .withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(8));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n+                .withOrder(ByteOrder.BIG_ENDIAN));\n@@ -103,1 +103,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n+        newLayout = newLayout.withByteAlignment(layout.byteAlignment());\n@@ -59,2 +59,2 @@\n-        assertEquals(newLayout.bitSize(), layout.bitSize());\n-        assertEquals(newLayout.bitAlignment(), layout.bitAlignment());\n+        assertEquals(newLayout.byteSize(), layout.byteSize());\n+        assertEquals(newLayout.byteAlignment(), layout.byteAlignment());\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(4), C_DOUBLE),\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(4), C_DOUBLE),\n@@ -260,1 +260,1 @@\n-        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE);\n+        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(4), C_DOUBLE);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.paddingLayout(4),\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            MemoryLayout.paddingLayout(32)\n+            MemoryLayout.paddingLayout(4)\n@@ -98,1 +98,1 @@\n-            MemoryLayout.paddingLayout(128)\n+            MemoryLayout.paddingLayout(16)\n@@ -110,1 +110,1 @@\n-            MemoryLayout.paddingLayout(48)\n+            MemoryLayout.paddingLayout(6)\n@@ -120,1 +120,1 @@\n-            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.paddingLayout(4),\n@@ -125,1 +125,1 @@\n-            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.paddingLayout(4),\n@@ -142,1 +142,1 @@\n-            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.paddingLayout(4),\n@@ -172,1 +172,1 @@\n-            MemoryLayout.paddingLayout(48),\n+            MemoryLayout.paddingLayout(6),\n@@ -178,1 +178,1 @@\n-            MemoryLayout.paddingLayout(56),\n+            MemoryLayout.paddingLayout(7),\n@@ -181,1 +181,1 @@\n-            MemoryLayout.paddingLayout(56),\n+            MemoryLayout.paddingLayout(7),\n@@ -210,1 +210,1 @@\n-            MemoryLayout.paddingLayout(8)\n+            MemoryLayout.paddingLayout(1)\n@@ -240,1 +240,1 @@\n-            MemoryLayout.paddingLayout(24),\n+            MemoryLayout.paddingLayout(3),\n@@ -243,1 +243,1 @@\n-            MemoryLayout.paddingLayout(56)\n+            MemoryLayout.paddingLayout(7)\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n-    private static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+    private static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    private static final AddressLayout C_POINTER = ValueLayout.ADDRESS;\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}