{"files":[{"patch":"@@ -596,2 +596,7 @@\n-          const TypeX *ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n-          if (ac->modifies(ld_offs_t->_lo, ld_offs_t->_hi, phase, can_see_stored_value)) {\n+          const TypeX* ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n+          assert(!ld_offs_t->empty(), \"dead reference should be checked already\");\n+          \/\/ Take into account vector or unsafe access size\n+          jlong ld_size_in_bytes = (jlong)memory_size();\n+          jlong offset_hi = ld_offs_t->_hi + ld_size_in_bytes - 1;\n+          offset_hi = MIN2(offset_hi, (jlong)(TypeX::MAX->_hi)); \/\/ Take care for overflow in 32-bit VM\n+          if (ac->modifies(ld_offs_t->_lo, (intptr_t)offset_hi, phase, can_see_stored_value)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317121\n+ * @summary Test masked vectors and unsafe access to memory modified by arraycopy\n+ * @requires vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -Xbatch -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,TestMaskedVectors::test* -XX:+StressLCM -XX:+StressGCM -XX:StressSeed=2210259638 TestMaskedVectors\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -Xbatch -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,TestMaskedVectors::test* -XX:+StressLCM -XX:+StressGCM TestMaskedVectors\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMaskedVectors {\n+\n+    private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final long BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);\n+\n+    static void testLoadVectorMasked(byte[] src, byte[] dst, int len) {\n+        byte[] tmp = new byte[64];\n+\n+        \/\/ (3) The LoadVectorMasked is found to be dependent on below arraycopy and\n+        \/\/ therefore scheduled just below it. As a result, the LoadVectorMasked misses the\n+        \/\/ updated elements at index 16..48 and dst will contain incorrect values.\n+        System.arraycopy(src, 0, tmp, 0, 16);\n+\n+        \/\/ (2) The LoadVectorMasked is incorrectly found to be independent of this arraycopy\n+        \/\/ because the LoadVectorMasked has offset 0 whereas the arraycopy writes offset >= 16.\n+        \/\/ The problem is that MemNode::find_previous_store() -> LoadNode::find_previous_arraycopy()\n+        \/\/ -> ArrayCopyNode::modifies does not account for the size of the load.\n+        System.arraycopy(src, 0, tmp, 16, 48);\n+\n+        \/\/ (1) The following arraycopy is expanded into a LoadVectorMasked and a\n+        \/\/ StoreVectorMasked in PhaseMacroExpand::generate_partial_inlining_block().\n+        System.arraycopy(tmp, 0, dst, 0, len);\n+    }\n+\n+    static long testUnsafeGetLong(byte[] src) {\n+        byte[] tmp = new byte[16];\n+\n+        \/\/ (3) The unsafe load is found to be dependent on below arraycopy and\n+        \/\/ therefore scheduled just below it. As a result, the unsafe load misses the\n+        \/\/ updated elements at index 1..16 and therefore returns an incorrect result.\n+        System.arraycopy(src, 0, tmp, 0, 16);\n+\n+        \/\/ (2) The unsafe load is incorrectly found to be independent of this arraycopy\n+        \/\/ because the load has offset 0 in 'tmp' whereas the arraycopy writes offsets >= 1.\n+        \/\/ The problem is that MemNode::find_previous_store() -> LoadNode::find_previous_arraycopy()\n+        \/\/ -> ArrayCopyNode::modifies does not account for the size of the load.\n+        System.arraycopy(src, 0, tmp, 1, 15);\n+\n+        \/\/ (1) Below unsafe load reads the first 8 (byte) array elements.\n+        return UNSAFE.getLong(tmp, BASE_OFFSET);\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Initialize src array with increasing byte values\n+        byte[] src = new byte[64];\n+        for (byte i = 0; i < src.length; ++i) {\n+            src[i] = (byte)i;\n+        }\n+\n+        \/\/ Compute expected outputs once\n+        byte[] golden1 = new byte[64];\n+        testLoadVectorMasked(src, golden1, 64);\n+\n+        long golden2 = testUnsafeGetLong(src);\n+\n+        \/\/ Trigger compilation of test methods and verify the results\n+        for (int i = 0; i < 50_000; ++i) {\n+            int len = i % 32;\n+            byte[] dst = new byte[len];\n+            testLoadVectorMasked(src, dst, len);\n+\n+            boolean error = false;\n+            for (int j = 0; j < dst.length; ++j) {\n+                if (dst[j] != golden1[j]) {\n+                    System.out.println(\"Incorrect value of element \" + j + \": Expected \" + golden1[j] + \" but got \" + dst[j]);\n+                    error = true;\n+                }\n+            }\n+            if (error) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+\n+            long res = testUnsafeGetLong(src);\n+            if (res != golden2) {\n+                throw new RuntimeException(\"Incorrect result: Expected \" + golden2 + \" but got \" + res);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestMaskedVectors.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}