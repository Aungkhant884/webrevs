{"files":[{"patch":"@@ -3369,0 +3369,3 @@\n+      assert((uintptr_t)addr >= stack_extent,\n+             \"Sanity: addr should be larger than extent, \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+             p2i(addr), stack_extent);\n@@ -5368,1 +5371,0 @@\n-#ifndef ZERO\n@@ -5424,1 +5426,0 @@\n-#endif\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -201,83 +201,0 @@\n-static void current_stack_region(address *bottom, size_t *size) {\n-  pthread_attr_t attr;\n-  int res = pthread_getattr_np(pthread_self(), &attr);\n-  if (res != 0) {\n-    if (res == ENOMEM) {\n-      vm_exit_out_of_memory(0, OOM_MMAP_ERROR, \"pthread_getattr_np\");\n-    }\n-    else {\n-      fatal(\"pthread_getattr_np failed with error = %d\", res);\n-    }\n-  }\n-\n-  address stack_bottom;\n-  size_t stack_bytes;\n-  res = pthread_attr_getstack(&attr, (void **) &stack_bottom, &stack_bytes);\n-  if (res != 0) {\n-    fatal(\"pthread_attr_getstack failed with error = %d\", res);\n-  }\n-  address stack_top = stack_bottom + stack_bytes;\n-\n-  \/\/ The block of memory returned by pthread_attr_getstack() includes\n-  \/\/ guard pages where present.  We need to trim these off.\n-  size_t page_bytes = os::Linux::page_size();\n-  assert(((intptr_t) stack_bottom & (page_bytes - 1)) == 0, \"unaligned stack\");\n-\n-  size_t guard_bytes;\n-  res = pthread_attr_getguardsize(&attr, &guard_bytes);\n-  if (res != 0) {\n-    fatal(\"pthread_attr_getguardsize failed with errno = %d\", res);\n-  }\n-  int guard_pages = align_up(guard_bytes, page_bytes) \/ page_bytes;\n-  assert(guard_bytes == guard_pages * page_bytes, \"unaligned guard\");\n-\n-#ifdef IA64\n-  \/\/ IA64 has two stacks sharing the same area of memory, a normal\n-  \/\/ stack growing downwards and a register stack growing upwards.\n-  \/\/ Guard pages, if present, are in the centre.  This code splits\n-  \/\/ the stack in two even without guard pages, though in theory\n-  \/\/ there's nothing to stop us allocating more to the normal stack\n-  \/\/ or more to the register stack if one or the other were found\n-  \/\/ to grow faster.\n-  int total_pages = align_down(stack_bytes, page_bytes) \/ page_bytes;\n-  stack_bottom += (total_pages - guard_pages) \/ 2 * page_bytes;\n-#endif \/\/ IA64\n-\n-  stack_bottom += guard_bytes;\n-\n-  pthread_attr_destroy(&attr);\n-\n-  \/\/ The initial thread has a growable stack, and the size reported\n-  \/\/ by pthread_attr_getstack is the maximum size it could possibly\n-  \/\/ be given what currently mapped.  This can be huge, so we cap it.\n-  if (os::is_primordial_thread()) {\n-    stack_bytes = stack_top - stack_bottom;\n-\n-    if (stack_bytes > JavaThread::stack_size_at_create())\n-      stack_bytes = JavaThread::stack_size_at_create();\n-\n-    stack_bottom = stack_top - stack_bytes;\n-  }\n-\n-  assert(os::current_stack_pointer() >= stack_bottom, \"should do\");\n-  assert(os::current_stack_pointer() < stack_top, \"should do\");\n-\n-  *bottom = stack_bottom;\n-  *size = stack_top - stack_bottom;\n-}\n-\n-address os::current_stack_base() {\n-  address bottom;\n-  size_t size;\n-  current_stack_region(&bottom, &size);\n-  return bottom + size;\n-}\n-\n-size_t os::current_stack_size() {\n-  \/\/ stack size includes normal stack and HotSpot guard pages\n-  address bottom;\n-  size_t size;\n-  current_stack_region(&bottom, &size);\n-  return size;\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"}]}