{"files":[{"patch":"@@ -5371,0 +5371,1 @@\n+#ifndef ZERO\n@@ -5426,0 +5427,1 @@\n+#endif\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,77 @@\n+static void current_stack_region(address *bottom, size_t *size) {\n+  address stack_bottom;\n+  size_t stack_bytes;\n+\n+  if (os::is_primordial_thread()) {\n+    \/\/ primordial thread needs special handling because pthread_getattr_np()\n+    \/\/ may return bogus value.\n+    stack_bottom = os::Linux::initial_thread_stack_bottom();\n+    stack_bytes  = os::Linux::initial_thread_stack_size();\n+  } else {\n+    pthread_attr_t attr;\n+    int res = pthread_getattr_np(pthread_self(), &attr);\n+    if (res != 0) {\n+      if (res == ENOMEM) {\n+        vm_exit_out_of_memory(0, OOM_MMAP_ERROR, \"pthread_getattr_np\");\n+      } else {\n+        fatal(\"pthread_getattr_np failed with error = %d\", res);\n+      }\n+    }\n+\n+    res = pthread_attr_getstack(&attr, (void **) &stack_bottom, &stack_bytes);\n+    if (res != 0) {\n+      fatal(\"pthread_attr_getstack failed with error = %d\", res);\n+    }\n+\n+    \/\/ The block of memory returned by pthread_attr_getstack() includes\n+    \/\/ guard pages where present.  We need to trim these off.\n+    size_t page_bytes = os::Linux::page_size();\n+    assert(((intptr_t) stack_bottom & (page_bytes - 1)) == 0, \"unaligned stack\");\n+\n+    size_t guard_bytes;\n+    res = pthread_attr_getguardsize(&attr, &guard_bytes);\n+    if (res != 0) {\n+      fatal(\"pthread_attr_getguardsize failed with errno = %d\", res);\n+    }\n+    int guard_pages = align_up(guard_bytes, page_bytes) \/ page_bytes;\n+    assert(guard_bytes == guard_pages * page_bytes, \"unaligned guard\");\n+\n+#ifdef IA64\n+    \/\/ IA64 has two stacks sharing the same area of memory, a normal\n+    \/\/ stack growing downwards and a register stack growing upwards.\n+    \/\/ Guard pages, if present, are in the centre.  This code splits\n+    \/\/ the stack in two even without guard pages, though in theory\n+    \/\/ there's nothing to stop us allocating more to the normal stack\n+    \/\/ or more to the register stack if one or the other were found\n+    \/\/ to grow faster.\n+    int total_pages = align_down(stack_bytes, page_bytes) \/ page_bytes;\n+    stack_bottom += (total_pages - guard_pages) \/ 2 * page_bytes;\n+#endif \/\/ IA64\n+\n+    stack_bottom += guard_bytes;\n+\n+    pthread_attr_destroy(&attr);\n+  }\n+\n+  assert(os::current_stack_pointer() >= stack_bottom, \"should do\");\n+  assert(os::current_stack_pointer() < stack_bottom + stack_bytes, \"should do\");\n+\n+  *bottom = stack_bottom;\n+  *size = stack_bytes;\n+}\n+\n+address os::current_stack_base() {\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return bottom + size;\n+}\n+\n+size_t os::current_stack_size() {\n+  \/\/ stack size includes normal stack and HotSpot guard pages\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"}]}