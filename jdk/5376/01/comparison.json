{"files":[{"patch":"@@ -3369,0 +3369,3 @@\n+      assert((uintptr_t)addr >= stack_extent,\n+             \"Sanity: addr should be larger than extent, \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+             p2i(addr), stack_extent);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -202,11 +202,0 @@\n-  pthread_attr_t attr;\n-  int res = pthread_getattr_np(pthread_self(), &attr);\n-  if (res != 0) {\n-    if (res == ENOMEM) {\n-      vm_exit_out_of_memory(0, OOM_MMAP_ERROR, \"pthread_getattr_np\");\n-    }\n-    else {\n-      fatal(\"pthread_getattr_np failed with error = %d\", res);\n-    }\n-  }\n-\n@@ -215,5 +204,0 @@\n-  res = pthread_attr_getstack(&attr, (void **) &stack_bottom, &stack_bytes);\n-  if (res != 0) {\n-    fatal(\"pthread_attr_getstack failed with error = %d\", res);\n-  }\n-  address stack_top = stack_bottom + stack_bytes;\n@@ -221,12 +205,15 @@\n-  \/\/ The block of memory returned by pthread_attr_getstack() includes\n-  \/\/ guard pages where present.  We need to trim these off.\n-  size_t page_bytes = os::Linux::page_size();\n-  assert(((intptr_t) stack_bottom & (page_bytes - 1)) == 0, \"unaligned stack\");\n-\n-  size_t guard_bytes;\n-  res = pthread_attr_getguardsize(&attr, &guard_bytes);\n-  if (res != 0) {\n-    fatal(\"pthread_attr_getguardsize failed with errno = %d\", res);\n-  }\n-  int guard_pages = align_up(guard_bytes, page_bytes) \/ page_bytes;\n-  assert(guard_bytes == guard_pages * page_bytes, \"unaligned guard\");\n+  if (os::is_primordial_thread()) {\n+    \/\/ primordial thread needs special handling because pthread_getattr_np()\n+    \/\/ may return bogus value.\n+    stack_bottom = os::Linux::initial_thread_stack_bottom();\n+    stack_bytes  = os::Linux::initial_thread_stack_size();\n+  } else {\n+    pthread_attr_t attr;\n+    int res = pthread_getattr_np(pthread_self(), &attr);\n+    if (res != 0) {\n+      if (res == ENOMEM) {\n+        vm_exit_out_of_memory(0, OOM_MMAP_ERROR, \"pthread_getattr_np\");\n+      } else {\n+        fatal(\"pthread_getattr_np failed with error = %d\", res);\n+      }\n+    }\n@@ -234,11 +221,4 @@\n-#ifdef IA64\n-  \/\/ IA64 has two stacks sharing the same area of memory, a normal\n-  \/\/ stack growing downwards and a register stack growing upwards.\n-  \/\/ Guard pages, if present, are in the centre.  This code splits\n-  \/\/ the stack in two even without guard pages, though in theory\n-  \/\/ there's nothing to stop us allocating more to the normal stack\n-  \/\/ or more to the register stack if one or the other were found\n-  \/\/ to grow faster.\n-  int total_pages = align_down(stack_bytes, page_bytes) \/ page_bytes;\n-  stack_bottom += (total_pages - guard_pages) \/ 2 * page_bytes;\n-#endif \/\/ IA64\n+    res = pthread_attr_getstack(&attr, (void **) &stack_bottom, &stack_bytes);\n+    if (res != 0) {\n+      fatal(\"pthread_attr_getstack failed with error = %d\", res);\n+    }\n@@ -246,1 +226,4 @@\n-  stack_bottom += guard_bytes;\n+    \/\/ The block of memory returned by pthread_attr_getstack() includes\n+    \/\/ guard pages where present.  We need to trim these off.\n+    size_t page_bytes = os::Linux::page_size();\n+    assert(((intptr_t) stack_bottom & (page_bytes - 1)) == 0, \"unaligned stack\");\n@@ -248,1 +231,7 @@\n-  pthread_attr_destroy(&attr);\n+    size_t guard_bytes;\n+    res = pthread_attr_getguardsize(&attr, &guard_bytes);\n+    if (res != 0) {\n+      fatal(\"pthread_attr_getguardsize failed with errno = %d\", res);\n+    }\n+    int guard_pages = align_up(guard_bytes, page_bytes) \/ page_bytes;\n+    assert(guard_bytes == guard_pages * page_bytes, \"unaligned guard\");\n@@ -250,5 +239,11 @@\n-  \/\/ The initial thread has a growable stack, and the size reported\n-  \/\/ by pthread_attr_getstack is the maximum size it could possibly\n-  \/\/ be given what currently mapped.  This can be huge, so we cap it.\n-  if (os::is_primordial_thread()) {\n-    stack_bytes = stack_top - stack_bottom;\n+#ifdef IA64\n+    \/\/ IA64 has two stacks sharing the same area of memory, a normal\n+    \/\/ stack growing downwards and a register stack growing upwards.\n+    \/\/ Guard pages, if present, are in the centre.  This code splits\n+    \/\/ the stack in two even without guard pages, though in theory\n+    \/\/ there's nothing to stop us allocating more to the normal stack\n+    \/\/ or more to the register stack if one or the other were found\n+    \/\/ to grow faster.\n+    int total_pages = align_down(stack_bytes, page_bytes) \/ page_bytes;\n+    stack_bottom += (total_pages - guard_pages) \/ 2 * page_bytes;\n+#endif \/\/ IA64\n@@ -256,2 +251,1 @@\n-    if (stack_bytes > JavaThread::stack_size_at_create())\n-      stack_bytes = JavaThread::stack_size_at_create();\n+    stack_bottom += guard_bytes;\n@@ -259,1 +253,1 @@\n-    stack_bottom = stack_top - stack_bytes;\n+    pthread_attr_destroy(&attr);\n@@ -263,1 +257,1 @@\n-  assert(os::current_stack_pointer() < stack_top, \"should do\");\n+  assert(os::current_stack_pointer() < stack_bottom + stack_bytes, \"should do\");\n@@ -266,1 +260,1 @@\n-  *size = stack_top - stack_bottom;\n+  *size = stack_bytes;\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":45,"deletions":51,"binary":false,"changes":96,"status":"modified"}]}