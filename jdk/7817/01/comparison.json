{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -79,0 +80,8 @@\n+    public Cluster getFromCluster() {\n+        return null;\n+    }\n+\n+    public Cluster getToCluster() {\n+        return null;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockConnectionWidget.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,8 @@\n+        public Cluster getFromCluster() {\n+            return null;\n+        }\n+\n+        public Cluster getToCluster() {\n+            return null;\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/HierarchicalGraphLayout.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+    private boolean artificial;\n@@ -80,0 +81,1 @@\n+        artificial = false;\n@@ -104,0 +106,4 @@\n+    public void setNodes(List<InputNode> nodes) {\n+        this.nodes = nodes;\n+    }\n+\n@@ -114,0 +120,8 @@\n+\n+    void setArtificial(boolean artificial) {\n+        this.artificial = artificial;\n+    }\n+\n+    public boolean isArtificial() {\n+        return artificial;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+    private String label;\n@@ -42,1 +43,1 @@\n-    public InputBlockEdge(InputBlock from, InputBlock to) {\n+    public InputBlockEdge(InputBlock from, InputBlock to, String label) {\n@@ -47,0 +48,1 @@\n+        this.label = label;\n@@ -65,0 +67,4 @@\n+    public String getLabel() {\n+        return label;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlockEdge.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,5 @@\n-        InputBlockEdge edge = new InputBlockEdge(left, right);\n+        return addBlockEdge(left, right, null);\n+    }\n+\n+    public InputBlockEdge addBlockEdge(InputBlock left, InputBlock right, String label) {\n+        InputBlockEdge edge = new InputBlockEdge(left, right, label);\n@@ -143,0 +147,1 @@\n+        blockEdges.clear();\n@@ -171,1 +176,1 @@\n-                    noBlock = this.addBlock(\"(no block)\");\n+                    noBlock = addArtificialBlock();\n@@ -273,0 +278,6 @@\n+    public InputBlock addArtificialBlock() {\n+        InputBlock b = addBlock(\"(no block)\");\n+        b.setArtificial(true);\n+        return b;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,1 @@\n-                                noBlock = graph.addBlock(\"(no block)\");\n+                                noBlock = graph.addArtificialBlock();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-            for (Connection c : s.getConnections()) {\n+            for (FigureConnection c : s.getConnections()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ColorFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-                            for (Connection c : s.getConnections()) {\n+                            for (FigureConnection c : s.getConnections()) {\n@@ -100,2 +100,2 @@\n-                            for (Connection c : s.getConnections()) {\n-                                Connection newConn = diagram.createConnection(slot, c.getOutputSlot(), c.getLabel(), c.getType());\n+                            for (FigureConnection c : s.getConnections()) {\n+                                FigureConnection newConn = diagram.createConnection(slot, c.getOutputSlot(), c.getLabel());\n@@ -118,1 +118,1 @@\n-                                    for (Connection c : s.getConnections()) {\n+                                    for (FigureConnection c : s.getConnections()) {\n@@ -158,2 +158,2 @@\n-                                for (Connection c : nextSlot.getConnections()) {\n-                                    Connection newConn = diagram.createConnection(c.getInputSlot(), slot, c.getLabel(), c.getType());\n+                                for (FigureConnection c : nextSlot.getConnections()) {\n+                                    FigureConnection newConn = diagram.createConnection(c.getInputSlot(), slot, c.getLabel());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CombineFilter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-                    for (Connection c : os.getConnections()) {\n+                    for (FigureConnection c : os.getConnections()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ConnectionFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-                    for (Connection c : slot.getConnections()) {\n+                    for (FigureConnection c : slot.getConnections()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/EdgeColorIndexFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.filter;\n+\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Block;\n+import com.sun.hotspot.igv.graph.BlockSelector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class RemoveBlockFilter extends AbstractFilter {\n+\n+    private final List<RemoveBlockRule> rules;\n+    private final String name;\n+\n+    public RemoveBlockFilter(String name) {\n+        this.name = name;\n+        rules = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public void apply(Diagram diagram) {\n+        for (RemoveBlockRule r : rules) {\n+            List<Block> selected = r.getBlockSelector().selected(diagram);\n+            Set<Block> toRemove = new HashSet<>(selected);\n+            diagram.removeAllBlocks(toRemove);\n+        }\n+    }\n+\n+    public void addRule(RemoveBlockRule rule) {\n+        rules.add(rule);\n+    }\n+\n+    public static class RemoveBlockRule {\n+\n+        private final BlockSelector selector;\n+\n+        public RemoveBlockRule(BlockSelector selector) {\n+            this.selector = selector;\n+        }\n+\n+        public BlockSelector getBlockSelector() {\n+            return selector;\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveBlockFilter.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-                        List<Connection> conns = is.getConnections();\n+                        List<FigureConnection> conns = is.getConnections();\n@@ -63,1 +63,1 @@\n-                            Connection c = conns.get(i);\n+                            FigureConnection c = conns.get(i);\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveInputsFilter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-                List<Connection> toRemove = new ArrayList<>();\n-                for (Connection c : is.getConnections()) {\n+                List<FigureConnection> toRemove = new ArrayList<>();\n+                for (FigureConnection c : is.getConnections()) {\n@@ -63,1 +63,1 @@\n-                for (Connection c : toRemove) {\n+                for (FigureConnection c : toRemove) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveSelfLoopsFilter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-                for (Connection c : is.getConnections()) {\n+                for (FigureConnection c : is.getConnections()) {\n@@ -74,1 +74,1 @@\n-                for (Connection c : os.getConnections()) {\n+                for (FigureConnection c : os.getConnections()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/SplitFilter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.hotspot.igv.graph.Connection;\n+import com.sun.hotspot.igv.graph.FigureConnection;\n@@ -45,1 +45,1 @@\n-        Set<Connection> connectionsToRemove = new HashSet<>();\n+        Set<FigureConnection> connectionsToRemove = new HashSet<>();\n@@ -60,1 +60,1 @@\n-                    for (Connection c : is.getConnections()) {\n+                    for (FigureConnection c : is.getConnections()) {\n@@ -69,1 +69,1 @@\n-        for (Connection c : connectionsToRemove) {\n+        for (FigureConnection c : connectionsToRemove) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Graal\/src\/main\/java\/com\/sun\/hotspot\/igv\/graal\/filters\/GraalCFGFilter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -28,2 +27,0 @@\n-import com.sun.hotspot.igv.graph.Connection;\n-import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n@@ -31,2 +28,0 @@\n-import com.sun.hotspot.igv.graph.Figure;\n-import com.sun.hotspot.igv.graph.InputSlot;\n@@ -35,1 +30,0 @@\n-import java.util.List;\n@@ -57,23 +51,0 @@\n-        List<Figure> figures = d.getFigures();\n-        for (Figure f : figures) {\n-            for (InputSlot is : f.getInputSlots()) {\n-                for (Connection c : is.getConnections()) {\n-                    String type = c.getType();\n-                    if (type == \"Association\" && \"EndNode\".equals(c.getOutputSlot().getFigure().getProperties().get(\"class\"))) {\n-                        type = \"Successor\";\n-                    }\n-\n-                    if (type != null) {\n-                        Color typeColor = usageColor.get(type);\n-                        if (typeColor == null) {\n-                            c.setColor(otherUsageColor);\n-                        } else {\n-                            c.setColor(typeColor);\n-                        }\n-                        if (c.getStyle() != ConnectionStyle.DASHED && type == \"Successor\") {\n-                            c.setStyle(ConnectionStyle.BOLD);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graal\/src\/main\/java\/com\/sun\/hotspot\/igv\/graal\/filters\/GraalEdgeColorFilter.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+\/\/ Selects blocks where any node is selected.\n+public class AnySelector implements BlockSelector {\n+\n+    private final Selector selector;\n+\n+    public AnySelector(Selector s) {\n+        this.selector = s;\n+    }\n+\n+    @Override\n+    public List<Block> selected(Diagram d) {\n+        List<Block> l = new ArrayList<>();\n+        for (Figure f : selector.selected(d)) {\n+            l.add(d.getBlock(f.getBlock()));\n+        }\n+        return l;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/AnySelector.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.awt.Dimension;\n@@ -58,1 +59,3 @@\n-            succs.add(diagram.getBlock(b));\n+            if (diagram.hasBlock(b)) {\n+                succs.add(diagram.getBlock(b));\n+            }\n@@ -63,0 +66,4 @@\n+    public Dimension getNodeOffset() {\n+        return new Dimension(0, -Figure.getVerticalOffset());\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import com.sun.hotspot.igv.layout.Port;\n+import java.awt.Color;\n+import java.awt.Point;\n+import java.util.List;\n+\n+public class BlockConnection implements Connection {\n+\n+    private final Block sourceBlock;\n+    private final Block destinationBlock;\n+    private final String label;\n+    private List<Point> controlPoints;\n+\n+    public BlockConnection(Block src, Block dst, String label) {\n+        this.sourceBlock = src;\n+        this.destinationBlock = dst;\n+        this.label = label;\n+    }\n+\n+    public Color getColor() {\n+        return Color.BLUE;\n+    }\n+\n+    public ConnectionStyle getStyle() {\n+        return ConnectionStyle.BOLD;\n+    }\n+\n+    @Override\n+    public String getToolTipText() {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(\"B\").append(sourceBlock.getInputBlock().getName())\n+               .append(\" → B\").append(destinationBlock.getInputBlock().getName());\n+        if (label != null) {\n+            builder.append(\": \").append(label);\n+        }\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BlockConnection('\" + label + \"', \" + getFromCluster() + \" to \" + getToCluster() + \")\";\n+    }\n+\n+    @Override\n+    public Port getFrom() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Block getFromCluster() {\n+        return sourceBlock;\n+    }\n+\n+    @Override\n+    public Port getTo() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Block getToCluster() {\n+        return destinationBlock;\n+    }\n+\n+    @Override\n+    public boolean isVIP() {\n+        return true;\n+    }\n+\n+    @Override\n+    public List<Point> getControlPoints() {\n+        return controlPoints;\n+    }\n+\n+    @Override\n+    public void setControlPoints(List<Point> list) {\n+        controlPoints = list;\n+    }\n+\n+    @Override\n+    public boolean isAlwaysVisible() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean hasSlots() {\n+        return false;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/BlockConnection.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import java.util.List;\n+\n+public interface BlockSelector {\n+    List<Block> selected(Diagram d);\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/BlockSelector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.Source;\n@@ -28,1 +27,0 @@\n-import com.sun.hotspot.igv.layout.Port;\n@@ -30,3 +28,0 @@\n-import java.awt.Point;\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -34,10 +29,1 @@\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Connection implements Source.Provider, Link {\n-\n-    @Override\n-    public boolean isVIP() {\n-        return style == ConnectionStyle.BOLD;\n-    }\n+public interface Connection extends Link {\n@@ -46,1 +32,0 @@\n-\n@@ -52,30 +37,0 @@\n-    private InputSlot inputSlot;\n-    private OutputSlot outputSlot;\n-    private Source source;\n-    private Color color;\n-    private ConnectionStyle style;\n-    private List<Point> controlPoints;\n-    private String label;\n-    private String type;\n-\n-    protected Connection(InputSlot inputSlot, OutputSlot outputSlot, String label, String type) {\n-        this.inputSlot = inputSlot;\n-        this.outputSlot = outputSlot;\n-        this.label = label;\n-        this.type = type;\n-        this.inputSlot.connections.add(this);\n-        this.outputSlot.connections.add(this);\n-        controlPoints = new ArrayList<>();\n-        Figure sourceFigure = this.outputSlot.getFigure();\n-        Figure destFigure = this.inputSlot.getFigure();\n-        sourceFigure.addSuccessor(destFigure);\n-        destFigure.addPredecessor(sourceFigure);\n-        source = new Source();\n-\n-        this.color = Color.BLACK;\n-        this.style = ConnectionStyle.NORMAL;\n-    }\n-\n-    public InputSlot getInputSlot() {\n-        return inputSlot;\n-    }\n@@ -83,3 +38,1 @@\n-    public OutputSlot getOutputSlot() {\n-        return outputSlot;\n-    }\n+    public ConnectionStyle getStyle();\n@@ -87,3 +40,1 @@\n-    public Color getColor() {\n-        return color;\n-    }\n+    public Color getColor();\n@@ -91,3 +42,1 @@\n-    public ConnectionStyle getStyle() {\n-        return style;\n-    }\n+    public String getToolTipText();\n@@ -95,3 +44,1 @@\n-    public void setColor(Color c) {\n-        color = c;\n-    }\n+    public boolean isAlwaysVisible();\n@@ -99,8 +46,1 @@\n-    public void setStyle(ConnectionStyle s) {\n-        style = s;\n-    }\n-\n-    @Override\n-    public Source getSource() {\n-        return source;\n-    }\n+    public boolean hasSlots();\n@@ -108,56 +48,0 @@\n-    public String getLabel() {\n-        return label;\n-    }\n-\n-    public String getType() {\n-        return type;\n-    }\n-\n-    public void remove() {\n-        inputSlot.getFigure().removePredecessor(outputSlot.getFigure());\n-        inputSlot.connections.remove(this);\n-        outputSlot.getFigure().removeSuccessor(inputSlot.getFigure());\n-        outputSlot.connections.remove(this);\n-    }\n-\n-    public String getToolTipText() {\n-        StringBuilder builder = new StringBuilder();\n-        if (label != null) {\n-            builder.append(label).append(\": \");\n-        }\n-        if (type != null) {\n-            builder.append(type).append(\" \");\n-        }\n-        \/\/ Resolve strings lazily every time the tooltip is shown, instead of\n-        \/\/ eagerly as for node labels, for efficiency.\n-        String shortNodeText = getInputSlot().getFigure().getDiagram().getShortNodeText();\n-        builder.append(getOutputSlot().getFigure().getProperties().resolveString(shortNodeText));\n-        builder.append(\" → \");\n-        builder.append(getInputSlot().getFigure().getProperties().resolveString(shortNodeText));\n-        return builder.toString();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Connection('\" + label + \"', \" + getFrom().getVertex() + \" to \" + getTo().getVertex() + \")\";\n-    }\n-\n-    @Override\n-    public Port getFrom() {\n-        return outputSlot;\n-    }\n-\n-    @Override\n-    public Port getTo() {\n-        return inputSlot;\n-    }\n-\n-    @Override\n-    public List<Point> getControlPoints() {\n-        return controlPoints;\n-    }\n-\n-    @Override\n-    public void setControlPoints(List<Point> list) {\n-        controlPoints = list;\n-    }\n@@ -165,1 +49,0 @@\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Connection.java","additions":7,"deletions":124,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -33,0 +34,1 @@\n+import java.awt.Color;\n@@ -47,0 +49,1 @@\n+    private String tinyNodeText;\n@@ -50,0 +53,4 @@\n+    \/\/ Whether widgets derived from this diagram should be adapted for the\n+    \/\/ control-flow graph view.\n+    private boolean cfg;\n+    private final Set<BlockConnection> blockConnections;\n@@ -63,1 +70,10 @@\n-    private Diagram() {\n+    public boolean isCFG() {\n+        return cfg;\n+    }\n+\n+    public void setCFG(boolean cfg) {\n+        this.cfg = cfg;\n+    }\n+\n+    private Diagram(InputGraph graph, String nodeText, String shortNodeText,\n+                    String tinyNodeText) {\n@@ -71,0 +87,6 @@\n+        this.cfg = false;\n+        this.blockConnections = new HashSet<>();\n+        this.graph = graph;\n+        this.nodeText = nodeText;\n+        this.shortNodeText = shortNodeText;\n+        this.tinyNodeText = tinyNodeText;\n@@ -78,0 +100,4 @@\n+    public boolean hasBlock(InputBlock b) {\n+        return blocks.containsKey(b);\n+    }\n+\n@@ -86,0 +112,4 @@\n+    public String getTinyNodeText() {\n+        return tinyNodeText;\n+    }\n+\n@@ -94,4 +124,0 @@\n-    public Diagram getNext() {\n-        return Diagram.createDiagram(graph.getNext(), nodeText, shortNodeText);\n-    }\n-\n@@ -102,4 +128,0 @@\n-    public Diagram getPrev() {\n-        return Diagram.createDiagram(graph.getPrev(), nodeText, shortNodeText);\n-    }\n-\n@@ -117,1 +139,1 @@\n-    public Connection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label, String type) {\n+    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n@@ -120,1 +142,1 @@\n-        return new Connection(inputSlot, outputSlot, label, type);\n+        return new FigureConnection(inputSlot, outputSlot, label);\n@@ -140,1 +162,2 @@\n-                                        String shortNodeText) {\n+                                        String shortNodeText,\n+                                        String tinyNodeText) {\n@@ -145,5 +168,1 @@\n-        Diagram d = new Diagram();\n-        d.graph = graph;\n-        d.nodeText = nodeText;\n-        d.shortNodeText = shortNodeText;\n-\n+        Diagram d = new Diagram(graph, nodeText, shortNodeText, tinyNodeText);\n@@ -159,0 +178,1 @@\n+            f.setBlock(graph.getBlock(n));\n@@ -184,1 +204,1 @@\n-            Connection c = d.createConnection(inputSlot, outputSlot, e.getLabel(), e.getType());\n+            FigureConnection c = d.createConnection(inputSlot, outputSlot, e.getLabel());\n@@ -193,0 +213,5 @@\n+        for (InputBlockEdge e : graph.getBlockEdges()) {\n+            Block p = d.getBlock(e.getFrom());\n+            Block s = d.getBlock(e.getTo());\n+            d.blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n+        }\n@@ -197,0 +222,15 @@\n+    public void removeAllBlocks(Set<Block> blocksToRemove) {\n+        Set<Figure> figuresToRemove = new HashSet<>();\n+        for (Block b : blocksToRemove) {\n+            for (Figure f : getFigures()) {\n+                if (f.getBlock() == b.getInputBlock()) {\n+                    figuresToRemove.add(f);\n+                }\n+            }\n+        }\n+        removeAllFigures(figuresToRemove);\n+        for (Block b : blocksToRemove) {\n+            blocks.remove(b.getInputBlock());\n+        }\n+    }\n+\n@@ -231,1 +271,0 @@\n-\n@@ -245,3 +284,2 @@\n-    public Set<Connection> getConnections() {\n-\n-        Set<Connection> connections = new HashSet<>();\n+    public Set<FigureConnection> getConnections() {\n+        Set<FigureConnection> connections = new HashSet<>();\n@@ -249,1 +287,0 @@\n-\n@@ -254,0 +291,2 @@\n+        return connections;\n+    }\n@@ -255,0 +294,8 @@\n+    public Set<BlockConnection> getBlockConnections() {\n+        Set<BlockConnection> connections = new HashSet<>();\n+        for (BlockConnection bc : blockConnections) {\n+            if (blocks.containsKey(bc.getFromCluster().getInputBlock()) &&\n+                blocks.containsKey(bc.getToCluster().getInputBlock())) {\n+                connections.add(bc);\n+            }\n+        }\n@@ -281,1 +328,1 @@\n-        Set<Connection> connections = getConnections();\n+        Set<FigureConnection> connections = getConnections();\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":72,"deletions":25,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.awt.image.BufferedImage;\n@@ -41,1 +40,1 @@\n-    public static int SLOT_WIDTH = 10;\n+    public static final int SLOT_WIDTH = 10;\n@@ -45,1 +44,2 @@\n-    public static final boolean VERTICAL_LAYOUT = true;\n+    public static final int TOP_CFG_HEIGHT = 7;\n+    public static final int BOTTOM_CFG_HEIGHT = 6;\n@@ -60,0 +60,2 @@\n+    private InputBlock block;\n+    private FontMetrics metrics;\n@@ -63,6 +65,1 @@\n-            BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n-            Graphics g = image.getGraphics();\n-            g.setFont(diagram.getFont().deriveFont(Font.BOLD));\n-            FontMetrics metrics = g.getFontMetrics();\n-            String nodeText = diagram.getNodeText();\n-            heightCash = nodeText.split(\"\\n\").length * metrics.getHeight() + INSET;\n+            updateHeight();\n@@ -73,0 +70,17 @@\n+    private void updateHeight() {\n+        String nodeText = diagram.getNodeText();\n+        int lines = nodeText.split(\"\\n\").length;\n+        if (hasInputList() && lines > 1) {\n+            lines++;\n+        }\n+        heightCash = lines * metrics.getHeight() + INSET;\n+        if (diagram.isCFG()) {\n+            if (hasNamedInputSlot()) {\n+                heightCash += TOP_CFG_HEIGHT;\n+            }\n+            if (hasNamedOutputSlot()) {\n+                heightCash += BOTTOM_CFG_HEIGHT;\n+            }\n+        }\n+    }\n+\n@@ -94,0 +108,10 @@\n+            updateWidth();\n+        }\n+        return widthCash;\n+    }\n+\n+    public void setWidth(int width) {\n+        widthCash = width;\n+    }\n+\n+    private void updateWidth() {\n@@ -95,4 +119,0 @@\n-            BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n-            Graphics g = image.getGraphics();\n-            g.setFont(diagram.getFont().deriveFont(Font.BOLD));\n-            FontMetrics metrics = g.getFontMetrics();\n@@ -108,2 +128,0 @@\n-        }\n-        return widthCash;\n@@ -124,0 +142,2 @@\n+        Canvas canvas = new Canvas();\n+        metrics = canvas.getFontMetrics(diagram.getFont().deriveFont(Font.BOLD));\n@@ -138,0 +158,12 @@\n+    public boolean hasInputList() {\n+        return diagram.isCFG() && !getPredecessors().isEmpty();\n+    }\n+\n+    public void setBlock(InputBlock block) {\n+        this.block = block;\n+    }\n+\n+    public InputBlock getBlock() {\n+        return block;\n+    }\n+\n@@ -224,2 +256,2 @@\n-        List<Connection> connections = new ArrayList<>(s.getConnections());\n-        for (Connection c : connections) {\n+        List<FigureConnection> connections = new ArrayList<>(s.getConnections());\n+        for (FigureConnection c : connections) {\n@@ -264,0 +296,18 @@\n+    public boolean hasNamedInputSlot() {\n+        for (InputSlot is : getInputSlots()) {\n+            if (is.hasSourceNodes() && is.shouldShowName()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean hasNamedOutputSlot() {\n+        for (OutputSlot os : getOutputSlots()) {\n+            if (os.hasSourceNodes() && os.shouldShowName()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -277,7 +327,0 @@\n-            \/\/ Set the \"label\" property of each input node, so that by default\n-            \/\/ search is done on the node label (without line breaks). See also\n-            \/\/ class NodeQuickSearch in the View module.\n-            for (InputNode n : getSource().getSourceNodes()) {\n-                String label = n.getProperties().resolveString(diagram.getNodeText());\n-                n.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n-            }\n@@ -290,1 +333,1 @@\n-        String[] result = new String[strings.length];\n+        List<String> result = new ArrayList<>(strings.length + 1);\n@@ -293,1 +336,1 @@\n-            result[i] = getProperties().resolveString(strings[i]);\n+            result.add(getProperties().resolveString(strings[i]));\n@@ -296,1 +339,27 @@\n-        lines = result;\n+        if (hasInputList()) {\n+            String inputList = \" ← \";\n+            List<String> inputs = new ArrayList<String>(getPredecessors().size());\n+            for (Figure p : getPredecessors()) {\n+                inputs.add(p.getProperties().resolveString(diagram.getTinyNodeText()));\n+            }\n+            inputList += String.join(\"  \", inputs);\n+            if (result.size() == 1) {\n+                \/\/ Single-line node, append input list to line.\n+                result.set(0, result.get(0) + inputList);\n+            } else {\n+                \/\/ Multi-line node, add yet another line for input list.\n+                result.add(inputList);\n+            }\n+        }\n+\n+        lines = result.toArray(new String[0]);\n+        \/\/ Set the \"label\" property of each input node, so that by default\n+        \/\/ search is done on the node label (without line breaks). See also\n+        \/\/ class NodeQuickSearch in the View module.\n+        for (InputNode n : getSource().getSourceNodes()) {\n+            String label = n.getProperties().resolveString(diagram.getNodeText());\n+            n.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n+        }\n+        \/\/ Update figure dimensions, as these are affected by the node text.\n+        updateWidth();\n+        updateHeight();\n@@ -301,11 +370,3 @@\n-        if (VERTICAL_LAYOUT) {\n-            int width = Math.max(getWidth(), Figure.SLOT_WIDTH * (Math.max(inputSlots.size(), outputSlots.size()) + 1));\n-            int height = getHeight() + 2 * Figure.SLOT_WIDTH - 2 * Figure.OVERLAPPING;\n-\n-\n-            return new Dimension(width, height);\n-        } else {\n-            int width = getWidth() + 2 * Figure.SLOT_WIDTH - 2*Figure.OVERLAPPING;\n-            int height = Figure.SLOT_WIDTH * (Math.max(inputSlots.size(), outputSlots.size()) + 1);\n-            return new Dimension(width, height);\n-        }\n+        int width = Math.max(getWidth(), Figure.SLOT_WIDTH * (Math.max(inputSlots.size(), outputSlots.size()) + 1));\n+        int height = getHeight() + (diagram.isCFG() ? 0 : 2 * Figure.SLOT_WIDTH - 2 * Figure.OVERLAPPING);\n+        return new Dimension(width, height);\n@@ -319,0 +380,8 @@\n+    public InputNode getFirstSourceNode() {\n+        return getSource().getSourceNodes().get(0);\n+    }\n+\n+    public static int getVerticalOffset() {\n+        return Figure.SLOT_WIDTH - Figure.OVERLAPPING;\n+    }\n+\n@@ -324,1 +393,1 @@\n-            final InputBlock inputBlock = diagram.getGraph().getBlock(getSource().getSourceNodes().get(0));\n+            final InputBlock inputBlock = diagram.getGraph().getBlock(getFirstSourceNode());\n@@ -336,2 +405,2 @@\n-        if (sourceNodes.size() > 0 && sourceNodes.get(0).getProperties().get(\"name\") != null) {\n-            return source.getSourceNodes().get(0).getProperties().get(\"name\").equals(\"Root\");\n+        if (sourceNodes.size() > 0 && getFirstSourceNode().getProperties().get(\"name\") != null) {\n+            return getFirstSourceNode().getProperties().get(\"name\").equals(\"Root\");\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":111,"deletions":42,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import com.sun.hotspot.igv.layout.Port;\n+import com.sun.hotspot.igv.layout.Cluster;\n+import java.awt.Color;\n+import java.awt.Point;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ *\n+ * @author Thomas Wuerthinger\n+ *\/\n+public class FigureConnection implements Connection {\n+\n+    private final InputSlot inputSlot;\n+    private final OutputSlot outputSlot;\n+    private Color color;\n+    private ConnectionStyle style;\n+    private List<Point> controlPoints;\n+    private String label;\n+\n+    protected FigureConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n+        this.inputSlot = inputSlot;\n+        this.outputSlot = outputSlot;\n+        this.label = label;\n+        this.inputSlot.connections.add(this);\n+        this.outputSlot.connections.add(this);\n+        controlPoints = new ArrayList<>();\n+        Figure sourceFigure = this.outputSlot.getFigure();\n+        Figure destFigure = this.inputSlot.getFigure();\n+        sourceFigure.addSuccessor(destFigure);\n+        destFigure.addPredecessor(sourceFigure);\n+\n+        this.color = Color.BLACK;\n+        this.style = ConnectionStyle.NORMAL;\n+    }\n+\n+    public InputSlot getInputSlot() {\n+        return inputSlot;\n+    }\n+\n+    public OutputSlot getOutputSlot() {\n+        return outputSlot;\n+    }\n+\n+    public Color getColor() {\n+        return color;\n+    }\n+\n+    public ConnectionStyle getStyle() {\n+        return style;\n+    }\n+\n+    public void setColor(Color c) {\n+        color = c;\n+    }\n+\n+    public void setStyle(ConnectionStyle s) {\n+        style = s;\n+    }\n+\n+    public String getLabel() {\n+        return label;\n+    }\n+\n+    public void remove() {\n+        inputSlot.getFigure().removePredecessor(outputSlot.getFigure());\n+        inputSlot.connections.remove(this);\n+        outputSlot.getFigure().removeSuccessor(inputSlot.getFigure());\n+        outputSlot.connections.remove(this);\n+    }\n+\n+    public String getToolTipText() {\n+        StringBuilder builder = new StringBuilder();\n+        if (label != null) {\n+            builder.append(label).append(\": \");\n+        }\n+        \/\/ Resolve strings lazily every time the tooltip is shown, instead of\n+        \/\/ eagerly as for node labels, for efficiency.\n+        String shortNodeText = getInputSlot().getFigure().getDiagram().getShortNodeText();\n+        builder.append(getOutputSlot().getFigure().getProperties().resolveString(shortNodeText));\n+        builder.append(\" → \");\n+        builder.append(getInputSlot().getFigure().getProperties().resolveString(shortNodeText));\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"FigureConnection('\" + label + \"', \" + getFrom().getVertex() + \" to \" + getTo().getVertex() + \")\";\n+    }\n+\n+    @Override\n+    public Port getFrom() {\n+        return outputSlot;\n+    }\n+\n+    @Override\n+    public Cluster getFromCluster() {\n+        return getFrom().getVertex().getCluster();\n+    }\n+\n+    @Override\n+    public Port getTo() {\n+        return inputSlot;\n+    }\n+\n+    @Override\n+    public Cluster getToCluster() {\n+        return getTo().getVertex().getCluster();\n+    }\n+\n+    @Override\n+    public boolean isVIP() {\n+        return style == ConnectionStyle.BOLD;\n+    }\n+\n+    @Override\n+    public List<Point> getControlPoints() {\n+        return controlPoints;\n+    }\n+\n+    @Override\n+    public void setControlPoints(List<Point> list) {\n+        controlPoints = list;\n+    }\n+\n+    @Override\n+    public boolean isAlwaysVisible() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasSlots() {\n+        return true;\n+    }\n+\n+}\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    protected List<Connection> connections;\n+    protected List<FigureConnection> connections;\n@@ -70,1 +70,1 @@\n-        if (source.getSourceNodes().size() > 0) {\n+        if (hasSourceNodes()) {\n@@ -161,0 +161,4 @@\n+    public boolean hasSourceNodes() {\n+        return !getSource().getSourceNodes().isEmpty();\n+    }\n+\n@@ -181,1 +185,1 @@\n-    public List<Connection> getConnections() {\n+    public List<FigureConnection> getConnections() {\n@@ -186,2 +190,2 @@\n-        List<Connection> connectionsCopy = new ArrayList<>(this.connections);\n-        for (Connection c : connectionsCopy) {\n+        List<FigureConnection> connectionsCopy = new ArrayList<>(this.connections);\n+        for (FigureConnection c : connectionsCopy) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Slot.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -56,0 +57,8 @@\n+    public Cluster getFromCluster() {\n+        return from.getCluster();\n+    }\n+\n+    public Cluster getToCluster() {\n+        return to.getCluster();\n+    }\n+\n@@ -67,0 +76,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return from + \"->\" + to;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -69,0 +70,8 @@\n+    public Cluster getFromCluster() {\n+        return null;\n+    }\n+\n+    public Cluster getToCluster() {\n+        return null;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-                p.x += ClusterNode.BORDER;\n+                p.x += blockNode.getBorder();\n@@ -145,0 +145,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterInputSlotNode.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,3 +54,8 @@\n-    public static final int BORDER = 20;\n-\n-    public ClusterNode(Cluster cluster, String name) {\n+    private final int border;\n+    private final Dimension nodeOffset;\n+    private final int headerVerticalSpace;\n+    private final Dimension emptySize;\n+\n+    public ClusterNode(Cluster cluster, String name, int border,\n+                       Dimension nodeOffset, int headerVerticalSpace,\n+                       Dimension emptySize) {\n@@ -62,0 +67,15 @@\n+        this.border = border;\n+        this.nodeOffset = nodeOffset;\n+        this.headerVerticalSpace = headerVerticalSpace;\n+        this.emptySize = emptySize;\n+        if (emptySize.width > 0 || emptySize.height > 0) {\n+            updateSize();\n+        }\n+    }\n+\n+    public ClusterNode(Cluster cluster, String name) {\n+        this(cluster, name, 20, new Dimension(0, 0), 0, new Dimension(0, 0));\n+    }\n+\n+    public String getName() {\n+        return name;\n@@ -91,0 +111,5 @@\n+\n+            @Override\n+            public String toString() {\n+                return \"ClusterInput(\" + name + \")\";\n+            }\n@@ -102,0 +127,5 @@\n+\n+            @Override\n+            public String toString() {\n+                return \"ClusterOutput(\" + name + \")\";\n+            }\n@@ -107,2 +137,3 @@\n-        if (subNodes.size() == 0) {\n-            size = new Dimension(0, 0);\n+        if (subNodes.isEmpty()) {\n+            size = emptySize;\n+            return;\n@@ -137,1 +168,1 @@\n-        size = new Dimension(maxX - minX, maxY - minY);\n+        size = new Dimension(maxX - minX, maxY - minY + headerVerticalSpace);\n@@ -141,1 +172,2 @@\n-            n.setPosition(new Point(n.getPosition().x - minX, n.getPosition().y - minY));\n+            n.setPosition(new Point(n.getPosition().x - minX + nodeOffset.width,\n+                                    n.getPosition().y - minY + nodeOffset.height + headerVerticalSpace));\n@@ -154,2 +186,2 @@\n-        size.width += 2 * BORDER;\n-        size.height += 2 * BORDER;\n+        size.width += 2 * border;\n+        size.height += 2 * border;\n@@ -180,1 +212,1 @@\n-            cur.translate(pos.x + BORDER, pos.y + BORDER);\n+            cur.translate(pos.x + border, pos.y + border);\n@@ -190,1 +222,1 @@\n-                    p2.translate(pos.x + BORDER, pos.y + BORDER);\n+                    p2.translate(pos.x + border, pos.y + border);\n@@ -221,0 +253,4 @@\n+    public int getBorder() {\n+        return border;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -61,0 +62,8 @@\n+    public Cluster getFromCluster() {\n+        return null;\n+    }\n+\n+    public Cluster getToCluster() {\n+        return null;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-                p.x += ClusterNode.BORDER;\n+                p.x += blockNode.getBorder();\n@@ -145,0 +145,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutputSlotNode.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.awt.Canvas;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.util.*;\n+import com.sun.hotspot.igv.layout.Cluster;\n+import com.sun.hotspot.igv.layout.LayoutGraph;\n+import com.sun.hotspot.igv.layout.LayoutManager;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n+\n+public class HierarchicalCFGLayoutManager implements LayoutManager {\n+\n+    private static final int BLOCK_BORDER = 5;\n+    private FontMetrics fontMetrics;\n+    \/\/ Lays out nodes within a single cluster (basic block).\n+    private LayoutManager subManager;\n+    \/\/ Lays out clusters in the CFG.\n+    private LayoutManager manager;\n+    private Set<Cluster> clusters;\n+\n+    public HierarchicalCFGLayoutManager() {\n+        \/\/ Anticipate block label sizes to dimension blocks appropriately.\n+        Canvas canvas = new Canvas();\n+        Font font = new Font(\"Arial\", Font.BOLD, 14);\n+        fontMetrics = canvas.getFontMetrics(font);\n+    }\n+\n+    public void setSubManager(LayoutManager manager) {\n+        this.subManager = manager;\n+    }\n+\n+    public void setManager(LayoutManager manager) {\n+        this.manager = manager;\n+    }\n+\n+    public void setClusters(Set<Cluster> clusters) {\n+        this.clusters = clusters;\n+    }\n+\n+    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n+        doLayout(graph);\n+    }\n+\n+    public void doLayout(LayoutGraph graph) {\n+\n+        \/\/ Create cluster-level nodes and edges.\n+        Map<Cluster, ClusterNode> clusterNode = createClusterNodes(graph);\n+        Set<ClusterEdge> clusterEdges = createClusterEdges(clusterNode);\n+        markRootClusters(clusterEdges);\n+\n+        \/\/ Compute layout for each cluster.\n+        for (Cluster c : clusters) {\n+            ClusterNode n = clusterNode.get(c);\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<Link>());\n+            n.updateSize();\n+        }\n+\n+        \/\/ Compute inter-cluster layout.\n+        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())),\n+                         new HashSet<Link>());\n+\n+        \/\/ Write back results.\n+        writeBackClusterBounds(clusterNode);\n+        writeBackClusterEdgePoints(graph, clusterEdges);\n+    }\n+\n+    private Map<Cluster, ClusterNode> createClusterNodes(LayoutGraph graph) {\n+        Map<Cluster, ClusterNode> clusterNode = new HashMap<>();\n+        for (Cluster c : clusters) {\n+            String blockLabel = \"B\" + c;\n+            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + BLOCK_BORDER * 2,\n+                                                fontMetrics.getHeight() + BLOCK_BORDER);\n+            ClusterNode cn = new ClusterNode(c, c.toString(), BLOCK_BORDER, c.getNodeOffset(),\n+                                             fontMetrics.getHeight(), emptySize);\n+            clusterNode.put(c, cn);\n+        }\n+\n+        for (Vertex v : graph.getVertices()) {\n+            Cluster c = v.getCluster();\n+            assert c != null : \"Cluster of vertex \" + v + \" is null!\";\n+            clusterNode.get(c).addSubNode(v);\n+        }\n+        return clusterNode;\n+    }\n+\n+    private Set<ClusterEdge> createClusterEdges(Map<Cluster, ClusterNode> clusterNode) {\n+        Set<ClusterEdge> clusterEdges = new HashSet<>();\n+        for (Cluster c : clusters) {\n+            ClusterNode start = clusterNode.get(c);\n+            for (Cluster succ : c.getSuccessors()) {\n+                ClusterNode end = clusterNode.get(succ);\n+                if (end != null) {\n+                    ClusterEdge e = new ClusterEdge(start, end);\n+                    clusterEdges.add(e);\n+                }\n+            }\n+        }\n+        return clusterEdges;\n+    }\n+\n+    private void markRootClusters(Set<ClusterEdge> clusterEdges) {\n+        Set<Vertex> roots = new LayoutGraph(clusterEdges).findRootVertices();\n+        for (Vertex v : roots) {\n+            assert v instanceof ClusterNode;\n+            ((ClusterNode) v).setRoot(true);\n+        }\n+    }\n+\n+    private void writeBackClusterBounds(Map<Cluster, ClusterNode> clusterNode) {\n+        for (Cluster c : clusters) {\n+            ClusterNode n = clusterNode.get(c);\n+            c.setBounds(new Rectangle(n.getPosition(), n.getSize()));\n+        }\n+    }\n+\n+    private void writeBackClusterEdgePoints(LayoutGraph graph, Set<ClusterEdge> clusterEdges) {\n+        \/\/ Map from \"primitive\" cluster edges to their input links.\n+        Map<AbstractMap.SimpleEntry<Cluster, Cluster>, Link> inputLink = new HashMap<>();\n+        for (Link l : graph.getLinks()) {\n+            inputLink.put(new AbstractMap.SimpleEntry<Cluster, Cluster>(l.getFromCluster(), l.getToCluster()), l);\n+        }\n+        for (ClusterEdge ce : clusterEdges) {\n+            assert (ce.getControlPoints() != null);\n+            Link l = inputLink.get(new AbstractMap.SimpleEntry<Cluster, Cluster>(ce.getFromCluster(), ce.getToCluster()));\n+            l.setControlPoints(ce.getControlPoints());\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -248,3 +248,0 @@\n-\n-    public void doRouting(LayoutGraph graph) {\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private boolean layoutSelfEdges;\n@@ -68,0 +69,1 @@\n+    private Set<LayoutEdge> selfEdges;\n@@ -111,0 +113,1 @@\n+        \/\/ Horizontal distance relative to start of 'from'.\n@@ -112,0 +115,1 @@\n+        \/\/ Horizontal distance relative to start of 'to'.\n@@ -115,0 +119,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"Edge \" + from + \", \" + to;\n+        }\n@@ -165,0 +174,1 @@\n+        this.layoutSelfEdges = false;\n@@ -168,0 +178,8 @@\n+    public void setXOffset(int xOffset) {\n+        this.xOffset = xOffset;\n+    }\n+\n+    public void setLayerOffset(int layerOffset) {\n+        this.layerOffset = layerOffset;\n+    }\n+\n@@ -180,0 +198,19 @@\n+    public void setLayoutSelfEdges(boolean layoutSelfEdges) {\n+        this.layoutSelfEdges = layoutSelfEdges;\n+    }\n+\n+    \/\/ Remove self-edges, possibly saving them into the selfEdges set.\n+    private void removeSelfEdges(boolean save) {\n+        for (LayoutNode node : nodes) {\n+            for (LayoutEdge e : new ArrayList<>(node.succs)) {\n+                if (e.to == node) {\n+                    if (save) {\n+                        selfEdges.add(e);\n+                    }\n+                    node.succs.remove(e);\n+                    node.preds.remove(e);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -194,0 +231,1 @@\n+        selfEdges = new HashSet<>();\n@@ -205,0 +243,5 @@\n+        if (!layoutSelfEdges) {\n+            \/\/ Remove self-edges from the beginning.\n+            removeSelfEdges(false);\n+        }\n+\n@@ -223,0 +266,3 @@\n+        \/\/ Hide self-edges from the layout algorithm and save them for later.\n+        removeSelfEdges(true);\n+\n@@ -243,0 +289,6 @@\n+        \/\/ Put saved self-edges back so that they are assigned points.\n+        for (LayoutEdge e : selfEdges) {\n+            e.from.succs.add(e);\n+            e.to.preds.add(e);\n+        }\n+\n@@ -325,0 +377,5 @@\n+                                if (selfEdges.contains(e)) {\n+                                    \/\/ For self edges, it is enough with the\n+                                    \/\/ start and end points computed by ReverseEdges.\n+                                    points.clear();\n+                                }\n@@ -354,1 +411,5 @@\n-                            points.add(new Point(p.x, p.y + e.from.outOffsets.get(e.relativeFrom) + e.link.getFrom().getRelativePosition().y));\n+                            Point pOffset = new Point(p.x, p.y + e.from.outOffsets.get(e.relativeFrom) +\n+                                                      e.link.getFrom().getRelativePosition().y + e.from.yOffset);\n+                            if (!pOffset.equals(p)) {\n+                                points.add(pOffset);\n+                            }\n@@ -407,1 +468,1 @@\n-                                    points.add(0, new Point(p1.x + other.x, p1.y + other.y));\n+                                    points.add(0, new Point(p1.x + other.x + other.xOffset, p1.y + other.y));\n@@ -412,1 +473,1 @@\n-                                    points.add(new Point(p1.x + cur.x, p1.y + cur.y));\n+                                    points.add(new Point(p1.x + cur.x + cur.xOffset, p1.y + cur.y));\n@@ -882,1 +943,1 @@\n-                x += n.width + X_OFFSET;\n+                x += n.width + xOffset;\n@@ -1449,12 +1510,0 @@\n-            \/\/ Remove self-edges\n-            for (LayoutNode node : nodes) {\n-                ArrayList<LayoutEdge> succs = new ArrayList<>(node.succs);\n-                for (LayoutEdge e : succs) {\n-                    assert e.from == node;\n-                    if (e.to == node) {\n-                        node.succs.remove(e);\n-                        node.preds.remove(e);\n-                    }\n-                }\n-            }\n-\n@@ -1488,0 +1537,1 @@\n+                boolean hasSelfEdge = false;\n@@ -1491,0 +1541,3 @@\n+                        if (e.from == e.to) {\n+                            hasSelfEdge = true;\n+                        }\n@@ -1494,0 +1547,6 @@\n+                \/\/ Whether the node has non-self reversed edges going downwards.\n+                \/\/ If so, reversed edges going upwards are drawn to the left.\n+                boolean hasReversedDown =\n+                    reversedDown.size() > 0 &&\n+                    !(reversedDown.size() == 1 && hasSelfEdge);\n+\n@@ -1495,3 +1554,1 @@\n-                if (reversedDown.size() == 0) {\n-                    reversedUp = new TreeSet<>(Collections.reverseOrder());\n-                } else {\n+                if (hasReversedDown) {\n@@ -1499,0 +1556,2 @@\n+                } else {\n+                    reversedUp = new TreeSet<>(Collections.reverseOrder());\n@@ -1507,1 +1566,1 @@\n-                final int offset = X_OFFSET + DUMMY_WIDTH;\n+                final int offset = xOffset + DUMMY_WIDTH;\n@@ -1534,1 +1593,0 @@\n-                node.width += reversedDown.size() * offset;\n@@ -1536,3 +1594,7 @@\n-                if (reversedDown.size() == 0) {\n-                    curX = offset;\n-                } else {\n+                int widthFactor = reversedDown.size();\n+                if (hasSelfEdge) {\n+                    widthFactor--;\n+                }\n+                node.width += widthFactor * offset;\n+\n+                if (hasReversedDown) {\n@@ -1540,0 +1602,2 @@\n+                } else {\n+                    curX = offset;\n@@ -1544,1 +1608,1 @@\n-                if (reversedDown.size() != 0) {\n+                if (hasReversedDown) {\n@@ -1553,3 +1617,1 @@\n-                            if (reversedDown.size() == 0) {\n-                                e.relativeTo = node.width + offset;\n-                            } else {\n+                            if (hasReversedDown) {\n@@ -1557,0 +1619,2 @@\n+                            } else {\n+                                e.relativeTo = node.width + offset;\n@@ -1565,7 +1629,2 @@\n-                    if (reversedDown.size() == 0) {\n-\n-                        curX += offset;\n-                        node.width += offset;\n-                        endPoints.add(new Point(node.width, node.height));\n-\n-                    } else {\n+                    node.width += offset;\n+                    if (hasReversedDown) {\n@@ -1573,1 +1632,0 @@\n-                        node.width += offset;\n@@ -1575,0 +1633,3 @@\n+                    } else {\n+                        curX += offset;\n+                        endPoints.add(new Point(node.width, node.height));\n@@ -1738,1 +1799,6 @@\n-            Collections.sort(vertices);\n+            \/\/ Order roots first to create more natural layer assignments.\n+            Collections.sort(vertices,\n+                             (Vertex a, Vertex b) ->\n+                             a.isRoot() == b.isRoot() ?\n+                             a.compareTo(b) :\n+                             Boolean.compare(b.isRoot(), a.isRoot()));\n@@ -1765,1 +1831,0 @@\n-                \/\/assert edge.from != edge.to; \/\/ No self-loops allowed\n@@ -1805,5 +1870,0 @@\n-\n-    @Override\n-    public void doRouting(LayoutGraph graph) {\n-        \/\/ Do nothing for now\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":104,"deletions":44,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -64,0 +65,8 @@\n+    public Cluster getFromCluster() {\n+        return null;\n+    }\n+\n+    public Cluster getToCluster() {\n+        return null;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.LayoutGraph;\n+import com.sun.hotspot.igv.layout.LayoutManager;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n+import java.util.*;\n+\n+public class LinearLayoutManager implements LayoutManager {\n+\n+    \/\/ Ranking determining the vertical node ordering.\n+    private final Map<? extends Vertex, Integer> vertexRank;\n+\n+    public LinearLayoutManager(Map<? extends Vertex, Integer> vertexRank) {\n+        this.vertexRank = vertexRank;\n+    }\n+\n+    @Override\n+    public void doLayout(LayoutGraph graph) {\n+        doLayout(graph, new HashSet<Link>());\n+    }\n+\n+    @Override\n+    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n+\n+        assert (graph.getLinks().isEmpty());\n+\n+        \/\/ Sort vertices according to given rank.\n+        List<Vertex> vertices = new ArrayList<>(graph.getVertices());\n+        vertices.sort(Comparator.comparingInt((Vertex v) -> vertexRank.getOrDefault(v, Integer.MAX_VALUE)));\n+\n+        \/\/ Assign vertical coordinates in rank order.\n+        assignVerticalCoordinates(vertices);\n+    }\n+\n+    private void assignVerticalCoordinates(List<Vertex> vertices) {\n+        int curY = 0;\n+        for (Vertex v : vertices) {\n+            v.setPosition(new Point(0, curY));\n+            curY += v.getSize().getHeight();\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LinearLayoutManager.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.awt.Dimension;\n@@ -40,0 +41,2 @@\n+\n+    public Dimension getNodeOffset();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,3 @@\n+            if (l.getFrom() == null || l.getTo() == null) {\n+                continue;\n+            }\n@@ -198,0 +201,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"LayoutGraph(\" + vertices + \", \" + links + \", \" + getClusters() + \")\";\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutGraph.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-\n-    public void doRouting(LayoutGraph graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutManager.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+    public Cluster getFromCluster();\n+\n@@ -39,0 +41,2 @@\n+    public Cluster getToCluster();\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Link.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Predicate;\n@@ -55,0 +56,32 @@\n+        public int rank; \/\/ Rank for local scheduling priority.\n+\n+        public Node(InputNode n) {\n+            inputNode = n;\n+            String p = n.getProperties().get(\"is_block_proj\");\n+            isBlockProjection = (p != null && p.equals(\"true\"));\n+            p = n.getProperties().get(\"is_block_start\");\n+            isBlockStart = (p != null && p.equals(\"true\"));\n+            computeRank();\n+        }\n+\n+        \/\/ Rank by local scheduling priority.\n+        private void computeRank() {\n+            if (isBlockStart || isOtherBlockStart(this)) {\n+                rank = 1;\n+            } else if (isPhi(this)) {\n+                rank = 2;\n+            } else if (isParm(this)) {\n+                rank = 3;\n+            } else if (isProj(this)) {\n+                rank = 4;\n+            } else if (!isControl(this)) { \/\/ Every other node except terminators.\n+                rank = 5;\n+            } else {\n+                rank = 6;\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return inputNode.getProperties().get(\"idx\") + \" \" + inputNode.getProperties().get(\"name\");\n+        }\n@@ -83,1 +116,1 @@\n-        Map<Node, Set<Node>> controlSuccs = new HashMap<>();\n+        Map<Node, List<Node>> controlSuccs = new HashMap<>();\n@@ -86,1 +119,1 @@\n-                Set<Node> nControlSuccs = new HashSet<>();\n+                List<Node> nControlSuccs = new ArrayList<>();\n@@ -92,0 +125,2 @@\n+                \/\/ Ensure that the block ordering is deterministic.\n+                nControlSuccs.sort(Comparator.comparingInt((Node a) -> a.inputNode.getId()));\n@@ -176,1 +211,12 @@\n-                graph.addBlockEdge(terms.getKey(), s.block);\n+                \/\/ Label the block edge with the short name of the corresponding\n+                \/\/ control projection, if any.\n+                String label = null;\n+                if (terms.getValue().size() > 1) {\n+                    for (Node t : terms.getValue()) {\n+                        if (s.preds.contains(t)) {\n+                            label = t.inputNode.getProperties().get(\"short_name\");\n+                            break;\n+                        }\n+                    }\n+                }\n+                graph.addBlockEdge(terms.getKey(), s.block, label);\n@@ -240,1 +286,1 @@\n-                        noBlock = graph.addBlock(\"(no block)\");\n+                        noBlock = graph.addArtificialBlock();\n@@ -249,0 +295,2 @@\n+            scheduleLocal();\n+\n@@ -253,0 +301,92 @@\n+    private void scheduleLocal() {\n+        \/\/ Leave only local predecessors and successors.\n+        for (InputBlock b : blocks) {\n+            for (InputNode in : b.getNodes()) {\n+                Node n = inputNodeToNode.get(in);\n+                Predicate<Node> excludePredecessors =\n+                    node -> isPhi(node) || node.isBlockStart;\n+                List<Node> localPreds = new ArrayList<>(n.preds.size());\n+                for (Node p : n.preds) {\n+                    if (p.block == b && p != n && !excludePredecessors.test(n)) {\n+                        localPreds.add(p);\n+                    }\n+                }\n+                n.preds = localPreds;\n+                Set<Node> localSuccs = new HashSet<>(n.succs.size());\n+                for (Node s : n.succs) {\n+                    if (s.block == b && s != n && !excludePredecessors.test(s)) {\n+                        localSuccs.add(s);\n+                    }\n+                }\n+                n.succs = localSuccs;\n+            }\n+        }\n+        \/\/ Schedule each block independently.\n+        for (InputBlock b : blocks) {\n+            List<Node> nodes = new ArrayList<>(b.getNodes().size());\n+            for (InputNode n : b.getNodes()) {\n+                nodes.add(inputNodeToNode.get(n));\n+            }\n+            List<InputNode> schedule = scheduleBlock(nodes);\n+            b.setNodes(schedule);\n+        }\n+    }\n+\n+    private static final Comparator<Node> schedulePriority = new Comparator<Node>(){\n+            @Override\n+            public int compare(Node n1, Node n2) {\n+                \/\/ Order by rank, then idx.\n+                int r1 = n1.rank, r2 = n2.rank;\n+                int o1, o2;\n+                if (r1 != r2) { \/\/ Different rank.\n+                    o1 = r1;\n+                    o2 = r2;\n+                } else { \/\/ Same rank, order by idx.\n+                    o1 = Integer.parseInt(n1.inputNode.getProperties().get(\"idx\"));\n+                    o2 = Integer.parseInt(n2.inputNode.getProperties().get(\"idx\"));\n+                }\n+                return Integer.compare(o1, o2);\n+            };\n+        };\n+\n+    private List<InputNode> scheduleBlock(Collection<Node> nodes) {\n+        List<InputNode> schedule = new ArrayList<InputNode>();\n+\n+        \/\/ Initialize ready priority queue with nodes without predecessors.\n+        Queue<Node> ready = new PriorityQueue<Node>(schedulePriority);\n+        \/\/ Set of nodes that have been enqueued.\n+        Set<Node> visited = new HashSet<Node>(nodes.size());\n+        for (Node n : nodes) {\n+            if (n.preds.isEmpty()) {\n+                ready.add(n);\n+                visited.add(n);\n+            }\n+        }\n+\n+        \/\/ Classic list scheduling algorithm.\n+        while (!ready.isEmpty()) {\n+            Node n = ready.remove();\n+            schedule.add(n.inputNode);\n+\n+            \/\/ Add nodes that are now ready after scheduling n.\n+            for (Node s : n.succs) {\n+                if (visited.contains(s)) {\n+                    continue;\n+                }\n+                boolean allPredsScheduled = true;\n+                for (Node p : s.preds) {\n+                    if (!visited.contains(p)) {\n+                        allPredsScheduled = false;\n+                        break;\n+                    }\n+                }\n+                if (allPredsScheduled) {\n+                    ready.add(s);\n+                    visited.add(s);\n+                }\n+            }\n+        }\n+        assert(schedule.size() == nodes.size());\n+        return schedule;\n+    }\n+\n@@ -429,2 +569,6 @@\n-    private boolean isRegion(Node n) {\n-        return n.inputNode.getProperties().get(\"name\").equals(\"Region\");\n+    private static boolean isOtherBlockStart(Node n) {\n+        return hasName(n, \"CountedLoopEnd\");\n+    }\n+\n+    private static boolean isPhi(Node n) {\n+        return hasName(n, \"Phi\");\n@@ -433,2 +577,18 @@\n-    private boolean isPhi(Node n) {\n-        return n.inputNode.getProperties().get(\"name\").equals(\"Phi\");\n+    private static boolean isProj(Node n) {\n+        return hasName(n, \"Proj\") || hasName(n, \"MachProj\");\n+    }\n+\n+    private static boolean isParm(Node n) {\n+        return hasName(n, \"Parm\");\n+    }\n+\n+    private static boolean hasName(Node n, String name) {\n+        String nodeName = n.inputNode.getProperties().get(\"name\");\n+        if (nodeName == null) {\n+            return false;\n+        }\n+        return nodeName.equals(name);\n+    }\n+\n+    private static boolean isControl(Node n) {\n+        return n.inputNode.getProperties().get(\"category\").equals(\"control\");\n@@ -442,3 +602,1 @@\n-            InputNode inputNode = node.inputNode;\n-            String s = inputNode.getProperties().get(\"name\");\n-            if (s != null && s.equals(\"Root\")) {\n+            if (hasName(node, \"Root\")) {\n@@ -476,2 +634,1 @@\n-            Node node = new Node();\n-            node.inputNode = n;\n+            Node node = new Node(n);\n@@ -479,4 +636,0 @@\n-            String p = n.getProperties().get(\"is_block_proj\");\n-            node.isBlockProjection = (p != null && p.equals(\"true\"));\n-            p = n.getProperties().get(\"is_block_start\");\n-            node.isBlockStart = (p != null && p.equals(\"true\"));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":170,"deletions":17,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+\/\/ Hide exception blocks.\n+\n+var f = new RemoveBlockFilter(\"Hide exception blocks\");\n+f.addRule(\n+  new RemoveBlockFilter.RemoveBlockRule(\n+    new AnySelector(\n+      new OrSelector(\n+        new MatcherSelector(\n+          new Properties.StringPropertyMatcher(\"name\", \"Rethrow\")\n+        ),\n+        new MatcherSelector(\n+          new Properties.StringPropertyMatcher(\"name\", \"RethrowException\")\n+        )\n+      )\n+    )\n+  )\n+);\n+f.apply(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideExceptionBlocks.filter","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\/\/ Remove root block and all nodes in it (hopefully just the Root node).\n+\n+var f = new RemoveBlockFilter(\"Hide root block\");\n+f.addRule(\n+  new RemoveBlockFilter.RemoveBlockRule(\n+    new AnySelector(\n+      new MatcherSelector(\n+        new Properties.RegexpPropertyMatcher(\"name\", \"Root\")\n+      )\n+    )\n+  )\n+);\n+f.apply(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideRootBlock.filter","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\/\/ Hide uncommon trap blocks.\n+\n+var f = new RemoveBlockFilter(\"Hide uncommon trap blocks\");\n+f.addRule(\n+  new RemoveBlockFilter.RemoveBlockRule(\n+    new AnySelector(\n+      new MatcherSelector(\n+        new Properties.RegexpPropertyMatcher(\"dump_spec\", \".*uncommon_trap.*\")\n+      )\n+    )\n+  )\n+);\n+f.apply(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideUncommonTrapBlocks.filter","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -60,0 +60,12 @@\n+        <file name=\"Hide root block\" url=\"filters\/hideRootBlock.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Hide other edges\"\/>\n+        <\/file>\n+        <file name=\"Hide uncommon trap blocks\" url=\"filters\/hideUncommonTrapBlocks.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Hide root block\"\/>\n+        <\/file>\n+        <file name=\"Hide exception blocks\" url=\"filters\/hideExceptionBlocks.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Hide uncommon trap blocks\"\/>\n+        <\/file>\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/layer.xml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,6 @@\n+    public static class DefaultView {\n+        public static final int SEA_OF_NODES = 0;\n+        public static final int CLUSTERED_SEA_OF_NODES = 1;\n+        public static final int CONTROL_FLOW_GRAPH = 2;\n+    }\n+\n@@ -39,2 +45,4 @@\n-    public static final String NODE_WIDTH = \"nodeWidth\";\n-    public static final String NODE_WIDTH_DEFAULT = \"100\";\n+    public static final String NODE_TINY_TEXT = \"nodeTinyText\";\n+    public static final String NODE_TINY_TEXT_DEFAULT = \"[idx]\";\n+    public static final String DEFAULT_VIEW = \"defaultView\";\n+    public static final int    DEFAULT_VIEW_DEFAULT = DefaultView.SEA_OF_NODES;\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-              <EmptySpace pref=\"153\" max=\"32767\" attributes=\"0\"\/>\n+              <EmptySpace pref=\"29\" max=\"32767\" attributes=\"0\"\/>\n@@ -49,0 +49,1 @@\n+                      <Component id=\"jLabel5\" alignment=\"0\" min=\"-2\" max=\"-2\" attributes=\"0\"\/>\n@@ -51,9 +52,6 @@\n-                  <Group type=\"103\" groupAlignment=\"0\" attributes=\"0\">\n-                      <Group type=\"103\" alignment=\"0\" groupAlignment=\"0\" max=\"-2\" attributes=\"0\">\n-                          <Component id=\"nodeShortTextField\" max=\"32767\" attributes=\"0\"\/>\n-                          <Component id=\"jScrollPane1\" pref=\"365\" max=\"32767\" attributes=\"0\"\/>\n-                      <\/Group>\n-                      <Group type=\"103\" alignment=\"0\" groupAlignment=\"1\" max=\"-2\" attributes=\"0\">\n-                          <Component id=\"nodeWidthSpinner\" alignment=\"0\" pref=\"100\" max=\"32767\" attributes=\"0\"\/>\n-                          <Component id=\"portSpinner\" alignment=\"0\" max=\"32767\" attributes=\"0\"\/>\n-                      <\/Group>\n+                  <Group type=\"103\" groupAlignment=\"0\" max=\"-2\" attributes=\"0\">\n+                      <Component id=\"nodeShortTextField\" max=\"32767\" attributes=\"0\"\/>\n+                      <Component id=\"jScrollPane1\" pref=\"470\" max=\"32767\" attributes=\"0\"\/>\n+                      <Component id=\"portSpinner\" alignment=\"0\" max=\"32767\" attributes=\"0\"\/>\n+                      <Component id=\"nodeTinyTextField\" alignment=\"0\" max=\"32767\" attributes=\"0\"\/>\n+                      <Component id=\"defaultViewComboBox\" alignment=\"0\" max=\"32767\" attributes=\"0\"\/>\n@@ -61,1 +59,1 @@\n-                  <EmptySpace pref=\"439\" max=\"32767\" attributes=\"0\"\/>\n+                  <EmptySpace max=\"32767\" attributes=\"0\"\/>\n@@ -80,1 +78,5 @@\n-                      <Component id=\"nodeWidthSpinner\" alignment=\"3\" min=\"-2\" max=\"-2\" attributes=\"0\"\/>\n+                      <Component id=\"jLabel5\" alignment=\"3\" min=\"-2\" max=\"-2\" attributes=\"0\"\/>\n+                      <Component id=\"nodeTinyTextField\" alignment=\"3\" min=\"-2\" max=\"-2\" attributes=\"0\"\/>\n+                  <\/Group>\n+                  <EmptySpace min=\"-2\" pref=\"27\" max=\"-2\" attributes=\"0\"\/>\n+                  <Group type=\"103\" groupAlignment=\"3\" attributes=\"0\">\n@@ -82,0 +84,1 @@\n+                      <Component id=\"defaultViewComboBox\" alignment=\"3\" min=\"-2\" max=\"-2\" attributes=\"0\"\/>\n@@ -100,1 +103,1 @@\n-            <Property name=\"text\" type=\"java.lang.String\" value=\"Node Width\"\/>\n+            <Property name=\"text\" type=\"java.lang.String\" value=\"Default View\"\/>\n@@ -121,2 +124,0 @@\n-        <Component class=\"javax.swing.JSpinner\" name=\"nodeWidthSpinner\">\n-        <\/Component>\n@@ -144,0 +145,31 @@\n+        <Component class=\"javax.swing.JLabel\" name=\"jLabel5\">\n+          <Properties>\n+            <Property name=\"text\" type=\"java.lang.String\" value=\"Tiny Node Text\"\/>\n+          <\/Properties>\n+        <\/Component>\n+        <Component class=\"javax.swing.JTextField\" name=\"nodeTinyTextField\">\n+          <Properties>\n+            <Property name=\"background\" type=\"java.awt.Color\" editor=\"org.netbeans.beaninfo.editors.ColorEditor\">\n+              <Color blue=\"ff\" green=\"ff\" red=\"ff\" type=\"rgb\"\/>\n+            <\/Property>\n+            <Property name=\"toolTipText\" type=\"java.lang.String\" value=\"Single-line format string for node input lists. Properties are specified with brackets  (example: &quot;[idx]&quot;).\"\/>\n+          <\/Properties>\n+          <AuxValues>\n+            <AuxValue name=\"JavaCodeGenerator_SerializeTo\" type=\"java.lang.String\" value=\"ViewPanel_nodeTinyTextField\"\/>\n+          <\/AuxValues>\n+        <\/Component>\n+        <Component class=\"javax.swing.JComboBox\" name=\"defaultViewComboBox\">\n+          <Properties>\n+            <Property name=\"model\" type=\"javax.swing.ComboBoxModel\" editor=\"org.netbeans.modules.form.editors2.ComboBoxModelEditor\">\n+              <StringArray count=\"3\">\n+                <StringItem index=\"0\" value=\"Sea of nodes\"\/>\n+                <StringItem index=\"1\" value=\"Clustered sea of nodes\"\/>\n+                <StringItem index=\"2\" value=\"Control-flow graph\"\/>\n+              <\/StringArray>\n+            <\/Property>\n+            <Property name=\"toolTipText\" type=\"java.lang.String\" value=\"View shown by default when a graph is opened.\"\/>\n+          <\/Properties>\n+          <AuxValues>\n+            <AuxValue name=\"JavaCodeGenerator_TypeParameters\" type=\"java.lang.String\" value=\"&lt;String&gt;\"\/>\n+          <\/AuxValues>\n+        <\/Component>\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/ViewPanel.form","additions":47,"deletions":15,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-        nodeWidthSpinner = new javax.swing.JSpinner();\n@@ -57,0 +56,3 @@\n+        jLabel5 = new javax.swing.JLabel();\n+        nodeTinyTextField = new javax.swing.JTextField();\n+        defaultViewComboBox = new javax.swing.JComboBox<>();\n@@ -60,1 +62,1 @@\n-        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, \"Node Width\");\n+        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, \"Default View\");\n@@ -74,0 +76,8 @@\n+        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, \"Tiny Node Text\");\n+\n+        nodeTinyTextField.setBackground(new java.awt.Color(255, 255, 255));\n+        nodeTinyTextField.setToolTipText(\"Single-line format string for node input lists. Properties are specified with brackets  (example: \\\"[idx]\\\").\");\n+\n+        defaultViewComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { \"Sea of nodes\", \"Clustered sea of nodes\", \"Control-flow graph\" }));\n+        defaultViewComboBox.setToolTipText(\"View shown by default when a graph is opened.\");\n+\n@@ -84,1 +94,2 @@\n-                    .add(jLabel4))\n+                    .add(jLabel4)\n+                    .add(jLabel5))\n@@ -86,8 +97,7 @@\n-                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n-                    .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)\n-                        .add(nodeShortTextField)\n-                        .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 365, Short.MAX_VALUE))\n-                    .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)\n-                        .add(org.jdesktop.layout.GroupLayout.LEADING, nodeWidthSpinner, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)\n-                        .add(org.jdesktop.layout.GroupLayout.LEADING, portSpinner)))\n-                .addContainerGap(439, Short.MAX_VALUE))\n+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)\n+                    .add(nodeShortTextField)\n+                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 470, Short.MAX_VALUE)\n+                    .add(portSpinner)\n+                    .add(nodeTinyTextField)\n+                    .add(defaultViewComboBox, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n+                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n@@ -108,2 +118,6 @@\n-                    .add(nodeWidthSpinner, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)\n-                    .add(jLabel2))\n+                    .add(jLabel5)\n+                    .add(nodeTinyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))\n+                .add(27, 27, 27)\n+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)\n+                    .add(jLabel2)\n+                    .add(defaultViewComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))\n@@ -130,1 +144,1 @@\n-                .addContainerGap(153, Short.MAX_VALUE))\n+                .addContainerGap(29, Short.MAX_VALUE))\n@@ -136,1 +150,2 @@\n-        nodeWidthSpinner.setValue(Integer.parseInt(Settings.get().get(Settings.NODE_WIDTH, Settings.NODE_WIDTH_DEFAULT)));\n+        nodeTinyTextField.setText(Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n+        defaultViewComboBox.setSelectedIndex(Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DefaultView.SEA_OF_NODES));\n@@ -143,1 +158,2 @@\n-        Settings.get().put(Settings.NODE_WIDTH, nodeWidthSpinner.getValue().toString());\n+        Settings.get().put(Settings.NODE_TINY_TEXT, nodeTinyTextField.getText());\n+        Settings.get().putInt(Settings.DEFAULT_VIEW, defaultViewComboBox.getSelectedIndex());\n@@ -151,0 +167,1 @@\n+    private javax.swing.JComboBox<String> defaultViewComboBox;\n@@ -155,0 +172,1 @@\n+    private javax.swing.JLabel jLabel5;\n@@ -159,1 +177,1 @@\n-    private javax.swing.JSpinner nodeWidthSpinner;\n+    private javax.swing.JTextField nodeTinyTextField;\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/ViewPanel.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,21 @@\n+    \/**\n+     * Rank a match of a query in a word. Full matches of a word rank highest,\n+     * followed by partial matches at the word start, followed by the rest of\n+     * matches in increasing size of the partially matched word, for example:\n+     *\n+     *   rank(\"5\", \"5\")   = 1 (full match)\n+     *   rank(\"5\", \"554\") = 2 (start match)\n+     *   rank(\"5\", \"25\")  = 3 (middle match with excess 1)\n+     *   rank(\"5\", \"253\") = 4 (middle match with excess 2)\n+     *\/\n+    public static int rankMatch(String query, String word) {\n+        if (word.equals(query)) {\n+            return 1;\n+        } else if (word.startsWith(query)) {\n+            return 2;\n+        } else if (word.contains(query)) {\n+            return word.length() - query.length() + 2;\n+        }\n+        return Integer.MAX_VALUE;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/StringUtils.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view;\n+\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.InputBlock;\n+import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n+import com.sun.hotspot.igv.data.services.InputGraphProvider;\n+import com.sun.hotspot.igv.util.LookupHistory;\n+import com.sun.hotspot.igv.util.StringUtils;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+import org.netbeans.spi.quicksearch.SearchProvider;\n+import org.netbeans.spi.quicksearch.SearchRequest;\n+import org.netbeans.spi.quicksearch.SearchResponse;\n+import org.openide.DialogDisplayer;\n+import org.openide.NotifyDescriptor;\n+import org.openide.NotifyDescriptor.Message;\n+\n+public class BlockQuickSearch implements SearchProvider {\n+\n+    @Override\n+    public void evaluate(SearchRequest request, SearchResponse response) {\n+        String rawValue = request.getText();\n+        if (rawValue.trim().isEmpty()) {\n+            return;\n+        }\n+        String value = \".*\" + Pattern.quote(rawValue) + \".*\";\n+\n+        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n+        if (p == null || p.getGraph() == null) {\n+            return;\n+        }\n+\n+        InputGraph matchGraph = p.getGraph();\n+        \/\/ Search the current graph\n+        List<InputBlock> matches = findMatches(value, p.getGraph(), response);\n+        if (matches == null) {\n+            \/\/ See if the it hits in a later graph\n+            for (InputGraph graph : p.searchForward()) {\n+                matches = findMatches(value, graph, response);\n+                if (matches != null) {\n+                    matchGraph = graph;\n+                    break;\n+                }\n+            }\n+        }\n+        if (matches == null) {\n+            \/\/ See if it hits in a earlier graph\n+            for (InputGraph graph : p.searchBackward()) {\n+                matches = findMatches(value, graph, response);\n+                if (matches != null) {\n+                    matchGraph = graph;\n+                    break;\n+                }\n+            }\n+        }\n+        if (matches != null) {\n+            \/\/ Rank the matches.\n+            matches.sort((InputBlock a, InputBlock b) ->\n+                         compareByRankThenNumVal(rawValue,\n+                                                 \"B\" + a.getName(),\n+                                                 \"B\" + b.getName()));\n+\n+            final InputGraph theGraph = p.getGraph() != matchGraph ? matchGraph : null;\n+            for (final InputBlock b : matches) {\n+                if (!response.addResult(() -> {\n+                            final EditorTopComponent comp = EditorTopComponent.getActive();\n+                            assert(comp != null);\n+                            if (theGraph != null) {\n+                                comp.getDiagramModel().selectGraph(theGraph);\n+                            }\n+                            comp.setSelectedNodes(b);\n+                            comp.requestActive();\n+                        },\n+                        \"B\" + b.getName() + (theGraph != null ? \" in \" + theGraph.getName() : \"\"))) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private List<InputBlock> findMatches(String blockName, InputGraph inputGraph, SearchResponse response) {\n+        try {\n+            RegexpPropertyMatcher matcher = new RegexpPropertyMatcher(\"\", blockName, Pattern.CASE_INSENSITIVE);\n+            List<InputBlock> matches = new ArrayList<>();\n+            for (InputBlock b : inputGraph.getBlocks()) {\n+                if (matcher.match(\"B\" + b.getName())) {\n+                    matches.add(b);\n+                }\n+            }\n+            return matches.size() == 0 ? null : matches;\n+        } catch (Exception e) {\n+            final String msg = e.getMessage();\n+            response.addResult(() -> {\n+                    Message desc = new NotifyDescriptor.Message(\"An exception occurred during the search, \"\n+                            + \"perhaps due to a malformed query string:\\n\" + msg,\n+                            NotifyDescriptor.WARNING_MESSAGE);\n+                    DialogDisplayer.getDefault().notify(desc);\n+                },\n+                \"(Error during search)\"\n+            );\n+        }\n+        return null;\n+    }\n+\n+    private int compareByRankThenNumVal(String qry, String b1, String b2) {\n+        int key1 = StringUtils.rankMatch(qry, b1);\n+        int key2 = StringUtils.rankMatch(qry, b2);\n+        if (key1 == key2) {\n+            \/\/ If the matches have the same rank, compare the numeric values of\n+            \/\/ their first words, if applicable.\n+            try {\n+                key1 = Integer.parseInt(b1.replace(\"B\", \"\"));\n+                key2 = Integer.parseInt(b2.replace(\"B\", \"\"));\n+            } catch (Exception e) {\n+                \/\/ Not applicable, return equality value.\n+                return 0;\n+            }\n+        }\n+        return Integer.compare(key1, key2);\n+    }\n+\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BlockQuickSearch.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import com.sun.hotspot.igv.hierarchicallayout.HierarchicalCFGLayoutManager;\n+import com.sun.hotspot.igv.hierarchicallayout.LinearLayoutManager;\n@@ -37,0 +39,1 @@\n+import com.sun.hotspot.igv.layout.Link;\n@@ -496,0 +499,13 @@\n+    public Action createGotoAction(final Block b) {\n+        final DiagramScene diagramScene = this;\n+        String name = \"B\" + b.getInputBlock().getName();\n+        Action a = new AbstractAction(name) {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                diagramScene.gotoBlock(b);\n+            }\n+        };\n+        a.setEnabled(true);\n+        return a;\n+    }\n+\n@@ -521,6 +537,11 @@\n-        if (d.getGraph().getBlocks().isEmpty()) {\n-            Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n-            d.getGraph().clearBlocks();\n-            s.schedule(d.getGraph());\n-            d.getGraph().ensureNodesInBlocks();\n-            d.updateBlocks();\n+        Map<InputBlock, Integer> maxWidth = new HashMap<>();\n+        for (InputBlock b : d.getGraph().getBlocks()) {\n+            maxWidth.put(b, 10);\n+        }\n+        for (Figure f : d.getFigures()) {\n+            \/\/ Update node text, since it might differ across views.\n+            f.updateLines();\n+            \/\/ Compute max node width in each block.\n+            if (f.getWidth() > maxWidth.get(f.getBlock())) {\n+                maxWidth.put(f.getBlock(), f.getWidth());\n+            }\n@@ -530,0 +551,6 @@\n+\n+            \/\/ Set all nodes' width to the maximum width in the blocks?\n+            if (getModel().getShowCFG()) {\n+                f.setWidth(maxWidth.get(f.getBlock()));\n+            }\n+\n@@ -555,1 +582,1 @@\n-        if (getModel().getShowBlocks()) {\n+        if (getModel().getShowBlocks() || getModel().getShowCFG()) {\n@@ -581,2 +608,5 @@\n-        FigureWidget w1 = getWidget(c.getInputSlot().getFigure());\n-        FigureWidget w2 = getWidget(c.getOutputSlot().getFigure());\n+        if (getModel().getShowCFG()) {\n+            return c.isAlwaysVisible();\n+        }\n+        FigureWidget w1 = getWidget(c.getFrom().getVertex());\n+        FigureWidget w2 = getWidget(c.getTo().getVertex());\n@@ -611,12 +641,6 @@\n-        if (getModel().getShowBlocks()) {\n-            HierarchicalClusterLayoutManager m = new HierarchicalClusterLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-            HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-            manager.setMaxLayerLength(9);\n-            manager.setMinLayerDifference(3);\n-            m.setManager(manager);\n-            m.setSubManager(new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS));\n-            m.doLayout(new LayoutGraph(edges, figures));\n-        } else {\n-            HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-            manager.setMaxLayerLength(10);\n-            manager.doLayout(new LayoutGraph(edges, figures));\n+        if (getModel().getShowSea()) {\n+            doSeaLayout(figures, edges);\n+        } else if (getModel().getShowBlocks()) {\n+            doClusteredLayout(figures, edges);\n+        } else if (getModel().getShowCFG()) {\n+            doCFGLayout(figures, edges);\n@@ -627,0 +651,56 @@\n+\n+    private void doSeaLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        manager.setMaxLayerLength(10);\n+        manager.doLayout(new LayoutGraph(edges, figures));\n+    }\n+\n+    private void doClusteredLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+        HierarchicalClusterLayoutManager m = new HierarchicalClusterLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        manager.setMaxLayerLength(9);\n+        manager.setMinLayerDifference(3);\n+        m.setManager(manager);\n+        m.setSubManager(new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS));\n+        m.doLayout(new LayoutGraph(edges, figures));\n+    }\n+\n+    private void doCFGLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+        Diagram diagram = getModel().getDiagramToView();\n+        HierarchicalCFGLayoutManager m = new HierarchicalCFGLayoutManager();\n+        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        manager.setMaxLayerLength(9);\n+        manager.setMinLayerDifference(1);\n+        manager.setLayoutSelfEdges(true);\n+        manager.setXOffset(25);\n+        manager.setLayerOffset(25);\n+        m.setManager(manager);\n+        Map<InputNode, Figure> nodeFig = new HashMap<InputNode, Figure>();\n+        for (Figure f : figures) {\n+            InputNode n = f.getFirstSourceNode();\n+            if (n != null) {\n+                nodeFig.put(n, f);\n+            }\n+        }\n+        \/\/ Compute global ranking among figures given by in-block order. If\n+        \/\/ needed, this could be cached as long as it is computed for all the\n+        \/\/ figures in the model, not just the visible ones.\n+        Map<Figure, Integer> figureRank =\n+            new HashMap<Figure, Integer>(figures.size());\n+        int r = 0;\n+        for (InputBlock b : getModel().getGraphToView().getBlocks()) {\n+            for (InputNode n : b.getNodes()) {\n+                Figure f = nodeFig.get(n);\n+                if (f != null) {\n+                    figureRank.put(f, r);\n+                    r++;\n+                }\n+            }\n+        }\n+        \/\/ Add connections for CFG edges.\n+        edges.addAll(diagram.getBlockConnections());\n+        m.setSubManager(new LinearLayoutManager(figureRank));\n+        m.setClusters(new HashSet<>(diagram.getBlocks()));\n+        m.doLayout(new LayoutGraph(edges, figures));\n+    }\n+\n@@ -645,1 +725,1 @@\n-        for (Connection c : diagram.getConnections()) {\n+        for (FigureConnection c : diagram.getConnections()) {\n@@ -659,1 +739,1 @@\n-        if (getModel().getShowBlocks()) {\n+        if (getModel().getShowBlocks() || getModel().getShowCFG()) {\n@@ -708,1 +788,12 @@\n-                processOutputSlot(lastLineCache, s, s.getConnections(), 0, null, null, offx2, offy2, anim);\n+                List<Connection> cl = new ArrayList<>(s.getConnections().size());\n+                for (FigureConnection c : s.getConnections()) {\n+                    cl.add((Connection) c);\n+                }\n+                processOutputSlot(lastLineCache, s, cl, 0, null, null, offx2, offy2, anim);\n+            }\n+        }\n+\n+        if (getModel().getShowCFG()) {\n+            for (BlockConnection c : diagram.getBlockConnections()) {\n+                SceneAnimator anim = animator;\n+                processOutputSlot(lastLineCache, null, Collections.singletonList(c), 0, null, null, offx2, offy2, anim);\n@@ -726,1 +817,1 @@\n-        if (getModel().getShowBlocks()) {\n+        if (getModel().getShowBlocks() || getModel().getShowCFG()) {\n@@ -762,1 +853,1 @@\n-            if (cur == null) {\n+            if (cur == null) { \/\/ Long connection, has been cut vertically.\n@@ -764,4 +855,7 @@\n-            } else if (controlPointIndex == 0 && !s.shouldShowName()) {\n-                cur = new Point(cur.x, cur.y - SLOT_OFFSET);\n-            } else if (controlPointIndex == controlPoints.size() - 1 && !c.getInputSlot().shouldShowName()) {\n-                cur = new Point(cur.x, cur.y + SLOT_OFFSET);\n+            } else if (c.hasSlots()) {\n+                if (controlPointIndex == 0 && !s.shouldShowName()) {\n+                    cur = new Point(cur.x, cur.y - SLOT_OFFSET);\n+                } else if (controlPointIndex == controlPoints.size() - 1 &&\n+                           !((Slot)c.getTo()).shouldShowName()) {\n+                    cur = new Point(cur.x, cur.y + SLOT_OFFSET);\n+                }\n@@ -886,0 +980,7 @@\n+    public void gotoBlock(final Block block) {\n+        BlockWidget bw = getWidget(block.getInputBlock());\n+        if (bw != null) {\n+            centerRectangle(bw.getBounds());\n+        }\n+    }\n+\n@@ -1045,1 +1146,1 @@\n-        if (getModel().getShowBlocks()) {\n+        if (getModel().getShowBlocks() || getModel().getShowCFG()) {\n@@ -1105,1 +1206,17 @@\n-        if (getModel().getShowBlocks()) {\n+        if (getModel().getShowCFG()) {\n+            \/\/ Blockless figures and artificial blocks are hidden in this view.\n+            for (Figure f : diagram.getFigures()) {\n+                if (f.getBlock().isArtificial()) {\n+                    FigureWidget w = getWidget(f);\n+                    w.setVisible(false);\n+                }\n+            }\n+            visibleBlocks.clear();\n+            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+                if (!b.isArtificial()) {\n+                    visibleBlocks.add(b);\n+                }\n+            }\n+        }\n+\n+        if (getModel().getShowBlocks() || getModel().getShowCFG()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":150,"deletions":33,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.data.services.Scheduler;\n@@ -37,0 +38,1 @@\n+import org.openide.util.Lookup;\n@@ -59,0 +61,1 @@\n+    private boolean showSea;\n@@ -60,0 +63,1 @@\n+    private boolean showCFG;\n@@ -105,0 +109,2 @@\n+        viewPropertiesChanged |= (showSea != newModel.showSea);\n+        this.showSea = newModel.showSea;\n@@ -107,0 +113,2 @@\n+        viewPropertiesChanged |= (showCFG != newModel.showCFG);\n+        this.showCFG = newModel.showCFG;\n@@ -125,0 +133,9 @@\n+    public boolean getShowSea() {\n+        return showSea;\n+    }\n+\n+    public void setShowSea(boolean b) {\n+        showSea = b;\n+        viewPropertiesChangedEvent.fire();\n+    }\n+\n@@ -134,0 +151,9 @@\n+    public boolean getShowCFG() {\n+        return showCFG;\n+    }\n+\n+    public void setShowCFG(boolean b) {\n+        showCFG = b;\n+        viewPropertiesChangedEvent.fire();\n+    }\n+\n@@ -167,1 +193,3 @@\n-        this.showBlocks = false;\n+        this.showSea = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.SEA_OF_NODES;\n+        this.showBlocks = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CLUSTERED_SEA_OF_NODES;\n+        this.showCFG = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CONTROL_FLOW_GRAPH;\n@@ -409,1 +437,8 @@\n-            diagram = Diagram.createDiagram(getGraphToView(),\n+            InputGraph graph = getGraphToView();\n+            if (graph.getBlocks().isEmpty()) {\n+                Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n+                graph.clearBlocks();\n+                s.schedule(graph);\n+                graph.ensureNodesInBlocks();\n+            }\n+            diagram = Diagram.createDiagram(graph,\n@@ -411,1 +446,2 @@\n-                                            Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT));\n+                                            Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n+                                            Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n@@ -423,0 +459,1 @@\n+        diagram.setCFG(getShowCFG());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import com.sun.hotspot.igv.data.InputBlock;\n@@ -41,0 +42,1 @@\n+import com.sun.hotspot.igv.settings.Settings;\n@@ -94,0 +96,1 @@\n+    private EnableSeaLayoutAction seaLayoutAction;\n@@ -95,0 +98,1 @@\n+    private EnableCFGLayoutAction cfgLayoutAction;\n@@ -241,0 +245,10 @@\n+        toolBar.addSeparator();\n+        ButtonGroup layoutButtons = new ButtonGroup();\n+\n+        seaLayoutAction = new EnableSeaLayoutAction();\n+        JToggleButton button = new JToggleButton(seaLayoutAction);\n+        button.setSelected(Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.SEA_OF_NODES);\n+        layoutButtons.add(button);\n+        toolBar.add(button);\n+        seaLayoutAction.addPropertyChangeListener(this);\n+\n@@ -242,2 +256,3 @@\n-        JToggleButton button = new JToggleButton(blockLayoutAction);\n-        button.setSelected(false);\n+        button = new JToggleButton(blockLayoutAction);\n+        button.setSelected(Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CLUSTERED_SEA_OF_NODES);\n+        layoutButtons.add(button);\n@@ -247,0 +262,8 @@\n+        cfgLayoutAction = new EnableCFGLayoutAction();\n+        button = new JToggleButton(cfgLayoutAction);\n+        button.setSelected(Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CONTROL_FLOW_GRAPH);\n+        layoutButtons.add(button);\n+        toolBar.add(button);\n+        cfgLayoutAction.addPropertyChangeListener(this);\n+\n+        toolBar.addSeparator();\n@@ -511,0 +534,10 @@\n+    public void setSelectedNodes(InputBlock b) {\n+        List<Figure> list = new ArrayList<>();\n+        for (Figure f : getModel().getDiagramToView().getFigures()) {\n+            if (f.getBlock() == b) {\n+                list.add(f);\n+            }\n+        }\n+        setSelectedFigures(list);\n+    }\n+\n@@ -523,0 +556,3 @@\n+        } else if (evt.getSource() == this.seaLayoutAction) {\n+            boolean b = seaLayoutAction.isSelected();\n+            this.getModel().setShowSea(b);\n@@ -524,1 +560,1 @@\n-            boolean b = (Boolean) blockLayoutAction.getValue(EnableBlockLayoutAction.STATE);\n+            boolean b = blockLayoutAction.isSelected();\n@@ -526,0 +562,3 @@\n+        } else if (evt.getSource() == this.cfgLayoutAction) {\n+            boolean b = cfgLayoutAction.isSelected();\n+            this.getModel().setShowCFG(b);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,2 @@\n-                                                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT));\n+                                                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n+                                                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n@@ -71,0 +72,1 @@\n+        diagram.setCFG(tc.getModel().getShowCFG());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.hotspot.igv.util.StringUtils;\n@@ -217,7 +218,2 @@\n-     * the rest of matches in increasing size of the partially matched word, for\n-     * example:\n-     *\n-     *   rank(\"5\", \"5 AddI\")   = 1 (full match of first word)\n-     *   rank(\"5\", \"554 MulI\") = 2 (start match of first word)\n-     *   rank(\"5\", \"25 AddL\")  = 3 (middle match of first word with excess 1)\n-     *   rank(\"5\", \"253 AddL\") = 4 (middle match of first word with excess 2)\n+     * the rest of matches in increasing size of the partially matched word. See\n+     * examples in class StringUtils.\n@@ -229,6 +225,3 @@\n-            if (component.equals(query)) {\n-                return 1;\n-            } else if (component.startsWith(query)) {\n-                return 2;\n-            } else if (component.contains(query)) {\n-                return component.length() - query.length() + 2;\n+            int rank = StringUtils.rankMatch(query, component);\n+            if (rank != Integer.MAX_VALUE) {\n+                return rank;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n-    private boolean state;\n-    public static final String STATE = \"state\";\n-\n@@ -42,1 +39,0 @@\n-        state = false;\n@@ -44,2 +40,2 @@\n-        putValue(STATE, state);\n-        putValue(Action.SHORT_DESCRIPTION, \"Cluster nodes into blocks\");\n+        putValue(SELECTED_KEY, false);\n+        putValue(Action.SHORT_DESCRIPTION, \"Show clustered sea of nodes\");\n@@ -48,3 +44,2 @@\n-    public void actionPerformed(ActionEvent ev) {\n-        this.state = !state;\n-        this.putValue(STATE, state);\n+    public boolean isSelected() {\n+        return (Boolean)getValue(SELECTED_KEY);\n@@ -54,1 +49,5 @@\n-        return \"com\/sun\/hotspot\/igv\/view\/images\/blocks.gif\";\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/blocks.png\";\n+    }\n+\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n@@ -56,0 +55,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableBlockLayoutAction.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import java.awt.event.ActionEvent;\n+import javax.swing.AbstractAction;\n+import javax.swing.Action;\n+import javax.swing.ImageIcon;\n+import org.openide.util.ImageUtilities;\n+\n+public class EnableCFGLayoutAction extends AbstractAction {\n+\n+    public EnableCFGLayoutAction() {\n+        putValue(AbstractAction.SMALL_ICON, new ImageIcon(ImageUtilities.loadImage(iconResource())));\n+        putValue(SELECTED_KEY, false);\n+        putValue(Action.SHORT_DESCRIPTION, \"Show control-flow graph\");\n+    }\n+\n+    public boolean isSelected() {\n+        return (Boolean)getValue(SELECTED_KEY);\n+    }\n+\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/cfg.png\";\n+    }\n+\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableCFGLayoutAction.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import java.awt.event.ActionEvent;\n+import javax.swing.AbstractAction;\n+import javax.swing.Action;\n+import javax.swing.ImageIcon;\n+import org.openide.util.ImageUtilities;\n+\n+public class EnableSeaLayoutAction extends AbstractAction {\n+\n+    public EnableSeaLayoutAction() {\n+        putValue(AbstractAction.SMALL_ICON, new ImageIcon(ImageUtilities.loadImage(iconResource())));\n+        putValue(SELECTED_KEY, false);\n+        putValue(Action.SHORT_DESCRIPTION, \"Show sea of nodes\");\n+    }\n+\n+    public boolean isSelected() {\n+        return (Boolean)getValue(SELECTED_KEY);\n+    }\n+\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/sea.png\";\n+    }\n+\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableSeaLayoutAction.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,2 @@\n-    private static final Font titleFont = new Font(\"Serif\", Font.PLAIN, 14).deriveFont(Font.BOLD);\n+    private static final Font TITLE_FONT = new Font(\"Arial\", Font.BOLD, 14);\n+    public static final Color TITLE_COLOR = new Color(42, 42, 171);\n@@ -73,3 +74,2 @@\n-        Color titleColor = Color.BLACK;\n-        g.setColor(titleColor);\n-        g.setFont(titleFont);\n+        g.setColor(TITLE_COLOR);\n+        g.setFont(TITLE_FONT);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import org.netbeans.api.visual.layout.LayoutFactory.SerialAlignment;\n@@ -109,1 +110,4 @@\n-        middleWidget.setLayout(LayoutFactory.createVerticalFlowLayout(LayoutFactory.SerialAlignment.CENTER, 0));\n+        SerialAlignment textAlign = scene.getModel().getShowCFG() ?\n+            LayoutFactory.SerialAlignment.LEFT_TOP :\n+            LayoutFactory.SerialAlignment.CENTER;\n+        middleWidget.setLayout(LayoutFactory.createVerticalFlowLayout(textAlign, 0));\n@@ -116,1 +120,4 @@\n-        dummyTop.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1));\n+        int extraTopHeight =\n+            getFigure().getDiagram().isCFG() && getFigure().hasNamedInputSlot() ?\n+            Figure.TOP_CFG_HEIGHT : 0;\n+        dummyTop.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1 + extraTopHeight));\n@@ -135,1 +142,4 @@\n-        dummyBottom.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1));\n+        int extraBottomHeight =\n+            getFigure().getDiagram().isCFG() && getFigure().hasNamedOutputSlot() ?\n+            Figure.BOTTOM_CFG_HEIGHT : 0;\n+        dummyBottom.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1  + extraBottomHeight));\n@@ -138,1 +148,1 @@\n-        middleWidget.setPreferredBounds(new Rectangle(0, Figure.SLOT_WIDTH - Figure.OVERLAPPING, f.getWidth(), f.getHeight()));\n+        middleWidget.setPreferredBounds(new Rectangle(0, Figure.getVerticalOffset(), f.getWidth(), f.getHeight()));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.awt.Point;\n@@ -44,6 +43,0 @@\n-        \/\/init();\n-        \/\/getFigureWidget().getLeftWidget().addChild(this);\n-        Point p = inputSlot.getRelativePosition();\n-        p.x -= this.calculateClientArea().width \/ 2;\n-        p.y += Figure.SLOT_START;\n-        this.setPreferredLocation(p);\n@@ -62,0 +55,6 @@\n+\n+    @Override\n+    protected int yOffset() {\n+        return getFigureWidget().getFigure().getDiagram().isCFG() ?\n+            calculateClientArea().height - 1 : Figure.SLOT_START;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.hotspot.igv.graph.InputSlot;\n@@ -30,0 +29,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -141,2 +141,4 @@\n-                    set.add(c.getInputSlot().getFigure());\n-                    set.add(c.getOutputSlot().getFigure());\n+                    if (c.hasSlots()) {\n+                        set.add(scene.getWidget(c.getTo()));\n+                        set.add(scene.getWidget(c.getFrom()));\n+                    }\n@@ -245,4 +247,6 @@\n-            highlightedObjectsChange.add(c.getInputSlot().getFigure());\n-            highlightedObjectsChange.add(c.getInputSlot());\n-            highlightedObjectsChange.add(c.getOutputSlot().getFigure());\n-            highlightedObjectsChange.add(c.getOutputSlot());\n+            if (c.hasSlots()) {\n+                highlightedObjectsChange.add(c.getTo());\n+                highlightedObjectsChange.add(c.getTo().getVertex());\n+                highlightedObjectsChange.add(c.getFrom());\n+                highlightedObjectsChange.add(c.getFrom().getVertex());\n+            }\n@@ -315,6 +319,12 @@\n-        menu.add(scene.createGotoAction(outputSlot.getFigure()));\n-        menu.addSeparator();\n-\n-        for (Connection c : connections) {\n-            InputSlot s = c.getInputSlot();\n-            menu.add(scene.createGotoAction(s.getFigure()));\n+        if (outputSlot == null) { \/\/ One-to-one block line.\n+            assert (connections.size() == 1);\n+            Connection c = connections.get(0);\n+            menu.add(scene.createGotoAction((Block)c.getFromCluster()));\n+            menu.addSeparator();\n+            menu.add(scene.createGotoAction((Block)c.getToCluster()));\n+        } else { \/\/ One-to-many figure line.\n+            menu.add(scene.createGotoAction(outputSlot.getFigure()));\n+            menu.addSeparator();\n+            for (Connection c : connections) {\n+                menu.add(scene.createGotoAction((Figure)c.getTo().getVertex()));\n+            }\n@@ -322,1 +332,0 @@\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.awt.Point;\n@@ -44,4 +43,0 @@\n-        Point p = outputSlot.getRelativePosition();\n-        p.y += getSlot().getFigure().getHeight() - Figure.SLOT_START;\n-        p.x -= this.calculateClientArea().width \/ 2;\n-        this.setPreferredLocation(p);\n@@ -61,0 +56,7 @@\n+\n+    @Override\n+    protected int yOffset() {\n+        int overlap = getFigureWidget().getFigure().getDiagram().isCFG() ?\n+            calculateClientArea().height : Figure.SLOT_START;\n+        return getSlot().getFigure().getHeight() - overlap;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/OutputSlotWidget.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.awt.Point;\n@@ -60,1 +61,1 @@\n-        if (!slot.getSource().getSourceNodes().isEmpty()) {\n+        if (slot.hasSourceNodes()) {\n@@ -66,1 +67,4 @@\n-        \/\/this.setPreferredBounds(this.calculateClientArea());\n+        Point p = slot.getRelativePosition();\n+        p.x -= this.calculateClientArea().width \/ 2;\n+        p.y += yOffset();\n+        this.setPreferredLocation(p);\n@@ -95,1 +99,1 @@\n-        if (getSlot().getSource().getSourceNodes().size() > 0) {\n+        if (getSlot().hasSourceNodes()) {\n@@ -112,1 +116,1 @@\n-            if (getSlot().getShortName() != null && getSlot().getShortName().length() > 0) {\n+            if (getSlot().shouldShowName()) {\n@@ -126,1 +130,1 @@\n-            if (getSlot().getShortName() != null && getSlot().getShortName().length() > 0 && getScene().getZoomFactor() >= TEXT_ZOOM_FACTOR) {\n+            if (getSlot().shouldShowName() && getScene().getZoomFactor() >= TEXT_ZOOM_FACTOR) {\n@@ -133,1 +137,2 @@\n-            if (this.getSlot().getConnections().isEmpty()) {\n+            if (this.getSlot().getConnections().isEmpty() &&\n+                !getFigureWidget().getFigure().getDiagram().isCFG()) {\n@@ -158,0 +163,2 @@\n+    protected abstract int yOffset();\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+CTL_EnableSeaLayoutAction=Enable sea-of-nodes layout\n@@ -4,0 +5,1 @@\n+CTL_EnableCFGLayoutAction=Enable control-flow graph layout\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/actions\/Bundle.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/blocks.gif","binary":true,"status":"deleted"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/blocks.png","binary":true,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/cfg.png","binary":true,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/sea.png","binary":true,"status":"added"},{"patch":"@@ -20,0 +20,1 @@\n+            <file name=\"com-sun-hotspot-igv-view-actions-EnableSeaLayoutAction.instance\"><attr name=\"position\" intvalue=\"2001\"\/><\/file>\n@@ -21,0 +22,1 @@\n+            <file name=\"com-sun-hotspot-igv-view-actions-EnableCFGLayoutAction.instance\"><attr name=\"position\" intvalue=\"2001\"\/><\/file>\n@@ -83,0 +85,5 @@\n+        <folder name=\"Blocks\">\n+            <attr name=\"command\" stringvalue=\"n\"\/>\n+            <attr name=\"position\" intvalue=\"1\"\/>\n+            <file name=\"com-sun-hotspot-igv-view-BlockQuickSearch.instance\"\/>\n+        <\/folder>\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/layer.xml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}