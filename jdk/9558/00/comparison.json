{"files":[{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -36,0 +38,97 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#define STOP(error) stop(error)\n+#else\n+#define BLOCK_COMMENT(str) block_comment(str)\n+#define STOP(error) block_comment(error); stop(error)\n+#endif\n+\n+\/\/ C2 compiled method's prolog code.\n+void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {\n+\n+  \/\/ WARNING: Initial instruction MUST be 5 bytes or longer so that\n+  \/\/ NativeJump::patch_verified_entry will be able to patch out the entry\n+  \/\/ code safely. The push to verify stack depth is ok at 5 bytes,\n+  \/\/ the frame allocation can be either 3 or 6 bytes. So if we don't do\n+  \/\/ stack bang then we must use the 6 byte frame allocation even if\n+  \/\/ we have no frame. :-(\n+  assert(stack_bang_size >= framesize || stack_bang_size <= 0, \"stack bang size incorrect\");\n+\n+  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+  \/\/ Remove word for return addr\n+  framesize -= wordSize;\n+  stack_bang_size -= wordSize;\n+\n+  \/\/ Calls to C2R adapters often do not accept exceptional returns.\n+  \/\/ We require that their callers must bang for them.  But be careful, because\n+  \/\/ some VM calls (such as call site linkage) can use several kilobytes of\n+  \/\/ stack.  But the stack safety zone should account for that.\n+  \/\/ See bugs 4446381, 4468289, 4497237.\n+  if (stack_bang_size > 0) {\n+    generate_stack_overflow_check(stack_bang_size);\n+\n+    \/\/ We always push rbp, so that on return to interpreter rbp, will be\n+    \/\/ restored correctly and we can correct the stack.\n+    push(rbp);\n+    \/\/ Save caller's stack pointer into RBP if the frame pointer is preserved.\n+    if (PreserveFramePointer) {\n+      mov(rbp, rsp);\n+    }\n+    \/\/ Remove word for ebp\n+    framesize -= wordSize;\n+\n+    \/\/ Create frame\n+    if (framesize) {\n+      subptr(rsp, framesize);\n+    }\n+  } else {\n+    \/\/ Create frame (force generation of a 4 byte immediate value)\n+    subptr_imm32(rsp, framesize);\n+\n+    \/\/ Save RBP register now.\n+    framesize -= wordSize;\n+    movptr(Address(rsp, framesize), rbp);\n+    \/\/ Save caller's stack pointer into RBP if the frame pointer is preserved.\n+    if (PreserveFramePointer) {\n+      movptr(rbp, rsp);\n+      if (framesize > 0) {\n+        addptr(rbp, framesize);\n+      }\n+    }\n+  }\n+\n+  if (VerifyStackAtCalls) { \/\/ Majik cookie to verify stack depth\n+    framesize -= wordSize;\n+    movptr(Address(rsp, framesize), (int32_t)0xbadb100d);\n+  }\n+\n+#ifndef _LP64\n+  \/\/ If method sets FPU control word do it now\n+  if (fp_mode_24b) {\n+    fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n+  }\n+  if (UseSSE >= 2 && VerifyFPU) {\n+    verify_FPU(0, \"FPU stack must be clean on entry\");\n+  }\n+#endif\n+\n+#ifdef ASSERT\n+  if (VerifyStackAtCalls) {\n+    Label L;\n+    push(rax);\n+    mov(rax, rsp);\n+    andptr(rax, StackAlignmentInBytes-1);\n+    cmpptr(rax, StackAlignmentInBytes-wordSize);\n+    pop(rax);\n+    jcc(Assembler::equal, L);\n+    STOP(\"Stack is not properly aligned!\");\n+    bind(L);\n+  }\n+#endif\n+\n+  if (!is_stub) {\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->nmethod_entry_barrier(this);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+  \/\/ C2 compiled method's prolog code.\n+  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5303,89 +5303,0 @@\n-\/\/ C2 compiled method's prolog code.\n-void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {\n-\n-  \/\/ WARNING: Initial instruction MUST be 5 bytes or longer so that\n-  \/\/ NativeJump::patch_verified_entry will be able to patch out the entry\n-  \/\/ code safely. The push to verify stack depth is ok at 5 bytes,\n-  \/\/ the frame allocation can be either 3 or 6 bytes. So if we don't do\n-  \/\/ stack bang then we must use the 6 byte frame allocation even if\n-  \/\/ we have no frame. :-(\n-  assert(stack_bang_size >= framesize || stack_bang_size <= 0, \"stack bang size incorrect\");\n-\n-  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  \/\/ Remove word for return addr\n-  framesize -= wordSize;\n-  stack_bang_size -= wordSize;\n-\n-  \/\/ Calls to C2R adapters often do not accept exceptional returns.\n-  \/\/ We require that their callers must bang for them.  But be careful, because\n-  \/\/ some VM calls (such as call site linkage) can use several kilobytes of\n-  \/\/ stack.  But the stack safety zone should account for that.\n-  \/\/ See bugs 4446381, 4468289, 4497237.\n-  if (stack_bang_size > 0) {\n-    generate_stack_overflow_check(stack_bang_size);\n-\n-    \/\/ We always push rbp, so that on return to interpreter rbp, will be\n-    \/\/ restored correctly and we can correct the stack.\n-    push(rbp);\n-    \/\/ Save caller's stack pointer into RBP if the frame pointer is preserved.\n-    if (PreserveFramePointer) {\n-      mov(rbp, rsp);\n-    }\n-    \/\/ Remove word for ebp\n-    framesize -= wordSize;\n-\n-    \/\/ Create frame\n-    if (framesize) {\n-      subptr(rsp, framesize);\n-    }\n-  } else {\n-    \/\/ Create frame (force generation of a 4 byte immediate value)\n-    subptr_imm32(rsp, framesize);\n-\n-    \/\/ Save RBP register now.\n-    framesize -= wordSize;\n-    movptr(Address(rsp, framesize), rbp);\n-    \/\/ Save caller's stack pointer into RBP if the frame pointer is preserved.\n-    if (PreserveFramePointer) {\n-      movptr(rbp, rsp);\n-      if (framesize > 0) {\n-        addptr(rbp, framesize);\n-      }\n-    }\n-  }\n-\n-  if (VerifyStackAtCalls) { \/\/ Majik cookie to verify stack depth\n-    framesize -= wordSize;\n-    movptr(Address(rsp, framesize), (int32_t)0xbadb100d);\n-  }\n-\n-#ifndef _LP64\n-  \/\/ If method sets FPU control word do it now\n-  if (fp_mode_24b) {\n-    fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n-  }\n-  if (UseSSE >= 2 && VerifyFPU) {\n-    verify_FPU(0, \"FPU stack must be clean on entry\");\n-  }\n-#endif\n-\n-#ifdef ASSERT\n-  if (VerifyStackAtCalls) {\n-    Label L;\n-    push(rax);\n-    mov(rax, rsp);\n-    andptr(rax, StackAlignmentInBytes-1);\n-    cmpptr(rax, StackAlignmentInBytes-wordSize);\n-    pop(rax);\n-    jcc(Assembler::equal, L);\n-    STOP(\"Stack is not properly aligned!\");\n-    bind(L);\n-  }\n-#endif\n-\n-  if (!is_stub) {\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->nmethod_entry_barrier(this);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":89,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1884,3 +1884,0 @@\n-  \/\/ C2 compiled method's prolog code.\n-  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -897,1 +897,1 @@\n-  MacroAssembler _masm(&cbuf);\n+  C2_MacroAssembler _masm(&cbuf);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}