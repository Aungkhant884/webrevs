{"files":[{"patch":"@@ -483,0 +483,2 @@\n+    print_field(node);\n+\n@@ -631,1 +633,65 @@\n-void IdealGraphPrinter::walk_nodes(Node *start, bool edges, VectorSet* temp_set) {\n+void IdealGraphPrinter::print_field(const Node* node) {\n+  buffer[0] = 0;\n+  stringStream ss(buffer, sizeof(buffer) - 1);\n+  ciField* field = get_field(node);\n+  uint depth = 0;\n+  if (field == NULL) {\n+    depth++;\n+    field = find_source_field_of_array_access(node, depth);\n+  }\n+\n+  if (field != NULL) {\n+    \/\/ Either direct field access or array access\n+    field->print_name_on(&ss);\n+    for (uint i = 0; i < depth; i++) {\n+      \/\/ For arrays: Add [] for each dimension\n+      ss.print(\"[]\");\n+    }\n+    if (node->is_Store()) {\n+      print_prop(\"destination\", buffer);\n+    } else {\n+      print_prop(\"source\", buffer);\n+    }\n+  }\n+}\n+\n+ciField* IdealGraphPrinter::get_field(const Node* node) {\n+  const TypePtr* adr_type = node->adr_type();\n+  Compile::AliasType* atp = NULL;\n+  if (C->have_alias_type(adr_type)) {\n+    atp = C->alias_type(adr_type);\n+  }\n+  if (atp != NULL) {\n+    ciField* field = atp->field();\n+    if (field != NULL) {\n+      \/\/ Found field associated with 'node'.\n+      return field;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Try to find the field that is associated with a memory node belonging to an array access.\n+ciField* IdealGraphPrinter::find_source_field_of_array_access(const Node* node, uint& depth) {\n+  if (!node->is_Mem()) {\n+    \/\/ Not an array access\n+    return NULL;\n+  }\n+\n+  do {\n+    if (node->adr_type() != NULL && node->adr_type()->isa_aryptr()) {\n+      \/\/ Only process array accesses. Pattern match to find actual field source access.\n+      node = get_load_node(node);\n+      if (node != NULL) {\n+        ciField* field = get_field(node);\n+        if (field != NULL) {\n+          return field;\n+        }\n+        \/\/ Could be a multi-dimensional array. Repeat loop.\n+        depth++;\n+        continue;\n+      }\n+    }\n+    \/\/ Not an array access with a field source.\n+    break;\n+  } while (depth < 256); \/\/ Cannot have more than 255 dimensions\n@@ -633,0 +699,22 @@\n+  return NULL;\n+}\n+\n+\/\/ Pattern match on the inputs of 'node' to find load node for the field access.\n+Node* IdealGraphPrinter::get_load_node(const Node* node) {\n+  Node* load = NULL;\n+  Node* addr = node->as_Mem()->in(MemNode::Address);\n+  if (addr != NULL && addr->is_AddP()) {\n+    Node* base = addr->as_AddP()->base_node();\n+    if (base != NULL) {\n+      base = base->uncast();\n+      if (base->is_Load()) {\n+        \/\/ Mem(AddP([ConstraintCast*](LoadP))) for non-compressed oops.\n+        load = base;\n+      } else if (base->is_DecodeN() && base->in(1)->is_Load()) {\n+        \/\/ Mem(AddP([ConstraintCast*](DecodeN(LoadN)))) for compressed oops.\n+        load = base->in(1);\n+      }\n+    }\n+  }\n+  return load;\n+}\n@@ -634,0 +722,1 @@\n+void IdealGraphPrinter::walk_nodes(Node* start, bool edges, VectorSet* temp_set) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":90,"deletions":1,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -102,0 +102,4 @@\n+  void print_field(const Node* node);\n+  ciField* get_field(const Node* node);\n+  ciField* find_source_field_of_array_access(const Node* node, uint& depth);\n+  static Node* get_load_node(const Node* node);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}