{"files":[{"patch":"@@ -2841,0 +2841,8 @@\n+\n+                    \/\/ Translate wRaster to start at (0, 0) and to contain\n+                    \/\/ only the relevent portion of the tile\n+                    wRaster = wRaster.createWritableChild(tileRect.x, tileRect.y,\n+                                                          tileRect.width,\n+                                                          tileRect.height,\n+                                                          0, 0,\n+                                                          null);\n@@ -2843,1 +2851,1 @@\n-                    \/\/ as the original raster.\n+                    \/\/ as the original raster, except origin which is (0,0).\n@@ -2850,8 +2858,0 @@\n-                \/\/ Translate wRaster to start at (0, 0) and to contain\n-                \/\/ only the relevent portion of the tile\n-                wRaster = wRaster.createWritableChild(tileRect.x, tileRect.y,\n-                                                      tileRect.width,\n-                                                      tileRect.height,\n-                                                      0, 0,\n-                                                      null);\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BandedSampleModel;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.Raster;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.SampleModel;\n+import java.awt.image.WritableRaster;\n+import java.util.Objects;\n+import java.util.Vector;\n+\n+\n+\/**\n+ * Test drawing a tiled image made of non-writable {@link Raster} tiles.\n+ * Drawing works when tiles are instances of {@link WritableRaster}.\n+ * But if tiles are instances of {@link Raster} only, then the following\n+ * exception is thrown:\n+ *\n+ * <pre>\n+ * Exception in thread \"main\" java.awt.image.RasterFormatException: (parentX + width) is outside raster\n+ *     at java.desktop\/java.awt.image.WritableRaster.createWritableChild(WritableRaster.java:228)\n+ *     at java.desktop\/sun.java2d.SunGraphics2D.drawTranslatedRenderedImage(SunGraphics2D.java:2852)\n+ *     at java.desktop\/sun.java2d.SunGraphics2D.drawRenderedImage(SunGraphics2D.java:2711)<\/pre>\n+ *\n+ * The bug is demonstrated by drawing the same image twice:\n+ * once with {@link WritableRaster} tiles (which succeed),\n+ * then the same operation but with {@link Raster} tiles.\n+ *\n+ * The bug is caused by the following code in {@code SunGraphics2D}:\n+ *\n+ * <pre>\n+ * \/\/ Create a WritableRaster containing the tile\n+ * WritableRaster wRaster = null;\n+ * if (raster instanceof WritableRaster) {\n+ *     wRaster = (WritableRaster)raster;\n+ * } else {\n+ *     \/\/ Create a WritableRaster in the same coordinate system\n+ *     \/\/ as the original raster.\n+ *     wRaster =\n+ *         Raster.createWritableRaster(raster.getSampleModel(),\n+ *                                     raster.getDataBuffer(),\n+ *                                     null);\n+ * }\n+ * \/\/ Translate wRaster to start at (0, 0) and to contain\n+ * \/\/ only the relevent portion of the tile\n+ * wRaster = wRaster.createWritableChild(tileRect.x, tileRect.y,\n+ *                                       tileRect.width,\n+ *                                       tileRect.height,\n+ *                                       0, 0,\n+ *                                       null);\n+ * <\/pre>\n+ *\n+ * If {@code raster} is not an instance of {@link WritableRaster},\n+ * then a new {@link WritableRaster} is created wrapping the same\n+ * buffer <strong>but with a location of (0,0)<\/strong>, because\n+ * the {@code location} argument of {@code createWritableRaster}\n+ * is null. Consequently the call to {@code createWritableChild}\n+ * shall not be done in that case, because the raster is already\n+ * translated. The current code applies translation twice.\n+ *\n+ * This bug is largely unnoticed because most {@code Raster.create}\n+ * methods actually create {@link WritableRaster} instances, even\n+ * when the user did not asked for writable raster. To make this\n+ * bug apparent, we need to invoke {@code Raster.createRaster(â€¦)}\n+ * with a sample model for which no optimization is provided.\n+ *\/\n+final class TiledImage implements RenderedImage {\n+    \/**\n+     * Run the test using writable tiles first, then read-only tiles.\n+     *\/\n+    public static void main(String[] args) {\n+        draw(true);         \/\/ Pass.\n+        draw(false);        \/\/ Fail with exception described in javadoc.\n+    }\n+\n+    private static final int NUM_X_TILES = 2, NUM_Y_TILES = 3;\n+\n+    private static final int TILE_WIDTH = 16, TILE_HEIGHT = 12;\n+\n+    \/**\n+     * Tests rendering a tiled image.\n+     *\n+     * @param  writable  whether the image shall use writable raster.\n+     *\/\n+    private static void draw(final boolean writable) {\n+        final BufferedImage target = new BufferedImage(\n+                TILE_WIDTH  * NUM_X_TILES,\n+                TILE_HEIGHT * NUM_Y_TILES,\n+                BufferedImage.TYPE_BYTE_GRAY);\n+\n+        final RenderedImage source = new TiledImage(writable,\n+                target.getColorModel());\n+\n+        Graphics2D g = target.createGraphics();\n+        g.drawRenderedImage(source, new AffineTransform());\n+        g.dispose();\n+    }\n+\n+    private final ColorModel colorModel;\n+\n+    private final Raster[] tiles;\n+\n+    \/**\n+     * Creates a tiled image. The image is empty,\n+     * but pixel values are not the purpose of this test.\n+     *\n+     * @param  writable  whether the image shall use writable raster.\n+     *\/\n+    private TiledImage(boolean writable, ColorModel cm) {\n+        \/*\n+         * We need a sample model class for which Raster.createRaster\n+         * do not provide a special case. That method has optimizations\n+         * for most SampleModel sub-types, except BandedSampleModel.\n+         *\/\n+        SampleModel sm = new BandedSampleModel(DataBuffer.TYPE_BYTE, TILE_WIDTH, TILE_HEIGHT, 1);\n+        tiles = new Raster[NUM_X_TILES * NUM_Y_TILES];\n+        final Point location = new Point();\n+        for (int tileY = 0; tileY < NUM_Y_TILES; tileY++) {\n+            for (int tileX = 0; tileX < NUM_X_TILES; tileX++) {\n+                location.x = tileX * TILE_WIDTH;\n+                location.y = tileY * TILE_HEIGHT;\n+                DataBufferByte db = new DataBufferByte(TILE_WIDTH * TILE_HEIGHT);\n+                Raster r;\n+                if (writable) {\n+                    r = Raster.createWritableRaster(sm, db, location);\n+                } else {\n+                    \/\/ Case causing RasterFormatException later.\n+                    r = Raster.createRaster(sm, db, location);\n+                }\n+                tiles[tileX + tileY * NUM_X_TILES] = r;\n+            }\n+        }\n+        colorModel = cm;\n+    }\n+\n+    @Override\n+    public ColorModel getColorModel() {\n+        return colorModel;\n+    }\n+\n+    @Override\n+    public SampleModel getSampleModel() {\n+        return tiles[0].getSampleModel();\n+    }\n+\n+    @Override\n+    public Vector<RenderedImage> getSources() {\n+        return new Vector();\n+    }\n+\n+    @Override\n+    public Object getProperty(String key) {\n+        return Image.UndefinedProperty;\n+    }\n+\n+    @Override\n+    public String[] getPropertyNames() {\n+        return null;\n+    }\n+\n+    @Override public int getMinX()            {return 0;}\n+    @Override public int getMinY()            {return 0;}\n+    @Override public int getMinTileX()        {return 0;}\n+    @Override public int getMinTileY()        {return 0;}\n+    @Override public int getTileGridXOffset() {return 0;}\n+    @Override public int getTileGridYOffset() {return 0;}\n+    @Override public int getNumXTiles()       {return NUM_X_TILES;}\n+    @Override public int getNumYTiles()       {return NUM_Y_TILES;}\n+    @Override public int getTileWidth()       {return TILE_WIDTH;}\n+    @Override public int getTileHeight()      {return TILE_HEIGHT;}\n+    @Override public int getWidth()           {return TILE_WIDTH  * NUM_X_TILES;}\n+    @Override public int getHeight()          {return TILE_HEIGHT * NUM_Y_TILES;}\n+\n+    @Override\n+    public Raster getTile(final int tileX, final int tileY) {\n+        Objects.checkIndex(tileX, NUM_X_TILES);\n+        Objects.checkIndex(tileY, NUM_Y_TILES);\n+        return tiles[tileX + tileY * NUM_X_TILES];\n+    }\n+\n+    @Override\n+    public Raster getData() {\n+        throw new UnsupportedOperationException(\"Not needed for this test.\");\n+    }\n+\n+    @Override\n+    public Raster getData(Rectangle rect) {\n+        throw new UnsupportedOperationException(\"Not needed for this test.\");\n+    }\n+\n+    @Override\n+    public WritableRaster copyData(WritableRaster raster) {\n+        throw new UnsupportedOperationException(\"Not needed for this test.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/DrawImage\/TiledImage.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}