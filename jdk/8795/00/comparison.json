{"files":[{"patch":"@@ -505,0 +505,10 @@\n+void HandshakeState::clean_async_exception_operation() {\n+  while (has_async_exception_operation(\/* ThreadDeath_only *\/ false)) {\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    HandshakeOperation* op;\n+    op = _queue.peek(async_exception_filter);\n+    remove_op(op);\n+    delete op;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  void clean_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1367,0 +1367,1 @@\n+  assert(!is_exiting(), \"should not be exiting or terminated already\");\n@@ -1428,7 +1429,0 @@\n-\n-    \/\/ The careful dance between thread suspension and exit is handled here.\n-    \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n-    \/\/ we can just put in the exiting state and it will be correctly handled.\n-    set_terminated(_thread_exiting);\n-\n-    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n@@ -1436,1 +1430,0 @@\n-    assert(!is_terminated() && !is_exiting(), \"must not be exiting\");\n@@ -1440,0 +1433,13 @@\n+  \/\/ Cleanup any pending async exception now since we cannot access oops after\n+  \/\/ BarrierSet::barrier_set()->on_thread_detach() has been executed.\n+  if (has_async_exception_condition()) {\n+    handshake_state()->clean_async_exception_operation();\n+  }\n+\n+  \/\/ The careful dance between thread suspension and exit is handled here.\n+  \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n+  \/\/ we can just put in the exiting state and it will be correctly handled.\n+  \/\/ Also, no more async exceptions will be added to the queue after this point.\n+  set_terminated(_thread_exiting);\n+  ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n+\n@@ -1531,1 +1537,2 @@\n-  \/\/ Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread\n+  \/\/ Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread.\n+  \/\/ We call BarrierSet::barrier_set()->on_thread_detach() here so no touching of oops after this point.\n@@ -1701,2 +1708,3 @@\n-  \/\/ Do not throw asynchronous exceptions against the compiler thread.\n-  if (!can_call_java()) {\n+  \/\/ Do not throw asynchronous exceptions against the compiler thread\n+  \/\/ or if the thread is already exiting.\n+  if (!can_call_java() || is_exiting()) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+        test(timeMax);\n@@ -76,0 +77,22 @@\n+        \/\/ Fire-up deamon that just creates new threads. This generates contention on\n+        \/\/ Threads_lock while worker tries to exit, creating more places where target\n+        \/\/ can be seen as handshake safe.\n+        Thread threadCreator = new Thread() {\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    Thread dummyThread = new Thread(() -> {});\n+                    dummyThread.start();\n+                    try {\n+                        dummyThread.join();\n+                    } catch(InterruptedException ie) {\n+                    }\n+                }\n+            }\n+        };\n+        threadCreator.setDaemon(true);\n+        threadCreator.start();\n+        test(timeMax);\n+    }\n+\n+    public static void test(int timeMax) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+        test(timeMax);\n@@ -82,0 +83,22 @@\n+        \/\/ Fire-up deamon that just creates new threads. This generates contention on\n+        \/\/ Threads_lock while worker tries to exit, creating more places where target\n+        \/\/ can be seen as handshake safe.\n+        Thread threadCreator = new Thread() {\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    Thread dummyThread = new Thread(() -> {});\n+                    dummyThread.start();\n+                    try {\n+                        dummyThread.join();\n+                    } catch(InterruptedException ie) {\n+                    }\n+                }\n+            }\n+        };\n+        threadCreator.setDaemon(true);\n+        threadCreator.start();\n+        test(timeMax);\n+    }\n+\n+    public static void test(int timeMax) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/SuspendAtExit.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}