{"files":[{"patch":"@@ -657,25 +657,0 @@\n-static const char* get_signal_handler_name(address handler,\n-                                           char* buf, int buflen) {\n-  int offset = 0;\n-  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n-  if (found) {\n-    \/\/ skip directory names\n-    const char *p1, *p2;\n-    p1 = buf;\n-    size_t len = strlen(os::file_separator());\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n-#if !defined(AIX)\n-    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n-#else\n-    \/\/ The way os::dll_address_to_library_name is implemented on Aix\n-    \/\/ right now, it always returns -1 for the offset which is not\n-    \/\/ terribly informative.\n-    \/\/ Will fix that. For now, omit the offset.\n-    jio_snprintf(buf, buflen, \"%s\", p1);\n-#endif\n-  } else {\n-    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n-  }\n-  return buf;\n-}\n-\n@@ -833,2 +808,4 @@\n-    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n-    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n+    tty->print_raw(\"expected:\");\n+    os::print_function_and_library_name(tty, jvmHandler, buf, O_BUFLEN, true, true, true);\n+    tty->print_raw(\"  found:\");\n+    os::print_function_and_library_name(tty, thisHandler, buf, O_BUFLEN, true, true, true);\n@@ -1375,1 +1352,1 @@\n-  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n+  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n@@ -1384,1 +1361,5 @@\n-    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n+    os::print_function_and_library_name(st, handler, buf, buflen,\n+                                        true, \/\/ shorten_path\n+                                        true, \/\/ demangle\n+                                        true  \/\/ omit arguments\n+                                        );\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -885,0 +885,47 @@\n+bool os::print_function_and_library_name(outputStream* st,\n+                                         address addr,\n+                                         char* buf, int buflen,\n+                                         bool shorten_paths,\n+                                         bool demangle,\n+                                         bool strip_arguments) {\n+  \/\/ If no scratch buffer given, allocate one here on stack.\n+  \/\/ (used during error handling; its a coin toss, really, if on-stack allocation\n+  \/\/  is worse than (raw) C-heap allocation in that case).\n+  char* p = buf;\n+  if (p == NULL) {\n+    p = (char*)::alloca(O_BUFLEN);\n+    buflen = O_BUFLEN;\n+  }\n+  int offset = 0;\n+  const bool have_function_name = dll_address_to_function_name(addr, p, buflen,\n+                                                               &offset, demangle);\n+  if (have_function_name) {\n+    if (demangle && strip_arguments) {\n+      char* args_start = strchr(p, '(');\n+      if (args_start != NULL) {\n+        *args_start = '\\0';\n+      }\n+    }\n+    st->print(\"%s+%d\", p, offset);\n+  } else {\n+    st->print(PTR_FORMAT, p2i(addr));\n+  }\n+  offset = 0;\n+\n+  const bool have_library_name = dll_address_to_library_name(addr, p, buflen, &offset);\n+  if (have_library_name) {\n+    \/\/ Cut path parts\n+    if (shorten_paths) {\n+      char* p2 = strrchr(p, os::file_separator()[0]);\n+      if (p2 != NULL) {\n+        p = p2 + 1;\n+      }\n+    }\n+    st->print(\" in %s\", p);\n+    if (!have_function_name) { \/\/ Omit offset if we already printed the function offset\n+      st->print(\"+%d\", offset);\n+    }\n+  }\n+  return have_function_name || have_library_name;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -602,0 +602,18 @@\n+  \/\/ Given an address, attempt to locate both the symbol and the library it\n+  \/\/ resides in. If at least one of these steps was successful, prints information\n+  \/\/ and returns true.\n+  \/\/ - if no scratch buffer is given, stack is used\n+  \/\/ - shorten_paths: path is omitted from library name\n+  \/\/ - demangle: function name is demangled\n+  \/\/ - strip_arguments: arguments are stripped (requires demangle=true)\n+  \/\/ On success prints either one of:\n+  \/\/ \"<function name>+<offset> in <library>\"\n+  \/\/ \"<function name>+<offset>\"\n+  \/\/ \"<address> in <library>+<offset>\"\n+  static bool print_function_and_library_name(outputStream* st,\n+                                              address addr,\n+                                              char* buf = NULL, int buflen = 0,\n+                                              bool shorten_paths = true,\n+                                              bool demangle = true,\n+                                              bool strip_arguments = false);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -699,0 +700,95 @@\n+\n+TEST_VM(os, dll_address_to_function_and_library_name) {\n+  char tmp[1024];\n+  char output[1024];\n+  stringStream st(output, sizeof(output));\n+\n+#define EXPECT_CONTAINS(haystack, needle) \\\n+  EXPECT_NE(::strstr(haystack, needle), (char*)NULL)\n+#define EXPECT_DOES_NOT_CONTAIN(haystack, needle) \\\n+  EXPECT_EQ(::strstr(haystack, needle), (char*)NULL)\n+#define LOG(...) tty->print_cr(__VA_ARGS__);\n+\n+  \/\/ Invalid addresses\n+  address addr = (address)(intptr_t)-1;\n+  EXPECT_FALSE(os::print_function_and_library_name(&st, addr));\n+  addr = NULL;\n+  EXPECT_FALSE(os::print_function_and_library_name(&st, addr));\n+\n+  \/\/ Valid addresses\n+  \/\/ Test with or without shorten-paths, demangle, and scratch buffer\n+  for (int i = 0; i < 16; i++) {\n+    const bool shorten_paths = (i & 1) != 0;\n+    const bool demangle = (i & 2) != 0;\n+    const bool strip_arguments = (i & 4) != 0;\n+    const bool provide_scratch_buffer = (i & 8) != 0;\n+    LOG(\"shorten_paths=%d, demangle=%d, strip_arguments=%d, provide_scratch_buffer=%d\",\n+        shorten_paths, demangle, strip_arguments, provide_scratch_buffer);\n+\n+    \/\/ Should show os::min_page_size in libjvm\n+    addr = CAST_FROM_FN_PTR(address, Threads::create_vm);\n+    st.reset();\n+    EXPECT_TRUE(os::print_function_and_library_name(&st, addr,\n+                                                    provide_scratch_buffer ? tmp : NULL,\n+                                                    sizeof(tmp),\n+                                                    shorten_paths, demangle,\n+                                                    strip_arguments));\n+    EXPECT_CONTAINS(output, \"Threads\");\n+    EXPECT_CONTAINS(output, \"create_vm\");\n+    EXPECT_CONTAINS(output, \"jvm\"); \/\/ \"jvm.dll\" or \"libjvm.so\" or similar\n+    if (demangle) {\n+      if (strip_arguments) {\n+        EXPECT_DOES_NOT_CONTAIN(output, \"(\");\n+      } else {\n+        EXPECT_CONTAINS(output, \"(\");\n+      }\n+    }\n+    LOG(\"%s\", output);\n+\n+    \/\/ Test truncation on scratch buffer\n+    if (provide_scratch_buffer) {\n+      st.reset();\n+      tmp[10] = 'X';\n+      EXPECT_TRUE(os::print_function_and_library_name(&st, addr, tmp, 10,\n+                                                      shorten_paths, demangle));\n+      EXPECT_EQ(tmp[10], 'X');\n+      LOG(\"%s\", output);\n+    }\n+\n+    \/\/ Pointer (probably) outside function, should show at least the library name\n+    addr -= 10;\n+    st.reset();\n+    EXPECT_TRUE(os::print_function_and_library_name(&st, addr,\n+                                                    provide_scratch_buffer ? tmp : NULL,\n+                                                    sizeof(tmp),\n+                                                    shorten_paths, demangle));\n+    EXPECT_CONTAINS(output, \"jvm\"); \/\/ \"jvm.dll\" or \"libjvm.so\" or similar\n+    LOG(\"%s\", output);\n+\n+    \/\/ Pointer into system library\n+#ifndef _WIN32\n+    addr = CAST_FROM_FN_PTR(address, ::malloc);\n+    st.reset();\n+    EXPECT_TRUE(os::print_function_and_library_name(&st, addr,\n+                                                    provide_scratch_buffer ? tmp : NULL,\n+                                                    sizeof(tmp),\n+                                                    shorten_paths, demangle));\n+    EXPECT_CONTAINS(output, \"malloc\");\n+    LINUX_ONLY(EXPECT_CONTAINS(output, \"libc\"));\n+    MACOS_ONLY(EXPECT_CONTAINS(output, \"libsystem\"));\n+    LOG(\"%s\", output);\n+#else\n+    addr = CAST_FROM_FN_PTR(address, CreateFileA);\n+    st.reset(); \/\/ this also zero-terminates start of output\n+    EXPECT_TRUE(os::print_function_and_library_name(&st, addr,\n+                                                    provide_scratch_buffer ? tmp : NULL,\n+                                                    sizeof(tmp),\n+                                                    shorten_paths, demangle));\n+    for (char* p = output; *p; p++) {\n+      *p = ::toupper(*p);\n+    }\n+    EXPECT_CONTAINS(output, \"KERNEL32.DLL\");\n+    LOG(\"%s\", output);\n+#endif\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"}]}