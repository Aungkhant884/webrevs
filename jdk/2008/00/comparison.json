{"files":[{"patch":"@@ -1945,1 +1945,1 @@\n-    o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \\\n+    o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false); \\\n@@ -2012,1 +2012,1 @@\n-    o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);\n+    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);\n@@ -2034,1 +2034,1 @@\n-    o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \\\n+    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \\\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1875,13 +1875,0 @@\n-  if (*((int *)get_field_access_count_addr()) > 0 && thread->has_last_Java_frame()) {\n-    \/\/ At least one field access watch is set so we have more work\n-    \/\/ to do. This wrapper is used by entry points that allow us\n-    \/\/ to create handles in post_field_access_by_jni().\n-    post_field_access_by_jni(thread, obj, klass, fieldID, is_static);\n-    \/\/ event posting can block so refetch oop if we were passed a jobj\n-    if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);\n-  }\n-  return obj;\n-}\n-\n-oop JvmtiExport::jni_GetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,\n-                                       Klass* klass, jfieldID fieldID, bool is_static) {\n@@ -1965,14 +1952,0 @@\n-  if (*((int *)get_field_modification_count_addr()) > 0 && thread->has_last_Java_frame()) {\n-    \/\/ At least one field modification watch is set so we have more work\n-    \/\/ to do. This wrapper is used by entry points that allow us\n-    \/\/ to create handles in post_field_modification_by_jni().\n-    post_field_modification_by_jni(thread, obj, klass, fieldID, is_static, sig_type, value);\n-    \/\/ event posting can block so refetch oop if we were passed a jobj\n-    if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);\n-  }\n-  return obj;\n-}\n-\n-oop JvmtiExport::jni_SetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,\n-                                       Klass* klass, jfieldID fieldID, bool is_static,\n-                                       char sig_type, jvalue *value) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,3 +313,0 @@\n-  static oop jni_GetField_probe_nh       (JavaThread *thread, jobject jobj,\n-    oop obj, Klass* klass, jfieldID fieldID, bool is_static)\n-    NOT_JVMTI_RETURN_(NULL);\n@@ -322,3 +319,0 @@\n-    jvalue *value) NOT_JVMTI_RETURN_(NULL);\n-  static oop jni_SetField_probe_nh       (JavaThread *thread, jobject jobj,\n-    oop obj, Klass* klass, jfieldID fieldID, bool is_static, char sig_type,\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}