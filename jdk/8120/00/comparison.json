{"files":[{"patch":"@@ -37,8 +37,0 @@\n-  \/\/ Returns address of n-th instruction preceding addr,\n-  \/\/ NULL if no preceding instruction can be found.\n-  \/\/ On ARM(aarch64), we assume a constant instruction length.\n-  \/\/ It might be beneficial to check \"is_readable\" as we do on ppc and s390.\n-  static address find_prev_instr(address addr, int n_instr) {\n-    return addr - Assembler::instruction_size*n_instr;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/disassembler_aarch64.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,8 +36,0 @@\n-  \/\/ Returns address of n-th instruction preceding addr,\n-  \/\/ NULL if no preceding instruction can be found.\n-  \/\/ On ARM, we assume a constant instruction length.\n-  \/\/ It might be beneficial to check \"is_readable\" as we do on ppc and s390.\n-  static address find_prev_instr(address addr, int n_instr) {\n-    return addr - Assembler::InstructionSize*n_instr;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/disassembler_arm.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -90,16 +90,0 @@\n-address Disassembler::find_prev_instr(address here, int n_instr) {\n-  if (!os::is_readable_pointer(here)) return NULL;    \/\/ obviously a bad location to decode\n-\n-  \/\/ Find most distant possible starting point.\n-  \/\/ Narrow down because we don't want to SEGV while printing.\n-  address start = here - n_instr*Assembler::instr_maxlen(); \/\/ starting point can't be further away.\n-  while ((start < here) && !os::is_readable_range(start, here)) {\n-    start = align_down(start, os::min_page_size()) + os::min_page_size();\n-  }\n-  if (start >= here) {\n-    \/\/ Strange. Can only happen with here on page boundary.\n-    return NULL;\n-  }\n-  return start;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/disassembler_ppc.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,9 +37,0 @@\n-  \/\/ Find preceding instruction.\n-  \/\/\n-  \/\/ Starting at the passed location, the n-th preceding (towards lower addresses)\n-  \/\/ location is searched, the contents of which - if interpreted as\n-  \/\/ instructions - has the passed location as n-th successor.\n-  \/\/  - If no such location exists, NULL is returned. The caller should then\n-  \/\/    terminate its search and react properly.\n-  static address find_prev_instr(address here, int n_instr);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/disassembler_ppc.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,8 +38,0 @@\n-\/\/ Returns address of n-th instruction preceding addr,\n-\/\/ NULL if no preceding instruction can be found.\n-\/\/ On riscv, we assume a constant instruction length.\n-\/\/ It might be beneficial to check \"is_readable\" as we do on ppc and s390.\n-static address find_prev_instr(address addr, int n_instr) {\n-  return addr - Assembler::instruction_size * n_instr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/disassembler_riscv.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,47 +39,0 @@\n-\/\/ List of all major opcodes, as of\n-\/\/ Principles of Operation, Eleventh Edition, March 2015\n-bool Disassembler::valid_opcodes[] =\n-{ true,  true,  false, false, true,  true,  true,  true,  \/\/ 0x00..07\n-  false, false, true,  true,  true,  true,  true,  true,  \/\/ 0x08..0f\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x10..17\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x18..1f\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x20..27\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x28..2f\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x30..37\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x38..3f\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x40..47\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x48..4f\n-  true,  true,  false, false, true,  true,  true,  true,  \/\/ 0x50..57\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x58..5f\n-  true,  false, false, false, false, false, false, true,  \/\/ 0x60..67\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x68..6f\n-  true,  true,  false, false, false, false, false, false, \/\/ 0x70..77\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x78..7f\n-  true,  false, true,  true,  true,  true,  true,  true,  \/\/ 0x80..87\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x88..8f\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0x90..97\n-  true,  true,  true,  true,  false, false, false, false, \/\/ 0x98..9f\n-  false, false, false, false, false, true,  false, true,  \/\/ 0xa0..a7\n-  true,  true,  false, false, true,  true,  true,  true,  \/\/ 0xa8..af\n-  false, true,  true,  true,  false, false, true,  true,  \/\/ 0xb0..b7\n-  false, true,  true,  true,  false, true,  true,  true,  \/\/ 0xb8..bf\n-  true,  false, true,  false, true,  false, true,  false, \/\/ 0xc0..c7\n-  true,  false, false, false, true,  false, false, false, \/\/ 0xc8..cf\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0xd0..d7\n-  false, true,  true,  true,  true,  true,  true,  true,  \/\/ 0xd8..df\n-  false, true,  true,  true,  false, true,  false, true,  \/\/ 0xe0..e7\n-  true,  true,  true,  true,  true,  true,  true,  true,  \/\/ 0xe8..ef\n-  true,  true,  true,  true,  false, false, false, false, \/\/ 0xf0..f7\n-  true,  true,  true,  true,  true,  true,  false, false, \/\/ 0xf8..ff\n-};\n-\/\/ Check for valid opcodes.\n-\/\/\n-\/\/ The major opcode (one byte) at the passed location is inspected.\n-\/\/ If the opcode found is assigned, the function returns true, false otherwise.\n-\/\/ The true indication is not reliable. It may well be that the major opcode is\n-\/\/ assigned, but there exists a minor opcode field in the instruction which\n-\/\/ which has unassigned values.\n-bool Disassembler::is_valid_opcode_at(address here) {\n-  return valid_opcodes[*here];\n-}\n-\n@@ -172,68 +125,0 @@\n-\/\/ Count the instructions contained in the range [begin..end).\n-\/\/ The range must exactly contain the instructions, i.e.\n-\/\/  - the first instruction starts @begin\n-\/\/  - the last instruction ends @(end-1)\n-\/\/ The caller has to make sure that the given range is readable.\n-\/\/ This function performs no safety checks!\n-\/\/ Return value:\n-\/\/  - The number of instructions, if there was exact containment.\n-\/\/  - If there is no exact containment, a negative value is returned.\n-\/\/    Its absolute value is the number of instructions from begin to end,\n-\/\/    where the last instruction counted runs over the range end.\n-\/\/  - 0 (zero) is returned if there was a parameter error\n-\/\/    (inverted range, bad starting point).\n-int Disassembler::count_instr(address begin, address end) {\n-  if (end < begin+2) return 0; \/\/ no instructions in range\n-  if (!Disassembler::is_valid_opcode_at(begin)) return 0; \/\/ bad starting point\n-\n-  address p = begin;\n-  int     n = 0;\n-  while(p < end) {\n-    p += Assembler::instr_len(p);\n-    n++;\n-  }\n-  return (p == end) ? n : -n;\n-}\n-\n-\/\/ Find preceding instruction.\n-\/\/\n-\/\/ Starting at the passed location, the n-th preceding (towards lower addresses)\n-\/\/ instruction is searched. With variable length instructions, there may be\n-\/\/ more than one solution, or no solution at all (if the passed location\n-\/\/ does not point to the start of an instruction or if the storage area\n-\/\/ does not contain instructions at all).\n-\/\/ instructions - has the passed location as n-th successor.\n-\/\/  - If multiple such locations exist between (here-n*instr_maxlen()) and here,\n-\/\/    the most distant location is selected.\n-\/\/  - If no such location exists, NULL is returned. The caller should then\n-\/\/    terminate its search and react properly.\n-\/\/ Must be placed here in disassembler_s390.cpp. It does not compile\n-\/\/ in the header. There the class 'Assembler' is not available.\n-address Disassembler::find_prev_instr(address here, int n_instr) {\n-  if (!os::is_readable_pointer(here)) return NULL;    \/\/ obviously a bad location to decode\n-\n-  \/\/ Find most distant possible starting point.\n-  \/\/ Narrow down because we don't want to SEGV while printing.\n-  address start = here - n_instr*Assembler::instr_maxlen(); \/\/ starting point can't be further away.\n-  while ((start < here) && !os::is_readable_range(start, here)) {\n-    start = align_down(start, os::min_page_size()) + os::min_page_size();\n-  }\n-  if (start >= here) {\n-    \/\/ Strange. Can only happen with here on page boundary.\n-    return NULL;\n-  }\n-\n-  \/\/---<  Find a starting point  >---\n-  int i_count = 0;\n-  while ((start < here) && ((i_count = count_instr(start, here)) <= 0)) start += 2;\n-  if (i_count == 0) return NULL; \/\/ There is something seriously wrong\n-\n-  \/\/---<  Narrow down distance (estimate was too large)  >---\n-  while(i_count-- > n_instr) {\n-    start   += Assembler::instr_len(start);\n-  }\n-  assert(n_instr >= count_instr(start, here), \"just checking\");\n-  return start;\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/s390\/disassembler_s390.cpp","additions":0,"deletions":115,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -37,15 +37,0 @@\n-  static bool valid_opcodes[256];\n-  static bool is_valid_opcode_at(address here);\n-\n-  \/\/ Find preceding instruction.\n-  \/\/\n-  \/\/ Starting at the passed location, the n-th preceding (towards lower addresses)\n-  \/\/ location is searched, the contents of which - if interpreted as\n-  \/\/ instructions - has the passed location as n-th successor.\n-  \/\/  - If multiple such locations exist between (here-n*instr_maxlen()) and here,\n-  \/\/    the most distant location is selected.\n-  \/\/  - If no such location exists, NULL is returned. The caller should then\n-  \/\/    terminate its search and react properly.\n-  static address find_prev_instr(address here, int n_instr);\n-  static int     count_instr(address begin, address end);\n-\n","filename":"src\/hotspot\/cpu\/s390\/disassembler_s390.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,9 +36,0 @@\n-  \/\/ Returns address of n-th instruction preceding addr,\n-  \/\/ NULL if no preceding instruction can be found.\n-  \/\/ On CISC architectures, it is difficult to impossible to step\n-  \/\/ backwards in the instruction stream. Therefore just return NULL.\n-  \/\/ It might be beneficial to check \"is_readable\" as we do on ppc and s390.\n-  static address find_prev_instr(address addr, int n_instr) {\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/disassembler_x86.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,8 +37,0 @@\n-  \/\/ Returns address of n-th instruction preceding addr,\n-  \/\/ NULL if no preceding instruction can be found.\n-  \/\/ On ZERO, we assume a constant instruction length of 1 byte.\n-  \/\/ It might be beneficial to check \"is_readable\" as we do on ppc and s390.\n-  static address find_prev_instr(address addr, int n_instr) {\n-    return addr - 1*n_instr;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/zero\/disassembler_zero.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}