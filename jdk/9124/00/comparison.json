{"files":[{"patch":"@@ -303,2 +303,0 @@\n-  \/\/ for rbp, based address use this:\n-  \/\/ return Address(rbp, in_bytes(sp_offset) - (framesize() - 2) * 4);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FrameMap_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-  \/\/ rbp, + 0: link\n+  \/\/ rfp, + 0: link\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-    \/\/ Since the prolog does the save and restore of EBP there is no oopmap\n+    \/\/ Since the prolog does the save and restore of FP there is no oopmap\n@@ -467,8 +467,5 @@\n-  \/\/ The interpreter and compiler(s) always save EBP\/RBP in a known\n-  \/\/ location on entry. We must record where that location is\n-  \/\/ so this if EBP\/RBP was live on callout from c2 we can find\n-  \/\/ the saved copy no matter what it called.\n-\n-  \/\/ Since the interpreter always saves EBP\/RBP if we record where it is then\n-  \/\/ we don't have to always save EBP\/RBP on entry and exit to c2 compiled\n-  \/\/ code, on entry will be enough.\n+  \/\/ The interpreter and compiler(s) always save FP in a known\n+  \/\/ location on entry. C2-compiled code uses FP as an allocatable\n+  \/\/ callee-saved register. We must record where that location is so\n+  \/\/ that if FP was live on callout from c2 we can find the saved copy.\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  \/\/ intrinsified Reference.get() routine) then ebp might be pointing to\n+  \/\/ intrinsified Reference.get() routine) then rfp might be pointing to\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  \/\/ intrinsified Reference.get() routine) then ebp might be pointing to\n+  \/\/ intrinsified Reference.get() routine) then rfp might be pointing to\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    rbp_off = 0,\n-    rbp_off2,\n+    rfp_off = 0,\n+    rfp_off2,\n@@ -2759,1 +2759,1 @@\n-\/\/ This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame\n+\/\/ This is here instead of runtime_aarch64_64.cpp because it uses SimpleRuntimeFrame\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3775,1 +3775,1 @@\n-\/\/ [saved rbp    ] <--- rbp\n+\/\/ [saved rfp    ] <--- rfp\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}