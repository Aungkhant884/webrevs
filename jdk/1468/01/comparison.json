{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -37,1 +39,0 @@\n-import java.util.List;\n@@ -176,0 +177,13 @@\n+ * <p>A layout path with free dimensions can also be used to create an offset computing method handle, using the\n+ * {@link #bitOffset(PathElement...)} or {@link #byteOffsetHandle(PathElement...)} method. Again, free dimensions are\n+ * translated into {@code long} parameters of the created method handle. The method handle can be used to compute the\n+ * offsets of elements of a sequence at different indices, by supplying these indices when invoking the method handle.\n+ * For instance:\n+ *\n+ * <blockquote><pre>{@code\n+MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n+                                                          PathElement.groupElement(\"kind\"));\n+long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n+long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+ * }<\/pre><\/blockquote>\n+ *\n@@ -340,3 +354,0 @@\n-     * @apiNote if the layout path has one (or more) free dimensions,\n-     * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.\n-     *\n@@ -351,1 +362,34 @@\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+    }\n+\n+    \/**\n+     * Creates a method handle that can be used to compute the offset, in bits, of the layout selected\n+     * by a given layout path, where the path is considered rooted in this layout.\n+     *\n+     * <p>The returned method handle has a return type of {@code long}, and features as many {@code long}\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * where the order of the parameters corresponds to the order of the path elements.\n+     * The returned method handle can be used to compute a layout offset similar to {@link #bitOffset(PathElement...)},\n+     * but where some sequence indices are specified only when invoking the method handle.\n+     *\n+     * <p>The final offset returned by the method handle is computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+    offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n+     * <em>static<\/em> stride constants which are derived from the layout path.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle that can be used to compute the bit offset of the layout element\n+     * specified by the given layout path elements, when supplied with the missing sequence element indices.\n+     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n+     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n+     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n+     *\/\n+    default MethodHandle bitOffsetHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offsetHandle,\n+                EnumSet.of(PathKind.SEQUENCE_RANGE), elements);\n@@ -358,3 +402,0 @@\n-     * @apiNote if the layout path has one (or more) free dimensions,\n-     * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.\n-     *\n@@ -370,2 +411,38 @@\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements),\n-                () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\"));\n+        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.bitsToBytesThrowOffset);\n+    }\n+\n+    \/**\n+     * Creates a method handle that can be used to compute the offset, in bytes, of the layout selected\n+     * by a given layout path, where the path is considered rooted in this layout.\n+     *\n+     * <p>The returned method handle has a return type of {@code long}, and features as many {@code long}\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * where the order of the parameters corresponds to the order of the path elements.\n+     * The returned method handle can be used to compute a layout offset similar to {@link #byteOffset(PathElement...)},\n+     * but where some sequence indices are specified only when invoking the method handle.\n+     *\n+     * <p>The final offset returned by the method handle is computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+    bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+    offset = bitOffset \/ 8\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n+     * <em>static<\/em> stride constants which are derived from the layout path.\n+     *\n+     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n+     * offset in bits is not a multiple of 8.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle that can be used to compute the byte offset of the layout element\n+     * specified by the given layout path elements, when supplied with the missing sequence element indices.\n+     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n+     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n+     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n+     *\/\n+    default MethodHandle byteOffsetHandle(PathElement... elements) {\n+        MethodHandle mh = bitOffsetHandle(elements);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.MH_bitsToBytesOrThrowForOffset);\n+        return mh;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":87,"deletions":10,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+    private static final MethodHandle MH_ADD_SCALED_OFFSET;\n+\n+    private static final int UNSPECIFIED_ELEM_INDEX = -1;\n@@ -67,1 +70,2 @@\n-            ADD_STRIDE = MethodHandles.lookup().findStatic(LayoutPath.class, \"addStride\",\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            ADD_STRIDE = lookup.findStatic(LayoutPath.class, \"addStride\",\n@@ -69,0 +73,2 @@\n+            MH_ADD_SCALED_OFFSET = lookup.findStatic(LayoutPath.class, \"addScaledOffset\",\n+                    MethodType.methodType(long.class, long.class, long.class, long.class));\n@@ -96,1 +102,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(sizeFunc.applyAsLong(elem)), -1, this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(sizeFunc.applyAsLong(elem)), UNSPECIFIED_ELEM_INDEX, this);\n@@ -105,1 +111,2 @@\n-        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step), -1, this);\n+        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step),\n+                UNSPECIFIED_ELEM_INDEX, this);\n@@ -180,0 +187,16 @@\n+    private static long addScaledOffset(long base, long index, long stride) {\n+        return base + (stride * index);\n+    }\n+\n+    public MethodHandle offsetHandle() {\n+        MethodHandle mh = MethodHandles.identity(long.class);\n+        for (int i = strides.length - 1; i >=0; i--) {\n+            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2, strides[i]);\n+            \/\/ (J, ...) -> J to (J, J, ...) -> J\n+            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n+            mh = MethodHandles.collectArguments(mh, 0, collector);\n+        }\n+        mh = MethodHandles.insertArguments(mh, 0, offset);\n+        return mh;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n+\n+    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n+        = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n@@ -59,1 +63,2 @@\n-            SEGMENT_FILTER = MethodHandles.lookup().findStatic(Utils.class, \"filterSegment\",\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            SEGMENT_FILTER = lookup.findStatic(Utils.class, \"filterSegment\",\n@@ -61,0 +66,5 @@\n+            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n+                lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n+                    MethodType.methodType(long.class, long.class, Supplier.class)),\n+                1,\n+                bitsToBytesThrowOffset);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n@@ -40,0 +43,3 @@\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n@@ -46,1 +52,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n@@ -52,1 +58,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n@@ -58,2 +64,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.bitOffset(PathElement.sequenceElement());\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n+        g.bitOffset(sequenceElement());\n@@ -64,2 +70,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.byteOffset(PathElement.sequenceElement());\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n+        g.byteOffset(sequenceElement());\n@@ -70,2 +76,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(), PathElement.sequenceElement());\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n+        seq.bitOffset(sequenceElement(), sequenceElement());\n@@ -76,2 +82,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(), PathElement.sequenceElement());\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n+        seq.byteOffset(sequenceElement(), sequenceElement());\n@@ -82,1 +88,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n@@ -88,1 +94,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n@@ -94,2 +100,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(6));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(6));\n@@ -100,2 +106,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(6));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.byteOffset(sequenceElement(6));\n@@ -106,1 +112,1 @@\n-       PathElement.sequenceElement(-2);\n+       sequenceElement(-2);\n@@ -111,2 +117,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(-2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(-2));\n@@ -117,2 +123,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(-2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.byteOffset(sequenceElement(-2));\n@@ -123,2 +129,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(6, 2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(6, 2));\n@@ -129,1 +135,1 @@\n-        PathElement.sequenceElement(-2, 2);\n+        sequenceElement(-2, 2);\n@@ -134,2 +140,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(-2, 2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(-2, 2));\n@@ -140,2 +146,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(-2, 2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.byteOffset(sequenceElement(-2, 2));\n@@ -146,2 +152,14 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT));\n-        seq.varHandle(int.class, PathElement.sequenceElement());\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        seq.varHandle(int.class, sequenceElement());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBitOffsetHandleBadRange() {\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        seq.bitOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testByteOffsetHandleBadRange() {\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        seq.byteOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n@@ -152,1 +170,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(3), MemoryLayouts.JAVA_INT.withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(3), JAVA_INT.withName(\"foo\"));\n@@ -156,0 +174,37 @@\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBitOffsetBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.bitOffset(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testByteOffsetBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.byteOffset(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBitOffsetHandleBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.bitOffsetHandle(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testByteOffsetHandleBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.byteOffsetHandle(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBadByteOffsetNoMultipleOf8() {\n+        MemoryLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(7), JAVA_INT.withName(\"x\"));\n+        layout.byteOffset(groupElement(\"x\"));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBadByteOffsetHandleNoMultipleOf8() throws Throwable {\n+        MemoryLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(7), JAVA_INT.withName(\"x\"));\n+        MethodHandle handle = layout.byteOffsetHandle(groupElement(\"x\"));\n+        handle.invoke();\n+    }\n+\n@@ -158,1 +213,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n@@ -177,1 +232,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, MemoryLayouts.JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n@@ -196,1 +251,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n@@ -198,1 +253,1 @@\n-        for (PathElement e : List.of( PathElement.sequenceElement(), PathElement.sequenceElement(0, 2) )) {\n+        for (PathElement e : List.of( sequenceElement(), sequenceElement(0, 2) )) {\n@@ -216,2 +271,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n-        for (PathElement e : List.of( PathElement.sequenceElement(0), PathElement.sequenceElement(0, 2) )) {\n+        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        for (PathElement e : List.of( sequenceElement(0), sequenceElement(0, 2) )) {\n@@ -229,2 +284,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n-        for (PathElement e : List.of( PathElement.sequenceElement(0), PathElement.sequenceElement(0, 2) )) {\n+        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        for (PathElement e : List.of( sequenceElement(0), sequenceElement(0, 2) )) {\n@@ -329,1 +384,1 @@\n-        MemoryLayout selected = g.select(PathElement.sequenceElement());\n+        MemoryLayout selected = g.select(sequenceElement());\n@@ -335,1 +390,1 @@\n-            long bitOffset = g.bitOffset(PathElement.sequenceElement(i));\n+            long bitOffset = g.bitOffset(sequenceElement(i));\n@@ -337,1 +392,1 @@\n-            long byteOffset = g.byteOffset(PathElement.sequenceElement(i));\n+            long byteOffset = g.byteOffset(sequenceElement(i));\n@@ -343,1 +398,1 @@\n-        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, PathElement.sequenceElement());\n+        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, sequenceElement());\n@@ -346,0 +401,92 @@\n+\n+    @Test(dataProvider =  \"offsetHandleCases\")\n+    public void testOffsetHandle(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                 long expectedBitOffset) throws Throwable {\n+        MethodHandle bitOffsetHandle = layout.bitOffsetHandle(pathElements);\n+        bitOffsetHandle = bitOffsetHandle.asSpreader(long[].class, indexes.length);\n+        long actualBitOffset = (long) bitOffsetHandle.invokeExact(indexes);\n+        assertEquals(actualBitOffset, expectedBitOffset);\n+        if (expectedBitOffset % 8 == 0) {\n+            MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+            byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+            long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+            assertEquals(actualByteOffset, expectedBitOffset \/ 8);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetHandleCases() {\n+        List<Object[]> testCases = new ArrayList<>();\n+\n+        testCases.add(new Object[] {\n+            MemoryLayout.ofSequence(10, JAVA_INT),\n+            new PathElement[] { sequenceElement() },\n+            new long[] { 4 },\n+            JAVA_INT.bitSize() * 4\n+        });\n+        testCases.add(new Object[] {\n+            MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(JAVA_INT, JAVA_INT.withName(\"y\"))),\n+            new PathElement[] { sequenceElement(), groupElement(\"y\") },\n+            new long[] { 4 },\n+            (JAVA_INT.bitSize() * 2) * 4 + JAVA_INT.bitSize()\n+        });\n+        testCases.add(new Object[] {\n+            MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(5), JAVA_INT.withName(\"y\"))),\n+            new PathElement[] { sequenceElement(), groupElement(\"y\") },\n+            new long[] { 4 },\n+            (JAVA_INT.bitSize() + 5) * 4 + 5\n+        });\n+        testCases.add(new Object[] {\n+            MemoryLayout.ofSequence(10, JAVA_INT),\n+            new PathElement[] { sequenceElement() },\n+            new long[] { 4 },\n+            JAVA_INT.bitSize() * 4\n+        });\n+        testCases.add(new Object[] {\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(10, JAVA_INT).withName(\"data\")\n+            ),\n+            new PathElement[] { groupElement(\"data\"), sequenceElement() },\n+            new long[] { 4 },\n+            JAVA_INT.bitSize() * 4\n+        });\n+\n+        MemoryLayout complexLayout = MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(10,\n+                MemoryLayout.ofSequence(10,\n+                    MemoryLayout.ofStruct(\n+                        JAVA_INT.withName(\"x\"),\n+                        JAVA_INT.withName(\"y\")\n+                    )\n+                )\n+            ).withName(\"data\")\n+        );\n+\n+        testCases.add(new Object[] {\n+            complexLayout,\n+            new PathElement[] { groupElement(\"data\"), sequenceElement(), sequenceElement(), groupElement(\"x\") },\n+            new long[] { 0, 1 },\n+            (JAVA_INT.bitSize() * 2)\n+        });\n+        testCases.add(new Object[] {\n+            complexLayout,\n+            new PathElement[] { groupElement(\"data\"), sequenceElement(), sequenceElement(), groupElement(\"x\") },\n+            new long[] { 1, 0 },\n+            (JAVA_INT.bitSize() * 2) * 10\n+        });\n+        testCases.add(new Object[] {\n+            complexLayout,\n+            new PathElement[] { groupElement(\"data\"), sequenceElement(), sequenceElement(), groupElement(\"y\") },\n+            new long[] { 0, 1 },\n+            (JAVA_INT.bitSize() * 2) + JAVA_INT.bitSize()\n+        });\n+        testCases.add(new Object[] {\n+            complexLayout,\n+            new PathElement[] { groupElement(\"data\"), sequenceElement(), sequenceElement(), groupElement(\"y\") },\n+            new long[] { 1, 0 },\n+            (JAVA_INT.bitSize() * 2) * 10 + JAVA_INT.bitSize()\n+        });\n+\n+        return testCases.toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":190,"deletions":43,"binary":false,"changes":233,"status":"modified"}]}