{"files":[{"patch":"@@ -167,1 +167,1 @@\n-        this.algorithmConstraints = new SSLAlgorithmConstraints(\n+        this.algorithmConstraints = SSLAlgorithmConstraints.wrap(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,7 @@\n+    static AlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n+        if (userSpecifiedConstraints == DEFAULT) {\n+            return DEFAULT;\n+        }\n+        return new SSLAlgorithmConstraints(userSpecifiedConstraints);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+import java.nio.ByteBuffer;\n+import java.security.KeyStore;\n+import java.util.Enumeration;\n+import java.util.concurrent.TimeUnit;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSessionContext;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+public class SSLHandshake {\n+\n+    private SSLContext sslc;\n+\n+    private SSLEngine clientEngine;\n+    private ByteBuffer clientOut = ByteBuffer.allocate(5);\n+    private ByteBuffer clientIn = ByteBuffer.allocate(1 << 15);\n+\n+    private SSLEngine serverEngine;\n+    private ByteBuffer serverOut = ByteBuffer.allocate(5);\n+    private ByteBuffer serverIn = ByteBuffer.allocate(1 << 15);\n+\n+    private ByteBuffer cTOs = ByteBuffer.allocateDirect(1 << 16);\n+    private ByteBuffer sTOc = ByteBuffer.allocateDirect(1 << 16);\n+\n+    @Param({\"true\", \"false\"})\n+    boolean resume;\n+\n+    @Param({\"TLSv1.2\", \"TLS\"})\n+    String tlsVersion;\n+\n+    @Setup(Level.Trial)\n+    public void init() throws Exception {\n+        KeyStore ks = TestCertificates.getKeyStore();\n+        KeyStore ts = TestCertificates.getTrustStore();\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, new char[0]);\n+\n+        TrustManagerFactory tmf =\n+                TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(tlsVersion);\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        sslc = sslCtx;\n+    }\n+\n+    private HandshakeStatus checkResult(SSLEngine engine, SSLEngineResult result) {\n+\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+\n+        if (hsStatus == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                runnable.run();\n+            }\n+            hsStatus = engine.getHandshakeStatus();\n+        }\n+        return hsStatus;\n+    }\n+\n+    \/**\n+     * This benchmark measures the time needed to perform a TLS handshake.\n+     * Data is exchanged using a pair of ByteBuffers.\n+     * The client and the server both operate on the same thread.\n+     *\/\n+    @Benchmark\n+    public SSLSession doHandshake() throws Exception {\n+\n+        createSSLEngines();\n+        boolean isCtoS = true;\n+        for (;;) {\n+            HandshakeStatus result;\n+            if (isCtoS) {\n+                result = checkResult(clientEngine,\n+                        clientEngine.wrap(clientOut, cTOs)\n+                );\n+                cTOs.flip();\n+                checkResult(serverEngine,\n+                        serverEngine.unwrap(cTOs, serverIn)\n+                );\n+                cTOs.compact();\n+                if (result == HandshakeStatus.NEED_UNWRAP) {\n+                    isCtoS = false;\n+                } else if (result == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (result != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected result \"+result);\n+                }\n+            } else {\n+                result = checkResult(serverEngine,\n+                        serverEngine.wrap(serverOut, sTOc)\n+                );\n+                sTOc.flip();\n+                checkResult(clientEngine,\n+                        clientEngine.unwrap(sTOc, clientIn)\n+                );\n+                sTOc.compact();\n+                if (result == HandshakeStatus.NEED_UNWRAP) {\n+                    isCtoS = true;\n+                } else if (result == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (result != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected result \"+result);\n+                }\n+            }\n+        }\n+\n+        SSLSession session = clientEngine.getSession();\n+        if (resume) {\n+            \/\/ TLS 1.3 needs another wrap\/unwrap to deliver a session ticket\n+            serverEngine.wrap(serverOut, sTOc);\n+            sTOc.flip();\n+            clientEngine.unwrap(sTOc, clientIn);\n+            sTOc.compact();\n+        } else {\n+            \/\/ invalidate TLS1.2 session. TLS 1.3 doesn't care\n+            session.invalidate();\n+        }\n+        return session;\n+    }\n+\n+    private void createSSLEngines() {\n+        \/*\n+         * Configure the serverEngine to act as a server in the SSL\/TLS\n+         * handshake.\n+         *\/\n+        serverEngine = sslc.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+\n+        \/*\n+         * Similar to above, but using client mode instead.\n+         *\/\n+        clientEngine = sslc.createSSLEngine(\"client\", 80);\n+        clientEngine.setUseClientMode(true);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.security;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.GeneralSecurityException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+\n+\/**\n+ * This class contains a 3-certificate chain for use in TLS tests.\n+ * The method {@link #getKeyStore()} returns a keystore with a single entry\n+ * containing one server+one intermediate CA certificate.\n+ * Server's CN and subjectAltName are both set to \"client\"\n+ *\n+ * The method {@link #getTrustStore()} returns a keystore with a single entry\n+ * containing the root CA certificate used for signing the intermediate CA.\n+ *\/\n+class TestCertificates {\n+\n+    \/\/ \"\/C=US\/ST=CA\/O=Test Root CA, Inc.\"\n+    \/\/ basicConstraints=critical, CA:true\n+    \/\/ subjectKeyIdentifier    = hash\n+    \/\/ authorityKeyIdentifier  = keyid:always\n+    \/\/ keyUsage                = keyCertSign\n+    private static final String ROOT_CA_CERT =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIB0jCCAXigAwIBAgIUE+wUdx22foJXSQzD3hpCNCqITLEwCgYIKoZIzj0EAwIw\\n\" +\n+            \"NzELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMRswGQYDVQQKDBJUZXN0IFJvb3Qg\\n\" +\n+            \"Q0EsIEluYy4wIBcNMjIwNDEyMDcxMzMzWhgPMjEyMjAzMTkwNzEzMzNaMDcxCzAJ\\n\" +\n+            \"BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEbMBkGA1UECgwSVGVzdCBSb290IENBLCBJ\\n\" +\n+            \"bmMuMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEBKye\/mwO0V0WLr71tf8auFEz\\n\" +\n+            \"EmqhaYWauaP17Fb33fRAeG8aVp9c4B0isv\/VgcqSTRMG0SJjbx7ttSYwR\/JNhqNg\\n\" +\n+            \"MF4wDwYDVR0TAQH\/BAUwAwEB\/zAdBgNVHQ4EFgQUpfGt4bjadmVzWeXAiSMp9pLU\\n\" +\n+            \"RMkwHwYDVR0jBBgwFoAUpfGt4bjadmVzWeXAiSMp9pLURMkwCwYDVR0PBAQDAgIE\\n\" +\n+            \"MAoGCCqGSM49BAMCA0gAMEUCIBF8YyD5BBuhkFNV\/3rNmvvMuvWUAECJ8rrUg8kr\\n\" +\n+            \"J8zpAiEAzbZQsC\/IZ0wVNd4lqHn6\/Ih5v7vhCgkg95KCP1NhBnU=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ \"\/C=US\/ST=CA\/O=Test Intermediate CA, Inc.\"\n+    \/\/ basicConstraints=critical, CA:true, pathlen:0\n+    \/\/ subjectKeyIdentifier    = hash\n+    \/\/ authorityKeyIdentifier  = keyid:always\n+    \/\/ keyUsage                = keyCertSign\n+    private static final String CA_CERT =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIB3TCCAYOgAwIBAgIUQ+lTbsDcIQ1UUg0RGdpJB6JMXpcwCgYIKoZIzj0EAwIw\\n\" +\n+            \"NzELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMRswGQYDVQQKDBJUZXN0IFJvb3Qg\\n\" +\n+            \"Q0EsIEluYy4wIBcNMjIwNDEyMDcxMzM0WhgPMjEyMjAzMTkwNzEzMzRaMD8xCzAJ\\n\" +\n+            \"BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEjMCEGA1UECgwaVGVzdCBJbnRlcm1lZGlh\\n\" +\n+            \"dGUgQ0EsIEluYy4wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQ7DsKCSQkP5oT2\\n\" +\n+            \"Wx0gf40N+H\/F75w1YmPm6dp2wiQ6JPMN\/4En87Ylx0ISJkeXJLxrbLvu2xZ+aonM\\n\" +\n+            \"kckNh\/ERo2MwYTASBgNVHRMBAf8ECDAGAQH\/AgEAMB0GA1UdDgQWBBTqP6hB5Ibr\\n\" +\n+            \"aivot\/zWSMKr8ZkCVzAfBgNVHSMEGDAWgBSl8a3huNp2ZXNZ5cCJIyn2ktREyTAL\\n\" +\n+            \"BgNVHQ8EBAMCAgQwCgYIKoZIzj0EAwIDSAAwRQIhAM0vCIV938aqGAEmELIA8Kc4\\n\" +\n+            \"X+kOc4LGE0R7sMiBAbXuAiBlbNVaskKYRHIEGHEtIWet6Ufi3w9NMrycEbBZ+v5o\\n\" +\n+            \"gA==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ \"\/C=US\/ST=CA\/O=Test Server\/CN=client\"\n+    \/\/ subjectKeyIdentifier    = hash\n+    \/\/ authorityKeyIdentifier  = keyid:always\n+    \/\/ keyUsage                = digitalSignature\n+    \/\/ subjectAltName          = DNS:client\n+    private static final String SERVER_CERT =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIB5TCCAYygAwIBAgIUNWe754lZoDc6wNs9Vsev\/h9TMicwCgYIKoZIzj0EAwIw\\n\" +\n+            \"PzELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMSMwIQYDVQQKDBpUZXN0IEludGVy\\n\" +\n+            \"bWVkaWF0ZSBDQSwgSW5jLjAgFw0yMjA0MTIwNzEzMzRaGA8yMTIyMDMxOTA3MTMz\\n\" +\n+            \"NFowQTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMRQwEgYDVQQKDAtUZXN0IFNl\\n\" +\n+            \"cnZlcjEPMA0GA1UEAwwGY2xpZW50MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE\\n\" +\n+            \"o6zUz5QmzmfHL2xRifvaJenggck\/Dlu6KC4v4rGXug69R7tWKWuRUsbSFLy29Rii\\n\" +\n+            \"F7V1wjFhsyGAzNyKf\/KlmaNiMGAwHQYDVR0OBBYEFHz32VSnXBF4WdLDOe7e3hF9\\n\" +\n+            \"yDxmMB8GA1UdIwQYMBaAFOo\/qEHkhutqK+i3\/NZIwqvxmQJXMAsGA1UdDwQEAwIH\\n\" +\n+            \"gDARBgNVHREECjAIggZjbGllbnQwCgYIKoZIzj0EAwIDRwAwRAIgWsCn2LIElgVs\\n\" +\n+            \"VihcQznvBemWneEcmnp\/Bw+lwk86KQ8CIA3loL7P\/0\/Ft\/xXtClxJfyxEoZ\/Az1n\\n\" +\n+            \"HTTjbe6ZnN0Y\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    private static final String serverkey =\n+            \/\/\"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgKb9cKLH++BgA9CL1\\n\" +\n+            \"cdCLHpD0poPJ\/uAkafGXDJBR67ChRANCAASjrNTPlCbOZ8cvbFGJ+9ol6eCByT8O\\n\" +\n+            \"W7ooLi\/isZe6Dr1Hu1Ypa5FSxtIUvLb1GKIXtXXCMWGzIYDM3Ip\/8qWZ\";\n+            \/\/ + \"\\n-----END PRIVATE KEY-----\";\n+\n+    private TestCertificates() {}\n+\n+    public static KeyStore getKeyStore() throws GeneralSecurityException, IOException {\n+        KeyStore result = KeyStore.getInstance(\"JKS\");\n+        result.load(null, null);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        Certificate serverCert = cf.generateCertificate(\n+                new ByteArrayInputStream(\n+                        TestCertificates.SERVER_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+        Certificate caCert = cf.generateCertificate(\n+                new ByteArrayInputStream(\n+                        CA_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+        KeyFactory kf = KeyFactory.getInstance(\"EC\");\n+        PKCS8EncodedKeySpec ks = new PKCS8EncodedKeySpec(\n+                Base64.getMimeDecoder().decode(serverkey));\n+        Key key = kf.generatePrivate(ks);\n+        Certificate[] chain = {serverCert, caCert};\n+\n+        result.setKeyEntry(\"server\", key, new char[0], chain);\n+        return result;\n+    }\n+\n+    public static KeyStore getTrustStore() throws GeneralSecurityException, IOException {\n+        KeyStore result = KeyStore.getInstance(\"JKS\");\n+        result.load(null, null);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        Certificate rootcaCert = cf.generateCertificate(\n+                new ByteArrayInputStream(\n+                        ROOT_CA_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+\n+        result.setCertificateEntry(\"testca\", rootcaCert);\n+        return result;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/TestCertificates.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}