{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-        this.algorithmConstraints = new SSLAlgorithmConstraints(\n+        this.algorithmConstraints = SSLAlgorithmConstraints.wrap(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-                        new SSLAlgorithmConstraints(null);\n+                        new SSLAlgorithmConstraints(null, true);\n@@ -64,1 +64,1 @@\n-                        new SSLAlgorithmConstraints((SSLSocket)null, false);\n+                        new SSLAlgorithmConstraints(null, false);\n@@ -66,1 +66,2 @@\n-    SSLAlgorithmConstraints(AlgorithmConstraints userSpecifiedConstraints) {\n+    private SSLAlgorithmConstraints(AlgorithmConstraints userSpecifiedConstraints,\n+                                    boolean enabledX509DisabledAlgConstraints) {\n@@ -69,1 +70,1 @@\n-        this.enabledX509DisabledAlgConstraints = true;\n+        this.enabledX509DisabledAlgConstraints = enabledX509DisabledAlgConstraints;\n@@ -72,5 +73,12 @@\n-    SSLAlgorithmConstraints(SSLSocket socket,\n-            boolean withDefaultCertPathConstraints) {\n-        this.userSpecifiedConstraints = getUserSpecifiedConstraints(socket);\n-        this.peerSpecifiedConstraints = null;\n-        this.enabledX509DisabledAlgConstraints = withDefaultCertPathConstraints;\n+    \/**\n+     * Returns a SSLAlgorithmConstraints instance that checks the provided\n+     * {@code userSpecifiedConstraints} in addition to standard checks.\n+     * Returns a singleton instance if parameter is null or DEFAULT.\n+     * @param userSpecifiedConstraints additional constraints to check\n+     * @return a SSLAlgorithmConstraints instance\n+     *\/\n+    static AlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n+        if (userSpecifiedConstraints == DEFAULT || userSpecifiedConstraints == null) {\n+            return DEFAULT;\n+        }\n+        return new SSLAlgorithmConstraints(userSpecifiedConstraints, true);\n@@ -79,5 +87,34 @@\n-    SSLAlgorithmConstraints(SSLEngine engine,\n-            boolean withDefaultCertPathConstraints) {\n-        this.userSpecifiedConstraints = getUserSpecifiedConstraints(engine);\n-        this.peerSpecifiedConstraints = null;\n-        this.enabledX509DisabledAlgConstraints = withDefaultCertPathConstraints;\n+    \/**\n+     * Returns a SSLAlgorithmConstraints instance that checks the constraints\n+     * configured for the given {@code socket} in addition to standard checks.\n+     * Returns a singleton instance if the constraints are null or DEFAULT.\n+     * @param socket socket with configured constraints\n+     * @return a SSLAlgorithmConstraints instance\n+     *\/\n+    static AlgorithmConstraints forSocket(SSLSocket socket,\n+                                             boolean withDefaultCertPathConstraints) {\n+        AlgorithmConstraints userSpecifiedConstraints =\n+                nullIfDefault(getUserSpecifiedConstraints(socket));\n+        if (userSpecifiedConstraints == null) {\n+            return withDefaultCertPathConstraints ? DEFAULT : DEFAULT_SSL_ONLY;\n+        }\n+        return new SSLAlgorithmConstraints(userSpecifiedConstraints,\n+                withDefaultCertPathConstraints);\n+    }\n+\n+    \/**\n+     * Returns a SSLAlgorithmConstraints instance that checks the constraints\n+     * configured for the given {@code engine} in addition to standard checks.\n+     * Returns a singleton instance if the constraints are null or DEFAULT.\n+     * @param engine engine with configured constraints\n+     * @return a SSLAlgorithmConstraints instance\n+     *\/\n+    static AlgorithmConstraints forEngine(SSLEngine engine,\n+                                             boolean withDefaultCertPathConstraints) {\n+        AlgorithmConstraints userSpecifiedConstraints =\n+                nullIfDefault(getUserSpecifiedConstraints(engine));\n+        if (userSpecifiedConstraints == null) {\n+            return withDefaultCertPathConstraints ? DEFAULT : DEFAULT_SSL_ONLY;\n+        }\n+        return new SSLAlgorithmConstraints(userSpecifiedConstraints,\n+                withDefaultCertPathConstraints);\n@@ -88,1 +125,2 @@\n-        this.userSpecifiedConstraints = getUserSpecifiedConstraints(socket);\n+        this.userSpecifiedConstraints =\n+                nullIfDefault(getUserSpecifiedConstraints(socket));\n@@ -96,1 +134,2 @@\n-        this.userSpecifiedConstraints = getUserSpecifiedConstraints(engine);\n+        this.userSpecifiedConstraints =\n+                nullIfDefault(getUserSpecifiedConstraints(engine));\n@@ -102,0 +141,5 @@\n+    private static AlgorithmConstraints nullIfDefault(\n+            AlgorithmConstraints constraints) {\n+        return constraints == DEFAULT ? null : constraints;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":61,"deletions":17,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1492,1 +1492,1 @@\n-                            new SSLAlgorithmConstraints(sslSocket, true);\n+                            SSLAlgorithmConstraints.forSocket(sslSocket, true);\n@@ -1495,1 +1495,1 @@\n-                constraints = new SSLAlgorithmConstraints(sslSocket, true);\n+                constraints = SSLAlgorithmConstraints.forSocket(sslSocket, true);\n@@ -1532,1 +1532,1 @@\n-                            new SSLAlgorithmConstraints(engine, true);\n+                            SSLAlgorithmConstraints.forEngine(engine, true);\n@@ -1535,1 +1535,1 @@\n-                constraints = new SSLAlgorithmConstraints(engine, true);\n+                constraints = SSLAlgorithmConstraints.forEngine(engine, true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,1 @@\n-            return new SSLAlgorithmConstraints(sslSocket, true);\n+            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n@@ -210,1 +210,1 @@\n-        return new SSLAlgorithmConstraints((SSLSocket)null, true);\n+        return SSLAlgorithmConstraints.DEFAULT;\n@@ -234,1 +234,1 @@\n-        return new SSLAlgorithmConstraints(engine, true);\n+        return SSLAlgorithmConstraints.forEngine(engine, true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-                constraints = new SSLAlgorithmConstraints(sslSocket, false);\n+                constraints = SSLAlgorithmConstraints.forSocket(sslSocket, false);\n@@ -276,1 +276,1 @@\n-                constraints = new SSLAlgorithmConstraints(engine, false);\n+                constraints = SSLAlgorithmConstraints.forEngine(engine, false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.nio.ByteBuffer;\n+import java.security.KeyStore;\n+import java.util.concurrent.TimeUnit;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+public class SSLHandshake {\n+\n+    private SSLContext sslc;\n+\n+    private SSLEngine clientEngine;\n+    private ByteBuffer clientOut = ByteBuffer.allocate(5);\n+    private ByteBuffer clientIn = ByteBuffer.allocate(1 << 15);\n+\n+    private SSLEngine serverEngine;\n+    private ByteBuffer serverOut = ByteBuffer.allocate(5);\n+    private ByteBuffer serverIn = ByteBuffer.allocate(1 << 15);\n+\n+    private ByteBuffer cTOs = ByteBuffer.allocateDirect(1 << 16);\n+    private ByteBuffer sTOc = ByteBuffer.allocateDirect(1 << 16);\n+\n+    @Param({\"true\", \"false\"})\n+    boolean resume;\n+\n+    @Param({\"TLSv1.2\", \"TLS\"})\n+    String tlsVersion;\n+\n+    @Setup(Level.Trial)\n+    public void init() throws Exception {\n+        KeyStore ks = TestCertificates.getKeyStore();\n+        KeyStore ts = TestCertificates.getTrustStore();\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, new char[0]);\n+\n+        TrustManagerFactory tmf =\n+                TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(tlsVersion);\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        sslc = sslCtx;\n+    }\n+\n+    private HandshakeStatus checkResult(SSLEngine engine, SSLEngineResult result) {\n+\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+\n+        if (hsStatus == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                runnable.run();\n+            }\n+            hsStatus = engine.getHandshakeStatus();\n+        }\n+        return hsStatus;\n+    }\n+\n+    \/**\n+     * This benchmark measures the time needed to perform a TLS handshake.\n+     * Data is exchanged using a pair of ByteBuffers.\n+     * The client and the server both operate on the same thread.\n+     *\/\n+    @Benchmark\n+    @Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+    @Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+    @Fork(3)\n+    public SSLSession doHandshake() throws Exception {\n+\n+        createSSLEngines();\n+        boolean isCtoS = true;\n+        for (;;) {\n+            HandshakeStatus result;\n+            if (isCtoS) {\n+                result = checkResult(clientEngine,\n+                        clientEngine.wrap(clientOut, cTOs)\n+                );\n+                cTOs.flip();\n+                checkResult(serverEngine,\n+                        serverEngine.unwrap(cTOs, serverIn)\n+                );\n+                cTOs.compact();\n+                if (result == HandshakeStatus.NEED_UNWRAP) {\n+                    isCtoS = false;\n+                } else if (result == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (result != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected result \"+result);\n+                }\n+            } else {\n+                result = checkResult(serverEngine,\n+                        serverEngine.wrap(serverOut, sTOc)\n+                );\n+                sTOc.flip();\n+                checkResult(clientEngine,\n+                        clientEngine.unwrap(sTOc, clientIn)\n+                );\n+                sTOc.compact();\n+                if (result == HandshakeStatus.NEED_UNWRAP) {\n+                    isCtoS = true;\n+                } else if (result == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (result != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected result \"+result);\n+                }\n+            }\n+        }\n+\n+        SSLSession session = clientEngine.getSession();\n+        if (resume) {\n+            \/\/ TLS 1.3 needs another wrap\/unwrap to deliver a session ticket\n+            serverEngine.wrap(serverOut, sTOc);\n+            sTOc.flip();\n+            clientEngine.unwrap(sTOc, clientIn);\n+            sTOc.compact();\n+        } else {\n+            \/\/ invalidate TLS1.2 session. TLS 1.3 doesn't care\n+            session.invalidate();\n+        }\n+        return session;\n+    }\n+\n+    private void createSSLEngines() {\n+        \/*\n+         * Configure the serverEngine to act as a server in the SSL\/TLS\n+         * handshake.\n+         *\/\n+        serverEngine = sslc.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+\n+        \/*\n+         * Similar to above, but using client mode instead.\n+         *\/\n+        clientEngine = sslc.createSSLEngine(\"client\", 80);\n+        clientEngine.setUseClientMode(true);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.security;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.GeneralSecurityException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+\n+\/**\n+ * This class contains a 3-certificate chain for use in TLS tests.\n+ * The method {@link #getKeyStore()} returns a keystore with a single entry\n+ * containing one server+one intermediate CA certificate.\n+ * Server's CN and subjectAltName are both set to \"client\"\n+ *\n+ * The method {@link #getTrustStore()} returns a keystore with a single entry\n+ * containing the root CA certificate used for signing the intermediate CA.\n+ *\/\n+class TestCertificates {\n+\n+    \/\/ \"\/C=US\/ST=CA\/O=Test Root CA, Inc.\"\n+    \/\/ basicConstraints=critical, CA:true\n+    \/\/ subjectKeyIdentifier    = hash\n+    \/\/ authorityKeyIdentifier  = keyid:always\n+    \/\/ keyUsage                = keyCertSign\n+    private static final String ROOT_CA_CERT =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIB0jCCAXigAwIBAgIUE+wUdx22foJXSQzD3hpCNCqITLEwCgYIKoZIzj0EAwIw\\n\" +\n+            \"NzELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMRswGQYDVQQKDBJUZXN0IFJvb3Qg\\n\" +\n+            \"Q0EsIEluYy4wIBcNMjIwNDEyMDcxMzMzWhgPMjEyMjAzMTkwNzEzMzNaMDcxCzAJ\\n\" +\n+            \"BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEbMBkGA1UECgwSVGVzdCBSb290IENBLCBJ\\n\" +\n+            \"bmMuMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEBKye\/mwO0V0WLr71tf8auFEz\\n\" +\n+            \"EmqhaYWauaP17Fb33fRAeG8aVp9c4B0isv\/VgcqSTRMG0SJjbx7ttSYwR\/JNhqNg\\n\" +\n+            \"MF4wDwYDVR0TAQH\/BAUwAwEB\/zAdBgNVHQ4EFgQUpfGt4bjadmVzWeXAiSMp9pLU\\n\" +\n+            \"RMkwHwYDVR0jBBgwFoAUpfGt4bjadmVzWeXAiSMp9pLURMkwCwYDVR0PBAQDAgIE\\n\" +\n+            \"MAoGCCqGSM49BAMCA0gAMEUCIBF8YyD5BBuhkFNV\/3rNmvvMuvWUAECJ8rrUg8kr\\n\" +\n+            \"J8zpAiEAzbZQsC\/IZ0wVNd4lqHn6\/Ih5v7vhCgkg95KCP1NhBnU=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ \"\/C=US\/ST=CA\/O=Test Intermediate CA, Inc.\"\n+    \/\/ basicConstraints=critical, CA:true, pathlen:0\n+    \/\/ subjectKeyIdentifier    = hash\n+    \/\/ authorityKeyIdentifier  = keyid:always\n+    \/\/ keyUsage                = keyCertSign\n+    private static final String CA_CERT =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIB3TCCAYOgAwIBAgIUQ+lTbsDcIQ1UUg0RGdpJB6JMXpcwCgYIKoZIzj0EAwIw\\n\" +\n+            \"NzELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMRswGQYDVQQKDBJUZXN0IFJvb3Qg\\n\" +\n+            \"Q0EsIEluYy4wIBcNMjIwNDEyMDcxMzM0WhgPMjEyMjAzMTkwNzEzMzRaMD8xCzAJ\\n\" +\n+            \"BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEjMCEGA1UECgwaVGVzdCBJbnRlcm1lZGlh\\n\" +\n+            \"dGUgQ0EsIEluYy4wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQ7DsKCSQkP5oT2\\n\" +\n+            \"Wx0gf40N+H\/F75w1YmPm6dp2wiQ6JPMN\/4En87Ylx0ISJkeXJLxrbLvu2xZ+aonM\\n\" +\n+            \"kckNh\/ERo2MwYTASBgNVHRMBAf8ECDAGAQH\/AgEAMB0GA1UdDgQWBBTqP6hB5Ibr\\n\" +\n+            \"aivot\/zWSMKr8ZkCVzAfBgNVHSMEGDAWgBSl8a3huNp2ZXNZ5cCJIyn2ktREyTAL\\n\" +\n+            \"BgNVHQ8EBAMCAgQwCgYIKoZIzj0EAwIDSAAwRQIhAM0vCIV938aqGAEmELIA8Kc4\\n\" +\n+            \"X+kOc4LGE0R7sMiBAbXuAiBlbNVaskKYRHIEGHEtIWet6Ufi3w9NMrycEbBZ+v5o\\n\" +\n+            \"gA==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ \"\/C=US\/ST=CA\/O=Test Server\/CN=client\"\n+    \/\/ subjectKeyIdentifier    = hash\n+    \/\/ authorityKeyIdentifier  = keyid:always\n+    \/\/ keyUsage                = digitalSignature\n+    \/\/ subjectAltName          = DNS:client\n+    private static final String SERVER_CERT =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIB5TCCAYygAwIBAgIUNWe754lZoDc6wNs9Vsev\/h9TMicwCgYIKoZIzj0EAwIw\\n\" +\n+            \"PzELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMSMwIQYDVQQKDBpUZXN0IEludGVy\\n\" +\n+            \"bWVkaWF0ZSBDQSwgSW5jLjAgFw0yMjA0MTIwNzEzMzRaGA8yMTIyMDMxOTA3MTMz\\n\" +\n+            \"NFowQTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMRQwEgYDVQQKDAtUZXN0IFNl\\n\" +\n+            \"cnZlcjEPMA0GA1UEAwwGY2xpZW50MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE\\n\" +\n+            \"o6zUz5QmzmfHL2xRifvaJenggck\/Dlu6KC4v4rGXug69R7tWKWuRUsbSFLy29Rii\\n\" +\n+            \"F7V1wjFhsyGAzNyKf\/KlmaNiMGAwHQYDVR0OBBYEFHz32VSnXBF4WdLDOe7e3hF9\\n\" +\n+            \"yDxmMB8GA1UdIwQYMBaAFOo\/qEHkhutqK+i3\/NZIwqvxmQJXMAsGA1UdDwQEAwIH\\n\" +\n+            \"gDARBgNVHREECjAIggZjbGllbnQwCgYIKoZIzj0EAwIDRwAwRAIgWsCn2LIElgVs\\n\" +\n+            \"VihcQznvBemWneEcmnp\/Bw+lwk86KQ8CIA3loL7P\/0\/Ft\/xXtClxJfyxEoZ\/Az1n\\n\" +\n+            \"HTTjbe6ZnN0Y\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    private static final String serverkey =\n+            \/\/\"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgKb9cKLH++BgA9CL1\\n\" +\n+            \"cdCLHpD0poPJ\/uAkafGXDJBR67ChRANCAASjrNTPlCbOZ8cvbFGJ+9ol6eCByT8O\\n\" +\n+            \"W7ooLi\/isZe6Dr1Hu1Ypa5FSxtIUvLb1GKIXtXXCMWGzIYDM3Ip\/8qWZ\";\n+            \/\/ + \"\\n-----END PRIVATE KEY-----\";\n+\n+    private TestCertificates() {}\n+\n+    public static KeyStore getKeyStore() throws GeneralSecurityException, IOException {\n+        KeyStore result = KeyStore.getInstance(\"JKS\");\n+        result.load(null, null);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        Certificate serverCert = cf.generateCertificate(\n+                new ByteArrayInputStream(\n+                        TestCertificates.SERVER_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+        Certificate caCert = cf.generateCertificate(\n+                new ByteArrayInputStream(\n+                        CA_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+        KeyFactory kf = KeyFactory.getInstance(\"EC\");\n+        PKCS8EncodedKeySpec ks = new PKCS8EncodedKeySpec(\n+                Base64.getMimeDecoder().decode(serverkey));\n+        Key key = kf.generatePrivate(ks);\n+        Certificate[] chain = {serverCert, caCert};\n+\n+        result.setKeyEntry(\"server\", key, new char[0], chain);\n+        return result;\n+    }\n+\n+    public static KeyStore getTrustStore() throws GeneralSecurityException, IOException {\n+        KeyStore result = KeyStore.getInstance(\"JKS\");\n+        result.load(null, null);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        Certificate rootcaCert = cf.generateCertificate(\n+                new ByteArrayInputStream(\n+                        ROOT_CA_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+\n+        result.setCertificateEntry(\"testca\", rootcaCert);\n+        return result;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/TestCertificates.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}