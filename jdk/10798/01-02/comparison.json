{"files":[{"patch":"@@ -193,0 +193,1 @@\n+    public final Type nullPointerExceptionType;\n@@ -558,0 +559,1 @@\n+        nullPointerExceptionType = enterClass(\"java.lang.NullPointerException\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -428,3 +428,2 @@\n-            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n-            return !isImplicitlyTyped((JCVariableDecl) tree.varOrRecordPattern);\n+            return tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE &&\n+                    !isImplicitlyTyped((JCVariableDecl) tree.varOrRecordPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1549,6 +1549,4 @@\n-            if(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE) {\n-                JCVariableDecl var = (JCVariableDecl) tree.varOrRecordPattern;\n-\n-                if (var.isImplicitlyTyped()) {\n-                    Type inferredType = chk.checkLocalVarType(var, tree.elementType, var.name);\n-                    setSyntheticVariableType(var, inferredType);\n+            if (tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                if (jcVariableDecl.isImplicitlyTyped()) {\n+                    Type inferredType = chk.checkLocalVarType(jcVariableDecl, tree.elementType, jcVariableDecl.name);\n+                    setSyntheticVariableType(jcVariableDecl, inferredType);\n@@ -1556,2 +1554,2 @@\n-                attribStat(var, loopEnv);\n-                chk.checkType(tree.expr.pos(), tree.elementType, var.sym.type);\n+                attribStat(jcVariableDecl, loopEnv);\n+                chk.checkType(tree.expr.pos(), tree.elementType, jcVariableDecl.sym.type);\n@@ -1562,4 +1560,2 @@\n-            else if (tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN) {\n-                JCRecordPattern recordPattern = (JCRecordPattern) tree.varOrRecordPattern;\n-\n-                attribTree(recordPattern, loopEnv, unknownExprInfo);\n+            else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                attribTree(jcRecordPattern, loopEnv, unknownExprInfo);\n@@ -1574,1 +1570,1 @@\n-                Type clazztype = recordPattern.type;\n+                Type clazztype = jcRecordPattern.type;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3463,2 +3463,0 @@\n-            JCBlock body = null;\n-\n@@ -3466,7 +3464,8 @@\n-            JCVariableDecl oldVar = (JCVariableDecl) tree.varOrRecordPattern;\n-            JCVariableDecl loopvardef = (JCVariableDecl) make.VarDef(oldVar.mods,\n-                    oldVar.name,\n-                    oldVar.vartype,\n-                    loopvarinit).setType(oldVar.type);\n-            loopvardef.sym = oldVar.sym;\n-            body = make.\n+            JCVariableDecl jcVariableDecl = (JCVariableDecl) tree.varOrRecordPattern;\n+\n+            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(jcVariableDecl.mods,\n+                    jcVariableDecl.name,\n+                    jcVariableDecl.vartype,\n+                    loopvarinit).setType(jcVariableDecl.type);\n+            loopvardef.sym = jcVariableDecl.sym;\n+            JCBlock body = make.\n@@ -3475,0 +3474,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCThrow;\n@@ -724,1 +725,1 @@\n-            if (tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN) {\n+            if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n@@ -753,2 +754,6 @@\n-                List<JCExpression> params = List.of(makeNull(), makeNull());\n-                JCTree.JCThrow thr = make.Throw(makeNewClass(syms.matchExceptionType, params));\n+                List<JCExpression> nestedNPEParams = List.of(makeNull());\n+                JCNewClass nestedNPE = makeNewClass(syms.nullPointerExceptionType, nestedNPEParams);\n+\n+                List<JCExpression> matchExParams = List.of(makeNull(), nestedNPE);\n+                JCThrow thr = make.Throw(makeNewClass(syms.matchExceptionType, matchExParams));\n+\n@@ -758,1 +763,1 @@\n-                        List.of(make.PatternCaseLabel((JCPattern) tree.varOrRecordPattern, null)),\n+                        List.of(make.PatternCaseLabel(jcRecordPattern, null)),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNull, MatchException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNull, NullPointerException.class);\n@@ -34,1 +34,1 @@\n-        assertEx(ForEachPatterns::simpleDecostructionPatternException, inWithPointEx, MatchException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternException, inWithPointEx, TestPatternFailed.class);\n@@ -37,1 +37,1 @@\n-        assertEx(ForEachPatterns::simpleDecostructionPatternNoComponentAccess, inWithNull, MatchException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternNoComponentAccess, inWithNull, NullPointerException.class);\n@@ -180,0 +180,14 @@\n+    static <T> void assertMatchExceptionWithNested(Function<List<T>, Integer> f, List<T> points, Class<?> nestedExceptionClass) {\n+        try {\n+            f.apply(points);\n+            fail(\"Expected an exception, but none happened!\");\n+        }\n+        catch(Exception ex) {\n+            assertEquals(MatchException.class, ex.getClass());\n+\n+            MatchException me = (MatchException) ex;\n+\n+            assertEquals(nestedExceptionClass, me.getCause().getClass());\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatterns.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @compile --enable-preview -source ${jdk.version} -XDfind=all ForEachTestAllAnalyzers.java\n+ *\/\n+public class ForEachTestAllAnalyzers {\n+    private void test(Iterable<? extends R> l) {\n+        for (R(Object a) : l) { }\n+    }\n+    record R(Object a) {}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachTestAllAnalyzers.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"}]}