{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -44,0 +46,17 @@\n+    \/**\n+     * \"Enhanced\" {@code for} declarations come in two forms:\n+     * <ul>\n+     * <li> local variable declarations and\n+     * <li> record patterns\n+     * <\/ul>\n+     *\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public enum DeclarationKind {\n+        \/** enum constant for local variable declarations *\/\n+        VARIABLE,\n+        \/** enum constant for record pattern declarations *\/\n+        PATTERN\n+    }\n+\n@@ -46,1 +65,1 @@\n-     * @return the control variable\n+     * @return the control variable, or {@code null} if this \"enhanced\" {@code for} uses a pattern\n@@ -50,0 +69,8 @@\n+    \/**\n+     * Returns the control variable or pattern for the loop.\n+     * @return the control variable or pattern\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    Tree getVariableOrRecordPattern();\n+\n@@ -61,0 +88,8 @@\n+\n+    \/**\n+     * Returns the kind of the declaration of the \"enhanced\" {@code for}.\n+     * @return the kind of the declaration\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    DeclarationKind getDeclarationKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/EnhancedForLoopTree.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-        R r = scan(node.getVariable(), p);\n+        R r = scan(node.getVariableOrRecordPattern(), p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+    public final Type nullPointerExceptionType;\n@@ -558,0 +559,1 @@\n+        nullPointerExceptionType = enterClass(\"java.lang.NullPointerException\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -427,1 +428,2 @@\n-            return !isImplicitlyTyped(tree.var);\n+            return tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE &&\n+                    !isImplicitlyTyped((JCVariableDecl) tree.varOrRecordPattern);\n@@ -431,0 +433,2 @@\n+            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n@@ -432,1 +436,1 @@\n-            newTree.var = rewriteVarType(oldTree.var);\n+            newTree.varOrRecordPattern = rewriteVarType((JCVariableDecl) oldTree.varOrRecordPattern);\n@@ -438,1 +442,4 @@\n-            processVar(oldTree.var, newTree.var, hasErrors);\n+            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n+            processVar((JCVariableDecl) oldTree.varOrRecordPattern,\n+                           (JCVariableDecl) newTree.varOrRecordPattern, hasErrors);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -1516,0 +1517,1 @@\n+\n@@ -1522,2 +1524,2 @@\n-            Type elemtype = types.elemtype(exprType); \/\/ perhaps expr is an array?\n-            if (elemtype == null) {\n+            tree.elementType = types.elemtype(exprType); \/\/ perhaps expr is an array?\n+            if (tree.elementType == null) {\n@@ -1530,1 +1532,1 @@\n-                    elemtype = types.createErrorType(exprType);\n+                    tree.elementType = types.createErrorType(exprType);\n@@ -1533,1 +1535,1 @@\n-                    elemtype = iterableParams.isEmpty()\n+                    tree.elementType = iterableParams.isEmpty()\n@@ -1547,3 +1549,33 @@\n-            if (tree.var.isImplicitlyTyped()) {\n-                Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);\n-                setSyntheticVariableType(tree.var, inferredType);\n+            if (tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                if (jcVariableDecl.isImplicitlyTyped()) {\n+                    Type inferredType = chk.checkLocalVarType(jcVariableDecl, tree.elementType, jcVariableDecl.name);\n+                    setSyntheticVariableType(jcVariableDecl, inferredType);\n+                }\n+                attribStat(jcVariableDecl, loopEnv);\n+                chk.checkType(tree.expr.pos(), tree.elementType, jcVariableDecl.sym.type);\n+\n+                loopEnv.tree = tree; \/\/ before, we were not in loop!\n+                attribStat(tree.body, loopEnv);\n+            } else {\n+                Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN);\n+                JCRecordPattern jcRecordPattern = (JCRecordPattern) tree.varOrRecordPattern;\n+\n+                attribExpr(jcRecordPattern, loopEnv, tree.elementType);\n+\n+                \/\/ for(<pattern> x : xs) { y }\n+                \/\/ we include x's bindings when true in y\n+                \/\/ we don't do anything with x's bindings when false\n+\n+                MatchBindings forWithRecordPatternBindings = matchBindings;\n+                Env<AttrContext> recordPatternEnv = bindingEnv(loopEnv, forWithRecordPatternBindings.bindingsWhenTrue);\n+\n+                Type clazztype = jcRecordPattern.type;\n+\n+                checkCastablePattern(tree.expr.pos(), tree.elementType, clazztype);\n+\n+                recordPatternEnv.tree = tree; \/\/ before, we were not in loop!\n+                try {\n+                    attribStat(tree.body, recordPatternEnv);\n+                } finally {\n+                    recordPatternEnv.info.scope.leave();\n+                }\n@@ -1551,4 +1583,0 @@\n-            attribStat(tree.var, loopEnv);\n-            chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);\n-            loopEnv.tree = tree; \/\/ before, we were not in loop!\n-            attribStat(tree.body, loopEnv);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -648,1 +648,15 @@\n-            visitVarDef(tree.var);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+\n+                Set<Symbol> coveredSymbols =\n+                        coveredSymbols(jcRecordPattern.pos(), List.of(jcRecordPattern));\n+\n+                boolean isExhaustive =\n+                        isExhaustive(jcRecordPattern.pos(), tree.elementType, coveredSymbols);\n+\n+                if (!isExhaustive) {\n+                    log.error(tree, Errors.ForeachNotExhaustiveOnType(jcRecordPattern.type, tree.elementType));\n+                }\n+            }\n@@ -1359,1 +1373,5 @@\n-            visitVarDef(tree.var);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+            }\n@@ -2520,2 +2538,0 @@\n-            visitVarDef(tree.var);\n-\n@@ -2530,1 +2546,7 @@\n-            letInit(tree.pos(), tree.var.sym);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+                letInit(tree.pos(), jcVariableDecl.sym);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -3464,5 +3465,9 @@\n-            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  loopvarinit).setType(tree.var.type);\n-            loopvardef.sym = tree.var.sym;\n+\n+            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+            JCVariableDecl jcVariableDecl = (JCVariableDecl) tree.varOrRecordPattern;\n+\n+            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(jcVariableDecl.mods,\n+                    jcVariableDecl.name,\n+                    jcVariableDecl.vartype,\n+                    loopvarinit).setType(jcVariableDecl.type);\n+            loopvardef.sym = jcVariableDecl.sym;\n@@ -3470,1 +3475,2 @@\n-                Block(0, List.of(loopvardef, tree.body));\n+                    Block(0, List.of(loopvardef, tree.body));\n+\n@@ -3549,1 +3555,5 @@\n-            if (tree.var.type.isPrimitive())\n+\n+            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n+            JCVariableDecl var = (JCVariableDecl) tree.varOrRecordPattern;\n+            if (var.type.isPrimitive())\n@@ -3552,6 +3562,6 @@\n-                vardefinit = make.TypeCast(tree.var.type, vardefinit);\n-            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  vardefinit).setType(tree.var.type);\n-            indexDef.sym = tree.var.sym;\n+                vardefinit = make.TypeCast(var.type, vardefinit);\n+            JCVariableDecl indexDef = (JCVariableDecl) make.VarDef(var.mods,\n+                    var.name,\n+                    var.vartype,\n+                    vardefinit).setType(var.type);\n+            indexDef.sym = var.sym;\n@@ -3561,4 +3571,4 @@\n-                ForLoop(List.of(init),\n-                        cond,\n-                        List.nil(),\n-                        body));\n+                    ForLoop(List.of(init),\n+                            cond,\n+                            List.nil(),\n+                            body));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -58,0 +59,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCThrow;\n@@ -692,0 +694,71 @@\n+    @Override\n+    public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+        bindingContext = new BasicBindingContext();\n+        VarSymbol prevCurrentValue = currentValue;\n+        try {\n+            if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                \/**\n+                 * A statement of the form\n+                 *\n+                 * <pre>\n+                 *     for (<pattern> : coll ) stmt ;\n+                 * <\/pre>\n+                 *\n+                 * (where coll implements {@code Iterable<R>}) gets translated to\n+                 *\n+                 * <pre>{@code\n+                 *     for (<type-of-coll-item> N$temp : coll) {\n+                 *     switch (N$temp) {\n+                 *         case <pattern>: stmt;\n+                 *         case null: throw new MatchException();\n+                 *     }\n+                 * }<\/pre>\n+                 *\n+                 *\/\n+                Type selectorType = types.classBound(tree.elementType);\n+\n+                currentValue = new VarSymbol(Flags.FINAL | Flags.SYNTHETIC,\n+                        names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                        selectorType,\n+                        currentMethodSym);\n+\n+                JCStatement newForVariableDeclaration =\n+                        make.at(tree.pos).VarDef(currentValue, null).setType(selectorType);\n+\n+                List<JCExpression> nestedNPEParams = List.of(makeNull());\n+                JCNewClass nestedNPE = makeNewClass(syms.nullPointerExceptionType, nestedNPEParams);\n+\n+                List<JCExpression> matchExParams = List.of(makeNull(), nestedNPE);\n+                JCThrow thr = make.Throw(makeNewClass(syms.matchExceptionType, matchExParams));\n+\n+                JCCase caseNull = make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(makeNull())), List.of(thr), null);\n+\n+                JCCase casePattern = make.Case(CaseTree.CaseKind.STATEMENT,\n+                        List.of(make.PatternCaseLabel(jcRecordPattern, null)),\n+                        List.of(translate(tree.body)),\n+                        null);\n+\n+                JCSwitch switchBody =\n+                        make.Switch(make.Ident(currentValue).setType(selectorType),\n+                                List.of(caseNull, casePattern));\n+\n+                switchBody.patternSwitch = true;\n+\n+                \/\/ re-using the same node to eliminate the need to re-patch targets (break\/continue)\n+                tree.varOrRecordPattern = newForVariableDeclaration.setType(selectorType);\n+                tree.expr = translate(tree.expr);\n+                tree.body = translate(switchBody);\n+\n+                JCTree.JCEnhancedForLoop newForEach = tree;\n+\n+                result = bindingContext.decorateStatement(newForEach);\n+            } else {\n+                super.visitForeachLoop(tree);\n+                result = bindingContext.decorateStatement(tree);\n+            }\n+        } finally {\n+            currentValue = prevCurrentValue;\n+            bindingContext.pop();\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-        tree.var = translate(tree.var, null);\n+        tree.varOrRecordPattern = translate(tree.varOrRecordPattern, null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                scan(tree.var, that.var)\n+                scan(tree.varOrRecordPattern, that.varOrRecordPattern)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-            sr.mergeWith(csp(tree.var));\n+            sr.mergeWith(csp(tree.varOrRecordPattern));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -763,1 +763,0 @@\n-\n@@ -2821,6 +2820,15 @@\n-            List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n-            if (inits.length() == 1 &&\n-                inits.head.hasTag(VARDEF) &&\n-                ((JCVariableDecl) inits.head).init == null &&\n-                token.kind == COLON) {\n-                JCVariableDecl var = (JCVariableDecl)inits.head;\n+            JCTree pattern;\n+\n+            ForInitResult initResult = analyzeForInit();\n+\n+            if (initResult == ForInitResult.RecordPattern) {\n+                int patternPos = token.pos;\n+                JCModifiers mods = optFinal(0);\n+                int typePos = token.pos;\n+                JCExpression type = unannotatedType(false);\n+\n+                pattern = parsePattern(patternPos, mods, type, false, false);\n+\n+                if (pattern != null) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                }\n@@ -2831,1 +2839,1 @@\n-                return F.at(pos).ForeachLoop(var, expr, body);\n+                return F.at(pos).ForeachLoop(pattern, expr, body);\n@@ -2833,7 +2841,20 @@\n-                accept(SEMI);\n-                JCExpression cond = token.kind == SEMI ? null : parseExpression();\n-                accept(SEMI);\n-                List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n-                accept(RPAREN);\n-                JCStatement body = parseStatementAsBlock();\n-                return F.at(pos).ForLoop(inits, cond, steps, body);\n+                List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n+                if (inits.length() == 1 &&\n+                        inits.head.hasTag(VARDEF) &&\n+                        ((JCVariableDecl) inits.head).init == null &&\n+                        token.kind == COLON) {\n+                    JCVariableDecl var = (JCVariableDecl) inits.head;\n+                    accept(COLON);\n+                    JCExpression expr = parseExpression();\n+                    accept(RPAREN);\n+                    JCStatement body = parseStatementAsBlock();\n+                    return F.at(pos).ForeachLoop(var, expr, body);\n+                } else {\n+                    accept(SEMI);\n+                    JCExpression cond = token.kind == SEMI ? null : parseExpression();\n+                    accept(SEMI);\n+                    List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n+                    accept(RPAREN);\n+                    JCStatement body = parseStatementAsBlock();\n+                    return F.at(pos).ForLoop(inits, cond, steps, body);\n+                }\n@@ -2956,0 +2977,83 @@\n+    private enum ForInitResult {\n+        LocalVarDecl,\n+        RecordPattern\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    ForInitResult analyzeForInit() {\n+        boolean inType = false;\n+        boolean inSelectionAndParenthesis = false;\n+        int typeParameterPossibleStart = -1;\n+        outer: for (int lookahead = 0; ; lookahead++) {\n+            TokenKind tk = S.token(lookahead).kind;\n+            switch (tk) {\n+                case DOT:\n+                    if (inType) break; \/\/ in qualified type\n+                case COMMA:\n+                    typeParameterPossibleStart = lookahead;\n+                    break;\n+                case QUES:\n+                    \/\/ \"?\" only allowed in a type parameter position - otherwise it's an expression\n+                    if (typeParameterPossibleStart == lookahead - 1) break;\n+                    else return ForInitResult.LocalVarDecl;\n+                case EXTENDS: case SUPER: case AMP:\n+                case GTGTGT: case GTGT: case GT:\n+                case FINAL: case ELLIPSIS:\n+                    break;\n+                case BYTE: case SHORT: case INT: case LONG: case FLOAT:\n+                case DOUBLE: case BOOLEAN: case CHAR: case VOID:\n+                    if (peekToken(lookahead, IDENTIFIER)) {\n+                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n+                                                         : ForInitResult.LocalVarDecl;\n+                    }\n+                    break;\n+                case LPAREN:\n+                    if (lookahead != 0 && inType) {\n+                        inSelectionAndParenthesis = true;\n+                        inType = false;\n+                    }\n+                    break;\n+                case RPAREN:\n+                    \/\/ a method call in the init part or a record pattern?\n+                    if (inSelectionAndParenthesis) {\n+                        if (peekToken(lookahead, DOT)  ||\n+                                peekToken(lookahead, SEMI) ||\n+                                peekToken(lookahead, ARROW)) {\n+                            return ForInitResult.LocalVarDecl;\n+                        }\n+                        else if(peekToken(lookahead, COLON)) {\n+                            return ForInitResult.RecordPattern;\n+                        }\n+                        break;\n+                    }\n+                case UNDERSCORE:\n+                case ASSERT:\n+                case ENUM:\n+                case IDENTIFIER:\n+                    if (lookahead == 0) {\n+                        inType = true;\n+                    }\n+                    break;\n+                case MONKEYS_AT: {\n+                    int prevLookahead = lookahead;\n+                    lookahead = skipAnnotation(lookahead);\n+                    if (typeParameterPossibleStart == prevLookahead - 1) {\n+                        \/\/ move possible start of type param after the anno\n+                        typeParameterPossibleStart = lookahead;\n+                    }\n+                    break;\n+                }\n+                case LBRACKET:\n+                    if (peekToken(lookahead, RBRACKET)) {\n+                        return ForInitResult.LocalVarDecl;\n+                    }\n+                case LT:\n+                    typeParameterPossibleStart = lookahead;\n+                    break;\n+                default:\n+                    \/\/this includes EOF\n+                    return ForInitResult.LocalVarDecl;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":119,"deletions":15,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -606,0 +606,4 @@\n+# 0: type, 1: type\n+compiler.err.foreach.not.exhaustive.on.type=\\\n+    Pattern {0} is not exhaustive on {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1213,1 +1213,1 @@\n-        public JCVariableDecl var;\n+        public JCTree varOrRecordPattern;\n@@ -1216,2 +1216,4 @@\n-        protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n-            this.var = var;\n+        public Type elementType;\n+\n+        protected JCEnhancedForLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n+            this.varOrRecordPattern = varOrRecordPattern;\n@@ -1227,1 +1229,5 @@\n-        public JCVariableDecl getVariable() { return var; }\n+        public JCVariableDecl getVariable() {\n+            return varOrRecordPattern instanceof JCVariableDecl var ? var : null;\n+        }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCTree getVariableOrRecordPattern() { return varOrRecordPattern; }\n@@ -1240,0 +1246,4 @@\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public EnhancedForLoopTree.DeclarationKind getDeclarationKind() {\n+            return varOrRecordPattern.hasTag(VARDEF) ? DeclarationKind.VARIABLE : DeclarationKind.PATTERN;\n+        }\n@@ -3413,1 +3423,1 @@\n-        JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);\n+        JCEnhancedForLoop ForeachLoop(JCTree var, JCExpression expr, JCStatement body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-            printExpr(tree.var);\n+            printExpr(tree.varOrRecordPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        JCVariableDecl var = copy(t.var, p);\n+        JCTree varOrRecordPattern = copy(t.varOrRecordPattern, p);\n@@ -229,1 +229,1 @@\n-        return M.at(t.pos).ForeachLoop(var, expr, body);\n+        return M.at(t.pos).ForeachLoop(varOrRecordPattern, expr, body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-    public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n-        JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);\n+    public JCEnhancedForLoop ForeachLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n+        JCEnhancedForLoop tree = new JCEnhancedForLoop(varOrRecordPattern, expr, body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-        scan(tree.var);\n+        scan(tree.varOrRecordPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        tree.var = translate(tree.var);\n+        tree.varOrRecordPattern = translate(tree.varOrRecordPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.err.foreach.not.exhaustive.on.type\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+import java.util.List;\n+\n+class ForeachNotExhaustive {\n+    void m(List<Object> points) {\n+        for (Point(var x, var y): points) {\n+            System.out.println();\n+        }\n+    }\n+\n+    record Point(Integer x, Integer y) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ForeachNotExhaustive.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -723,1 +723,1 @@\n-            printTree(\"var\", tree.var);\n+            printTree(\"var\", tree.varOrRecordPattern);\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @enablePreview\n+ *\/\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class ForEachPatterns {\n+    public static void main(String[] args) {\n+\n+        List<Point>             in                   = List.of(new Point(1, 2), new Point(2, 3));\n+        List<IPoint>            in_iface             = List.of(new Point(1, 2), new Point(2, 3));\n+        List                    inRaw                = List.of(new Point(1, 2), new Point(2, 3), new Frog(3, 4));\n+        List<PointEx>           inWithPointEx        = List.of(new PointEx(1, 2));\n+        byte[]                  inBytes              = { (byte) 127, (byte) 127 };\n+        List<Point>             inWithNullComponent  = List.of(new Point(1, null), new Point(2, 3));\n+        Point[]                 inArray              = in.toArray(Point[]::new);\n+        List<WithPrimitives>    inWithPrimitives     = List.of(new WithPrimitives(1, 2), new WithPrimitives(2, 3));\n+        IParent                 recs []              = { new Rec(1) };\n+        List<Point>             inWithNull           = new ArrayList<>();\n+        {\n+            inWithNull.add(new Point(2, 3));\n+            inWithNull.add(null);\n+        }\n+\n+        assertEquals(8, iteratorEnhancedFor(in));\n+        assertEquals(8, arrayEnhancedFor(inArray));\n+        assertEquals(8, simpleDecostructionPatternWithAccesses(in));\n+        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, null, NullPointerException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNull, NullPointerException.class);\n+        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNullComponent, NullPointerException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternException, inWithPointEx, TestPatternFailed.class);\n+        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, (List<Point>) inRaw, ClassCastException.class);\n+        assertEquals(2, simpleDecostructionPatternNoComponentAccess(in));\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternNoComponentAccess, inWithNull, NullPointerException.class);\n+        assertEquals(2, simpleDecostructionPatternNoComponentAccess(inWithNullComponent));\n+        assertEquals(8, varAndConcrete(in));\n+        assertEquals(3, returnFromEnhancedFor(in));\n+        assertEquals(0, breakFromEnhancedFor(in));\n+        assertEquals(254, primitiveWidening(inBytes));\n+        assertEquals(8, sealedRecordPassBaseType(in_iface));\n+        assertEquals(8, withPrimitives(inWithPrimitives));\n+        assertEquals(List.of(Color.RED), JEPExample());\n+        assertEquals(1, arrayWithSealed(recs));\n+    }\n+\n+    static int iteratorEnhancedFor(List<Point> points) {\n+        int result = 0;\n+        for (Point(Integer a, Integer b) : points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int arrayEnhancedFor(Point[] points) {\n+        int result = 0;\n+        for (Point(Integer a, Integer b) : points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int simpleDecostructionPatternWithAccesses(List<Point> points) {\n+        int result = 0;\n+        for (Point(var a, var b): points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int simpleDecostructionPatternException(List<PointEx> points) {\n+        int result = 0;\n+        for (PointEx(var a, var b): points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int simpleDecostructionPatternNoComponentAccess(List<Point> points) {\n+        int result = 0;\n+        for (Point(var a, var b): points) {\n+            result += 1;\n+        }\n+        return result;\n+    }\n+\n+    static int varAndConcrete(List<Point> points) {\n+        int result = 0;\n+        for (Point(Integer a, var b): points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int returnFromEnhancedFor(List<Point> points) {\n+        for (Point(var a, var b): points) {\n+            return a + b;\n+        }\n+        return -1;\n+    }\n+\n+    static int breakFromEnhancedFor(List<Point> points) {\n+        int i = 1;\n+        int result = 0;\n+        for (Point(var a, var b): points) {\n+            if (i == 1) break;\n+            else result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int sealedRecordPassBaseType(List<IPoint> points) {\n+        int result = 0;\n+\n+        for(Point(var x, var y) : points) {\n+            result += (x + y);\n+        }\n+\n+        return result;\n+    }\n+\n+    static int withPrimitives(List<WithPrimitives> points) {\n+        int result = 0;\n+        for (WithPrimitives(int a, double b): points) {\n+            result += a + (int) b;\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Simpler pos tests with local variable declarations\n+    \/\/ Should pass now and in the future if local variable\n+    \/\/ declaration is subsumed by patterns (not just record patterns)\n+    static int primitiveWidening(byte[] inBytes) {\n+        int acc = 0;\n+        for (int i: inBytes) {\n+            acc += i;\n+        }\n+        return acc;\n+    }\n+\n+    static int applicability1(List<Point> points) {\n+        for (IPoint p: points) {\n+            System.out.println(p);\n+        }\n+        return -1;\n+    }\n+\n+    static int applicability2(List<Object> points) {\n+        for (Object p: points) {\n+            System.out.println(p);\n+        }\n+        return -1;\n+    }\n+\n+    static void m(int i) { }\n+    static void m(GPoint<?> gpoint, int i) { }\n+    static int b() { return 42; }\n+\n+    static void forParsing(int i, boolean cond) {\n+        List<Point>                 points = null;\n+        List<GPoint<Integer>>       generic_points = null;\n+        List<GPoint<Point>>         generic_points_nested = null;\n+        List<GPoint<VoidPoint>>     generic_vpoints_nested = null;\n+        List<RecordOfLists>         list_of_records = null;\n+        List<RecordOfLists2>        list_of_records2 = null;\n+\n+        for (Point(Integer a, Integer b) : points) { }\n+        for (ForEachPatterns.Point(Integer a, Integer b) : points) { }\n+        for (GPoint<Integer>(Integer a, Integer b) : generic_points) { }\n+        for (@Annot(field = \"test\") Point p : points) {}\n+        for (method(); i == 0;) { i++; }\n+        for (method(), method(); i == 0;) { i++; }\n+        for (ForEachPatterns.<Integer>method(); i == 0;) { i++; }\n+        for (GPoint<Point>(Point(Integer a, Integer b), Point c) : generic_points_nested) { }\n+        for (GPoint<Point>(Point(var a, Integer b), Point c) : generic_points_nested) { }\n+        for (GPoint<VoidPoint>(VoidPoint(), VoidPoint()) : generic_vpoints_nested) { }\n+        for (method2((Integer a) -> 42); i == 0;) { i++; }\n+        for (RecordOfLists(List<Integer> lr) : list_of_records) {}\n+        for (RecordOfLists2(List<List<Integer>> lr) : list_of_records2) {}\n+        for (m(cond ? b() : i) ; ;) {}\n+        for (m((GPoint<?>)null, cond ? b() : i) ; ;) {}\n+        for (GPoint<@Annot(field = \"\") ? extends Point>(var x, var y) : generic_points_nested) {};\n+    }\n+    \/\/where\n+    static <T> void method() {}\n+    static <T> void method2(Function<Integer, Integer> f) {}\n+\n+    static List<Color> JEPExample() {\n+        Rectangle rect = new Rectangle(\n+                new ColoredPoint(new Point(1,2), Color.RED),\n+                new ColoredPoint(new Point(3,4), Color.GREEN)\n+        );\n+        Rectangle[] rArr = {rect};\n+        return printUpperLeftColors(rArr);\n+    }\n+    \/\/where\n+    static List<Color> printUpperLeftColors(Rectangle[] r) {\n+        List<Color> ret = new ArrayList<>();\n+        for (Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr): r) {\n+            ret.add(c);\n+        }\n+        return ret;\n+    }\n+\n+    static int arrayWithSealed(IParent[] recs){\n+        for (Rec(int a) : recs) {\n+            return a;\n+        }\n+        return -1;\n+    }\n+\n+    enum Color { RED, GREEN, BLUE }\n+    record ColoredPoint(Point p, Color c) {}\n+    record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}\n+\n+    sealed interface IParent permits Rec {}\n+    record Rec(int a) implements IParent {}\n+\n+    sealed interface IPoint permits Point {}\n+    record Point(Integer x, Integer y) implements IPoint { }\n+\n+    record GPoint<T>(T x, T y) { }\n+    record VoidPoint() { }\n+    record RecordOfLists(List<Integer> o) {}\n+    record RecordOfLists2(List<List<Integer>> o) {}\n+\n+    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n+    @interface Annot {\n+        String field();\n+    }\n+    record Frog(Integer x, Integer y) { }\n+    record PointEx(Integer x, Integer y) {\n+        @Override\n+        public Integer x() {\n+            throw new TestPatternFailed(EXCEPTION_MESSAGE);\n+        }\n+    }\n+    record WithPrimitives(int x, double y) { }\n+    static final String EXCEPTION_MESSAGE = \"exception-message\";\n+    public static class TestPatternFailed extends AssertionError {\n+        public TestPatternFailed(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    \/\/ error handling\n+    static void fail(String message) {\n+        throw new AssertionError(message);\n+    }\n+\n+    static void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \",\" +\n+                    \"got: \" + actual);\n+        }\n+    }\n+\n+    static <T> void assertMatchExceptionWithNested(Function<List<T>, Integer> f, List<T> points, Class<?> nestedExceptionClass) {\n+        try {\n+            f.apply(points);\n+            fail(\"Expected an exception, but none happened!\");\n+        }\n+        catch(Exception ex) {\n+            assertEquals(MatchException.class, ex.getClass());\n+\n+            MatchException me = (MatchException) ex;\n+\n+            assertEquals(nestedExceptionClass, me.getCause().getClass());\n+        }\n+    }\n+\n+    static <T> void assertEx(Function<List<T>, Integer> f, List<T> points, Class<?> exceptionClass) {\n+        try {\n+            f.apply(points);\n+            fail(\"Expected an exception, but none happened!\");\n+        }\n+        catch(Exception ex) {\n+            assertEquals(exceptionClass, ex.getClass());\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatterns.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @enablePreview\n+ * @compile\/fail\/ref=ForEachPatternsErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW ForEachPatternsErrors.java\n+ *\/\n+\n+import java.util.List;\n+\n+public class ForEachPatternsErrors {\n+\n+    static void exhaustivity_error1(List<Object> points) {\n+        for (Point(var x, var y): points) {\n+            System.out.println();\n+        }\n+    }\n+\n+    static void exhaustivity_error2(List points) {\n+        for (Point(var x, var y): points) {\n+            System.out.println();\n+        }\n+    }\n+\n+    static void exhaustivity_error3(List<OPoint> opoints) {\n+        for (OPoint(String s, String t) : opoints) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    static void exhaustivity_error4(List<?> f) {\n+        for (Rec(var x): f){\n+        }\n+    }\n+\n+    static void applicability_error(List<Object> points) {\n+        for (Interface p: points) {\n+            System.out.println(p);\n+        }\n+    }\n+\n+    record  Rec(String x) { }\n+    interface Interface {}\n+    sealed interface IPoint permits Point {}\n+    record Point(Integer x, Integer y) implements IPoint { }\n+    record OPoint(Object x, Object y) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+ForEachPatternsErrors.java:36:27: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, ForEachPatternsErrors.Interface)\n+ForEachPatternsErrors.java:13:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n+ForEachPatternsErrors.java:19:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n+ForEachPatternsErrors.java:25:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.OPoint, ForEachPatternsErrors.OPoint\n+ForEachPatternsErrors.java:31:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Rec, compiler.misc.type.captureof: 1, ?\n+- compiler.note.preview.filename: ForEachPatternsErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @enablePreview\n+ * @compile -XDfind=all ForEachTestAllAnalyzers.java\n+ *\/\n+public class ForEachTestAllAnalyzers {\n+    private void test(Iterable<? extends R> l) {\n+        for (R(Object a) : l) { }\n+    }\n+    record R(Object a) {}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachTestAllAnalyzers.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-\n+import java.util.List;\n@@ -47,0 +47,2 @@\n+        assertEquals(0, forEachInference(List.of(new Box(\"\"))));\n+        assertEquals(1, forEachInference(List.of(new Box(null))));\n@@ -102,0 +104,7 @@\n+    int forEachInference(Iterable<I<String>> b) {\n+        for (Box(var s) : b) {\n+            return s == null ? 1 : s.length();\n+        }\n+        return -1;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}