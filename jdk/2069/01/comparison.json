{"files":[{"patch":"@@ -153,4 +153,3 @@\n-\/\/ analysis, The method was changed from JRT_LEAF to JRT_BLOCK_ENTRY and\n-\/\/ ResetNoHandleMark and HandleMark were removed from it. The actual reallocation\n-\/\/ of previously eliminated objects occurs in realloc_objects, which is\n-\/\/ called from the method fetch_unroll_info_helper below.\n+\/\/ analysis, the method was changed from JRT_LEAF to JRT_BLOCK_ENTRY.\n+\/\/ The actual reallocation of previously eliminated objects occurs in realloc_objects,\n+\/\/ which is called from the method fetch_unroll_info_helper below.\n@@ -158,4 +157,0 @@\n-  \/\/ It is actually ok to allocate handles in a leaf method. It causes no safepoints,\n-  \/\/ but makes the entry a little slower. There is however a little dance we have to\n-  \/\/ do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro\n-\n@@ -692,4 +687,7 @@\n-  \/\/ It is actually ok to allocate handles in a leaf method. It causes no safepoints,\n-  \/\/ but makes the entry a little slower. There is however a little dance we have to\n-  \/\/ do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro\n-  ResetNoHandleMark rnhm; \/\/ No-op in release\/product versions\n+  \/\/ JRT_LEAF methods don't normally allocate handles and there is a\n+  \/\/ NoHandleMark to enforce that. It is actually safe to use Handles\n+  \/\/ in a JRT_LEAF method, and sometimes desirable, but to do so we\n+  \/\/ must use ResetNoHandleMark to bypass the NoHandleMark, and\n+  \/\/ then use a HandleMark to ensure any Handles we do create are\n+  \/\/ cleaned up in this scope.\n+  ResetNoHandleMark rnhm;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"}]}