{"files":[{"patch":"@@ -335,0 +335,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -356,0 +357,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -370,0 +372,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -386,0 +389,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -404,0 +408,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -424,0 +429,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -447,0 +453,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -472,0 +479,1 @@\n+  , _igvn_verify_epoch(0)\n@@ -2213,3 +2221,47 @@\n-\/\/ Verify all nodes if verify_depth is negative\n-void Node::verify(Node* n, int verify_depth) {\n-  assert(verify_depth != 0, \"depth should not be 0\");\n+\/*\n+ * Design target:\n+ * 1. Each node is only verified once in PhaseIterGVN::verify_step, optimize\n+ *    1.1. Redundant verifications between full and nodes in _verify_window\n+ *    1.2. Redundant verifications between nodes in _verify_window\n+ * 2. Node's def-use count is only verified once.\n+ *\n+ * Node none product fields to record IGVN verification status:\n+ * 1. _igvn_verify_epoch: if node is visisted in current PhaseIterGVN::verify_step\n+ * 2. _igvn_verify_depth_cur: processed depth in current Node::verify\n+ * 3. _igvn_verify_depth_prev: processed depth in previous Node::verify\n+ *\n+ * Status:\n+ * 1. _igvn_verify_epoch != verify_epoch: self and recurisive check\n+ * 2. _igvn_verify_epoch == verify_epoch:\n+ *    2.1. _igvn_verify_depth_prev == 0: self and recurisive check\n+ *    2.2. 0 < _igvn_verify_depth_prev < _igvn_verify_depth_cur: recurisive check\n+ *\n+ * Actions:\n+ * Adding node into worklist when:\n+ * 1. _igvn_verify_epoch is different with current verify_epoch\n+ * 2. Or _igvn_verify_depth_cur is smaller than verify_depth\n+ * Note: verify_depth variable decreased in this method.\n+ *\n+ * When adding node into worklist:\n+ * 1. If _igvn_verify_epoch is different with current verify_epoch\n+ *    _igvn_verify_depth_prev = 0\n+ *    _igvn_verify_depth_cur = (current verify_depth)\n+ * 2. Else\n+ *    _igvn_verify_depth_prev = _igvn_verify_depth_cur\n+ *    _igvn_verify_depth_cur = (current verify_depth)\n+ *\n+ * As recursive is performed in BFS, bigger verify_depth is processed\n+ * before smaller verify_depth, there are no redundannt nodes in worklist.\n+ *\/\n+ void Node::verify(Node* n, jint verify_depth, julong verify_epoch) {\n+  assert(verify_depth > 0, \"depth should not be positive\");\n+  if (n->_igvn_verify_epoch != verify_epoch) {\n+    n->_igvn_verify_epoch = verify_epoch;\n+    n->_igvn_verify_depth_prev = 0;\n+    n->_igvn_verify_depth_cur = verify_depth;\n+  } else if (n->_igvn_verify_depth_cur < verify_depth) {\n+    n->_igvn_verify_depth_prev = n->_igvn_verify_depth_cur;\n+    n->_igvn_verify_depth_cur = verify_depth;\n+  } else {\n+    return;\n+  }\n@@ -2217,2 +2269,0 @@\n-  VectorSet old_space;\n-  VectorSet new_space;\n@@ -2222,0 +2272,1 @@\n+  Node* top = C->top();\n@@ -2224,3 +2275,1 @@\n-  \/\/ Only add nodes to worklist if verify_depth is negative (visit all nodes) or greater than 0\n-  bool add_to_worklist = verify_depth != 0;\n-\n+  bool add_to_worklist = verify_depth > 0; \/\/ add nodes to worklist if verify_depth is positive\n@@ -2231,1 +2280,3 @@\n-    if (n->is_Con() && n->bottom_type() == Type::TOP) {\n+    bool verify_self = (n->_igvn_verify_depth_prev == 0);\n+\n+    if (verify_self && n->is_Con() && n->bottom_type() == Type::TOP) {\n@@ -2238,3 +2289,4 @@\n-    for (uint i = 0; i < n->len(); i++) {\n-      Node* x = n->in(i);\n-      if (!x || x->is_top()) {\n+    uint in_len = n->len();\n+    for (uint i = 0; i < in_len; i++) {\n+      Node* x = n->_in[i];\n+      if (!x || x == top) {\n@@ -2246,4 +2298,16 @@\n-      int cnt = 0;\n-      for (uint j = 0; j < n->len(); j++) {\n-        if (n->in(j) == x) {\n-          cnt++;\n+      if (verify_self) {\n+        int cnt = 1;\n+        for (uint j = 0; j < i; j++) {\n+          if (n->_in[j] == x) {\n+            cnt++;\n+            break;\n+          }\n+        }\n+        \/\/ has same input node before i, x already checked\n+        if (cnt == 2) {\n+          continue;\n+        }\n+        for (uint j = i + 1; j < in_len; j++) {\n+          if (n->_in[j] == x) {\n+            cnt++;\n+          }\n@@ -2251,1 +2315,0 @@\n-      }\n@@ -2253,5 +2316,6 @@\n-      \/\/ Count def-use edges from x to n\n-      uint max = x->_outcnt;\n-      for (uint k = 0; k < max; k++) {\n-        if (x->_out[k] == n) {\n-          cnt--;\n+        \/\/ Count def-use edges from x to n\n+        uint max = x->_outcnt;\n+        for (uint k = 0; k < max; k++) {\n+          if (x->_out[k] == n) {\n+            cnt--;\n+          }\n@@ -2259,0 +2323,1 @@\n+        assert(cnt == 0, \"mismatched def-use edge counts\");\n@@ -2260,8 +2325,12 @@\n-      assert(cnt == 0, \"mismatched def-use edge counts\");\n-\n-      \/\/ Contained in new_space or old_space?\n-      VectorSet* v = C->node_arena()->contains(x) ? &new_space : &old_space;\n-      \/\/ Check for visited in the proper space. Numberings are not unique\n-      \/\/ across spaces so we need a separate VectorSet for each space.\n-      if (add_to_worklist && !v->test_set(x->_idx)) {\n-        worklist.push(x);\n+\n+      if (add_to_worklist) {\n+        if (x->_igvn_verify_epoch != verify_epoch) {\n+          x->_igvn_verify_epoch = verify_epoch;\n+          x->_igvn_verify_depth_prev = 0;\n+          x->_igvn_verify_depth_cur = verify_depth;\n+          worklist.push(x);\n+        } else if (x->_igvn_verify_depth_cur < verify_depth) {\n+          x->_igvn_verify_depth_prev = x->_igvn_verify_depth_cur;\n+          x->_igvn_verify_depth_cur = verify_depth;\n+          worklist.push(x);\n+        }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":99,"deletions":30,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -1164,0 +1164,4 @@\n+  \/\/ used in VerifyIterativeGVN, indicate if Node is processed in this iteration.\n+  jint _igvn_verify_depth_cur;\n+  jint _igvn_verify_depth_prev;\n+  julong _igvn_verify_epoch;\n@@ -1204,1 +1208,1 @@\n-  static void verify(Node* n, int verify_depth);\n+  static void verify(Node* n, jint verify_depth, julong verify_epoch);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -970,0 +970,1 @@\n+  NOT_PRODUCT(_verify_epoch = 0;)\n@@ -984,0 +985,1 @@\n+  NOT_PRODUCT(_verify_epoch = 0;)\n@@ -1027,0 +1029,2 @@\n+    \/\/ Node::verify is only invoked in PhaseIterGVN::verify_step\n+    ++_verify_epoch;\n@@ -1031,1 +1035,1 @@\n-      Node::verify(C->root(), -1);\n+      Node::verify(C->root(), max_jint, _verify_epoch);\n@@ -1044,1 +1048,1 @@\n-      Node::verify(n, 4);\n+      Node::verify(n, 4, _verify_epoch);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -558,0 +558,1 @@\n+  julong _verify_epoch;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}