{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import javax.lang.model.SourceVersion;\n@@ -955,2 +956,3 @@\n-        if (e == null)\n-            env.messages.error(REFERENCE, tree, \"dc.ref.not.found\");\n+        if (e == null) {\n+            reportBadReference(tree);\n+        }\n@@ -960,0 +962,19 @@\n+    private void reportBadReference(ReferenceTree tree) {\n+        if (!env.strictReferenceChecks) {\n+            String refSig = tree.getSignature();\n+            int sep = refSig.indexOf(\"\/\");\n+            if (sep > 0) {\n+                String moduleName = refSig.substring(0, sep);\n+                if (SourceVersion.isName(moduleName)) {\n+                    Element m = env.elements.getModuleElement(moduleName);\n+                    if (m == null) {\n+                        env.messages.warning(REFERENCE, tree, \"dc.ref.in.missing.module\", moduleName);\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        env.messages.error(REFERENCE, tree, \"dc.ref.not.found\");\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -277,0 +277,8 @@\n+    \/**\n+     * Initialize DocLint for use with a {@code JavacTask}.\n+     * {@link Env#strictReferenceChecks Strict reference checks} are <em>not<\/em> enabled by default.\n+     *\n+     * @param task            the task\n+     * @param args            arguments to configure DocLint\n+     * @param addTaskListener whether or not to register a {@code TaskListener} to invoke DocLint\n+     *\/\n@@ -322,0 +330,9 @@\n+    \/**\n+     * Initialize DocLint with the given utility objects and arguments.\n+     * {@link Env#strictReferenceChecks Strict reference checks} <em>are<\/em> enabled by default.\n+     *\n+     * @param trees    the {@code DocTrees} utility class\n+     * @param elements the {@code Elements} utility class\n+     * @param types    the {@code Types} utility class\n+     * @param args     arguments to configure DocLint\n+     *\/\n@@ -325,0 +342,1 @@\n+        env.strictReferenceChecks = true;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/DocLint.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,0 +111,14 @@\n+    \/**\n+     * How to handle bad references.\n+     *\n+     * If {@code false}, a reference into a module that is not\n+     * in the module graph will just be reported as a warning.\n+     * All other bad references will be reported as errors.\n+     * This is the desired behavior for javac.\n+     *\n+     * If {@code true}, all bad references will be reported as\n+     * errors. This is the desired behavior for javadoc.\n+     *\n+     *\/\n+    boolean strictReferenceChecks = false;\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Env.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+dc.ref.in.missing.module = module for reference not found: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280688\n+ * @summary doclint reference checks withstand warning suppression\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.api\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.JavacTask toolbox.JavadocTask toolbox.TestRunner toolbox.ToolBox\n+ * @run main DocLintReferencesTest\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.JavadocTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * Combo test for how javac and javadoc handle {@code @see MODULE\/TYPE}\n+ * for different combinations of MODULE and TYPE, with and without\n+ * {@code @SuppressWarnings(\"doclint\") }.\n+ *\n+ * Generally, in javac, references to unknown elements are reported\n+ * as suppressible warnings if the module is not resolved in the module graph.\n+ * Otherwise, in both javac and javadoc, any issues with references\n+ * are reported as errors.\n+ *\n+ * This allows references to other modules to appear in documentation comments\n+ * without causing a hard error if the modules are not available at compile-time.\n+ *\/\n+public class DocLintReferencesTest extends TestRunner {\n+\n+    public static void main(String... args) throws Exception {\n+        DocLintReferencesTest t = new DocLintReferencesTest();\n+        t.runTests();\n+    }\n+\n+    DocLintReferencesTest() {\n+        super(System.err);\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    enum SuppressKind { NO, YES }\n+    enum ModuleKind { NONE, BAD, NOT_FOUND, GOOD }\n+    enum TypeKind { NONE, BAD, NOT_FOUND, GOOD }\n+\n+    @Test\n+    public void comboTest () {\n+        for (SuppressKind sk : SuppressKind.values() ) {\n+            for (ModuleKind mk : ModuleKind.values() ) {\n+                for (TypeKind tk: TypeKind.values() ) {\n+                    if (mk == ModuleKind.NONE && tk == TypeKind.NONE) {\n+                        continue;\n+                    }\n+\n+                    try {\n+                        test(sk, mk, tk);\n+                    } catch (Throwable e) {\n+                        error(\"Exception \" + e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void test(SuppressKind sk, ModuleKind mk, TypeKind tk) throws Exception {\n+        out.println();\n+        out.println(\"*** Test SuppressKind:\" + sk + \" ModuleKind: \" + mk + \" TypeKind: \" + tk);\n+        Path base = Path.of(sk + \"-\" + mk + \"-\" + tk);\n+\n+        String sw = switch (sk) {\n+            case NO -> \"\";\n+            case YES -> \"@SuppressWarnings(\\\"doclint\\\")\";\n+        };\n+        String m = switch (mk) {\n+            case NONE -> \"\";\n+            case BAD -> \"bad-name\/\";\n+            case NOT_FOUND -> \"not.found\/\";\n+            case GOOD -> \"java.base\/\";\n+        };\n+        String t = switch (tk) {\n+            case NONE -> \"\";\n+            case BAD -> \"bad-name\";\n+            case NOT_FOUND -> \"java.lang.NotFound\";\n+            case GOOD -> \"java.lang.Object\";\n+        };\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * Comment.\n+                 * @see #M##T#\n+                 *\/\n+                 #SW#\n+                public class C {\n+                   private C() { }\n+                }\n+                \"\"\"\n+                .replace(\"#M#\", m)\n+                .replace(\"#T#\", t)\n+                .replace(\"#SW#\", sw));\n+\n+        testJavac(sk, mk, tk, base, src);\n+        testJavadoc(sk, mk, tk, base, src);\n+    }\n+\n+    void testJavac(SuppressKind sk, ModuleKind mk, TypeKind tk, Path base, Path src) throws Exception {\n+        Files.createDirectories(base.resolve(\"classes\"));\n+\n+        out.println(\"javac:\");\n+        try {\n+            String s = predictOutput(sk, mk, tk, false);\n+            Task.Expect e = s.isEmpty() ? Task.Expect.SUCCESS : Task.Expect.FAIL;\n+\n+            String o = new JavacTask(tb)\n+                    .outdir(base.resolve(\"classes\"))\n+                    .options(\"-Xdoclint:all\/protected\", \"-Werror\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run(e)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+            checkOutput(s, o);\n+\n+        } catch (Throwable t) {\n+            error(\"Error: \" + t);\n+        }\n+        out.println();\n+    }\n+\n+    void testJavadoc(SuppressKind sk, ModuleKind mk, TypeKind tk, Path base, Path src) throws Exception {\n+        Files.createDirectories(base.resolve(\"api\"));\n+\n+        out.println(\"javadoc:\");\n+        try {\n+            String s = predictOutput(sk, mk, tk, true);\n+            Task.Expect e = s.isEmpty() ? Task.Expect.SUCCESS : Task.Expect.FAIL;\n+\n+            String o = new JavadocTask(tb)\n+                    .outdir(base.resolve(\"api\"))\n+                    .options(\"-Xdoclint\", \"-Werror\", \"-quiet\", \"-sourcepath\", src.toString(), \"p\")\n+                    .run(e)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+            checkOutput(s, o);\n+\n+        } catch (Throwable t) {\n+            error(\"Error: \" + t);\n+        }\n+        out.println();\n+    }\n+\n+    private static final String ERROR_UNEXPECTED_TEXT = \"error: unexpected text\";\n+    private static final String ERROR_REFERENCE_NOT_FOUND = \"error: reference not found\";\n+    private static final String WARNING_MODULE_FOR_REFERENCE_NOT_FOUND = \"warning: module for reference not found: not.found\";\n+    private static final String EMPTY = \"\";\n+\n+    \/**\n+     * Returns the expected diagnostic, if any, based on the parameters of the test case.\n+     *\n+     * The \"interesting\" cases are those for which the module name is not found,\n+     * in which case an error for \"reference not found\" is reduced to warning,\n+     * which may be suppressed.\n+     *\n+     * @param sk whether @SuppressWarnings is present of not\n+     * @param mk the kind of module in the reference\n+     * @param tk the kind of class or interface name in the reference\n+     * @param strict whether all \"not found\" references are errors,\n+     *               or just warnings if the module name is not found\n+     * @return a diagnostic string, or an empty string if no diagnostic should be generated\n+     *\/\n+    String predictOutput(SuppressKind sk, ModuleKind mk, TypeKind tk, boolean strict) {\n+        return switch (mk) {\n+            case NONE -> switch(tk) {\n+                case NONE -> throw new Error(\"should not happen\"); \/\/ filtered out in combo loops\n+                case BAD -> ERROR_UNEXPECTED_TEXT;\n+                case NOT_FOUND -> ERROR_REFERENCE_NOT_FOUND;\n+                case GOOD -> EMPTY;\n+            };\n+\n+            case BAD -> ERROR_UNEXPECTED_TEXT;\n+\n+            case NOT_FOUND -> switch(tk) {\n+                case BAD -> ERROR_UNEXPECTED_TEXT;\n+                case NONE, NOT_FOUND, GOOD -> strict\n+                        ? ERROR_REFERENCE_NOT_FOUND\n+                        : sk == SuppressKind.YES\n+                            ? EMPTY\n+                            : WARNING_MODULE_FOR_REFERENCE_NOT_FOUND;\n+            };\n+\n+            case GOOD -> switch(tk) {\n+                case BAD -> ERROR_UNEXPECTED_TEXT;\n+                case NOT_FOUND -> ERROR_REFERENCE_NOT_FOUND;\n+                case GOOD, NONE -> EMPTY;\n+            };\n+        };\n+    }\n+\n+    \/**\n+     * Checks the actual output against the expected string, generated by {@code predictError}.\n+     * If the expected string is empty, the output should be empty.\n+     * If the expected string is not empty, it should be present in the output.\n+     *\n+     * @param expect the expected string\n+     * @param found  the output\n+     *\/\n+    void checkOutput(String expect, String found) {\n+        if (expect.isEmpty()) {\n+            if (found.isEmpty()) {\n+                out.println(\"Output OK\");\n+            } else {\n+                error(\"unexpected output\");\n+            }\n+        } else {\n+            if (found.contains(expect)) {\n+                out.println(\"Output OK\");\n+            } else {\n+                error(\"expected output not found: \" + expect);\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/doclint\/DocLintReferencesTest.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"}]}