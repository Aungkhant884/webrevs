{"files":[{"patch":"@@ -1669,0 +1669,3 @@\n+      if (is_subword_type(bt)) {\n+        return false;\n+      } \/\/ fallthrough\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -338,0 +338,1 @@\n+  bool arch_supports_vector_rotate(int opc, int num_elem, BasicType elem_bt, bool check_bcast = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2491,1 +2491,0 @@\n-        assert(in2->bottom_type()->isa_int(), \"Shift must always be an int value\");\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,26 @@\n+bool LibraryCallKit::arch_supports_vector_rotate(int opc, int num_elem, BasicType elem_bt, bool check_bcast) {\n+    bool is_supported = true;\n+    if (!arch_supports_vector(opc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/) ||\n+        (check_bcast && !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed))) {\n+      is_supported = false;\n+    }\n+    int lshiftopc = VectorNode::opcode(elem_bt == T_LONG ? Op_LShiftL : Op_LShiftI, elem_bt);\n+    auto urshiftopc = [&]() {\n+      switch(elem_bt) {\n+        case T_INT: return Op_URShiftI;\n+        case T_LONG: return Op_URShiftL;\n+        case T_BYTE: return Op_URShiftB;\n+        case T_SHORT: return Op_URShiftS;\n+        default: return (Opcodes)0;\n+      }\n+    };\n+    int rshiftopc = VectorNode::opcode(urshiftopc(), elem_bt);\n+    if (!is_supported &&\n+        arch_supports_vector(lshiftopc, num_elem, elem_bt, VecMaskNotUsed) &&\n+        arch_supports_vector(rshiftopc, num_elem, elem_bt, VecMaskNotUsed) &&\n+        arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+      is_supported = true;\n+    }\n+    return is_supported;\n+}\n+\n@@ -243,6 +269,18 @@\n-  \/\/ TODO When mask usage is supported, VecMaskNotUsed needs to be VecMaskUseLoad.\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, is_vector_mask(vbox_klass) ? VecMaskUseAll : VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d\",\n-                    n, sopc, num_elem, type2name(elem_bt),\n-                    is_vector_mask(vbox_klass) ? 1 : 0);\n+  if (VectorNode::is_rotate_opcode(opc)) {\n+    if (!arch_supports_vector_rotate(sopc, num_elem, elem_bt, false)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d\",\n+                      n, sopc, num_elem, type2name(elem_bt),\n+                      is_vector_mask(vbox_klass) ? 1 : 0);\n+      }\n+      return false; \/\/ not supported\n+    }\n+  } else {\n+    \/\/ TODO When mask usage is supported, VecMaskNotUsed needs to be VecMaskUseLoad.\n+    if (!arch_supports_vector(sopc, num_elem, elem_bt, is_vector_mask(vbox_klass) ? VecMaskUseAll : VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d\",\n+                      n, sopc, num_elem, type2name(elem_bt),\n+                      is_vector_mask(vbox_klass) ? 1 : 0);\n+      }\n+      return false; \/\/ not supported\n@@ -250,1 +288,0 @@\n-    return false; \/\/ not supported\n@@ -1338,1 +1375,3 @@\n-  if (opc == 0 || !VectorNode::is_shift_opcode(opc)) {\n+  bool is_shift  = VectorNode::is_shift_opcode(opc);\n+  bool is_rotate = VectorNode::is_rotate_opcode(opc);\n+  if (opc == 0 || (!is_shift && !is_rotate)) {\n@@ -1351,0 +1390,1 @@\n+  Node* cnt  = argument(5);\n@@ -1353,5 +1393,18 @@\n-\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n-                    sopc, num_elem, type2name(elem_bt));\n+  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n+  bool is_const_rotate = is_rotate && cnt_type && cnt_type->is_con() &&\n+                         -0x80 <= cnt_type->get_con() && cnt_type->get_con() < 0x80;\n+  if (is_rotate) {\n+    if (!arch_supports_vector_rotate(sopc, num_elem, elem_bt, !is_const_rotate)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n+                      sopc, num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+  } else {\n+    if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n+                      sopc, num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n@@ -1359,1 +1412,0 @@\n-    return false; \/\/ not supported\n@@ -1362,1 +1414,14 @@\n-  Node* opd2 = vector_shift_count(argument(5), opc, elem_bt, num_elem);\n+  Node* opd2 = NULL;\n+  if (is_shift) {\n+    opd2 = vector_shift_count(cnt, opc, elem_bt, num_elem);\n+  } else {\n+    assert(is_rotate, \"unexpected operation\");\n+    if (!is_const_rotate) {\n+      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+      cnt = elem_bt == T_LONG ? gvn().transform(new ConvI2LNode(cnt)) : cnt;\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+    } else {\n+      \/\/ constant shift.\n+      opd2 = cnt;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":80,"deletions":15,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateLeftV : 0);\n+    return (is_integral_type(bt) ? Op_RotateLeftV : 0);\n@@ -147,1 +147,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateRightV : 0);\n+    return (is_integral_type(bt) ? Op_RotateRightV : 0);\n@@ -298,7 +298,0 @@\n-bool VectorNode::is_scalar_rotate(Node* n) {\n-  if (n->Opcode() == Op_RotateLeft || n->Opcode() == Op_RotateRight) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -350,0 +343,17 @@\n+bool VectorNode::is_rotate_opcode(int opc) {\n+  switch (opc) {\n+  case Op_RotateRight:\n+  case Op_RotateLeft:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool VectorNode::is_scalar_rotate(Node* n) {\n+  if (is_rotate_opcode(n->Opcode())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -1130,1 +1140,1 @@\n-  assert(bt == T_INT || bt == T_LONG, \"sanity\");\n+  assert(is_integral_type(bt), \"sanity\");\n@@ -1133,3 +1143,12 @@\n-  int shift_mask = (bt == T_INT) ? 0x1F : 0x3F;\n-  int shiftLOpc = (bt == T_INT) ? Op_LShiftI : Op_LShiftL;\n-  int shiftROpc = (bt == T_INT) ? Op_URShiftI: Op_URShiftL;\n+  int shift_mask = (type2aelembytes(bt) * 8) - 1;\n+  int shiftLOpc = (bt == T_LONG) ? Op_LShiftL : Op_LShiftI;\n+  auto urshiftopc = [=]() {\n+    switch(bt) {\n+      case T_INT: return Op_URShiftI;\n+      case T_LONG: return Op_URShiftL;\n+      case T_BYTE: return Op_URShiftB;\n+      case T_SHORT: return Op_URShiftS;\n+      default: return (Opcodes)0;\n+    }\n+  };\n+  int shiftROpc = urshiftopc();\n@@ -1141,3 +1160,5 @@\n-  if (cnt->is_Con() && cnt->bottom_type()->isa_int()) {\n-    \/\/ Constant shift case.\n-    int shift = cnt->get_int() & shift_mask;\n+  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n+  bool is_binary_vector_op = false;\n+  if (cnt_type && cnt_type->is_con()) {\n+    \/\/ Constant shift.\n+    int shift = cnt_type->get_con() & shift_mask;\n@@ -1146,2 +1167,2 @@\n-  } else {\n-    \/\/ Variable shift case.\n+  } else if (VectorNode::is_invariant_vector(cnt)) {\n+    \/\/ Scalar variable shift.\n@@ -1155,1 +1176,1 @@\n-    shiftRCnt = phase->transform(new AndINode(cnt, phase->intcon(shift_mask)));\n+    shiftRCnt = cnt;\n@@ -1157,0 +1178,11 @@\n+  } else {\n+    \/\/ Vector variable shift.\n+    assert(cnt->bottom_type()->isa_vect(), \"Unexpected shift\");\n+    const Type* elem_ty = Type::get_const_basic_type(bt);\n+    Node* shift_mask_node = (bt == T_LONG) ? (Node*)(phase->longcon(shift_mask + 1L)) :\n+                                             (Node*)(phase->intcon(shift_mask + 1));\n+    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node,vlen, elem_ty));\n+    int subVopc = VectorNode::opcode((bt == T_LONG) ? Op_SubL : Op_SubI, bt);\n+    shiftRCnt = cnt;\n+    shiftLCnt = phase->transform(VectorNode::make(subVopc, vector_mask, shiftRCnt, vt));\n+    is_binary_vector_op = true;\n@@ -1164,2 +1196,4 @@\n-  shiftLCnt = phase->transform(new LShiftCntVNode(shiftLCnt, vt));\n-  shiftRCnt = phase->transform(new RShiftCntVNode(shiftRCnt, vt));\n+  if (!is_binary_vector_op) {\n+    shiftLCnt = phase->transform(new LShiftCntVNode(shiftLCnt, vt));\n+    shiftRCnt = phase->transform(new RShiftCntVNode(shiftRCnt, vt));\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":55,"deletions":21,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool is_rotate_opcode(int opc);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -352,0 +352,20 @@\n+    case VECTOR_OP_LROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateLeft;\n+        default: fatal(\"LROTATE: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_RROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateRight;\n+        default: fatal(\"RROTATE: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -85,1 +85,5 @@\n-    VECTOR_OP_MASK_LASTTRUE  = 21\n+    VECTOR_OP_MASK_LASTTRUE  = 21,\n+\n+    \/\/ Rotate operations\n+    VECTOR_OP_LROTATE = 22,\n+    VECTOR_OP_RROTATE = 23\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+    \/\/ Rotate operations\n+    public static final int VECTOR_OP_LROTATE = 22;\n+    public static final int VECTOR_OP_RROTATE = 23;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static byte rotateLeft(byte a, int n) {\n+        return (byte)(((((byte)a) & Byte.toUnsignedInt((byte)-1)) << (n & Byte.SIZE-1)) | ((((byte)a) & Byte.toUnsignedInt((byte)-1)) >>> (Byte.SIZE - (n & Byte.SIZE-1))));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static byte rotateRight(byte a, int n) {\n+        return (byte)(((((byte)a) & Byte.toUnsignedInt((byte)-1)) >>> (n & Byte.SIZE-1)) | ((((byte)a) & Byte.toUnsignedInt((byte)-1)) << (Byte.SIZE - (n & Byte.SIZE-1))));\n+    }\n+\n@@ -616,6 +628,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ByteVector neg = that.lanewise(NEG);\n-                ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +669,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -808,5 +819,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ByteVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ByteVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +831,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static int rotateLeft(int a, int n) {\n+        return Integer.rotateLeft(a, n);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static int rotateRight(int a, int n) {\n+        return Integer.rotateRight(a, n);\n+    }\n+\n@@ -616,6 +628,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                IntVector neg = that.lanewise(NEG);\n-                IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +669,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -808,5 +819,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            IntVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            IntVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +831,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static long rotateLeft(long a, int n) {\n+        return Long.rotateLeft(a, n);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long rotateRight(long a, int n) {\n+        return Long.rotateRight(a, n);\n+    }\n+\n@@ -574,6 +586,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                LongVector neg = that.lanewise(NEG);\n-                LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -620,0 +627,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -726,5 +737,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            LongVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            LongVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -743,0 +749,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static short rotateLeft(short a, int n) {\n+        return (short)(((((short)a) & Short.toUnsignedInt((short)-1)) << (n & Short.SIZE-1)) | ((((short)a) & Short.toUnsignedInt((short)-1)) >>> (Short.SIZE - (n & Short.SIZE-1))));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short rotateRight(short a, int n) {\n+        return (short)(((((short)a) & Short.toUnsignedInt((short)-1)) >>> (n & Short.SIZE-1)) | ((((short)a) & Short.toUnsignedInt((short)-1)) << (Short.SIZE - (n & Short.SIZE-1))));\n+    }\n+\n@@ -616,6 +628,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ShortVector neg = that.lanewise(NEG);\n-                ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +669,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -808,5 +819,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ShortVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ShortVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +831,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", -1 \/*VectorSupport.VECTOR_OP_LROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", VectorSupport.VECTOR_OP_LROTATE, VO_SHIFT);\n@@ -526,1 +526,1 @@\n-    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", -1 \/*VectorSupport.VECTOR_OP_RROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", VectorSupport.VECTOR_OP_RROTATE, VO_SHIFT);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -400,0 +400,22 @@\n+#if[BITWISE]\n+    \/*package-private*\/\n+    @ForceInline\n+    static $type$ rotateLeft($type$ a, int n) {\n+#if[intOrLong]\n+        return $Boxtype$.rotateLeft(a, n);\n+#else[intOrLong]\n+        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+#end[intOrLong]\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static $type$ rotateRight($type$ a, int n) {\n+#if[intOrLong]\n+        return $Boxtype$.rotateRight(a, n);\n+#else[intOrLong]\n+        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+#end[intOrLong]\n+    }\n+#end[BITWISE]\n+\n@@ -676,6 +698,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                $abstractvectortype$ neg = that.lanewise(NEG);\n-                $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -733,0 +750,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -889,5 +910,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -906,0 +922,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2297,1 +2305,1 @@\n-    static void LSHLByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2315,1 +2323,1 @@\n-    static void LSHLByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2343,1 +2351,1 @@\n-    static void LSHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2361,1 +2369,1 @@\n-    static void LSHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2389,1 +2397,1 @@\n-    static void ASHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2407,1 +2415,1 @@\n-    static void ASHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2427,0 +2435,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2297,1 +2305,1 @@\n-    static void LSHLByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2315,1 +2323,1 @@\n-    static void LSHLByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2343,1 +2351,1 @@\n-    static void LSHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2361,1 +2369,1 @@\n-    static void LSHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2389,1 +2397,1 @@\n-    static void ASHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2407,1 +2415,1 @@\n-    static void ASHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2427,0 +2435,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2297,1 +2305,1 @@\n-    static void LSHLByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2315,1 +2323,1 @@\n-    static void LSHLByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2343,1 +2351,1 @@\n-    static void LSHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2361,1 +2369,1 @@\n-    static void LSHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2389,1 +2397,1 @@\n-    static void ASHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2407,1 +2415,1 @@\n-    static void ASHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2427,0 +2435,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2297,1 +2305,1 @@\n-    static void LSHLByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2315,1 +2323,1 @@\n-    static void LSHLByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2343,1 +2351,1 @@\n-    static void LSHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2361,1 +2369,1 @@\n-    static void LSHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2389,1 +2397,1 @@\n-    static void ASHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2407,1 +2415,1 @@\n-    static void ASHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2427,0 +2435,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1173,0 +1173,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2302,1 +2310,1 @@\n-    static void LSHLByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2320,1 +2328,1 @@\n-    static void LSHLByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2348,1 +2356,1 @@\n-    static void LSHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2366,1 +2374,1 @@\n-    static void LSHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2394,1 +2402,1 @@\n-    static void ASHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2412,1 +2420,1 @@\n-    static void ASHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2432,0 +2440,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ByteMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ByteMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1933,0 +1933,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1933,0 +1933,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1933,0 +1933,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1933,0 +1933,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1938,0 +1938,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1943,0 +1943,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1943,0 +1943,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1943,0 +1943,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1943,0 +1943,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1948,0 +1948,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2261,1 +2269,1 @@\n-    static void LSHLInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2279,1 +2287,1 @@\n-    static void LSHLInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2307,1 +2315,1 @@\n-    static void LSHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2325,1 +2333,1 @@\n-    static void LSHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2353,1 +2361,1 @@\n-    static void ASHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2371,1 +2379,1 @@\n-    static void ASHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2393,0 +2401,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2261,1 +2269,1 @@\n-    static void LSHLInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2279,1 +2287,1 @@\n-    static void LSHLInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2307,1 +2315,1 @@\n-    static void LSHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2325,1 +2333,1 @@\n-    static void LSHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2353,1 +2361,1 @@\n-    static void ASHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2371,1 +2379,1 @@\n-    static void ASHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2393,0 +2401,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2261,1 +2269,1 @@\n-    static void LSHLInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2279,1 +2287,1 @@\n-    static void LSHLInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2307,1 +2315,1 @@\n-    static void LSHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2325,1 +2333,1 @@\n-    static void LSHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2353,1 +2361,1 @@\n-    static void ASHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2371,1 +2379,1 @@\n-    static void ASHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2393,0 +2401,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2261,1 +2269,1 @@\n-    static void LSHLInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2279,1 +2287,1 @@\n-    static void LSHLInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2307,1 +2315,1 @@\n-    static void LSHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2325,1 +2333,1 @@\n-    static void LSHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2353,1 +2361,1 @@\n-    static void ASHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2371,1 +2379,1 @@\n-    static void ASHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2393,0 +2401,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1134,0 +1134,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2266,1 +2274,1 @@\n-    static void LSHLIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2284,1 +2292,1 @@\n-    static void LSHLIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2312,1 +2320,1 @@\n-    static void LSHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2330,1 +2338,1 @@\n-    static void LSHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2358,1 +2366,1 @@\n-    static void ASHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2376,1 +2384,1 @@\n-    static void ASHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2398,0 +2406,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2282,1 +2290,1 @@\n-    static void LSHLLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2300,1 +2308,1 @@\n-    static void LSHLLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2328,1 +2336,1 @@\n-    static void LSHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2346,1 +2354,1 @@\n-    static void LSHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2374,1 +2382,1 @@\n-    static void ASHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2392,1 +2400,1 @@\n-    static void ASHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2414,0 +2422,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2282,1 +2290,1 @@\n-    static void LSHLLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2300,1 +2308,1 @@\n-    static void LSHLLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2328,1 +2336,1 @@\n-    static void LSHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2346,1 +2354,1 @@\n-    static void LSHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2374,1 +2382,1 @@\n-    static void ASHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2392,1 +2400,1 @@\n-    static void ASHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2414,0 +2422,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2282,1 +2290,1 @@\n-    static void LSHLLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2300,1 +2308,1 @@\n-    static void LSHLLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2328,1 +2336,1 @@\n-    static void LSHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2346,1 +2354,1 @@\n-    static void LSHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2374,1 +2382,1 @@\n-    static void ASHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2392,1 +2400,1 @@\n-    static void ASHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2414,0 +2422,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2282,1 +2290,1 @@\n-    static void LSHLLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2300,1 +2308,1 @@\n-    static void LSHLLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2328,1 +2336,1 @@\n-    static void LSHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2346,1 +2354,1 @@\n-    static void LSHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2374,1 +2382,1 @@\n-    static void ASHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2392,1 +2400,1 @@\n-    static void ASHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2414,0 +2422,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1155,0 +1155,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2287,1 +2295,1 @@\n-    static void LSHLLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2305,1 +2313,1 @@\n-    static void LSHLLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2333,1 +2341,1 @@\n-    static void LSHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2351,1 +2359,1 @@\n-    static void LSHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2379,1 +2387,1 @@\n-    static void ASHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2397,1 +2405,1 @@\n-    static void ASHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2419,0 +2427,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2289,1 +2297,1 @@\n-    static void LSHLShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2307,1 +2315,1 @@\n-    static void LSHLShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2335,1 +2343,1 @@\n-    static void LSHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2353,1 +2361,1 @@\n-    static void LSHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2381,1 +2389,1 @@\n-    static void ASHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2399,1 +2407,1 @@\n-    static void ASHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2417,0 +2425,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2289,1 +2297,1 @@\n-    static void LSHLShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2307,1 +2315,1 @@\n-    static void LSHLShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2335,1 +2343,1 @@\n-    static void LSHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2353,1 +2361,1 @@\n-    static void LSHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2381,1 +2389,1 @@\n-    static void ASHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2399,1 +2407,1 @@\n-    static void ASHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2417,0 +2425,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2289,1 +2297,1 @@\n-    static void LSHLShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2307,1 +2315,1 @@\n-    static void LSHLShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2335,1 +2343,1 @@\n-    static void LSHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2353,1 +2361,1 @@\n-    static void LSHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2381,1 +2389,1 @@\n-    static void ASHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2399,1 +2407,1 @@\n-    static void ASHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2417,0 +2425,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2289,1 +2297,1 @@\n-    static void LSHLShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2307,1 +2315,1 @@\n-    static void LSHLShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2335,1 +2343,1 @@\n-    static void LSHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2353,1 +2361,1 @@\n-    static void LSHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2381,1 +2389,1 @@\n-    static void ASHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2399,1 +2407,1 @@\n-    static void ASHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2417,0 +2425,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1163,0 +1163,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2294,1 +2302,1 @@\n-    static void LSHLShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2312,1 +2320,1 @@\n-    static void LSHLShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2340,1 +2348,1 @@\n-    static void LSHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2358,1 +2366,1 @@\n-    static void LSHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2386,1 +2394,1 @@\n-    static void ASHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2404,1 +2412,1 @@\n-    static void ASHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2422,0 +2430,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ShortMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ShortMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    local kernel_escaped=$(echo -e \"$kernel\" | tr '\\n' '|')\n+    local kernel_escaped=$(echo -e \"$kernel\" | tr '\\n' '`')\n@@ -108,1 +108,1 @@\n-    cat ${filename}.current1 | tr '|' \"\\n\" > ${filename}.current\n+    cat ${filename}.current1 | tr '`' \"\\n\" > ${filename}.current\n@@ -163,1 +163,1 @@\n-        local kernel_smoke_escaped=$(echo -e \"$kernel_smoke\" | tr '\\n' '|')\n+        local kernel_smoke_escaped=$(echo -e \"$kernel_smoke\" | tr '\\n' '`')\n@@ -165,1 +165,1 @@\n-        cat ${filename}.scurrent1 | tr '|' \"\\n\" > ${filename}.scurrent\n+        cat ${filename}.scurrent1 | tr '`' \"\\n\" > ${filename}.scurrent\n@@ -452,0 +452,4 @@\n+gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n+gen_shift_cst_op  \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+gen_shift_cst_op  \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-    static void [[TEST]]$vectorteststype$Shift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+    static void [[TEST]]$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-Masked-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-    static void [[TEST]]$vectorteststype$Shift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+    static void [[TEST]]$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1394,0 +1394,24 @@\n+\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/\/\n+\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class RotateBenchmark {\n+    @Param({\"64\",\"128\",\"256\"})\n+    int size;\n+\n+    @Param({\"128\",\"256\", \"512\"})\n+    int bits;\n+\n+    @Param({\"7\",\"15\",\"31\"})\n+    int shift;\n+\n+    byte[] byteinp;\n+    byte[] byteres;\n+    short[] shortinp;\n+    short[] shortres;\n+    int[] intinp;\n+    int[] intres;\n+    long[] longinp;\n+    long[] longres;\n+    VectorSpecies bspecies;\n+    VectorSpecies sspecies;\n+    VectorSpecies ispecies;\n+    VectorSpecies lspecies;\n+\n+    static final byte[] specialvalsbyte = {0, -0, Byte.MIN_VALUE, Byte.MAX_VALUE};\n+    static final short[] specialvalsshort = {0, -0, Short.MIN_VALUE, Short.MAX_VALUE};\n+    static final int[] specialvalsint = {0, -0, Integer.MIN_VALUE, Integer.MAX_VALUE};\n+    static final long[] specialvalslong = {0L, -0L, Long.MIN_VALUE, Long.MAX_VALUE};\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        byteinp = new byte[size];\n+        byteres = new byte[size];\n+        shortinp = new short[size];\n+        shortres = new short[size];\n+        intinp = new int[size];\n+        intres = new int[size];\n+        longinp = new long[size];\n+        longres = new long[size];\n+\n+        bspecies = VectorSpecies.of(byte.class, VectorShape.forBitSize(bits));\n+        sspecies = VectorSpecies.of(short.class, VectorShape.forBitSize(bits));\n+        ispecies = VectorSpecies.of(int.class, VectorShape.forBitSize(bits));\n+        lspecies = VectorSpecies.of(long.class, VectorShape.forBitSize(bits));\n+\n+        for (int i = 4; i < size; i++) {\n+            byteinp[i] = (byte)i;\n+            shortinp[i] = (short)i;\n+            intinp[i] = i;\n+            longinp[i] = i;\n+        }\n+        for (int i = 0 ; i < specialvalsbyte.length; i++) {\n+            byteinp[i] = specialvalsbyte[i];\n+        }\n+        for (int i = 0 ; i < specialvalsshort.length; i++) {\n+            shortinp[i] = specialvalsshort[i];\n+        }\n+        for (int i = 0 ; i < specialvalsint.length; i++) {\n+            intinp[i] = specialvalsint[i];\n+        }\n+        for (int i = 0 ; i < specialvalslong.length; i++) {\n+            longinp[i] = specialvalslong[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftB(Blackhole bh) {\n+        ByteVector bytevec = null;\n+        for (int j = 0 ; j < size; j+= bspecies.length()) {\n+            bytevec = ByteVector.fromArray(bspecies, byteinp, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROL, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROL, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROL, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROL, shift);\n+            bytevec.lanewise(VectorOperators.ROL, j).intoArray(byteres, j);\n+        }\n+        bh.consume(bytevec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightB(Blackhole bh) {\n+        ByteVector bytevec = null;\n+        for (int j = 0 ; j < size; j+= bspecies.length()) {\n+            bytevec = ByteVector.fromArray(bspecies, byteinp, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROR, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROR, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROR, shift);\n+            bytevec = bytevec.lanewise(VectorOperators.ROR, shift);\n+            bytevec.lanewise(VectorOperators.ROR, j).intoArray(byteres, j);\n+        }\n+        bh.consume(bytevec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftS(Blackhole bh) {\n+        ShortVector shortvec = null;\n+        for (int j = 0 ; j < size; j+= sspecies.length()) {\n+            shortvec = ShortVector.fromArray(sspecies, shortinp, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROL, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROL, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROL, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROL, shift);\n+            shortvec.lanewise(VectorOperators.ROL, j).intoArray(shortres, j);\n+        }\n+        bh.consume(shortvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightS(Blackhole bh) {\n+        ShortVector shortvec = null;\n+        for (int j = 0 ; j < size; j+= sspecies.length()) {\n+            shortvec = ShortVector.fromArray(sspecies, shortinp, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROR, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROR, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROR, shift);\n+            shortvec = shortvec.lanewise(VectorOperators.ROR, shift);\n+            shortvec.lanewise(VectorOperators.ROR, j).intoArray(shortres, j);\n+        }\n+        bh.consume(shortvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftI(Blackhole bh) {\n+        IntVector intvec = null;\n+        for (int j = 0 ; j < size; j+= ispecies.length()) {\n+            intvec = IntVector.fromArray(ispecies, intinp, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec.lanewise(VectorOperators.ROL, j).intoArray(intres, j);\n+        }\n+        bh.consume(intvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightI(Blackhole bh) {\n+        IntVector intvec = null;\n+        for (int j = 0 ; j < size; j+= ispecies.length()) {\n+            intvec = IntVector.fromArray(ispecies, intinp, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec.lanewise(VectorOperators.ROR, j).intoArray(intres, j);\n+        }\n+        bh.consume(intvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftL(Blackhole bh) {\n+        LongVector longvec = null;\n+        for (int j = 0 ; j < size; j+= lspecies.length()) {\n+            longvec = LongVector.fromArray(lspecies, longinp, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec.lanewise(VectorOperators.ROL, j).intoArray(longres, j);\n+        }\n+        bh.consume(longvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightL(Blackhole bh) {\n+        LongVector longvec = null;\n+        for (int j = 0 ; j < size; j+= lspecies.length()) {\n+            longvec = LongVector.fromArray(lspecies, longinp, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec.lanewise(VectorOperators.ROR, j).intoArray(longres, j);\n+        }\n+        bh.consume(longvec);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/RotateBenchmark.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}