{"files":[{"patch":"@@ -1652,0 +1652,3 @@\n+      if (is_subword_type(bt)) {\n+        return false;\n+      } \/\/ fallthrough\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1281,1 +1281,3 @@\n-  if (opc == 0 || !VectorNode::is_shift_opcode(opc)) {\n+  bool is_shift  = VectorNode::is_shift_opcode(opc);\n+  bool is_rotate = VectorNode::is_rotate_opcode(opc);\n+  if (opc == 0 || (!is_shift && !is_rotate)) {\n@@ -1294,0 +1296,1 @@\n+  Node* cnt  = argument(5);\n@@ -1296,5 +1299,39 @@\n-\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n-                    sopc, num_elem, type2name(elem_bt));\n+  bool is_const_rotate = is_rotate && cnt->is_Con() && -0x80 <= cnt->get_int() && cnt->get_int() < 0x80;\n+\n+  if (is_rotate) {\n+    bool is_unsupported = false;\n+    if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/) ||\n+        (!is_const_rotate && !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed))) {\n+      is_unsupported = true;\n+    }\n+    int lshiftopc = VectorNode::opcode(elem_bt == T_LONG ? Op_LShiftL : Op_LShiftI, elem_bt);\n+    auto urshiftopc = [=]() {\n+      switch(elem_bt) {\n+        case T_INT: return Op_URShiftI;\n+        case T_LONG: return Op_URShiftL;\n+        case T_BYTE: return Op_URShiftB;\n+        case T_SHORT: return Op_URShiftS;\n+        default: return (Opcodes)0;\n+      }\n+    };\n+    int rshiftopc = VectorNode::opcode(urshiftopc(), elem_bt);\n+    if (is_unsupported &&\n+        arch_supports_vector(lshiftopc, num_elem, elem_bt, VecMaskNotUsed) &&\n+        arch_supports_vector(rshiftopc, num_elem, elem_bt, VecMaskNotUsed) &&\n+        arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+      is_unsupported = false;\n+    }\n+    if (is_unsupported) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n+                      sopc, num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+  } else {\n+    if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n+                      sopc, num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n@@ -1302,1 +1339,0 @@\n-    return false; \/\/ not supported\n@@ -1305,1 +1341,14 @@\n-  Node* opd2 = vector_shift_count(argument(5), opc, elem_bt, num_elem);\n+  Node* opd2 = NULL;\n+  if (is_shift) {\n+    opd2 = vector_shift_count(cnt, opc, elem_bt, num_elem);\n+  } else {\n+    assert(is_rotate, \"unexpected operation\");\n+    if (!is_const_rotate) {\n+      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+      cnt = elem_bt == T_LONG ? gvn().transform(new ConvI2LNode(cnt)) : cnt;\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+    } else {\n+      \/\/ constant shift.\n+      opd2 = cnt;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateLeftV : 0);\n+    return (is_integral_type(bt) ? Op_RotateLeftV : 0);\n@@ -147,1 +147,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateRightV : 0);\n+    return (is_integral_type(bt) ? Op_RotateRightV : 0);\n@@ -298,7 +298,0 @@\n-bool VectorNode::is_scalar_rotate(Node* n) {\n-  if (n->Opcode() == Op_RotateLeft || n->Opcode() == Op_RotateRight) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -350,0 +343,17 @@\n+bool VectorNode::is_rotate_opcode(int opc) {\n+  switch (opc) {\n+  case Op_RotateRight:\n+  case Op_RotateLeft:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool VectorNode::is_scalar_rotate(Node* n) {\n+  if (is_rotate_opcode(n->Opcode())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -1130,1 +1140,1 @@\n-  assert(bt == T_INT || bt == T_LONG, \"sanity\");\n+  assert(is_integral_type(bt), \"sanity\");\n@@ -1133,3 +1143,12 @@\n-  int shift_mask = (bt == T_INT) ? 0x1F : 0x3F;\n-  int shiftLOpc = (bt == T_INT) ? Op_LShiftI : Op_LShiftL;\n-  int shiftROpc = (bt == T_INT) ? Op_URShiftI: Op_URShiftL;\n+  int shift_mask = (type2aelembytes(bt) * 8) - 1;\n+  int shiftLOpc = (bt == T_LONG) ? Op_LShiftL : Op_LShiftI;\n+  auto urshiftopc = [=]() {\n+    switch(bt) {\n+      case T_INT: return Op_URShiftI;\n+      case T_LONG: return Op_URShiftL;\n+      case T_BYTE: return Op_URShiftB;\n+      case T_SHORT: return Op_URShiftS;\n+      default: return (Opcodes)0;\n+    }\n+  };\n+  int shiftROpc = urshiftopc();\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool is_rotate_opcode(int opc);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -365,0 +365,20 @@\n+    case VECTOR_OP_LROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateLeft;\n+        default: fatal(\"URSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_RROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateRight;\n+        default: fatal(\"URSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+    VECTOR_OP_LROTATE = 17,\n+    VECTOR_OP_RROTATE = 18,\n@@ -79,2 +81,2 @@\n-    VECTOR_OP_CAST        = 17,\n-    VECTOR_OP_REINTERPRET = 18\n+    VECTOR_OP_CAST        = 19,\n+    VECTOR_OP_REINTERPRET = 20\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    public static final int VECTOR_OP_LROTATE = 17;\n+    public static final int VECTOR_OP_RROTATE = 18;\n@@ -69,2 +71,2 @@\n-    public static final int VECTOR_OP_CAST        = 17;\n-    public static final int VECTOR_OP_REINTERPRET = 18;\n+    public static final int VECTOR_OP_CAST        = 19;\n+    public static final int VECTOR_OP_REINTERPRET = 20;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static byte rotateLeft(byte a, int n) {\n+        return (byte)(((((byte)a) & Byte.toUnsignedInt((byte)-1)) << (n & Byte.SIZE-1)) | ((((byte)a) & Byte.toUnsignedInt((byte)-1)) >>> (Byte.SIZE - (n & Byte.SIZE-1))));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static byte rotateRight(byte a, int n) {\n+        return (byte)(((((byte)a) & Byte.toUnsignedInt((byte)-1)) >>> (n & Byte.SIZE-1)) | ((((byte)a) & Byte.toUnsignedInt((byte)-1)) << (Byte.SIZE - (n & Byte.SIZE-1))));\n+    }\n+\n@@ -616,6 +628,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ByteVector neg = that.lanewise(NEG);\n-                ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +669,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -808,5 +819,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ByteVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ByteVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +831,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static int rotateLeft(int a, int n) {\n+        return Integer.rotateLeft(a, n);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static int rotateRight(int a, int n) {\n+        return Integer.rotateRight(a, n);\n+    }\n+\n@@ -616,6 +628,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                IntVector neg = that.lanewise(NEG);\n-                IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +669,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -808,5 +819,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            IntVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            IntVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +831,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static long rotateLeft(long a, int n) {\n+        return Long.rotateLeft(a, n);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long rotateRight(long a, int n) {\n+        return Long.rotateRight(a, n);\n+    }\n+\n@@ -574,6 +586,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                LongVector neg = that.lanewise(NEG);\n-                LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -620,0 +627,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -726,5 +737,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            LongVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            LongVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -743,0 +749,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -396,0 +396,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static short rotateLeft(short a, int n) {\n+        return (short)(((((short)a) & Short.toUnsignedInt((short)-1)) << (n & Short.SIZE-1)) | ((((short)a) & Short.toUnsignedInt((short)-1)) >>> (Short.SIZE - (n & Short.SIZE-1))));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short rotateRight(short a, int n) {\n+        return (short)(((((short)a) & Short.toUnsignedInt((short)-1)) >>> (n & Short.SIZE-1)) | ((((short)a) & Short.toUnsignedInt((short)-1)) << (Short.SIZE - (n & Short.SIZE-1))));\n+    }\n+\n@@ -616,6 +628,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ShortVector neg = that.lanewise(NEG);\n-                ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +669,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -808,5 +819,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ShortVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ShortVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +831,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", -1 \/*VectorSupport.VECTOR_OP_LROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", VectorSupport.VECTOR_OP_LROTATE, VO_SHIFT | VO_SPECIAL);\n@@ -526,1 +526,1 @@\n-    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", -1 \/*VectorSupport.VECTOR_OP_RROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", VectorSupport.VECTOR_OP_RROTATE, VO_SHIFT | VO_SPECIAL);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -400,0 +400,22 @@\n+#if[BITWISE]\n+    \/*package-private*\/\n+    @ForceInline\n+    static $type$ rotateLeft($type$ a, int n) {\n+#if[intOrLong]\n+        return $Boxtype$.rotateLeft(a, n);\n+#else[intOrLong]\n+        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+#end[intOrLong]\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static $type$ rotateRight($type$ a, int n) {\n+#if[intOrLong]\n+        return $Boxtype$.rotateRight(a, n);\n+#else[intOrLong]\n+        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+#end[intOrLong]\n+    }\n+#end[BITWISE]\n+\n@@ -676,6 +698,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                $abstractvectortype$ neg = that.lanewise(NEG);\n-                $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -733,0 +750,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -889,5 +910,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -906,0 +922,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2427,0 +2435,66 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte128VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte128VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2427,0 +2435,66 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte256VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte256VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2427,0 +2435,66 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte512VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte512VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1168,0 +1168,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2427,0 +2435,66 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte64VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte64VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1173,0 +1173,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2432,0 +2440,66 @@\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ByteMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ByteMaxVectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2393,0 +2401,66 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2393,0 +2401,66 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2393,0 +2401,66 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1129,0 +1129,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2393,0 +2401,66 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1134,0 +1134,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2398,0 +2406,66 @@\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2414,0 +2422,66 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2414,0 +2422,66 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2414,0 +2422,66 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1150,0 +1150,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2414,0 +2422,66 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1155,0 +1155,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2419,0 +2427,66 @@\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2417,0 +2425,66 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short128VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short128VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short128VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2417,0 +2425,66 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short256VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short256VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short256VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2417,0 +2425,66 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short512VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short512VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short512VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1158,0 +1158,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2417,0 +2425,66 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short64VectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short64VectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short64VectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1163,0 +1163,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2422,0 +2430,66 @@\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ShortMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROL_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ShortMaxVectorTests::ROR_scalar);\n+    }\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROR_scalar);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+rotate_template=\"Rotate-op\"\n@@ -77,0 +78,1 @@\n+rotate_masked_template=\"Rotate-Masked-op\"\n@@ -106,1 +108,1 @@\n-    local kernel_escaped=$(echo -e \"$kernel\" | tr '\\n' '|')\n+    local kernel_escaped=$(echo -e \"$kernel\" | tr '\\n' '`')\n@@ -108,1 +110,1 @@\n-    cat ${filename}.current1 | tr '|' \"\\n\" > ${filename}.current\n+    cat ${filename}.current1 | tr '`' \"\\n\" > ${filename}.current\n@@ -163,1 +165,1 @@\n-        local kernel_smoke_escaped=$(echo -e \"$kernel_smoke\" | tr '\\n' '|')\n+        local kernel_smoke_escaped=$(echo -e \"$kernel_smoke\" | tr '\\n' '`')\n@@ -165,1 +167,1 @@\n-        cat ${filename}.scurrent1 | tr '|' \"\\n\" > ${filename}.scurrent\n+        cat ${filename}.scurrent1 | tr '`' \"\\n\" > ${filename}.scurrent\n@@ -281,0 +283,6 @@\n+function gen_rotate_cst_op {\n+  echo \"Generating Rotate constant op $1 ($2)...\"\n+  gen_op_tmpl $rotate_template \"$@\"\n+  gen_op_tmpl $rotate_masked_template \"$@\"\n+}\n+\n@@ -452,0 +460,2 @@\n+gen_rotate_cst_op  \"ROL\" \"\" \"\"\n+gen_rotate_cst_op  \"ROR\" \"\" \"\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Rotate-Masked-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Shift-Masked-op.template","status":"copied"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Rotate-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Shift-op.template","status":"copied"},{"patch":"@@ -0,0 +1,8 @@\n+#if[BITWISE]\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]]_scalar);\n+    }\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Rotate-Masked-op.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+#if[BITWISE]\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::[[TEST]]_scalar);\n+    }\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Rotate-op.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -1394,0 +1394,24 @@\n+\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/\/\n+\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+public class RotateBenchmark {\n+    @Param({\"64\",\"128\",\"256\"})\n+    int size;\n+\n+    @Param({\"128\",\"256\", \"512\"})\n+    int bits;\n+\n+    @Param({\"11\",\"21\",\"31\"})\n+    int shift;\n+\n+    long[] longinp;\n+    long[] longres;\n+    int[] intinp;\n+    int[] intres;\n+    VectorSpecies ispecies;\n+    VectorSpecies lspecies;\n+\n+    static final long[] specialvalslong = {0L, -0L, Long.MIN_VALUE, Long.MAX_VALUE};\n+    static final int[] specialvalsint = {0, -0, Integer.MIN_VALUE, Integer.MAX_VALUE};\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        longinp = new long[size];\n+        longres = new long[size];\n+        intinp = new int[size];\n+        intres = new int[size];\n+\n+        ispecies = VectorSpecies.of(int.class, VectorShape.forBitSize(bits));\n+        lspecies = VectorSpecies.of(long.class, VectorShape.forBitSize(bits));\n+\n+        for (int i = 4; i < size; i++) {\n+            intinp[i] = i;\n+            longinp[i] = i;\n+        }\n+        for (int i = 0 ; i < specialvalslong.length; i++) {\n+            longinp[i] = specialvalslong[i];\n+        }\n+        for (int i = 0 ; i < specialvalsint.length; i++) {\n+            intinp[i] = specialvalsint[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftI(Blackhole bh) {\n+        IntVector intvec = null;\n+        for (int j = 0 ; j < size; j+= ispecies.length()) {\n+            intvec = IntVector.fromArray(ispecies, intinp, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROL, shift);\n+            intvec.lanewise(VectorOperators.ROL, j).intoArray(intres, j);\n+        }\n+        bh.consume(intvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightI(Blackhole bh) {\n+        IntVector intvec = null;\n+        for (int j = 0 ; j < size; j+= ispecies.length()) {\n+            intvec = IntVector.fromArray(ispecies, intinp, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec = intvec.lanewise(VectorOperators.ROR, shift);\n+            intvec.lanewise(VectorOperators.ROR, j).intoArray(intres, j);\n+        }\n+        bh.consume(intvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftL(Blackhole bh) {\n+        LongVector longvec = null;\n+        for (int j = 0 ; j < size; j+= lspecies.length()) {\n+            longvec = LongVector.fromArray(lspecies, longinp, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROL, shift);\n+            longvec.lanewise(VectorOperators.ROL, j).intoArray(longres, j);\n+        }\n+        bh.consume(longvec);\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightL(Blackhole bh) {\n+        LongVector longvec = null;\n+        for (int j = 0 ; j < size; j+= lspecies.length()) {\n+            longvec = LongVector.fromArray(lspecies, longinp, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec = longvec.lanewise(VectorOperators.ROR, shift);\n+            longvec.lanewise(VectorOperators.ROR, j).intoArray(longres, j);\n+        }\n+        bh.consume(longvec);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/RotateBenchmark.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}