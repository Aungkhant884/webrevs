{"files":[{"patch":"@@ -1652,0 +1652,3 @@\n+      if (is_subword_type(bt)) {\n+        return false;\n+      } \/\/ fallthrough\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1281,1 +1281,3 @@\n-  if (opc == 0 || !VectorNode::is_shift_opcode(opc)) {\n+  bool is_shift  = VectorNode::is_shift_opcode(opc);\n+  bool is_rotate = VectorNode::is_rotate_opcode(opc);\n+  if (opc == 0 || (!is_shift && !is_rotate)) {\n@@ -1297,4 +1299,37 @@\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n-                    sopc, num_elem, type2name(elem_bt));\n+  if (is_rotate) {\n+    bool is_unsupported = false;\n+    if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/) ||\n+        !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n+      is_unsupported = true;\n+    }\n+    int lshiftopc = VectorNode::opcode(elem_bt == T_LONG ? Op_LShiftL : Op_LShiftI, elem_bt);\n+    auto urshiftopc = [=]() {\n+      switch(elem_bt) {\n+        case T_INT: return Op_URShiftI;\n+        case T_LONG: return Op_URShiftL;\n+        case T_BYTE: return Op_URShiftB;\n+        case T_SHORT: return Op_URShiftS;\n+        default: return (Opcodes)0;\n+      }\n+    };\n+    int rshiftopc = VectorNode::opcode(urshiftopc(), elem_bt);\n+    if (is_unsupported &&\n+        arch_supports_vector(lshiftopc, num_elem, elem_bt, VecMaskNotUsed) &&\n+        arch_supports_vector(rshiftopc, num_elem, elem_bt, VecMaskNotUsed) &&\n+        arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+      is_unsupported = false;\n+    }\n+    if (is_unsupported) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n+                      sopc, num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+  } else {\n+    if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s ismask=no\",\n+                      sopc, num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n@@ -1302,1 +1337,0 @@\n-    return false; \/\/ not supported\n@@ -1305,1 +1339,15 @@\n-  Node* opd2 = vector_shift_count(argument(5), opc, elem_bt, num_elem);\n+  Node* opd2 = NULL;\n+  Node* cnt  = argument(5);\n+  if (is_shift) {\n+    opd2 = vector_shift_count(cnt, opc, elem_bt, num_elem);\n+  } else {\n+    assert(is_rotate, \"unexpected operation\");\n+    if (!cnt->is_Con() || -0x80 > cnt->get_int() || cnt->get_int() >= 0x80) {\n+      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+      cnt = elem_bt == T_LONG ? gvn().transform(new ConvI2LNode(cnt)) : cnt;\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+    } else {\n+      \/\/ constant shift.\n+      opd2 = cnt;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":55,"deletions":7,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateLeftV : 0);\n+    return (is_integral_type(bt) ? Op_RotateLeftV : 0);\n@@ -147,1 +147,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateRightV : 0);\n+    return (is_integral_type(bt) ? Op_RotateRightV : 0);\n@@ -298,7 +298,0 @@\n-bool VectorNode::is_scalar_rotate(Node* n) {\n-  if (n->Opcode() == Op_RotateLeft || n->Opcode() == Op_RotateRight) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -350,0 +343,17 @@\n+bool VectorNode::is_rotate_opcode(int opc) {\n+  switch (opc) {\n+  case Op_RotateRight:\n+  case Op_RotateLeft:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool VectorNode::is_scalar_rotate(Node* n) {\n+  if (is_rotate_opcode(n->Opcode())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -1130,1 +1140,1 @@\n-  assert(bt == T_INT || bt == T_LONG, \"sanity\");\n+  assert(is_integral_type(bt), \"sanity\");\n@@ -1133,3 +1143,12 @@\n-  int shift_mask = (bt == T_INT) ? 0x1F : 0x3F;\n-  int shiftLOpc = (bt == T_INT) ? Op_LShiftI : Op_LShiftL;\n-  int shiftROpc = (bt == T_INT) ? Op_URShiftI: Op_URShiftL;\n+  int shift_mask = (type2aelembytes(bt) * 8) - 1;\n+  int shiftLOpc = (bt == T_LONG) ? Op_LShiftL : Op_LShiftI;\n+  auto urshiftopc = [=]() {\n+    switch(bt) {\n+      case T_INT: return Op_URShiftI;\n+      case T_LONG: return Op_URShiftL;\n+      case T_BYTE: return Op_URShiftB;\n+      case T_SHORT: return Op_URShiftS;\n+      default: return (Opcodes)0;\n+    }\n+  };\n+  int shiftROpc = urshiftopc();\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool is_rotate_opcode(int opc);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -365,0 +365,20 @@\n+    case VECTOR_OP_LROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateLeft;\n+        default: fatal(\"URSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_RROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateRight;\n+        default: fatal(\"URSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+    VECTOR_OP_LROTATE = 17,\n+    VECTOR_OP_RROTATE = 18,\n@@ -79,2 +81,2 @@\n-    VECTOR_OP_CAST        = 17,\n-    VECTOR_OP_REINTERPRET = 18\n+    VECTOR_OP_CAST        = 19,\n+    VECTOR_OP_REINTERPRET = 20\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    public static final int VECTOR_OP_LROTATE = 17;\n+    public static final int VECTOR_OP_RROTATE = 18;\n@@ -69,2 +71,2 @@\n-    public static final int VECTOR_OP_CAST        = 17;\n-    public static final int VECTOR_OP_REINTERPRET = 18;\n+    public static final int VECTOR_OP_CAST        = 19;\n+    public static final int VECTOR_OP_REINTERPRET = 20;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -616,6 +616,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ByteVector neg = that.lanewise(NEG);\n-                ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +657,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (byte)((a << (n & (Byte.SIZE-1))) | (a >>> (Byte.SIZE - (n & (Byte.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (byte)((a >>> (n & (Byte.SIZE-1))) | (a << (Byte.SIZE - (n & (Byte.SIZE-1))))));\n@@ -808,5 +807,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ByteVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ByteVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +819,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (byte)((a << (n & (Byte.SIZE-1))) | (a >>> (Byte.SIZE - (n & (Byte.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (byte)((a >>> (n & (Byte.SIZE-1))) | (a << (Byte.SIZE - (n & (Byte.SIZE-1))))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -616,6 +616,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                IntVector neg = that.lanewise(NEG);\n-                IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +657,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (int)((a << (n & (Integer.SIZE-1))) | (a >>> (Integer.SIZE - (n & (Integer.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (int)((a >>> (n & (Integer.SIZE-1))) | (a << (Integer.SIZE - (n & (Integer.SIZE-1))))));\n@@ -808,5 +807,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            IntVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            IntVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +819,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (int)((a << (n & (Integer.SIZE-1))) | (a >>> (Integer.SIZE - (n & (Integer.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (int)((a >>> (n & (Integer.SIZE-1))) | (a << (Integer.SIZE - (n & (Integer.SIZE-1))))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -574,6 +574,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                LongVector neg = that.lanewise(NEG);\n-                LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -620,0 +615,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (long)((a << (n & (Long.SIZE-1))) | (a >>> (Long.SIZE - (n & (Long.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (long)((a >>> (n & (Long.SIZE-1))) | (a << (Long.SIZE - (n & (Long.SIZE-1))))));\n@@ -726,5 +725,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            LongVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            LongVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -743,0 +737,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (long)((a << (n & (Long.SIZE-1))) | (a >>> (Long.SIZE - (n & (Long.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (long)((a >>> (n & (Long.SIZE-1))) | (a << (Long.SIZE - (n & (Long.SIZE-1))))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -616,6 +616,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ShortVector neg = that.lanewise(NEG);\n-                ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -662,0 +657,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (short)((a << (n & (Short.SIZE-1))) | (a >>> (Short.SIZE - (n & (Short.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> (short)((a >>> (n & (Short.SIZE-1))) | (a << (Short.SIZE - (n & (Short.SIZE-1))))));\n@@ -808,5 +807,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ShortVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ShortVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -825,0 +819,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (short)((a << (n & (Short.SIZE-1))) | (a >>> (Short.SIZE - (n & (Short.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> (short)((a >>> (n & (Short.SIZE-1))) | (a << (Short.SIZE - (n & (Short.SIZE-1))))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", -1 \/*VectorSupport.VECTOR_OP_LROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", VectorSupport.VECTOR_OP_LROTATE, VO_SHIFT | VO_SPECIAL);\n@@ -526,1 +526,1 @@\n-    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", -1 \/*VectorSupport.VECTOR_OP_RROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", VectorSupport.VECTOR_OP_RROTATE, VO_SHIFT | VO_SPECIAL);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -676,6 +676,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                $abstractvectortype$ neg = that.lanewise(NEG);\n-                $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -733,0 +728,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> ($type$)((a << (n & ($Boxtype$.SIZE-1))) | (a >>> ($Boxtype$.SIZE - (n & ($Boxtype$.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> ($type$)((a >>> (n & ($Boxtype$.SIZE-1))) | (a << ($Boxtype$.SIZE - (n & ($Boxtype$.SIZE-1))))));\n@@ -889,5 +888,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -906,0 +900,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> ($type$)((a << (n & ($Boxtype$.SIZE-1))) | (a >>> ($Boxtype$.SIZE - (n & ($Boxtype$.SIZE-1))))));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> ($type$)((a >>> (n & ($Boxtype$.SIZE-1))) | (a << ($Boxtype$.SIZE - (n & ($Boxtype$.SIZE-1))))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2427,0 +2427,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2427,0 +2427,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2427,0 +2427,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2427,0 +2427,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2432,0 +2432,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1937,0 +1937,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1937,0 +1937,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1937,0 +1937,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1937,0 +1937,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1942,0 +1942,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1947,0 +1947,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1947,0 +1947,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1947,0 +1947,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1947,0 +1947,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1952,0 +1952,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2393,0 +2393,84 @@\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROL_unary);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2393,0 +2393,84 @@\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROL_unary);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2393,0 +2393,84 @@\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROL_unary);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2393,0 +2393,84 @@\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROL_unary);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2398,0 +2398,84 @@\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2414,0 +2414,84 @@\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROL_unary);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2414,0 +2414,84 @@\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROL_unary);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2414,0 +2414,84 @@\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROL_unary);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2414,0 +2414,84 @@\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROL_unary);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2419,0 +2419,84 @@\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)((a << b) | (a >>> -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)((a >>> b) | (a << -b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROR_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2417,0 +2417,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2417,0 +2417,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2417,0 +2417,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2417,0 +2417,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2422,0 +2422,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -452,0 +452,2 @@\n+gen_shift_cst_op  \"ROL\" \"(a << b) | (a >>> -b)\" \"intOrLong\"\n+gen_shift_cst_op  \"ROR\" \"(a >>> b) | (a << -b)\" \"intOrLong\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/\/\n+\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+public class RotateBenchmark {\n+\n+  @Param({\"64\",\"128\",\"256\"})\n+  public int TESTSIZE;\n+\n+  @Param({\"128\",\"256\", \"512\"})\n+  public int bits;\n+\n+  @Param({\"31\"})\n+  public int shift;\n+\n+  public long[] inpL;\n+  public long[] resL;\n+  public int[] inpI;\n+  public int[] resI;\n+  public VectorSpecies ISPECIES;\n+  public VectorSpecies LSPECIES;\n+  public IntVector vecI;\n+  public LongVector vecL;\n+\n+  public final long[] specialValsL = {0L, -0L, Long.MIN_VALUE, Long.MAX_VALUE};\n+  public final int[] specialValsI = {0, -0, Integer.MIN_VALUE, Integer.MAX_VALUE};\n+\n+  @Setup(Level.Trial)\n+  public void BmSetup() {\n+    Random r = new Random(1024);\n+    inpL = new long[TESTSIZE];\n+    resL = new long[TESTSIZE];\n+    inpI = new int[TESTSIZE];\n+    resI = new int[TESTSIZE];\n+\n+    ISPECIES = VectorSpecies.of(int.class, VectorShape.forBitSize(bits));\n+    LSPECIES = VectorSpecies.of(long.class, VectorShape.forBitSize(bits));\n+\n+    for (int i = 4; i < TESTSIZE; i++) {\n+      inpI[i] = i;\n+      inpL[i] = i;\n+    }\n+    for (int i = 0 ; i < specialValsL.length; i++) {\n+      inpL[i] = specialValsL[i];\n+    }\n+    for (int i = 0 ; i < specialValsI.length; i++) {\n+      inpI[i] = specialValsI[i];\n+    }\n+\n+  }\n+\n+  @Benchmark\n+  public void testRotateLeftI(Blackhole bh) {\n+    for(int i = 0 ; i < 10000; i++) {\n+      for (int j = 0 ; j < TESTSIZE; j+= ISPECIES.length()) {\n+        vecI = IntVector.fromArray(ISPECIES, inpI, j);\n+        vecI = vecI.lanewise(VectorOperators.ROL, i);\n+        vecI = vecI.lanewise(VectorOperators.ROL, i);\n+        vecI = vecI.lanewise(VectorOperators.ROL, i);\n+        vecI = vecI.lanewise(VectorOperators.ROL, i);\n+        vecI.lanewise(VectorOperators.ROL, i).intoArray(resI, j);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void testRotateRightI(Blackhole bh) {\n+    for(int i = 0 ; i < 10000; i++) {\n+      for (int j = 0 ; j < TESTSIZE; j+= ISPECIES.length()) {\n+        vecI = IntVector.fromArray(ISPECIES, inpI, j);\n+        vecI = vecI.lanewise(VectorOperators.ROR, i);\n+        vecI = vecI.lanewise(VectorOperators.ROR, i);\n+        vecI = vecI.lanewise(VectorOperators.ROR, i);\n+        vecI = vecI.lanewise(VectorOperators.ROR, i);\n+        vecI.lanewise(VectorOperators.ROR, i).intoArray(resI, j);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void testRotateLeftL(Blackhole bh) {\n+    for(int i = 0 ; i < 10000; i++) {\n+      for (int j = 0 ; j < TESTSIZE; j+= LSPECIES.length()) {\n+        vecL = LongVector.fromArray(LSPECIES, inpL, j);\n+        vecL = vecL.lanewise(VectorOperators.ROL, i);\n+        vecL = vecL.lanewise(VectorOperators.ROL, i);\n+        vecL = vecL.lanewise(VectorOperators.ROL, i);\n+        vecL = vecL.lanewise(VectorOperators.ROL, i);\n+        vecL.lanewise(VectorOperators.ROL, i).intoArray(resL, j);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void testRotateRightL(Blackhole bh) {\n+    for(int i = 0 ; i < 10000; i++) {\n+      for (int j = 0 ; j < TESTSIZE; j+= LSPECIES.length()) {\n+        vecL = LongVector.fromArray(LSPECIES, inpL, j);\n+        vecL = vecL.lanewise(VectorOperators.ROR, i);\n+        vecL = vecL.lanewise(VectorOperators.ROR, i);\n+        vecL = vecL.lanewise(VectorOperators.ROR, i);\n+        vecL = vecL.lanewise(VectorOperators.ROR, i);\n+        vecL.lanewise(VectorOperators.ROR, i).intoArray(resL, j);\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/RotateBenchmark.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}