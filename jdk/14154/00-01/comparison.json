{"files":[{"patch":"@@ -305,5 +305,16 @@\n-  \/\/ to demote them to strong roots that the GC does *not* trace from. Conceptually,\n-  \/\/ we are retiring a normal strong root, and creating a strong non-root handle, which\n-  \/\/ happens to reuse the same address as the normal strong root had.\n-  \/\/ The way we would retire a strong root, is by clearing it. Then its address can be\n-  \/\/ reused for a new handle, that isn't a normal strong root. We do that dance below.\n+  \/\/ to demote them to strong native oops that the GC does *not* trace from. Conceptually,\n+  \/\/ we are retiring a rather normal strong root, and creating a strong non-root handle,\n+  \/\/ which happens to reuse the same address as the normal strong root had.\n+  \/\/ Unless we invoke the right barriers, the GC might not notice that a strong root\n+  \/\/ has been pulled from the system, and is left unprocessed by the GC. There can be\n+  \/\/ several consequences:\n+  \/\/ 1. A concurrently marking snapshot-at-the-beginning GC might assume that the contents\n+  \/\/    of all strong roots get processed by the GC in order to keep them alive. Without\n+  \/\/    barriers, some objects might not be kept alive.\n+  \/\/ 2. A concurrently relocating GC might assume that after moving an object, a subsequent\n+  \/\/    tracing from all roots can fix all the pointers in the system, which doesn't play\n+  \/\/    well with roots racingly being pulled.\n+  \/\/ 3. A concurrent GC using colored pointers, might assume that tracing the object graph\n+  \/\/    from roots results in all pointers getting some particular color, which also doesn't\n+  \/\/    play well with roots being pulled out from the system concurrently.\n+\n@@ -313,0 +324,8 @@\n+      \/\/ By loading the strong root with the access API, we can use the right barriers to\n+      \/\/ store the oop as a strong non-root handle, that happens to reuse the same memory\n+      \/\/ address as the strong root. The barriered store ensures that:\n+      \/\/ 1. The concurrent SATB marking properties are satisfied as the store will keep\n+      \/\/    the oop alive.\n+      \/\/ 2. The concurrent object movement properties are satisfied as we store the address\n+      \/\/    of the new location of the object, if any.\n+      \/\/ 3. The colors if any will be stored as the new good colors.\n@@ -314,3 +333,0 @@\n-      NativeAccess<>::oop_store(p, nullptr); \/\/ Clear the strong root\n-      \/\/ No-op free handle\n-      \/\/ No-op allocate new handle using the same address\n@@ -346,2 +362,2 @@\n-      \/\/ system when concurrent marking is running at the same time, without\n-      \/\/ clearing the oops with GC barriers.\n+      \/\/ system when concurrent GCs are running at the same time, without\n+      \/\/ invoking the right barriers.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"}]}