{"files":[{"patch":"@@ -303,0 +303,24 @@\n+void ClassLoaderData::demote_strong_roots() {\n+  \/\/ The oop handle area contains strong roots that the GC traces from. We are about\n+  \/\/ to demote them to strong roots that the GC does *not* trace from. Conceptually,\n+  \/\/ we are retiring a normal strong root, and creating a strong non-root handle, which\n+  \/\/ happens to reuse the same address as the normal strong root had.\n+  \/\/ The way we would retire a strong root, is by clearing it. Then its address can be\n+  \/\/ reused for a new handle, that isn't a normal strong root. We do that dance below.\n+  class TransitionRootsOopClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      oop obj = NativeAccess<>::oop_load(p); \/\/ Load the strong root\n+      NativeAccess<>::oop_store(p, nullptr); \/\/ Clear the strong root\n+      \/\/ No-op free handle\n+      \/\/ No-op allocate new handle using the same address\n+      NativeAccess<>::oop_store(p, obj); \/\/ Store the strong non-root\n+    }\n+\n+    virtual void do_oop(narrowOop* p) {\n+      ShouldNotReachHere();\n+    }\n+  } cl;\n+  oops_do(&cl, ClassLoaderData::_claim_none, false \/* clear_mod_oops *\/);\n+}\n+\n@@ -318,0 +342,8 @@\n+    if (_keep_alive == 1) {\n+      \/\/ When the keep_alive counter is 1, the oop handle area is a strong root,\n+      \/\/ acting as input to the GC tracing. Such strong roots are part of the\n+      \/\/ snapshot-at-the-beginning, and can not just be pulled out from the\n+      \/\/ system when concurrent marking is running at the same time, without\n+      \/\/ clearing the oops with GC barriers.\n+      demote_strong_roots();\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -197,0 +197,2 @@\n+  void demote_strong_roots();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}