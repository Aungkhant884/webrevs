{"files":[{"patch":"@@ -303,0 +303,40 @@\n+void ClassLoaderData::demote_strong_roots() {\n+  \/\/ The oop handle area contains strong roots that the GC traces from. We are about\n+  \/\/ to demote them to strong native oops that the GC does *not* trace from. Conceptually,\n+  \/\/ we are retiring a rather normal strong root, and creating a strong non-root handle,\n+  \/\/ which happens to reuse the same address as the normal strong root had.\n+  \/\/ Unless we invoke the right barriers, the GC might not notice that a strong root\n+  \/\/ has been pulled from the system, and is left unprocessed by the GC. There can be\n+  \/\/ several consequences:\n+  \/\/ 1. A concurrently marking snapshot-at-the-beginning GC might assume that the contents\n+  \/\/    of all strong roots get processed by the GC in order to keep them alive. Without\n+  \/\/    barriers, some objects might not be kept alive.\n+  \/\/ 2. A concurrently relocating GC might assume that after moving an object, a subsequent\n+  \/\/    tracing from all roots can fix all the pointers in the system, which doesn't play\n+  \/\/    well with roots racingly being pulled.\n+  \/\/ 3. A concurrent GC using colored pointers, might assume that tracing the object graph\n+  \/\/    from roots results in all pointers getting some particular color, which also doesn't\n+  \/\/    play well with roots being pulled out from the system concurrently.\n+\n+  class TransitionRootsOopClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      \/\/ By loading the strong root with the access API, we can use the right barriers to\n+      \/\/ store the oop as a strong non-root handle, that happens to reuse the same memory\n+      \/\/ address as the strong root. The barriered store ensures that:\n+      \/\/ 1. The concurrent SATB marking properties are satisfied as the store will keep\n+      \/\/    the oop alive.\n+      \/\/ 2. The concurrent object movement properties are satisfied as we store the address\n+      \/\/    of the new location of the object, if any.\n+      \/\/ 3. The colors if any will be stored as the new good colors.\n+      oop obj = NativeAccess<>::oop_load(p); \/\/ Load the strong root\n+      NativeAccess<>::oop_store(p, obj); \/\/ Store the strong non-root\n+    }\n+\n+    virtual void do_oop(narrowOop* p) {\n+      ShouldNotReachHere();\n+    }\n+  } cl;\n+  oops_do(&cl, ClassLoaderData::_claim_none, false \/* clear_mod_oops *\/);\n+}\n+\n@@ -318,0 +358,8 @@\n+    if (_keep_alive == 1) {\n+      \/\/ When the keep_alive counter is 1, the oop handle area is a strong root,\n+      \/\/ acting as input to the GC tracing. Such strong roots are part of the\n+      \/\/ snapshot-at-the-beginning, and can not just be pulled out from the\n+      \/\/ system when concurrent GCs are running at the same time, without\n+      \/\/ invoking the right barriers.\n+      demote_strong_roots();\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -197,0 +197,2 @@\n+  void demote_strong_roots();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}