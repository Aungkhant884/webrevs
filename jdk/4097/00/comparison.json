{"files":[{"patch":"@@ -450,3 +450,0 @@\n-   ifeq ($(call isTargetOs, macosx), true)\n-     HARFBUZZ_CFLAGS += -DHAVE_CORETEXT\n-   endif\n@@ -460,3 +457,0 @@\n-   ifeq ($(call isTargetOs, macosx), false)\n-     LIBFONTMANAGER_EXCLUDE_FILES += libharfbuzz\/hb-coretext.cc\n-   endif\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -214,0 +214,3 @@\n+        if (FontUtilities.isLogging()) {\n+            FontUtilities.logInfo(\"Cascading list for \" + this + \" :\");\n+        }\n@@ -215,0 +218,3 @@\n+            if (FontUtilities.isLogging()) {\n+                FontUtilities.logInfo(\"Fallback:\" + s);\n+            }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFont.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-    static WeakHashMap<Font2D, Boolean> aatInfo = new WeakHashMap<>();\n@@ -158,24 +157,0 @@\n-    private static boolean isAAT(Font2D font) {\n-       Boolean aatObj;\n-       synchronized (aatInfo) {\n-           aatObj = aatInfo.get(font);\n-       }\n-       if (aatObj != null) {\n-          return aatObj.booleanValue();\n-       }\n-       boolean aat = false;\n-       if (font instanceof TrueTypeFont) {\n-           TrueTypeFont ttf = (TrueTypeFont)font;\n-           aat =  ttf.getDirectoryEntry(TrueTypeFont.morxTag) != null ||\n-                  ttf.getDirectoryEntry(TrueTypeFont.mortTag) != null;\n-       } else if (font instanceof PhysicalFont) {\n-           PhysicalFont pf = (PhysicalFont)font;\n-           aat =  pf.getTableBytes(TrueTypeFont.morxTag) != null ||\n-                  pf.getTableBytes(TrueTypeFont.mortTag) != null;\n-       }\n-       synchronized (aatInfo) {\n-           aatInfo.put(font, Boolean.valueOf(aat));\n-       }\n-       return aat;\n-    }\n-\n@@ -195,1 +170,0 @@\n-        long pNativeFont = font.getPlatformNativeFontPtr(); \/\/ used on OSX\n@@ -198,2 +172,1 @@\n-            shape(font, strike, ptSize, mat, pNativeFont,\n-                    pFace, isAAT(font),\n+            shape(font, strike, ptSize, mat, pFace,\n@@ -209,1 +182,1 @@\n-              long pNativeFont, long pFace, boolean aat,\n+              long pFace,\n@@ -215,1 +188,0 @@\n-                                          boolean aat,\n@@ -230,1 +202,1 @@\n-                facePtr = createFace(font, isAAT(font),\n+                facePtr = createFace(font,\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunLayoutEngine.java","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-#ifdef MACOSX\n-#include \"hb-coretext.h\"\n-#endif\n@@ -204,3 +201,1 @@\n-                       jlong pNativeFont,\n-                       jfloatArray matrix,\n-                       jboolean aat) {\n+                       jfloatArray matrix) {\n@@ -216,2 +211,0 @@\n-    fi->nativeFont = pNativeFont;\n-    fi->aat = aat;\n@@ -222,1 +215,1 @@\n-    if (!aat && (getenv(\"HB_NODEVTX\") != NULL)) {\n+    if (getenv(\"HB_NODEVTX\") != NULL) {\n@@ -241,1 +234,0 @@\n-     jlong pNativeFont,\n@@ -243,1 +235,0 @@\n-     jboolean aat,\n@@ -271,2 +262,1 @@\n-         createJDKFontInfo(env, font2D, fontStrike, ptSize,\n-                           pNativeFont, matrix, aat);\n+         createJDKFontInfo(env, font2D, fontStrike, ptSize, matrix);\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/HBShaper.c","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-#ifdef MACOSX\n-#include \"hb-coretext.h\"\n-#endif\n@@ -366,1 +363,1 @@\n- * Signature: (Lsun\/font\/Font2D;ZJJ)J\n+ * Signature: (Lsun\/font\/Font2D;JJ)J\n@@ -371,1 +368,0 @@\n-                         jboolean aat,\n@@ -373,6 +369,0 @@\n-#ifdef MACOSX\n-    if (aat && platformFontPtr) {\n-        hb_face_t *face = hb_coretext_face_create((CGFontRef)platformFontPtr);\n-        return ptr_to_jlong(face);\n-    }\n-#endif\n@@ -442,5 +432,1 @@\n-#ifdef MACOSX\n-     if (jdkFontInfo->aat && jdkFontInfo->nativeFont) {\n-         return _hb_jdk_ct_font_create(hbFace, jdkFontInfo);\n-     }\n-#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/hb-jdk-font.cc","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-    jlong nativeFont;\n@@ -47,1 +46,0 @@\n-    jboolean aat;\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/hb-jdk.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1196 +0,0 @@\n-\/*\n- * Copyright © 2012,2013  Mozilla Foundation.\n- * Copyright © 2012,2013  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Mozilla Author(s): Jonathan Kew\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifdef HAVE_CORETEXT\n-\n-#include \"hb-shaper-impl.hh\"\n-\n-#include \"hb-coretext.h\"\n-#include \"hb-aat-layout.hh\"\n-\n-\n-\/**\n- * SECTION:hb-coretext\n- * @title: hb-coretext\n- * @short_description: CoreText integration\n- * @include: hb-coretext.h\n- *\n- * Functions for using HarfBuzz with the CoreText fonts.\n- **\/\n-\n-\/* https:\/\/developer.apple.com\/documentation\/coretext\/1508745-ctfontcreatewithgraphicsfont *\/\n-#define HB_CORETEXT_DEFAULT_FONT_SIZE 12.f\n-\n-static void\n-release_table_data (void *user_data)\n-{\n-  CFDataRef cf_data = reinterpret_cast<CFDataRef> (user_data);\n-  CFRelease(cf_data);\n-}\n-\n-static hb_blob_t *\n-_hb_cg_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)\n-{\n-  CGFontRef cg_font = reinterpret_cast<CGFontRef> (user_data);\n-  CFDataRef cf_data = CGFontCopyTableForTag (cg_font, tag);\n-  if (unlikely (!cf_data))\n-    return nullptr;\n-\n-  const char *data = reinterpret_cast<const char*> (CFDataGetBytePtr (cf_data));\n-  const size_t length = CFDataGetLength (cf_data);\n-  if (!data || !length)\n-  {\n-    CFRelease (cf_data);\n-    return nullptr;\n-  }\n-\n-  return hb_blob_create (data, length, HB_MEMORY_MODE_READONLY,\n-                         reinterpret_cast<void *> (const_cast<__CFData *> (cf_data)),\n-                         release_table_data);\n-}\n-\n-static void\n-_hb_cg_font_release (void *data)\n-{\n-  CGFontRelease ((CGFontRef) data);\n-}\n-\n-\n-static CTFontDescriptorRef\n-get_last_resort_font_desc ()\n-{\n-  \/\/ TODO Handle allocation failures?\n-  CTFontDescriptorRef last_resort = CTFontDescriptorCreateWithNameAndSize (CFSTR(\"LastResort\"), 0);\n-  CFArrayRef cascade_list = CFArrayCreate (kCFAllocatorDefault,\n-                                           (const void **) &last_resort,\n-                                           1,\n-                                           &kCFTypeArrayCallBacks);\n-  CFRelease (last_resort);\n-  CFDictionaryRef attributes = CFDictionaryCreate (kCFAllocatorDefault,\n-                                                   (const void **) &kCTFontCascadeListAttribute,\n-                                                   (const void **) &cascade_list,\n-                                                   1,\n-                                                   &kCFTypeDictionaryKeyCallBacks,\n-                                                   &kCFTypeDictionaryValueCallBacks);\n-  CFRelease (cascade_list);\n-\n-  CTFontDescriptorRef font_desc = CTFontDescriptorCreateWithAttributes (attributes);\n-  CFRelease (attributes);\n-  return font_desc;\n-}\n-\n-static void\n-release_data (void *info, const void *data, size_t size)\n-{\n-  assert (hb_blob_get_length ((hb_blob_t *) info) == size &&\n-          hb_blob_get_data ((hb_blob_t *) info, nullptr) == data);\n-\n-  hb_blob_destroy ((hb_blob_t *) info);\n-}\n-\n-static CGFontRef\n-create_cg_font (hb_face_t *face)\n-{\n-  CGFontRef cg_font = nullptr;\n-  if (face->destroy == _hb_cg_font_release)\n-  {\n-    cg_font = CGFontRetain ((CGFontRef) face->user_data);\n-  }\n-  else\n-  {\n-    hb_blob_t *blob = hb_face_reference_blob (face);\n-    unsigned int blob_length;\n-    const char *blob_data = hb_blob_get_data (blob, &blob_length);\n-    if (unlikely (!blob_length))\n-      DEBUG_MSG (CORETEXT, face, \"Face has empty blob\");\n-\n-    CGDataProviderRef provider = CGDataProviderCreateWithData (blob, blob_data, blob_length, &release_data);\n-    if (likely (provider))\n-    {\n-      cg_font = CGFontCreateWithDataProvider (provider);\n-      if (unlikely (!cg_font))\n-        DEBUG_MSG (CORETEXT, face, \"Face CGFontCreateWithDataProvider() failed\");\n-      CGDataProviderRelease (provider);\n-    }\n-  }\n-  return cg_font;\n-}\n-\n-static CTFontRef\n-create_ct_font (CGFontRef cg_font, CGFloat font_size)\n-{\n-  CTFontRef ct_font = nullptr;\n-\n-  \/* CoreText does not enable trak table usage \/ tracking when creating a CTFont\n-   * using CTFontCreateWithGraphicsFont. The only way of enabling tracking seems\n-   * to be through the CTFontCreateUIFontForLanguage call. *\/\n-  CFStringRef cg_postscript_name = CGFontCopyPostScriptName (cg_font);\n-  if (CFStringHasPrefix (cg_postscript_name, CFSTR (\".SFNSText\")) ||\n-      CFStringHasPrefix (cg_postscript_name, CFSTR (\".SFNSDisplay\")))\n-  {\n-#if !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && MAC_OS_X_VERSION_MIN_REQUIRED < 1080\n-# define kCTFontUIFontSystem kCTFontSystemFontType\n-# define kCTFontUIFontEmphasizedSystem kCTFontEmphasizedSystemFontType\n-#endif\n-    CTFontUIFontType font_type = kCTFontUIFontSystem;\n-    if (CFStringHasSuffix (cg_postscript_name, CFSTR (\"-Bold\")))\n-      font_type = kCTFontUIFontEmphasizedSystem;\n-\n-    ct_font = CTFontCreateUIFontForLanguage (font_type, font_size, nullptr);\n-    CFStringRef ct_result_name = CTFontCopyPostScriptName(ct_font);\n-    if (CFStringCompare (ct_result_name, cg_postscript_name, 0) != kCFCompareEqualTo)\n-    {\n-      CFRelease(ct_font);\n-      ct_font = nullptr;\n-    }\n-    CFRelease (ct_result_name);\n-  }\n-  CFRelease (cg_postscript_name);\n-\n-  if (!ct_font)\n-    ct_font = CTFontCreateWithGraphicsFont (cg_font, font_size, nullptr, nullptr);\n-\n-  if (unlikely (!ct_font)) {\n-    DEBUG_MSG (CORETEXT, cg_font, \"Font CTFontCreateWithGraphicsFont() failed\");\n-    return nullptr;\n-  }\n-\n-  \/* crbug.com\/576941 and crbug.com\/625902 and the investigation in the latter\n-   * bug indicate that the cascade list reconfiguration occasionally causes\n-   * crashes in CoreText on OS X 10.9, thus let's skip this step on older\n-   * operating system versions. Except for the emoji font, where _not_\n-   * reconfiguring the cascade list causes CoreText crashes. For details, see\n-   * crbug.com\/549610 *\/\n-  \/\/ 0x00070000 stands for \"kCTVersionNumber10_10\", see CoreText.h\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n-  if (&CTGetCoreTextVersion != nullptr && CTGetCoreTextVersion() < 0x00070000) {\n-#pragma GCC diagnostic pop\n-    CFStringRef fontName = CTFontCopyPostScriptName (ct_font);\n-    bool isEmojiFont = CFStringCompare (fontName, CFSTR(\"AppleColorEmoji\"), 0) == kCFCompareEqualTo;\n-    CFRelease (fontName);\n-    if (!isEmojiFont)\n-      return ct_font;\n-  }\n-\n-  CFURLRef original_url = nullptr;\n-#if !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && MAC_OS_X_VERSION_MIN_REQUIRED < 1060\n-  ATSFontRef atsFont;\n-  FSRef fsref;\n-  OSStatus status;\n-  atsFont = CTFontGetPlatformFont (ct_font, NULL);\n-  status = ATSFontGetFileReference (atsFont, &fsref);\n-  if (status == noErr)\n-    original_url = CFURLCreateFromFSRef (NULL, &fsref);\n-#else\n-  original_url = (CFURLRef) CTFontCopyAttribute (ct_font, kCTFontURLAttribute);\n-#endif\n-\n-  \/* Create font copy with cascade list that has LastResort first; this speeds up CoreText\n-   * font fallback which we don't need anyway. *\/\n-  {\n-    CTFontDescriptorRef last_resort_font_desc = get_last_resort_font_desc ();\n-    CTFontRef new_ct_font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, last_resort_font_desc);\n-    CFRelease (last_resort_font_desc);\n-    if (new_ct_font)\n-    {\n-      \/* The CTFontCreateCopyWithAttributes call fails to stay on the same font\n-       * when reconfiguring the cascade list and may switch to a different font\n-       * when there are fonts that go by the same name, since the descriptor is\n-       * just name and size.\n-       *\n-       * Avoid reconfiguring the cascade lists if the new font is outside the\n-       * system locations that we cannot access from the sandboxed renderer\n-       * process in Blink. This can be detected by the new file URL location\n-       * that the newly found font points to. *\/\n-      CFURLRef new_url = nullptr;\n-#if !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && MAC_OS_X_VERSION_MIN_REQUIRED < 1060\n-      atsFont = CTFontGetPlatformFont (new_ct_font, NULL);\n-      status = ATSFontGetFileReference (atsFont, &fsref);\n-      if (status == noErr)\n-        new_url = CFURLCreateFromFSRef (NULL, &fsref);\n-#else\n-      new_url = (CFURLRef) CTFontCopyAttribute (new_ct_font, kCTFontURLAttribute);\n-#endif\n-      \/\/ Keep reconfigured font if URL cannot be retrieved (seems to be the case\n-      \/\/ on Mac OS 10.12 Sierra), speculative fix for crbug.com\/625606\n-      if (!original_url || !new_url || CFEqual (original_url, new_url)) {\n-        CFRelease (ct_font);\n-        ct_font = new_ct_font;\n-      } else {\n-        CFRelease (new_ct_font);\n-        DEBUG_MSG (CORETEXT, ct_font, \"Discarding reconfigured CTFont, location changed.\");\n-      }\n-      if (new_url)\n-        CFRelease (new_url);\n-    }\n-    else\n-      DEBUG_MSG (CORETEXT, ct_font, \"Font copy with empty cascade list failed\");\n-  }\n-\n-  if (original_url)\n-    CFRelease (original_url);\n-  return ct_font;\n-}\n-\n-hb_coretext_face_data_t *\n-_hb_coretext_shaper_face_data_create (hb_face_t *face)\n-{\n-  CGFontRef cg_font = create_cg_font (face);\n-\n-  if (unlikely (!cg_font))\n-  {\n-    DEBUG_MSG (CORETEXT, face, \"CGFont creation failed..\");\n-    return nullptr;\n-  }\n-\n-  return (hb_coretext_face_data_t *) cg_font;\n-}\n-\n-void\n-_hb_coretext_shaper_face_data_destroy (hb_coretext_face_data_t *data)\n-{\n-  CFRelease ((CGFontRef) data);\n-}\n-\n-\/**\n- * hb_coretext_face_create:\n- * @cg_font: The CGFontRef to work upon\n- *\n- * Creates an #hb_face_t face object from the specified\n- * CGFontRef.\n- *\n- * Return value: the new #hb_face_t face object\n- *\n- * Since: 0.9.10\n- *\/\n-hb_face_t *\n-hb_coretext_face_create (CGFontRef cg_font)\n-{\n-  return hb_face_create_for_tables (_hb_cg_reference_table, CGFontRetain (cg_font), _hb_cg_font_release);\n-}\n-\n-\/**\n- * hb_coretext_face_get_cg_font:\n- * @face: The #hb_face_t to work upon\n- *\n- * Fetches the CGFontRef associated with an #hb_face_t\n- * face object\n- *\n- * Return value: the CGFontRef found\n- *\n- * Since: 0.9.10\n- *\/\n-CGFontRef\n-hb_coretext_face_get_cg_font (hb_face_t *face)\n-{\n-  return (CGFontRef) (const void *) face->data.coretext;\n-}\n-\n-\n-hb_coretext_font_data_t *\n-_hb_coretext_shaper_font_data_create (hb_font_t *font)\n-{\n-  hb_face_t *face = font->face;\n-  const hb_coretext_face_data_t *face_data = face->data.coretext;\n-  if (unlikely (!face_data)) return nullptr;\n-  CGFontRef cg_font = (CGFontRef) (const void *) face->data.coretext;\n-\n-  CGFloat font_size = (CGFloat) (font->ptem <= 0.f ? HB_CORETEXT_DEFAULT_FONT_SIZE : font->ptem);\n-  CTFontRef ct_font = create_ct_font (cg_font, font_size);\n-\n-  if (unlikely (!ct_font))\n-  {\n-    DEBUG_MSG (CORETEXT, font, \"CGFont creation failed..\");\n-    return nullptr;\n-  }\n-\n-  return (hb_coretext_font_data_t *) ct_font;\n-}\n-\n-void\n-_hb_coretext_shaper_font_data_destroy (hb_coretext_font_data_t *data)\n-{\n-  CFRelease ((CTFontRef) data);\n-}\n-\n-static const hb_coretext_font_data_t *\n-hb_coretext_font_data_sync (hb_font_t *font)\n-{\n-retry:\n-  const hb_coretext_font_data_t *data = font->data.coretext;\n-  if (unlikely (!data)) return nullptr;\n-\n-  if (fabs (CTFontGetSize ((CTFontRef) data) - (CGFloat) font->ptem) > (CGFloat) .5)\n-  {\n-    \/* XXX-MT-bug\n-     * Note that evaluating condition above can be dangerous if another thread\n-     * got here first and destructed data.  That's, as always, bad use pattern.\n-     * If you modify the font (change font size), other threads must not be\n-     * using it at the same time.  However, since this check is delayed to\n-     * when one actually tries to shape something, this is a XXX race condition\n-     * (and the only one we have that I know of) right now.  Ie. you modify the\n-     * font size in one thread, then (supposedly safely) try to use it from two\n-     * or more threads and BOOM!  I'm not sure how to fix this.  We want RCU.\n-     *\/\n-\n-    \/* Drop and recreate. *\/\n-    \/* If someone dropped it in the mean time, throw it away and don't touch it.\n-     * Otherwise, destruct it. *\/\n-    if (likely (font->data.coretext.cmpexch (const_cast<hb_coretext_font_data_t *> (data), nullptr)))\n-      _hb_coretext_shaper_font_data_destroy (const_cast<hb_coretext_font_data_t *> (data));\n-    else\n-      goto retry;\n-  }\n-  return font->data.coretext;\n-}\n-\n-\/**\n- * hb_coretext_font_create:\n- * @ct_font: The CTFontRef to work upon\n- *\n- * Creates an #hb_font_t font object from the specified\n- * CTFontRef.\n- *\n- * Return value: the new #hb_font_t font object\n- *\n- * Since: 1.7.2\n- **\/\n-hb_font_t *\n-hb_coretext_font_create (CTFontRef ct_font)\n-{\n-  CGFontRef cg_font = CTFontCopyGraphicsFont (ct_font, nullptr);\n-  hb_face_t *face = hb_coretext_face_create (cg_font);\n-  CFRelease (cg_font);\n-  hb_font_t *font = hb_font_create (face);\n-  hb_face_destroy (face);\n-\n-  if (unlikely (hb_object_is_immutable (font)))\n-    return font;\n-\n-  hb_font_set_ptem (font, CTFontGetSize (ct_font));\n-\n-  \/* Let there be dragons here... *\/\n-  font->data.coretext.cmpexch (nullptr, (hb_coretext_font_data_t *) CFRetain (ct_font));\n-\n-  return font;\n-}\n-\n-\/**\n- * hb_coretext_font_get_ct_font:\n- * @font: #hb_font_t to work upon\n- *\n- * Fetches the CTFontRef associated with the specified\n- * #hb_font_t font object.\n- *\n- * Return value: the CTFontRef found\n- *\n- * Since: 0.9.10\n- *\/\n-CTFontRef\n-hb_coretext_font_get_ct_font (hb_font_t *font)\n-{\n-  const hb_coretext_font_data_t *data = hb_coretext_font_data_sync (font);\n-  return data ? (CTFontRef) data : nullptr;\n-}\n-\n-\n-\/*\n- * shaper\n- *\/\n-\n-struct feature_record_t {\n-  unsigned int feature;\n-  unsigned int setting;\n-};\n-\n-struct active_feature_t {\n-  feature_record_t rec;\n-  unsigned int order;\n-\n-  HB_INTERNAL static int cmp (const void *pa, const void *pb) {\n-    const active_feature_t *a = (const active_feature_t *) pa;\n-    const active_feature_t *b = (const active_feature_t *) pb;\n-    return a->rec.feature < b->rec.feature ? -1 : a->rec.feature > b->rec.feature ? 1 :\n-           a->order < b->order ? -1 : a->order > b->order ? 1 :\n-           a->rec.setting < b->rec.setting ? -1 : a->rec.setting > b->rec.setting ? 1 :\n-           0;\n-  }\n-  bool operator== (const active_feature_t *f) {\n-    return cmp (this, f) == 0;\n-  }\n-};\n-\n-struct feature_event_t {\n-  unsigned int index;\n-  bool start;\n-  active_feature_t feature;\n-\n-  HB_INTERNAL static int cmp (const void *pa, const void *pb) {\n-    const feature_event_t *a = (const feature_event_t *) pa;\n-    const feature_event_t *b = (const feature_event_t *) pb;\n-    return a->index < b->index ? -1 : a->index > b->index ? 1 :\n-           a->start < b->start ? -1 : a->start > b->start ? 1 :\n-           active_feature_t::cmp (&a->feature, &b->feature);\n-  }\n-};\n-\n-struct range_record_t {\n-  CTFontRef font;\n-  unsigned int index_first; \/* == start *\/\n-  unsigned int index_last;  \/* == end - 1 *\/\n-};\n-\n-\n-hb_bool_t\n-_hb_coretext_shape (hb_shape_plan_t    *shape_plan,\n-                    hb_font_t          *font,\n-                    hb_buffer_t        *buffer,\n-                    const hb_feature_t *features,\n-                    unsigned int        num_features)\n-{\n-  hb_face_t *face = font->face;\n-  CGFontRef cg_font = (CGFontRef) (const void *) face->data.coretext;\n-  CTFontRef ct_font = (CTFontRef) hb_coretext_font_data_sync (font);\n-\n-  CGFloat ct_font_size = CTFontGetSize (ct_font);\n-  CGFloat x_mult = (CGFloat) font->x_scale \/ ct_font_size;\n-  CGFloat y_mult = (CGFloat) font->y_scale \/ ct_font_size;\n-\n-  \/* Attach marks to their bases, to match the 'ot' shaper.\n-   * Adapted from a very old version of hb-ot-shape:hb_form_clusters().\n-   * Note that this only makes us be closer to the 'ot' shaper,\n-   * but by no means the same.  For example, if there's\n-   * B1 M1 B2 M2, and B1-B2 form a ligature, M2's cluster will\n-   * continue pointing to B2 even though B2 was merged into B1's\n-   * cluster... *\/\n-  if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n-  {\n-    hb_unicode_funcs_t *unicode = buffer->unicode;\n-    unsigned int count = buffer->len;\n-    hb_glyph_info_t *info = buffer->info;\n-    for (unsigned int i = 1; i < count; i++)\n-      if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (unicode->general_category (info[i].codepoint)))\n-        buffer->merge_clusters (i - 1, i + 1);\n-  }\n-\n-  hb_vector_t<feature_record_t> feature_records;\n-  hb_vector_t<range_record_t> range_records;\n-\n-  \/*\n-   * Set up features.\n-   * (copied + modified from code from hb-uniscribe.cc)\n-   *\/\n-  if (num_features)\n-  {\n-    \/* Sort features by start\/end events. *\/\n-    hb_vector_t<feature_event_t> feature_events;\n-    for (unsigned int i = 0; i < num_features; i++)\n-    {\n-      active_feature_t feature;\n-\n-#if MAC_OS_X_VERSION_MIN_REQUIRED < 101000\n-      const hb_aat_feature_mapping_t * mapping = hb_aat_layout_find_feature_mapping (features[i].tag);\n-      if (!mapping)\n-        continue;\n-\n-      feature.rec.feature = mapping->aatFeatureType;\n-      feature.rec.setting = features[i].value ? mapping->selectorToEnable : mapping->selectorToDisable;\n-#else\n-      feature.rec.feature = features[i].tag;\n-      feature.rec.setting = features[i].value;\n-#endif\n-      feature.order = i;\n-\n-      feature_event_t *event;\n-\n-      event = feature_events.push ();\n-      event->index = features[i].start;\n-      event->start = true;\n-      event->feature = feature;\n-\n-      event = feature_events.push ();\n-      event->index = features[i].end;\n-      event->start = false;\n-      event->feature = feature;\n-    }\n-    feature_events.qsort ();\n-    \/* Add a strategic final event. *\/\n-    {\n-      active_feature_t feature;\n-      feature.rec.feature = HB_TAG_NONE;\n-      feature.rec.setting = 0;\n-      feature.order = num_features + 1;\n-\n-      feature_event_t *event = feature_events.push ();\n-      event->index = 0; \/* This value does magic. *\/\n-      event->start = false;\n-      event->feature = feature;\n-    }\n-\n-    \/* Scan events and save features for each range. *\/\n-    hb_vector_t<active_feature_t> active_features;\n-    unsigned int last_index = 0;\n-    for (unsigned int i = 0; i < feature_events.length; i++)\n-    {\n-      feature_event_t *event = &feature_events[i];\n-\n-      if (event->index != last_index)\n-      {\n-        \/* Save a snapshot of active features and the range. *\/\n-        range_record_t *range = range_records.push ();\n-\n-        if (active_features.length)\n-        {\n-          CFMutableArrayRef features_array = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);\n-\n-          \/* TODO sort and resolve conflicting features? *\/\n-          \/* active_features.qsort (); *\/\n-          for (unsigned int j = 0; j < active_features.length; j++)\n-          {\n-#if MAC_OS_X_VERSION_MIN_REQUIRED < 101000\n-            CFStringRef keys[] = {\n-              kCTFontFeatureTypeIdentifierKey,\n-              kCTFontFeatureSelectorIdentifierKey\n-            };\n-            CFNumberRef values[] = {\n-              CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &active_features[j].rec.feature),\n-              CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &active_features[j].rec.setting)\n-            };\n-#else\n-            char tag[5] = {HB_UNTAG (active_features[j].rec.feature)};\n-            CFTypeRef keys[] = {\n-              kCTFontOpenTypeFeatureTag,\n-              kCTFontOpenTypeFeatureValue\n-            };\n-            CFTypeRef values[] = {\n-              CFStringCreateWithCString (kCFAllocatorDefault, tag, kCFStringEncodingASCII),\n-              CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &active_features[j].rec.setting)\n-            };\n-#endif\n-            static_assert ((ARRAY_LENGTH_CONST (keys) == ARRAY_LENGTH_CONST (values)), \"\");\n-            CFDictionaryRef dict = CFDictionaryCreate (kCFAllocatorDefault,\n-                                                       (const void **) keys,\n-                                                       (const void **) values,\n-                                                       ARRAY_LENGTH (keys),\n-                                                       &kCFTypeDictionaryKeyCallBacks,\n-                                                       &kCFTypeDictionaryValueCallBacks);\n-            for (unsigned int i = 0; i < ARRAY_LENGTH (values); i++)\n-              CFRelease (values[i]);\n-\n-            CFArrayAppendValue (features_array, dict);\n-            CFRelease (dict);\n-\n-          }\n-\n-          CFDictionaryRef attributes = CFDictionaryCreate (kCFAllocatorDefault,\n-                                                           (const void **) &kCTFontFeatureSettingsAttribute,\n-                                                           (const void **) &features_array,\n-                                                           1,\n-                                                           &kCFTypeDictionaryKeyCallBacks,\n-                                                           &kCFTypeDictionaryValueCallBacks);\n-          CFRelease (features_array);\n-\n-          CTFontDescriptorRef font_desc = CTFontDescriptorCreateWithAttributes (attributes);\n-          CFRelease (attributes);\n-\n-          range->font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, font_desc);\n-          CFRelease (font_desc);\n-        }\n-        else\n-        {\n-          range->font = nullptr;\n-        }\n-\n-        range->index_first = last_index;\n-        range->index_last  = event->index - 1;\n-\n-        last_index = event->index;\n-      }\n-\n-      if (event->start)\n-      {\n-        active_features.push (event->feature);\n-      } else {\n-        active_feature_t *feature = active_features.find (&event->feature);\n-        if (feature)\n-          active_features.remove (feature - active_features.arrayZ);\n-      }\n-    }\n-  }\n-\n-  unsigned int scratch_size;\n-  hb_buffer_t::scratch_buffer_t *scratch = buffer->get_scratch_buffer (&scratch_size);\n-\n-#define ALLOCATE_ARRAY(Type, name, len, on_no_room) \\\n-  Type *name = (Type *) scratch; \\\n-  do { \\\n-    unsigned int _consumed = DIV_CEIL ((len) * sizeof (Type), sizeof (*scratch)); \\\n-    if (unlikely (_consumed > scratch_size)) \\\n-    { \\\n-      on_no_room; \\\n-      assert (0); \\\n-    } \\\n-    scratch += _consumed; \\\n-    scratch_size -= _consumed; \\\n-  } while (0)\n-\n-  ALLOCATE_ARRAY (UniChar, pchars, buffer->len * 2, ((void)nullptr) \/*nothing*\/);\n-  unsigned int chars_len = 0;\n-  for (unsigned int i = 0; i < buffer->len; i++) {\n-    hb_codepoint_t c = buffer->info[i].codepoint;\n-    if (likely (c <= 0xFFFFu))\n-      pchars[chars_len++] = c;\n-    else if (unlikely (c > 0x10FFFFu))\n-      pchars[chars_len++] = 0xFFFDu;\n-    else {\n-      pchars[chars_len++] = 0xD800u + ((c - 0x10000u) >> 10);\n-      pchars[chars_len++] = 0xDC00u + ((c - 0x10000u) & ((1u << 10) - 1));\n-    }\n-  }\n-\n-  ALLOCATE_ARRAY (unsigned int, log_clusters, chars_len, ((void)nullptr) \/*nothing*\/);\n-  chars_len = 0;\n-  for (unsigned int i = 0; i < buffer->len; i++)\n-  {\n-    hb_codepoint_t c = buffer->info[i].codepoint;\n-    unsigned int cluster = buffer->info[i].cluster;\n-    log_clusters[chars_len++] = cluster;\n-    if (hb_in_range (c, 0x10000u, 0x10FFFFu))\n-      log_clusters[chars_len++] = cluster; \/* Surrogates. *\/\n-  }\n-\n-#define FAIL(...) \\\n-  HB_STMT_START { \\\n-    DEBUG_MSG (CORETEXT, nullptr, __VA_ARGS__); \\\n-    ret = false; \\\n-    goto fail; \\\n-  } HB_STMT_END\n-\n-  bool ret = true;\n-  CFStringRef string_ref = nullptr;\n-  CTLineRef line = nullptr;\n-\n-  if (false)\n-  {\n-resize_and_retry:\n-    DEBUG_MSG (CORETEXT, buffer, \"Buffer resize\");\n-    \/* string_ref uses the scratch-buffer for backing store, and line references\n-     * string_ref (via attr_string).  We must release those before resizing buffer. *\/\n-    assert (string_ref);\n-    assert (line);\n-    CFRelease (string_ref);\n-    CFRelease (line);\n-    string_ref = nullptr;\n-    line = nullptr;\n-\n-    \/* Get previous start-of-scratch-area, that we use later for readjusting\n-     * our existing scratch arrays. *\/\n-    unsigned int old_scratch_used;\n-    hb_buffer_t::scratch_buffer_t *old_scratch;\n-    old_scratch = buffer->get_scratch_buffer (&old_scratch_used);\n-    old_scratch_used = scratch - old_scratch;\n-\n-    if (unlikely (!buffer->ensure (buffer->allocated * 2)))\n-      FAIL (\"Buffer resize failed\");\n-\n-    \/* Adjust scratch, pchars, and log_cluster arrays.  This is ugly, but really the\n-     * cleanest way to do without completely restructuring the rest of this shaper. *\/\n-    scratch = buffer->get_scratch_buffer (&scratch_size);\n-    pchars = reinterpret_cast<UniChar *> (((char *) scratch + ((char *) pchars - (char *) old_scratch)));\n-    log_clusters = reinterpret_cast<unsigned int *> (((char *) scratch + ((char *) log_clusters - (char *) old_scratch)));\n-    scratch += old_scratch_used;\n-    scratch_size -= old_scratch_used;\n-  }\n-  {\n-    string_ref = CFStringCreateWithCharactersNoCopy (nullptr,\n-                                                     pchars, chars_len,\n-                                                     kCFAllocatorNull);\n-    if (unlikely (!string_ref))\n-      FAIL (\"CFStringCreateWithCharactersNoCopy failed\");\n-\n-    \/* Create an attributed string, populate it, and create a line from it, then release attributed string. *\/\n-    {\n-      CFMutableAttributedStringRef attr_string = CFAttributedStringCreateMutable (kCFAllocatorDefault,\n-                                                                                  chars_len);\n-      if (unlikely (!attr_string))\n-        FAIL (\"CFAttributedStringCreateMutable failed\");\n-      CFAttributedStringReplaceString (attr_string, CFRangeMake (0, 0), string_ref);\n-      if (HB_DIRECTION_IS_VERTICAL (buffer->props.direction))\n-      {\n-        CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),\n-                                        kCTVerticalFormsAttributeName, kCFBooleanTrue);\n-      }\n-\n-      if (buffer->props.language)\n-      {\n-\/* What's the iOS equivalent of this check?\n- * The symbols was introduced in iOS 7.0.\n- * At any rate, our fallback is safe and works fine. *\/\n-#if !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && MAC_OS_X_VERSION_MIN_REQUIRED < 1090\n-#  define kCTLanguageAttributeName CFSTR (\"NSLanguage\")\n-#endif\n-        CFStringRef lang = CFStringCreateWithCStringNoCopy (kCFAllocatorDefault,\n-                                                            hb_language_to_string (buffer->props.language),\n-                                                            kCFStringEncodingUTF8,\n-                                                            kCFAllocatorNull);\n-        if (unlikely (!lang))\n-        {\n-          CFRelease (attr_string);\n-          FAIL (\"CFStringCreateWithCStringNoCopy failed\");\n-        }\n-        CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),\n-                                        kCTLanguageAttributeName, lang);\n-        CFRelease (lang);\n-      }\n-      CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),\n-                                      kCTFontAttributeName, ct_font);\n-\n-      if (num_features && range_records.length)\n-      {\n-        unsigned int start = 0;\n-        range_record_t *last_range = &range_records[0];\n-        for (unsigned int k = 0; k < chars_len; k++)\n-        {\n-          range_record_t *range = last_range;\n-          while (log_clusters[k] < range->index_first)\n-            range--;\n-          while (log_clusters[k] > range->index_last)\n-            range++;\n-          if (range != last_range)\n-          {\n-            if (last_range->font)\n-              CFAttributedStringSetAttribute (attr_string, CFRangeMake (start, k - start),\n-                                              kCTFontAttributeName, last_range->font);\n-\n-            start = k;\n-          }\n-\n-          last_range = range;\n-        }\n-        if (start != chars_len && last_range->font)\n-          CFAttributedStringSetAttribute (attr_string, CFRangeMake (start, chars_len - start),\n-                                          kCTFontAttributeName, last_range->font);\n-      }\n-      \/* Enable\/disable kern if requested.\n-       *\n-       * Note: once kern is disabled, reenabling it doesn't currently seem to work in CoreText.\n-       *\/\n-      if (num_features)\n-      {\n-        unsigned int zeroint = 0;\n-        CFNumberRef zero = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &zeroint);\n-        for (unsigned int i = 0; i < num_features; i++)\n-        {\n-          const hb_feature_t &feature = features[i];\n-          if (feature.tag == HB_TAG('k','e','r','n') &&\n-              feature.start < chars_len && feature.start < feature.end)\n-          {\n-            CFRange feature_range = CFRangeMake (feature.start,\n-                                                 hb_min (feature.end, chars_len) - feature.start);\n-            if (feature.value)\n-              CFAttributedStringRemoveAttribute (attr_string, feature_range, kCTKernAttributeName);\n-            else\n-              CFAttributedStringSetAttribute (attr_string, feature_range, kCTKernAttributeName, zero);\n-          }\n-        }\n-        CFRelease (zero);\n-      }\n-\n-      int level = HB_DIRECTION_IS_FORWARD (buffer->props.direction) ? 0 : 1;\n-      CFNumberRef level_number = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &level);\n-#if !(defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) && MAC_OS_X_VERSION_MIN_REQUIRED < 1060\n-      extern const CFStringRef kCTTypesetterOptionForcedEmbeddingLevel;\n-#endif\n-      CFDictionaryRef options = CFDictionaryCreate (kCFAllocatorDefault,\n-                                                    (const void **) &kCTTypesetterOptionForcedEmbeddingLevel,\n-                                                    (const void **) &level_number,\n-                                                    1,\n-                                                    &kCFTypeDictionaryKeyCallBacks,\n-                                                    &kCFTypeDictionaryValueCallBacks);\n-      CFRelease (level_number);\n-      if (unlikely (!options))\n-      {\n-        CFRelease (attr_string);\n-        FAIL (\"CFDictionaryCreate failed\");\n-      }\n-\n-      CTTypesetterRef typesetter = CTTypesetterCreateWithAttributedStringAndOptions (attr_string, options);\n-      CFRelease (options);\n-      CFRelease (attr_string);\n-      if (unlikely (!typesetter))\n-        FAIL (\"CTTypesetterCreateWithAttributedStringAndOptions failed\");\n-\n-      line = CTTypesetterCreateLine (typesetter, CFRangeMake(0, 0));\n-      CFRelease (typesetter);\n-      if (unlikely (!line))\n-        FAIL (\"CTTypesetterCreateLine failed\");\n-    }\n-\n-    CFArrayRef glyph_runs = CTLineGetGlyphRuns (line);\n-    unsigned int num_runs = CFArrayGetCount (glyph_runs);\n-    DEBUG_MSG (CORETEXT, nullptr, \"Num runs: %d\", num_runs);\n-\n-    buffer->len = 0;\n-    uint32_t status_and = ~0, status_or = 0;\n-    CGFloat advances_so_far = 0;\n-    \/* For right-to-left runs, CoreText returns the glyphs positioned such that\n-     * any trailing whitespace is to the left of (0,0).  Adjust coordinate system\n-     * to fix for that.  Test with any RTL string with trailing spaces.\n-     * https:\/\/crbug.com\/469028\n-     *\/\n-    if (HB_DIRECTION_IS_BACKWARD (buffer->props.direction))\n-    {\n-      advances_so_far -= CTLineGetTrailingWhitespaceWidth (line);\n-      if (HB_DIRECTION_IS_VERTICAL (buffer->props.direction))\n-          advances_so_far = -advances_so_far;\n-    }\n-\n-    const CFRange range_all = CFRangeMake (0, 0);\n-\n-    for (unsigned int i = 0; i < num_runs; i++)\n-    {\n-      CTRunRef run = static_cast<CTRunRef>(CFArrayGetValueAtIndex (glyph_runs, i));\n-      CTRunStatus run_status = CTRunGetStatus (run);\n-      status_or  |= run_status;\n-      status_and &= run_status;\n-      DEBUG_MSG (CORETEXT, run, \"CTRunStatus: %x\", run_status);\n-      CGFloat run_advance = CTRunGetTypographicBounds (run, range_all, nullptr, nullptr, nullptr);\n-      if (HB_DIRECTION_IS_VERTICAL (buffer->props.direction))\n-          run_advance = -run_advance;\n-      DEBUG_MSG (CORETEXT, run, \"Run advance: %g\", (double) run_advance);\n-\n-      \/* CoreText does automatic font fallback (AKA \"cascading\") for  characters\n-       * not supported by the requested font, and provides no way to turn it off,\n-       * so we must detect if the returned run uses a font other than the requested\n-       * one and fill in the buffer with .notdef glyphs instead of random glyph\n-       * indices from a different font.\n-       *\/\n-      CFDictionaryRef attributes = CTRunGetAttributes (run);\n-      CTFontRef run_ct_font = static_cast<CTFontRef>(CFDictionaryGetValue (attributes, kCTFontAttributeName));\n-      if (!CFEqual (run_ct_font, ct_font))\n-      {\n-        \/* The run doesn't use our main font instance.  We have to figure out\n-         * whether font fallback happened, or this is just CoreText giving us\n-         * another CTFont using the same underlying CGFont.  CoreText seems\n-         * to do that in a variety of situations, one of which being vertical\n-         * text, but also perhaps for caching reasons.\n-         *\n-         * First, see if it uses any of our subfonts created to set font features...\n-         *\n-         * Next, compare the CGFont to the one we used to create our fonts.\n-         * Even this doesn't work all the time.\n-         *\n-         * Finally, we compare PS names, which I don't think are unique...\n-         *\n-         * Looks like if we really want to be sure here we have to modify the\n-         * font to change the name table, similar to what we do in the uniscribe\n-         * backend.\n-         *\n-         * However, even that wouldn't work if we were passed in the CGFont to\n-         * construct a hb_face to begin with.\n-         *\n-         * See: https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/36\n-         *\n-         * Also see: https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=597098\n-         *\/\n-        bool matched = false;\n-        for (unsigned int i = 0; i < range_records.length; i++)\n-          if (range_records[i].font && CFEqual (run_ct_font, range_records[i].font))\n-          {\n-            matched = true;\n-            break;\n-          }\n-        if (!matched)\n-        {\n-          CGFontRef run_cg_font = CTFontCopyGraphicsFont (run_ct_font, nullptr);\n-          if (run_cg_font)\n-          {\n-            matched = CFEqual (run_cg_font, cg_font);\n-            CFRelease (run_cg_font);\n-          }\n-        }\n-        if (!matched)\n-        {\n-          CFStringRef font_ps_name = CTFontCopyName (ct_font, kCTFontPostScriptNameKey);\n-          CFStringRef run_ps_name = CTFontCopyName (run_ct_font, kCTFontPostScriptNameKey);\n-          CFComparisonResult result = CFStringCompare (run_ps_name, font_ps_name, 0);\n-          CFRelease (run_ps_name);\n-          CFRelease (font_ps_name);\n-          if (result == kCFCompareEqualTo)\n-            matched = true;\n-        }\n-        if (!matched)\n-        {\n-          CFRange range = CTRunGetStringRange (run);\n-          DEBUG_MSG (CORETEXT, run, \"Run used fallback font: %ld..%ld\",\n-                     range.location, range.location + range.length);\n-          if (!buffer->ensure_inplace (buffer->len + range.length))\n-            goto resize_and_retry;\n-          hb_glyph_info_t *info = buffer->info + buffer->len;\n-\n-          hb_codepoint_t notdef = 0;\n-          hb_direction_t dir = buffer->props.direction;\n-          hb_position_t x_advance, y_advance, x_offset, y_offset;\n-          hb_font_get_glyph_advance_for_direction (font, notdef, dir, &x_advance, &y_advance);\n-          hb_font_get_glyph_origin_for_direction (font, notdef, dir, &x_offset, &y_offset);\n-          hb_position_t advance = x_advance + y_advance;\n-          x_offset = -x_offset;\n-          y_offset = -y_offset;\n-\n-          unsigned int old_len = buffer->len;\n-          for (CFIndex j = range.location; j < range.location + range.length; j++)\n-          {\n-              UniChar ch = CFStringGetCharacterAtIndex (string_ref, j);\n-              if (hb_in_range<UniChar> (ch, 0xDC00u, 0xDFFFu) && range.location < j)\n-              {\n-                ch = CFStringGetCharacterAtIndex (string_ref, j - 1);\n-                if (hb_in_range<UniChar> (ch, 0xD800u, 0xDBFFu))\n-                  \/* This is the second of a surrogate pair.  Don't need .notdef\n-                   * for this one. *\/\n-                  continue;\n-              }\n-              if (buffer->unicode->is_default_ignorable (ch))\n-                continue;\n-\n-              info->codepoint = notdef;\n-              info->cluster = log_clusters[j];\n-\n-              info->mask = advance;\n-              info->var1.i32 = x_offset;\n-              info->var2.i32 = y_offset;\n-\n-              info++;\n-              buffer->len++;\n-          }\n-          if (HB_DIRECTION_IS_BACKWARD (buffer->props.direction))\n-            buffer->reverse_range (old_len, buffer->len);\n-          advances_so_far += run_advance;\n-          continue;\n-        }\n-      }\n-\n-      unsigned int num_glyphs = CTRunGetGlyphCount (run);\n-      if (num_glyphs == 0)\n-        continue;\n-\n-      if (!buffer->ensure_inplace (buffer->len + num_glyphs))\n-        goto resize_and_retry;\n-\n-      hb_glyph_info_t *run_info = buffer->info + buffer->len;\n-\n-      \/* Testing used to indicate that CTRunGetGlyphsPtr, etc (almost?) always\n-       * succeed, and so copying data to our own buffer will be rare.  Reports\n-       * have it that this changed in OS X 10.10 Yosemite, and nullptr is returned\n-       * frequently.  At any rate, we can test that codepath by setting USE_PTR\n-       * to false. *\/\n-\n-#define USE_PTR true\n-\n-#define SCRATCH_SAVE() \\\n-  unsigned int scratch_size_saved = scratch_size; \\\n-  hb_buffer_t::scratch_buffer_t *scratch_saved = scratch\n-\n-#define SCRATCH_RESTORE() \\\n-  scratch_size = scratch_size_saved; \\\n-  scratch = scratch_saved\n-\n-      { \/* Setup glyphs *\/\n-        SCRATCH_SAVE();\n-        const CGGlyph* glyphs = USE_PTR ? CTRunGetGlyphsPtr (run) : nullptr;\n-        if (!glyphs) {\n-          ALLOCATE_ARRAY (CGGlyph, glyph_buf, num_glyphs, goto resize_and_retry);\n-          CTRunGetGlyphs (run, range_all, glyph_buf);\n-          glyphs = glyph_buf;\n-        }\n-        const CFIndex* string_indices = USE_PTR ? CTRunGetStringIndicesPtr (run) : nullptr;\n-        if (!string_indices) {\n-          ALLOCATE_ARRAY (CFIndex, index_buf, num_glyphs, goto resize_and_retry);\n-          CTRunGetStringIndices (run, range_all, index_buf);\n-          string_indices = index_buf;\n-        }\n-        hb_glyph_info_t *info = run_info;\n-        for (unsigned int j = 0; j < num_glyphs; j++)\n-        {\n-          info->codepoint = glyphs[j];\n-          info->cluster = log_clusters[string_indices[j]];\n-          info++;\n-        }\n-        SCRATCH_RESTORE();\n-      }\n-      {\n-        \/* Setup positions.\n-         * Note that CoreText does not return advances for glyphs.  As such,\n-         * for all but last glyph, we use the delta position to next glyph as\n-         * advance (in the advance direction only), and for last glyph we set\n-         * whatever is needed to make the whole run's advance add up. *\/\n-        SCRATCH_SAVE();\n-        const CGPoint* positions = USE_PTR ? CTRunGetPositionsPtr (run) : nullptr;\n-        if (!positions) {\n-          ALLOCATE_ARRAY (CGPoint, position_buf, num_glyphs, goto resize_and_retry);\n-          CTRunGetPositions (run, range_all, position_buf);\n-          positions = position_buf;\n-        }\n-        hb_glyph_info_t *info = run_info;\n-        if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n-        {\n-          hb_position_t x_offset = (positions[0].x - advances_so_far) * x_mult;\n-          for (unsigned int j = 0; j < num_glyphs; j++)\n-          {\n-            CGFloat advance;\n-            if (likely (j + 1 < num_glyphs))\n-              advance = positions[j + 1].x - positions[j].x;\n-            else \/* last glyph *\/\n-              advance = run_advance - (positions[j].x - positions[0].x);\n-            info->mask = advance * x_mult;\n-            info->var1.i32 = x_offset;\n-            info->var2.i32 = positions[j].y * y_mult;\n-            info++;\n-          }\n-        }\n-        else\n-        {\n-          hb_position_t y_offset = (positions[0].y - advances_so_far) * y_mult;\n-          for (unsigned int j = 0; j < num_glyphs; j++)\n-          {\n-            CGFloat advance;\n-            if (likely (j + 1 < num_glyphs))\n-              advance = positions[j + 1].y - positions[j].y;\n-            else \/* last glyph *\/\n-              advance = run_advance - (positions[j].y - positions[0].y);\n-            info->mask = advance * y_mult;\n-            info->var1.i32 = positions[j].x * x_mult;\n-            info->var2.i32 = y_offset;\n-            info++;\n-          }\n-        }\n-        SCRATCH_RESTORE();\n-        advances_so_far += run_advance;\n-      }\n-#undef SCRATCH_RESTORE\n-#undef SCRATCH_SAVE\n-#undef USE_PTR\n-#undef ALLOCATE_ARRAY\n-\n-      buffer->len += num_glyphs;\n-    }\n-\n-    \/* Mac OS 10.6 doesn't have kCTTypesetterOptionForcedEmbeddingLevel,\n-     * or if it does, it doesn't respect it.  So we get runs with wrong\n-     * directions.  As such, disable the assert...  It wouldn't crash, but\n-     * cursoring will be off...\n-     *\n-     * https:\/\/crbug.com\/419769\n-     *\/\n-    if (false)\n-    {\n-      \/* Make sure all runs had the expected direction. *\/\n-      HB_UNUSED bool backward = HB_DIRECTION_IS_BACKWARD (buffer->props.direction);\n-      assert (bool (status_and & kCTRunStatusRightToLeft) == backward);\n-      assert (bool (status_or  & kCTRunStatusRightToLeft) == backward);\n-    }\n-\n-    buffer->clear_positions ();\n-\n-    unsigned int count = buffer->len;\n-    hb_glyph_info_t *info = buffer->info;\n-    hb_glyph_position_t *pos = buffer->pos;\n-    if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n-      for (unsigned int i = 0; i < count; i++)\n-      {\n-        pos->x_advance = info->mask;\n-        pos->x_offset = info->var1.i32;\n-        pos->y_offset = info->var2.i32;\n-\n-        info++, pos++;\n-      }\n-    else\n-      for (unsigned int i = 0; i < count; i++)\n-      {\n-        pos->y_advance = info->mask;\n-        pos->x_offset = info->var1.i32;\n-        pos->y_offset = info->var2.i32;\n-\n-        info++, pos++;\n-      }\n-\n-    \/* Fix up clusters so that we never return out-of-order indices;\n-     * if core text has reordered glyphs, we'll merge them to the\n-     * beginning of the reordered cluster.  CoreText is nice enough\n-     * to tell us whenever it has produced nonmonotonic results...\n-     * Note that we assume the input clusters were nonmonotonic to\n-     * begin with.\n-     *\n-     * This does *not* mean we'll form the same clusters as Uniscribe\n-     * or the native OT backend, only that the cluster indices will be\n-     * monotonic in the output buffer. *\/\n-    if (count > 1 && (status_or & kCTRunStatusNonMonotonic))\n-    {\n-      hb_glyph_info_t *info = buffer->info;\n-      if (HB_DIRECTION_IS_FORWARD (buffer->props.direction))\n-      {\n-        unsigned int cluster = info[count - 1].cluster;\n-        for (unsigned int i = count - 1; i > 0; i--)\n-        {\n-          cluster = hb_min (cluster, info[i - 1].cluster);\n-          info[i - 1].cluster = cluster;\n-        }\n-      }\n-      else\n-      {\n-        unsigned int cluster = info[0].cluster;\n-        for (unsigned int i = 1; i < count; i++)\n-        {\n-          cluster = hb_min (cluster, info[i].cluster);\n-          info[i].cluster = cluster;\n-        }\n-      }\n-    }\n-  }\n-\n-  buffer->unsafe_to_break_all ();\n-\n-#undef FAIL\n-\n-fail:\n-  if (string_ref)\n-    CFRelease (string_ref);\n-  if (line)\n-    CFRelease (line);\n-\n-  for (unsigned int i = 0; i < range_records.length; i++)\n-    if (range_records[i].font)\n-      CFRelease (range_records[i].font);\n-\n-  return ret;\n-}\n-\n-\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-coretext.cc","additions":0,"deletions":1196,"binary":false,"changes":1196,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright © 2012  Mozilla Foundation.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Mozilla Author(s): Jonathan Kew\n- *\/\n-\n-#ifndef HB_CORETEXT_H\n-#define HB_CORETEXT_H\n-\n-#include \"hb.h\"\n-\n-#include <TargetConditionals.h>\n-#if TARGET_OS_IPHONE\n-#  include <CoreText\/CoreText.h>\n-#  include <CoreGraphics\/CoreGraphics.h>\n-#else\n-#  include <ApplicationServices\/ApplicationServices.h>\n-#endif\n-\n-HB_BEGIN_DECLS\n-\n-\n-\/**\n- * HB_CORETEXT_TAG_MORT:\n- *\n- * The #hb_tag_t tag for the `mort` (glyph metamorphosis) table,\n- * which holds AAT features.\n- *\n- * For more information, see\n- * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6mort.html\n- *\n- **\/\n-#define HB_CORETEXT_TAG_MORT HB_TAG('m','o','r','t')\n-\n-\/**\n- * HB_CORETEXT_TAG_MORX:\n- *\n- * The #hb_tag_t tag for the `morx` (extended glyph metamorphosis)\n- * table, which holds AAT features.\n- *\n- * For more information, see\n- * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6morx.html\n- *\n- **\/\n-#define HB_CORETEXT_TAG_MORX HB_TAG('m','o','r','x')\n-\n-\/**\n- * HB_CORETEXT_TAG_KERX:\n- *\n- * The #hb_tag_t tag for the `kerx` (extended kerning) table, which\n- * holds AAT kerning information.\n- *\n- * For more information, see\n- * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6kerx.html\n- *\n- **\/\n-#define HB_CORETEXT_TAG_KERX HB_TAG('k','e','r','x')\n-\n-\n-HB_EXTERN hb_face_t *\n-hb_coretext_face_create (CGFontRef cg_font);\n-\n-HB_EXTERN hb_font_t *\n-hb_coretext_font_create (CTFontRef ct_font);\n-\n-\n-HB_EXTERN CGFontRef\n-hb_coretext_face_get_cg_font (hb_face_t *face);\n-\n-HB_EXTERN CTFontRef\n-hb_coretext_font_get_ct_font (hb_font_t *font);\n-\n-\n-HB_END_DECLS\n-\n-#endif \/* HB_CORETEXT_H *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-coretext.h","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8256372\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+\n+public class NLGlyphTest {\n+\n+   public static void main(String[] args) {\n+      char[] chs = { '\\n' };\n+      FontRenderContext frc = new FontRenderContext(null, true, true);\n+      GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+      Font[] fonts = ge.getAllFonts();\n+      for (Font font : fonts) {\n+          GlyphVector cgv = font.createGlyphVector(frc, \"\\n\");\n+          GlyphVector lgv = font.layoutGlyphVector(frc, chs, 0, 1, 0);\n+          int c_code = cgv.getGlyphCode(0);\n+          int l_code = lgv.getGlyphCode(0);\n+          if ((c_code != l_code) || (l_code == 0)) {\n+              System.out.println(font);\n+              System.out.println(\"create code=\"+c_code + \" layout code=\"+l_code);\n+              Rectangle r_l = lgv.getPixelBounds(frc, 0f, 0f);\n+              Rectangle r_c = cgv.getPixelBounds(frc, 0f, 0f);\n+              System.out.println(r_l.isEmpty()+\" \"+ r_c.isEmpty());\n+              if (r_l.isEmpty() != r_c.isEmpty()) {\n+                 throw new RuntimeException(\"One glyph renders\");\n+              }\n+          }\n+      }\n+   }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/GlyphVector\/NLGlyphTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}