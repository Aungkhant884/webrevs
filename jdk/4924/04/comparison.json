{"files":[{"patch":"@@ -141,0 +141,5 @@\n+  \/\/ Does the CPU supports vector constant rotate instructions?\n+  static constexpr bool supports_vector_constant_rotates(int shift) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -134,0 +134,5 @@\n+  \/\/ Does the CPU supports vector constant rotate instructions?\n+  static constexpr bool supports_vector_constant_rotates(int shift) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,5 @@\n+  \/\/ Does the CPU supports vector constant rotate instructions?\n+  static constexpr bool supports_vector_constant_rotates(int shift) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+  \/\/ Does the CPU supports vector constant rotate instructions?\n+  static constexpr bool supports_vector_constant_rotates(int shift) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -161,0 +161,5 @@\n+  \/\/ Does the CPU supports vector constant rotate instructions?\n+  static constexpr bool supports_vector_constant_rotates(int shift) {\n+    return -0x80 <= shift && shift < 0x80;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1641,0 +1641,3 @@\n+      if (bt != T_INT && bt != T_LONG) {\n+        return false;\n+      } \/\/ fallthrough\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -339,0 +339,1 @@\n+  bool arch_supports_vector_rotate(int opc, int num_elem, BasicType elem_bt, bool has_scalar_args = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2492,1 +2492,1 @@\n-        if (!in2->is_Con() || -0x80 > in2->get_int() || in2->get_int() >= 0x80) {\n+        if (!in2->is_Con() || !Matcher::supports_vector_constant_rotates(in2->get_int())) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,42 @@\n+bool LibraryCallKit::arch_supports_vector_rotate(int opc, int num_elem, BasicType elem_bt, bool has_scalar_args) {\n+    bool is_supported = true;\n+    \/\/ has_scalar_args flag is true only for non-constant scalar shift count,\n+    \/\/ since in this case shift needs to be broadcasted.\n+    if (!Matcher::match_rule_supported_vector(opc, num_elem, elem_bt) ||\n+         (has_scalar_args &&\n+           !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed))) {\n+      is_supported = false;\n+    }\n+\n+    int lshiftopc, rshiftopc;\n+    switch(elem_bt) {\n+      case T_BYTE:\n+        lshiftopc = Op_LShiftI;\n+        rshiftopc = Op_URShiftB;\n+        break;\n+      case T_SHORT:\n+        lshiftopc = Op_LShiftI;\n+        rshiftopc = Op_URShiftS;\n+        break;\n+      case T_INT:\n+        lshiftopc = Op_LShiftI;\n+        rshiftopc = Op_URShiftI;\n+        break;\n+      case T_LONG:\n+        lshiftopc = Op_LShiftL;\n+        rshiftopc = Op_URShiftL;\n+        break;\n+      default:\n+        assert(false, \"Unexpected type\");\n+    }\n+    int lshiftvopc = VectorNode::opcode(lshiftopc, elem_bt);\n+    int rshiftvopc = VectorNode::opcode(rshiftopc, elem_bt);\n+    if (!is_supported &&\n+        arch_supports_vector(lshiftvopc, num_elem, elem_bt, VecMaskNotUsed, has_scalar_args) &&\n+        arch_supports_vector(rshiftvopc, num_elem, elem_bt, VecMaskNotUsed, has_scalar_args) &&\n+        arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+      is_supported = true;\n+    }\n+    return is_supported;\n+}\n+\n@@ -115,2 +157,2 @@\n-  \/\/ Check that architecture supports this op-size-type combination.\n-  if (!Matcher::match_rule_supported_vector(sopc, num_elem, type)) {\n+  if (VectorNode::is_vector_rotate(sopc)) {\n+    if(!arch_supports_vector_rotate(sopc, num_elem, type, has_scalar_args)) {\n@@ -118,4 +160,4 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support it\",\n-                    NodeClassNames[sopc], type2name(type), num_elem);\n-    }\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n@@ -123,1 +165,2 @@\n-    return false;\n+      return false;\n+    }\n@@ -125,1 +168,12 @@\n-    assert(Matcher::match_rule_supported(sopc), \"must be supported\");\n+    \/\/ Check that architecture supports this op-size-type combination.\n+    if (!Matcher::match_rule_supported_vector(sopc, num_elem, type)) {\n+#ifndef PRODUCT\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support it\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n+#endif\n+      return false;\n+    } else {\n+      assert(Matcher::match_rule_supported(sopc), \"must be supported\");\n+    }\n@@ -1503,1 +1557,3 @@\n-  if (opc == 0 || !VectorNode::is_shift_opcode(opc)) {\n+  bool is_shift  = VectorNode::is_shift_opcode(opc);\n+  bool is_rotate = VectorNode::is_rotate_opcode(opc);\n+  if (opc == 0 || (!is_shift && !is_rotate)) {\n@@ -1516,0 +1572,1 @@\n+  Node* cnt  = argument(5);\n@@ -1518,0 +1575,1 @@\n+  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n@@ -1519,1 +1577,5 @@\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, true \/*has_scalar_args*\/)) {\n+  \/\/ If CPU supports vector constant rotate instructions pass it directly\n+  bool is_const_rotate = is_rotate && cnt_type && cnt_type->is_con() &&\n+                         Matcher::supports_vector_constant_rotates(cnt_type->get_con());\n+  bool has_scalar_args = is_rotate ? !is_const_rotate : true;\n+  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskNotUsed, has_scalar_args)) {\n@@ -1527,1 +1589,14 @@\n-  Node* opd2 = vector_shift_count(argument(5), opc, elem_bt, num_elem);\n+  Node* opd2 = NULL;\n+  if (is_shift) {\n+    opd2 = vector_shift_count(cnt, opc, elem_bt, num_elem);\n+  } else {\n+    assert(is_rotate, \"unexpected operation\");\n+    if (!is_const_rotate) {\n+      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+      cnt = elem_bt == T_LONG ? gvn().transform(new ConvI2LNode(cnt)) : cnt;\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+    } else {\n+      \/\/ Constant shift value.\n+      opd2 = cnt;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":86,"deletions":11,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateLeftV : 0);\n+    return (is_integral_type(bt) ? Op_RotateLeftV : 0);\n@@ -148,1 +148,1 @@\n-    return (bt == T_LONG || bt == T_INT ? Op_RotateRightV : 0);\n+    return (is_integral_type(bt) ? Op_RotateRightV : 0);\n@@ -265,1 +265,1 @@\n-    if (vopc == Op_RotateLeftV || vopc == Op_RotateRightV) {\n+    if (VectorNode::is_vector_rotate(vopc)) {\n@@ -299,7 +299,0 @@\n-bool VectorNode::is_scalar_rotate(Node* n) {\n-  if (n->Opcode() == Op_RotateLeft || n->Opcode() == Op_RotateRight) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -307,1 +300,1 @@\n-  assert(vopc == Op_RotateLeftV || vopc == Op_RotateRightV, \"wrong opcode\");\n+  assert(VectorNode::is_vector_rotate(vopc), \"wrong opcode\");\n@@ -359,0 +352,17 @@\n+bool VectorNode::is_rotate_opcode(int opc) {\n+  switch (opc) {\n+  case Op_RotateRight:\n+  case Op_RotateLeft:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool VectorNode::is_scalar_rotate(Node* n) {\n+  if (is_rotate_opcode(n->Opcode())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -590,0 +600,10 @@\n+bool VectorNode::is_vector_rotate(int opc) {\n+  switch (opc) {\n+  case Op_RotateLeftV:\n+  case Op_RotateRightV:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n@@ -1143,1 +1163,1 @@\n-  assert(bt == T_INT || bt == T_LONG, \"sanity\");\n+  assert(is_integral_type(bt), \"sanity\");\n@@ -1146,3 +1166,12 @@\n-  int shift_mask = (bt == T_INT) ? 0x1F : 0x3F;\n-  int shiftLOpc = (bt == T_INT) ? Op_LShiftI : Op_LShiftL;\n-  int shiftROpc = (bt == T_INT) ? Op_URShiftI: Op_URShiftL;\n+  int shift_mask = (type2aelembytes(bt) * 8) - 1;\n+  int shiftLOpc = (bt == T_LONG) ? Op_LShiftL : Op_LShiftI;\n+  auto urshiftopc = [=]() {\n+    switch(bt) {\n+      case T_INT: return Op_URShiftI;\n+      case T_LONG: return Op_URShiftL;\n+      case T_BYTE: return Op_URShiftB;\n+      case T_SHORT: return Op_URShiftS;\n+      default: return (Opcodes)0;\n+    }\n+  };\n+  int shiftROpc = urshiftopc();\n@@ -1177,1 +1206,1 @@\n-    \/\/ Vector variable shift.\n+    \/\/ Variable vector rotate count.\n@@ -1179,1 +1208,5 @@\n-    assert(bt == T_INT, \"Variable vector case supported for integer type rotation\");\n+\n+    int subVopc = 0;\n+    int addVopc = 0;\n+    Node* shift_mask_node = NULL;\n+    Node* const_one_node = NULL;\n@@ -1184,6 +1217,11 @@\n-    Node* shift_mask_node = phase->intcon(shift_mask);\n-    Node* const_one_node = phase->intcon(1);\n-\n-    int subVopc = VectorNode::opcode(Op_SubI, bt);\n-    int addVopc = VectorNode::opcode(Op_AddI, bt);\n-\n+    if (bt == T_LONG) {\n+      shift_mask_node = phase->longcon(shift_mask);\n+      const_one_node = phase->longcon(1L);\n+      subVopc = VectorNode::opcode(Op_SubL, bt);\n+      addVopc = VectorNode::opcode(Op_AddL, bt);\n+    } else {\n+      shift_mask_node = phase->intcon(shift_mask);\n+      const_one_node = phase->intcon(1);\n+      subVopc = VectorNode::opcode(Op_SubI, bt);\n+      addVopc = VectorNode::opcode(Op_AddI, bt);\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":61,"deletions":23,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool is_rotate_opcode(int opc);\n@@ -90,1 +91,1 @@\n-  static bool is_vector_rotate_supported(int vopc, uint vlen, BasicType bt);\n+  static bool is_vector_rotate_supported(int opc, uint vlen, BasicType bt);\n@@ -102,0 +103,1 @@\n+  static bool is_vector_rotate(int opc);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -377,0 +377,20 @@\n+    case VECTOR_OP_LROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateLeft;\n+        default: fatal(\"LROTATE: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_RROTATE: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:  return Op_RotateRight;\n+        default: fatal(\"RROTATE: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    \/\/ Rotate operations\n+    VECTOR_OP_LROTATE = 22,\n+    VECTOR_OP_RROTATE = 23,\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,0 +73,4 @@\n+    \/\/ Rotate operations\n+    public static final int VECTOR_OP_LROTATE = 22;\n+    public static final int VECTOR_OP_RROTATE = 23;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -383,0 +383,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static byte rotateLeft(byte a, int n) {\n+        return (byte)(((((byte)a) & Byte.toUnsignedInt((byte)-1)) << (n & Byte.SIZE-1)) | ((((byte)a) & Byte.toUnsignedInt((byte)-1)) >>> (Byte.SIZE - (n & Byte.SIZE-1))));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static byte rotateRight(byte a, int n) {\n+        return (byte)(((((byte)a) & Byte.toUnsignedInt((byte)-1)) >>> (n & Byte.SIZE-1)) | ((((byte)a) & Byte.toUnsignedInt((byte)-1)) << (Byte.SIZE - (n & Byte.SIZE-1))));\n+    }\n+\n@@ -603,6 +615,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ByteVector neg = that.lanewise(NEG);\n-                ByteVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ByteVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -649,0 +656,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -795,5 +806,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ByteVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ByteVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -812,0 +818,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -383,0 +383,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -383,0 +383,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -383,0 +383,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static int rotateLeft(int a, int n) {\n+        return Integer.rotateLeft(a, n);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static int rotateRight(int a, int n) {\n+        return Integer.rotateRight(a, n);\n+    }\n+\n@@ -603,6 +615,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                IntVector neg = that.lanewise(NEG);\n-                IntVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                IntVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -649,0 +656,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -795,5 +806,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            IntVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            IntVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -812,0 +818,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -383,0 +383,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static long rotateLeft(long a, int n) {\n+        return Long.rotateLeft(a, n);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long rotateRight(long a, int n) {\n+        return Long.rotateRight(a, n);\n+    }\n+\n@@ -561,6 +573,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                LongVector neg = that.lanewise(NEG);\n-                LongVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                LongVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -607,0 +614,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -713,5 +724,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            LongVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            LongVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -730,0 +736,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -383,0 +383,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    static short rotateLeft(short a, int n) {\n+        return (short)(((((short)a) & Short.toUnsignedInt((short)-1)) << (n & Short.SIZE-1)) | ((((short)a) & Short.toUnsignedInt((short)-1)) >>> (Short.SIZE - (n & Short.SIZE-1))));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short rotateRight(short a, int n) {\n+        return (short)(((((short)a) & Short.toUnsignedInt((short)-1)) >>> (n & Short.SIZE-1)) | ((((short)a) & Short.toUnsignedInt((short)-1)) << (Short.SIZE - (n & Short.SIZE-1))));\n+    }\n+\n@@ -603,6 +615,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                ShortVector neg = that.lanewise(NEG);\n-                ShortVector hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                ShortVector lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -649,0 +656,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -795,5 +806,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            ShortVector hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            ShortVector lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -812,0 +818,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", -1 \/*VectorSupport.VECTOR_OP_LROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROL = binary(\"ROL\", \"rotateLeft\", VectorSupport.VECTOR_OP_LROTATE, VO_SHIFT);\n@@ -556,1 +556,1 @@\n-    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", -1 \/*VectorSupport.VECTOR_OP_RROTATE*\/, VO_SHIFT | VO_SPECIAL);\n+    public static final \/*bitwise*\/ Binary ROR = binary(\"ROR\", \"rotateRight\", VectorSupport.VECTOR_OP_RROTATE, VO_SHIFT);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -387,0 +387,22 @@\n+#if[BITWISE]\n+    \/*package-private*\/\n+    @ForceInline\n+    static $type$ rotateLeft($type$ a, int n) {\n+#if[intOrLong]\n+        return $Boxtype$.rotateLeft(a, n);\n+#else[intOrLong]\n+        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+#end[intOrLong]\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static $type$ rotateRight($type$ a, int n) {\n+#if[intOrLong]\n+        return $Boxtype$.rotateRight(a, n);\n+#else[intOrLong]\n+        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+#end[intOrLong]\n+    }\n+#end[BITWISE]\n+\n@@ -660,6 +682,1 @@\n-            if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-                $abstractvectortype$ neg = that.lanewise(NEG);\n-                $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? neg : that);\n-                $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? that : neg);\n-                return hi.lanewise(OR, lo);\n-            } else if (op == AND_NOT) {\n+            if (op == AND_NOT) {\n@@ -708,0 +725,4 @@\n+                case VECTOR_OP_LROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, n) -> rotateRight(a, (int)n));\n@@ -872,5 +893,0 @@\n-        if (op == ROR || op == ROL) {  \/\/ FIXME: JIT should do this\n-            $abstractvectortype$ hi = this.lanewise(LSHL, (op == ROR) ? -e : e);\n-            $abstractvectortype$ lo = this.lanewise(LSHR, (op == ROR) ? e : -e);\n-            return hi.lanewise(OR, lo);\n-        }\n@@ -889,0 +905,4 @@\n+                case VECTOR_OP_LROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateLeft(a, (int)n));\n+                case VECTOR_OP_RROTATE: return (v, n) ->\n+                        v.uOp((i, a) -> rotateRight(a, (int)n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1156,0 +1156,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2325,1 +2333,1 @@\n-    static void LSHLByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2343,1 +2351,1 @@\n-    static void LSHLByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2371,1 +2379,1 @@\n-    static void LSHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2389,1 +2397,1 @@\n-    static void LSHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2417,1 +2425,1 @@\n-    static void ASHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2435,1 +2443,1 @@\n-    static void ASHRByte128VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2455,0 +2463,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte128VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte128VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1156,0 +1156,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2325,1 +2333,1 @@\n-    static void LSHLByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2343,1 +2351,1 @@\n-    static void LSHLByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2371,1 +2379,1 @@\n-    static void LSHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2389,1 +2397,1 @@\n-    static void LSHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2417,1 +2425,1 @@\n-    static void ASHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2435,1 +2443,1 @@\n-    static void ASHRByte256VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2455,0 +2463,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte256VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte256VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1156,0 +1156,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2325,1 +2333,1 @@\n-    static void LSHLByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2343,1 +2351,1 @@\n-    static void LSHLByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2371,1 +2379,1 @@\n-    static void LSHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2389,1 +2397,1 @@\n-    static void LSHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2417,1 +2425,1 @@\n-    static void ASHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2435,1 +2443,1 @@\n-    static void ASHRByte512VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2455,0 +2463,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte512VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte512VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1156,0 +1156,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2325,1 +2333,1 @@\n-    static void LSHLByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2343,1 +2351,1 @@\n-    static void LSHLByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2371,1 +2379,1 @@\n-    static void LSHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2389,1 +2397,1 @@\n-    static void LSHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2417,1 +2425,1 @@\n-    static void ASHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2435,1 +2443,1 @@\n-    static void ASHRByte64VectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2455,0 +2463,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByte64VectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Byte64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByte64VectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Byte64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1161,0 +1161,8 @@\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n@@ -2330,1 +2338,1 @@\n-    static void LSHLByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHLByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2348,1 +2356,1 @@\n-    static void LSHLByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHLByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2376,1 +2384,1 @@\n-    static void LSHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void LSHRByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2394,1 +2402,1 @@\n-    static void LSHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void LSHRByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2422,1 +2430,1 @@\n-    static void ASHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ASHRByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -2440,1 +2448,1 @@\n-    static void ASHRByteMaxVectorTestsShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ASHRByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -2460,0 +2468,172 @@\n+\n+    static byte ROR(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROR);\n+    }\n+\n+\n+    static byte ROL(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROL);\n+    }\n+\n+\n+    static byte ROR_unary(byte a, byte b) {\n+        return (byte)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void RORByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ByteMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void RORByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static byte ROL_unary(byte a, byte b) {\n+        return (byte)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void ROLByteMaxVectorTestsScalarShift(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ByteMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void ROLByteMaxVectorTestsScalarShiftMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ByteMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1928,0 +1928,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1928,0 +1928,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1928,0 +1928,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1946,0 +1946,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1951,0 +1951,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1956,0 +1956,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1956,0 +1956,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1956,0 +1956,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1956,0 +1956,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1961,0 +1961,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1116,0 +1116,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2288,1 +2296,1 @@\n-    static void LSHLInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2306,1 +2314,1 @@\n-    static void LSHLInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2334,1 +2342,1 @@\n-    static void LSHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2352,1 +2360,1 @@\n-    static void LSHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2380,1 +2388,1 @@\n-    static void ASHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2398,1 +2406,1 @@\n-    static void ASHRInt128VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2420,0 +2428,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt128VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1116,0 +1116,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2288,1 +2296,1 @@\n-    static void LSHLInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2306,1 +2314,1 @@\n-    static void LSHLInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2334,1 +2342,1 @@\n-    static void LSHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2352,1 +2360,1 @@\n-    static void LSHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2380,1 +2388,1 @@\n-    static void ASHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2398,1 +2406,1 @@\n-    static void ASHRInt256VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2420,0 +2428,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt256VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1116,0 +1116,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2288,1 +2296,1 @@\n-    static void LSHLInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2306,1 +2314,1 @@\n-    static void LSHLInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2334,1 +2342,1 @@\n-    static void LSHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2352,1 +2360,1 @@\n-    static void LSHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2380,1 +2388,1 @@\n-    static void ASHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2398,1 +2406,1 @@\n-    static void ASHRInt512VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2420,0 +2428,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt512VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1116,0 +1116,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2288,1 +2296,1 @@\n-    static void LSHLInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2306,1 +2314,1 @@\n-    static void LSHLInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2334,1 +2342,1 @@\n-    static void LSHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2352,1 +2360,1 @@\n-    static void LSHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2380,1 +2388,1 @@\n-    static void ASHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2398,1 +2406,1 @@\n-    static void ASHRInt64VectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2420,0 +2428,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLInt64VectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Int64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Int64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1121,0 +1121,8 @@\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2293,1 +2301,1 @@\n-    static void LSHLIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHLIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2311,1 +2319,1 @@\n-    static void LSHLIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHLIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2339,1 +2347,1 @@\n-    static void LSHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void LSHRIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2357,1 +2365,1 @@\n-    static void LSHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void LSHRIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2385,1 +2393,1 @@\n-    static void ASHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ASHRIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -2403,1 +2411,1 @@\n-    static void ASHRIntMaxVectorTestsShift(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ASHRIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -2425,0 +2433,172 @@\n+\n+    static int ROR(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::ROR);\n+    }\n+\n+\n+    static int ROL(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::ROL);\n+    }\n+\n+\n+    static int ROR_unary(int a, int b) {\n+        return (int)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void RORIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static int ROL_unary(int a, int b) {\n+        return (int)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void ROLIntMaxVectorTestsScalarShift(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, IntMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsScalarShiftMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, IntMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1138,0 +1138,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2310,1 +2318,1 @@\n-    static void LSHLLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2328,1 +2336,1 @@\n-    static void LSHLLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2356,1 +2364,1 @@\n-    static void LSHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2374,1 +2382,1 @@\n-    static void LSHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2402,1 +2410,1 @@\n-    static void ASHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2420,1 +2428,1 @@\n-    static void ASHRLong128VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2442,0 +2450,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong128VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long128VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1138,0 +1138,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2310,1 +2318,1 @@\n-    static void LSHLLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2328,1 +2336,1 @@\n-    static void LSHLLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2356,1 +2364,1 @@\n-    static void LSHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2374,1 +2382,1 @@\n-    static void LSHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2402,1 +2410,1 @@\n-    static void ASHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2420,1 +2428,1 @@\n-    static void ASHRLong256VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2442,0 +2450,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong256VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long256VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1138,0 +1138,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2310,1 +2318,1 @@\n-    static void LSHLLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2328,1 +2336,1 @@\n-    static void LSHLLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2356,1 +2364,1 @@\n-    static void LSHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2374,1 +2382,1 @@\n-    static void LSHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2402,1 +2410,1 @@\n-    static void ASHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2420,1 +2428,1 @@\n-    static void ASHRLong512VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2442,0 +2450,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong512VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long512VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1138,0 +1138,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2310,1 +2318,1 @@\n-    static void LSHLLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2328,1 +2336,1 @@\n-    static void LSHLLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2356,1 +2364,1 @@\n-    static void LSHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2374,1 +2382,1 @@\n-    static void LSHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2402,1 +2410,1 @@\n-    static void ASHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2420,1 +2428,1 @@\n-    static void ASHRLong64VectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2442,0 +2450,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLong64VectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Long64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Long64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1143,0 +1143,8 @@\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n@@ -2315,1 +2323,1 @@\n-    static void LSHLLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHLLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2333,1 +2341,1 @@\n-    static void LSHLLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHLLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2361,1 +2369,1 @@\n-    static void LSHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void LSHRLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2379,1 +2387,1 @@\n-    static void LSHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void LSHRLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2407,1 +2415,1 @@\n-    static void ASHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ASHRLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -2425,1 +2433,1 @@\n-    static void ASHRLongMaxVectorTestsShift(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ASHRLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -2447,0 +2455,172 @@\n+\n+    static long ROR(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::ROR);\n+    }\n+\n+\n+    static long ROL(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::ROL);\n+    }\n+\n+\n+    static long ROR_unary(long a, long b) {\n+        return (long)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void RORLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static long ROL_unary(long a, long b) {\n+        return (long)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void ROLLongMaxVectorTestsScalarShift(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, LongMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsScalarShiftMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, LongMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1146,0 +1146,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2317,1 +2325,1 @@\n-    static void LSHLShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2335,1 +2343,1 @@\n-    static void LSHLShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2363,1 +2371,1 @@\n-    static void LSHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2381,1 +2389,1 @@\n-    static void LSHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2409,1 +2417,1 @@\n-    static void ASHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2427,1 +2435,1 @@\n-    static void ASHRShort128VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2444,0 +2452,172 @@\n+\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short128VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short128VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort128VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short128VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort128VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short128VectorTests::ROL_unary);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1146,0 +1146,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2317,1 +2325,1 @@\n-    static void LSHLShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2335,1 +2343,1 @@\n-    static void LSHLShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2363,1 +2371,1 @@\n-    static void LSHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2381,1 +2389,1 @@\n-    static void LSHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2409,1 +2417,1 @@\n-    static void ASHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2427,1 +2435,1 @@\n-    static void ASHRShort256VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2444,0 +2452,172 @@\n+\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short256VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short256VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort256VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short256VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort256VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short256VectorTests::ROL_unary);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1146,0 +1146,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2317,1 +2325,1 @@\n-    static void LSHLShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2335,1 +2343,1 @@\n-    static void LSHLShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2363,1 +2371,1 @@\n-    static void LSHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2381,1 +2389,1 @@\n-    static void LSHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2409,1 +2417,1 @@\n-    static void ASHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2427,1 +2435,1 @@\n-    static void ASHRShort512VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2444,0 +2452,172 @@\n+\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short512VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short512VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort512VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short512VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort512VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short512VectorTests::ROL_unary);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1146,0 +1146,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2317,1 +2325,1 @@\n-    static void LSHLShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2335,1 +2343,1 @@\n-    static void LSHLShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2363,1 +2371,1 @@\n-    static void LSHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2381,1 +2389,1 @@\n-    static void LSHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2409,1 +2417,1 @@\n-    static void ASHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2427,1 +2435,1 @@\n-    static void ASHRShort64VectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2445,0 +2453,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short64VectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short64VectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShort64VectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, Short64VectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShort64VectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, Short64VectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1151,0 +1151,8 @@\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n@@ -2322,1 +2330,1 @@\n-    static void LSHLShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHLShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2340,1 +2348,1 @@\n-    static void LSHLShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHLShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2368,1 +2376,1 @@\n-    static void LSHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void LSHRShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2386,1 +2394,1 @@\n-    static void LSHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void LSHRShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2414,1 +2422,1 @@\n-    static void ASHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ASHRShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -2432,1 +2440,1 @@\n-    static void ASHRShortMaxVectorTestsShift(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ASHRShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -2450,0 +2458,172 @@\n+\n+    static short ROR(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::ROR);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROR);\n+    }\n+\n+\n+    static short ROL(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::ROL);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROL);\n+    }\n+\n+\n+    static short ROR_unary(short a, short b) {\n+        return (short)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void RORShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ShortMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void RORShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROR_unary);\n+    }\n+\n+\n+    static short ROL_unary(short a, short b) {\n+        return (short)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ROLShortMaxVectorTestsScalarShift(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, ShortMaxVectorTests::ROL_unary);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ROLShortMaxVectorTestsScalarShiftMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, ShortMaxVectorTests::ROL_unary);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":186,"deletions":6,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    local kernel_escaped=$(echo -e \"$kernel\" | tr '\\n' '|')\n+    local kernel_escaped=$(echo -e \"$kernel\" | tr '\\n' '`')\n@@ -104,1 +104,1 @@\n-    cat ${filename}.current1 | tr '|' \"\\n\" > ${filename}.current\n+    cat ${filename}.current1 | tr '`' \"\\n\" > ${filename}.current\n@@ -159,1 +159,1 @@\n-        local kernel_smoke_escaped=$(echo -e \"$kernel_smoke\" | tr '\\n' '|')\n+        local kernel_smoke_escaped=$(echo -e \"$kernel_smoke\" | tr '\\n' '`')\n@@ -161,1 +161,1 @@\n-        cat ${filename}.scurrent1 | tr '|' \"\\n\" > ${filename}.scurrent\n+        cat ${filename}.scurrent1 | tr '`' \"\\n\" > ${filename}.scurrent\n@@ -448,0 +448,4 @@\n+gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n+gen_shift_cst_op  \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+gen_shift_cst_op  \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-    static void [[TEST]]$vectorteststype$Shift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+    static void [[TEST]]$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-Masked-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-    static void [[TEST]]$vectorteststype$Shift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+    static void [[TEST]]$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1386,0 +1386,24 @@\n+\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class RotateBenchmark {\n+    @Param({\"256\",\"512\"})\n+    int size;\n+\n+    @Param({\"128\",\"256\", \"512\"})\n+    int bits;\n+\n+    @Param({\"7\",\"15\",\"31\"})\n+    int shift;\n+\n+    byte[] byteinp;\n+    byte[] byteres;\n+\n+    short[] shortinp;\n+    short[] shortres;\n+\n+    int[] intinp;\n+    int[] intres;\n+\n+    long[] longinp;\n+    long[] longres;\n+\n+    VectorSpecies<Byte> bspecies;\n+    VectorSpecies<Short> sspecies;\n+    VectorSpecies<Integer> ispecies;\n+    VectorSpecies<Long> lspecies;\n+\n+    static final byte[] specialvalsbyte = {0, -0, Byte.MIN_VALUE, Byte.MAX_VALUE};\n+    static final short[] specialvalsshort = {0, -0, Short.MIN_VALUE, Short.MAX_VALUE};\n+    static final int[] specialvalsint = {0, -0, Integer.MIN_VALUE, Integer.MAX_VALUE};\n+    static final long[] specialvalslong = {0L, -0L, Long.MIN_VALUE, Long.MAX_VALUE};\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        byteinp = new byte[size];\n+        byteres = new byte[size];\n+        shortinp = new short[size];\n+        shortres = new short[size];\n+        intinp = new int[size];\n+        intres = new int[size];\n+        longinp = new long[size];\n+        longres = new long[size];\n+\n+        bspecies = VectorSpecies.of(byte.class, VectorShape.forBitSize(bits));\n+        sspecies = VectorSpecies.of(short.class, VectorShape.forBitSize(bits));\n+        ispecies = VectorSpecies.of(int.class, VectorShape.forBitSize(bits));\n+        lspecies = VectorSpecies.of(long.class, VectorShape.forBitSize(bits));\n+\n+        for (int i = 4; i < size; i++) {\n+            byteinp[i] = (byte)i;\n+            shortinp[i] = (short)i;\n+            intinp[i] = i;\n+            longinp[i] = i;\n+        }\n+        for (int i = 0; i < specialvalsbyte.length; i++) {\n+            byteinp[i] = specialvalsbyte[i];\n+        }\n+        for (int i = 0; i < specialvalsshort.length; i++) {\n+            shortinp[i] = specialvalsshort[i];\n+        }\n+        for (int i = 0; i < specialvalsint.length; i++) {\n+            intinp[i] = specialvalsint[i];\n+        }\n+        for (int i = 0; i < specialvalslong.length; i++) {\n+            longinp[i] = specialvalslong[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftB() {\n+        for (int j = 0; j < size; j += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, byteinp, j)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift).intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightB() {\n+        for (int j = 0; j < size; j += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, byteinp, j)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift).intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftS() {\n+        for (int j = 0; j < size; j += sspecies.length()) {\n+            ShortVector.fromArray(sspecies, shortinp, j)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift).intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightS() {\n+        for (int j = 0; j < size; j += sspecies.length()) {\n+            ShortVector.fromArray(sspecies, shortinp, j)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift).intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftI() {\n+        for (int j = 0; j < size; j += ispecies.length()) {\n+            IntVector.fromArray(ispecies, intinp, j)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift)\n+                .lanewise(VectorOperators.ROL, shift).intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightI() {\n+        for (int j = 0; j < size; j += ispecies.length()) {\n+            IntVector.fromArray(ispecies, intinp, j)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift)\n+                .lanewise(VectorOperators.ROR, shift).intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateLeftL() {\n+        for (int j = 0; j < size; j += lspecies.length()) {\n+            LongVector.fromArray(lspecies, longinp, j)\n+                   .lanewise(VectorOperators.ROL, shift)\n+                   .lanewise(VectorOperators.ROL, shift)\n+                   .lanewise(VectorOperators.ROL, shift)\n+                   .lanewise(VectorOperators.ROL, shift)\n+                   .lanewise(VectorOperators.ROL, shift)\n+                   .lanewise(VectorOperators.ROL, shift)\n+                   .lanewise(VectorOperators.ROL, shift).intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRotateRightL() {\n+        for (int j = 0; j < size; j += lspecies.length()) {\n+            LongVector.fromArray(lspecies, longinp, j)\n+                   .lanewise(VectorOperators.ROR, shift)\n+                   .lanewise(VectorOperators.ROR, shift)\n+                   .lanewise(VectorOperators.ROR, shift)\n+                   .lanewise(VectorOperators.ROR, shift)\n+                   .lanewise(VectorOperators.ROR, shift)\n+                   .lanewise(VectorOperators.ROR, shift)\n+                   .lanewise(VectorOperators.ROR, shift).intoArray(longres, j);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/RotateBenchmark.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}