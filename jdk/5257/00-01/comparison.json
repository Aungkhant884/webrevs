{"files":[{"patch":"@@ -1085,3 +1085,2 @@\n-            X509Authentications ka\n-                    = new X509Authentications(allAuths.toArray(String[]::new));\n-            SSLPossession pos = ka.createPossession(hc);\n+            SSLPossession pos = X509Authentication\n+                    .createPossession(hc, allAuths.toArray(String[]::new));\n@@ -1093,1 +1092,0 @@\n-                return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -773,2 +773,2 @@\n-            X509Authentications ka = new X509Authentications(allAuths.toArray(String[]::new));\n-            SSLPossession pos = ka.createPossession(hc);\n+            SSLPossession pos = X509Authentication\n+                    .createPossession(hc, allAuths.toArray(String[]::new));\n@@ -780,1 +780,0 @@\n-                return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -42,0 +44,1 @@\n+\n@@ -207,17 +210,3 @@\n-            if (context.sslConfig.isClientMode) {\n-                for (String keyType : keyTypes) {\n-                    SSLPossession poss = createClientPossession(\n-                            (ClientHandshakeContext)context, keyType);\n-                    if (poss != null) {\n-                        return poss;\n-                    }\n-                }\n-            } else {\n-                for (String keyType : keyTypes) {\n-                    SSLPossession poss = createServerPossession(\n-                            (ServerHandshakeContext)context, keyType);\n-                    if (poss != null) {\n-                        return poss;\n-                    }\n-                }\n-            }\n+            return X509Authentication.createPossession(context, keyTypes);\n+        }\n+    }\n@@ -225,1 +214,8 @@\n-            return null;\n+    public static SSLPossession createPossession(\n+            HandshakeContext context, String[] keyTypes) {\n+        if (context.sslConfig.isClientMode) {\n+            return createClientPossession(\n+                    (ClientHandshakeContext) context, keyTypes);\n+        } else {\n+            return createServerPossession(\n+                    (ServerHandshakeContext) context, keyTypes);\n@@ -227,0 +223,1 @@\n+    }\n@@ -228,18 +225,18 @@\n-        \/\/ Used by TLS 1.2 and TLS 1.3.\n-        private SSLPossession createClientPossession(\n-                ClientHandshakeContext chc, String keyType) {\n-            X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n-            String clientAlias = null;\n-            if (chc.conContext.transport instanceof SSLSocketImpl) {\n-                clientAlias = km.chooseClientAlias(\n-                        new String[] { keyType },\n-                        chc.peerSupportedAuthorities == null ? null :\n-                                chc.peerSupportedAuthorities.clone(),\n-                        (SSLSocket)chc.conContext.transport);\n-            } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n-                clientAlias = km.chooseEngineClientAlias(\n-                        new String[] { keyType },\n-                        chc.peerSupportedAuthorities == null ? null :\n-                                chc.peerSupportedAuthorities.clone(),\n-                        (SSLEngine)chc.conContext.transport);\n-            }\n+    \/\/ Used by TLS 1.2 and TLS 1.3.\n+    private static SSLPossession createClientPossession(\n+            ClientHandshakeContext chc, String[] keyTypes) {\n+        X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n+        String clientAlias = null;\n+        if (chc.conContext.transport instanceof SSLSocketImpl) {\n+            clientAlias = km.chooseClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    (SSLSocket) chc.conContext.transport);\n+        } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n+            clientAlias = km.chooseEngineClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    (SSLEngine) chc.conContext.transport);\n+        }\n@@ -247,5 +244,4 @@\n-            if (clientAlias == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\"No X.509 cert selected for \" + keyType);\n-                }\n-                return null;\n+        if (clientAlias == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\"No X.509 cert selected for \"\n+                        + Arrays.toString(keyTypes));\n@@ -253,0 +249,2 @@\n+            return null;\n+        }\n@@ -254,7 +252,5 @@\n-            PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n-            if (clientPrivateKey == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\n-                            clientAlias + \" is not a private key entry\");\n-                }\n-                return null;\n+        PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n+        if (clientPrivateKey == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\n+                        clientAlias + \" is not a private key entry\");\n@@ -262,0 +258,2 @@\n+            return null;\n+        }\n@@ -263,4 +261,4 @@\n-            X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n-            if ((clientCerts == null) || (clientCerts.length == 0)) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(clientAlias +\n+        X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n+        if ((clientCerts == null) || (clientCerts.length == 0)) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(clientAlias +\n@@ -268,2 +266,0 @@\n-                }\n-                return null;\n@@ -271,0 +267,2 @@\n+            return null;\n+        }\n@@ -272,9 +270,8 @@\n-            PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n-            if ((!clientPrivateKey.getAlgorithm().equals(keyType))\n-                    || (!clientPublicKey.getAlgorithm().equals(keyType))) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.fine(\n-                            clientAlias + \" private or public key is not of \" +\n-                            keyType + \" algorithm\");\n-                }\n-                return null;\n+        PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n+        if (!clientPrivateKey.getAlgorithm().equals(clientPublicKey.getAlgorithm())) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.fine(\n+                        clientAlias + \" private or public key is not of \" +\n+                                \"same algorithm: \" +\n+                                clientPrivateKey.getAlgorithm() + \" vs \" +\n+                                clientPublicKey.getAlgorithm());\n@@ -282,2 +279,1 @@\n-\n-            return new X509Possession(clientPrivateKey, clientCerts);\n+            return null;\n@@ -286,4 +282,8 @@\n-        private SSLPossession createServerPossession(\n-                ServerHandshakeContext shc, String keyType) {\n-            X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n-            String serverAlias = null;\n+        return new X509Possession(clientPrivateKey, clientCerts);\n+    }\n+\n+    private static SSLPossession createServerPossession(\n+            ServerHandshakeContext shc, String[] keyTypes) {\n+        X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n+        String serverAlias = null;\n+        for (String keyType : keyTypes) {\n@@ -294,1 +294,1 @@\n-                        (SSLSocket)shc.conContext.transport);\n+                        (SSLSocket) shc.conContext.transport);\n@@ -299,1 +299,1 @@\n-                        (SSLEngine)shc.conContext.transport);\n+                        (SSLEngine) shc.conContext.transport);\n@@ -306,1 +306,1 @@\n-                return null;\n+                continue;\n@@ -315,1 +315,1 @@\n-                return null;\n+                continue;\n@@ -324,1 +324,1 @@\n-                return null;\n+                continue;\n@@ -333,1 +333,1 @@\n-                            keyType + \" algorithm\");\n+                                    keyType + \" algorithm\");\n@@ -335,1 +335,1 @@\n-                return null;\n+                continue;\n@@ -347,1 +347,1 @@\n-                            \" public key is not an instance of ECPublicKey\");\n+                                \" public key is not an instance of ECPublicKey\");\n@@ -349,1 +349,1 @@\n-                    return null;\n+                    continue;\n@@ -357,1 +357,1 @@\n-                        ((ECPublicKey)serverPublicKey).getParams();\n+                        ((ECPublicKey) serverPublicKey).getParams();\n@@ -362,1 +362,1 @@\n-                        !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n+                                !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n@@ -366,2 +366,2 @@\n-                            \"Unsupported named group (\" + namedGroup +\n-                            \") used in the \" + serverAlias + \" certificate\");\n+                                \"Unsupported named group (\" + namedGroup +\n+                                        \") used in the \" + serverAlias + \" certificate\");\n@@ -370,1 +370,1 @@\n-                    return null;\n+                    continue;\n@@ -376,0 +376,1 @@\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":84,"deletions":83,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.ssl;\n-\n-import java.security.PrivateKey;\n-import java.security.PublicKey;\n-import java.security.cert.X509Certificate;\n-import java.security.interfaces.ECPublicKey;\n-import java.security.spec.ECParameterSpec;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.X509ExtendedKeyManager;\n-\n-class X509Authentications implements SSLAuthentication {\n-\n-    private final String[] keyTypes;\n-\n-    public X509Authentications(String[] keyTypes) {\n-        this.keyTypes = keyTypes;\n-    }\n-\n-    @Override\n-    public SSLPossession createPossession(HandshakeContext context) {\n-        if (context.sslConfig.isClientMode) {\n-            SSLPossession poss = createClientPossession(\n-                    (ClientHandshakeContext)context);\n-            if (poss != null) {\n-                return poss;\n-            }\n-        } else {\n-            SSLPossession poss = createServerPossession(\n-                    (ServerHandshakeContext)context);\n-            if (poss != null) {\n-                return poss;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    public SSLPossession createClientPossession(HandshakeContext handshakeContext) {\n-        ClientHandshakeContext chc = (ClientHandshakeContext)handshakeContext;\n-        X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n-        String clientAlias = null;\n-        if (chc.conContext.transport instanceof SSLSocketImpl) {\n-            clientAlias = km.chooseClientAlias(\n-                    keyTypes,\n-                    chc.peerSupportedAuthorities == null ? null :\n-                            chc.peerSupportedAuthorities.clone(),\n-                    (SSLSocket)chc.conContext.transport);\n-        } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n-            clientAlias = km.chooseEngineClientAlias(\n-                    keyTypes,\n-                    chc.peerSupportedAuthorities == null ? null :\n-                            chc.peerSupportedAuthorities.clone(),\n-                    (SSLEngine)chc.conContext.transport);\n-        }\n-\n-        if (clientAlias == null) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.finest(\"No X.509 cert selected for \");\n-            }\n-            return null;\n-        }\n-\n-        PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n-        if (clientPrivateKey == null) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.finest(\n-                        clientAlias + \" is not a private key entry\");\n-            }\n-            return null;\n-        }\n-\n-        X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n-        if ((clientCerts == null) || (clientCerts.length == 0)) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.finest(clientAlias +\n-                        \" is a private key entry with no cert chain stored\");\n-            }\n-            return null;\n-        }\n-\n-        PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n-        if (!clientPrivateKey.getAlgorithm().equals(clientPublicKey.getAlgorithm())) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.fine(\n-                        clientAlias + \" private or public key is not of \" +\n-                                \"keyType\" + \" algorithm\");\n-            }\n-            return null;\n-        }\n-\n-        return new X509Authentication.X509Possession(clientPrivateKey, clientCerts);\n-    }\n-\n-    private SSLPossession createServerPossession(ServerHandshakeContext shc) {\n-        X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n-        String serverAlias = null;\n-        for (String keyType : keyTypes) {\n-            if (shc.conContext.transport instanceof SSLSocketImpl) {\n-                serverAlias = km.chooseServerAlias(keyType,\n-                        shc.peerSupportedAuthorities == null ? null :\n-                                shc.peerSupportedAuthorities.clone(),\n-                        (SSLSocket) shc.conContext.transport);\n-            } else if (shc.conContext.transport instanceof SSLEngineImpl) {\n-                serverAlias = km.chooseEngineServerAlias(keyType,\n-                        shc.peerSupportedAuthorities == null ? null :\n-                                shc.peerSupportedAuthorities.clone(),\n-                        (SSLEngine) shc.conContext.transport);\n-            }\n-\n-            if (serverAlias == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\"No X.509 cert selected for \" + keyType);\n-                }\n-                continue;\n-            }\n-\n-            PrivateKey serverPrivateKey = km.getPrivateKey(serverAlias);\n-            if (serverPrivateKey == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\n-                            serverAlias + \" is not a private key entry\");\n-                }\n-                continue;\n-            }\n-\n-            X509Certificate[] serverCerts = km.getCertificateChain(serverAlias);\n-            if ((serverCerts == null) || (serverCerts.length == 0)) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\n-                            serverAlias + \" is not a certificate entry\");\n-                }\n-                continue;\n-            }\n-\n-            PublicKey serverPublicKey = serverCerts[0].getPublicKey();\n-            if ((!serverPrivateKey.getAlgorithm().equals(keyType))\n-                    || (!serverPublicKey.getAlgorithm().equals(keyType))) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.fine(\n-                            serverAlias + \" private or public key is not of \" +\n-                                    keyType + \" algorithm\");\n-                }\n-                continue;\n-            }\n-\n-            \/\/ For TLS 1.2 and prior versions, the public key of a EC cert\n-            \/\/ MUST use a curve and point format supported by the client.\n-            \/\/ But for TLS 1.3, signature algorithms are negotiated\n-            \/\/ independently via the \"signature_algorithms\" extension.\n-            if (!shc.negotiatedProtocol.useTLS13PlusSpec() &&\n-                    keyType.equals(\"EC\")) {\n-                if (!(serverPublicKey instanceof ECPublicKey)) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                        SSLLogger.warning(serverAlias +\n-                                \" public key is not an instance of ECPublicKey\");\n-                    }\n-                    continue;\n-                }\n-\n-                \/\/ For ECC certs, check whether we support the EC domain\n-                \/\/ parameters.  If the client sent a supported_groups\n-                \/\/ ClientHello extension, check against that too for\n-                \/\/ TLS 1.2 and prior versions.\n-                ECParameterSpec params =\n-                        ((ECPublicKey) serverPublicKey).getParams();\n-                NamedGroup namedGroup = NamedGroup.valueOf(params);\n-                if ((namedGroup == null) ||\n-                        (!SupportedGroupsExtension.SupportedGroups.isSupported(namedGroup)) ||\n-                        ((shc.clientRequestedNamedGroups != null) &&\n-                                !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n-\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                        SSLLogger.warning(\n-                                \"Unsupported named group (\" + namedGroup +\n-                                        \") used in the \" + serverAlias + \" certificate\");\n-                    }\n-\n-                    continue;\n-                }\n-            }\n-\n-            return new X509Authentication.X509Possession(serverPrivateKey, serverCerts);\n-        }\n-        return null;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentications.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -57,1 +57,2 @@\n- * @run main\/othervm MultipleChooseAlias\n+ * @run main\/othervm MultipleChooseAlias PKIX\n+ * @run main\/othervm MultipleChooseAlias SunX509\n@@ -62,0 +63,1 @@\n+    static String kmfAlgorithm = null;\n@@ -74,0 +76,1 @@\n+        kmfAlgorithm = args[0];\n@@ -99,1 +102,1 @@\n-                fac = KeyManagerFactory.getInstance(\"SunX509\");\n+                fac = KeyManagerFactory.getInstance(kmfAlgorithm);\n@@ -167,1 +170,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLContextImpl\/MultipleChooseAlias.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}