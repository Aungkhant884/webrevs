{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.LinkedHashSet;\n@@ -1046,0 +1047,1 @@\n+            LinkedHashSet<String> allAuths = new LinkedHashSet<>();\n@@ -1071,1 +1073,1 @@\n-                SSLAuthentication ka = X509Authentication.valueOf(ss);\n+                X509Authentication ka = X509Authentication.valueOf(ss);\n@@ -1080,11 +1082,1 @@\n-\n-                SSLPossession pos = ka.createPossession(hc);\n-                if (pos == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unavailable authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                return pos;\n+                allAuths.add(ss.keyAlgorithm);\n@@ -1093,2 +1085,7 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\"No available authentication scheme\");\n+            SSLPossession pos = X509Authentication\n+                    .createPossession(hc, allAuths.toArray(String[]::new));\n+            if (pos == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                            \"Unavailable authentication scheme: \" + allAuths);\n+                }\n@@ -1096,1 +1093,1 @@\n-            return null;\n+            return pos;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.LinkedHashSet;\n@@ -734,0 +735,1 @@\n+            LinkedHashSet<String> allAuths = new LinkedHashSet<>();\n@@ -759,1 +761,1 @@\n-                SSLAuthentication ka = X509Authentication.valueOf(ss);\n+                X509Authentication ka = X509Authentication.valueOf(ss);\n@@ -768,11 +770,1 @@\n-\n-                SSLPossession pos = ka.createPossession(hc);\n-                if (pos == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unavailable authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                return pos;\n+                allAuths.add(ss.keyAlgorithm);\n@@ -781,2 +773,7 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\"No available authentication scheme\");\n+            SSLPossession pos = X509Authentication\n+                    .createPossession(hc, allAuths.toArray(String[]::new));\n+            if (pos == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                            \"Unavailable authentication scheme: \" + allAuths);\n+                }\n@@ -784,1 +781,1 @@\n-            return null;\n+            return pos;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -42,0 +44,1 @@\n+\n@@ -207,17 +210,3 @@\n-            if (context.sslConfig.isClientMode) {\n-                for (String keyType : keyTypes) {\n-                    SSLPossession poss = createClientPossession(\n-                            (ClientHandshakeContext)context, keyType);\n-                    if (poss != null) {\n-                        return poss;\n-                    }\n-                }\n-            } else {\n-                for (String keyType : keyTypes) {\n-                    SSLPossession poss = createServerPossession(\n-                            (ServerHandshakeContext)context, keyType);\n-                    if (poss != null) {\n-                        return poss;\n-                    }\n-                }\n-            }\n+            return X509Authentication.createPossession(context, keyTypes);\n+        }\n+    }\n@@ -225,1 +214,8 @@\n-            return null;\n+    public static SSLPossession createPossession(\n+            HandshakeContext context, String[] keyTypes) {\n+        if (context.sslConfig.isClientMode) {\n+            return createClientPossession(\n+                    (ClientHandshakeContext) context, keyTypes);\n+        } else {\n+            return createServerPossession(\n+                    (ServerHandshakeContext) context, keyTypes);\n@@ -227,0 +223,1 @@\n+    }\n@@ -228,18 +225,18 @@\n-        \/\/ Used by TLS 1.2 and TLS 1.3.\n-        private SSLPossession createClientPossession(\n-                ClientHandshakeContext chc, String keyType) {\n-            X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n-            String clientAlias = null;\n-            if (chc.conContext.transport instanceof SSLSocketImpl) {\n-                clientAlias = km.chooseClientAlias(\n-                        new String[] { keyType },\n-                        chc.peerSupportedAuthorities == null ? null :\n-                                chc.peerSupportedAuthorities.clone(),\n-                        (SSLSocket)chc.conContext.transport);\n-            } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n-                clientAlias = km.chooseEngineClientAlias(\n-                        new String[] { keyType },\n-                        chc.peerSupportedAuthorities == null ? null :\n-                                chc.peerSupportedAuthorities.clone(),\n-                        (SSLEngine)chc.conContext.transport);\n-            }\n+    \/\/ Used by TLS 1.2 and TLS 1.3.\n+    private static SSLPossession createClientPossession(\n+            ClientHandshakeContext chc, String[] keyTypes) {\n+        X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n+        String clientAlias = null;\n+        if (chc.conContext.transport instanceof SSLSocketImpl) {\n+            clientAlias = km.chooseClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    (SSLSocket) chc.conContext.transport);\n+        } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n+            clientAlias = km.chooseEngineClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    (SSLEngine) chc.conContext.transport);\n+        }\n@@ -247,5 +244,4 @@\n-            if (clientAlias == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\"No X.509 cert selected for \" + keyType);\n-                }\n-                return null;\n+        if (clientAlias == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\"No X.509 cert selected for \"\n+                        + Arrays.toString(keyTypes));\n@@ -253,0 +249,2 @@\n+            return null;\n+        }\n@@ -254,7 +252,5 @@\n-            PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n-            if (clientPrivateKey == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\n-                            clientAlias + \" is not a private key entry\");\n-                }\n-                return null;\n+        PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n+        if (clientPrivateKey == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\n+                        clientAlias + \" is not a private key entry\");\n@@ -262,0 +258,2 @@\n+            return null;\n+        }\n@@ -263,4 +261,4 @@\n-            X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n-            if ((clientCerts == null) || (clientCerts.length == 0)) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(clientAlias +\n+        X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n+        if ((clientCerts == null) || (clientCerts.length == 0)) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(clientAlias +\n@@ -268,2 +266,0 @@\n-                }\n-                return null;\n@@ -271,0 +267,2 @@\n+            return null;\n+        }\n@@ -272,9 +270,8 @@\n-            PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n-            if ((!clientPrivateKey.getAlgorithm().equals(keyType))\n-                    || (!clientPublicKey.getAlgorithm().equals(keyType))) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.fine(\n-                            clientAlias + \" private or public key is not of \" +\n-                            keyType + \" algorithm\");\n-                }\n-                return null;\n+        PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n+        if (!clientPrivateKey.getAlgorithm().equals(clientPublicKey.getAlgorithm())) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.fine(\n+                        clientAlias + \" private or public key is not of \" +\n+                                \"same algorithm: \" +\n+                                clientPrivateKey.getAlgorithm() + \" vs \" +\n+                                clientPublicKey.getAlgorithm());\n@@ -282,2 +279,1 @@\n-\n-            return new X509Possession(clientPrivateKey, clientCerts);\n+            return null;\n@@ -286,4 +282,8 @@\n-        private SSLPossession createServerPossession(\n-                ServerHandshakeContext shc, String keyType) {\n-            X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n-            String serverAlias = null;\n+        return new X509Possession(clientPrivateKey, clientCerts);\n+    }\n+\n+    private static SSLPossession createServerPossession(\n+            ServerHandshakeContext shc, String[] keyTypes) {\n+        X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n+        String serverAlias = null;\n+        for (String keyType : keyTypes) {\n@@ -294,1 +294,1 @@\n-                        (SSLSocket)shc.conContext.transport);\n+                        (SSLSocket) shc.conContext.transport);\n@@ -299,1 +299,1 @@\n-                        (SSLEngine)shc.conContext.transport);\n+                        (SSLEngine) shc.conContext.transport);\n@@ -306,1 +306,1 @@\n-                return null;\n+                continue;\n@@ -315,1 +315,1 @@\n-                return null;\n+                continue;\n@@ -324,1 +324,1 @@\n-                return null;\n+                continue;\n@@ -333,1 +333,1 @@\n-                            keyType + \" algorithm\");\n+                                    keyType + \" algorithm\");\n@@ -335,1 +335,1 @@\n-                return null;\n+                continue;\n@@ -347,1 +347,1 @@\n-                            \" public key is not an instance of ECPublicKey\");\n+                                \" public key is not an instance of ECPublicKey\");\n@@ -349,1 +349,1 @@\n-                    return null;\n+                    continue;\n@@ -357,1 +357,1 @@\n-                        ((ECPublicKey)serverPublicKey).getParams();\n+                        ((ECPublicKey) serverPublicKey).getParams();\n@@ -362,1 +362,1 @@\n-                        !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n+                                !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n@@ -366,2 +366,2 @@\n-                            \"Unsupported named group (\" + namedGroup +\n-                            \") used in the \" + serverAlias + \" certificate\");\n+                                \"Unsupported named group (\" + namedGroup +\n+                                        \") used in the \" + serverAlias + \" certificate\");\n@@ -370,1 +370,1 @@\n-                    return null;\n+                    continue;\n@@ -376,0 +376,1 @@\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":84,"deletions":83,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.X509KeyManager;\n+import java.net.Socket;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8262186\n+ * @summary Callback semantics of the method X509KeyManager.chooseClientAlias(...)\n+ * @library \/javax\/net\/ssl\/templates\n+ * @modules java.base\/sun.security.ssl:+open\n+ *          java.base\/javax.net.ssl:+open\n+ * @run main\/othervm MultipleChooseAlias PKIX\n+ * @run main\/othervm MultipleChooseAlias SunX509\n+ *\/\n+public class MultipleChooseAlias extends SSLSocketTemplate {\n+\n+    static volatile int numOfCalls = 0;\n+    static String kmfAlgorithm = null;\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(true);\n+    }\n+\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLS\", \"PKIX\", \"Mine\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        kmfAlgorithm = args[0];\n+        Security.addProvider(new MyProvider());\n+        try {\n+            new MultipleChooseAlias().run();\n+        } catch (Exception e) {\n+            \/\/ expected\n+        }\n+        if (numOfCalls != 1) {\n+            throw new RuntimeException(\"Too many times \" + numOfCalls);\n+        }\n+    }\n+\n+    static class MyProvider extends Provider {\n+        public MyProvider() {\n+            super(\"Mine\", \"1\", \"many many things\");\n+            put(\"KeyManagerFactory.Mine\", \"MultipleChooseAlias$MyKMF\");\n+        }\n+    }\n+\n+    \/\/ This KeyManagerFactory impl returns key managers\n+    \/\/ wrapped in MyKM\n+    public static class MyKMF extends KeyManagerFactorySpi {\n+        KeyManagerFactory fac;\n+\n+        public MyKMF() {\n+            try {\n+                fac = KeyManagerFactory.getInstance(kmfAlgorithm);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        @Override\n+        protected void engineInit(KeyStore ks, char[] password)\n+                throws KeyStoreException, NoSuchAlgorithmException,\n+                UnrecoverableKeyException {\n+            fac.init(ks, password);\n+        }\n+\n+        @Override\n+        protected void engineInit(ManagerFactoryParameters spec)\n+                throws InvalidAlgorithmParameterException {\n+            fac.init(spec);\n+        }\n+\n+        @Override\n+        protected KeyManager[] engineGetKeyManagers() {\n+            KeyManager[] result = fac.getKeyManagers();\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MyKM((X509KeyManager)result[i]);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    \/\/ This KeyManager remembers how many times  chooseClientAlias is called.\n+    static class MyKM implements X509KeyManager {\n+\n+        X509KeyManager km;\n+\n+        MyKM(X509KeyManager km) {\n+            this.km = km;\n+        }\n+\n+        public String[] getClientAliases(String keyType, Principal[] issuers) {\n+            return km.getClientAliases(keyType, issuers);\n+        }\n+\n+        public String chooseClientAlias(String[] keyType, Principal[] issuers,\n+                Socket socket) {\n+            System.out.println(\"chooseClientAlias called on \"\n+                    + Arrays.toString(keyType));\n+            numOfCalls++;\n+            return null; \/\/ so it will try all key types and finally fails\n+        }\n+\n+        public String[] getServerAliases(String keyType, Principal[] issuers) {\n+            return getServerAliases(keyType, issuers);\n+        }\n+\n+        public String chooseServerAlias(String keyType, Principal[] issuers,\n+                Socket socket) {\n+            return km.chooseServerAlias(keyType, issuers, socket);\n+        }\n+\n+        public X509Certificate[] getCertificateChain(String alias) {\n+            return km.getCertificateChain(alias);\n+        }\n+\n+        public PrivateKey getPrivateKey(String alias) {\n+            return km.getPrivateKey(alias);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLContextImpl\/MultipleChooseAlias.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}