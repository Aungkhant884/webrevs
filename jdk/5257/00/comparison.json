{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.LinkedHashSet;\n@@ -1046,0 +1047,1 @@\n+            LinkedHashSet<String> allAuths = new LinkedHashSet<>();\n@@ -1071,1 +1073,1 @@\n-                SSLAuthentication ka = X509Authentication.valueOf(ss);\n+                X509Authentication ka = X509Authentication.valueOf(ss);\n@@ -1080,11 +1082,1 @@\n-\n-                SSLPossession pos = ka.createPossession(hc);\n-                if (pos == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unavailable authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                return pos;\n+                allAuths.add(ss.keyAlgorithm);\n@@ -1093,2 +1085,9 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\"No available authentication scheme\");\n+            X509Authentications ka\n+                    = new X509Authentications(allAuths.toArray(String[]::new));\n+            SSLPossession pos = ka.createPossession(hc);\n+            if (pos == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                            \"Unavailable authentication scheme: \" + allAuths);\n+                }\n+                return null;\n@@ -1096,1 +1095,1 @@\n-            return null;\n+            return pos;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.LinkedHashSet;\n@@ -734,0 +735,1 @@\n+            LinkedHashSet<String> allAuths = new LinkedHashSet<>();\n@@ -759,1 +761,1 @@\n-                SSLAuthentication ka = X509Authentication.valueOf(ss);\n+                X509Authentication ka = X509Authentication.valueOf(ss);\n@@ -768,11 +770,1 @@\n-\n-                SSLPossession pos = ka.createPossession(hc);\n-                if (pos == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unavailable authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                return pos;\n+                allAuths.add(ss.keyAlgorithm);\n@@ -781,2 +773,8 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\"No available authentication scheme\");\n+            X509Authentications ka = new X509Authentications(allAuths.toArray(String[]::new));\n+            SSLPossession pos = ka.createPossession(hc);\n+            if (pos == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                            \"Unavailable authentication scheme: \" + allAuths);\n+                }\n+                return null;\n@@ -784,1 +782,1 @@\n-            return null;\n+            return pos;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.spec.ECParameterSpec;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+class X509Authentications implements SSLAuthentication {\n+\n+    private final String[] keyTypes;\n+\n+    public X509Authentications(String[] keyTypes) {\n+        this.keyTypes = keyTypes;\n+    }\n+\n+    @Override\n+    public SSLPossession createPossession(HandshakeContext context) {\n+        if (context.sslConfig.isClientMode) {\n+            SSLPossession poss = createClientPossession(\n+                    (ClientHandshakeContext)context);\n+            if (poss != null) {\n+                return poss;\n+            }\n+        } else {\n+            SSLPossession poss = createServerPossession(\n+                    (ServerHandshakeContext)context);\n+            if (poss != null) {\n+                return poss;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public SSLPossession createClientPossession(HandshakeContext handshakeContext) {\n+        ClientHandshakeContext chc = (ClientHandshakeContext)handshakeContext;\n+        X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n+        String clientAlias = null;\n+        if (chc.conContext.transport instanceof SSLSocketImpl) {\n+            clientAlias = km.chooseClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    (SSLSocket)chc.conContext.transport);\n+        } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n+            clientAlias = km.chooseEngineClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    (SSLEngine)chc.conContext.transport);\n+        }\n+\n+        if (clientAlias == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\"No X.509 cert selected for \");\n+            }\n+            return null;\n+        }\n+\n+        PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n+        if (clientPrivateKey == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\n+                        clientAlias + \" is not a private key entry\");\n+            }\n+            return null;\n+        }\n+\n+        X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n+        if ((clientCerts == null) || (clientCerts.length == 0)) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(clientAlias +\n+                        \" is a private key entry with no cert chain stored\");\n+            }\n+            return null;\n+        }\n+\n+        PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n+        if (!clientPrivateKey.getAlgorithm().equals(clientPublicKey.getAlgorithm())) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.fine(\n+                        clientAlias + \" private or public key is not of \" +\n+                                \"keyType\" + \" algorithm\");\n+            }\n+            return null;\n+        }\n+\n+        return new X509Authentication.X509Possession(clientPrivateKey, clientCerts);\n+    }\n+\n+    private SSLPossession createServerPossession(ServerHandshakeContext shc) {\n+        X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n+        String serverAlias = null;\n+        for (String keyType : keyTypes) {\n+            if (shc.conContext.transport instanceof SSLSocketImpl) {\n+                serverAlias = km.chooseServerAlias(keyType,\n+                        shc.peerSupportedAuthorities == null ? null :\n+                                shc.peerSupportedAuthorities.clone(),\n+                        (SSLSocket) shc.conContext.transport);\n+            } else if (shc.conContext.transport instanceof SSLEngineImpl) {\n+                serverAlias = km.chooseEngineServerAlias(keyType,\n+                        shc.peerSupportedAuthorities == null ? null :\n+                                shc.peerSupportedAuthorities.clone(),\n+                        (SSLEngine) shc.conContext.transport);\n+            }\n+\n+            if (serverAlias == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.finest(\"No X.509 cert selected for \" + keyType);\n+                }\n+                continue;\n+            }\n+\n+            PrivateKey serverPrivateKey = km.getPrivateKey(serverAlias);\n+            if (serverPrivateKey == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.finest(\n+                            serverAlias + \" is not a private key entry\");\n+                }\n+                continue;\n+            }\n+\n+            X509Certificate[] serverCerts = km.getCertificateChain(serverAlias);\n+            if ((serverCerts == null) || (serverCerts.length == 0)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.finest(\n+                            serverAlias + \" is not a certificate entry\");\n+                }\n+                continue;\n+            }\n+\n+            PublicKey serverPublicKey = serverCerts[0].getPublicKey();\n+            if ((!serverPrivateKey.getAlgorithm().equals(keyType))\n+                    || (!serverPublicKey.getAlgorithm().equals(keyType))) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.fine(\n+                            serverAlias + \" private or public key is not of \" +\n+                                    keyType + \" algorithm\");\n+                }\n+                continue;\n+            }\n+\n+            \/\/ For TLS 1.2 and prior versions, the public key of a EC cert\n+            \/\/ MUST use a curve and point format supported by the client.\n+            \/\/ But for TLS 1.3, signature algorithms are negotiated\n+            \/\/ independently via the \"signature_algorithms\" extension.\n+            if (!shc.negotiatedProtocol.useTLS13PlusSpec() &&\n+                    keyType.equals(\"EC\")) {\n+                if (!(serverPublicKey instanceof ECPublicKey)) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.warning(serverAlias +\n+                                \" public key is not an instance of ECPublicKey\");\n+                    }\n+                    continue;\n+                }\n+\n+                \/\/ For ECC certs, check whether we support the EC domain\n+                \/\/ parameters.  If the client sent a supported_groups\n+                \/\/ ClientHello extension, check against that too for\n+                \/\/ TLS 1.2 and prior versions.\n+                ECParameterSpec params =\n+                        ((ECPublicKey) serverPublicKey).getParams();\n+                NamedGroup namedGroup = NamedGroup.valueOf(params);\n+                if ((namedGroup == null) ||\n+                        (!SupportedGroupsExtension.SupportedGroups.isSupported(namedGroup)) ||\n+                        ((shc.clientRequestedNamedGroups != null) &&\n+                                !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n+\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.warning(\n+                                \"Unsupported named group (\" + namedGroup +\n+                                        \") used in the \" + serverAlias + \" certificate\");\n+                    }\n+\n+                    continue;\n+                }\n+            }\n+\n+            return new X509Authentication.X509Possession(serverPrivateKey, serverCerts);\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentications.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.X509KeyManager;\n+import java.net.Socket;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8262186\n+ * @summary Callback semantics of the method X509KeyManager.chooseClientAlias(...)\n+ * @library \/javax\/net\/ssl\/templates\n+ * @modules java.base\/sun.security.ssl:+open\n+ *          java.base\/javax.net.ssl:+open\n+ * @run main\/othervm MultipleChooseAlias\n+ *\/\n+public class MultipleChooseAlias extends SSLSocketTemplate {\n+\n+    static volatile int numOfCalls = 0;\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(true);\n+    }\n+\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLS\", \"PKIX\", \"Mine\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new MyProvider());\n+        try {\n+            new MultipleChooseAlias().run();\n+        } catch (Exception e) {\n+            \/\/ expected\n+        }\n+        if (numOfCalls != 1) {\n+            throw new RuntimeException(\"Too many times \" + numOfCalls);\n+        }\n+    }\n+\n+    static class MyProvider extends Provider {\n+        public MyProvider() {\n+            super(\"Mine\", \"1\", \"many many things\");\n+            put(\"KeyManagerFactory.Mine\", \"MultipleChooseAlias$MyKMF\");\n+        }\n+    }\n+\n+    \/\/ This KeyManagerFactory impl returns key managers\n+    \/\/ wrapped in MyKM\n+    public static class MyKMF extends KeyManagerFactorySpi {\n+        KeyManagerFactory fac;\n+\n+        public MyKMF() {\n+            try {\n+                fac = KeyManagerFactory.getInstance(\"SunX509\");\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        @Override\n+        protected void engineInit(KeyStore ks, char[] password)\n+                throws KeyStoreException, NoSuchAlgorithmException,\n+                UnrecoverableKeyException {\n+            fac.init(ks, password);\n+        }\n+\n+        @Override\n+        protected void engineInit(ManagerFactoryParameters spec)\n+                throws InvalidAlgorithmParameterException {\n+            fac.init(spec);\n+        }\n+\n+        @Override\n+        protected KeyManager[] engineGetKeyManagers() {\n+            KeyManager[] result = fac.getKeyManagers();\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MyKM((X509KeyManager)result[i]);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    \/\/ This KeyManager remembers how many times  chooseClientAlias is called.\n+    static class MyKM implements X509KeyManager {\n+\n+        X509KeyManager km;\n+\n+        MyKM(X509KeyManager km) {\n+            this.km = km;\n+        }\n+\n+        public String[] getClientAliases(String keyType, Principal[] issuers) {\n+            return km.getClientAliases(keyType, issuers);\n+        }\n+\n+        public String chooseClientAlias(String[] keyType, Principal[] issuers,\n+                Socket socket) {\n+            System.out.println(\"chooseClientAlias called on \"\n+                    + Arrays.toString(keyType));\n+            numOfCalls++;\n+            return null; \/\/ so it will try all key types and finally fails\n+        }\n+\n+        public String[] getServerAliases(String keyType, Principal[] issuers) {\n+            return getServerAliases(keyType, issuers);\n+        }\n+\n+        public String chooseServerAlias(String keyType, Principal[] issuers,\n+                Socket socket) {\n+            return km.chooseServerAlias(keyType, issuers, socket);\n+        }\n+\n+        public X509Certificate[] getCertificateChain(String alias) {\n+            return km.getCertificateChain(alias);\n+        }\n+\n+        public PrivateKey getPrivateKey(String alias) {\n+            return km.getPrivateKey(alias);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLContextImpl\/MultipleChooseAlias.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"}]}