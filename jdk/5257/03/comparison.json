{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1046,0 +1046,1 @@\n+            List<String> supportedKeyTypes = new ArrayList<>();\n@@ -1054,0 +1055,1 @@\n+                checkedKeyTypes.add(ss.keyAlgorithm);\n@@ -1067,1 +1069,0 @@\n-                    checkedKeyTypes.add(ss.keyAlgorithm);\n@@ -1071,1 +1072,1 @@\n-                SSLAuthentication ka = X509Authentication.valueOf(ss);\n+                X509Authentication ka = X509Authentication.valueOf(ss);\n@@ -1077,1 +1078,0 @@\n-                    checkedKeyTypes.add(ss.keyAlgorithm);\n@@ -1080,11 +1080,1 @@\n-\n-                SSLPossession pos = ka.createPossession(hc);\n-                if (pos == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unavailable authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                return pos;\n+                supportedKeyTypes.add(ss.keyAlgorithm);\n@@ -1093,2 +1083,6 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\"No available authentication scheme\");\n+            SSLPossession pos = X509Authentication\n+                    .createPossession(hc, supportedKeyTypes.toArray(String[]::new));\n+            if (pos == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\"No available authentication scheme\");\n+                }\n@@ -1096,1 +1090,1 @@\n-            return null;\n+            return pos;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -734,0 +734,1 @@\n+            List<String> supportedKeyTypes = new ArrayList<>();\n@@ -742,0 +743,1 @@\n+                checkedKeyTypes.add(ss.keyAlgorithm);\n@@ -755,1 +757,0 @@\n-                    checkedKeyTypes.add(ss.keyAlgorithm);\n@@ -759,1 +760,1 @@\n-                SSLAuthentication ka = X509Authentication.valueOf(ss);\n+                X509Authentication ka = X509Authentication.valueOf(ss);\n@@ -765,1 +766,0 @@\n-                    checkedKeyTypes.add(ss.keyAlgorithm);\n@@ -768,11 +768,1 @@\n-\n-                SSLPossession pos = ka.createPossession(hc);\n-                if (pos == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unavailable authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                return pos;\n+                supportedKeyTypes.add(ss.keyAlgorithm);\n@@ -781,2 +771,6 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                SSLLogger.warning(\"No available authentication scheme\");\n+            SSLPossession pos = X509Authentication\n+                    .createPossession(hc, supportedKeyTypes.toArray(String[]::new));\n+            if (pos == null) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\"No available authentication scheme\");\n+                }\n@@ -784,1 +778,1 @@\n-            return null;\n+            return pos;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.Arrays;\n@@ -39,2 +40,0 @@\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLSocket;\n@@ -42,0 +41,1 @@\n+\n@@ -46,2 +46,1 @@\n-    RSA         (\"RSA\",         new X509PossessionGenerator(\n-                                    new String[]{\"RSA\"})),\n+    RSA         (\"RSA\",         \"RSA\"),\n@@ -50,2 +49,1 @@\n-    RSASSA_PSS  (\"RSASSA-PSS\",  new X509PossessionGenerator(\n-                                    new String[] {\"RSASSA-PSS\"})),\n+    RSASSA_PSS  (\"RSASSA-PSS\",  \"RSASSA-PSS\"),\n@@ -58,2 +56,1 @@\n-    RSA_OR_PSS  (\"RSA_OR_PSS\",  new X509PossessionGenerator(\n-                                    new String[] {\"RSA\", \"RSASSA-PSS\"})),\n+    RSA_OR_PSS  (\"RSA_OR_PSS\",  \"RSA\", \"RSASSA-PSS\"),\n@@ -62,2 +59,1 @@\n-    DSA         (\"DSA\",         new X509PossessionGenerator(\n-                                    new String[] {\"DSA\"})),\n+    DSA         (\"DSA\",         \"DSA\"),\n@@ -66,2 +62,1 @@\n-    EC          (\"EC\",          new X509PossessionGenerator(\n-                                    new String[] {\"EC\"})),\n+    EC          (\"EC\",          \"EC\"),\n@@ -69,2 +64,1 @@\n-    EDDSA       (\"EdDSA\",       new X509PossessionGenerator(\n-                                    new String[] {\"EdDSA\"}));\n+    EDDSA       (\"EdDSA\",       \"EdDSA\");\n@@ -72,2 +66,2 @@\n-    final String keyType;\n-    final SSLPossessionGenerator possessionGenerator;\n+    final String keyAlgorithm;\n+    final String[] keyTypes;\n@@ -75,4 +69,4 @@\n-    private X509Authentication(String keyType,\n-            SSLPossessionGenerator possessionGenerator) {\n-        this.keyType = keyType;\n-        this.possessionGenerator = possessionGenerator;\n+    private X509Authentication(String keyAlgorithm,\n+            String... keyTypes) {\n+        this.keyAlgorithm = keyAlgorithm;\n+        this.keyTypes = keyTypes;\n@@ -83,1 +77,1 @@\n-            if (au.keyType.equals(signatureScheme.keyAlgorithm)) {\n+            if (au.keyAlgorithm.equals(signatureScheme.keyAlgorithm)) {\n@@ -93,1 +87,1 @@\n-        return possessionGenerator.createPossession(handshakeContext);\n+        return X509Authentication.createPossession(handshakeContext, keyTypes);\n@@ -197,3 +191,10 @@\n-    private static final\n-            class X509PossessionGenerator implements SSLPossessionGenerator {\n-        private final String[] keyTypes;\n+    public static SSLPossession createPossession(\n+            HandshakeContext context, String[] keyTypes) {\n+        if (context.sslConfig.isClientMode) {\n+            return createClientPossession(\n+                    (ClientHandshakeContext) context, keyTypes);\n+        } else {\n+            return createServerPossession(\n+                    (ServerHandshakeContext) context, keyTypes);\n+        }\n+    }\n@@ -201,2 +202,17 @@\n-        private X509PossessionGenerator(String[] keyTypes) {\n-            this.keyTypes = keyTypes;\n+    \/\/ Used by TLS 1.2 and TLS 1.3.\n+    private static SSLPossession createClientPossession(\n+            ClientHandshakeContext chc, String[] keyTypes) {\n+        X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n+        String clientAlias = null;\n+        if (chc.conContext.transport instanceof SSLSocketImpl socket) {\n+            clientAlias = km.chooseClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    socket);\n+        } else if (chc.conContext.transport instanceof SSLEngineImpl engine) {\n+            clientAlias = km.chooseEngineClientAlias(\n+                    keyTypes,\n+                    chc.peerSupportedAuthorities == null ? null :\n+                            chc.peerSupportedAuthorities.clone(),\n+                    engine);\n@@ -205,18 +221,4 @@\n-        @Override\n-        public SSLPossession createPossession(HandshakeContext context) {\n-            if (context.sslConfig.isClientMode) {\n-                for (String keyType : keyTypes) {\n-                    SSLPossession poss = createClientPossession(\n-                            (ClientHandshakeContext)context, keyType);\n-                    if (poss != null) {\n-                        return poss;\n-                    }\n-                }\n-            } else {\n-                for (String keyType : keyTypes) {\n-                    SSLPossession poss = createServerPossession(\n-                            (ServerHandshakeContext)context, keyType);\n-                    if (poss != null) {\n-                        return poss;\n-                    }\n-                }\n+        if (clientAlias == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\"No X.509 cert selected for \"\n+                        + Arrays.toString(keyTypes));\n@@ -224,1 +226,0 @@\n-\n@@ -228,33 +229,5 @@\n-        \/\/ Used by TLS 1.2 and TLS 1.3.\n-        private SSLPossession createClientPossession(\n-                ClientHandshakeContext chc, String keyType) {\n-            X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();\n-            String clientAlias = null;\n-            if (chc.conContext.transport instanceof SSLSocketImpl) {\n-                clientAlias = km.chooseClientAlias(\n-                        new String[] { keyType },\n-                        chc.peerSupportedAuthorities == null ? null :\n-                                chc.peerSupportedAuthorities.clone(),\n-                        (SSLSocket)chc.conContext.transport);\n-            } else if (chc.conContext.transport instanceof SSLEngineImpl) {\n-                clientAlias = km.chooseEngineClientAlias(\n-                        new String[] { keyType },\n-                        chc.peerSupportedAuthorities == null ? null :\n-                                chc.peerSupportedAuthorities.clone(),\n-                        (SSLEngine)chc.conContext.transport);\n-            }\n-\n-            if (clientAlias == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\"No X.509 cert selected for \" + keyType);\n-                }\n-                return null;\n-            }\n-\n-            PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n-            if (clientPrivateKey == null) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(\n-                            clientAlias + \" is not a private key entry\");\n-                }\n-                return null;\n+        PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);\n+        if (clientPrivateKey == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(\n+                        clientAlias + \" is not a private key entry\");\n@@ -262,0 +235,2 @@\n+            return null;\n+        }\n@@ -263,4 +238,4 @@\n-            X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n-            if ((clientCerts == null) || (clientCerts.length == 0)) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.finest(clientAlias +\n+        X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);\n+        if ((clientCerts == null) || (clientCerts.length == 0)) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.finest(clientAlias +\n@@ -268,2 +243,0 @@\n-                }\n-                return null;\n@@ -271,0 +244,2 @@\n+            return null;\n+        }\n@@ -272,9 +247,6 @@\n-            PublicKey clientPublicKey = clientCerts[0].getPublicKey();\n-            if ((!clientPrivateKey.getAlgorithm().equals(keyType))\n-                    || (!clientPublicKey.getAlgorithm().equals(keyType))) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.fine(\n-                            clientAlias + \" private or public key is not of \" +\n-                            keyType + \" algorithm\");\n-                }\n-                return null;\n+        String privateKeyAlgorithm = clientPrivateKey.getAlgorithm();\n+        if (!Arrays.asList(keyTypes).contains(privateKeyAlgorithm)) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.fine(\n+                        clientAlias + \" private key algorithm \" +\n+                                privateKeyAlgorithm + \" not in request list\");\n@@ -282,0 +254,2 @@\n+            return null;\n+        }\n@@ -283,1 +257,10 @@\n-            return new X509Possession(clientPrivateKey, clientCerts);\n+        String publicKeyAlgorithm = clientCerts[0].getPublicKey().getAlgorithm();\n+        if (!privateKeyAlgorithm.equals(publicKeyAlgorithm)) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                SSLLogger.fine(\n+                        clientAlias + \" private or public key is not of \" +\n+                                \"same algorithm: \" +\n+                                privateKeyAlgorithm + \" vs \" +\n+                                publicKeyAlgorithm);\n+            }\n+            return null;\n@@ -286,5 +269,9 @@\n-        private SSLPossession createServerPossession(\n-                ServerHandshakeContext shc, String keyType) {\n-            X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n-            String serverAlias = null;\n-            if (shc.conContext.transport instanceof SSLSocketImpl) {\n+        return new X509Possession(clientPrivateKey, clientCerts);\n+    }\n+\n+    private static SSLPossession createServerPossession(\n+            ServerHandshakeContext shc, String[] keyTypes) {\n+        X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();\n+        String serverAlias = null;\n+        for (String keyType : keyTypes) {\n+            if (shc.conContext.transport instanceof SSLSocketImpl socket) {\n@@ -294,2 +281,2 @@\n-                        (SSLSocket)shc.conContext.transport);\n-            } else if (shc.conContext.transport instanceof SSLEngineImpl) {\n+                        socket);\n+            } else if (shc.conContext.transport instanceof SSLEngineImpl engine) {\n@@ -299,1 +286,1 @@\n-                        (SSLEngine)shc.conContext.transport);\n+                        engine);\n@@ -306,1 +293,1 @@\n-                return null;\n+                continue;\n@@ -315,1 +302,1 @@\n-                return null;\n+                continue;\n@@ -324,1 +311,1 @@\n-                return null;\n+                continue;\n@@ -333,1 +320,1 @@\n-                            keyType + \" algorithm\");\n+                                    keyType + \" algorithm\");\n@@ -335,1 +322,1 @@\n-                return null;\n+                continue;\n@@ -347,1 +334,1 @@\n-                            \" public key is not an instance of ECPublicKey\");\n+                                \" public key is not an instance of ECPublicKey\");\n@@ -349,1 +336,1 @@\n-                    return null;\n+                    continue;\n@@ -357,1 +344,1 @@\n-                        ((ECPublicKey)serverPublicKey).getParams();\n+                        ((ECPublicKey) serverPublicKey).getParams();\n@@ -362,1 +349,1 @@\n-                        !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n+                                !shc.clientRequestedNamedGroups.contains(namedGroup))) {\n@@ -366,2 +353,2 @@\n-                            \"Unsupported named group (\" + namedGroup +\n-                            \") used in the \" + serverAlias + \" certificate\");\n+                                \"Unsupported named group (\" + namedGroup +\n+                                        \") used in the \" + serverAlias + \" certificate\");\n@@ -370,1 +357,1 @@\n-                    return null;\n+                    continue;\n@@ -376,0 +363,1 @@\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":104,"deletions":116,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.X509KeyManager;\n+import java.net.Socket;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8262186\n+ * @summary Callback semantics of the method X509KeyManager.chooseClientAlias(...)\n+ * @library \/javax\/net\/ssl\/templates\n+ * @modules java.base\/sun.security.ssl:+open\n+ *          java.base\/javax.net.ssl:+open\n+ * @run main\/othervm MultipleChooseAlias PKIX\n+ * @run main\/othervm MultipleChooseAlias SunX509\n+ *\/\n+public class MultipleChooseAlias extends SSLSocketTemplate {\n+\n+    static volatile int numOfCalls = 0;\n+    static String kmfAlgorithm = null;\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(true);\n+    }\n+\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLS\", \"PKIX\", \"Mine\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        kmfAlgorithm = args[0];\n+        Security.addProvider(new MyProvider());\n+        try {\n+            new MultipleChooseAlias().run();\n+        } catch (Exception e) {\n+            \/\/ expected\n+        }\n+        if (numOfCalls != 1) {\n+            throw new RuntimeException(\"Too many times \" + numOfCalls);\n+        }\n+    }\n+\n+    static class MyProvider extends Provider {\n+        public MyProvider() {\n+            super(\"Mine\", \"1\", \"many many things\");\n+            put(\"KeyManagerFactory.Mine\", \"MultipleChooseAlias$MyKMF\");\n+        }\n+    }\n+\n+    \/\/ This KeyManagerFactory impl returns key managers\n+    \/\/ wrapped in MyKM\n+    public static class MyKMF extends KeyManagerFactorySpi {\n+        KeyManagerFactory fac;\n+\n+        public MyKMF() {\n+            try {\n+                fac = KeyManagerFactory.getInstance(kmfAlgorithm);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        @Override\n+        protected void engineInit(KeyStore ks, char[] password)\n+                throws KeyStoreException, NoSuchAlgorithmException,\n+                UnrecoverableKeyException {\n+            fac.init(ks, password);\n+        }\n+\n+        @Override\n+        protected void engineInit(ManagerFactoryParameters spec)\n+                throws InvalidAlgorithmParameterException {\n+            fac.init(spec);\n+        }\n+\n+        @Override\n+        protected KeyManager[] engineGetKeyManagers() {\n+            KeyManager[] result = fac.getKeyManagers();\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MyKM((X509KeyManager)result[i]);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    \/\/ This KeyManager remembers how many times  chooseClientAlias is called.\n+    static class MyKM implements X509KeyManager {\n+\n+        X509KeyManager km;\n+\n+        MyKM(X509KeyManager km) {\n+            this.km = km;\n+        }\n+\n+        public String[] getClientAliases(String keyType, Principal[] issuers) {\n+            return km.getClientAliases(keyType, issuers);\n+        }\n+\n+        public String chooseClientAlias(String[] keyType, Principal[] issuers,\n+                Socket socket) {\n+            System.out.println(\"chooseClientAlias called on \"\n+                    + Arrays.toString(keyType));\n+            numOfCalls++;\n+            return null; \/\/ so it will try all key types and finally fails\n+        }\n+\n+        public String[] getServerAliases(String keyType, Principal[] issuers) {\n+            return getServerAliases(keyType, issuers);\n+        }\n+\n+        public String chooseServerAlias(String keyType, Principal[] issuers,\n+                Socket socket) {\n+            return km.chooseServerAlias(keyType, issuers, socket);\n+        }\n+\n+        public X509Certificate[] getCertificateChain(String alias) {\n+            return km.getCertificateChain(alias);\n+        }\n+\n+        public PrivateKey getPrivateKey(String alias) {\n+            return km.getPrivateKey(alias);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLContextImpl\/MultipleChooseAlias.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}