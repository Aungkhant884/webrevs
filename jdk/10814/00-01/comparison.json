{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -43,0 +45,17 @@\n+\n+    \/**\n+     * Two possible variants of instanceof expressions:\n+     * <ul>\n+     * <li> testing types, and\n+     * <li> performing pattern matching\n+     * <\/ul>\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public enum TestKind {\n+        \/** instanceof only testing a type *\/\n+        TYPE,\n+        \/** instanceof doing a pattern matching *\/\n+        PATTERN\n+    }\n+\n@@ -76,0 +95,9 @@\n+\n+    \/**\n+     * Returns the type of this instanceof expression.\n+     *\n+     * @return the type of this instanceof expression\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    TestKind getTestKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/InstanceOfTree.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -511,2 +511,5 @@\n-        List<Type> formals = vars;\n-        for (Type t : todo) {\n+        replaceTypeVarsInBounds(todo.toList(), inferenceContext);\n+    }\n+\n+    private void replaceTypeVarsInBounds(List<Type> vars, InferenceContext inferenceContext) {\n+        for (Type t : vars) {\n@@ -520,1 +523,0 @@\n-            formals = formals.tail;\n@@ -677,11 +679,3 @@\n-        \/\/step 2:\n-        Set<Symbol> patternTypeSuperTypes = new HashSet<>();\n-        types.closure(patternTypeSymbol.type).stream().map(s -> s.tsym).forEach(patternTypeSuperTypes::add);\n-        Set<Symbol> expressionTypeSuperTypes = new HashSet<>();\n-        types.closure(expressionType).stream().map(s -> s.tsym).forEach(expressionTypeSuperTypes::add);\n-        patternTypeSuperTypes.retainAll(expressionTypeSuperTypes);\n-\n-        for (Symbol common : patternTypeSuperTypes) {\n-            Type fromPatternType = types.asSuper(patternType, common);\n-            Type fromExprType = types.asSuper(exprType, common);\n-            if (!types.isSameType(fromPatternType, fromExprType) && !fromExprType.isRaw()) {\n+        try {\n+            \/\/step 2:\n+            if (commonSuperWithDiffParameterization(patternType, exprType)) {\n@@ -690,1 +684,0 @@\n-        }\n@@ -692,1 +685,1 @@\n-        List<Type> varsToSolve = params.map(s -> c.asUndetVar(s));\n+            List<Type> varsToSolve = params.map(s -> c.asUndetVar(s));\n@@ -694,1 +687,0 @@\n-        try {\n@@ -700,0 +692,8 @@\n+\n+            \/\/step 3:\n+            List<Type> freshVars = instantiatePatternVars(params, c);\n+\n+            Type substituted = c.asInstType(patternTypeSymbol.type);\n+\n+            \/\/step 4:\n+            return types.upward(substituted, freshVars);\n@@ -703,0 +703,1 @@\n+    }\n@@ -704,1 +705,1 @@\n-        \/\/step 3:\n+    private List<Type> instantiatePatternVars(List<Type> vars, InferenceContext c) {\n@@ -706,0 +707,1 @@\n+        ListBuffer<Type> todo = new ListBuffer<>();\n@@ -707,2 +709,3 @@\n-        for (Type param : patternType.allparams()) {\n-            UndetVar undet = (UndetVar) param;\n+        \/\/step 1 - create fresh tvars\n+        for (Type t : vars) {\n+            UndetVar undet = (UndetVar) c.asUndetVar(t);\n@@ -714,1 +717,10 @@\n-                Type bound = upperBounds.isEmpty() ? syms.objectType : types.glb(upperBounds);\n+                Type bound;\n+                boolean recursive = Type.containsAny(upperBounds, vars);\n+                if (recursive) {\n+                    bound = types.makeIntersectionType(upperBounds);\n+                    todo.append(undet);\n+                } else if (upperBounds.nonEmpty()) {\n+                    bound = types.glb(upperBounds);\n+                } else {\n+                    bound = syms.objectType;\n+                }\n@@ -725,1 +737,2 @@\n-        Type substituted = c.asInstType(patternTypeSymbol.type);\n+        \/\/step 2 - replace fresh tvars in their bounds\n+        replaceTypeVarsInBounds(todo.toList(), c);\n@@ -727,2 +740,1 @@\n-        \/\/step 4:\n-        return types.upward(substituted, freshVars.toList());\n+        return freshVars.toList();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2230,0 +2230,4 @@\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public TestKind getTestKind() {\n+            return pattern instanceof JCPatternCaseLabel ? TestKind.PATTERN : TestKind.TYPE;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.List;\n@@ -51,0 +50,1 @@\n+import com.sun.tools.javac.util.List;\n@@ -55,0 +55,1 @@\n+import javax.tools.JavaCompiler;\n@@ -61,1 +62,1 @@\n-    JavacTaskImpl task;\n+    Context context;\n@@ -70,1 +71,2 @@\n-        task = (JavacTaskImpl) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, List.of(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, null, null, List.of(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n@@ -83,1 +85,1 @@\n-                       class Test<T1 extends CharSequence&Runnable> {\n+                       class Test<T1 extends CharSequence&Runnable, T2 extends Number> {\n@@ -85,0 +87,4 @@\n+                       interface RecursiveTest1Interface<IB extends RecursiveTest1Interface<IB>> { }\n+                       interface RecursiveTest1Use<BB extends RecursiveTest1Use<BB>> extends RecursiveTest1Interface<BB> { }\n+                       interface RecursiveTest2Interface<X> { }\n+                       interface RecursiveTest2Use<X extends RecursiveTest2Use<X, Y>, Y> extends RecursiveTest2Interface<Y> { }\n@@ -89,22 +95,23 @@\n-        infer = Infer.instance(task.getContext());\n-        types = Types.instance(task.getContext());\n-\n-        checkAsSub(\"A<String>\", \"B\", \"B<java.lang.String>\");\n-        checkAsSub(\"A<String>\", \"C\", \"C<java.lang.String,?>\");\n-        checkAsSub(\"A<String>\", \"D\", \"D<?,java.lang.String>\");\n-        checkAsSub(\"A<String>\", \"E\", \"E<java.lang.String>\");\n-        checkAsSub(\"A<String>\", \"F\", null);\n-        checkAsSub(\"A<String>\", \"G\", null); \/\/ doesn't check bounds\n-        checkAsSub(\"A<String>\", \"H\", \"H\");\n-        checkAsSub(\"A<String>\", \"I\", \"I<?>\");\n-\n-        checkAsSub(\"A<B<String>>\", \"B\", \"B<B<java.lang.String>>\");\n-        checkAsSub(\"A<B<String>>\", \"C\", \"C<B<java.lang.String>,?>\");\n-        checkAsSub(\"A<B<String>>\", \"F\", \"F<java.lang.String>\");\n-        checkAsSub(\"A<B<String>>\", \"H\", null);\n-        checkAsSub(\"A<B<String>>\", \"I\", null);\n-\n-        checkAsSub(\"C<String, String>\", \"E\", \"E<java.lang.String>\");\n-        checkAsSub(\"C<String, Integer>\", \"E\", null);\n-        checkAsSub(\"C<A<?>, A<?>>\", \"E\", \"E<A<?>>\");\n-        checkAsSub(\"C<A<? extends Object>, A<?>>\", \"E\", \"E<A<? extends java.lang.Object>>\");\n+        context = task.getContext();\n+        infer = Infer.instance(context);\n+        types = Types.instance(context);\n+\n+        checkInferedType(\"A<String>\", \"B\", \"B<java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"C\", \"C<java.lang.String,?>\");\n+        checkInferedType(\"A<String>\", \"D\", \"D<?,java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"E\", \"E<java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"F\", null);\n+        checkInferedType(\"A<String>\", \"G\", null); \/\/ doesn't check bounds\n+        checkInferedType(\"A<String>\", \"H\", \"H\");\n+        checkInferedType(\"A<String>\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"A<B<String>>\", \"B\", \"B<B<java.lang.String>>\");\n+        checkInferedType(\"A<B<String>>\", \"C\", \"C<B<java.lang.String>,?>\");\n+        checkInferedType(\"A<B<String>>\", \"F\", \"F<java.lang.String>\");\n+        checkInferedType(\"A<B<String>>\", \"H\", null);\n+        checkInferedType(\"A<B<String>>\", \"I\", null);\n+\n+        checkInferedType(\"C<String, String>\", \"E\", \"E<java.lang.String>\");\n+        checkInferedType(\"C<String, Integer>\", \"E\", null);\n+        checkInferedType(\"C<A<?>, A<?>>\", \"E\", \"E<A<?>>\");\n+        checkInferedType(\"C<A<? extends Object>, A<?>>\", \"E\", \"E<A<? extends java.lang.Object>>\");\n@@ -113,7 +120,7 @@\n-        checkAsSub(\"A\", \"B\", \"B\");\n-        checkAsSub(\"A\", \"C\", \"C\");\n-        checkAsSub(\"A\", \"D\", \"D\");\n-        checkAsSub(\"A\", \"E\", \"E\");\n-        checkAsSub(\"A\", \"F\", \"F\");\n-        checkAsSub(\"A\", \"G\", \"G\");\n-        checkAsSub(\"A\", \"H\", \"H\");\n+        checkInferedType(\"A\", \"B\", \"B\");\n+        checkInferedType(\"A\", \"C\", \"C\");\n+        checkInferedType(\"A\", \"D\", \"D\");\n+        checkInferedType(\"A\", \"E\", \"E\");\n+        checkInferedType(\"A\", \"F\", \"F\");\n+        checkInferedType(\"A\", \"G\", \"G\");\n+        checkInferedType(\"A\", \"H\", \"H\");\n@@ -122,40 +129,42 @@\n-        checkAsSub(\"A\", \"I\", \"I<?>\"); \/\/ always erases if input is raw\n-\n-        checkAsSub(\"A<?>\", \"B\", \"B<?>\");\n-        checkAsSub(\"A<?>\", \"C\", \"C<?,?>\");\n-        checkAsSub(\"A<?>\", \"D\", \"D<?,?>\");\n-        checkAsSub(\"A<?>\", \"E\", \"E<?>\");\n-        checkAsSub(\"A<?>\", \"F\", \"F<?>\");\n-        checkAsSub(\"A<?>\", \"G\", \"G<?>\");\n-        checkAsSub(\"A<?>\", \"H\", \"H\");\n-        checkAsSub(\"A<?>\", \"I\", \"I<?>\");\n-\n-        checkAsSub(\"A<? extends Runnable>\", \"B\", \"B<? extends java.lang.Runnable>\");\n-        checkAsSub(\"A<? extends Runnable>\", \"C\", \"C<? extends java.lang.Runnable,?>\");\n-        checkAsSub(\"A<? extends Runnable>\", \"D\", \"D<?,? extends java.lang.Runnable>\");\n-        checkAsSub(\"A<? extends Runnable>\", \"E\", \"E<? extends java.lang.Runnable>\");\n-        checkAsSub(\"A<? extends Runnable>\", \"F\", null);\n-        checkAsSub(\"A<? extends Runnable>\", \"G\", \"G<? extends java.lang.Number&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n-        checkAsSub(\"A<? extends Runnable>\", \"H\", null);\n-        checkAsSub(\"A<? extends Runnable>\", \"I\", null);\n-\n-        checkAsSub(\"A<? extends B<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n-        checkAsSub(\"A<? extends A<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n-\n-        checkAsSub(\"C<? extends Number, Integer>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n-        checkAsSub(\"C<Integer, ? extends Number>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n-        checkAsSub(\"C<?, ? extends Number>\", \"E\", \"E<? extends java.lang.Number>\");\n-        checkAsSub(\"C<? extends Number, ?>\", \"E\", \"E<? extends java.lang.Number>\");\n-\n-        checkAsSub(\"C<? extends Number, ? extends Integer>\", \"E\", \"E<? extends java.lang.Integer>\");\n-        checkAsSub(\"C<? extends Integer, ? extends Number>\", \"E\", \"E<? extends java.lang.Integer>\");\n-        checkAsSub(\"C<? extends Runnable, ? extends Cloneable>\", \"E\", \"E<? extends java.lang.Object&java.lang.Cloneable&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n-        checkAsSub(\"C<? extends Number, ? super Integer>\", \"E\", \"E<? extends java.lang.Number>\"); \/\/ doesn't know how to mix lower\/upper\n-        checkAsSub(\"C<? super Integer, ? super Number>\", \"E\", \"E<? super java.lang.Number>\");\n-        checkAsSub(\"C<? super B<String>, ? super C<String,String>>\", \"E\", \"E<? super A<java.lang.String>>\"); \/\/ doesn't do lub\n-\n-        checkAsSub(\"H\", \"I\", \"I<?>\");\n-\n-        checkAsSub(\"B<String>\", \"C\", \"C<java.lang.String,?>\"); \/\/ no sideways casts\n-\n-        checkAsSub(\"A<T1>\", \"B\", \"B<T1>\");\n+        checkInferedType(\"A\", \"I\", \"I<?>\"); \/\/ always erases if input is raw\n+\n+        checkInferedType(\"A<?>\", \"B\", \"B<?>\");\n+        checkInferedType(\"A<?>\", \"C\", \"C<?,?>\");\n+        checkInferedType(\"A<?>\", \"D\", \"D<?,?>\");\n+        checkInferedType(\"A<?>\", \"E\", \"E<?>\");\n+        checkInferedType(\"A<?>\", \"F\", \"F<?>\");\n+        checkInferedType(\"A<?>\", \"G\", \"G<?>\");\n+        checkInferedType(\"A<?>\", \"H\", \"H\");\n+        checkInferedType(\"A<?>\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"A<? extends Runnable>\", \"B\", \"B<? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"C\", \"C<? extends java.lang.Runnable,?>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"D\", \"D<?,? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"E\", \"E<? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"F\", null);\n+        checkInferedType(\"A<? extends Runnable>\", \"G\", \"G<? extends java.lang.Number&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n+        checkInferedType(\"A<? extends Runnable>\", \"H\", null);\n+        checkInferedType(\"A<? extends Runnable>\", \"I\", null);\n+\n+        checkInferedType(\"A<? extends B<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n+        checkInferedType(\"A<? extends A<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n+\n+        checkInferedType(\"C<? extends Number, Integer>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n+        checkInferedType(\"C<Integer, ? extends Number>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n+        checkInferedType(\"C<?, ? extends Number>\", \"E\", \"E<? extends java.lang.Number>\");\n+        checkInferedType(\"C<? extends Number, ?>\", \"E\", \"E<? extends java.lang.Number>\");\n+\n+        checkInferedType(\"C<? extends Number, ? extends Integer>\", \"E\", \"E<? extends java.lang.Integer>\");\n+        checkInferedType(\"C<? extends Integer, ? extends Number>\", \"E\", \"E<? extends java.lang.Integer>\");\n+        checkInferedType(\"C<? extends Runnable, ? extends Cloneable>\", \"E\", \"E<? extends java.lang.Object&java.lang.Cloneable&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n+        checkInferedType(\"C<? extends Number, ? super Integer>\", \"E\", \"E<? extends java.lang.Number>\"); \/\/ doesn't know how to mix lower\/upper\n+        checkInferedType(\"C<? super Integer, ? super Number>\", \"E\", \"E<? super java.lang.Number>\");\n+        checkInferedType(\"C<? super B<String>, ? super C<String,String>>\", \"E\", \"E<? super A<java.lang.String>>\"); \/\/ doesn't do lub\n+\n+        checkInferedType(\"H\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"B<String>\", \"C\", \"C<java.lang.String,?>\"); \/\/ no sideways casts\n+\n+        checkInferedType(\"A<T1>\", \"B\", \"B<T1>\");\n+        checkInferedType(\"RecursiveTest1Interface<?>\", \"RecursiveTest1Use\", \"RecursiveTest1Use<? extends java.lang.Object&RecursiveTest1Use<?>&RecursiveTest1Interface<? extends RecursiveTest1Use<?>>>\");\n+        checkInferedType(\"RecursiveTest2Interface<?>\", \"RecursiveTest2Use\", \"RecursiveTest2Use<? extends RecursiveTest2Use<?,?>,?>\");\n@@ -164,1 +173,1 @@\n-    private void checkAsSub(String base, String test, String expected) {\n+    private void checkInferedType(String base, String test, String expected) {\n@@ -174,1 +183,0 @@\n-        Context context = task.getContext();\n","filename":"test\/langtools\/tools\/javac\/patterns\/InferenceUnitTest.java","additions":83,"deletions":75,"binary":false,"changes":158,"status":"modified"}]}