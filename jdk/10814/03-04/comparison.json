{"files":[{"patch":"@@ -658,0 +658,10 @@\n+    \/**\n+     * Infer record type for pattern matching. Given an expression type\n+     * (@code expressionType}), and a given record ({@code patternTypeSymbol}),\n+     * a parameterized type of {@code patternTypeSymbol} is inferred\n+     * according to JLS 18.5.5.\n+     *\n+     * @param expressionType\n+     * @param patternTypeSymbol\n+     * @return\n+     *\/\n@@ -663,1 +673,1 @@\n-        Type expressionTypeCaptured = types.capture(expressionType);\n+        List<Type> expressionTypes = List.nil();\n@@ -666,5 +676,24 @@\n-        \/\/add synthetic captured ivars\n-        for (Type ta : expressionTypeCaptured.getTypeArguments()) {\n-            if (ta.hasTag(TYPEVAR) && ((TypeVar)ta).isCaptured()) {\n-                params = params.prepend((TypeVar)ta);\n-                capturedWildcards = capturedWildcards.prepend(ta);\n+        List<Type> todo = List.of(expressionType);\n+        while (todo.nonEmpty()) {\n+            Type current = todo.head;\n+            todo = todo.tail;\n+            switch (current.getTag()) {\n+                case CLASS -> {\n+                    if (current.isCompound()) {\n+                        todo = todo.prependList(types.directSupertypes(current));\n+                    } else {\n+                        Type captured = types.capture(current);\n+\n+                        for (Type ta : captured.getTypeArguments()) {\n+                            if (ta.hasTag(TYPEVAR) && ((TypeVar) ta).isCaptured()) {\n+                                params = params.prepend((TypeVar) ta);\n+                                capturedWildcards = capturedWildcards.prepend(ta);\n+                            }\n+                        }\n+                        expressionTypes = expressionTypes.prepend(captured);\n+                    }\n+                }\n+                case TYPEVAR -> {\n+                    todo = todo.prepend(((TypeVar) current).getUpperBound());\n+                }\n+                default -> expressionTypes = expressionTypes.prepend(current);\n@@ -673,0 +702,1 @@\n+        \/\/add synthetic captured ivars\n@@ -675,1 +705,1 @@\n-        Type exprType = c.asUndetVar(expressionTypeCaptured);\n+        List<Type> exprTypes = expressionTypes.map(t -> c.asUndetVar(t));\n@@ -681,6 +711,8 @@\n-            if (exprType.isParameterized()) {\n-                Type patternAsExpression =\n-                        types.asSuper(patternType, exprType.tsym);\n-                if (patternAsExpression == null ||\n-                    !types.isSameType(patternAsExpression, exprType)) {\n-                    return null;\n+            for (Type exprType : exprTypes) {\n+                if (exprType.isParameterized()) {\n+                    Type patternAsExpression =\n+                            types.asSuper(patternType, exprType.tsym);\n+                    if (patternAsExpression == null ||\n+                        !types.isSameType(patternAsExpression, exprType)) {\n+                        return null;\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -734,1 +734,1 @@\n-            result = make.at(tree.pos).Ident(bindingVar);\n+            result = make.at(tree.pos).Ident(bindingVar).setType(bindingVar.erasure(types));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+        runTest(this::runSwitchInference4);\n@@ -88,0 +89,10 @@\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    <Z extends I<String>> int runSwitchInference4(Z b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    <B extends CharSequence & Runnable, Z extends I<B>> int runSwitchInference5(Z b) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}