{"files":[{"patch":"@@ -51,6 +51,0 @@\n-    \/**\n-     * Returns the binding variable.\n-     * @return the binding variable\n-     *\/\n-    VariableTree getVariable();\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -43,0 +45,17 @@\n+\n+    \/**\n+     * Two possible variants of instanceof expressions:\n+     * <ul>\n+     * <li> testing types, and\n+     * <li> performing pattern matching\n+     * <\/ul>\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public enum TestKind {\n+        \/** instanceof only testing a type *\/\n+        TYPE,\n+        \/** instanceof doing a pattern matching *\/\n+        PATTERN\n+    }\n+\n@@ -76,0 +95,9 @@\n+\n+    \/**\n+     * Returns the kind of this instanceof expression.\n+     *\n+     * @return the kind of this instanceof expression\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    TestKind getTestKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/InstanceOfTree.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -842,1 +842,0 @@\n-        r = scanAndReduce(node.getVariable(), p, r);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2045,0 +2045,5 @@\n+        public void setNormal() {\n+            Assert.check(this.kind == Kind.CAPTURED);\n+            this.kind = Kind.NORMAL;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1668,1 +1668,2 @@\n-                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL));\n+                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL) ||\n+                                                    TreeInfo.isNullCaseLabel(l));\n@@ -1680,1 +1681,0 @@\n-            MatchBindings prevBindings = null;\n@@ -1690,1 +1690,1 @@\n-                MatchBindings currentBindings = prevBindings;\n+                MatchBindings currentBindings = null;\n@@ -1754,1 +1754,1 @@\n-                        attribExpr(pat, switchEnv);\n+                        attribExpr(pat, switchEnv, seltype);\n@@ -1808,3 +1808,0 @@\n-\n-                prevBindings = c.caseKind == CaseTree.CaseKind.STATEMENT && c.completesNormally ? currentBindings\n-                                                                                                : null;\n@@ -4081,1 +4078,1 @@\n-            attribTree(tree.pattern, env, unknownExprInfo);\n+            attribExpr(tree.pattern, env, exprtype);\n@@ -4145,2 +4142,1 @@\n-            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n-            type = attribTree(tree.var.vartype, env, varInfo);\n+            type = attribType(tree.var.vartype, env);\n@@ -4169,1 +4165,10 @@\n-        tree.type = attribType(tree.deconstructor, env);\n+        Type type = attribType(tree.deconstructor, env);\n+        if (type.isRaw() && type.tsym.getTypeParameters().nonEmpty()) {\n+            Type inferred = infer.instantiatePatternType(resultInfo.pt, type.tsym);\n+            if (inferred == null) {\n+                log.error(tree.pos(), Errors.PatternTypeCannotInfer);\n+            } else {\n+                type = inferred;\n+            }\n+        }\n+        tree.type = tree.deconstructor.type = type;\n@@ -4174,3 +4179,0 @@\n-            if (record.type.getTypeArguments().nonEmpty() && tree.type.isRaw()) {\n-                log.error(tree.pos(),Errors.RawDeconstructionPattern);\n-            }\n@@ -4193,4 +4195,1 @@\n-                boolean nestedIsVarPattern = false;\n-                nestedIsVarPattern |= nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n-                                      ((JCBindingPattern) nestedPatterns.head).var.vartype == null;\n-                attribExpr(nestedPatterns.head, localEnv, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+                attribExpr(nestedPatterns.head, localEnv, recordTypes.head);\n@@ -4214,15 +4213,0 @@\n-            if (tree.var != null) {\n-                BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.type,\n-                                                    localEnv.info.scope.owner);\n-                v.pos = tree.pos;\n-                tree.var.sym = v;\n-                if (chk.checkUnique(tree.var.pos(), v, localEnv.info.scope)) {\n-                    chk.checkTransparentVar(tree.var.pos(), v, localEnv.info.scope);\n-                }\n-                if (tree.var.vartype != null) {\n-                    annotate.annotateLater(tree.var.mods.annotations, localEnv, v, tree.pos());\n-                    annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, localEnv, v, tree.var.pos());\n-                    annotate.flush();\n-                }\n-                outBindings.add(v);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4349,9 +4349,0 @@\n-        boolean wasConstant = false;          \/\/ Seen a constant in the same case label\n-        boolean wasDefault = false;           \/\/ Seen a default in the same case label\n-        boolean wasNullPattern = false;       \/\/ Seen a null pattern in the same case label,\n-                                              \/\/or fall through from a null pattern\n-        boolean wasPattern = false;           \/\/ Seen a pattern in the same case label\n-                                              \/\/or fall through from a pattern\n-        boolean wasTypePattern = false;       \/\/ Seen a pattern in the same case label\n-                                              \/\/or fall through from a type pattern\n-        boolean wasNonEmptyFallThrough = false;\n@@ -4360,11 +4351,9 @@\n-            for (JCCaseLabel label : c.labels) {\n-                if (label.hasTag(CONSTANTCASELABEL)) {\n-                    JCExpression expr = ((JCConstantCaseLabel) label).expr;\n-                    if (TreeInfo.isNull(expr)) {\n-                        if (wasPattern && !wasTypePattern && !wasNonEmptyFallThrough) {\n-                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n-                        }\n-                        wasNullPattern = true;\n-                    } else {\n-                        if (wasPattern && !wasNonEmptyFallThrough) {\n-                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n+            if (c.labels.head instanceof JCConstantCaseLabel constLabel) {\n+                if (TreeInfo.isNull(constLabel.expr)) {\n+                    if (c.labels.tail.nonEmpty()) {\n+                        if (c.labels.tail.head instanceof JCDefaultCaseLabel defLabel) {\n+                            if (c.labels.tail.tail.nonEmpty()) {\n+                                log.error(c.labels.tail.tail.head.pos(), Errors.InvalidCaseLabelCombination);\n+                            }\n+                        } else {\n+                            log.error(c.labels.tail.head.pos(), Errors.InvalidCaseLabelCombination);\n@@ -4372,5 +4361,0 @@\n-                        wasConstant = true;\n-                    }\n-                } else if (label.hasTag(DEFAULTCASELABEL)) {\n-                    if (wasPattern && !wasNonEmptyFallThrough) {\n-                        log.error(label.pos(), Errors.FlowsThroughFromPattern);\n@@ -4378,1 +4362,0 @@\n-                    wasDefault = true;\n@@ -4380,8 +4363,5 @@\n-                    JCPattern pat = ((JCPatternCaseLabel) label).pat;\n-                    while (pat instanceof JCParenthesizedPattern parenthesized) {\n-                        pat = parenthesized.pattern;\n-                    }\n-                    boolean isTypePattern = pat.hasTag(BINDINGPATTERN);\n-                    if (wasPattern || wasConstant || wasDefault ||\n-                        (wasNullPattern && (!isTypePattern || wasNonEmptyFallThrough))) {\n-                        log.error(label.pos(), Errors.FlowsThroughToPattern);\n+                    for (JCCaseLabel label : c.labels.tail) {\n+                        if (!(label instanceof JCConstantCaseLabel) || TreeInfo.isNullCaseLabel(label)) {\n+                            log.error(label.pos(), Errors.InvalidCaseLabelCombination);\n+                            break;\n+                        }\n@@ -4389,2 +4369,0 @@\n-                    wasPattern = true;\n-                    wasTypePattern = isTypePattern;\n@@ -4392,0 +4370,26 @@\n+            } else {\n+                if (c.labels.tail.nonEmpty()) {\n+                    log.error(c.labels.tail.head.pos(), Errors.FlowsThroughFromPattern);\n+                }\n+            }\n+        }\n+\n+        boolean isCaseStatementGroup = cases.nonEmpty() &&\n+                                       cases.head.caseKind == CaseTree.CaseKind.STATEMENT;\n+\n+        if (isCaseStatementGroup) {\n+            boolean previousCompletessNormally = false;\n+            for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+                JCCase c = l.head;\n+                if (previousCompletessNormally &&\n+                    c.stats.nonEmpty() &&\n+                    c.labels.head instanceof JCPatternCaseLabel patternLabel &&\n+                    hasBindings(patternLabel.pat)) {\n+                    log.error(c.labels.head.pos(), Errors.FlowsThroughToPattern);\n+                } else if (c.stats.isEmpty() &&\n+                           c.labels.head instanceof JCPatternCaseLabel patternLabel &&\n+                           hasBindings(patternLabel.pat) &&\n+                           hasStatements(l.tail)) {\n+                    log.error(c.labels.head.pos(), Errors.FlowsThroughFromPattern);\n+                }\n+                previousCompletessNormally = c.completesNormally;\n@@ -4393,0 +4397,2 @@\n+        }\n+    }\n@@ -4394,2 +4400,2 @@\n-            boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? c.completesNormally\n-                                                                                  : false;\n+    boolean hasBindings(JCPattern p) {\n+        boolean[] bindings = new boolean[1];\n@@ -4397,6 +4403,5 @@\n-            if (c.stats.nonEmpty()) {\n-                wasConstant = false;\n-                wasDefault = false;\n-                wasNullPattern &= completesNormally;\n-                wasPattern &= completesNormally;\n-                wasTypePattern &= completesNormally;\n+        new TreeScanner() {\n+            @Override\n+            public void visitBindingPattern(JCBindingPattern tree) {\n+                bindings[0] = true;\n+                super.visitBindingPattern(tree);\n@@ -4404,0 +4409,1 @@\n+        }.scan(p);\n@@ -4405,2 +4411,1 @@\n-            wasNonEmptyFallThrough = c.stats.nonEmpty() && completesNormally;\n-        }\n+        return bindings[0];\n@@ -4409,0 +4414,9 @@\n+    boolean hasStatements(List<JCCase> cases) {\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            if (l.head.stats.nonEmpty()) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n@@ -4411,0 +4425,3 @@\n+        boolean seenDefault = false;\n+        boolean seenDefaultLabel = false;\n+        boolean warnDominatedByDefault = false;\n@@ -4414,1 +4431,4 @@\n-                if (label.hasTag(DEFAULTCASELABEL) || TreeInfo.isNullCaseLabel(label)) {\n+                if (label.hasTag(DEFAULTCASELABEL)) {\n+                    seenDefault = true;\n+                    seenDefaultLabel |=\n+                            TreeInfo.isNullCaseLabel(c.labels.head);\n@@ -4417,0 +4437,13 @@\n+                if (TreeInfo.isNullCaseLabel(label)) {\n+                    if (seenDefault) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                    }\n+                    continue;\n+                }\n+                if (seenDefault && !warnDominatedByDefault) {\n+                    if (label.hasTag(PATTERNCASELABEL) ||\n+                        (label instanceof JCConstantCaseLabel && seenDefaultLabel)) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                        warnDominatedByDefault = true;\n+                    }\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":80,"deletions":47,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import com.sun.tools.javac.code.Types.UniqueType;\n@@ -691,1 +692,1 @@\n-                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -726,1 +727,1 @@\n-            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -738,1 +739,1 @@\n-                                                   JCExpression selector, List<JCCase> cases) {\n+                                                   List<JCCase> cases) {\n@@ -746,1 +747,1 @@\n-            return coveredSymbols(pos, selector.type, labelValues);\n+            return coveredSymbols(pos, labelValues);\n@@ -749,1 +750,1 @@\n-        private Set<Symbol> coveredSymbols(DiagnosticPosition pos, Type targetType,\n+        private Set<Symbol> coveredSymbols(DiagnosticPosition pos,\n@@ -752,1 +753,1 @@\n-            Map<Symbol, List<JCRecordPattern>> deconstructionPatternsBySymbol = new HashMap<>();\n+            Map<UniqueType, List<JCRecordPattern>> deconstructionPatternsByType = new HashMap<>();\n@@ -764,1 +765,1 @@\n-                        Symbol type = dpat.record;\n+                        UniqueType type = new UniqueType(dpat.type, types);\n@@ -766,1 +767,1 @@\n-                                deconstructionPatternsBySymbol.getOrDefault(type, List.nil())\n+                                deconstructionPatternsByType.getOrDefault(type, List.nil())\n@@ -769,1 +770,1 @@\n-                        deconstructionPatternsBySymbol.put(type, augmentedPatterns);\n+                        deconstructionPatternsByType.put(type, augmentedPatterns);\n@@ -780,3 +781,3 @@\n-            for (Entry<Symbol, List<JCRecordPattern>> e : deconstructionPatternsBySymbol.entrySet()) {\n-                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), 0)) {\n-                    coveredSymbols.add(e.getKey());\n+            for (Entry<UniqueType, List<JCRecordPattern>> e : deconstructionPatternsByType.entrySet()) {\n+                if (coversDeconstructionFromComponent(pos, e.getKey().type, e.getValue(), 0)) {\n+                    coveredSymbols.add(e.getKey().type.tsym);\n@@ -789,1 +790,1 @@\n-                                                          Type targetType,\n+                                                          Type recordType,\n@@ -812,1 +813,1 @@\n-            Type instantiatedComponentType = types.memberType(targetType, components.get(component));\n+            Type instantiatedComponentType = types.memberType(recordType, components.get(component));\n@@ -814,1 +815,1 @@\n-            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos, instantiatedComponentType,\n+            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos,\n@@ -854,1 +855,1 @@\n-                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), component + 1)) {\n+                if (coversDeconstructionFromComponent(pos, recordType, e.getValue(), component + 1)) {\n@@ -935,1 +936,1 @@\n-                    yield covered.contains(seltype.tsym);\n+                    yield covered.contains(types.erasure(seltype).tsym);\n@@ -2983,8 +2984,0 @@\n-        @Override\n-        public void visitRecordPattern(JCRecordPattern tree) {\n-            super.visitRecordPattern(tree);\n-            if (tree.var != null) {\n-                initParam(tree.var);\n-            }\n-        }\n-\n@@ -3165,1 +3158,0 @@\n-            scan(tree.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import java.util.Comparator;\n@@ -510,2 +511,5 @@\n-        List<Type> formals = vars;\n-        for (Type t : todo) {\n+        replaceTypeVarsInBounds(todo.toList(), inferenceContext);\n+    }\n+\n+    private void replaceTypeVarsInBounds(List<Type> vars, InferenceContext inferenceContext) {\n+        for (Type t : vars) {\n@@ -519,1 +523,0 @@\n-            formals = formals.tail;\n@@ -654,0 +657,116 @@\n+\n+    \/**\n+     * Infer record type for pattern matching. Given an expression type\n+     * (@code expressionType}), and a given record ({@code patternTypeSymbol}),\n+     * a parameterized type of {@code patternTypeSymbol} is inferred\n+     * according to JLS 18.5.5.\n+     *\n+     * @param expressionType\n+     * @param patternTypeSymbol\n+     * @return\n+     *\/\n+    public Type instantiatePatternType(Type expressionType, TypeSymbol patternTypeSymbol) {\n+        if (expressionType.tsym == patternTypeSymbol)\n+            return expressionType;\n+\n+        \/\/step 1:\n+        List<Type> expressionTypes = List.nil();\n+        List<Type> params = patternTypeSymbol.type.allparams();\n+        List<Type> capturedWildcards = List.nil();\n+        List<Type> todo = List.of(expressionType);\n+        while (todo.nonEmpty()) {\n+            Type current = todo.head;\n+            todo = todo.tail;\n+            switch (current.getTag()) {\n+                case CLASS -> {\n+                    if (current.isCompound()) {\n+                        todo = todo.prependList(types.directSupertypes(current));\n+                    } else {\n+                        Type captured = types.capture(current);\n+\n+                        for (Type ta : captured.getTypeArguments()) {\n+                            if (ta.hasTag(TYPEVAR) && ((TypeVar) ta).isCaptured()) {\n+                                params = params.prepend((TypeVar) ta);\n+                                capturedWildcards = capturedWildcards.prepend(ta);\n+                            }\n+                        }\n+                        expressionTypes = expressionTypes.prepend(captured);\n+                    }\n+                }\n+                case TYPEVAR -> {\n+                    todo = todo.prepend(types.skipTypeVars(current, false));\n+                }\n+                default -> expressionTypes = expressionTypes.prepend(current);\n+            }\n+        }\n+        \/\/add synthetic captured ivars\n+        InferenceContext c = new InferenceContext(this, params);\n+        Type patternType = c.asUndetVar(patternTypeSymbol.type);\n+        List<Type> exprTypes = expressionTypes.map(t -> c.asUndetVar(t));\n+\n+        capturedWildcards.forEach(s -> ((UndetVar) c.asUndetVar(s)).setNormal());\n+\n+        try {\n+            \/\/step 2:\n+            for (Type exprType : exprTypes) {\n+                if (exprType.isParameterized()) {\n+                    Type patternAsExpression =\n+                            types.asSuper(patternType, exprType.tsym);\n+                    if (patternAsExpression == null ||\n+                        !types.isSameType(patternAsExpression, exprType)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            doIncorporation(c, types.noWarnings);\n+\n+            \/\/step 3:\n+            List<Type> freshVars = instantiatePatternVars(params, c);\n+\n+            Type substituted = c.asInstType(patternTypeSymbol.type);\n+\n+            \/\/step 4:\n+            return types.upward(substituted, freshVars);\n+        } catch (Infer.InferenceException ex) {\n+            return null;\n+        }\n+    }\n+\n+    private List<Type> instantiatePatternVars(List<Type> vars, InferenceContext c) {\n+        ListBuffer<Type> freshVars = new ListBuffer<>();\n+        ListBuffer<Type> todo = new ListBuffer<>();\n+\n+        \/\/step 1 - create fresh tvars\n+        for (Type t : vars) {\n+            UndetVar undet = (UndetVar) c.asUndetVar(t);\n+            List<Type> bounds = InferenceStep.EQ.filterBounds(undet, c);\n+            if (bounds.nonEmpty()) {\n+                undet.setInst(bounds.head);\n+            } else {\n+                List<Type> upperBounds = undet.getBounds(InferenceBound.UPPER);\n+                Type upper;\n+                boolean recursive = Type.containsAny(upperBounds, vars);\n+                if (recursive) {\n+                    upper = types.makeIntersectionType(upperBounds);\n+                    todo.append(undet);\n+                } else if (upperBounds.nonEmpty()) {\n+                    upper = types.glb(upperBounds);\n+                } else {\n+                    upper = syms.objectType;\n+                }\n+                List<Type> lowerBounds = undet.getBounds(InferenceBound.LOWER);\n+                Type lower = lowerBounds.isEmpty() ? syms.botType\n+                                                   : lowerBounds.tail.isEmpty() ? lowerBounds.head\n+                                                                                : types.lub(lowerBounds);\n+                TypeVar vt = new TypeVar(syms.noSymbol, upper, lower);\n+                freshVars.add(vt);\n+                undet.setInst(vt);\n+            }\n+        }\n+\n+        \/\/step 2 - replace fresh tvars in their bounds\n+        replaceTypeVarsInBounds(todo.toList(), c);\n+\n+        return freshVars.toList();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":122,"deletions":3,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -326,17 +326,0 @@\n-        if (tree.var != null) {\n-            BindingSymbol binding = (BindingSymbol) tree.var.sym;\n-            Type castTargetType = principalType(tree);\n-            VarSymbol bindingVar = bindingContext.bindingDeclared(binding);\n-\n-            JCAssign fakeInit =\n-                    (JCAssign) make.at(TreeInfo.getStartPos(tree))\n-                                   .Assign(make.Ident(bindingVar),\n-                                           convert(make.Ident(currentValue), castTargetType))\n-                                   .setType(bindingVar.erasure(types));\n-            LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n-                                            make.Literal(true));\n-            nestedLE.needsCond = true;\n-            nestedLE.setType(syms.booleanType);\n-            test = test != null ? makeBinary(Tag.AND, test, nestedLE) : nestedLE;\n-        }\n-\n@@ -444,9 +427,0 @@\n-            ListBuffer<JCCase> newCases = new ListBuffer<>();\n-            for (List<JCCase> c = cases; c.nonEmpty(); c = c.tail) {\n-                if (c.head.stats.isEmpty() && c.tail.nonEmpty()) {\n-                    c.tail.head.labels = c.tail.head.labels.prependList(c.head.labels);\n-                } else {\n-                    newCases.add(c.head);\n-                }\n-            }\n-            cases = newCases.toList();\n@@ -760,1 +734,1 @@\n-            result = make.at(tree.pos).Ident(bindingVar);\n+            result = make.at(tree.pos).Ident(bindingVar).setType(bindingVar.erasure(types));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n@@ -799,12 +800,1 @@\n-                JCVariableDecl var;\n-                if (token.kind == IDENTIFIER) {\n-                    if (!checkGuard || token.name() != names.when) {\n-                        var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), e, null));\n-                        nextToken();\n-                    } else {\n-                        var = null;\n-                    }\n-                } else {\n-                    var = null;\n-                }\n-                pattern = toP(F.at(pos).RecordPattern(e, nested.toList(), var));\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n@@ -1539,0 +1529,1 @@\n+            boolean allowDefault = false;\n@@ -1540,1 +1531,1 @@\n-                JCCaseLabel label = parseCaseLabel();\n+                JCCaseLabel label = parseCaseLabel(allowDefault);\n@@ -1545,0 +1536,1 @@\n+                allowDefault = TreeInfo.isNullCaseLabel(label);\n@@ -3037,0 +3029,1 @@\n+            boolean allowDefault = false;\n@@ -3038,1 +3031,2 @@\n-                pats.append(parseCaseLabel());\n+                JCCaseLabel label = parseCaseLabel(allowDefault);\n+                pats.append(label);\n@@ -3042,0 +3036,1 @@\n+                allowDefault = TreeInfo.isNullCaseLabel(label);\n@@ -3094,1 +3089,1 @@\n-    private JCCaseLabel parseCaseLabel() {\n+    private JCCaseLabel parseCaseLabel(boolean allowDefault) {\n@@ -3100,0 +3095,4 @@\n+            if (!allowDefault) {\n+                reportSyntaxError(new SimpleDiagnosticPosition(token.pos),\n+                                  Errors.DefaultLabelNotAllowed);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -528,0 +528,9 @@\n+compiler.err.invalid.case.label.combination=\\\n+    invalid case label combination\n+\n+compiler.err.default.label.not.allowed=\\\n+    default label not allowed here\n+\n+compiler.err.pattern.type.cannot.infer=\\\n+    cannot infer pattern type\n+\n@@ -3913,3 +3922,0 @@\n-compiler.err.raw.deconstruction.pattern=\\\n-    raw deconstruction patterns are not allowed\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2230,0 +2230,4 @@\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public TestKind getTestKind() {\n+            return pattern instanceof JCPatternCaseLabel ? TestKind.PATTERN : TestKind.TYPE;\n+        }\n@@ -2431,1 +2435,0 @@\n-        public JCVariableDecl var;\n@@ -2435,2 +2438,1 @@\n-        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                  JCVariableDecl var) {\n+        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested) {\n@@ -2439,1 +2441,0 @@\n-            this.var = var;\n@@ -2478,5 +2479,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public VariableTree getVariable() {\n-            return var;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -948,4 +948,0 @@\n-            if (tree.var != null) {\n-                print(\" \");\n-                print(tree.var.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -533,2 +533,1 @@\n-        JCVariableDecl var = copy(t.var, p);\n-        return M.at(t.pos).RecordPattern(deconstructor, nested, var);\n+        return M.at(t.pos).RecordPattern(deconstructor, nested);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -515,3 +515,2 @@\n-    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                         JCVariableDecl var) {\n-        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested, var);\n+    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -334,3 +334,0 @@\n-        if (that.var != null) {\n-            scan(that.var);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.default.label.not.allowed\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DefaultLabelNotAllowed {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultLabelNotAllowed.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+\/\/ key: compiler.misc.feature.case.null\n+\/\/ key: compiler.warn.preview.feature.use\n@@ -32,1 +34,1 @@\n-            case String str:\n+            case null:\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughToPattern.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.invalid.case.label.combination\n+\/\/ key: compiler.misc.feature.case.null\n+\/\/ key: compiler.warn.preview.feature.use\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class InvalidCaseLabelCombination {\n+    private void doSwitch(Integer i) {\n+        switch (i) {\n+            case null, 1: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidCaseLabelCombination.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.pattern.type.cannot.infer\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PatternTypeCannotInfer {\n+    interface A<T> {}\n+    record R<T extends Number>() implements A<T> {}\n+    void test(A<String> i) {\n+        if (i instanceof R()) {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternTypeCannotInfer.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.raw.deconstruction.pattern\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n-\n-class RawDeconstructionPattern {\n-    boolean test(Object o) {\n-        return o instanceof R(String s);\n-    }\n-\n-    record R<T>(T t) {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RawDeconstructionPattern.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8262891\n- * @summary Check null handling for non-pattern switches.\n- * @compile\/fail\/ref=CaseDefault.out --release 16 -XDrawDiagnostics CaseDefault.java\n- * @compile --enable-preview -source ${jdk.version} CaseDefault.java\n- * @run main\/othervm --enable-preview CaseDefault\n- *\/\n-\n-public class CaseDefault {\n-\n-    public static void main(String[] args) {\n-        new CaseDefault().run();\n-    }\n-\n-    void run() {\n-        String str = \"other\";\n-        switch (str) {\n-            case \"a\": throw new AssertionError(\"Wrong branch.\");\n-            case default: break; \/\/OK\n-        }\n-        switch (str) {\n-            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n-            case default -> {} \/\/OK\n-        }\n-        int i;\n-        i = switch (str) {\n-            case \"a\": throw new AssertionError(\"Wrong branch.\");\n-            case default: yield 0; \/\/OK\n-        };\n-        i = switch (str) {\n-            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n-            case default -> 0; \/\/OK\n-        };\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CaseDefault.java:20:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -98,1 +98,0 @@\n-            long typePatternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n@@ -108,0 +107,3 @@\n+            if (defaultCases > 0) {\n+                shouldPass &= asCaseLabelElements && nullCases > 0;\n+            }\n@@ -114,2 +116,7 @@\n-            if (nullCases > 0 && patternCases > 0) {\n-                shouldPass &= patternCases == typePatternCases;\n+            if (nullCases > 0) {\n+                shouldPass &= patternCases == 0 && (constantCases == 0 || !asCaseLabelElements);\n+                if (defaultCases > 0 && asCaseLabelElements) {\n+                    int nullIndex = Arrays.asList(caseLabels).indexOf(CaseLabel.NULL);\n+                    int defaultIndex = Arrays.asList(caseLabels).indexOf(CaseLabel.DEFAULT);\n+                    shouldPass &= nullIndex < defaultIndex;\n+                }\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-        if (p instanceof P2(var v, var v) v); \/\/duplicated variables\n-        if (p instanceof P6(P2(var v1, var v2) v1, P2(var v1, var v2) v2) v1); \/\/duplicated variables\n+        if (p instanceof P2(var v, var v)); \/\/duplicated variables\n+        if (p instanceof P6(P2(var v1, var v2), P2(var v1, var v2))); \/\/duplicated variables\n@@ -47,0 +47,1 @@\n+        boolean b = p instanceof P(int i) p; \/\/introducing a variable for the record pattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+DeconstructionPatternErrors.java:47:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:47:43: compiler.err.not.stmt\n@@ -21,6 +23,2 @@\n-DeconstructionPatternErrors.java:29:43: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:48: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:59: compiler.err.already.defined: kindname.variable, v1, kindname.method, main(java.lang.String...)\n-DeconstructionPatternErrors.java:30:67: compiler.err.already.defined: kindname.variable, v2, kindname.method, main(java.lang.String...)\n-DeconstructionPatternErrors.java:30:71: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:75: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, main(java.lang.String...)\n+DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, main(java.lang.String...)\n@@ -31,2 +29,1 @@\n-DeconstructionPatternErrors.java:39:27: compiler.err.raw.deconstruction.pattern\n-DeconstructionPatternErrors.java:41:18: compiler.err.raw.deconstruction.pattern\n+DeconstructionPatternErrors.java:44:9: compiler.err.not.exhaustive.statement\n@@ -35,1 +32,1 @@\n-32 errors\n+29 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1173,0 +1173,23 @@\n+    @Test\n+    public void testInferenceExhaustive(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface Opt<T> {}\n+                   record Some<T>(T t) implements Opt<T> {}\n+                   final class None<T> implements Opt<T> {}\n+\n+                   void test(Opt<String> optValue) {\n+                       switch (optValue) {\n+                           case Some<String>(String s) ->\n+                               System.out.printf(\"got string: %s%n\", s);\n+                           case None<String> none ->\n+                               System.out.println(\"got none\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,0 +42,5 @@\n+        runTest(this::runSwitchInference1);\n+        runTest(this::runSwitchInference2);\n+        runTest(this::runSwitchInference3);\n+        runTest(this::runSwitchInference4);\n+        testInference3();\n@@ -68,1 +73,43 @@\n-    record Box<V>(V v) {\n+    int runSwitchInference1(I<String> b) {\n+        switch (b) {\n+            case Box(String s): return s == null ? 1 : s.length();\n+            default: return -1;\n+        }\n+    }\n+\n+    int runSwitchInference2(I<String> b) {\n+        switch (b) {\n+            case Box(var s): return s == null ? 1 : s.length();\n+            default: return -1;\n+        }\n+    }\n+\n+    int runSwitchInference3(I<String> b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    <Z extends I<String>> int runSwitchInference4(Z b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    <B extends CharSequence & Runnable, Z extends I<B>> int runSwitchInference5(Z b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    void testInference3() {\n+        I<I<String>> b = new Box<>(new Box<>(null));\n+        assertEquals(1, runSwitchInferenceNested(b));\n+    }\n+\n+    int runSwitchInferenceNested(I<I<String>> b) {\n+        switch (b) {\n+            case Box(Box(var s)): return s == null ? 1 : s.length();\n+            default: return -1;\n+        }\n+    }\n+\n+    sealed interface I<T> {}\n+    record Box<V>(V v) implements I<V> {\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-        testGuardNPE();\n@@ -165,28 +164,0 @@\n-    void testGuardNPE() {\n-        doTestGuardNPE(this::guardNPE1);\n-        doTestGuardNPE(this::guardNPE2);\n-    }\n-\n-    void doTestGuardNPE(Function<Object, String> test) {\n-        assertEquals(\"empty\", test.apply(\"\"));\n-        assertEquals(\"A\", test.apply(\"A\"));\n-        assertEquals(\"other\", test.apply(1));\n-        assertEquals(\"empty\", test.apply(null));\n-    }\n-\n-    String guardNPE1(Object o) {\n-        return switch (o) {\n-            case null, String s when s.isEmpty() -> \"empty\";\n-            case String s -> s;\n-            case Object x -> \"other\";\n-        };\n-    }\n-\n-    String guardNPE2(Object o) {\n-        return switch (o) {\n-            case null, ((((String s)))) when s.isEmpty() -> \"empty\";\n-            case ((((String s)))) -> s;\n-            case Object x -> \"other\";\n-        };\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify Infer.instantiatePatternType provides correct results\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.model\n+ *          jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @run main InferenceUnitTest\n+ *\/\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.TypeSymbol;\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.Attr;\n+import com.sun.tools.javac.comp.Infer;\n+import com.sun.tools.javac.model.JavacElements;\n+import com.sun.tools.javac.parser.ParserFactory;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.List;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Objects;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class InferenceUnitTest {\n+\n+    Context context;\n+    Infer infer;\n+    Types types;\n+\n+    public static void main(String... args) throws Exception {\n+        new InferenceUnitTest().runAll();\n+    }\n+\n+    void runAll() throws URISyntaxException {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, null, null, List.of(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return \"\"\"\n+                       interface A<T> {}\n+                       interface B<T> extends A<T> {}\n+                       interface C<X,Y> extends A<X> {}\n+                       interface D<X,Y> extends A<Y> {}\n+                       interface E<T> extends C<T,T> {}\n+                       interface F<T> extends A<B<T>> {}\n+                       interface G<T extends Number> extends A<T> {}\n+                       interface H extends A<String> {}\n+                       interface I<T> extends H {}\n+                       class Test<T1 extends CharSequence&Runnable, T2 extends Number> {\n+                       }\n+                       interface RecursiveTest1Interface<IB extends RecursiveTest1Interface<IB>> { }\n+                       interface RecursiveTest1Use<BB extends RecursiveTest1Use<BB>> extends RecursiveTest1Interface<BB> { }\n+                       interface RecursiveTest2Interface<X> { }\n+                       interface RecursiveTest2Use<X extends RecursiveTest2Use<X, Y>, Y> extends RecursiveTest2Interface<Y> { }\n+                       \"\"\";\n+            }\n+        }));\n+        task.enter();\n+        context = task.getContext();\n+        infer = Infer.instance(context);\n+        types = Types.instance(context);\n+\n+        checkInferedType(\"A<String>\", \"B\", \"B<java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"C\", \"C<java.lang.String,?>\");\n+        checkInferedType(\"A<String>\", \"D\", \"D<?,java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"E\", \"E<java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"F\", null);\n+        checkInferedType(\"A<String>\", \"G\", null); \/\/ doesn't check bounds\n+        checkInferedType(\"A<String>\", \"H\", \"H\");\n+        checkInferedType(\"A<String>\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"A<B<String>>\", \"B\", \"B<B<java.lang.String>>\");\n+        checkInferedType(\"A<B<String>>\", \"C\", \"C<B<java.lang.String>,?>\");\n+        checkInferedType(\"A<B<String>>\", \"F\", \"F<java.lang.String>\");\n+        checkInferedType(\"A<B<String>>\", \"H\", null);\n+        checkInferedType(\"A<B<String>>\", \"I\", null);\n+\n+        checkInferedType(\"C<String, String>\", \"E\", \"E<java.lang.String>\");\n+        checkInferedType(\"C<String, Integer>\", \"E\", null);\n+        checkInferedType(\"C<A<?>, A<?>>\", \"E\", \"E<A<?>>\");\n+        checkInferedType(\"C<A<? extends Object>, A<?>>\", \"E\", \"E<A<? extends java.lang.Object>>\");\n+\n+        if (false) {\n+        checkInferedType(\"A\", \"B\", \"B\");\n+        checkInferedType(\"A\", \"C\", \"C\");\n+        checkInferedType(\"A\", \"D\", \"D\");\n+        checkInferedType(\"A\", \"E\", \"E\");\n+        checkInferedType(\"A\", \"F\", \"F\");\n+        checkInferedType(\"A\", \"G\", \"G\");\n+        checkInferedType(\"A\", \"H\", \"H\");\n+        }\n+\n+        checkInferedType(\"A\", \"I\", \"I<?>\"); \/\/ always erases if input is raw\n+\n+        checkInferedType(\"A<?>\", \"B\", \"B<?>\");\n+        checkInferedType(\"A<?>\", \"C\", \"C<?,?>\");\n+        checkInferedType(\"A<?>\", \"D\", \"D<?,?>\");\n+        checkInferedType(\"A<?>\", \"E\", \"E<?>\");\n+        checkInferedType(\"A<?>\", \"F\", \"F<?>\");\n+        checkInferedType(\"A<?>\", \"G\", \"G<?>\");\n+        checkInferedType(\"A<?>\", \"H\", \"H\");\n+        checkInferedType(\"A<?>\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"A<? extends Runnable>\", \"B\", \"B<? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"C\", \"C<? extends java.lang.Runnable,?>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"D\", \"D<?,? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"E\", \"E<? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"F\", null);\n+        checkInferedType(\"A<? extends Runnable>\", \"G\", \"G<? extends java.lang.Number&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n+        checkInferedType(\"A<? extends Runnable>\", \"H\", null);\n+        checkInferedType(\"A<? extends Runnable>\", \"I\", null);\n+\n+        checkInferedType(\"A<? extends B<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n+        checkInferedType(\"A<? extends A<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n+\n+        checkInferedType(\"C<? extends Number, Integer>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n+        checkInferedType(\"C<Integer, ? extends Number>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n+        checkInferedType(\"C<?, ? extends Number>\", \"E\", \"E<? extends java.lang.Number>\");\n+        checkInferedType(\"C<? extends Number, ?>\", \"E\", \"E<? extends java.lang.Number>\");\n+\n+        checkInferedType(\"C<? extends Number, ? extends Integer>\", \"E\", \"E<? extends java.lang.Integer>\");\n+        checkInferedType(\"C<? extends Integer, ? extends Number>\", \"E\", \"E<? extends java.lang.Integer>\");\n+        checkInferedType(\"C<? extends Runnable, ? extends Cloneable>\", \"E\", \"E<? extends java.lang.Object&java.lang.Cloneable&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n+        checkInferedType(\"C<? extends Number, ? super Integer>\", \"E\", \"E<? extends java.lang.Number>\"); \/\/ doesn't know how to mix lower\/upper\n+        checkInferedType(\"C<? super Integer, ? super Number>\", \"E\", \"E<? super java.lang.Number>\");\n+        checkInferedType(\"C<? super B<String>, ? super C<String,String>>\", \"E\", \"E<? super A<java.lang.String>>\"); \/\/ doesn't do lub\n+\n+        checkInferedType(\"H\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"B<String>\", \"C\", null); \/\/ no sideways casts\n+\n+        checkInferedType(\"A<T1>\", \"B\", \"B<T1>\");\n+        checkInferedType(\"RecursiveTest1Interface<?>\", \"RecursiveTest1Use\", \"RecursiveTest1Use<? extends java.lang.Object&RecursiveTest1Use<?>&RecursiveTest1Interface<? extends RecursiveTest1Use<?>>>\");\n+        checkInferedType(\"RecursiveTest2Interface<?>\", \"RecursiveTest2Use\", \"RecursiveTest2Use<? extends RecursiveTest2Use<?,?>,?>\");\n+    }\n+\n+    private void checkInferedType(String base, String test, String expected) {\n+        Type baseType = parseType(base);\n+        TypeSymbol testType = parseType(test).tsym;\n+        Type actualType = infer.instantiatePatternType(baseType, testType);\n+        String actualTypeString = actualType != null ? actualType.toString() : null;\n+        if (!Objects.equals(expected, actualTypeString)) {\n+            error(\"Unexpected type, expected: \" + expected + \", got: \" + actualTypeString);\n+        }\n+    }\n+    Type parseType(String spec) {\n+        ParserFactory fact = ParserFactory.instance(context);\n+        JCExpression specTypeTree = fact.newParser(spec, false, false, false).parseType();\n+        Attr attr = Attr.instance(context);\n+        JavacElements elementUtils = JavacElements.instance(context);\n+        ClassSymbol testClass = elementUtils.getTypeElement(\"Test\");\n+        return attr.attribType(specTypeTree, testClass);\n+    }\n+\n+    \/** assert that 's' is the same type as 't' *\/\n+    public void assertSameType(Type s, Type t) {\n+        assertSameType(s, t, true);\n+    }\n+\n+    \/** assert that 's' is\/is not the same type as 't' *\/\n+    public void assertSameType(Type s, Type t, boolean expected) {\n+        if (types.isSameType(s, t) != expected) {\n+            String msg = expected ?\n+                \" is not the same type as \" :\n+                \" is the same type as \";\n+            error(s + msg + t);\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        throw new AssertionError(\"Unexpected result: \" + msg);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/InferenceUnitTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294942\n+ * @summary Check compilation outcomes for various combinations of case label element.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @compile NewCaseStructureTest.java\n+ * @run main NewCaseStructureTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class NewCaseStructureTest extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new NewCaseStructureTest().runTests();\n+    }\n+\n+    NewCaseStructureTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testCorrectMultiLabelCaseStructure(Path base) throws Exception {\n+        for (String pattern : new String[] {\"String s\",\n+                                            \"(String s)\",\n+                                            \"R(int i)\",\n+                                            \"(R(int i))\",\n+                                            \"null, default\",\n+                                            \"null\",\n+                                            \"1\",\n+                                            \"1, 2\",\n+                                            \"1, 2, 3\"}) {\n+            for (String sep : new String[] {\":\", \"->\"}) {\n+                doTest(base,\n+                       \"\"\"\n+                       package test;\n+                       public class Test {\n+                           private int test(${switchType} obj) {\n+                               return switch (obj) {\n+                                   case ${pattern} ${sep} { yield 0; }\n+                                   ${default}\n+                               };\n+                           }\n+                       }\n+                       record R(int i) {}\n+                       \"\"\".replace(\"${switchType}\", pattern.contains(\"1\") ? \"Integer\" : \"Object\")\n+                          .replace(\"${pattern}\", pattern)\n+                          .replace(\"${sep}\", sep)\n+                          .replace(\"${default}\", pattern.contains(\"default\") ? \"\" : \"default \" + sep + \" { yield 1; }\"),\n+                       false);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMalformedCaseStructure(Path base) throws Exception {\n+        for (String pattern : new String[] {\"String s, Integer i\",\n+                                            \"String s, R(int i)\",\n+                                            \"E1(), E2()\",\n+                                            \"String s, null\",\n+                                            \"String s, default\",\n+                                            \"String s, null, default\",\n+                                            \"null, String s\",\n+                                            \"null, default, String s\",\n+                                            \"default, String s\",\n+                                            \"1, Integer i\",\n+                                            \"1, 2, 3, Integer i\",\n+                                            \"Integer i, 1, 2, 3\",\n+                                            \"1, null\",\n+                                            \"1, 2, 3, null\",\n+                                            \"null, 1, 2, 3\",\n+                                            \"default, null\",\n+                                            \"default\"}) {\n+            for (String sep : new String[] {\":\", \"->\"}) {\n+                doTest(base,\n+                       \"\"\"\n+                       package test;\n+                       public class Test {\n+                           private int test(${switchType} obj) {\n+                               return switch (obj) {\n+                                   case ${pattern} ${sep} { yield 0; }\n+                                   ${default}\n+                               };\n+                           }\n+                       }\n+                       record R(int i) {}\n+                       record E1() {}\n+                       record E2() {}\n+                       \"\"\".replace(\"${switchType}\", pattern.contains(\"1\") ? \"Integer\" : \"Object\")\n+                          .replace(\"${pattern}\", pattern)\n+                          .replace(\"${sep}\", sep)\n+                          .replace(\"${default}\", pattern.contains(\"default\") ? \"\" : \"default \" + sep + \" { yield 1; }\"),\n+                       true);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSwitchLabeledStatementGroups(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case null:\n+                           case Object obj: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.flows.through.to.pattern\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case null: System.err.println();\n+                           case Object obj: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.flows.through.to.pattern\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case Object obj:\n+                           case null: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:18: compiler.err.flows.through.from.pattern\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case Object obj: System.err.println();\n+                           case null: System.err.println();\n+                                      yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case String s: System.err.println();\n+                           case E1(): System.err.println(); yield 0;\n+                           default: yield 0;\n+                       };\n+                   }\n+               }\n+               record E1() {}\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case String s: System.err.println();\n+                           default: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case String s:\n+                           case Integer i:\n+                           case Object obj:\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case Object obj: System.err.println();\n+                           case null: System.err.println(obj);\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:43: compiler.err.cant.resolve.location: kindname.variable, obj, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+               \"1 error\");\n+\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case default -> 0;\n+                           case 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:18: compiler.err.default.label.not.allowed\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testDominance(Path base) throws Exception {\n+        \/\/A case label with a case pattern p (guarded or unguarded) dominates another case label with a case constant c if p dominates c, which is defined as follows:\n+        \/\/ A type pattern that declares a pattern variable of type T dominates a constant c of a primitive type P if the wrapper class of P ([5.1.7]) is a subtype of the erasure of T.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case Integer i when i > 0 -> 0;\n+                           case 0 -> 0;\n+                           case Integer i -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ A type pattern that declares a pattern variable of type T dominates an enum constant c of type E if E is a subtype of the erasure of the type of T.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(E o) {\n+                       return switch (o) {\n+                           case E e when e == E.A -> 0;\n+                           case B -> 0;\n+                           case E e -> 0;\n+                       };\n+                   }\n+               }\n+               enum E {A, B;}\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/dtto for String:\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(String o) {\n+                       return switch (o) {\n+                           case String s when s.isEmpty() -> 0;\n+                           case \"a\" -> 0;\n+                           case String s -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ A parenthesized pattern dominates a constant c if its contained pattern dominates c.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case (Integer i) when i > 0 -> 0;\n+                           case 0 -> 0;\n+                           case Integer i -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ A default label dominates a case label with a case pattern, and it also dominates a case label with a null case constant.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           default -> 0;\n+                           case (Integer i) when i > 0 -> 0;\n+                           case (Integer i) when i > 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case (Integer i) when i > 0 -> 0;\n+                           default -> 0;\n+                           case null -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:7:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ case label with a default dominates all other switch labels.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case null, default -> 0;\n+                           case (Integer i) when i > 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case null, default -> 0;\n+                           case 0 -> 0;\n+                           case 1 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           default -> 0;\n+                           case 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String testCode, boolean expectErrors) throws IOException {\n+        doTest(base, testCode, expectErrors, (String[]) null);\n+    }\n+\n+    private void doTest(Path base, String testCode, String... output) throws IOException {\n+        doTest(base, testCode, output != null && output.length > 0, output);\n+    }\n+\n+    private void doTest(Path base, String testCode, boolean expectErrors, String... output) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actual = new JavacTask(tb)\n+            .options(\"--enable-preview\",\n+                     \"-source\", JAVA_VERSION,\n+                     \"-XDrawDiagnostics\",\n+                     \"-Xlint:-preview\",\n+                     \"-XDshould-stop.at=FLOW\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(expectErrors? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (output != null) {\n+            actual.remove(\"- compiler.note.preview.filename: Test.java, DEFAULT\");\n+            actual.remove(\"- compiler.note.preview.recompile\");\n+            actual.remove(\"\");\n+\n+            List<String> expected = List.of(output);\n+\n+            if (!Objects.equals(expected, actual)) {\n+                throw new AssertionError(\"Unexpected output: \" + actual);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NewCaseStructureTest.java","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-        assertEquals(0, matchingSwitch4(\"\"));\n-        assertEquals(1, matchingSwitch4(null));\n-        assertEquals(1, matchingSwitch4(0.0));\n@@ -95,1 +92,2 @@\n-            case null, Integer i -> i == null ? -1 : 100 + i;\n+            case Integer i -> 100 + i;\n+            case null -> -1;\n@@ -110,1 +108,2 @@\n-            case Integer i, null -> i == null ? -1 : 100 + i;\n+            case Integer i -> 100 + i;\n+            case null -> -1;\n@@ -115,7 +114,0 @@\n-    private int matchingSwitch4(Object obj) {\n-        return switch (obj) {\n-            case String s -> 0;\n-            case default, null -> 1;\n-        };\n-    }\n-\n@@ -125,2 +117,2 @@\n-            case null:\n-            case Integer i: yield i == null ? -1 : 100 + i;\n+            case null: yield -1;\n+            case Integer i: yield 100 + i;\n@@ -134,1 +126,1 @@\n-            case null:\n+            case null: yield 1;\n@@ -142,2 +134,2 @@\n-            case Integer i:\n-            case null: yield i == null ? -1 : 100 + i;\n+            case Integer i: yield 100 + i;\n+            case null: yield -1;\n@@ -151,2 +143,2 @@\n-            default:\n-            case null: yield 1;\n+            case null:\n+            default: yield 1;\n@@ -159,1 +151,2 @@\n-            case null, Object o: yield 1;\n+            case null: yield 1;\n+            case Object o: yield 1;\n@@ -166,1 +159,2 @@\n-            case null, Object o: return 1;\n+            case null: return 1;\n+            case Object o: return 1;\n@@ -217,1 +211,0 @@\n-                default: return 1;\n@@ -219,0 +212,1 @@\n+                default: return 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-                      \"         b = o instanceof R(String s) r;\\n\" +\n@@ -74,1 +73,0 @@\n-                                  b = o instanceof R(String s) r;\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,3 +94,0 @@\n-        if (!testD(new P4(\"test\"))) {\n-            throw new IllegalStateException();\n-        }\n@@ -174,4 +171,0 @@\n-    private static boolean testD(Object o) throws Throwable {\n-        return o instanceof P4(String s) p && (s.isEmpty() || \"test\".equals(p.o()));\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SimpleDeconstructionPattern.java:121:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n+SimpleDeconstructionPattern.java:118:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,0 +280,23 @@\n+    void noDiamond(Object o) {\n+        record R<T>(T t) {}\n+        switch (o) {\n+            case R<> r -> {}\n+            default -> {}\n+        }\n+        if (o instanceof R<> r) {}\n+    }\n+    void noRawInferenceNonDeconstruction() {\n+        record R<T>(T t) {}\n+        R<String> o = null;\n+        switch (o) {\n+            case R r -> System.out.println(r.t().length());\n+        }\n+        if (o instanceof R r) System.out.println(r.t().length());\n+    }\n+    void cannotInfer() {\n+        interface A<T> {}\n+        record R<T extends Number>() implements A<T> {}\n+        A<String> i = null;\n+        if (i instanceof R()) {\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+SwitchErrors.java:66:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:72:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:72:27: compiler.err.default.label.not.allowed\n+SwitchErrors.java:138:28: compiler.err.default.label.not.allowed\n+SwitchErrors.java:144:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:149:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:154:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:213:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:220:47: compiler.err.default.label.not.allowed\n+SwitchErrors.java:227:47: compiler.err.default.label.not.allowed\n+SwitchErrors.java:283:20: compiler.err.illegal.start.of.type\n+SwitchErrors.java:286:28: compiler.err.illegal.start.of.type\n@@ -14,1 +26,0 @@\n-SwitchErrors.java:72:27: compiler.err.duplicate.default.label\n@@ -17,1 +28,2 @@\n-SwitchErrors.java:88:28: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:88:28: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:93:18: compiler.err.flows.through.from.pattern\n@@ -25,3 +37,2 @@\n-SwitchErrors.java:138:28: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:144:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:149:27: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:149:27: compiler.err.flows.through.from.pattern\n@@ -32,1 +43,1 @@\n-SwitchErrors.java:186:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:186:21: compiler.err.invalid.case.label.combination\n@@ -34,3 +45,2 @@\n-SwitchErrors.java:213:29: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:220:21: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:220:47: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:204:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:220:21: compiler.err.invalid.case.label.combination\n@@ -38,1 +48,0 @@\n-SwitchErrors.java:227:47: compiler.err.flows.through.from.pattern\n@@ -42,2 +51,7 @@\n-SwitchErrors.java:262:24: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:276:37: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:255:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:262:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:269:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:276:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:292:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:294:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:300:26: compiler.err.pattern.type.cannot.infer\n@@ -58,1 +72,1 @@\n-55 errors\n+69 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-        runDefaultTest(this::testDefaultDoesNotDominateStatement);\n-        runDefaultTest(this::testDefaultDoesNotDominateExpression);\n@@ -101,0 +99,3 @@\n+        emptyFallThrough(1);\n+        emptyFallThrough(\"\");\n+        emptyFallThrough(1.0);\n@@ -229,16 +230,0 @@\n-    String testDefaultDoesNotDominateStatement(Object o) {\n-        String res;\n-        switch (o) {\n-            default -> res = \"default\";\n-            case String str -> res = \"str\" + str.length();\n-        }\n-        return res;\n-    }\n-\n-    String testDefaultDoesNotDominateExpression(Object o) {\n-        return switch (o) {\n-            case default -> \"default\";\n-            case String str -> \"str\" + str.length();\n-        };\n-    }\n-\n@@ -265,1 +250,2 @@\n-            case null, E x -> String.valueOf(x);\n+            case E x -> String.valueOf(x);\n+            case null -> \"null\";\n@@ -273,1 +259,2 @@\n-            case E x, null -> String.valueOf(x);\n+            case E x -> String.valueOf(x);\n+            case null -> \"null\";\n@@ -283,1 +270,2 @@\n-            case null, E x: return String.valueOf(x);\n+            case E x: return String.valueOf(x);\n+            case null: return \"null\";\n@@ -293,1 +281,2 @@\n-            case null, E x -> String.valueOf(x);\n+            case E x -> String.valueOf(x);\n+            case null -> \"null\";\n@@ -302,1 +291,2 @@\n-            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -311,1 +301,2 @@\n-            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -320,1 +311,2 @@\n-            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -329,1 +321,2 @@\n-            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -338,1 +331,2 @@\n-            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -347,1 +341,2 @@\n-            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -356,1 +351,2 @@\n-            case null, String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n+            case String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -365,1 +361,2 @@\n-            case null, String x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case String x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -374,1 +371,2 @@\n-            case null, Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -383,1 +381,2 @@\n-            case null, Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -465,4 +464,2 @@\n-            case null, Object obj:; \/\/no break intentionally - should not fall through to any possible default\n-        }\n-        switch (o) {\n-            case Object obj, null:; \/\/no break intentionally - should not fall through to any possible default\n+            case Object obj: int i;\n+            case null:; \/\/no break intentionally - should not fall through to any possible default\n@@ -475,1 +472,2 @@\n-            case null, B b:; \/\/no break intentionally - should not fall through to any possible default\n+            case B b:; \/\/no break intentionally - should not fall through to any possible default\n+            case null:;\n@@ -479,1 +477,2 @@\n-            case null, B b -> {}\n+            case B b -> {}\n+            case null -> {}\n@@ -627,1 +626,1 @@\n-            case R(Integer i) r -> {return r.o().toString();}\n+            case R(Integer i) -> {return i.toString();}\n@@ -635,1 +634,1 @@\n-            case R(Integer i) r -> r.o().toString();\n+            case R(Integer i) -> i.toString();\n@@ -643,1 +642,2 @@\n-            case Integer i: case null: { yield \"OK\";}\n+            case null: { yield \"OK\";}\n+            case Integer i: { yield \"OK\";}\n@@ -654,0 +654,8 @@\n+    void emptyFallThrough(Object o) {\n+        switch (o) {\n+            case Integer i:\n+            case String s:\n+            case Object obj:\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-            default: return 1;\n@@ -102,0 +101,1 @@\n+            default: return 1;\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNull.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}